ypeNone;

    swprintf(OpenPath,L"\\device\\floppy%u",FloppyOrdinal);

    INIT_OBJA(&ObjectAttributes,&UnicodeString,OpenPath);

    Status = ZwCreateFile(
                &Handle,
                SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,                           // allocation size
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_VALID_FLAGS,         // full sharing
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,                           // no EAs
                0
                );

    if(NT_SUCCESS(Status)) {

        //
        // Get supported media types.
        //
        Status = ZwDeviceIoControlFile(
                    Handle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    IOCTL_DISK_GET_MEDIA_TYPES,
                    NULL,
                    0,
                    DiskGeom,
                    sizeof(DiskGeom)
                    );

        if(NT_SUCCESS(Status)) {

            ASSERT((IoStatusBlock.Information % sizeof(DISK_GEOMETRY)) == 0);
            if(MediaTypeCount = IoStatusBlock.Information / sizeof(DISK_GEOMETRY)) {

                //
                // Highest capacity media type is last entry.
                //
                switch(DiskGeom[MediaTypeCount-1].MediaType) {

                case F5_1Pt23_1024: //NEC98
                    if (!IsNEC_98) {
                        break;
                    }
                    // trough down to set FloppyType525High on NEC98

                case F5_1Pt2_512:

                    FloppyType = FloppyType525High;
                    break;

                case F3_1Pt23_1024: //NEC98
                    if (!IsNEC_98) {
                        break;
                    }
                    // trough down to set FloppyType35High on NEC98

                case F3_1Pt44_512:
                case F3_2Pt88_512:
                case F3_20Pt8_512:

                    FloppyType = FloppyType35High;
                    break;

                case F3_720_512:

                    FloppyType = FloppyType35Low;
                    break;

                case F5_360_512:
                case F5_320_512:
                case F5_320_1024:
                case F5_180_512:
                case F5_160_512:

                    FloppyType = FloppyType525Low;
                    break;

                case F3_120M_512:
                    FloppyType = FloppyType35High120MB;
                    break;
                }

            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: no media types for %ws!\n",OpenPath));
            }

        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to get media types for %ws (%lx)\n",OpenPath,Status));
        }

        ZwClose(Handle);

    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: %ws does not exist (%lx)\n",OpenPath,Status));
    }

    //
    // Save the value.
    //
    if(FloppyOrdinal < ELEMENT_COUNT(CachedTypes)) {
        CachedTypes[FloppyOrdinal] = FloppyType;
    }

    return(FloppyType);
}

VOID
SpConfirmScsiMiniports(
    IN PVOID SifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice
    )
{
    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_PLEASE_WAIT,DEFAULT_STATUS_ATTRIBUTE);

    //
    // Start with scsi.
    //
    SpDetectScsi(SifHandle,SourceDevicePath,DirectoryOnSourceDevice);
    SpConfirmScsiInteract(SifHandle,SourceDevicePath,DirectoryOnSourceDevice);
}


VOID
SpConfirmHardware(
    IN PVOID SifHandle
    )
{
    ULONG i;
    BOOLEAN AllConfirmed,FirstPass,NeedConfirm;
    PWSTR p;

    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_PLEASE_WAIT,DEFAULT_STATUS_ATTRIBUTE);

    //
    // Determine the computer type.
    //
    SpDetectComputer(SifHandle);

    //
    // Determine the video type.
    //
    SpDetectVideo(SifHandle);

    //
    // Determine the keyboard type.
    //
    SpDetectKeyboard(SifHandle);

    //
    // Determine the mouse.
    //
    SpDetectMouse(SifHandle);

    //
    // Determine the keyboard layout.
    //
    SpDetectLayout(SifHandle);

    //
    // If we have upgrade, we don't need to know what display, keyboard,
    // layout, mouse we have.   We just need the computer type and that
    // is 100% accurate.  So we can skip the hardware confirmation dialog
    //

    if(NTUpgrade == UpgradeFull) {
        return;
    }

    //
    // Handle locale-specific keyboard stuff for Far East.
    //
    SplangSelectKeyboard(
        UnattendedOperation,
        UnattendedSifHandle,
        NTUpgrade,
        SifHandle,
        HardwareComponents
        );

    //
    // See whether this is an unattended setup.
    //
    NeedConfirm = FALSE;
    if(UnattendedOperation) {

        NeedConfirm = FALSE;

        if( !PreInstall ) {
            //
            //  If this is not an OEM pre-install, then check if we need
            //  to confirm the hardware
            //
            p = SpGetSectionKeyIndex(
                    UnattendedSifHandle,
                    SIF_UNATTENDED,
                    SIF_CONFIRMHW,
                    0
                    );

            if(p && !_wcsicmp(p,L"yes")) {
                NeedConfirm = TRUE;
            }
        } else {
            return;
        }
    }

    FirstPass = TRUE;
    do {

        //
        // See if we know what everything is.
        //
        AllConfirmed = TRUE;
        for(i=0; i<HwComponentMax; i++) {
            if(HardwareComponents[i]->Description == NULL) {
                AllConfirmed = FALSE;
                break;
            }
        }

        //
        // If we don't know what everything is, put up a warning.
        //
        if(FirstPass) {
            if(CustomSetup && NeedConfirm) {
                AllConfirmed = FALSE;
            }
            FirstPass = FALSE;
        } else if(!AllConfirmed) {

            SpDisplayScreen(UnknownHwScreens[i],4,HEADER_HEIGHT+2);
            SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_ENTER_EQUALS_CONTINUE,0);
            SpInputDrain();
            while(SpInputGetKeypress() != ASCI_CR) ;
        }

        //
        // If this is a custom setup or we don't know what
        // a piece of hardware is, present the confirmation screen
        // to the user.
        //
        if(!AllConfirmed) {
            SpHardwareConfirmInteract(SifHandle);
        }

    } while(!AllConfirmed);
}



VOID
SpHardwareConfirmInteract(
    IN PVOID SifHandle
    )
{
    PWSTR szUnknown,szListMatches;
    PWSTR p;
    ULONG MenuLeftX,MenuTopY;
    ULONG LongestLength,len;
    PWSTR MenuItems[HARDWARE_MENU_SIZE];
    PVOID Menu;
    ULONG KeyPressed;
    ULONG_PTR Selection;
    ULONG ValidKeys[3] = { KEY_F3,ASCI_CR,0 };
    BOOLEAN Done;
    ULONG i;
    WCHAR c;


    //
    // Fetch 'unknown' and 'the above list matches my computer' from the resources.
    //
    SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_TEXT_UNKNOWN);
    szUnknown = SpDupStringW(TemporaryBuffer);
    SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_TEXT_LIST_MATCHES);
    szListMatches = SpDupStringW(TemporaryBuffer);

    for(Done=FALSE; !Done; ) {

        //
        // Part 1 of the screen.
        //
        SpDisplayScreen(SP_SCRN_HW_CONFIRM_1,3,HEADER_HEIGHT+1);

        //
        // Remember top line of the menu.
        //
        MenuTopY = NextMessageTopLine + 2;

        //
        // Part 2 of the screen.
        //
        SpContinueScreen(SP_SCRN_HW_CONFIRM_2,3,2,FALSE,DEFAULT_ATTRIBUTE);

        //
        // To determine where the left margin of the menu is, we'll load
        // the second part of the screen and look for the first semicolon.
        //
        SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_SCRN_HW_CONFIRM_2);
        p = wcschr(TemporaryBuffer,L':');
        ASSERT(p);
        if(p) {
            c = *p;
            *p = 0;
            MenuLeftX = SplangGetColumnCount(TemporaryBuffer) + 5;
            *p = c;
        } else {
            MenuLeftX = 23;
        }

        //
        // Build up menu items.
        //
        LongestLength = SplangGetColumnCount(szListMatches);
        for(i=0; i<HARDWARE_MENU_SIZE; i++) {

            MenuItems[i] = HardwareComponents[i]->Description
                         ? HardwareComponents[i]->Description
                         : szUnknown;
            if((len=SplangGetColumnCount(MenuItems[i])) > LongestLength) {
                LongestLength = len;
            }
        }

        Menu = SpMnCreate(MenuLeftX,MenuTopY,LongestLength,HARDWARE_MENU_SIZE+2);

        ASSERT(Menu);

        //
        // Silently fail, if we cannot create the menu
        //
        if (!Menu) {            
            Done = TRUE;

            continue;
        }

        //
        // Add all the items to the menu, plus one unselectable spacer and
        // the 'the list matches' item.
        //
        for(i=0; i<HARDWARE_MENU_SIZE; i++) {
            BOOLEAN ItemSelectable;

#if defined(_IA64_)
            ItemSelectable = TRUE; // in softsdv the mouse + keyboard are
                                   // unknown; we need to select them.
#else
            ItemSelectable = ( (i != HwComponentKeyboard) &&
                               (i != HwComponentMouse) );
#endif
            SpMnAddItem(Menu,
                        MenuItems[i],
                        MenuLeftX,
                        LongestLength,
                        ItemSelectable,
                        ItemSelectable ? i : 0);
        }
        SpMnAddItem(Menu,L"",MenuLeftX,LongestLength,FALSE,0);
        SpMnAddItem(Menu,szListMatches,MenuLeftX,LongestLength,TRUE,(ULONG_PTR)(-1));

        //
        // Display the status text.
        //
        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_SELECT,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        //
        // Display the menu and await a selection.
        //
        SpMnDisplay(Menu,
                    (ULONG_PTR)(-1),
                    FALSE,
                    ValidKeys,
                    NULL,
                    NULL,
                    NULL,
                    &KeyPressed,
                    &Selection);

        SpMnDestroy(Menu);

        switch(KeyPressed) {
        case KEY_F3:
            SpConfirmExit();
            break;
        case ASCI_CR:
            //
            // Selection was made.
            //
            if(Selection == (ULONG_PTR)(-1)) {
                Done = TRUE;
            } else {

                ASSERT(Selection < HwComponentMax);

                //
                // Allow user to make alternate selection for this component.
                //
                SpSelectHwItem(
                    SifHandle,
                    NonlocalizedComponentNames[Selection],
                    NULL,               // use component name as section name
                    SelectHwScreens[Selection],
                    SelectOemHwScreens[Selection],
                    AllowedFileTypes[Selection],
                    RequiredFileTypes[Selection],
                    HardwareComponents[Selection]
                    );
            }
            break;
        default:
            // should never get here!
            ASSERT(0);
            break;
        }
    }

    SpMemFree(szUnknown);
    SpMemFree(szListMatches);
}


BOOLEAN
SpSelectHwItem(
    IN     PVOID               SifHandle,
    IN     PWSTR               NonlocalizedComponentName,
    IN     PWSTR               OemSectionName,            OPTIONAL
    IN     ULONG               SelectHwScreenId,
    IN     ULONG               SelectOemHwScreenId,
    IN     ULONG               AllowedFileTypes,
    IN     ULONG               RequiredFileTypes,
    IN OUT PHARDWARE_COMPONENT HwComp
    )

/*++

Routine Description:

    Allow the user to make selection from a list of choices for a component.

    The list comes from a section in the setup information file named
    for the component.  For example, [Display].

    The descriptions in that section will be placed into a menu to make
    up the selections.  Also added to the menu will be a choice for 'other'
    which the user can choose if he has a third-party driver diskette.
    If a third-party option is the currently selected option, then that
    option will also be on the menu and will be the default.

    If the user selects 'other' then prompt for a driver diskette.

Arguments:

    SifHandle - supplies handle to open setup information file.

    NonlocalizedComponentName - supplies name of component to be used
        as the name of a section in the sif file for the component.

    OemSectionName - supplies name of a section that will contain the
        options for the component in txtsetup.oem.  This may be different
        than NonloclizedComponentName -- for example, the componentname
        string might be "SCSI.MCA" but the OemSectionName would be "SCSI."

    SelectHwScreenId - supplies message id of the screen prompting the user
        to select an option for this component.

    SelectOemHwScreenId - supplies message id of the screen prompting the
        user to select an option on an oem screen for this component
        (ie, the screen the user gets when he selects 'other' hw type
        and inserts an oem floppy).

    AllowedFileTypes - supplies a mask indicating which types of files are
        allowed for this component.  Used to validate the oem selection
        if the user chooses the 'other' hardware type and inserts an oem floppy.

    RequiredFileTypes - supplies a mask indicating which types of files are
        required for this component.  Used to validate the oem selection
        if the user chooses the 'other' hardware type and inserts an oem floppy.

    HwComp - hardware component structure to be filled in with information
        about the user's selection.

Return Value:

    TRUE if the selected hardware item has been changed by the user's action.
    FALSE otherwise.

--*/

{
    ULONG LineCount,Line;
    PVOID Menu;
    ULONG MenuTopY,MenuHeight,MenuWidth;
    PWSTR Description;
    ULONG_PTR Selection;
    PWSTR szOtherHardware;
    ULONG OtherOption;
    ULONG_PTR OriginalSelection = (ULONG_PTR)(-1);
    ULONG ValidKeys[4] = { KEY_F3,ASCI_CR,ASCI_ESC,0 };
    ULONG Keypress;
    BOOLEAN Done;
    BOOLEAN rc = FALSE;
    PWSTR Id,Descr;

    //
    // Fetch the 'other hardware' string from resources.
    //
    SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_TEXT_OTHER_HARDWARE);
    szOtherHardware = SpDupStringW(TemporaryBuffer);

    for(Done=FALSE; !Done; ) {

        //
        // Display the selection prompt screen.
        //
        SpDisplayScreen(SelectHwScreenId,5,HEADER_HEIGHT+1);

        MenuTopY = NextMessageTopLine + 2;
        MenuHeight = VideoVars.ScreenHeight - MenuTopY - 3;
        MenuWidth = VideoVars.ScreenWidth - 6;

        //
        // Create a menu.
        //
        Menu = SpMnCreate(3,MenuTopY,MenuWidth,MenuHeight);
        ASSERT(Menu);

        //
        // Assume unknown option.
        //
        Selection = (ULONG_PTR)(-1);

        //
        // Build a list of options containing the options in our box
        // and the currently selected oem option (if any).
        //
        LineCount = SpCountLinesInSection(SifHandle,NonlocalizedComponentName);
        for(Line=0; Line<LineCount; Line++) {

            //
            // Get the description from the current line and add it to the menu.
            //
            Description = SpGetSectionLineIndex(
                                SifHandle,
                                NonlocalizedComponentName,
                                Line,
                                INDEX_DESCRIPTION
                                );

            if(!Description) {
                SpFatalSifError(SifHandle,NonlocalizedComponentName,NULL,Line,INDEX_DESCRIPTION);
            }

            SpMnAddItem(Menu,Description,3,VideoVars.ScreenWidth-6,TRUE,Line);

            //
            // See if this is the currently selected item.
            //
            if(HwComp->Description && !wcscmp(HwComp->Description,Description)) {
                Selection = Line;
            }
        }

        //
        // If there is an oem option, add its description and make it the default.
        //
        if(HwComp->ThirdPartyOptionSelected) {
            SpMnAddItem(Menu,HwComp->Description,3,VideoVars.ScreenWidth-6,TRUE,Line);
            Selection = Line++;
        }

        //
        // Add 'other to the list and make it the defualt if the current type is
        // 'other' and there is no third-party option.
        // Note that we don't allow oem keyboard layouts any more.
        //
        if(HwComp == HardwareComponents[HwComponentLayout]) {
            if(Selection == (ULONG_PTR)(-1)) {
                Selection = 0;
            }
            OtherOption = (ULONG)(-1);
        } else {
            SpMnAddItem(Menu,szOtherHardware,3,VideoVars.ScreenWidth-6,TRUE,Line);
            if((Selection == (ULONG_PTR)(-1))
            || (!HwComp->ThirdPartyOptionSelected && !HwComp->IdString))
            {
                Selection = Line;
            }
            OtherOption = Line;
        }

        if(OriginalSelection == (ULONG_PTR)(-1)) {
            OriginalSelection = Selection;
        }

        //
        // Display the status text options.
        //
        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_SELECT,
            SP_STAT_F3_EQUALS_EXIT,
            SP_STAT_ESC_EQUALS_CANCEL,
            0
            );

        //
        // Display the menu.
        //
        SpMnDisplay(
            Menu,
            Selection,
            TRUE,
            ValidKeys,
            NULL,
            NULL,
            NULL,
            &Keypress,
            &Selection
            );

        //
        // Fetch the description text before we free the menu structure.
        //
        Descr = SpMnGetTextDup(Menu,Selection);

        SpMnDestroy(Menu);

        switch(Keypress) {

        case ASCI_CR:

            if(Selection == OtherOption) {

                //
                // User selected 'other' -- prompt for a diskette, etc.
                //
                rc = SpOemDiskette(
                        SifHandle,
                        OemSectionName ? OemSectionName : NonlocalizedComponentName,
                        SelectOemHwScreenId,
                        AllowedFileTypes,
                        RequiredFileTypes,
                        HwComp,
                        SP_SCRN_OEM_INF_ERROR
                        );

            } else if(Selection == OriginalSelection) {
                //
                // User chose same thinbg that was selected before.
                //
                rc = FALSE;
            } else {

                //
                // User chose a non-oem option.  Update structures accordingly
                // and forget any previously selected oem option.
                //
                Id = SpGetKeyName(SifHandle,NonlocalizedComponentName,(ULONG)Selection);
                if(!Id) {
                    SpFatalSifError(SifHandle,NonlocalizedComponentName,NULL,(ULONG)Selection,(ULONG)(-1));
                }

                ASSERT(Descr);

                SpFreeHwComponentFile(&HwComp->Files);

                SpInitHwComponent(HwComp,Id,Descr,FALSE,0,NULL,FALSE);
                rc = TRUE;
            }

            Done = TRUE;
            break;

        case ASCI_ESC:

            Done = TRUE;
            break;

        case KEY_F3:

            SpConfirmExit();
            break;

        default:

            // shouldn't ever get here!
            ASSERT(0);
            break;
        }

        SpMemFree(Descr);
    }

    SpMemFree(szOtherHardware);
    return(rc);
}


VOID
SpOemInfError(
    IN ULONG ErrorScreenId,
    IN ULONG SubErrorId,
    IN PWSTR SectionName,
    IN ULONG LineNumber,
    IN PWSTR Description
    )
{
    WCHAR SubError[512];

    //
    // Line numbers are 0-based.  Want to display to user as 1-based.
    //
    LineNumber++;

    //
    // Fetch/format the suberror.
    //
    SpFormatMessage(SubError,sizeof(SubError),SubErrorId,SectionName,LineNumber,Description);

    //
    // Display the error screen.
    //
    SpStartScreen(
        ErrorScreenId,
        3,
        HEADER_HEIGHT+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE,
        SubError
        );

    if( !PreInstall ) {
        //
        // Display status options: enter to continue.
        //
        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_ENTER_EQUALS_CONTINUE,0);

        //
        // Wait for the user to press enter.
        //
        SpInputDrain();
        while(SpInputGetKeypress() != ASCI_CR) ;
    } else {
        //
        // If this is an OEM pre-install then treat the error as a fatal one.
        // Display status options: F3 to exit.
        //
        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);

        //
        // Wait for the user to press enter.
        //
        SpInputDrain();
        while(SpInputGetKeypress() != KEY_F3) ;

        SpDone(0,FALSE,TRUE);
    }
}


BOOLEAN
SpOemDiskette(
    IN     PVOID               SifHandle,
    IN     PWSTR               SectionName,
    IN     ULONG               SelectOemHwScreenId,
    IN     ULONG               AllowedFileTypes,
    IN     ULONG               RequiredFileTypes,
    IN OUT PHARDWARE_COMPONENT HwComp,
    IN     ULONG               ErrorId
    )
{
    PWSTR szDiskName;
    BOOLEAN b;
    ULONG ErrorLine;
    NTSTATUS Status;
    PVOID TxtsetupOem;
    ULONG Count;
    ULONG Line;
    ULONG_PTR DefaultSelection,Selection;
    PWSTR DefSelId;
    PVOID Menu;
    ULONG MenuTopY,MenuHeight,MenuWidth;
    BOOLEAN rc;
    ULONG ValidKeys[3] = { ASCI_CR, ASCI_ESC, 0 };
    ULONG Key;
    PWSTR szDefaults = TXTSETUP_OEM_DEFAULTS_U;
    PWSTR szDevicePath = 0;

    //
    // Assume failure.
    //
    rc = FALSE;

    //
    // Always want to prompt for the disk in A:.
    // First, make sure there is an A:!
    //
    if(SpGetFloppyDriveType(0) == FloppyTypeNone) {
        SpDisplayScreen(SP_SCRN_NO_FLOPPY_FOR_OEM_DISK,3,HEADER_HEIGHT+1);
        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_ENTER_EQUALS_CONTINUE,0);
        SpInputDrain();
        while(SpInputGetKeypress() != ASCI_CR) ;
        goto sod0;
    }

    //
    // Fetch the generic oem disk name.
    //
    SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_TEXT_OEM_DISK_NAME);
    szDiskName = SpDupStringW(TemporaryBuffer);

    //
    // Prompt for the disk -- ignore what may be in the drive already,
    // and allow escape.
    //
    szDevicePath = SpDupStringW(L"\\device\\floppy0");

    if (szDevicePath) {
        b = SpPromptForDisk(
                szDiskName,
                szDevicePath,
                TXTSETUP_OEM_FILENAME_U,
                TRUE,
                TRUE,
                FALSE,
                NULL
                );
        SpMemFree(szDevicePath);
    } else {
        b = FALSE;
    }

    SpMemFree(szDiskName);

    //
    // If the user pressed escape at the disk prompt, bail out now.
    //
    if(!b) {
        goto sod0;
    }

    //
    // Load txtsetup.oem.
    //
    HandleLineContinueChars = FALSE;
    Status = SpLoadSetupTextFile(
                L"\\device\\floppy0\\" TXTSETUP_OEM_FILENAME_U,
                NULL,
                0,
                &TxtsetupOem,
                &ErrorLine,
                TRUE,
                FALSE
                );
    HandleLineContinueChars = TRUE;

    if(!NT_SUCCESS(Status)) {
        if(Status == STATUS_UNSUCCESSFUL) {
            SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_A,NULL,ErrorLine,NULL);
        } else {
            SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_0,NULL,0,NULL);
        }
        goto sod0;
    }

    //
    // Determine if this inf file is relevent to the device class the user
    // is selecting.  If there is a section called 'display' 'keyboard' etc
    // as appropriate for DeviceClass, then we're in business.
    //

    Count = SpCountLinesInSection(TxtsetupOem,SectionName);
    if(!Count) {
        SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_1,SectionName,0,NULL);
        goto sod1;
    }

    //
    // Get the id of the default choice.
    //

    DefaultSelection = 0;
    DefSelId = SpGetSectionKeyIndex(TxtsetupOem,szDefaults,SectionName,OINDEX_DEFAULT);
    if(DefSelId == NULL) {
        DefSelId = L"";
    }

    //
    // Display the prompt screen, calculate where the menu goes,
    // and create a menu.
    //
    SpDisplayScreen(SelectOemHwScreenId,5,HEADER_HEIGHT+1);

    MenuTopY = NextMessageTopLine + 2;
    MenuHeight = VideoVars.ScreenHeight - MenuTopY - 3;
    MenuWidth = VideoVars.ScreenWidth - 6;

    Menu = SpMnCreate(3,MenuTopY,MenuWidth,MenuHeight);

    //
    // Build a menu from the choices in the oem inf file section.
    //
    for(Line=0; Line<Count; Line++) {

        PWSTR p,Descr;

        Descr = SpGetSectionLineIndex(TxtsetupOem,SectionName,Line,OINDEX_DESCRIPTION);
        if(Descr == NULL) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpOemDiskette: no description on line %u in [%ws]",Line,SectionName));
            SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_2,SectionName,Line,NULL);
            goto sod2;
        }

        SpMnAddItem(Menu,Descr,3,MenuWidth,TRUE,Line);

        // determine if this is the default selection.
        if(p = SpGetKeyName(TxtsetupOem,SectionName,Line)) {
            if(!_wcsicmp(p,DefSelId)) {
                DefaultSelection = Line;
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpOemDiskette: no key on line %u of section %ws",Line,SectionName));
            SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_2,SectionName,Line,NULL);
            goto sod2;
        }
    }

    //
    // Display options in status bar: enter = select, escape = cancel.
    //
    SpDisplayStatusOptions(
        DEFAULT_STATUS_ATTRIBUTE,
        SP_STAT_ENTER_EQUALS_SELECT,
        SP_STAT_ESC_EQUALS_CANCEL,
        0
        );

    //
    // Display the menu and await a selection.
    //
    SpMnDisplay(Menu,
                DefaultSelection,
                TRUE,
                ValidKeys,
                NULL,
                NULL,
                NULL,
                &Key,
                &Selection);

    if(Key == ASCI_CR) {

        PWSTR Id = SpGetKeyName(TxtsetupOem,SectionName,(ULONG)Selection);
        PWSTR p;

        //
        // We already checked this once for non-null (above).
        //
        ASSERT(Id);

        rc = SpOemInfSelection(
                TxtsetupOem,
                SectionName,
                Id,
                p = SpMnGetTextDup(Menu,Selection),
                AllowedFileTypes,
                RequiredFileTypes,
                HwComp,
                ErrorId
                );

        SpMemFree(p);

    } else {

        ASSERT(Key == ASCI_ESC);

        // just fall through and return false.
    }

sod2:
    SpMnDestroy(Menu);

sod1:
    SpFreeTextFile(TxtsetupOem);

sod0:
    return(rc);
}


BOOLEAN
SpOemInfSelection(
    IN  PVOID               TxtsetupOem,
    IN  PWSTR               NonlocalizedComponentName,
    IN  PWSTR               SelectedId,
    IN  PWSTR               ItemDescription,
    IN  ULONG               AllowedFileTypes,
    IN  ULONG               RequiredFileTypes,
    OUT PHARDWARE_COMPONENT HwComp,
    IN  ULONG               ErrorId
    )
{
    PWSTR FilesSectionName,ConfigSectionName;
    ULONG Line,Count,Line2,Count2;
    BOOLEAN rc = FALSE;
    PHARDWARE_COMPONENT_FILE FileList = NULL;
    PHARDWARE_COMPONENT_REGISTRY RegList = NULL;
    ULONG FileTypeBits = 0;
    PWSTR szDisks = TXTSETUP_OEM_DISKS_U;

    //
    // Iterate through the files section, remembering info about the
    // files to be copied in support of the selection.
    //

    FilesSectionName = SpMemAlloc(
                                ((wcslen(NonlocalizedComponentName)+wcslen(SelectedId)+1)*sizeof(WCHAR))
                              + sizeof(L"Files.")
                            );

    wcscpy(FilesSectionName,L"Files.");
    wcscat(FilesSectionName,NonlocalizedComponentName);
    wcscat(FilesSectionName,L".");
    wcscat(FilesSectionName,SelectedId);
    Count = SpCountLinesInSection(TxtsetupOem,FilesSectionName);
    if(Count == 0) {
        SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_3,FilesSectionName,0,NULL);
        goto sod0;
    }

    for(Line=0; Line<Count; Line++) {

        PWSTR Disk,Filename,Filetype,Tagfile,Description,Directory,ConfigName;
        HwFileType filetype;
        PHARDWARE_COMPONENT_FILE FileStruct;

        //
        // Get the disk specification, filename, and filetype from the line.
        //

        Disk = SpGetSectionLineIndex(TxtsetupOem,FilesSectionName,Line,OINDEX_DISKSPEC);
        Filename = SpGetSectionLineIndex(TxtsetupOem,FilesSectionName,Line,OINDEX_FILENAME);
        Filetype = SpGetKeyName(TxtsetupOem,FilesSectionName,Line);

        if(!Disk || !Filename || !Filetype) {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                "SETUP: SpOemInfSelection: Disk=%ws, Filename=%ws, Filetype=%ws",
                Disk ? Disk : L"(null)",
                Filename ? Filename : L"(null)",
                Filetype ? Filetype : L"(null)"
                ));

            SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_2,FilesSectionName,Line,NULL);
            SpFreeHwComponentFile(&FileList);
            goto sod0;
        }

        //
        // Parse the filetype.
        //
        filetype = SpFindStringInTable(FileTypeNames,Filetype);
        if(filetype == HwFileMax) {
            SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_4,FilesSectionName,Line,NULL);
            SpFreeHwComponentFile(&FileList);
            goto sod0;
        }

        //
        // Fetch the name of the section containing configuration information.
        // Required if file is of type port, class, or driver.
        //
        if((filetype == HwFilePort) || (filetype == HwFileClass) || (filetype == HwFileDriver)) {
            ConfigName = SpGetSectionLineIndex(TxtsetupOem,FilesSectionName,Line,OINDEX_CONFIGNAME);
            if(ConfigName == NULL) {
                SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_8,FilesSectionName,Line,NULL);
                SpFreeHwComponentFile(&FileList);
                goto sod0;
            }
        } else {
            ConfigName = NULL;
        }

        //
        // Using the disk specification, look up the tagfile, description,
        // and directory for the disk.
        //

        Tagfile     = SpGetSectionKeyIndex(TxtsetupOem,szDisks,Disk,OINDEX_TAGFILE);
        Description = SpGetSectionKeyIndex(TxtsetupOem,szDisks,Disk,OINDEX_DISKDESCR);
        Directory   = SpGetSectionKeyIndex(TxtsetupOem,szDisks,Disk,OINDEX_DIRECTORY);
        if((Directory == NULL) || !wcscmp(Directory,L"\\")) {
            Directory = L"";
        }

        if(!Tagfile || !Description) {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                "SETUP: SpOemInfSelection: Tagfile=%ws, Description=%ws",
                Tagfile ? Tagfile : L"(null)",
                Description ? Description : L"(null)"
                ));

            SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_5,FilesSectionName,Line,NULL);
            SpFreeHwComponentFile(&FileList);
            goto sod0;
        }

        FileStruct = SpMemAlloc(sizeof(HARDWARE_COMPONENT_FILE));
        RtlZeroMemory(FileStruct,sizeof(HARDWARE_COMPONENT_FILE));

        SpInitHwComponentFile(
            FileStruct,
            Filename,
            filetype,
            ConfigName,
            Description,
            Tagfile,
            Directory,
            NULL
            );

        FileStruct->Next = FileList;
        FileList = FileStruct;

        if((filetype == HwFilePort) || (filetype == HwFileDriver)) {
            SET_FILETYPE_PRESENT(FileTypeBits,HwFilePort);
            SET_FILETYPE_PRESENT(FileTypeBits,HwFileDriver);
        } else {
            SET_FILETYPE_PRESENT(FileTypeBits,filetype);
        }

        //
        // Now go look in the [Config.<ConfigName>] section for registry
        // information that is to be set for this driver file.
        //
        if(ConfigName) {
            ConfigSectionName = SpMemAlloc((wcslen(ConfigName)*sizeof(WCHAR)) + sizeof(L"Config."));
            wcscpy(ConfigSectionName,L"Config.");
            wcscat(ConfigSectionName,ConfigName);
            Count2 = SpCountLinesInSection(TxtsetupOem,ConfigSectionName);

            for(Line2=0; Line2<Count2; Line2++) {

                PWSTR KeyName,ValueName,ValueType;
                PHARDWARE_COMPONENT_REGISTRY Reg;
                HwRegistryType valuetype;

                //
                // Fetch KeyName, ValueName, and ValueType from the line.
                //

                KeyName   = SpGetSectionLineIndex(TxtsetupOem,ConfigSectionName,Line2,OINDEX_KEYNAME);
                ValueName = SpGetSectionLineIndex(TxtsetupOem,ConfigSectionName,Line2,OINDEX_VALUENAME);
                ValueType = SpGetSectionLineIndex(TxtsetupOem,ConfigSectionName,Line2,OINDEX_VALUETYPE);

                if(!KeyName || !ValueName || !ValueType) {

                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                        "SETUP: SpOemInfSelection: KeyName=%ws, ValueName=%ws, ValueType=%ws",
                        KeyName ? KeyName : L"(null)",
                        ValueName ? ValueName : L"(null)",
                        ValueType ? ValueType : L"(null)"
                        ));

                    SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_2,ConfigSectionName,Line2,NULL);
                    SpFreeHwComponentReg(&RegList);
                    SpFreeHwComponentFile(&FileList);
                    goto sod0;
                }

                //
                // Parse the value type and associated values.
                //
                valuetype = SpFindStringInTable(RegistryTypeNames,ValueType);
                if(valuetype == HwRegistryMax) {
                    SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_6,ConfigSectionName,Line2,NULL);
                    SpFreeHwComponentFile(&FileList);
                    SpFreeHwComponentReg(&RegList);
                    goto sod0;
                }

                valuetype = RegistryValueTypeMap[valuetype];

                Reg = SpInterpretOemRegistryData(
                            TxtsetupOem,
                            ConfigSectionName,
                            Line2,
                            valuetype,
                            KeyName,
                            ValueName
                            );

                if(Reg) {
                    Reg->Next = RegList;
                    RegList = Reg;
                } else {
                    SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_7,ConfigSectionName,Line2,NULL);
                    SpFreeHwComponentReg(&RegList);
                    SpFreeHwComponentFile(&FileList);
                    goto sod0;
                }
            }

            FileStruct->RegistryValueList = RegList;
            RegList = NULL;

            SpMemFree(ConfigSectionName);
        }
    }

    //
    // Check to see whether only files of the allowed types for this component
    // have been specified.
    //

    if((AllowedFileTypes | FileTypeBits) != AllowedFileTypes) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SppOemInfSelection: allowed files: %lx, what we've got: %lx",AllowedFileTypes,FileTypeBits));
        SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_9,FilesSectionName,0,NULL);
        SpFreeHwComponentFile(&FileList);
        goto sod0;
    }

    //
    // Check to see whether files were specified for each required type.
    //

    if((RequiredFileTypes & FileTypeBits) != RequiredFileTypes) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SppOemInfSelection: required files: %lx, what we've got: %lx",RequiredFileTypes,FileTypeBits));
        SpOemInfError(ErrorId,SP_TEXT_OEM_INF_ERROR_9,FilesSectionName,0,NULL);
        SpFreeHwComponentFile(&FileList);
        goto sod0;
    }

    //
    // Everything is OK so we can place the information we have gathered
    // into the main structure for the device class.
    //

    SpFreeHwComponentFile(&HwComp->Files);
    SpInitHwComponent(HwComp,SelectedId,ItemDescription,TRUE,FileTypeBits,NULL,FALSE);
    HwComp->Files = FileList;
    rc = TRUE;

    //
    // Clean up and exit.
    //

sod0:
    SpMemFree(FilesSectionName);

    return(rc);
}


VOID
SpDetectComputer(
    IN PVOID SifHandle
    )
{
    PHARDWARE_COMPONENT pHw = HardwareComponents[HwComponentComputer];
    PWSTR Description;

    //
    // Setupldr *must* have given us this information.
    //
    ASSERT(pHw);
    ASSERT(pHw->Next == NULL);

    //
    // If the computer is a third-aprty type, the desscription
    // should already be there.
    //
    if(pHw->ThirdPartyOptionSelected) {

        ASSERT(pHw->Description);

    } else {

        //
        // Description might already be there if the user chose
        // a type we support, during setupldr phase.
        //
        if(pHw->Description) {
            SpMemFree(pHw->Description);
        }

        //
        // Look up the description.
        //
        Description = SpGetSectionKeyIndex(
                            SifHandle,
                            NonlocalizedComponentNames[HwComponentComputer],
                            pHw->IdString,
                            INDEX_DESCRIPTION
                            );

        if(!Description) {

            SpFatalSifError(
                SifHandle,
                NonlocalizedComponentNames[HwComponentComputer],
                pHw->IdString,
                0,
                INDEX_DESCRIPTION
                );
        }

        pHw->Description = SpDupStringW(Description);
    }


}


VOID
SpDetectVideo(
    IN PVOID SifHandle
    )
{
    PHARDWARE_COMPONENT VideoDevice;

    VideoDevice = HardwareComponents[HwComponentDisplay];

    //
    // Just use what setupldr detected but we'll have to go
    // fetch the description for non-oem video types.
    //
    if(!VideoDevice->ThirdPartyOptionSelected && !VideoDevice->Description) {

        VideoDevice->Description = SpGetSectionKeyIndex(
                                        SifHandle,
                                        NonlocalizedComponentNames[HwComponentDisplay],
                                        VideoDevice->IdString,
                                        INDEX_DESCRIPTION
                                        );

        if(VideoDevice->Description) {
            VideoDevice->Description = SpDupStringW(VideoDevice->Description);
        } else {
            SpFatalSifError(
                SifHandle,
                NonlocalizedComponentNames[HwComponentDisplay],
                VideoDevice->IdString,
                0,
                INDEX_DESCRIPTION
                );
        }
    }

    //
    // There should be only one video device.
    //
    ASSERT(VideoDevice->Next == NULL);
}


VOID
SpDetectKeyboard(
    IN PVOID SifHandle
    )
{
#if 0
    PHARDWARE_COMPONENT KeyboardDevice;

    KeyboardDevice = HardwareComponents[HwComponentKeyboard];

    //
    // If setupldr did any keyboard detection, ignore it
    // unless it's a third-party option.
    //
    if(KeyboardDevice && KeyboardDevice->ThirdPartyOptionSelected)  {

        //
        // There should be only one keyboard device.
        //
        ASSERT(KeyboardDevice->Next == NULL);

    } else {

        //
        // Free the keyboard device if there is one.
        //
        if(KeyboardDevice) {
            SpFreeHwComponent(&KeyboardDevice,TRUE);
        }

        KeyboardDevice = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
        RtlZeroMemory(KeyboardDevice,sizeof(HARDWARE_COMPONENT));

        SpDetermineComponent(
            SifHandle,
            KeyboardDevice,
            L"KeyboardPeripheral",
            NULL,
            L"Keyboard"
            );

        HardwareComponents[HwComponentKeyboard] = KeyboardDevice;
    }
#endif

    PHARDWARE_COMPONENT KeyboardDevice, p;
    PWSTR   ComponentName;
    PWSTR   Key;
    PWSTR   Description;

#if 0
    for( KeyboardDevice = HardwareComponents[HwComponentKeyboard];
         KeyboardDevice != NULL;
         KeyboardDevice = KeyboardDevice->Next ) {

        //
        // Free the keyboard device if there is one.
        //
        if(KeyboardDevice) {
            SpFreeHwComponent(&KeyboardDevice,TRUE);
        }
    }
#endif

    KeyboardDevice = HardwareComponents[HwComponentKeyboard];
    //
    // Free the keyboard device if there is one.
    //
    if(KeyboardDevice) {
        SpFreeHwComponent(&KeyboardDevice,TRUE);
    }
    ComponentName = NonlocalizedComponentNames[HwComponentKeyboard];
    KeyboardDevice = NULL;
    p = NULL;
    
    if( UsbKeyboardDetected ) {

        Key = SpDupStringW( L"kbdhid" );

        if (Key) {
            Description = SpGetSectionKeyIndex(SifHandle,ComponentName,Key,INDEX_DESCRIPTION);
        } else {
            Description = NULL;
            Key = L"kbdhid";
        }            
        
        if(!Description) {
            SpFatalSifError(SifHandle,ComponentName,Key,0,INDEX_DESCRIPTION);
        }
        p = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
        RtlZeroMemory(p,sizeof(HARDWARE_COMPONENT));
        SpInitHwComponent(p,Key,Description,FALSE,0,NULL,FALSE);
        
        KeyboardDevice = p;
     
    } 
    else if (StdKeyboardDetected) {

        Key = SpDupStringW( L"STANDARD" );

        if (Key) {
            Description = SpGetSectionKeyIndex(SifHandle,ComponentName,Key,INDEX_DESCRIPTION);
        } else {
            Description = NULL;
            Key = L"STANDARD";
        }            
        
        if(!Description) {
            SpFatalSifError(SifHandle,ComponentName,Key,0,INDEX_DESCRIPTION);
        }
        p = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
        RtlZeroMemory(p,sizeof(HARDWARE_COMPONENT));
        SpInitHwComponent(p,Key,Description,FALSE,0,NULL,FALSE);
        KeyboardDevice = p;

    } else {

         p = SpMemAlloc(sizeof(HARDWARE_COMPONENT));

         if (p) {
             RtlZeroMemory(p,sizeof(HARDWARE_COMPONENT));

             SpDetermineComponent(
                 SifHandle,
                 p,
                 L"KeyboardPeripheral",
                 L"NO KEYBOARD",
                 L"Keyboard"
                 );

            KeyboardDevice = p;
         }
     }

     ASSERT(KeyboardDevice);

     HardwareComponents[HwComponentKeyboard] = KeyboardDevice;
}

VOID
SpDetectLayout(
    IN PVOID SifHandle
    )
{
    PHARDWARE_COMPONENT KeyboardLayout;
    PWSTR IdString,Description;

    KeyboardLayout = HardwareComponents[HwComponentLayout];

    //
    // Setupldr never chooses a layout.
    //
    ASSERT(KeyboardLayout == NULL);

    KeyboardLayout = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
    RtlZeroMemory(KeyboardLayout,sizeof(HARDWARE_COMPONENT));

    HardwareComponents[HwComponentLayout] = KeyboardLayout;

    //
    // Look up the default layout in the setup information file.
    //
    IdString = SpGetSectionKeyIndex(SifHandle,SIF_NLS,SIF_DEFAULTLAYOUT,0);
    if(!IdString) {
        SpFatalSifError(SifHandle,SIF_NLS,SIF_DEFAULTLAYOUT,0,0);
    }

    Description = SpGetSectionKeyIndex(
                        SifHandle,
                        NonlocalizedComponentNames[HwComponentLayout],
                        IdString,
                        INDEX_DESCRIPTION
                        );
    if(!Description) {
        SpFatalSifError(
            SifHandle,
            NonlocalizedComponentNames[HwComponentLayout],
            IdString,
            0,
            INDEX_DESCRIPTION
            );
    }

    //
    // Initialize the hardware component strucutre for the layout.
    //
    SpInitHwComponent(KeyboardLayout,IdString,Description,FALSE,0,NULL,FALSE);
}


VOID
SpDetectMouse(
    IN PVOID SifHandle
    )
{
#if 0
    PHARDWARE_COMPONENT MouseDevice;

    //
    // Setupldr does not do any mouse detection.
    //
    ASSERT(HardwareComponents[HwComponentMouse] == NULL);

    MouseDevice = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
    RtlZeroMemory(MouseDevice,sizeof(HARDWARE_COMPONENT));

    SpDetermineComponent(
        SifHandle,
        MouseDevice,
        L"PointerPeripheral",
        L"NO MOUSE",
        L"Mouse"
        );

    HardwareComponents[HwComponentMouse] = MouseDevice;
#endif

    PHARDWARE_COMPONENT MouseDevice, p;
    PWSTR   ComponentName;
    PWSTR   Key;
    PWSTR   Description;

    ComponentName = NonlocalizedComponentNames[HwComponentMouse];
    MouseDevice = NULL;
    p = NULL;
    
    //
    // If a mouse was detected (through pnp), then add the mouse to the list
    //
    // none = "No Mouse or Other Pointing Device",files.none,""
    // mouhid = "USB Mouse",files.mouhid,mouhid
    // msser = "Microsoft Serial Mouse",files.sermouse,sermouse
    // ps2 = "Mouse Port Mouse",files.i8042,i8042prt
    // sermouse = "Serial Mouse",files.sermouse,sermouse
    //
    if( UsbMouseDetected ) {
        
        Key = SpDupStringW( L"mouhid" );

        if (Key) {
            Description = SpGetSectionKeyIndex(SifHandle,ComponentName,Key,INDEX_DESCRIPTION);
        } else {
            Description = NULL;
            Key = L"mouhid";
        }
        
        if(!Description) {
            SpFatalSifError(SifHandle,ComponentName,Key,0,INDEX_DESCRIPTION);
        }

        p = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
        RtlZeroMemory(p,sizeof(HARDWARE_COMPONENT));
        SpInitHwComponent(p,Key,Description,FALSE,0,NULL,FALSE);
        MouseDevice = p;
    
    } else if( SerMouseDetected ) {

        Key = SpDupStringW( L"msser" );

        if (Key) {
            Description = SpGetSectionKeyIndex(SifHandle,ComponentName,Key,INDEX_DESCRIPTION);
        } else {
            Description = NULL;
            Key = L"msser";                
        }
        
        if(!Description) {
            SpFatalSifError(SifHandle,ComponentName,Key,0,INDEX_DESCRIPTION);
        }

        p = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
        RtlZeroMemory(p,sizeof(HARDWARE_COMPONENT));
        SpInitHwComponent(p,Key,Description,FALSE,0,NULL,FALSE);
        p->Next = MouseDevice;
        MouseDevice = p;
    
    }
#if defined(_AMD64_) || defined(_IA64_)
    else if( PS2MouseDetected ) {
            
        Key = SpDupStringW( L"ps2" );

        if (Key) {
            Description = SpGetSectionKeyIndex(SifHandle,ComponentName,Key,INDEX_DESCRIPTION);
        } else {
            Description = NULL;
            Key = L"ps2";                
        }
        
        if(!Description) {
            SpFatalSifError(SifHandle,ComponentName,Key,0,INDEX_DESCRIPTION);
        }
        
        p = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
        RtlZeroMemory(p,sizeof(HARDWARE_COMPONENT));
        SpInitHwComponent(p,Key,Description,FALSE,0,NULL,FALSE);
        p->Next = MouseDevice;
        MouseDevice = p;
        
    } 
    else
#endif // defined(_AMD64_) || defined (_IA64_)
    {
        //
        //  Now look for a mouse detected by NTDETECT.
        //
        
        p = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
        RtlZeroMemory(p,sizeof(HARDWARE_COMPONENT));

        SpDetermineComponent(
            SifHandle,
            p,
            L"PointerPeripheral",
            L"NO MOUSE",
            L"Mouse"
            );
        if( MouseDevice == NULL ) {
            //
            // If we did not any mice through pnp, then add whatever we found through NTDETECT
            // (even "No Mouse"), to the mice list.
            //
            MouseDevice = p;
        } else {
            //
            //  Add the mouse detected through NTDETECT, if any
            //
            if( _wcsicmp( p->IdString, L"none" ) != 0 ) {
                p->Next = MouseDevice;
                MouseDevice = p;
            }
        }
    
    }

    ASSERT(MouseDevice);

    HardwareComponents[HwComponentMouse] = MouseDevice;
}



VOID
SpDetermineComponent(
    IN  PVOID               SifHandle,
    OUT PHARDWARE_COMPONENT HwComp,
    IN  PWSTR               HardwareDescriptionKeyName,
    IN  PWSTR               FallbackIdentifier,
    IN  PWSTR               ComponentName
    )

/*++

Routine Description:

    Make an initial determination about the type of a hardware component
    (ie, perform a hardware 'detection').

    The detection is performed by scanning the hardware configuration tree
    for a key representing a particular hardware component, and attempting
    to match its identifier string with a set of known identifier strings
    (stored in the setup information file).

Arguments:

    SifHandle - supplies handle for main setup information file.

    HwComp - a hardware component structure that is filled in with information
        about the component we find.

    HardwareDescriptionKeyName - supplies the name of the key in the hardware
        description (ie, the firmware configuration tree).

    FallbackIdentifier - supplies the id string to use if we cannot detect
        the hardware type for the component.  For example, if we can't find
        a PointerPeripheral (mouse), this might be "NO MOUSE."

    ComponentName - supplies name of the component.  This name is not translated.

Return Value:

    TRUE if a match was found, FALSE otherwise.

--*/

{
    PWSTR IdString;

    //
    // Scan the firmware configuration tree.
    //
    SpScanHardwareDescription(HardwareDescriptionKeyName);

    if (IdStringCount && (0 == _wcsicmp(HardwareDescriptionKeyName, L"PointerPeripheral"))) {
        //
        // Skip the Microsoft Bus Mouse device
        //
        ULONG Index;        
        
        for (Index = 0; Index < IdStringCount; Index++) {
            if (IdStringArray[Index] && _wcsicmp(IdStringArray[Index], MICROSOFT_BUS_MOUSE_NAME)) {
                if (Index) {
                    PWSTR FirstId = IdStringArray[0];

                    IdStringArray[0] = IdStringArray[Index];
                    IdStringArray[Index] = FirstId;
                }                    

                break;
            }                
        }

        if (Index >= IdStringCount) {
            IdStringCount = 0;
        }
    }
    
    //
    // Pick off the first identifier found.  If no such node
    // was found, then use the fallback identifier.
    //    
    IdString = IdStringCount ? IdStringArray[0] : FallbackIdentifier;

    //
    // Now go scan the map section in the sif file to see whether we
    // recognize the hardware described by this particular id string.
    //
    SpScanMapSection(SifHandle,HwComp,ComponentName,IdString);

    SpFreeLocatedIdStrings();
}



BOOLEAN
SpScanMapSection(
    IN  PVOID               SifHandle,
    OUT PHARDWARE_COMPONENT HwComp,
    IN  PWSTR               ComponentName,
    IN  PWSTR               IdString
    )

/*++

Routine Description:

    Scan a 'map' section in the main sif file.  A 'map' section is used to
    map values seen as id strings in the firmware configuration tree t0
    'shortnames' -- ie, key values that represent a particular component type.

    A map section has the form, for example,

    [Map.Display]
    g300 = *G300
    g364 = *G364
    vxl  = *VXL

    where the values on the RHS represent possible values for the DisplayController
    node in the hardware description.  The values on the LHS are the keys to be used
    throughout the rest of setup to represent the type of video present in the machine.

    If an entry starts with a * then it need only appear as a substring of the
    id string found in the firmware configuration tree; otherwise the entry and
    the id string must match exactly.

    There is then a section like

    [Display]
    g300 = "Integrated Video Controller (G300)",...
    g364 = "Integrated Video Controller (G364)",...
    vxl  = "Integrated Jaguar Video",...

    that gives additional information about the video type, like a description, etc.

    This routine scans the map section for a match of a given id string found in
    the firmware tree, looks up additional information about the component if a match
    is found, and fills in a hardware component structure.

Arguments:

    SifHandle - supplies handle for main setup information file.

    HwComp - a hardware component structure that is filled in with information
        about the component we find, if a match is found.

    ComponentName - supplies name of the component.  This name is not translated.

    IdString - supplies the id string located in a key in the
        firmware configuration tree.

Return Value:

    TRUE if a match was found, FALSE otherwise.

--*/

{
    PWSTR MapSectionName;
    ULONG LineCount;
    ULONG Line;
    BOOLEAN b;
    PWSTR Value;
    PWSTR Key,Description;


    if(IdString == NULL) {
        IdString = L"";
    }

    //
    // Form the name of the map section.
    //
    MapSectionName = SpMemAlloc((wcslen(ComponentName)*sizeof(WCHAR)) + sizeof(MAP_SECTION_NAME_PREFIX));
    wcscpy(MapSectionName,MAP_SECTION_NAME_PREFIX);
    wcscat(MapSectionName,ComponentName);
    LineCount = SpCountLinesInSection(SifHandle,MapSectionName);
    if(!LineCount) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Warning: no lines in [%ws]\n",MapSectionName));
        SpMemFree(MapSectionName);
        return(FALSE);
    }

    //
    // We have a section like
    //
    // [Map.Display]
    // vga = "VGA"
    // xga = *XGA
    //
    // We look at each line in the section, seeing if the IdString found in the
    // firmware configuration tree matches the value on the right hand side.
    // If so, then we expect to find a line like, for example
    //
    // [Display]
    // xga = "IBM XGA or XGA2"
    //

    for(Line=0; Line<LineCount; Line++) {

        Value = SpGetSectionLineIndex(SifHandle,MapSectionName,Line,INDEX_MAP_FWID);

        if(!Value) {
            SpFatalSifError(SifHandle,MapSectionName,NULL,Line,INDEX_MAP_FWID);
            return FALSE;
        }

        if(*Value == L'*') {
            b = (BOOLEAN)(wcsstr(IdString,Value+1) != NULL);
        } else {
            b = (BOOLEAN)(wcscmp(IdString,Value) == 0);
        }

        if(b) {

            //
            // We've got a match.
            //

            if((Key = SpGetKeyName(SifHandle,MapSectionName,Line)) == NULL) {

                SpFatalSifError(SifHandle,MapSectionName,NULL,Line,(ULONG)(-1));
            }

            Description = SpGetSectionKeyIndex(SifHandle,ComponentName,Key,INDEX_DESCRIPTION);
            if(!Description) {
                SpFatalSifError(SifHandle,ComponentName,Key,0,INDEX_DESCRIPTION);
            }

            SpInitHwComponent(HwComp,Key,Description,FALSE,0,NULL,FALSE);

            SpMemFree(MapSectionName);
            return(TRUE);
        }
    }

    SpMemFree(MapSectionName);
    return(FALSE);
}


VOID
SpScanHardwareDescription(
    IN PWSTR DesiredKeyName
    )

/*++

Routine Description:

    Scan the hardware tree looking for subkeys of a key whose name
    matches a given value.

    Keys in the hardware tree do not match nodes in the arc configuration
    tree exactly.  In the arc configuration tree, each node has 3 attributes:
    a class, a type, and a key (not the same as a registry key; an arc key
    is more like an instance number or ordinal).  In the TN tree, the instances
    are themselves made subkeys.  So something like scsi(0)disk(0)rdisk(0)
    in the arc space ends up looking like

        HKEY_LOCAL_MACHINE
            HARDWARE
                DESCRIPTION
                    System
                        ScsiAdapter
                            0
                                DiskController
                                    0
                                        DiskPeripheral
                                            0

    in the nt hardware description tree.

    This is why we need to look for subkeys on a desired node in the arc tree --
    we assume that the subkeys of, say, a PointerPeripheral key in the registry
    are named "0" "1" etc and contain the ARC configuration data and id string.

    Id strings in keys we locate are added to a global table, in the variables
    IdStringCount and IdStringArray.  The caller must free these resources by
    calling SpFreeLocatedIdStrings.

Arguments:

Return Value:

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE hKey;

    //
    // Initialize some globals that allow us to track identifier strings
    // of devices we have located.
    //
    IdStringCount = 0;
    IdStringArray = SpMemAlloc(0);

    //
    // Open the root of the hardware description tree.
    //
    INIT_OBJA(&Obja,&UnicodeString,L"\\Registry\\Machine\\Hardware\\Description\\System");

    Status = ZwOpenKey(&hKey,KEY_READ,&Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open hardware description (%lx)\n",Status));
        return;
    }

    //
    // Scan the tree.
    //
    SpScanHardwareDescriptionWorker(hKey,L"System",DesiredKeyName);

    ZwClose(hKey);
}


VOID
SpScanHardwareDescriptionWorker(
    IN HANDLE KeyHandle,
    IN PWSTR  KeyName,
    IN PWSTR  DesiredKeyName
    )

/*++

Routine Description:

    Recursive worker routine used to do a depth-first traveral of a registry
    tree rooted at a given key.

Arguments:

    KeyHandle - handle for a registry tree.

    KeyName - name of the key for which KeyHandle is an open handle.
        This is one component long -- ie, no path separator characters appear.

    DesiredKeyName - supplies the name of the key we are looking for.

Return Value:

--*/

{
    ULONG SubKeyIndex;
    ULONG ResultLength;
    PKEY_BASIC_INFORMATION KeyInfo;
    PKEY_VALUE_PARTIAL_INFORMATION ValInfo;
    HANDLE hSubkey;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    PWSTR SubkeyName;

    KeyInfo = (PKEY_BASIC_INFORMATION)TemporaryBuffer;
    ValInfo = (PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer;

    //
    // Enumerate all subkeys of the current key.
    //
    for( SubKeyIndex=0;

         NT_SUCCESS(
            ZwEnumerateKey(
                KeyHandle,
                SubKeyIndex,
                KeyBasicInformation,
                TemporaryBuffer,
                sizeof(TemporaryBuffer),
                &ResultLength
                )
            );

         SubKeyIndex++ )
    {
        //
        // Zero-terminate the subkey name just in case.
        //
        KeyInfo->Name[KeyInfo->NameLength/sizeof(WCHAR)] = 0;

        //
        // Make a duplicate of the subkey name because the name is
        // in TemporaryBuffer, which might get clobbered by recursive
        // calls to this routine.
        //
        SubkeyName = SpDupStringW(KeyInfo->Name);

        if (SubkeyName) {
            //
            // Open this subkey.
            //
            INIT_OBJA(&Obja,&UnicodeString,SubkeyName);
            Obja.RootDirectory = KeyHandle;

            Status = ZwOpenKey(&hSubkey,KEY_READ,&Obja);

            if(NT_SUCCESS(Status)) {
                //
                // See if the current key's name matches the type we're looking for.
                //
                if(!_wcsicmp(KeyName,DesiredKeyName)) {

                    RtlInitUnicodeString(&UnicodeString,L"Identifier");

                    //
                    // Get the identifier string,
                    //
                    Status = ZwQueryValueKey(
                                hSubkey,
                                &UnicodeString,
                                KeyValuePartialInformation,
                                TemporaryBuffer,
                                sizeof(TemporaryBuffer),
                                &ResultLength
                                );

                    if(NT_SUCCESS(Status)) {

                        //
                        // Zero-terminate the id string value just in case.
                        // The data is a wstring, so there shouldn't be
                        // any alignment problems.
                        //
                        *(PWCHAR)(ValInfo->Data + ValInfo->DataLength) = 0;

                        //
                        // Now we have the identifier string -- save it.
                        //
                        IdStringArray = SpMemRealloc(
                                            IdStringArray,
                                            (IdStringCount+1) * sizeof(PWSTR)
                                            );

                        IdStringArray[IdStringCount++] = SpDupStringW((PWSTR)ValInfo->Data);

                    } else {

                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                            "SETUP: Unable to get identifier string in %ws\\%ws (%lx)\n",
                            KeyName,
                            SubkeyName,
                            Status
                            ));
                    }
                } else {

                    //
                    // Enumerate this subkey's subkeys.
                    //
                    SpScanHardwareDescriptionWorker(hSubkey,SubkeyName,DesiredKeyName);
                }

                ZwClose(hSubkey);
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, 
                    "SETUP: Warning: unable to open key %ws\\%ws (%lx)\n",
                    KeyName,SubkeyName,Status));
            }

            SpMemFree(SubkeyName);
        }            
    }
}


VOID
SpFreeLocatedIdStrings(
    VOID
    )
{
    ULONG i;

    ASSERT(IdStringArray);

    for(i=0; i<IdStringCount; i++) {
        SpMemFree(IdStringArray[i]);
    }
    SpMemFree(IdStringArray);
    IdStringArray = NULL;
    IdStringCount = 0;
}



PHARDWARE_COMPONENT
SpSetupldrHwToHwDevice(
    IN PDETECTED_DEVICE SetupldrHw
    )
{
    PHARDWARE_COMPONENT HwComp,HwCompPrev,HwCompFirst=NULL;
    PHARDWARE_COMPONENT_FILE HwCompFile,HwCompFilePrev;
    PHARDWARE_COMPONENT_REGISTRY HwCompReg,HwCompRegPrev;
    PDETECTED_DEVICE_FILE SetupldrFile;
    PDETECTED_DEVICE_REGISTRY SetupldrReg;
    PWSTR s1,s2,s3,s4,s5;
    PVOID Buffer;
    ULONG BufferSize;

    if (SetupldrHw==NULL) {
        return(NULL);
    }
    HwCompPrev = NULL;
    for( ; SetupldrHw; SetupldrHw=SetupldrHw->Next) {

        //
        // Fetch and convert the two strings from the detected device structure.
        //
        s1 = SpToUnicode(SetupldrHw->IdString);
#ifdef UNICODE_SETUPLDR
        // cast this to avoid having to drag in tchar.h, etc.
        s2 = (PWSTR)SetupldrHw->Description;
#else
        s2 = SetupldrHw->Description ? SpToUnicode(SetupldrHw->Description) : NULL;
#endif
        s3 = SpToUnicode(SetupldrHw->BaseDllName);

        //
        // Create a new hardware component structure.
        //
        HwComp = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
        RtlZeroMemory(HwComp,sizeof(HARDWARE_COMPONENT));

        //
        // Initialize the component structure.
        //
        SpInitHwComponent(
            HwComp,
            s1,
            s2,
            SetupldrHw->ThirdPartyOptionSelected,
            SetupldrHw->FileTypeBits,
            s3,
            SetupldrHw->MigratedDriver
            );

        //
        // Link the component structure into the list.
        //
        if(HwCompPrev) {
            HwCompPrev->Next = HwComp;
        } else {
            HwCompFirst = HwComp;
        }
        HwCompPrev = HwComp;

        //
        // Free the unicode strings.
        //
        SpMemFree(s1);
#ifndef UNICODE_SETUPLDR
        if(s2) {
            SpMemFree(s2);
        }
#endif
        SpMemFree(s3);

        //
        // Create new entries for each of the hardware component's files.
        //
        HwCompFilePrev = NULL;

        for(SetupldrFile=SetupldrHw->Files; SetupldrFile; SetupldrFile=SetupldrFile->Next) {
            //
            // We can't convert the ARC device name to NT device name since may may not have
            // the ARC <-> NT name map fully initialized yet
            //
            PWSTR ArcDeviceName = SetupldrFile->ArcDeviceName ? 
                                    SpToUnicode(SetupldrFile->ArcDeviceName) : NULL;

            //
            // Fetch and convert the 5 strings from the detected device file structure.
            //
            s1 = SpToUnicode(SetupldrFile->Filename);
#ifdef UNICODE_SETUPLDR
            // cast this to avoid having to drag in tchar.h, etc.
            s2 = (PWSTR)SetupldrFile->DiskDescription;
#else
            s2 = SpToUnicode(SetupldrFile->DiskDescription);
#endif
            s3 = SpToUnicode(SetupldrFile->DiskTagfile);
            s4 = SpToUnicode(SetupldrFile->Directory);
            if (SetupldrFile->ConfigName != NULL) {
                s5 = SpToUnicode(SetupldrFile->ConfigName);
            } else {
                s5 = NULL;
            }

            //
            // Create a new hardware component file structure.
            //
            HwCompFile = SpMemAlloc(sizeof(HARDWARE_COMPONENT_FILE));

            //
            // Initialize the component file structure.
            //
            SpInitHwComponentFile(HwCompFile,
                    s1,
                    SetupldrFile->FileType,
                    s5,
                    s2,
                    s3,
                    s4,
                    ArcDeviceName          
                    );

            //
            // Link the component file structure into the list.
            //
            if(HwCompFilePrev) {
                HwCompFilePrev->Next = HwCompFile;
            } else {
                HwComp->Files = HwCompFile;
            }
            HwCompFilePrev = HwCompFile;

            //
            // Free the unicode strings.
            //
            SpMemFree(s1);
#ifndef UNICODE_SETUPLDR
            SpMemFree(s2);
#endif
            SpMemFree(s3);
            SpMemFree(s4);
            if (s5 != NULL) {
                SpMemFree(s5);
            }

            if (ArcDeviceName) {
                SpMemFree(ArcDeviceName);
            }

            //
            // Create new entries for each registry value structure for this file.
            //
            HwCompRegPrev = NULL;
            for( SetupldrReg=SetupldrFile->RegistryValueList;
                 SetupldrReg;
                 SetupldrReg=SetupldrReg->Next)
            {
                //
                // Make a duplicate of the buffer.
                // Special case REG_SZ, REG_EXPAND_SZ and REG_MULTI_SZ values because
                // we need to convert then to unicode.
                //
                if(SetupldrReg->ValueType == REG_SZ || SetupldrReg->ValueType == REG_EXPAND_SZ) {

                    Buffer = SpToUnicode(SetupldrReg->Buffer);
                    BufferSize = (wcslen(Buffer) + 1) * sizeof(WCHAR);

                } else {

                    if(SetupldrReg->ValueType == REG_MULTI_SZ) {

                        PUCHAR p;
                        ULONG len;

                        //
                        // Determine the size of the buffer needed to hold the unicode
                        // equivalent of the multi_sz.  Assume all characters are
                        // single-byte and thus the size exactly doubles.
                        //
                        for(BufferSize=sizeof(WCHAR),p=SetupldrReg->Buffer; *p; ) {

                            len = strlen(p) + 1;
                            BufferSize += len * sizeof(WCHAR);
                            p += len;
                        }

                        Buffer = SpMemAlloc(BufferSize);

                        //
                        // Convert each string in the multi_sz to unicode
                        // and place in the resulting unicode multi_sz.
                        //
                        for(s1=Buffer,p=SetupldrReg->Buffer; *p; ) {

                            s2 = SpToUnicode(p);
                            wcscpy(s1,s2);
                            SpMemFree(s2);

                            p  += strlen(p)  + 1;
                            s1 += wcslen(s1) + 1;
                        }

                        //
                        // Final terminating nul in the multi_sz.
                        //
                        *s1++ = 0;

                        //
                        // Reallocate the buffer. If some of the characters
                        // were double-byte, the buffer will be smaller than
                        // the maximum size we allocated above.
                        //
                        BufferSize = (ULONG)((PUCHAR)s1 - (PUCHAR)Buffer);
                        Buffer = SpMemRealloc(Buffer,BufferSize);

                    } else {

                        BufferSize = SetupldrReg->BufferSize;
                        Buffer = SpMemAlloc(BufferSize);
                        ASSERT(Buffer);
                        RtlMoveMemory(Buffer,SetupldrReg->Buffer,BufferSize);
                    }
                }

                //
                // Fetch and convert the 2 strings from the detected device
                // registry value structure.
                //
                s1 = SpToUnicode(SetupldrReg->KeyName);
                s2 = SpToUnicode(SetupldrReg->ValueName);

                //
                // Create a new registry value structure.
                //
                HwCompReg = SpMemAlloc(sizeof(HARDWARE_COMPONENT_REGISTRY));

                //
                // Initialize the component registry value structure.
                //
                SpInitHwComponentRegVal(
                    HwCompReg,
                    s1,
                    s2,
                    SetupldrReg->ValueType,
                    Buffer,
                    BufferSize
                    );

                //
                // Link the component registry value structure into the list.
                //
                if(HwCompRegPrev) {
                    HwCompRegPrev->Next = HwCompReg;
                } else {
                    HwCompFile->RegistryValueList = HwCompReg;
                }
                HwCompRegPrev = HwCompReg;

                //
                // Free the unicode strings.
                //
                SpMemFree(s1);
                SpMemFree(s2);
            }
        }
    }
    return(HwCompFirst);
}


VOID
SpInitHwComponent(
    OUT PHARDWARE_COMPONENT HwComp,
    IN  PWSTR               IdString,
    IN  PWSTR               Description,
    IN  BOOLEAN             ThirdPartyOption,
    IN  ULONG               FileTypeBits,
    IN  PWSTR               BaseDllName,
    IN  BOOLEAN             MigratedDriver
    )

/*++

Routine Description:

    Initialize the fields of a HARDWARE_COMPONENT structure.

    Before initializing the fields, ther IdString and Description
    strings are freed if they are present in the given hardware
    component structure.

    All string values are duplicated by this routine so the caller
    may free them without worrying about ruining the hardware component
    structure.

Arguments:

    IdString - supplies a nul-terminated unicode string for the
        IdString field of the structure.  May be NULL.

    Description - supplies a nul-terminated unicode string for the
        Description field pf the structure.  May be NULL.

    ThirdPartyOption - supplies value of the ThirdPartyOptionSelected
        field of the strcture.

    FileTypeBits - supplies value for the FileTypeBits field
        of the structure.

Return Value:

    None.

--*/

{
    if(HwComp->IdString) {
        SpMemFree(HwComp->IdString);
    }

    if(HwComp->Description) {
        SpMemFree(HwComp->Description);
    }

    if(HwComp->BaseDllName) {
        SpMemFree(HwComp->BaseDllName);
    }

    RtlZeroMemory(HwComp,sizeof(HARDWARE_COMPONENT));

    if(IdString) {
        HwComp->IdString = SpDupStringW(IdString);
    }

    if(Description) {
        HwComp->Description = SpDupStringW(Description);
    }

    if(BaseDllName) {
        HwComp->BaseDllName = SpDupStringW(BaseDllName);
    }

    HwComp->ThirdPartyOptionSelected = ThirdPartyOption;

    HwComp->FileTypeBits = FileTypeBits;

    HwComp->MigratedDriver = MigratedDriver;

}


VOID
SpFreeHwComponent(
    IN OUT PHARDWARE_COMPONENT *HwComp,
    IN     BOOLEAN              FreeAllInList
    )
{
    PHARDWARE_COMPONENT hwComp,Next;

    for(hwComp = *HwComp; hwComp; hwComp=(FreeAllInList ? Next : NULL)) {

        SpFreeHwComponentFile(&hwComp->Files);

        if(hwComp->IdString) {
            SpMemFree(hwComp->IdString);
        }

        if(hwComp->Description) {
            SpMemFree(hwComp->Description);
        }

        if(hwComp->BaseDllName) {
            SpMemFree(hwComp->BaseDllName);
        }

        Next = hwComp->Next;
        SpMemFree(hwComp);
    }

    *HwComp = NULL;
}


VOID
SpFreeHwComponentFile(
    IN OUT PHARDWARE_COMPONENT_FILE *HwCompFile
    )

/*++

Routine Description:

    Free a hardware component file list and all resources used by it,
    including any registry value structures associated with the file
    and resources used by such structgures.

Arguments:

    HwCompFile - supplies pointer to pointer to the first hardware
        component file structure in a linked list.

Return Value:

    None.  HwCompFile is filled in with NULL to prevent the caller
        from retaining a 'dangling' pointer to memory that has been freed.

--*/

{
    PHARDWARE_COMPONENT_FILE hwCompFile,NextFile;

    for(hwCompFile = *HwCompFile ; hwCompFile; hwCompFile=NextFile) {

        if(hwCompFile->Filename) {
            SpMemFree(hwCompFile->Filename);
        }

        if(hwCompFile->ConfigName) {
            SpMemFree(hwCompFile->ConfigName);
        }

        if(hwCompFile->DiskDescription) {
            SpMemFree(hwCompFile->DiskDescription);
        }

        if(hwCompFile->DiskTagFile) {
            SpMemFree(hwCompFile->DiskTagFile);
        }

        if(hwCompFile->Directory) {
            SpMemFree(hwCompFile->Directory);
        }

        //
        // Free registry values as well.
        //
        SpFreeHwComponentReg(&hwCompFile->RegistryValueList);

        NextFile = hwCompFile->Next;
        SpMemFree(hwCompFile);
    }

    *HwCompFile = NULL;
}


VOID
SpInitHwComponentFile(
    OUT PHARDWARE_COMPONENT_FILE HwCompFile,
    IN  PWSTR                    Filename,
    IN  HwFileType               FileType,
    IN  PWSTR                    ConfigName,
    IN  PWSTR                    DiskDescription,
    IN  PWSTR                    DiskTagFile,
    IN  PWSTR                    Directory,
    IN  PWSTR                    ArcDeviceName
    )

/*++

Routine Description:

    Initialize the fields of a HARDWARE_COMPONENT_FILE structure.

    All string values are duplicated by this routine so the caller
    may free them without worrying about ruining the
    hardware component file structure.

Arguments:

    Filename - supplies a nul-terminated unicode string for the
        Filename field of the structure.  May be NULL.

    FileType - supplies value for the FileType field of the structure.

    ConfigName - supplies a nul-terminated unicode string for the
        ConfigName field of the structure.  May be NULL.

    DiskDescription - supplies a nul-terminated unicode string for the
        DiskDescription field of the structure.  May be NULL.

    DiskTagFile - supplies a nul-terminated unicode string for the
        DiskTagFile field of the structure.  May be NULL.

    Directory - supplies a nul-terminated unicode string for the
        Directory field of the structure.  May be NULL.

    ArcDeviceName - supplies the arc device name where the file
        resides.

Return Value:

    None.

--*/

{
    RtlZeroMemory(HwCompFile,sizeof(HARDWARE_COMPONENT_FILE));

    if(Filename) {
        HwCompFile->Filename = SpDupStringW(Filename);
    }

    HwCompFile->FileType = FileType;

    if(ConfigName) {
        HwCompFile->ConfigName = SpDupStringW(ConfigName);
    }

    if(DiskDescription) {
        HwCompFile->DiskDescription = SpDupStringW(DiskDescription);
    }

    if(DiskTagFile) {
        HwCompFile->DiskTagFile = SpDupStringW(DiskTagFile);
    }

    if(Directory) {
        HwCompFile->Directory = SpDupStringW(Directory);
    }

    if (ArcDeviceName) {
        HwCompFile->ArcDeviceName = SpDupStringW(ArcDeviceName);
    }
}


VOID
SpFreeHwComponentReg(
    IN OUT PHARDWARE_COMPONENT_REGISTRY *HwCompReg
    )

/*++

Routine Description:

    Free a hardware component registry value list and all resources
    used by it.

Arguments:

    HwCompReg - supplies pointer to pointer to the first hardware
        component registry value structure in a linked list.

Return Value:

    None.  HwCompReg is filled in with NULL to prevent the caller
        from retaining a 'dangling' pointer to memory that has been freed.

--*/

{
    PHARDWARE_COMPONENT_REGISTRY hwCompReg,NextReg;

    for(hwCompReg = *HwCompReg ; hwCompReg; hwCompReg=NextReg) {

        if(hwCompReg->KeyName) {
            SpMemFree(hwCompReg->KeyName);
        }

        if(hwCompReg->ValueName) {
            SpMemFree(hwCompReg->ValueName);
        }

        if(hwCompReg->Buffer) {
            SpMemFree(hwCompReg->Buffer);
        }

        NextReg = hwCompReg->Next;
        SpMemFree(hwCompReg);
    }

    *HwCompReg = NULL;
}


VOID
SpInitHwComponentRegVal(
    OUT PHARDWARE_COMPONENT_REGISTRY HwCompReg,
    IN  PWSTR                        KeyName,
    IN  PWSTR                        ValueName,
    IN  ULONG                        ValueType,
    IN  PVOID                        Buffer,
    IN  ULONG                        BufferSize
    )

/*++

Routine Description:

    Initialize the fields of a HARDWARE_COMPONENT_REGISTRY structure.

    All string values are duplicated by this routine so the caller
    may free them without worrying about ruining the
    hardware component file structure.

Arguments:

    KeyName - supplies a nul-terminated unicode string for the
        KeyName field of the structure.  May be NULL.

    ValueName - supplies a nul-terminated unicode string for the
        ValueName field of the structure.  May be NULL.

    ValueType - supplies value for the ValueType field of the structure.

    Buffer - supplies value for the Buffer field of the structure.

    BufferSize - supplies value for the BufferSize field of the structure.

Return Value:

    None.

--*/

{
    RtlZeroMemory(HwCompReg,sizeof(HARDWARE_COMPONENT_REGISTRY));

    if(KeyName) {
        HwCompReg->KeyName = SpDupStringW(KeyName);
    }

    if(ValueName) {
        HwCompReg->ValueName = SpDupStringW(ValueName);
    }

    HwCompReg->ValueType  = ValueType;
    HwCompReg->Buffer     = Buffer;
    HwCompReg->BufferSize = BufferSize;
}



PHARDWARE_COMPONENT_REGISTRY
SpInterpretOemRegistryData(
    IN PVOID          SifHandle,
    IN PWSTR          SectionName,
    IN ULONG          Line,
    IN ULONG          ValueType,
    IN PWSTR          KeyName,
    IN PWSTR          ValueName
    )
{
    PHARDWARE_COMPONENT_REGISTRY Reg;
    PWSTR Value;
    unsigned i,len;
    ULONG Dword;
    ULONG BufferSize;
    PVOID Buffer = NULL;
    PWSTR BufferWstr;
    WCHAR str[3];

    //
    // Perform appropriate action based on the type
    //

    switch(ValueType) {

    case REG_DWORD:

        Value = SpGetSectionLineIndex(SifHandle,SectionName,Line,OINDEX_FIRSTVALUE);
        if(Value == NULL) {
            goto x1;
        }

        //
        // Make sure it's really a hex number
        //

        len = wcslen(Value);
        if(len > 8) {
            goto x1;
        }
        for(i=0; i<len; i++) {
            if(!SpIsXDigit(Value[i])) {
                goto x1;
            }
        }

        //
        // convert it from unicode to a hex number
        //
        Dword = (ULONG)SpStringToLong(Value,NULL,16);

        //
        // Allocate a 4-byte buffer and store the dword in it
        //

        Buffer = SpMemAlloc(BufferSize = sizeof(ULONG));
        *(PULONG)Buffer = Dword;
        break;

    case REG_SZ:
    case REG_EXPAND_SZ:

        Value = SpGetSectionLineIndex(SifHandle,SectionName,Line,OINDEX_FIRSTVALUE);
        if(Value == NULL) {
            goto x1;
        }

        //
        // Allocate a buffer of appropriate size for the string
        //

        Buffer = SpDupStringW(Value);
        BufferSize = (wcslen(Value)+1) * sizeof(WCHAR);

        break;

    case REG_BINARY:

        Value = SpGetSectionLineIndex(SifHandle,SectionName,Line,OINDEX_FIRSTVALUE);
        if(Value == NULL) {
            goto x1;
        }

        //
        // Figure out how many byte values are specified
        //

        len = wcslen(Value);
        if(len & 1) {
            goto x1;            // odd # of characters
        }

        //
        // Allocate a buffer to hold the byte values
        //

        Buffer = SpMemAlloc(BufferSize = len / 2);

        //
        // For each digit pair, convert to a hex number and store in the
        // buffer
        //

        str[2] = 0;

        for(i=0; i<len; i+=2) {

            //
            // SpIsXDigit evaluates args more than once so break out assignments.
            //
            str[0] = SpToUpper(Value[i]);
            str[1] = SpToUpper(Value[i+1]);
            if(!SpIsXDigit(str[0]) || !SpIsXDigit(str[1])) {
                goto x1;
            }

            ((PUCHAR)Buffer)[i/2] = (UCHAR)SpStringToLong(str,NULL,16);
        }

        break;

    case REG_MULTI_SZ:

        //
        // Calculate size of the buffer needed to hold all specified strings
        //

        for(BufferSize=sizeof(WCHAR),i=0;
            Value = SpGetSectionLineIndex(SifHandle,SectionName,Line,OINDEX_FIRSTVALUE+i);
            i++)
        {
            BufferSize += (wcslen(Value)+1) * sizeof(WCHAR);
        }

        //
        // Allocate a buffer of appropriate size
        //

        Buffer = SpMemAlloc(BufferSize);
        BufferWstr = Buffer;

        //
        // Store each string in the buffer, converting to wide char format
        // in the process
        //

        for(i=0;
            Value = SpGetSectionLineIndex(SifHandle,SectionName,Line,OINDEX_FIRSTVALUE+i);
            i++)
        {
            wcscpy(BufferWstr,Value);
            BufferWstr += wcslen(Value) + 1;
        }

        //
        // Place final terminating widechar nul in the buffer
        //

        *BufferWstr = 0;

        break;

    default:
    x1:

        //
        // Error - bad type specified or maybe we detected bad data values
        // and jumped here
        //

        if(Buffer) {
            SpMemFree(Buffer);
        }
        return(NULL);
    }

    Reg = SpMemAlloc(sizeof(HARDWARE_COMPONENT_REGISTRY));

    SpInitHwComponentRegVal(Reg,KeyName,ValueName,ValueType,Buffer,BufferSize);

    return(Reg);
}



VOID
SpDetectScsi(
    IN PVOID SifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice
    )
{
    BOOLEAN DetectScsi;
    BOOLEAN b;
    ULONG DriverLoadCount;
    ULONG d;
    NTSTATUS Status;
    PWSTR DriverDescription,DriverFilename;
    PWSTR DriverShortname,DiskDesignator;
    PHARDWARE_COMPONENT scsi,Prev;
    PWSTR PreviousDiskDesignator;

    //
    // Determine the name of the scsi section.
    // This is a remnant from the time when we had separate
    // lists for isa, eisa, and mca machines.
    //
    ScsiSectionName = SpDupStringW(L"SCSI");
    ScsiLoadSectionName = SpDupStringW(L"SCSI.Load");

    LoadedScsiMiniportCount = 0;

    //
    // If scsi drivers have already been loaded, assume setupldr
    // did the detection and skip the scsi confirmation screen.
    //
    if(SetupParameters.LoadedScsi) {

        DetectScsi = FALSE;

        //
        // Fill in descriptions, ignoring what setupldr may have put in
        // the device descriptor.
        //
        for(scsi=ScsiHardware; scsi; scsi=scsi->Next) {

            if(scsi->ThirdPartyOptionSelected) {
                ASSERT(scsi->Description);
                if(!scsi->Description) {

                }
            } else if(scsi->MigratedDriver) {
                if(scsi->Description) {
                    SpMemFree(scsi->Description);
                }

                SpFormatMessage( TemporaryBuffer,
                                 sizeof(TemporaryBuffer),
                                 SP_TEXT_MIGRATED_DRIVER,
                                 scsi->BaseDllName );
                scsi->Description = SpDupStringW( TemporaryBuffer );

            } else {
                if(scsi->Description) {
                    SpMemFree(scsi->Description);
                }

                scsi->Description = SpGetSectionKeyIndex(
                                        SifHandle,
                                        ScsiSectionName,
                                        scsi->IdString,
                                        INDEX_DESCRIPTION
                                        );

                if(!scsi->Description) {
                    SpFatalSifError(SifHandle,ScsiSectionName,scsi->IdString,0,INDEX_DESCRIPTION);
                }
            }
        }


    } else {

        //
        // Scsi drivers have not been loaded.
        // Assume we need to perform detection and confirmation here.
        //

        //
        // If this is a custom setup, ask the user if he wants to skip detection.
        // We do this because loading some miniports can whack the hardware such
        // that the machine hangs.
        //
        if(CustomSetup) {

            ULONG ValidKeys[3] = { KEY_F3,ASCI_CR,0 };
            ULONG Mnemonics[2] = { MnemonicSkipDetection,0 };

            do {
                SpDisplayScreen(SP_SCRN_CONFIRM_SCSI_DETECT,3,HEADER_HEIGHT+1);

                SpDisplayStatusOptions(
                    DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_F3_EQUALS_EXIT,
                    SP_STAT_ENTER_EQUALS_CONTINUE,
                    SP_STAT_S_EQUALS_SKIP_DETECTION,
                    0
                    );

                switch(SpWaitValidKey(ValidKeys,NULL,Mnemonics)) {

                case KEY_F3:

                    SpConfirmExit();
                    b = TRUE;
                    break;

                case ASCI_CR:

                    DetectScsi = TRUE;
                    b = FALSE;
                    break;

                default:

                    //
                    // Must be MnemonicSkipDetection.
                    //
                    DetectScsi = FALSE;
                    b = FALSE;
                    break;
                }
            } while(b);

        } else {

            //
            // Express Setup; always detect scsi.
            //
            DetectScsi = TRUE;
        }
    }

    //
    // If we are supposed to detect scsi, do that here.
    // We will 'detect' scsi by loading scsi miniport drivers.
    //
    if(DetectScsi) {

        ASSERT(ScsiHardware == NULL);

        CLEAR_CLIENT_SCREEN();

        //
        // Determine the number of drivers to be loaded.
        //
        PreviousDiskDesignator = L"";
        Prev = NULL;
        DriverLoadCount = SpCountLinesInSection(SifHandle,ScsiLoadSectionName);
        for(d=0; (d<DriverLoadCount) && (LoadedScsiMiniportCount < MAX_SCSI_MINIPORT_COUNT); d++) {

            PWSTR p;

            //
            // Determine whether we are really supposed to load this driver.
            //
            if((p = SpGetSectionLineIndex(SifHandle,ScsiLoadSectionName,d,2)) && !_wcsicmp(p,L"noload")) {
                continue;
            }

            //
            // Get the driver shortname.
            //
            DriverShortname = SpGetKeyName(SifHandle,ScsiLoadSectionName,d);
            if(!DriverShortname) {
                SpFatalSifError(SifHandle,ScsiLoadSectionName,NULL,d,(ULONG)(-1));
            }

            //
            // Get parameters used to load the driver.
            //
            SpGetDriverValuesForLoad(
                SifHandle,
                ScsiSectionName,
                ScsiLoadSectionName,
                DriverShortname,
                &DriverFilename,
                &DiskDesignator,
                &DriverDescription
                );

            //
            // Prompt for the disk containing the driver.
            //
            retryload:
            if(_wcsicmp(DiskDesignator,PreviousDiskDesignator)) {

                ULONG i;

                SpPromptForSetupMedia(
                    SifHandle,
                    DiskDesignator,
                    SourceDevicePath
                    );

                //
                // Redraw the found list.
                //
                CLEAR_CLIENT_SCREEN();
                for(i=0,scsi=ScsiHardware; scsi; scsi=scsi->Next,i++) {
                    SpDisplayFormattedMessage(
                        SP_TEXT_FOUND_ADAPTER,
                        FALSE,
                        FALSE,
                        DEFAULT_ATTRIBUTE,
                        4,
                        HEADER_HEIGHT+4+i,
                        scsi->Description
                        );
                }

                PreviousDiskDesignator = DiskDesignator;
            }

            //
            // Attempt to load the driver.
            //
            Status = SpLoadDeviceDriver(
                        DriverDescription,
                        SourceDevicePath,
                        DirectoryOnSourceDevice,
                        DriverFilename
                        );

            //
            // If the driver loaded, remember it.
            //
            if(NT_SUCCESS(Status)) {

                SpDisplayFormattedMessage(
                    SP_TEXT_FOUND_ADAPTER,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE,
                    4,
                    HEADER_HEIGHT+4+LoadedScsiMiniportCount,
                    DriverDescription
                    );

                LoadedScsiMiniportCount++;

                scsi = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
                RtlZeroMemory(scsi,sizeof(HARDWARE_COMPONENT));

                SpInitHwComponent(scsi,DriverShortname,DriverDescription,FALSE,0,NULL,FALSE);

                //
                // Link the hardware description into the list.
                //
                if(Prev) {
                    Prev->Next = scsi;
                } else {
                    ScsiHardware = scsi;
                }
                Prev = scsi;
            } else {
                if(Status == STATUS_NO_MEDIA_IN_DEVICE) {
                    PreviousDiskDesignator = L"";
                    goto retryload;
                }
            }
        }

    } else {

        //
        // Count the number of loaded miniport drivers.
        //
        for(scsi=ScsiHardware; scsi; scsi=scsi->Next) {
            LoadedScsiMiniportCount++;
        }
    }
}


VOID
SpConfirmScsiInteract(
    IN PVOID SifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice
    )
{
    ULONG ValidKeys[3] = { ASCI_CR, KEY_F3, 0 };
    ULONG Mnemonics[2] = { MnemonicScsiAdapters,0 };
    ULONG ListTopY;
    PHARDWARE_COMPONENT scsi;
    ULONG i;
    BOOLEAN ScsiConfirmed;
    BOOLEAN b;
    BOOLEAN AddDriver;
    NTSTATUS Status;

    #define SCSI_LIST_LEFT_X  7

    //
    // In unattended mode, we might skip this
    // depending on the unattended script.
    //
    if(UnattendedOperation) {

        if( !PreInstall ) {
            PWSTR p;

            p = SpGetSectionKeyIndex(
                    UnattendedSifHandle,
                    SIF_UNATTENDED,
                    SIF_CONFIRMHW,
                    0
                    );

            //
            // If not specified or specified and not "yes"
            // then return.
            //
            if(!p || _wcsicmp(p,L"yes")) {
                return;
            }
        } else {
            return;
        }
    } else if (LoadedScsiMiniportCount) {
        return;
    }

    ScsiConfirmed = FALSE;
    do {
        //
        // First part of the screen.
        //
        SpDisplayScreen(SP_SCRN_SCSI_LIST_1,3,HEADER_HEIGHT+1);

        //
        // Remember where the first part of the screen ends.
        //
        ListTopY = NextMessageTopLine + 2;

        //
        // Second part of the screen.
        //
        SpContinueScreen(
            SP_SCRN_SCSI_LIST_2,
            3,
            MAX_SCSI_MINIPORT_COUNT+6,
            FALSE,
            DEFAULT_ATTRIBUTE
            );

        //
        // Display each loaded miniport driver description.
        //
        if(ScsiHardware) {
            for(i=0,scsi=ScsiHardware; scsi; scsi=scsi->Next,i++) {

                if(i == MAX_SCSI_MINIPORT_COUNT) {

                    SpvidDisplayString(
                        L"...",
                        DEFAULT_ATTRIBUTE,
                        SCSI_LIST_LEFT_X,
                        ListTopY+i
                        );

                    break;
                }

                SpvidDisplayString(
                    scsi->Description,
                    DEFAULT_ATTRIBUTE,
                    SCSI_LIST_LEFT_X,
                    ListTopY+i
                    );
            }
        } else {

            SpDisplayFormattedMessage(
                SP_TEXT_ANGLED_NONE,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                SCSI_LIST_LEFT_X,
                ListTopY
                );
        }

        //
        // display status text options.
        //
        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_S_EQUALS_SCSI_ADAPTER,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        //
        // Wait for the user to press a valid key.
        //
        switch(SpWaitValidKey(ValidKeys,NULL,Mnemonics)) {

        case ASCI_CR:

            ScsiConfirmed = TRUE;
            break;

        case KEY_F3:

            SpConfirmExit();
            break;

        default:

            //
            // Must be s=specify additional adapter.
            //

            AddDriver = FALSE;

            scsi = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
            RtlZeroMemory(scsi,sizeof(HARDWARE_COMPONENT));

            b = SpSelectHwItem(
                    SifHandle,
                    ScsiSectionName,
                    L"Scsi",
                    SP_SCRN_SELECT_SCSI,
                    SP_SCRN_SELECT_OEM_SCSI,
                    SCSI_ALLOWED_FILETYPES,
                    SCSI_REQUIRED_FILETYPES,
                    scsi
                    );

            if(b) {
                //
                // User made a selection. Determine whether that scsi adapter
                // is already on the list for instllation.
                //
                PHARDWARE_COMPONENT p;

                b = FALSE;
                for(p=ScsiHardware; p; p=p->Next) {

                    if((p->ThirdPartyOptionSelected == scsi->ThirdPartyOptionSelected)
                    && !_wcsicmp(p->IdString,scsi->IdString))
                    {
                        b = TRUE;
                        break;
                    }
                }

                if(b) {
                    //
                    // The driver is already loaded -- silently ignore the user's selection.
                    //
                    #if 0
                    //
                    // This driver is already loaded -- tell the user.
                    //
                    SpDisplayScreen(SP_SCRN_SCSI_ALREADY_LOADED,3,HEADER_HEIGHT+1);
                    SpDisplayStatusOptions(
                        DEFAULT_STATUS_ATTRIBUTE,
                        SP_STAT_ENTER_EQUALS_CONTINUE,
                        0
                        );

                    SpInputDrain();
                    while(SpInputGetKeypress() != ASCI_CR) ;
                    #endif

                } else {

                    PWSTR DiskDevicePath;
                    PWSTR DirectoryOnDisk;
                    PWSTR DriverFilename;
                    PWSTR Media;

                    //
                    // The driver is not loaded.  Atempt to load it.
                    //
                    if(scsi->ThirdPartyOptionSelected) {

                        PHARDWARE_COMPONENT_FILE fil;

                        //
                        // Locate the first file of type driver or port.
                        //
                        for(fil=scsi->Files; fil; fil=fil->Next) {
                            if((fil->FileType == HwFileDriver) || (fil->FileType == HwFilePort)) {

                                DirectoryOnDisk = fil->Directory;
                                DriverFilename = fil->Filename;
                                break;
                            }
                        }

                        DiskDevicePath = L"\\device\\floppy0";

                    } else {

                        DiskDevicePath = SourceDevicePath;
                        DirectoryOnDisk = DirectoryOnSourceDevice;

                        SpGetDriverValuesForLoad(
                            SifHandle,
                            ScsiSectionName,
                            ScsiLoadSectionName,
                            scsi->IdString,
                            &DriverFilename,
                            &Media,
                            NULL
                            );

                        SpPromptForSetupMedia(
                            SifHandle,
                            Media,
                            DiskDevicePath
                            );
                    }

                    CLEAR_CLIENT_SCREEN();

                    Status = SpLoadDeviceDriver(
                                scsi->Description,
                                DiskDevicePath,
                                DirectoryOnDisk,
                                DriverFilename
                                );

                    //
                    // If the driver did not load, tell the user.
                    //
                    if(NT_SUCCESS(Status)) {
                        AddDriver = TRUE;
                    } else {
                        SpDisplayScreen(SP_SCRN_SCSI_DIDNT_LOAD,3,HEADER_HEIGHT+1);
                        SpDisplayStatusOptions(
                            DEFAULT_STATUS_ATTRIBUTE,
                            SP_STAT_ENTER_EQUALS_CONTINUE,
                            0
                            );

                        SpInputDrain();
                        while(SpInputGetKeypress() != ASCI_CR) ;
                    }
                }
            }

            if(AddDriver) {

                if(ScsiHardware) {

                    PHARDWARE_COMPONENT p = ScsiHardware;

                    while(p->Next) {
                        p = p->Next;
                    }
                    p->Next = scsi;

                } else {
                    ScsiHardware = scsi;
                }

                LoadedScsiMiniportCount++;

            } else {
                SpFreeHwComponent(&scsi,TRUE);
            }

            break;
        }
    } while(!ScsiConfirmed);
}


VOID
SpGetDriverValuesForLoad(
    IN  PVOID  SifHandle,
    IN  PWSTR  ComponentSectionName,
    IN  PWSTR  ComponentLoadSectionName,
    IN  PWSTR  Shortname,
    OUT PWSTR *Filename,
    OUT PWSTR *MediaDesignator,
    OUT PWSTR *Description OPTIONAL
    )
{
    PWSTR description,mediaDesignator,filename;

    //
    // Get the filename associated with this load option.
    //
    filename = SpGetSectionKeyIndex(SifHandle,ComponentLoadSectionName,Shortname,0);
    if(!filename) {
        SpFatalSifError(SifHandle,ComponentLoadSectionName,Shortname,0,0);
    }

    //
    // Look up the description in the component section.
    //
    description = SpGetSectionKeyIndex(
                        SifHandle,
                        ComponentSectionName,
                        Shortname,
                        INDEX_DESCRIPTION
                        );

    if(!description) {
        SpFatalSifError(SifHandle,ComponentSectionName,Shortname,0,INDEX_DESCRIPTION);
    }

    //
    // Look up the media designator.  If we are loading the driver for use
    // during setup, we want to get it from the setup boot media.
    //
    mediaDesignator = SpLookUpValueForFile(SifHandle,filename,INDEX_WHICHBOOTMEDIA,TRUE);

    //
    // Pass information back to caller.
    //
    *Filename = filename;
    *MediaDesignator = mediaDesignator;
    if(Description) {
        *Description = description;
    }
}


BOOLEAN
SpInstallingMp(
    VOID
    )
{
    PWSTR ComputerId;
    ULONG ComputerIdLen;

    ComputerId = HardwareComponents[HwComponentComputer]->IdString;
    ComputerIdLen = wcslen(ComputerId);

    //
    // If _up is specified use the up kernel.  Otherwise use the mp kernel.
    //
    if((ComputerIdLen >= 3) && !_wcsicmp(ComputerId+ComputerIdLen-3,L"_mp")) {

        return(TRUE);
    }

    return(FALSE);
}



PHARDWARE_COMPONENT
SpGetPreinstallComponentInfo(
    IN HANDLE       MasterSifHandle,
    IN BOOLEAN      OemComponent,
    IN PWSTR        ComponentName,
    IN PWSTR        Description,
    IN ULONG        AllowedFileTypes,
    IN ULONG        RequiredFileTypes
    )

/*++

Routine Description:

    Initialize a structure that contains the information about a
    component to be pre-installed.

Arguments:

    MasterSifHandle - Handle to txtsetup.sif.

    OemComponent - Flag that indicates if the component to be pre-installed
                   is an OEM or retail component.

    ComponentName - Name of the component whose information will be retrieved
                    (Computer, Display, Keyboard, Keyboard Layout and Mouse ).

    AllowedFileTypes -

    RequiredFileTypes -


Return Value:

    Returns a pointer to an initialized HARDWARE_COMPONENT structure.

--*/


{
    PHARDWARE_COMPONENT TempHwComponent;
    PWSTR               IdString;
    ULONG ValidKeys[2] = { KEY_F3,0 };


    TempHwComponent = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
    RtlZeroMemory(TempHwComponent,sizeof(HARDWARE_COMPONENT));

    if( !OemComponent ) {
        //
        //  Pre-install a retail component
        //
        IdString = SpGetKeyNameByValue( MasterSifHandle,
                                        ComponentName,
                                        Description );
        if( IdString == NULL ) {
            //
            //  This is a fatal error
            //
            SpStartScreen( SP_SCRN_OEM_PREINSTALL_VALUE_NOT_FOUND,
                           3,
                           HEADER_HEIGHT+3,
                           FALSE,
                           FALSE,
                           DEFAULT_ATTRIBUTE,
                           Description,
                           ComponentName);

            SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);
            SpWaitValidKey(ValidKeys,NULL,NULL);

            SpDone(0,FALSE,TRUE);

            return NULL;    // for prefix
        }
        
        SpInitHwComponent(TempHwComponent,IdString,Description,FALSE,0,NULL,FALSE);

    } else {
        //
        //  Pre-install an OEM component
        //
        IdString = SpGetKeyNameByValue( PreinstallOemSifHandle,
                                        ComponentName,
                                        Description );
        if( IdString == NULL ) {
            //
            //  Put a fatal error message indicating that txtsetup.oem
            //  is needed but that it couldn't be loaded. Note that the
            //  that SpOemInfError() will not return.
            //
            SpOemInfError(SP_SCRN_OEM_PREINSTALL_INF_ERROR,
                          SP_TEXT_OEM_INF_ERROR_B,
                          ComponentName,
                          0,
                          Description);

            // SpDone(0,FALSE,TRUE);
        }
        if( !SpOemInfSelection( PreinstallOemSifHandle,
                                ComponentName,
                                IdString,
                                Description,
                                AllowedFileTypes,
                                RequiredFileTypes,
                                TempHwComponent,
                                SP_SCRN_OEM_PREINSTALL_INF_ERROR ) ) {

            //
            //  This case shoud never occur, becase in case of error,
            //  SpOemInfSelection will not return.
            //
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpOemInfSelection() in pre-install mode failed \n" ));
            ASSERT(FALSE);
            // SpDone(0,FALSE,TRUE);
        }
    }
    return( TempHwComponent );
}


VOID
SpInitializePreinstallList(
    IN HANDLE       MasterSifHandle,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        OemPreinstallSourcePath
    )

/*++

Routine Description:

    Initialize the structures that contains the information about the
    components to be pre-installed.

Arguments:

    MasterSifHandle - Handle to txtsetup.sif.

    SetupSourceDevicePath - Path to the device that contains the source media.

    OemDirectoryOnSourceDevice - Directory on the media where the OEM
                                 components are loacted.


Return Value:

    NONE.

--*/

{
    PWSTR       TxtsetupOemPath;
    PWSTR       p;
    PWSTR       OemTag = L"OEM";
    BOOLEAN     OemComponent;
    NTSTATUS    Status;
    PHARDWARE_COMPONENT TempHwComponent;
    PWSTR       IdString;
    PWSTR       Description;
    ULONG       ErrorLine;
    ULONG       i,j;
#if defined(_AMD64_) || defined(_X86_)
    PWSTR       r, s;
#endif // defined(_AMD64_) || defined(_X86_)

#if defined(_AMD64_) || defined(_X86_)

    //
    //  First, we need to check if the directory '\$' exists on the root.
    //  if it does, we need to move it to (\$win_nt$.~ls\$OEM$).
    //  This will happen only when winnt.exe (DOS) was used in the installation
    //  process.
    //  Winnt.exe copies the $OEM$ to the '\$', in order to avoid hitting the
    //  DOS limitiation for the length of a path (maximum of 64 characters).
    //
    wcscpy(TemporaryBuffer, SetupSourceDevicePath);
    SpConcatenatePaths( TemporaryBuffer, WINNT_OEM_DEST_DIR_W );    
    r = SpDupStringW(TemporaryBuffer);

    if (r) {
        if( SpFileExists( r, TRUE ) ) {
            wcscpy(TemporaryBuffer, SetupSourceDevicePath);
            SpConcatenatePaths( TemporaryBuffer, PreinstallOemSourcePath );
            s = wcsrchr( TemporaryBuffer, (WCHAR)'\\' );

            if( s != NULL ) {
                *s = (WCHAR)'\0';
            }

            s = SpDupStringW(TemporaryBuffer);

            if (s) {
                Status = SpMoveFileOrDirectory( r, s );
                
                SpMemFree( s );
            } else {
                Status = STATUS_NO_MEMORY;
            }                

            if( !NT_SUCCESS( Status ) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, 
                    "SETUP: Unable to move directory %ws to %ws. Status = %lx \n", 
                    r, s, Status ));
            }
        }

        SpMemFree( r );
    }

#endif // defined(_AMD64_) || defined(_X86_)

    //
    //  Attempt to load txtsetup.oem
    //
    wcscpy( TemporaryBuffer, SetupSourceDevicePath );
    SpConcatenatePaths( TemporaryBuffer, OemPreinstallSourcePath );
    SpConcatenatePaths( TemporaryBuffer, L"txtsetup.oem" );
    TxtsetupOemPath = SpDupStringW( TemporaryBuffer );

    CLEAR_CLIENT_SCREEN();

    HandleLineContinueChars = FALSE;
    Status = SpLoadSetupTextFile(
                TxtsetupOemPath,
                NULL,                  // No image already in memory
                0,                     // Image size is empty
                &PreinstallOemSifHandle,
                &ErrorLine,
                TRUE,
                FALSE
                );
    HandleLineContinueChars = TRUE;

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to read txtsetup.oem. Status = %lx \n", Status ));

        PreinstallOemSifHandle = NULL;

        if(Status == STATUS_UNSUCCESSFUL) {
            //
            //  Put an fatal error. On pre-install mode, the function will
            //  never come back.
            //
            SpOemInfError(SP_SCRN_OEM_PREINSTALL_INF_ERROR,SP_TEXT_OEM_INF_ERROR_A,NULL,ErrorLine,NULL);
            return;
        } else {
            //
            //  Unable to load txtsetup.oem. Don't put an error message yet.
            //  Wait until we know that the file is needed.
            //
        }
    }

    for( j = 0; j < HwComponentMax; j++ ) {
        PreinstallHardwareComponents[j] = NULL;
        if( ( j == HwComponentComputer ) || ( j == HwComponentLayout ) ) {

            Description = SpGetSectionKeyIndex(UnattendedSifHandle,
                                               SIF_UNATTENDED,
                                               PreinstallSectionNames[j],
                                               0);

            if( Description != NULL ) {
                if( j != HwComponentLayout ) {
                    p = SpGetSectionKeyIndex(UnattendedSifHandle,
                                             SIF_UNATTENDED,
                                             PreinstallSectionNames[j],
                                             1);

                    OemComponent = (p != NULL) && (_wcsicmp(p, OemTag) == 0);

                    if( OemComponent && ( PreinstallOemSifHandle == NULL ) ) {
                        //
                        //  Put a fatal error message indicating that txtsetup.oem
                        //  is needed but that it couldn't be loaded. Note that the
                        //  SpOemInfError() will not return.
                        //
                        SpOemInfError(SP_SCRN_OEM_PREINSTALL_INF_ERROR,SP_TEXT_OEM_INF_ERROR_A,NULL,0,NULL);
                        // return;
                    }
                } else {
                    OemComponent = FALSE;
                }

                PreinstallHardwareComponents[j] =
                    SpGetPreinstallComponentInfo( MasterSifHandle,
                                                  OemComponent,
                                                  NonlocalizedComponentNames[j],
                                                  Description,
                                                  AllowedFileTypes[j],
                                                  RequiredFileTypes[j] );
            }
        } else {

            for( i = 0;
                 Description = SpGetKeyName( UnattendedSifHandle,
                                             PreinstallSectionNames[j],
                                             i );
                 i++ ) {

                p = SpGetSectionKeyIndex(UnattendedSifHandle,
                                         PreinstallSectionNames[j],
                                         Description,
                                         0);

                OemComponent = (p != NULL) && (_wcsicmp(p, OemTag) == 0);

                if( OemComponent && ( PreinstallOemSifHandle == NULL ) ) {
                    //
                    //  Put a fatal error message indicating that txtsetup.oem
                    //  is needed but that it couldn't be loaded. Note that the
                    //  SpOemInfError() will not return.
                    //
                    SpOemInfError(SP_SCRN_OEM_PREINSTALL_INF_ERROR,SP_TEXT_OEM_INF_ERROR_A,NULL,0,NULL);
                    // return;
                }

                TempHwComponent =
                    SpGetPreinstallComponentInfo( MasterSifHandle,
                                                  OemComponent,
                                                  NonlocalizedComponentNames[j],
                                                  Description,
                                                  AllowedFileTypes[j],
                                                  RequiredFileTypes[j] );

                TempHwComponent->Next = PreinstallHardwareComponents[j];
                PreinstallHardwareComponents[j] = TempHwComponent;
            }
        }
    }


    //
    //  Note that there is no need to get the information about the scsi
    //  drivers to pre-install, ScsiHardware already contains the correct
    //  information.
    //

// #if 0
    for( i = 0;
         Description = SpGetKeyName( UnattendedSifHandle,
                                     WINNT_OEMSCSIDRIVERS_W,
                                     i );
         i++ ) {

        p = SpGetSectionKeyIndex(UnattendedSifHandle,
                                 WINNT_OEMSCSIDRIVERS_W,
                                 Description,
                                 0);

        OemComponent = (p != NULL) && (_wcsicmp(p, OemTag) == 0);

        if( OemComponent && ( PreinstallOemSifHandle == NULL ) ) {
            //
            //  Put a fatal error message indicating that txtsetup.oem
            //  is needed but that it couldn't be loaded. Note that the
            //  SpOemInfError() will not return.
            //
            SpOemInfError(SP_SCRN_OEM_PREINSTALL_INF_ERROR,SP_TEXT_OEM_INF_ERROR_A,NULL,0,NULL);
            // return;
        }

        TempHwComponent =
            SpGetPreinstallComponentInfo( MasterSifHandle,
                                          OemComponent,
                                          L"SCSI",
                                          Description,
                                          SCSI_ALLOWED_FILETYPES,
                                          SCSI_REQUIRED_FILETYPES );

        TempHwComponent->Next = PreinstallScsiHardware;
        PreinstallScsiHardware = TempHwComponent;
    }


// #endif
}


PSETUP_PNP_HARDWARE_ID
SpSetupldrPnpDatabaseToSetupPnpDatabase(
    IN PPNP_HARDWARE_ID AnsiHardwareIdDatabase
    )

{
    PPNP_HARDWARE_ID        TempAnsiId;
    PSETUP_PNP_HARDWARE_ID  TempUnicodeId;
    PSETUP_PNP_HARDWARE_ID  UnicodeHardwareIdDatabase;
#if 0
    ULONG   Index;
#endif


    UnicodeHardwareIdDatabase = NULL;
    for( TempAnsiId = AnsiHardwareIdDatabase; TempAnsiId != NULL; TempAnsiId = TempAnsiId->Next ) {

        TempUnicodeId = SpMemAlloc( sizeof( SETUP_PNP_HARDWARE_ID ) );
        ASSERT(TempUnicodeId);
        RtlZeroMemory( TempUnicodeId, sizeof(SETUP_PNP_HARDWARE_ID ) );

        TempUnicodeId->Id = SpToUnicode( TempAnsiId->Id );
        ASSERT(TempUnicodeId->Id);
        TempUnicodeId->DriverName = SpToUnicode( TempAnsiId->DriverName );
        ASSERT(TempUnicodeId->DriverName);
        if( TempAnsiId->ClassGuid != NULL ) {
            TempUnicodeId->ClassGuid = SpToUnicode( TempAnsiId->ClassGuid );
        } else {
            TempUnicodeId->ClassGuid = NULL;
        }
        TempUnicodeId->Next = UnicodeHardwareIdDatabase;
        UnicodeHardwareIdDatabase = TempUnicodeId;

    }

#if 0
    for( TempUnicodeId = UnicodeHardwareIdDatabase, Index = 0;
         TempUnicodeId != NULL;
         TempUnicodeId = TempUnicodeId->Next, Index++ ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Index = %d, Id = %ls, DriverName = %ls, ClassGUID = %ls \n", Index, TempUnicodeId->Id, TempUnicodeId->DriverName, ((TempUnicodeId->ClassGuid)? TempUnicodeId->ClassGuid : none)));
    }
#endif
    return( UnicodeHardwareIdDatabase );
}

BOOLEAN
SpSelectSectionItem(
    IN    PVOID   SifHandle,
    IN    PWSTR   SectionName,
    IN    ULONG   SelectScreenId,
    IN    ULONG   DefaultSelection OPTIONAL,
    OUT   PULONG  SelectedOption
    )
/*++

Routine Description:

    Allow the user to make selection from a list of choices for a component.

    The list comes from a section in the setup information file named
    for the component.  For example, [Display].

    The descriptions in that section will be placed into a menu to make
    up the selections.
    
Arguments:

    SifHandle - supplies handle to open setup information file.

    SectionName - supplies name of section to be used.

    SelectHwScreenId - supplies message id of the screen prompting the user
        to select an option for this section.

    DefaultSelection - Item index, which should be highlighted as the default
        choice when the menu is shown
    
    SelectedOption - Returns the selected option        

Return Value:

    TRUE if a valid option is selected, otherwise FALSE

--*/
{
  BOOLEAN Result;
  ULONG LineCount,Line;
  PVOID Menu;
  ULONG MenuTopY,MenuHeight,MenuWidth;
  PWSTR Description;
  ULONG_PTR Selection;
  ULONG ValidKeys[4] = {ASCI_CR, ASCI_ESC, 0};
  ULONG Keypress;

  //
  // Display the selection prompt screen.
  //
  SpDisplayScreen(SelectScreenId, 5, HEADER_HEIGHT+1);

  MenuTopY = NextMessageTopLine + 2;
  MenuHeight = VideoVars.ScreenHeight - MenuTopY - 3;
  MenuWidth = VideoVars.ScreenWidth - 6;

  //
  // Create a menu.
  //
  Menu = SpMnCreate(3, MenuTopY, MenuWidth, MenuHeight);
  Result = (Menu != NULL);
  
  //
  // Assume unknown option.
  //
  Selection = (ULONG_PTR)(-1);
  
  //
  // Build a list of options containing the options in our box
  //
  LineCount = SpCountLinesInSection(SifHandle, SectionName);

  for(Line=0; (Line < LineCount) && Result; Line++) {
      //
      // Get the description from the current line and add it to the menu.
      //
      Description = SpGetSectionLineIndex(
                          SifHandle,
                          SectionName,
                          Line,
                          INDEX_DESCRIPTION
                          );

      if(!Description) {
        Result = FALSE;

        break;              
      }

      SpMnAddItem(Menu, Description, 3, VideoVars.ScreenWidth-6, TRUE, Line);

      //
      // See if this is the currently selected item.
      //
      if((DefaultSelection != -1) && (DefaultSelection == Line)) {
        Selection = Line;
      }
  }

  if (Result) {    
    if(Selection == (ULONG_PTR)(-1)) {
      Selection = 0;
    }

    //
    // Display the status text options.
    //
    SpDisplayStatusOptions(
        (UCHAR)(ATT_FG_BLACK | ATT_BG_WHITE),
        SP_STAT_ENTER_EQUALS_SELECT,
        SP_STAT_ESC_EQUALS_CANCEL,
        0
        );

    //
    // Display the menu.
    //
    SpMnDisplay(Menu, 
                Selection, 
                TRUE, 
                ValidKeys, 
                NULL, 
                NULL, 
                NULL,
                &Keypress,
                &Selection);

    //
    // Destroy the menu
    //
    SpMnDestroy(Menu);

    switch(Keypress) {
      case ASCI_CR:
          Result = TRUE;
          *SelectedOption = (ULONG)Selection;
          
          break;

      case ASCI_ESC:
          Result = FALSE;

          if (DefaultSelection != -1)
            *SelectedOption = (ULONG)Selection;
          
          break;

      default:
          Result = FALSE;
          break;
    }
  }

  return Result;
}


NTSTATUS
SpInitVirtualOemDevices(
    IN PSETUP_LOADER_BLOCK SetupLoaderBlock,
    OUT PVIRTUAL_OEM_SOURCE_DEVICE *SourceDevices
    )
/*++

Routine Description:

    Iterates through the virtual OEM source devices which loader
    created and converts them into VIRTUAL_OEM_SOURCE_DEVICE list.
    Also creates the required registry entries for each device 
    under RAM disk's parameters key.
    
Arguments:

    SetupLoaderBlock  - Setup loader block constructed by setupldr.

    SourceDevice - Place holder for receiving the pointer to
        head of the linked list of VIRTUAL_OEM_SOURCE_DEVICEs.
        
Return Value:

    Appropriate NTSTATUS code

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (SetupLoaderBlock && SourceDevices) {
        Status = STATUS_SUCCESS;

        //
        // Setupldr would have constructed its own version
        // of the virtual OEM source devices
        //
        if (SetupLoaderBlock->OemSourceDevices) {
            PVIRTUAL_OEM_SOURCE_DEVICE DeviceList = NULL;
            PDETECTED_OEM_SOURCE_DEVICE CurrDevice = SetupLoaderBlock->OemSourceDevices;
            ULONG DeviceCount = 0;
            
            //
            // Replicate the device list
            //
            while (CurrDevice) {
                PVIRTUAL_OEM_SOURCE_DEVICE NewDevice;

                NewDevice = SpMemAlloc(sizeof(VIRTUAL_OEM_SOURCE_DEVICE));

                if (!NewDevice) {
                    Status = STATUS_NO_MEMORY;
                    break;
                }

                RtlZeroMemory(NewDevice, sizeof(VIRTUAL_OEM_SOURCE_DEVICE));

                NewDevice->ArcDeviceName = SpToUnicode(CurrDevice->ArcDeviceName);

#if defined(_AMD64_) || defined(_X86_)                
                //
                // NOTE : Loader allocated "LoaderFirmwarePermanent" memory
                // so that memory manager while initializing doesn't
                // reclaim this memory. This also helps us to avoid 
                // double copy -- i.e. this is the only location
                // where we read the device contents into memory and 
                // this memory is valid through out the textmode setup so
                // just reuse the memory.
                //                                    
                NewDevice->ImageBase = CurrDevice->ImageBase;
#else
                //
                // NOTE : 05/13/2001 : LoaderFirmwarePermanent doesn't seem to work on non
                // x86 platforsm (particularly IA64). Till this issue is resolved
                // we have to allocate paged pool memory and replicate the disk
                // image in loader heap tracked by "CurrDevice->ImageBase".
                //
                NewDevice->ImageBase = SpMemAlloc((SIZE_T)(CurrDevice->ImageSize));

                if (NewDevice->ImageBase) {
                    memcpy(NewDevice->ImageBase, 
                        CurrDevice->ImageBase,
                        (SIZE_T)(CurrDevice->ImageSize));
                } else {                
                    Status = STATUS_NO_MEMORY;  // ran out of memory
                    
                    break;
                }                    
#endif // defined(_AMD64_) || defined(_X86_)
                NewDevice->ImageSize = CurrDevice->ImageSize;
                NewDevice->DeviceId = DeviceCount++;

                //
                // Insert the node at the head of the list
                //
                if (!DeviceList) {
                    DeviceList = NewDevice;
                } else {
                    NewDevice->Next = DeviceList;
                    DeviceList = NewDevice;
                }                    
                
                CurrDevice = CurrDevice->Next;
            }

            //
            // Sanity check
            //
            if (NT_SUCCESS(Status) && !DeviceList) {
                Status = STATUS_UNSUCCESSFUL;
            } 

            //
            // Setup the parameters for the RAM disk driver
            // to create appropriate device objects as
            // needed by us
            //
            if (NT_SUCCESS(Status) && DeviceList) {
                WCHAR   KeyName[MAX_PATH];
                UNICODE_STRING  RamDiskDriverName;
                OBJECT_ATTRIBUTES ObjectAttrs;
                HANDLE RamDiskDriverHandle = NULL;

                //
                // Create the service key
                //            
                swprintf(KeyName,
                    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\%ws",
                    RAMDISK_DRIVER_NAME
                    );

                INIT_OBJA(&ObjectAttrs, &RamDiskDriverName, KeyName);
                
                Status = ZwCreateKey(&RamDiskDriverHandle,
                            KEY_ALL_ACCESS,
                            &ObjectAttrs,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            NULL);

                if (NT_SUCCESS(Status)) {
                    UNICODE_STRING  ParamName;
                    OBJECT_ATTRIBUTES ParamAttrs;
                    HANDLE ParamHandle = NULL;

                    //
                    // Create the parameters key
                    //
                    INIT_OBJA(&ParamAttrs, &ParamName, L"Parameters");
                    ParamAttrs.RootDirectory = RamDiskDriverHandle;

                    Status = ZwCreateKey(&ParamHandle,
                                KEY_ALL_ACCESS,
                                &ParamAttrs,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                NULL);

                    if (NT_SUCCESS(Status)) {
                        WCHAR   ValueStr[MAX_PATH];
                        PVIRTUAL_OEM_SOURCE_DEVICE  CurrDevice = DeviceList;

                        //
                        // Create the regsitry values indicating the virtual
                        // devices for the Ram drive
                        //
                        while (CurrDevice) {
                            UNICODE_STRING  ValueName;
                            BYTE  Value[MAX_PATH * 2];
                            PBYTE ValuePtr = (PBYTE)Value;
                            ULONG ValueSize;
                            ULONGLONG ImageBase = (ULONGLONG)(ULONG_PTR)(CurrDevice->ImageBase);
                            ULONG ImageSize = (ULONG)(CurrDevice->ImageSize);
                            
                            swprintf(ValueStr, 
                                L"%ws%d", 
                                MS_RAMDISK_DRIVER_PARAM,
                                CurrDevice->DeviceId);                                            

                            memcpy(ValuePtr, &ImageBase, sizeof(ULONGLONG));
                            ValuePtr += sizeof(ULONGLONG);
                            memcpy(ValuePtr, &ImageSize, sizeof(ULONG));
                            ValuePtr += sizeof(ULONG);

                            ValueSize = (ULONG)(ULONG_PTR)(ValuePtr - Value);
                            
                            RtlInitUnicodeString(&ValueName, ValueStr);
                                                    
                            Status = ZwSetValueKey(ParamHandle,
                                        &ValueName,
                                        0,
                                        REG_BINARY,
                                        Value,
                                        ValueSize);

                            if (!NT_SUCCESS(Status)) {
                                break;
                            }

                            //
                            // process next device
                            //
                            CurrDevice = CurrDevice->Next;
                        }                

                        ZwClose(ParamHandle);
                    }

                    ZwClose(RamDiskDriverHandle);
                }
            }

            //
            // Initialize the return value only if we are successful
            //
            if (NT_SUCCESS(Status)) {
                *SourceDevices = DeviceList;                
            }
        } else {
            *SourceDevices = NULL;
        }            
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\splddrv.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    sploaddrv.c

Abstract:

    Routines to load sets of device drivers for use during text setup.

Author:

    Ted Miller (tedm) 13-November-1993

Revision History:

--*/

#include "spprecmp.h"
#pragma hdrstop

//
// Define type of routine used by the device driver set loader.
// Before each driver is loaded, this routine is called with
// a flag indicating whether the machine is an MCA machine and
// the shortname of the driver about to be loaded.  If this routine
// returns FALSE, the driver is not loaded.  If it returns TRUE,
// the driver is loaded.
//
typedef
BOOLEAN
(*PDRIVER_VERIFY_LOAD_ROUTINE) (
    IN PVOID   SifHandle,
    IN BOOLEAN IsMcaMachine,
    IN PWSTR   DriverShortname
    );



BOOLEAN
pSpVerifyLoadDiskDrivers(
    IN PVOID   SifHandle,
    IN BOOLEAN IsMcaMachine,
    IN PWSTR   DriverShortname
    )
{
    UNREFERENCED_PARAMETER(SifHandle);

    //
    // Don't load fat if setupldr loaded floppy drivers.
    //
    if(!_wcsicmp(DriverShortname,L"Fat") && SetupParameters.LoadedFloppyDrivers) {
        return(FALSE);
    }

    //
    // On an MCA machine, don't load atdisk.
    // On a non-MCA machine, don't load abiosdsk.
    //
    if(( IsMcaMachine && !_wcsicmp(DriverShortname,L"atdisk"))
    || (!IsMcaMachine && !_wcsicmp(DriverShortname,L"abiosdsk")))
    {
        return(FALSE);
    }

    //
    // If we get this far, the driver should be loaded.
    //
    return(TRUE);
}


VOID
SpLoadDriverSet(
    IN PVOID                        SifHandle,
    IN PWSTR                        SifSectionName,
    IN PWSTR                        SourceDevicePath,
    IN PWSTR                        DirectoryOnSourceDevice,
    IN PDRIVER_VERIFY_LOAD_ROUTINE  VerifyLoad                  OPTIONAL
    )

/*++

Routine Description:

    Load a set of device drivers listed in a section in the setup
    information file.  The section is expected to be in the following form:

        [SectionName.Load]
        DriverShortname = DriverFilename
        DriverShortname = DriverFilename
        DriverShortname = DriverFilename
        etc.

        [SectionName]
        DriverShortname = Description
        DriverShortname = Description
        DriverShortname = Description
        etc.

    The drivers will be loaded from the setup boot media, and errors
    loading the drivers will be ignored.

    Before loading each driver, a callback routine is called to verify
    that the driver should actually be loaded.  This allows the caller
    to gain a fine degree of control over which drivers are loaded.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    SifSectionName - supplies name of section in setup information file
        listing drivers to be laoded.

    SourceDevicePath - supplies the device path in the nt namespace of
        the device from which the drivers are to be loaded.

    DirectoryOnSourceDevice - supplies the directory on the source device
        from which the drivers are to be loaded.

    VerifyLoad - if specified, supplies the address of a routine to be
        called before each driver is loaded.  The routine takes a flag
        indicating whether the machine is an MCA machine, and the driver
        shortname.  If the routine returns false, the driver is not loaded.
        If this parameter is not specified, all drivers in the section
        will be loaded.

Return Value:

    None.

--*/

{
    BOOLEAN IsMcaMachine;
    ULONG d,DriverLoadCount;
    PWSTR DiskDesignator,PreviousDiskDesignator;
    PWSTR DriverShortname,DriverFilename,DriverDescription;
    PWSTR LoadSectionName;
    NTSTATUS Status;

    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_PLEASE_WAIT,DEFAULT_STATUS_ATTRIBUTE);

    //
    // Form the .load section name.
    //
    LoadSectionName = SpMemAlloc((wcslen(SifSectionName)*sizeof(WCHAR))+sizeof(L".Load"));
    wcscpy(LoadSectionName,SifSectionName);
    wcscat(LoadSectionName,L".Load");

    IsMcaMachine = FALSE;

    //
    // Set up some initial state.
    //
    PreviousDiskDesignator = L"";

    //
    // Determine the number of drivers to be loaded.
    //
    DriverLoadCount = SpCountLinesInSection(SifHandle,LoadSectionName);
    for(d=0; d<DriverLoadCount; d++) {

        PWSTR p;

        //
        // Get the driver shortname.
        //
        DriverShortname = SpGetKeyName(SifHandle,LoadSectionName,d);
        if(!DriverShortname) {
            SpFatalSifError(SifHandle,LoadSectionName,NULL,d,(ULONG)(-1));
        }

        //
        // Determine whether we are really supposed to load this driver.
        //
        if((p = SpGetSectionLineIndex(SifHandle,LoadSectionName,d,2)) && !_wcsicmp(p,L"noload")) {
            continue;
        }

        if(VerifyLoad && !VerifyLoad(SifHandle,IsMcaMachine,DriverShortname)) {
            continue;
        }

        //
        // Get a human-readable description for this driver.
        //
        DriverDescription = SpGetSectionLineIndex(SifHandle,SifSectionName,d,0);
        if(!DriverDescription) {
            SpFatalSifError(SifHandle,SifSectionName,NULL,d,0);
        }

        //
        // Get the driver filename.
        //
        DriverFilename = SpGetSectionLineIndex(SifHandle,LoadSectionName,d,0);
        if(!DriverFilename) {
            SpFatalSifError(SifHandle,LoadSectionName,NULL,d,0);
        }

        //
        // Determine the disk on which this driver resides.
        //
        DiskDesignator = SpLookUpValueForFile(
                            SifHandle,
                            DriverFilename,
                            INDEX_WHICHBOOTMEDIA,
                            TRUE
                            );

        //
        // Prompt for the disk containing the driver.
        //
        retryload:
        if(_wcsicmp(DiskDesignator,PreviousDiskDesignator)) {

            SpPromptForSetupMedia(
                SifHandle,
                DiskDesignator,
                SourceDevicePath
                );

            PreviousDiskDesignator = DiskDesignator;

            CLEAR_CLIENT_SCREEN();
            SpDisplayStatusText(SP_STAT_PLEASE_WAIT,DEFAULT_STATUS_ATTRIBUTE);
        }

        //
        // Attempt to load the driver.
        //
        Status = SpLoadDeviceDriver(
                    DriverDescription,
                    SourceDevicePath,
                    DirectoryOnSourceDevice,
                    DriverFilename
                    );

        if(Status == STATUS_NO_MEDIA_IN_DEVICE) {
            PreviousDiskDesignator = L"";
            goto retryload;
        }
    }

    SpMemFree(LoadSectionName);
}


VOID
SpLoadScsiClassDrivers(
    IN PVOID SifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice
    )

/*++

Routine Description:

    Load scsi class drivers if setupldr has not already loaded them
    and there are any miniport drivers loaded.

    The drivers to be loaded are listed in [ScsiClass].
    The section is expected to be in the following form:

        [ScsiClass]
        cdrom  = "SCSI CD-ROM"     ,scsicdrm.sys
        floppy = "SCSI Floppy Disk",scsiflop.sys
        disk   = "SCSI Disk"       ,scsidisk.sys

    The drivers will be loaded from the setup boot media, and errors
    loading the drivers will be ignored.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    SourceDevicePath - supplies the device path in the nt namespace of
        the device from which the drivers are to be loaded.

    DirectoryOnSourceDevice - supplies the directory on the source device
        where the drivers are to be found.

Return Value:

    None.

--*/

{
    //
    // If setupldr loaded scsi drivers, nothing to do.
    // If there are no miniport drivers loaded, nothing to do.
    //
    if(!SetupParameters.LoadedScsi && LoadedScsiMiniportCount) {

        SpLoadDriverSet(
            SifHandle,
            SIF_SCSICLASSDRIVERS,
            SourceDevicePath,
            DirectoryOnSourceDevice,
            NULL
            );
    }
}


VOID
SpLoadDiskDrivers(
    IN PVOID SifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice
    )

/*++

Routine Description:

    Load (non-scsi) disk class drivers and disk filesystems
    if setupldr has not already loaded them.

    The drivers to be loaded are listed in [DiskDrivers] and [FileSystems].
    The section is expected to be in the following form:

        [DiskDrivers]
        atdisk   = "ESDI/IDE Hard DIsk",atdisk.sys
        abiosdsk = "Micro Channel Hard Disk",abiosdsk.sys

        [FileSystems]
        fat      = "FAT File System",fastfat.sys
        ntfs     = "Windows NT File System (NTFS)",ntfs.sys


    The drivers will be loaded from the setup boot media, and errors
    loading the drivers will be ignored.

    On MCA machines, atdisk will not be loaded.
    On non-MCA machines, abiosdsk will not be loaded.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    SourceDevicePath - supplies the device path in the nt namespace of
        the device from which the drivers are to be loaded.

    DirectoryOnSourceDevice - supplies the directory on the source device
        where the drivers are to be found.

Return Value:

    None.

--*/

{
    //
    // If setupldr loaded disk drivers, nothing to do.
    //
    if(!SetupParameters.LoadedDiskDrivers) {

        SpLoadDriverSet(
            SifHandle,
            SIF_DISKDRIVERS,
            SourceDevicePath,
            DirectoryOnSourceDevice,
            pSpVerifyLoadDiskDrivers
            );
    }
    //
    // If setupldr loaded file systems, nothing to do.
    //
    if(!SetupParameters.LoadedFileSystems) {

        SpLoadDriverSet(
            SifHandle,
            SIF_FILESYSTEMS,
            SourceDevicePath,
            DirectoryOnSourceDevice,
            pSpVerifyLoadDiskDrivers
            );
    }

}

VOID
SpLoadCdRomDrivers(
    IN PVOID SifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice
    )

/*++

Routine Description:

    Load the cd-rom filesystem if setupldr has not already loaded it.

    The drivers to be loaded are listed in [CdRomDrivers].
    The section is expected to be in the following form:

        [CdRomDrivers]
        cdfs = "CD-ROM File System",cdfs.sys


    The drivers will be loaded from the setup boot media, and errors
    loading the drivers will be ignored.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    SourceDevicePath - supplies the device path in the nt namespace of
        the device from which the drivers are to be loaded.

    DirectoryOnSourceDevice - supplies the directory on the source device
        where the drivers are to be found.

Return Value:

    None.

--*/

{
    //
    // If setupldr loaded cd-rom drivers, nothing to do.
    //
    if(!SetupParameters.LoadedCdRomDrivers) {

        SpLoadDriverSet(
            SifHandle,
            SIF_CDROMDRIVERS,
            SourceDevicePath,
            DirectoryOnSourceDevice,
            NULL
            );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spmemory.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spmemory.h

Abstract:

    Public Header file for memory allocation routines
    for text setup.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:

--*/


#ifndef _SPMEM_DEFN_
#define _SPMEM_DEFN_


PVOID
SpMemAlloc(
    IN SIZE_T Size
    );

PVOID
SpMemAllocEx(
    IN SIZE_T Size,
    IN ULONG Tag,
    IN POOL_TYPE Type
    );

PVOID
SpMemAllocNonPagedPool(
    IN SIZE_T Size
    );

PVOID
SpMemRealloc(
    IN PVOID Block,
    IN SIZE_T NewSize
    );

VOID
SpMemFree(
    IN PVOID Block
    );

VOID
SpOutOfMemory(
    VOID
    );

#endif // ndef _SPMEM_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spmenu.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spmenu.c

Abstract:

    Text setup menu support.

Author:

    Ted Miller (tedm) 8-September-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop

#define MENUITEM_NORMAL     0x00000000
#define MENUITEM_STATIC     0x00000001


typedef struct _MENU_ITEM {

    PWSTR Text;

    ULONG Flags;

    ULONG LeftX;

    ULONG_PTR UserData;

    ULONG OriginalLength;

} MENU_ITEM, *PMENU_ITEM;


typedef struct _MENU {

    PMENU_ITEM Items;
    ULONG      ItemCount;

    ULONG      TopY;
    ULONG      Height;

    ULONG      LeftX;
    ULONG      Width;

    ULONG      TopDisplayedIndex;

    BOOLEAN    MoreUp,MoreDown;

} MENU, *PMENU;



VOID
pSpMnDrawMenu(
    IN PMENU   pMenu,
    IN ULONG   SelectedIndex,
    IN BOOLEAN DrawFrame,
    IN BOOLEAN IndicateMore,
    IN PWSTR   MoreUpText,
    IN PWSTR   MoreDownText
    );


PVOID
SpMnCreate(
    IN ULONG   LeftX,
    IN ULONG   TopY,
    IN ULONG   Width,
    IN ULONG   Height
    )

/*++

Routine Description:

    Create a new menu by allocating space for a new menu structure
    and initializing its fields.

Arguments:

    LeftX - supplies the 0-based X coordinate of the leftmost column
        of the menu.

    TopY - supplies the 0-based Y coordinate of the topmost line
        of the menu.

    Width - supplies the maximum displayed width for lines in the menu.

    Height - supplies the maximum displayed height of the menu.
        The menu will scroll if it is too long to fit in the
        allotted space.

Return Value:

    Menu handle (expressed as a pvoid) of NULL if memory couldn't
    be allocated.

--*/

{
    PMENU p;

    if(p = SpMemAlloc(sizeof(MENU))) {

        RtlZeroMemory(p,sizeof(MENU));

        if(p->Items = SpMemAlloc(0)) {
            p->LeftX = LeftX;
            p->TopY = TopY;
            p->Width = Width;
            p->Height = Height;
        } else {
            SpMemFree(p);
            p = NULL;
        }
    }

    return(p);
}


VOID
SpMnDestroy(
    IN PVOID Menu
    )

/*++

Routine Description:

    Destroy a menu, releasing all memory associated with it.

Arguments:

    Menu - supplies handle to menu to destroy.

Return Value:

    None.

--*/

{
    PMENU pMenu = Menu;
    ULONG u;

    for(u=0; u<pMenu->ItemCount; u++) {
        if(pMenu->Items[u].Text) {
            SpMemFree(pMenu->Items[u].Text);
        }
    }

    SpMemFree(pMenu->Items);

    SpMemFree(pMenu);
}



BOOLEAN
SpMnAddItem(
    IN PVOID   Menu,
    IN PWSTR   Text,
    IN ULONG   LeftX,
    IN ULONG   Width,
    IN BOOLEAN Selectable,
    IN ULONG_PTR UserData
    )

/*++

Routine Description:

    Add an item to a menu.

Arguments:

    Menu - supplies handle to menu to which the item is to be added.

    Text - supplies text that comprises the menu selection.  This routine
        will make a copy of the text.

    LeftX - supplies 0-based x coordinate of leftmost character of the text
        when it is displayed.

    Width - supplies width in characters of the field for this selection.
        If this is larger than the number of characters in the text, then
        the text is padded to the right with blanks when highlighted.

    Selectable - if FALSE, then this text is static -- ie, not selectable.

    UserData - supplies a ulong's worth of caller-specific data to be associated
        with this menu item.

Return Value:

    TRUE if the menu item was added successfully; FALSE if insufficient memory.

--*/

{
    PMENU pMenu = Menu;
    PMENU_ITEM p;
    ULONG TextLen;
    ULONG PaddedLen;
    PWSTR String;
    ULONG u;
    ULONG ColumnLen;
    ULONG FillLen;

    //
    // Build a string that is padded to the right with blanks to make
    // it the right width.
    //
    TextLen = wcslen(Text);
    PaddedLen = max(TextLen,Width);
    ColumnLen = SplangGetColumnCount(Text);
    FillLen = (PaddedLen <= ColumnLen) ? 0 : PaddedLen - ColumnLen;

    String = SpMemAlloc((PaddedLen+1)*sizeof(WCHAR));
    if(!String) {
        return(FALSE);
    }

    wcsncpy(String,Text,TextLen);
    for(u=0; u<FillLen; u++) {
        String[TextLen+u] = L' ';
    }
    String[TextLen+u] = 0;

    //
    // Make space for the item.
    //
    if((p = SpMemRealloc(pMenu->Items,(pMenu->ItemCount+1) * sizeof(MENU_ITEM))) == NULL) {
        SpMemFree(String);
        return(FALSE);
    }

    pMenu->Items = p;

    //
    // Calculate the address of the new menu item and
    // indicate that there is now an additional item in the menu.
    //
    p = &pMenu->Items[pMenu->ItemCount++];

    //
    // Set the fields of the menu.
    //
    p->LeftX = LeftX;
    p->UserData = UserData;

    p->Flags = Selectable ? MENUITEM_NORMAL : MENUITEM_STATIC;

    p->Text = String;

    p->OriginalLength = TextLen;

    return(TRUE);
}


PWSTR
SpMnGetText(
    IN PVOID Menu,
    IN ULONG_PTR UserData
    )
{
    PMENU pMenu = Menu;
    ULONG i;

    for(i=0; i<pMenu->ItemCount; i++) {
        if(pMenu->Items[i].UserData == UserData) {
            return(pMenu->Items[i].Text);
        }
    }

    return(NULL);
}

PWSTR
SpMnGetTextDup(
    IN PVOID Menu,
    IN ULONG_PTR UserData
    )
{
    PMENU pMenu = Menu;
    ULONG i;
    PWSTR p;

    for(i=0; i<pMenu->ItemCount; i++) {
        if(pMenu->Items[i].UserData == UserData) {
            //
            // Make a duplicate; leave off trailing pad spaces.
            //
            p = SpMemAlloc((pMenu->Items[i].OriginalLength+1)*sizeof(WCHAR));
            wcsncpy(p,pMenu->Items[i].Text,pMenu->Items[i].OriginalLength);
            p[pMenu->Items[i].OriginalLength] = 0;
            return(p);
        }
    }

    return(NULL);
}


VOID
SpMnDisplay(
    IN  PVOID                               Menu,
    IN  ULONG_PTR                           UserDataOfHighlightedItem,
    IN  BOOLEAN                             Framed,
    IN  PULONG                              ValidKeys,
    IN  PULONG                              Mnemonics,               OPTIONAL
    IN  PMENU_CALLBACK_ROUTINE              NewHighlightCallback,    OPTIONAL
    IN  PMENU_SELECTION_CALLBACK_ROUTINE    SelectionCallbackRoutine,OPTIONAL
    OUT PULONG                              KeyPressed,
    OUT PULONG_PTR                          UserDataOfSelectedItem
    )

/*++

Routine Description:

    Display a menu and accept keystrokes.

    When the user presses a menu keystroke (up/down arrow keys), this
    routine automatically updates the highlight and calls a callback function
    to inform the caller that a new item has the highlight.

    When the user presses a keystroke in a list provided by the caller,
    this routine returns, providing information about the key pressed and
    the item that was highlighted when the key was pressed.

Arguments:

    Menu - supplies handle to menu to be displayed.

    UserDataOfHighlightedItem - supplies user data of the menu item which
        is to receive the highlight initially.

    Framed - if TRUE, then draw a single-line bordera around the menu.

    ValidKeys - supplies a list of keystrokes that cause this routine to
        return to the caller.  The list must be terminated with a 0 entry.

    NewHighlightCallback - If specified, supplies a routine to be called
        when a new item has received the highlight.

    SelectionCallbackRoutine - If specified, supplies a routine to be called
        when a item in the menu is selected.

    KeyPressed - receives the key press that caused this routine to exit.
        This will be a valid from the ValidKeys array.

    UserDataOfSelectedItem - receives the UserData of the item that had the
        highlight when the user pressed a key in ValidKeys.

Return Value:

    None.

--*/


{
    ULONG ValidMenuKeys[3] = { KEY_UP, KEY_DOWN, 0 };
    ULONG key;
    PMENU pMenu = Menu;
    ULONG SelectedIndex,OldIndex;
    BOOLEAN FoundNewItem;
    ULONG NewTopDisplayedIndex;
    BOOLEAN MustScroll;
    PWSTR MoreUpText,MoreDownText;


    //
    // Get the text for the text that indicate that there are more
    // selections.
    //
    SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_TEXT_MORE_UP);
    MoreUpText = SpDupStringW(TemporaryBuffer);
    SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_TEXT_MORE_DOWN);
    MoreDownText = SpDupStringW(TemporaryBuffer);

    //
    // Locate the seleccted item.
    //
    for(SelectedIndex=0; SelectedIndex<pMenu->ItemCount; SelectedIndex++) {
        if(!(pMenu->Items[SelectedIndex].Flags & MENUITEM_STATIC)
        && (pMenu->Items[SelectedIndex].UserData == UserDataOfHighlightedItem))
        {
            break;
        }
    }
    ASSERT(SelectedIndex < pMenu->ItemCount);

    //    
    // In free builds we bugcheck later on because of it being equal so 
    // inserting code to handle this situation even if it is a remote case
    // but can occur.
    //
    if (SelectedIndex >= pMenu->ItemCount){
        SelectedIndex = pMenu->ItemCount - 1;
    }
    

    //
    // Make sure the selected item will be visible when we draw the menu.
    //
    pMenu->TopDisplayedIndex = 0;
    while(SelectedIndex >= pMenu->TopDisplayedIndex + pMenu->Height) {
        pMenu->TopDisplayedIndex += pMenu->Height;
    }

    //
    // Draw the menu itself.
    //
    pSpMnDrawMenu(pMenu,SelectedIndex,Framed,Framed,MoreUpText,MoreDownText);

    while(1) {

        //
        // Wait for a valid keypress.
        //
        key = SpWaitValidKey(ValidKeys,ValidMenuKeys,Mnemonics);

        //
        // If the key is a menu keystroke, handle it here.
        //
        FoundNewItem = FALSE;
        MustScroll = FALSE;
        OldIndex = SelectedIndex;

        switch(key) {

        case KEY_UP:

            //
            // Locate the previous selectable item.
            //
            if(SelectedIndex) {

                for(SelectedIndex=SelectedIndex-1; (LONG)SelectedIndex>=0; SelectedIndex--) {
                    if(!(pMenu->Items[SelectedIndex].Flags & MENUITEM_STATIC)) {
                        FoundNewItem = TRUE;
                        break;
                    }
                }

                if(FoundNewItem) {
                    //
                    // Figure out whether we have to scroll the menu.
                    //
                    if(SelectedIndex < pMenu->TopDisplayedIndex) {
                        MustScroll = TRUE;
                        NewTopDisplayedIndex = SelectedIndex;
                    }
                } else {
                    //
                    // If the first lines are static text, there might be no
                    // way to get them back on the screen -- the tests above
                    // fail in this case.  So if the user hits the up arrow
                    // when he's at the topmost selectable item but there are
                    // static items above him, we'll simply scroll the menu
                    // so that item #0 is at the top.
                    //
                    FoundNewItem = TRUE;
                    NewTopDisplayedIndex = 0;
                    MustScroll = TRUE;
                    SelectedIndex = OldIndex;
                }
            }
            break;

        case KEY_DOWN:

            //
            // Locate the next selectable item.
            //
            if(SelectedIndex < pMenu->ItemCount) {

                for(SelectedIndex=SelectedIndex+1; SelectedIndex < pMenu->ItemCount; SelectedIndex++) {

                    if(!(pMenu->Items[SelectedIndex].Flags & MENUITEM_STATIC)) {
                        FoundNewItem = TRUE;
                        break;
                    }
                }

                if(FoundNewItem) {
                    //
                    // Figure out whether we have to scroll the menu.
                    //
                    if(SelectedIndex >= pMenu->TopDisplayedIndex + pMenu->Height) {
                        MustScroll = TRUE;
                        NewTopDisplayedIndex = pMenu->TopDisplayedIndex + SelectedIndex - OldIndex;
                    }
                }
            }
            break;

        default:
            if (SelectionCallbackRoutine){
                if (!SelectionCallbackRoutine(pMenu->Items[SelectedIndex].UserData, 
                                          key)){

                    continue;
                }                
            }

            //
            // User pressed a non-menu key.
            //
            *KeyPressed = key;
            *UserDataOfSelectedItem = pMenu->Items[SelectedIndex].UserData;

            SpMemFree(MoreUpText);
            SpMemFree(MoreDownText);
            return;

        }


        if(FoundNewItem) {

            //
            // Unhighlight the currently selected item.
            //
            SpvidDisplayString(
                pMenu->Items[OldIndex].Text,
                DEFAULT_ATTRIBUTE,
                pMenu->Items[OldIndex].LeftX,
                pMenu->TopY + OldIndex - pMenu->TopDisplayedIndex
                );


            //
            // Highlight the newly selected item.  This may involve
            // scrolling the menu.
            //
            if(MustScroll) {
                //
                // Redraw the menu so the newly highlighted line is in view.
                //
                pMenu->TopDisplayedIndex = NewTopDisplayedIndex;

                pSpMnDrawMenu(pMenu,SelectedIndex,FALSE,Framed,MoreUpText,MoreDownText);
            }

            //
            // Highlight the newly selected item.
            //
            SpvidDisplayString(
                pMenu->Items[SelectedIndex].Text,
                ATT_BG_WHITE | ATT_FG_BLUE,
                pMenu->Items[SelectedIndex].LeftX,
                pMenu->TopY + SelectedIndex - pMenu->TopDisplayedIndex
                );


            //
            // Inform the caller.
            //
            if(NewHighlightCallback){
                NewHighlightCallback(pMenu->Items[SelectedIndex].UserData);
            }

        } else {
            SelectedIndex = OldIndex;
        }
    }
}


VOID
pSpMnDrawMenu(
    IN PMENU   pMenu,
    IN ULONG   SelectedIndex,
    IN BOOLEAN DrawFrame,
    IN BOOLEAN IndicateMore,
    IN PWSTR   MoreUpText,
    IN PWSTR   MoreDownText
    )
{
    ULONG item;
    BOOLEAN MoreUp,MoreDown,MoreStatusChanged;

    //
    // Blank out the on-screen menu display.
    //
    SpvidClearScreenRegion(
        pMenu->LeftX,
        pMenu->TopY,
        pMenu->Width,
        pMenu->Height,
        DEFAULT_BACKGROUND
    );


    MoreUp = (BOOLEAN)(pMenu->TopDisplayedIndex > 0);
    MoreDown = (BOOLEAN)(pMenu->TopDisplayedIndex + pMenu->Height < pMenu->ItemCount);

    //
    // We want to force the frame to be drawn if there is a change in whether
    // there are more selections above or below us.
    //
    MoreStatusChanged = (BOOLEAN)(    IndicateMore
                                   && (    (pMenu->MoreUp != MoreUp)
                                        || (pMenu->MoreDown != MoreDown)
                                      )
                                 );

    if(DrawFrame || MoreStatusChanged) {

        ASSERT(pMenu->LeftX);
        ASSERT(pMenu->TopY);

        SpDrawFrame(
            pMenu->LeftX-1,
            pMenu->Width+2,
            pMenu->TopY-1,
            pMenu->Height+2,
            DEFAULT_ATTRIBUTE,
            FALSE
            );
    }

    //
    // Draw each item that is currently on-screen.
    //
    ASSERT(pMenu->TopDisplayedIndex < pMenu->ItemCount);
    for(item = pMenu->TopDisplayedIndex;
        item < min(pMenu->TopDisplayedIndex+pMenu->Height,pMenu->ItemCount);
        item++)
    {
        SpvidDisplayString(
            pMenu->Items[item].Text,
            (UCHAR)((item == SelectedIndex) ? ATT_BG_WHITE | ATT_FG_BLUE : DEFAULT_ATTRIBUTE),
            pMenu->Items[item].LeftX,
            pMenu->TopY + item - pMenu->TopDisplayedIndex
            );
    }


    //
    // If there are more selections above or below us,
    // indicate so by placing a small bit of text on the frame.
    // Note that the arrow chars can sometimes be DBCS.
    //
    if(MoreStatusChanged) {

        if(MoreUp) {
            SpvidDisplayString(
                MoreUpText,
                DEFAULT_ATTRIBUTE,
                pMenu->LeftX + pMenu->Width - SplangGetColumnCount(MoreUpText) - 1,
                pMenu->TopY - 1
                );
        }

        if(MoreDown) {
            SpvidDisplayString(
                MoreDownText,
                DEFAULT_ATTRIBUTE,
                pMenu->LeftX + pMenu->Width - SplangGetColumnCount(MoreDownText) - 1,
                pMenu->TopY + pMenu->Height
                );
        }

        pMenu->MoreUp = MoreUp;
        pMenu->MoreDown = MoreDown;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spmsg.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spmsg.h

Abstract:

    Public header file for text message functions in text setup.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:

--*/



#ifndef _SPMSG_DEFN_
#define _SPMSG_DEFN_


VOID
vSpFormatMessage(
    OUT PVOID    LargeBuffer,
    IN  ULONG    BufferSize,
    IN  ULONG    MessageId,
    OUT PULONG   ReturnLength, OPTIONAL
    IN  va_list *arglist
    );

VOID
SpFormatMessage(
    OUT PVOID LargeBuffer,
    IN  ULONG BufferSize,
    IN  ULONG MessageId,
    ...
    );

VOID
vSpFormatMessageText(
    OUT PVOID    LargeBuffer,
    IN  ULONG    BufferSize,
    IN  PWSTR    MessageText,
    OUT PULONG   ReturnLength, OPTIONAL
    IN  va_list *arglist
    );

VOID
SpFormatMessageText(
    OUT PVOID   LargeBuffer,
    IN  ULONG   BufferSize,
    IN  PWSTR   MessageText,
    ...
    );


extern PVOID ResourceImageBase;

#endif // ndef _SPMSG_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spmemory.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spmemory.c

Abstract:

    Memory allocation routines for text setup.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:

--*/



#include "spprecmp.h"
#pragma hdrstop

PVOID
SpMemAlloc(
    IN SIZE_T Size
    )
{
    return(SpMemAllocEx(Size,'pteS', PagedPool));
}

PVOID
SpMemAllocNonPagedPool(
    IN SIZE_T Size
    )
{
    return(SpMemAllocEx(Size,'pteS', NonPagedPool));
}

PVOID
SpMemAllocEx(
    IN SIZE_T Size,
    IN ULONG Tag,
    IN POOL_TYPE Type
    )

/*++

Routine Description:

    This function is guaranteed to succeed.

Arguments:

Return Value:

--*/

{
    PSIZE_T p;

    //
    // Add space for storing the size of the block.
    //
#if defined(SETUP_TEST_USERMODE)
    p = RtlAllocateHeap(RtlProcessHeap(), 0, Size + (2 * sizeof(SIZE_T)));
#else
    p = ExAllocatePoolWithTag(Type, Size + (2 * sizeof(SIZE_T)), Tag);
#endif

    if(!p) {

        SpOutOfMemory();
    }

    //
    // Store the size of the block, and return the address
    // of the user portion of the block.
    //
    *p = Tag;
    *(p + 1) = Size;

    return(p + 2);
}



PVOID
SpMemRealloc(
    IN PVOID Block,
    IN SIZE_T NewSize
    )

/*++

Routine Description:

    This function is guaranteed to succeed.

Arguments:

Return Value:

--*/

{
    PSIZE_T NewBlock;
    SIZE_T  OldSize;
    ULONG   OldTag;

    //
    // Get the size of the block being reallocated.
    //
    OldTag = (ULONG)((PSIZE_T)Block)[-2];
    OldSize = ((PSIZE_T)Block)[-1];

    //
    // Allocate a new block of the new size.
    //
    NewBlock = SpMemAllocEx(NewSize, OldTag, PagedPool);
    ASSERT(NewBlock);

    //
    // Copy the old block to the new block.
    //
    if (NewSize < OldSize) {
        RtlCopyMemory(NewBlock, Block, NewSize);
    } else {
        RtlCopyMemory(NewBlock, Block, OldSize);
    }

    //
    // Free the old block.
    //
    SpMemFree(Block);

    //
    // Return the address of the new block.
    //
    return(NewBlock);
}


VOID
SpMemFree(
    IN PVOID Block
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
extern PWSTR CommonStrings[11];
unsigned long i;

    if (Block == NULL)
        return;

    for( i = 0; i < sizeof(CommonStrings)/sizeof(PWSTR); i++ ) {
        if( (PWSTR)Block == CommonStrings[i] ) {
            return;
        }
    }

    //
    // Free the block at its real address.
    //
#if defined(SETUP_TEST_USERMODE)
    RtlFreeHeap(RtlProcessHeap(), 0, (PULONG_PTR)Block - 2);
#else
    ExFreePool((PULONG_PTR)Block - 2);
#endif
}


VOID
SpOutOfMemory(
    VOID
    )
{
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Out of memory\n"));

#if !defined(SETUP_TEST_USERMODE)

    if(VideoInitialized) {
        if(KbdLayoutInitialized) {

            ULONG ValidKeys[2] = { KEY_F3,0 };

            //
            // We run a high risk of getting into an infinite loop
            // here because SpStartScreen will result in a call to
            // SpMemAlloc(), which will fail and call SpOutOfMemory
            // again.  In order to get around this, we'll jettison
            // some memory that we won't need anymore (since we're
            // about to die).  These should give us enough memory
            // to display the messages below.
            //
            SpFreeBootVars();
            SpFreeArcNames();

            while(1) {
                SpStartScreen(SP_SCRN_OUT_OF_MEMORY,5,0,FALSE,TRUE,DEFAULT_ATTRIBUTE);

                SpDisplayStatusOptions(
                    DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_F3_EQUALS_EXIT,
                    0
                    );

                if(SpWaitValidKey(ValidKeys,NULL,NULL) == KEY_F3) {
                    SpDone(0,FALSE,TRUE);
                }
            }
        } else {
            //
            // we haven't loaded the layout dll yet, so we can't prompt for a keypress to reboot
            //
            SpStartScreen(SP_SCRN_OUT_OF_MEMORY_RAW,5,0,FALSE,TRUE,DEFAULT_ATTRIBUTE);

            SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, SP_STAT_KBD_HARD_REBOOT, 0);

            while(TRUE);    // Loop forever
        }
    } else {
        SpDisplayRawMessage(SP_SCRN_OUT_OF_MEMORY_RAW, 2);
        while(TRUE);    // loop forever
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spmenu.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spmenu.h

Abstract:

    Public header file for text setup menu support.

Author:

    Ted Miller (tedm) 8-September-1993

Revision History:

--*/


#ifndef _SPMENU_
#define _SPMENU_


//
// Define type of routine that is called from within
// SpMnDisplay when the user moves the highlight via
// the up and down arrow keys.
//
typedef
VOID
(*PMENU_CALLBACK_ROUTINE) (
    IN ULONG_PTR UserDataOfHighlightedItem
    );

//
// Define type of routine that is called from within
// SpMnDisplay when the user selects a menu item by
// the ENTER key.
//
typedef
BOOLEAN
(*PMENU_SELECTION_CALLBACK_ROUTINE) (
    IN ULONG_PTR    UserData,
    IN ULONG        Key
    );

PVOID
SpMnCreate(
    IN ULONG LeftX,
    IN ULONG TopY,
    IN ULONG Width,
    IN ULONG Height
    );

VOID
SpMnDestroy(
    IN PVOID Menu
    );

BOOLEAN
SpMnAddItem(
    IN PVOID   Menu,
    IN PWSTR   Text,
    IN ULONG   LeftX,
    IN ULONG   Width,
    IN BOOLEAN Selectable,
    IN ULONG_PTR UserData
    );

PWSTR
SpMnGetText(
    IN PVOID Menu,
    IN ULONG_PTR UserData
    );

PWSTR
SpMnGetTextDup(
    IN PVOID Menu,
    IN ULONG_PTR UserData
    );

VOID
SpMnDisplay(
    IN  PVOID                               Menu,
    IN  ULONG_PTR                           UserDataOfHighlightedItem,
    IN  BOOLEAN                             Framed,
    IN  PULONG                              ValidKeys,
    IN  PULONG                              Mnemonics,               OPTIONAL
    IN  PMENU_CALLBACK_ROUTINE              NewHighlightCallback,    OPTIONAL
    IN  PMENU_SELECTION_CALLBACK_ROUTINE    ActionCallbackRoutine,   OPTIONAL
    OUT PULONG                              KeyPressed,
    OUT PULONG_PTR                          UserDataOfSelectedItem
    );

#endif // _SPMENU_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spmisc.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spmisc.h

Abstract:

    Miscellaneous stuff for text setup.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:

--*/

#include <crypt.h>

#ifndef _SPSETUP_DEFN_
#define _SPSETUP_DEFN_


extern PWSTR SetupSourceDevicePath;
extern PWSTR DirectoryOnSetupSource;
extern PVOID SifHandle;
extern BOOLEAN Win9xRollback;

ULONG
SpStartSetup(
    VOID
    );

VOID
SpGetWinntParams(
    OUT PWSTR *DevicePath,
    OUT PWSTR *DirectoryOnDevice
    );

extern WCHAR TemporaryBuffer[16384];
extern const UNICODE_STRING TemporaryBufferUnicodeString;

//
// TRUE if setup should run in the step-up upgrade mode.
// In this mode, setup is not allowed to do clean install,
// and is not allowed to upgrade workstation to server.
//
// We also track an evaluation time for the evaluation SKU.
//
extern BOOLEAN StepUpMode;
extern ULONG EvaluationTime;
extern ULONG RestrictCpu;
extern ULONG SuiteType;

__inline
BOOLEAN
SpIsProductSuite(
    DWORD SuiteToCheck
    )
{
    return (SuiteType & SuiteToCheck) ? TRUE : FALSE;
}


//
// Non-0 if gui setup is supposed to be restartable.
// This causes us to do special stuff with hives in spconfig.c.
//
extern BOOLEAN RestartableGuiSetup;

//
// TRUE if user chose Repair Winnt
//

extern BOOLEAN RepairWinnt;

//
// TRUE if user chose Custom Setup.
//
extern BOOLEAN CustomSetup;

//
// TRUE if floppyless boot
//
extern BOOLEAN IsFloppylessBoot;

//
// TRUE is textmode is to pick a partition
//
extern BOOLEAN AutoPartitionPicker;

//
// Preferred installation dir
//
extern PWSTR PreferredInstallDir;

//
// ARC pathname of the device from which we were started.
//
extern PWSTR ArcBootDevicePath;

//
// Gets set to TRUE if the user elects to convert or format to ntfs.
// And a flag indicating whether we are doing a dirty sleazy hack
// for oem preinstall.
//
extern BOOLEAN ConvertNtVolumeToNtfs;
extern BOOLEAN ExtendingOemPartition;

//
// TRUE if upgrading NT to NT
//
typedef enum _ENUMUPRADETYPE {
    DontUpgrade = 0,
    UpgradeFull,
    UpgradeInstallFresh
    } ENUMUPGRADETYPE;

extern ENUMUPGRADETYPE NTUpgrade;

extern ENUMUPGRADETYPE IsNTUpgrade;

extern ULONG OldMinorVersion,OldMajorVersion;

//
// TRUE if upgrading Workstation to Standard Server, or upgrading
// existing Standard Server
//
extern BOOLEAN StandardServerUpgrade;

typedef enum _ENUMNONNTUPRADETYPE {
    NoWinUpgrade = 0,
    UpgradeWin31,
    UpgradeWin95
    } ENUMNONNTUPRADETYPE;

//
// Non-zero if upgrading win31 or win95 to NT.
//
extern ENUMNONNTUPRADETYPE WinUpgradeType;

//
// Macros to simplify use of enum type
//

#define ANY_TYPE_OF_UPGRADE    (NTUpgrade || WinUpgradeType)
#define WIN9X_OR_NT_UPGRADE    (NTUpgrade == UpgradeFull || WinUpgradeType == UpgradeWin95)

//
// TRUE if this setup was started with winnt.exe.
// Also a flag indicating whether the local source was not created and we
// should get files from the CD instead.
//
extern BOOLEAN WinntSetup;
extern BOOLEAN WinntFromCd;

#ifdef _X86_
//
// TRUE if this setup was started with winnt95.exe.
//
extern BOOLEAN Winnt95Setup;
#endif

//
// TRUE if any of the accessibility options was selected
//
extern BOOLEAN AccessibleSetup;
//
// If this is an unattended setup, this value will be a TRUE
//
extern BOOLEAN UnattendedOperation;
//
// If there is an Unattended GUI section, this value will be TRUE
//
extern BOOLEAN UnattendedGuiOperation;
//
// This value is strictly a pointer to the WINNT.SIF file in the
// case that Unattended operation occurs in either the textmode
// or GUI Mode case. It has been kept to avoid changing large
// sections of code.
//
extern PVOID UnattendedSifHandle;
//
// This value is a non-null pointer to the WINNT.SIF file. It is
// initialized when the driver is started. Any parameter which is
// to be passed to GUI mode is added to the WINNT.SIF file by
// referencing this parameter.
//
extern PVOID WinntSifHandle;
extern BOOLEAN SkipMissingFiles;
extern BOOLEAN HideWinDir;


//
// this value is a non-null pointer to the drvindex.inf file.  It is
// initialized on startup.  The list of files that are present in our
// driver cab file are indexed in this inf, so we can quickly look if a
// file is present in the cab
//
extern PVOID DriverInfHandle;


//
// This structure will keep track of all the cabs
// that we'll be installing from.
//
typedef struct _CABDATA {
    struct _CABDATA     *Next;
    PWSTR               CabName;
    HANDLE              CabHandle;
    PWSTR               CabSectionName;
    PVOID               CabInfHandle;
} CABDATA;

extern CABDATA *CabData;

//
// handle to delta.inf, used for private testing
//
extern PVOID PrivateInfHandle;

#ifdef _X86_
//
// WINNT95 may turn this flag on, it is off by default for everything
// else.
//

extern BOOLEAN MigrateOption;
#endif


//
//  This is a handle to txtsetup.oem, used on pre-install mode.
//
extern PVOID PreinstallOemSifHandle;


//
// On unattended mode, indicates whether OEM files
// that have same name as Microsoft files released
// with the product should be overwritten.
//
extern BOOLEAN UnattendedOverwriteOem;

//
// On unattended mode, indicates that this is is
// an OEM pre-installation
//
extern BOOLEAN PreInstall;


//
//  On pre-install mode, points to the directory that contains the files
//  that need to be copied during textmode setup
//
extern PWSTR   PreinstallOemSourcePath;

//
//  Flags that indicate the type of mice detected in the machine.
//  Note that more than one type of mice may be present.
//
extern BOOLEAN UsbMouseDetected;
extern BOOLEAN PS2MouseDetected;
extern BOOLEAN SerMouseDetected;

//
//  Flags that indicate the type of keyboard detected in the machine.
//  Note that more than one type of keyborad may be present.
//
extern BOOLEAN UsbKeyboardDetected;
extern BOOLEAN StdKeyboardDetected;

//
// This flag identifies "dockable" machines (portables)
// so that we can disble dynamic volumes on them
//
extern BOOLEAN DockableMachine;

//
// Variable used during the repair process, that indicates that the
// system has no CD-ROM drive.
// This is a hack that we did for World Bank so that they can repair
// the hives even if they don't have a CD-ROM drive.
//
extern BOOLEAN RepairNoCDROMDrive;

//
//  RemoteBootSetup is true when Source and target paths are through the redirector
//  with possibly no system partition.
//
//  RemoteInstallSetup is true when we are doing a remote install.
//
//  RemoteSysPrepSetup is true when we are doing a remote install of a sys prep image.
//
//  RemoteSysPrepVolumeIsNtfs is true when the sysprep image we're copying down
//  represents an ntfs volume.
//

extern BOOLEAN RemoteBootSetup;
extern BOOLEAN RemoteInstallSetup;
extern BOOLEAN RemoteSysPrepSetup;
extern BOOLEAN RemoteSysPrepVolumeIsNtfs;

//
// setupldr may pass us the administrator password in a remote install
// if the user is prompted for the password.
//
extern PWSTR NetBootAdministratorPassword;



extern BOOLEAN NoLs;

//
// Source and target paths are through the redirector with possibly no
// system partition,
//

extern BOOLEAN RemoteBootSetup;

//
// Filename of local source directory.
//
extern PWSTR LocalSourceDirectory;

//
// Platform-specific extension, used when creating names of sections
// in sif/inf files.
//
extern PWSTR PlatformExtension;

//
// TRUE if this is advanced server we're setting up.
//
extern BOOLEAN AdvancedServer;

//
// Windows NT Version.
//
extern ULONG WinntMajorVer;
extern ULONG WinntMinorVer;

//
// Representation of the boot device path in the nt namespace.
//
extern PWSTR NtBootDevicePath;
extern PWSTR DirectoryOnBootDevice;

//
// Setup parameters passed to us by setupldr.
//
extern SETUP_LOADER_BLOCK_SCALARS SetupParameters;

//
// System information gathered by the user-mode part of text setup
// and passed to us in IOCTL_SETUP_START
//
extern SYSTEM_BASIC_INFORMATION SystemBasicInfo;

//
// Flags indicating whether or not keyboard and video have been initialized
//
extern BOOLEAN VideoInitialized, KeyboardInitialized, KbdLayoutInitialized;

//
// ARC disk/signature information structure.
// A list of these is created during phase0 initialization.
//
typedef struct _DISK_SIGNATURE_INFORMATION {
    struct _DISK_SIGNATURE_INFORMATION *Next;
    ULONG Signature;
    PWSTR ArcPath;
    ULONG CheckSum;
    BOOLEAN ValidPartitionTable;
    BOOLEAN xInt13;
    BOOLEAN IsGPTDisk;
} DISK_SIGNATURE_INFORMATION, *PDISK_SIGNATURE_INFORMATION;

extern PDISK_SIGNATURE_INFORMATION DiskSignatureInformation;

//
// Flag indicating whether or not pcmcia driver has been initialized
//

extern BOOLEAN PcmciaLoaded;

//
// Flag indicating whether or not atapi driver has been initialized
//

extern BOOLEAN AtapiLoaded;

//
//  Array with the PIDs of all NT greater than 4.x found in the machine (PID 2.0)
//  The values in this array will be saved under Setup\PID key in the registry,
//  and will be used during GUI setup
//
extern PWSTR*  Pid20Array;

//
//  Product Id read from setup.ini
//
extern PWSTR   PidString;

//
// Object types.
//
extern POBJECT_TYPE *IoFileObjectType;
extern POBJECT_TYPE *IoDeviceObjectType;


//
//  Gauge used to report progress of autochk and autofmt
//
extern PVOID   UserModeGauge;

//
//  This variable is used when displaying the progress bar
//  during autochk and autofmt. It indicates the disk that
//  is being autochecked or formatted.
//
extern ULONG   CurrentDiskIndex;

//
// Process structure for usetup.exe
//
extern PEPROCESS UsetupProcess;

//
// Setup fatal error codes.
//
// If you add anything here, you must also update ntos\nls\bugcodes.txt.
//
#define     SETUP_BUGCHECK_BAD_OEM_FONT         0
#define     SETUP_BUGCHECK_BOOTPATH             4
#define     SETUP_BUGCHECK_PARTITION            5
#define     SETUP_BUGCHECK_BOOTMSGS             6

//
// The following error codes are no longer used, because we have friendlier
// error messages for them.
//
// #define  SETUP_BUGCHECK_VIDEO                1
// #define  SETUP_BUGCHECK_MEMORY               2
// #define  SETUP_BUGCHECK_KEYBOARD             3


//
// Video-specific bugcheck subcodes.
//
#define     VIDEOBUG_OPEN           0
#define     VIDEOBUG_GETNUMMODES    1
#define     VIDEOBUG_GETMODES       2
#define     VIDEOBUG_BADMODE        3
#define     VIDEOBUG_SETMODE        4
#define     VIDEOBUG_MAP            5
#define     VIDEOBUG_SETFONT        6

//
// Partition sanity check bugcheck subcodes.
//
#define     PARTITIONBUG_A          0
#define     PARTITIONBUG_B          1

//
// Use the following enum to access line draw characters in
// the LineChars array.
//

typedef enum {
    LineCharDoubleUpperLeft = 0,
    LineCharDoubleUpperRight,
    LineCharDoubleLowerLeft,
    LineCharDoubleLowerRight,
    LineCharDoubleHorizontal,
    LineCharDoubleVertical,
    LineCharSingleUpperLeft,
    LineCharSingleUpperRight,
    LineCharSingleLowerLeft,
    LineCharSingleLowerRight,
    LineCharSingleHorizontal,
    LineCharSingleVertical,
    LineCharDoubleVerticalToSingleHorizontalRight,
    LineCharDoubleVerticalToSingleHorizontalLeft,
    LineCharMax
} LineCharIndex;

extern WCHAR LineChars[LineCharMax];


//
// Remember whether or not we write out an ntbootdd.sys
//
typedef struct _HARDWAREIDLIST {
    struct _HARDWAREIDLIST *Next;
    PWSTR HardwareID;
} HARDWAREIDLIST;

extern HARDWAREIDLIST *HardwareIDList;
extern BOOLEAN ForceBIOSBoot;

//
// Structure used to track a gauge.
//
typedef struct _GAS_GAUGE {

    //
    // upper left corner of outside of gauge.
    //
    ULONG GaugeX,GaugeY;

    //
    // Total width of gauge.
    //
    ULONG GaugeW;

    //
    // upper left corner of thermometer box.
    //
    ULONG ThermX,ThermY;

    //
    // Width of thermometer box.
    //
    ULONG ThermW;

    //
    // Total items reperesented by 100%
    //
    ULONG ItemCount;

    //
    // Items elapsed.
    //
    ULONG ItemsElapsed;

    //
    // Current percentage represented by ItemsElapsed.
    //
    ULONG CurrentPercentage;

    //
    // Caption text.
    //
    PWCHAR Caption;

    //
    // Absolute string
    //
    PWCHAR ProgressFmtStr;
    ULONG ProgressFmtWidth;

    //
    // Flags controlling what value to print
    //
    ULONG Flags;

    //
    // Color for the gauge bar
    //
    UCHAR Attribute;

    //
    // Buffer used for drawing.
    //
    PWCHAR Buffer;

} GAS_GAUGE, *PGAS_GAUGE;

//
// Indicates whether autochk or autofmt are running
//
extern BOOLEAN AutochkRunning;
extern BOOLEAN AutofrmtRunning;

//
// Various textmode setup progress events
//
typedef enum {
    CallbackEvent,
    InitializationEvent,
    PartitioningEvent,
    FileCopyEvent,
    BackupEvent,
    UninstallEvent,
    SavingSettingsEvent,
    SetupCompletedEvent
} TM_SETUP_MAJOR_EVENT;

typedef enum {
    CallbackInitialize,
    CallbackDeInitialize,
    InitializationStartEvent,
    InitializationEndEvent,
    PartitioningStartEvent,
    ScanDisksEvent,
    ScanDiskEvent,
    CreatePartitionEvent,
    DeletePartitionEvent,
    FormatPartitionEvent,
    ValidatePartitionEvent,
    PartitioningEventEnd,
    FileCopyStartEvent,
    OneFileCopyEvent,
    FileCopyEndEvent,
    SavingSettingsStartEvent,
    InitializeHiveEvent,
    SaveHiveEvent,
    HiveProcessingEndEvent,
    SavingSettingsEndEvent,
    ShutdownEvent,
    UninstallStartEvent,
    UninstallUpdateEvent,
    UninstallEndEvent,
    BackupStartEvent,
    BackupEndEvent,
    OneFileBackedUpEvent
} TM_SETUP_MINOR_EVENT;

typedef VOID (*TM_SETUP_PROGRESS_CALLBACK) (
    IN TM_SETUP_MAJOR_EVENT MajorEvent,
    IN TM_SETUP_MINOR_EVENT MinorEvent,
    IN PVOID Context,
    IN PVOID EventData
    );

typedef struct _TM_PROGRESS_SUBSCRIBER {
    TM_SETUP_PROGRESS_CALLBACK  Callback;
    PVOID                       Context;
} TM_PROGRESS_SUBSCRIBER, *PTM_PROGRESS_SUBSCRIBER;


NTSTATUS
RegisterSetupProgressCallback(
    IN TM_SETUP_PROGRESS_CALLBACK CallBack,
    IN PVOID Context
    );

NTSTATUS
DeregisterSetupProgressCallback(
    IN TM_SETUP_PROGRESS_CALLBACK CallBack,
    IN PVOID Context
    );

VOID
SendSetupProgressEvent(
    IN TM_SETUP_MAJOR_EVENT MajorEvent,
    IN TM_SETUP_MINOR_EVENT MinorEvent,
    IN PVOID EventData
    );

//
// Enumerate the possible returns values from SpEnumFiles()
//
typedef enum {
    NormalReturn,   // if the whole process completes uninterrupted
    EnumFileError,  // if an error occurs while enumerating files
    CallbackReturn  // if the callback returns FALSE, causing termination
} ENUMFILESRESULT;

typedef BOOLEAN (*ENUMFILESPROC) (
    IN  PCWSTR,
    IN  PFILE_BOTH_DIR_INFORMATION,
    OUT PULONG,
    IN  PVOID
    );

ENUMFILESRESULT
SpEnumFiles(
    IN  PCWSTR        DirName,
    IN  ENUMFILESPROC EnumFilesProc,
    OUT PULONG        ReturnData,
    IN  PVOID         Pointer
    );

ENUMFILESRESULT
SpEnumFilesRecursive (
    IN  PWSTR         DirName,
    IN  ENUMFILESPROC EnumFilesProc,
    OUT PULONG        ReturnData,
    IN  PVOID         Pointer       OPTIONAL
    );

ENUMFILESRESULT
SpEnumFilesRecursiveLimited (
    IN  PWSTR         DirName,
    IN  ENUMFILESPROC EnumFilesProc,
    IN  ULONG         MaxDepth,
    IN  ULONG         CurrentDepth,
    OUT PULONG        ReturnData,
    IN  PVOID         p1    OPTIONAL
    );

ENUMFILESRESULT
SpEnumFilesRecursiveDel (
    IN  PWSTR         DirName,
    IN  ENUMFILESPROC EnumFilesProc,
    OUT PULONG        ReturnData,
    IN  PVOID         p1    OPTIONAL
    );

#define SecToNano(_sec) (LONGLONG)((_sec) * 1000 * 1000 * 10)

//
// This macro filters in-page exceptions, which occur if there is
// an I/O error while the memory manager is paging in parts of a
// memory-mapped file.  Access to such data should be guarded with SEH!
//
#define IN_PAGE_ERROR                                   \
                                                        \
    ((GetExceptionCode() == STATUS_IN_PAGE_ERROR)       \
     ? EXCEPTION_EXECUTE_HANDLER                        \
     : EXCEPTION_CONTINUE_SEARCH)


//
// Helper macro to make object attribute initialization a little cleaner.
//
#define INIT_OBJA(Obja,UnicodeString,UnicodeText)           \
                                                            \
    RtlInitUnicodeString((UnicodeString),(UnicodeText));    \
                                                            \
    InitializeObjectAttributes(                             \
        (Obja),                                             \
        (UnicodeString),                                    \
        OBJ_CASE_INSENSITIVE,                               \
        NULL,                                               \
        NULL                                                \
        )

//
// Macro to align a buffer.
//
#define ALIGN(p,val)                                        \
                                                            \
    (PVOID)((((ULONG_PTR)(p) + (val) - 1)) & (~((ULONG_PTR)((val) - 1))))


//
// Macro to determine the number of elements in a statically
// initialized array.
//
#define ELEMENT_COUNT(x) (sizeof(x)/sizeof(x[0]))

//
// Marcos to pull potentially unaligned values from memory.
//
#define U_USHORT(p)    (*(USHORT UNALIGNED *)(p))
#define U_ULONG(p)     (*(ULONG  UNALIGNED *)(p))
#define U_ULONGLONG(p) (*(ULONGLONG  UNALIGNED *)(p))



typedef struct _SP_MIG_DRIVER_ENTRY {
    LIST_ENTRY ListEntry;
    PWSTR BaseDllName;
} SP_MIG_DRIVER_ENTRY, *PSP_MIG_DRIVER_ENTRY;

extern LIST_ENTRY MigratedDriversList;

BOOL
SpRememberMigratedDrivers (
    OUT     PLIST_ENTRY List,
    IN      PDETECTED_DEVICE SetupldrList
    );


//
// Setup media types. Setup can be started from one media
// (ie, floppy) and copy files from another (ie, cd-rom).
//
typedef enum {
    SetupBootMedia,
    SetupSourceMedia
} SetupMediaType;


//
// Upgrade-specific routines.
//
VOID
SpPrepareFontsForUpgrade(
    IN PCWSTR SystemDirectory
    );

//
// User-mode services.
//
NTSTATUS
SpExecuteImage(
    IN  PWSTR  ImagePath,
    OUT PULONG ReturnStatus,    OPTIONAL
    IN  ULONG  ArgumentCount,
    ...                         // argv[0] is generated automatically
    );

NTSTATUS
SpLoadUnloadKey(
    IN HANDLE  TargetKeyRootDirectory,  OPTIONAL
    IN HANDLE  SourceFileRootDirectory, OPTIONAL
    IN PWSTR   TargetKeyName,
    IN PWSTR   SourceFileName           OPTIONAL
    );

NTSTATUS
SpDeleteKey(
    IN HANDLE  KeyRootDirectory, OPTIONAL
    IN PWSTR   Key
    );

NTSTATUS
SpQueryDirectoryObject(
    IN     HANDLE  DirectoryHandle,
    IN     BOOLEAN RestartScan,
    IN OUT PULONG  Context
    );

NTSTATUS
SpFlushVirtualMemory(
    IN PVOID BaseAddress,
    IN ULONG RangeLength
    );

VOID
SpShutdownSystem(
    VOID
    );

NTSTATUS
SpLoadKbdLayoutDll(
    IN  PWSTR  Directory,
    IN  PWSTR  DllName,
    OUT PVOID *TableAddress
    );

NTSTATUS
SpVerifyFileAccess(
    IN  PWSTR       FileName,
    IN  ACCESS_MASK DesiredAccess
    );

NTSTATUS
SpSetDefaultFileSecurity(
    IN PWSTR    FileName
    );

NTSTATUS
SpCreatePageFile(
    IN PWSTR FileName,
    IN ULONG MinSize,
    IN ULONG MaxSize
    );

NTSTATUS
SpGetFullPathName(
    IN OUT PWSTR FileName
    );

NTSTATUS
SpDecryptPassword(
    PENCRYPTED_NT_OWF_PASSWORD PasswordData,
    ULONG PasswordDataLength,
    ULONG Rid,
    PNT_OWF_PASSWORD NtOwfPassword
    );

//
// Registry Hives.  We pass around the keys to the hives
// in an array.  Use the following enum values to access
// the hive members
//
typedef enum {
    SetupHiveSystem,
    SetupHiveSoftware,
    SetupHiveDefault,
    SetupHiveUserdiff,
    SetupHiveMax
} SetupHive;

//
// Function to set up registry.
//
VOID
SpInitializeRegistry(
    IN PVOID        SifHandle,
    IN PDISK_REGION TargetRegion,
    IN PWSTR        SystemRoot,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice,
    IN PWSTR        SpecialDevicePath   OPTIONAL,
    IN PDISK_REGION SystemPartitionRegion
    );

NTSTATUS
SpThirdPartyRegistry(
    IN PVOID hKeyControlSetServices
    );


//
// Function to examine a target registry
//

typedef enum {
    UpgradeNotInProgress = 0,
    UpgradeInProgress,
    UpgradeMaxValue
    } UPG_PROGRESS_TYPE;


NTSTATUS
SpDetermineProduct(
    IN  PDISK_REGION      TargetRegion,
    IN  PWSTR             SystemRoot,
    OUT PNT_PRODUCT_TYPE  ProductType,
    OUT ULONG             *MajorVersion,
    OUT ULONG             *MinorVersion,
    OUT ULONG             *BuildNumber,          OPTIONAL
    OUT ULONG             *ProductSuiteMask,
    OUT UPG_PROGRESS_TYPE *UpgradeProgressValue,
    OUT PWSTR             *UniqueIdFromReg,      OPTIONAL
    OUT PWSTR             *Pid,                  OPTIONAL
    OUT PBOOLEAN          pIsEvalVariation       OPTIONAL,
    OUT PLCID             LangId,
    OUT ULONG             *ServicePack            OPTIONAL
    );

NTSTATUS
SpSetUpgradeStatus(
    IN  PDISK_REGION      TargetRegion,
    IN  PWSTR             SystemRoot,
    IN  UPG_PROGRESS_TYPE UpgradeProgressValue
    );


//
// Utility functions.
//
BOOLEAN
SpGetTargetPath(
    IN  PVOID        SifHandle,
    IN  PDISK_REGION Region,
    IN  PWSTR        DefaultPath,
    OUT PWSTR       *TargetPath
    );

VOID
SpDeleteExistingTargetDir(
    IN  PDISK_REGION     Region,
    IN  PWSTR            NtDir,
    IN  BOOLEAN          GaugeNeeded,
    IN  DWORD            MsgId
    );

VOID
SpDone(
    IN ULONG   MsgId,
    IN BOOLEAN Successful,
    IN BOOLEAN Wait
    );

VOID
SpFatalSifError(
    IN PVOID SifHandle,
    IN PWSTR Section,
    IN PWSTR Key,           OPTIONAL
    IN ULONG Line,
    IN ULONG ValueNumber
    );

VOID
SpNonFatalSifError(
    IN PVOID SifHandle,
    IN PWSTR Section,
    IN PWSTR Key,           OPTIONAL
    IN ULONG Line,
    IN ULONG ValueNumber,
    IN PWSTR FileName
    );

VOID
SpFatalKbdError(
    IN ULONG MessageId,
    ...
    );

VOID
SpFatalError(
    IN ULONG MessageId,
    ...
    );

PWSTR
SpMakePlatformSpecificSectionName(
    IN PWSTR SectionName
    );

VOID
SpConfirmExit(
    VOID
    );

PWSTR
SpDupStringW(
    IN PCWSTR String
    );

PSTR
SpDupString(
    IN PCSTR String
    );

#define \
SpDupStringA SpDupString

PWSTR
SpToUnicode(
    IN PUCHAR OemString
    );

PUCHAR
SpToOem(
    IN PWSTR UnicodeString
    );

VOID
SpGetSourceMediaInfo(
    IN  PVOID  SifHandle,
    IN  PWSTR  MediaShortName,
    OUT PWSTR *Description,     OPTIONAL
    OUT PWSTR *Tagfile,         OPTIONAL
    OUT PWSTR *Directory        OPTIONAL
    );

NTSTATUS
SpConcatenatePaths_Ustr(
    IN OUT PUNICODE_STRING Path1_Ustr,
    IN     PCUNICODE_STRING Path2_Ustr
    );

VOID
SpConcatenatePaths(
    IN OUT LPWSTR  Path1,
    IN     LPCWSTR Path2
    );

VOID
SpFetchDiskSpaceRequirements(
    IN  PVOID  SifHandle,
    IN  ULONG  BytesPerCluster,
    OUT PULONG FreeKBRequired,          OPTIONAL
    OUT PULONG FreeKBRequiredSysPart    OPTIONAL
    );

VOID
SpFetchTempDiskSpaceRequirements(
    IN  PVOID  SifHandle,
    IN  ULONG  BytesPerCluster,
    OUT PULONG LocalSourceKBRequired,   OPTIONAL
    OUT PULONG BootKBRequired           OPTIONAL
    );

VOID
SpFetchUpgradeDiskSpaceReq(
    IN  PVOID  SifHandle,
    OUT PULONG FreeKBRequired,          OPTIONAL
    OUT PULONG FreeKBRequiredSysPart    OPTIONAL
    );

PWCHAR
SpRetreiveMessageText(
    IN     PVOID  ImageBase,            OPTIONAL
    IN     ULONG  MessageId,
    IN OUT PWCHAR MessageText,          OPTIONAL
    IN     ULONG  MessageTextBufferSize OPTIONAL
    );

NTSTATUS
SpRtlFormatMessage(
    IN PWSTR MessageFormat,
    IN ULONG MaximumWidth OPTIONAL,
    IN BOOLEAN IgnoreInserts,
    IN BOOLEAN ArgumentsAreAnsi,
    IN BOOLEAN ArgumentsAreAnArray,
    IN va_list *Arguments,
    OUT PWSTR Buffer,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    );

VOID
SpInitializeDriverInf(
    IN HANDLE       MasterSifHandle,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice
    );

VOID
SpOpenDriverCab(
    IN HANDLE       MasterSifHandle,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice,
    OUT PWSTR       *Directory        OPTIONAL
    );

//
// Disk region name translations
//

typedef enum _ENUMARCPATHTYPE {
                PrimaryArcPath = 0,
                SecondaryArcPath
                } ENUMARCPATHTYPE;

VOID
SpNtNameFromRegion(
    IN  PDISK_REGION         Region,
    OUT PWSTR                NtPath,
    IN  ULONG                BufferSizeBytes,
    IN  PartitionOrdinalType OrdinalType
    );

BOOLEAN
SpNtNameFromDosPath (
    IN      PCWSTR DosPath,
    OUT     PWSTR NtPath,
    IN      UINT NtPathSizeInBytes,
    IN      PartitionOrdinalType OrdinalType
    );

VOID
SpArcNameFromRegion(
    IN  PDISK_REGION         Region,
    OUT PWSTR                ArcPath,
    IN  ULONG                BufferSizeBytes,
    IN  PartitionOrdinalType OrdinalType,
    IN  ENUMARCPATHTYPE      ArcPathType
    );

PDISK_REGION
SpRegionFromArcOrDosName(
    IN PWSTR                Name,
    IN PartitionOrdinalType OrdinalType,
    IN PDISK_REGION         PreviousMatch
    );

PDISK_REGION
SpRegionFromNtName(
    IN PWSTR                NtName,
    IN PartitionOrdinalType OrdinalType
    );

PDISK_REGION
SpRegionFromDosName(
    IN PCWSTR DosName
    );

PDISK_REGION
SpRegionFromArcName(
    IN PWSTR                ArcName,
    IN PartitionOrdinalType OrdinalType,
    IN PDISK_REGION         PreviousMatch
    );

//
// Help routine.
//
#define SPHELP_HELPTEXT         0x00000000
#define SPHELP_LICENSETEXT      0x00000001

VOID
SpHelp(
    IN ULONG    MessageId,      OPTIONAL
    IN PCWSTR   FileText,       OPTIONAL
    IN ULONG    Flags
    );

//
//
//

BOOLEAN
SpPromptForDisk(
    IN      PWSTR    DiskDescription,
    IN OUT  PWSTR    DiskDevicePath,
    IN      PWSTR    DiskTagFile,
    IN      BOOLEAN  IgnoreDiskInDrive,
    IN      BOOLEAN  AllowEscape,
    IN      BOOLEAN  WarnMultiplePrompts,
    OUT     PBOOLEAN pRedrawFlag
    );

BOOLEAN
SpPromptForSetupMedia(
    IN  PVOID  SifHandle,
    IN  PWSTR  MediaShortname,
    IN  PWSTR  DiskDevicePath
    );

ULONG
SpFindStringInTable(
    IN PWSTR *StringTable,
    IN PWSTR  StringToFind
    );

PWSTR
SpGenerateCompressedName(
    IN PWSTR Filename
    );

BOOLEAN
SpNonCriticalError(
    IN PVOID SifHandle,
    IN ULONG MsgId,
    IN PWSTR p1,
    IN PWSTR p2
    );

BOOLEAN
SpNonCriticalErrorWithContinue(
    IN ULONG MsgId,
    IN PWSTR p1,
    IN PWSTR p2
    );

VOID
SpNonCriticalErrorNoRetry(
    IN ULONG MsgId,
    IN PWSTR p1,
    IN PWSTR p2
    );

VOID
SpPrepareForPrinterUpgrade(
    IN PVOID        SifHandle,
    IN PDISK_REGION NtRegion,
    IN PWSTR        Sysroot
    );

NTSTATUS
SpOpenSetValueAndClose(
    IN HANDLE hKeyRoot,
    IN PWSTR  SubKeyName, OPTIONAL
    IN PWSTR  ValueName,
    IN ULONG  ValueType,
    IN PVOID  Value,
    IN ULONG  ValueSize
    );

NTSTATUS
SpDeleteValueKey(
    IN  HANDLE     hKeyRoot,
    IN  PWSTR      KeyName,
    IN  PWSTR      ValueName
    );

NTSTATUS
SpGetValueKey(
    IN  HANDLE     hKeyRoot,
    IN  PWSTR      KeyName,
    IN  PWSTR      ValueName,
    IN  ULONG      BufferLength,
    OUT PUCHAR     Buffer,
    OUT PULONG     ResultLength
    );

BOOLEAN
SpIsRegionBeyondCylinder1024(
    IN PDISK_REGION Region
    );

PWSTR
SpDetermineSystemPartitionDirectory(
    IN PDISK_REGION SystemPartitionRegion,
    IN PWSTR        OriginalSystemPartitionDirectory OPTIONAL
    );

VOID
SpFindSizeOfFilesInOsWinnt(
    IN PVOID        MasterSifHandle,
    IN PDISK_REGION SystemPartition,
    IN PULONG       TotalSize
    );

VOID
SpRunAutochkOnNtAndSystemPartitions(
    IN HANDLE       MasterSifHandle,
    IN PDISK_REGION WinntPartitionRegion,
    IN PDISK_REGION SystemPartitionRegion,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice,
    IN PWSTR        TargetPath
    );

NTSTATUS
SpRunAutoFormat(
    IN HANDLE       MasterSifHandle,
    IN PWSTR        RegionDescription,
    IN PDISK_REGION PartitionRegion,
    IN ULONG        FilesystemType,
    IN BOOLEAN      QuickFormat,
    IN DWORD        ClusterSize,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice
    );


#if defined(_AMD64_) || defined(_X86_)
BOOL
SpUseBIOSToBoot(
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR        NtPartitionDevicePath,
    IN PVOID        SifHandle
    );
#endif // defined(_AMD64_) || defined(_X86_)

//
// Utilities used for partitioning/formatting
//

USHORT
ComputeSecPerCluster(
    IN  ULONG   NumSectors,
    IN  BOOLEAN SmallFat
    );

NTSTATUS
SpLockUnlockVolume(
    IN HANDLE   Handle,
    IN BOOLEAN  LockVolume
    );

NTSTATUS
SpDismountVolume(
    IN HANDLE   Handle
    );

//
// Miscellaneous other stuff
//
BOOLEAN
SpReadSKUStuff(
    VOID
    );

VOID
SpSetDirtyShutdownFlag(
    IN  PDISK_REGION    TargetRegion,
    IN  PWSTR           SystemRoot
    );

BOOLEAN
SpPatchBootMessages(
    VOID
    );

ULONG
SpGetHeaderTextId(
    VOID
    );


NTSTATUS
SpGetVersionFromStr(
    IN  PWSTR   VersionStr,
    OUT PDWORD  Version,        // major * 100 + minor
    OUT PDWORD  BuildNumber
    );

NTSTATUS
SpQueryCanonicalName(
    IN  PWSTR   Name,
    IN  ULONG   MaxDepth,
    OUT PWSTR   CanonicalName,
    IN  ULONG   SizeOfBufferInBytes
    );

void
SpDisableCrashRecoveryForGuiMode(
    IN PDISK_REGION TargetRegion,
    IN PWSTR        SystemRoot
    );

//
// mountmanger mount point iteration routine(s)
//
typedef BOOLEAN (* SPMOUNTMGR_ITERATION_CALLBACK)(
                    IN PVOID Context,
                    IN PMOUNTMGR_MOUNT_POINTS MountPoints,
                    IN PMOUNTMGR_MOUNT_POINT MountPoint);


NTSTATUS
SpIterateMountMgrMountPoints(
    IN PVOID Context,
    IN SPMOUNTMGR_ITERATION_CALLBACK Callback
    );


//
// Registry iteration abstractions
//
typedef struct _SPREGISTERYKEY_ITERATION_CALLBACK_DATA {
    KEY_INFORMATION_CLASS   InformationType;
    PVOID                   Information;
    HANDLE                  ParentKeyHandle;
} SP_REGISTRYKEY_ITERATION_CALLBACK_DATA, *PSP_REGISTRYKEY_ITERATION_CALLBACK_DATA;

//
// registry iteration call back
// 
typedef BOOLEAN (* SP_REGISTRYKEY_ITERATION_CALLBACK)(
                    IN PVOID Context,
                    IN PSP_REGISTRYKEY_ITERATION_CALLBACK_DATA Data,
                    OUT NTSTATUS *StatusCode
                    );                    

NTSTATUS
SpIterateRegistryKeyForKeys(
    IN HANDLE RootKeyHandle,
    IN PWSTR  KeyToIterate,
    IN SP_REGISTRYKEY_ITERATION_CALLBACK Callback,
    IN PVOID  Context
    );

VOID
SpGetFileVersion(
    IN  PVOID      ImageBase,
    OUT PULONGLONG Version
    );

NTSTATUS
SpGetFileVersionFromPath(
    IN PCWSTR FilePath,
    OUT PULONGLONG Version
    );

#define MAX_ARRAY_SIZE(a) (sizeof(a)/sizeof((a)[0]))
#define MAX_COPY_SIZE(a) (MAX_ARRAY_SIZE(a) - 1)
#define MAX_APPEND_SIZE_W(a) (MAX_COPY_SIZE(a) - wcslen(a))
#define MAX_APPEND_SIZE MAX_APPEND_SIZE_W


#if defined(EFI_NVRAM_ENABLED)

#define FPSWA_DRIVER_IMAGE_NAME         L"fpswa.efi"
#define FPSWA_DRIVER_FRIENDLY_NAME      L"Auxiliary Floating Point Driver"
#define FPSWA_DRIVER_DEST_DIR           L"\\EFI\\Microsoft\\EFIDrivers"

NTSTATUS
SpUpdateDriverEntry(
    IN PCWSTR DriverName,
    IN PCWSTR FriendlyName,
    IN PCWSTR SrcNtDevice,
    IN PCWSTR SrcDir,
    IN PCWSTR DestNtDevice OPTIONAL,
    IN PCWSTR DestDir OPTIONAL
    );

#endif    

#ifdef PRERELEASE
extern INT g_TestHook;
# define TESTHOOK(n)        if(g_TestHook==(n))SpBugCheck(SETUP_BUGCHECK_BOOTMSGS,0,0,0)
#else
# define TESTHOOK(n)
#endif


//
// On the x86 and amd64, we want to clear the previous OS entry in boot.ini
// if we reformat C:
//
#if defined(_AMD64_) || defined(_X86_)
extern UCHAR    OldSystemLine[MAX_PATH];
extern BOOLEAN  DiscardOldSystemLine;
#endif // defined(_AMD64_) || defined(_X86_)

#endif // ndef _SPSETUP_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spmsg.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spdsputl.c

Abstract:

    Text setup high-level display utility routines.

Author:

    Ted Miller (tedm) 30-July-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop

//
// This will be filled in at init time with the base address of the image
// containing the message resources.
// This implementation assumes that we are always executing in the context
// of that image!
//

PVOID ResourceImageBase;


NTSTATUS
SpRtlFormatMessage(
    IN PWSTR MessageFormat,
    IN ULONG MaximumWidth OPTIONAL,
    IN BOOLEAN IgnoreInserts,
    IN BOOLEAN ArgumentsAreAnsi,
    IN BOOLEAN ArgumentsAreAnArray,
    IN va_list *Arguments,
    OUT PWSTR Buffer,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    )
{
    ULONG Column;
    int cchRemaining, cchWritten;
    PULONG_PTR ArgumentsArray = (PULONG_PTR)Arguments;
    ULONG_PTR rgInserts[ 100 ];
    ULONG cSpaces;
    ULONG MaxInsert, CurInsert;
    ULONG PrintParameterCount;
    ULONG_PTR PrintParameter1;
    ULONG_PTR PrintParameter2;
    WCHAR PrintFormatString[ 32 ];
    WCHAR c;
    PWSTR s, s1;
    PWSTR lpDst, lpDstBeg, lpDstLastSpace;

    cchRemaining = Length / sizeof( WCHAR );
    lpDst = Buffer;
    MaxInsert = 0;
    lpDstLastSpace = NULL;
    Column = 0;
    s = MessageFormat;
    while (*s != UNICODE_NULL) {
        if (*s == L'%') {
            s++;
            lpDstBeg = lpDst;
            if (*s >= L'1' && *s <= L'9') {
                CurInsert = *s++ - L'0';
                if (*s >= L'0' && *s <= L'9') {
                    CurInsert = (CurInsert * 10) + (*s++ - L'0');
                    }
                CurInsert -= 1;

                PrintParameterCount = 0;
                if (*s == L'!') {
                    s1 = PrintFormatString;
                    *s1++ = L'%';
                    s++;
                    while (*s != L'!') {
                        if (*s != UNICODE_NULL) {
                            if (s1 >= &PrintFormatString[ 31 ]) {
                                return( STATUS_INVALID_PARAMETER );
                                }

                            if (*s == L'*') {
                                if (PrintParameterCount++ > 1) {
                                    return( STATUS_INVALID_PARAMETER );
                                    }
                                }

                            *s1++ = *s++;
                            }
                        else {
                            return( STATUS_INVALID_PARAMETER );
                            }
                        }

                    s++;
                    *s1 = UNICODE_NULL;
                    }
                else {
                    wcscpy( PrintFormatString, L"%s" );
                    s1 = PrintFormatString + wcslen( PrintFormatString );
                    }

                if (!IgnoreInserts && ARGUMENT_PRESENT( Arguments )) {

                    if (ArgumentsAreAnsi) {
                        if (s1[ -1 ] == L'c' && s1[ -2 ] != L'h'
                          && s1[ -2 ] != L'w' && s1[ -2 ] != L'l') {
                            wcscpy( &s1[ -1 ], L"hc" );
                            }
                        else
                        if (s1[ -1 ] == L's' && s1[ -2 ] != L'h'
                          && s1[ -2 ] != L'w' && s1[ -2 ] != L'l') {
                            wcscpy( &s1[ -1 ], L"hs" );
                            }
                        else if (s1[ -1 ] == L'S') {
                            s1[ -1 ] = L's';
                            }
                        else if (s1[ -1 ] == L'C') {
                            s1[ -1 ] = L'c';
                            }
                        }

                    while (CurInsert >= MaxInsert) {
                        if (ArgumentsAreAnArray) {
                            rgInserts[ MaxInsert++ ] = *((PULONG_PTR)Arguments)++;
                            }
                        else {
                            rgInserts[ MaxInsert++ ] = va_arg(*Arguments, ULONG_PTR);
                            }
                        }

                    s1 = (PWSTR)rgInserts[ CurInsert ];
                    PrintParameter1 = 0;
                    PrintParameter2 = 0;
                    if (PrintParameterCount > 0) {
                        if (ArgumentsAreAnArray) {
                            PrintParameter1 = rgInserts[ MaxInsert++ ] = *((PULONG_PTR)Arguments)++;
                            }
                        else {
                            PrintParameter1 = rgInserts[ MaxInsert++ ] = va_arg( *Arguments, ULONG_PTR );
                            }

                        if (PrintParameterCount > 1) {
                            if (ArgumentsAreAnArray) {
                                PrintParameter2 = rgInserts[ MaxInsert++ ] = *((PULONG_PTR)Arguments)++;
                                }
                            else {
                                PrintParameter2 = rgInserts[ MaxInsert++ ] = va_arg( *Arguments, ULONG_PTR );
                                }
                            }
                        }

                    cchWritten = _snwprintf( lpDst,
                                             cchRemaining,
                                             PrintFormatString,
                                             s1,
                                             PrintParameter1,
                                             PrintParameter2
                                           );
                    }
                else
                if (!wcscmp( PrintFormatString, L"%s" )) {
                    cchWritten = _snwprintf( lpDst,
                                             cchRemaining,
                                             L"%%%u",
                                             CurInsert+1
                                           );
                    }
                else {
                    cchWritten = _snwprintf( lpDst,
                                             cchRemaining,
                                             L"%%%u!%s!",
                                             CurInsert+1,
                                             &PrintFormatString[ 1 ]
                                           );
                    }

                if ((cchRemaining -= cchWritten) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                lpDst += cchWritten;
                }
            else
            if (*s == L'0') {
                break;
                }
            else
            if (!*s) {
                return( STATUS_INVALID_PARAMETER );
                }
            else
            if (*s == L'!') {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = L'!';
                s++;
                }
            else
            if (*s == L't') {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                if (Column % 8) {
                    Column = (Column + 7) & ~7;
                    }
                else {
                    Column += 8;
                    }

                lpDstLastSpace = lpDst;
                *lpDst++ = L'\t';
                s++;
                }
            else
            if (*s == L'b') {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                lpDstLastSpace = lpDst;
                *lpDst++ = L' ';
                s++;
                }
            else
            if (*s == L'r') {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = L'\r';
                s++;
                lpDstBeg = NULL;
                }
            else
            if (*s == L'n') {
                if ((cchRemaining -= 2) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = L'\r';
                *lpDst++ = L'\n';
                s++;
                lpDstBeg = NULL;
                }
            else {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                if (IgnoreInserts) {
                    if ((cchRemaining -= 1) <= 0) {
                        return STATUS_BUFFER_OVERFLOW;
                        }

                    *lpDst++ = L'%';
                    }

                *lpDst++ = *s++;
                }

            if (lpDstBeg == NULL) {
                lpDstLastSpace = NULL;
                Column = 0;
                }
            else {
                Column += (ULONG)(lpDst - lpDstBeg);
                }
            }
        else {
            c = *s++;
            if (c == L'\r' || c == L'\n') {
                if (c == L'\r' && *s == L'\n') {
                    s++;
                    }

                if (MaximumWidth != 0) {
                    lpDstLastSpace = lpDst;
                    c = L' ';
                    }
                else {
                    c = L'\n';
                    }
                }


            if (c == L'\n') {
                if ((cchRemaining -= 2) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = L'\r';
                *lpDst++ = L'\n';
                lpDstLastSpace = NULL;
                Column = 0;
                }
            else {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                if (c == L' ') {
                    lpDstLastSpace = lpDst;
                    }

                *lpDst++ = c;
                Column += 1;
                }
            }

        if (MaximumWidth != 0 &&
            MaximumWidth != 0xFFFFFFFF &&
            Column >= MaximumWidth
           ) {
            if (lpDstLastSpace != NULL) {
                lpDstBeg = lpDstLastSpace;
                while (*lpDstBeg == L' ' || *lpDstBeg == L'\t') {
                    lpDstBeg += 1;
                    if (lpDstBeg == lpDst) {
                        break;
                        }
                    }
                while (lpDstLastSpace > Buffer) {
                    if (lpDstLastSpace[ -1 ] == L' ' || lpDstLastSpace[ -1 ] == L'\t') {
                        lpDstLastSpace -= 1;
                        }
                    else {
                        break;
                        }
                    }

                cSpaces = (ULONG)(lpDstBeg - lpDstLastSpace);
                if (cSpaces == 1) {
                    if ((cchRemaining -= 1) <= 0) {
                        return STATUS_BUFFER_OVERFLOW;
                        }
                    }
                else
                if (cSpaces > 2) {
                    cchRemaining += (cSpaces - 2);
                    }

                memmove( lpDstLastSpace + 2,
                         lpDstBeg,
                         (size_t)((lpDst - lpDstBeg) * sizeof( WCHAR ))
                       );
                *lpDstLastSpace++ = L'\r';
                *lpDstLastSpace++ = L'\n';
                Column = (ULONG)(lpDst - lpDstBeg);
                lpDst = lpDstLastSpace + Column;
                lpDstLastSpace = NULL;
                }
            else {
                if ((cchRemaining -= 2) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = L'\r';
                *lpDst++ = L'\n';
                lpDstLastSpace = NULL;
                Column = 0;
                }
            }
        }

    if ((cchRemaining -= 1) <= 0) {
        return STATUS_BUFFER_OVERFLOW;
        }

    *lpDst++ = '\0';
    if ( ARGUMENT_PRESENT(ReturnLength) ) {
        *ReturnLength = (ULONG)((lpDst - Buffer) * sizeof( WCHAR ));
        }
    return( STATUS_SUCCESS );
}


PWCHAR
SpRetreiveMessageText(
    IN     PVOID  ImageBase,            OPTIONAL
    IN     ULONG  MessageId,
    IN OUT PWCHAR MessageText,          OPTIONAL
    IN     ULONG  MessageTextBufferSize OPTIONAL
    )
{
    ULONG LenBytes;
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
    BOOLEAN IsUnicode;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;

    Status = RtlFindMessage(
                ImageBase ? ImageBase : ResourceImageBase,
                (ULONG)(ULONG_PTR)RT_MESSAGETABLE,
                0,
                MessageId,
                &MessageEntry
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Can't find message 0x%lx\n",MessageId));
        return(NULL);
    }

    IsUnicode = (BOOLEAN)((MessageEntry->Flags & MESSAGE_RESOURCE_UNICODE) != 0);

    //
    // Get the size in bytes of a buffer large enough to hold the
    // message and its terminating nul wchar.  If the message is
    // unicode, then this value is equal to the size of the message.
    // If the message is not unicode, then we have to calculate this value.
    //
    if(IsUnicode) {

        LenBytes = (wcslen((PWSTR)MessageEntry->Text) + 1) * sizeof(WCHAR);

    } else {

        //
        // RtlAnsiStringToUnicodeSize includes an implied wide-nul terminator
        // in the count it returns.
        //

        AnsiString.Buffer = MessageEntry->Text;
        AnsiString.Length = (USHORT)strlen(MessageEntry->Text);
        AnsiString.MaximumLength = AnsiString.Length;

        LenBytes = RtlAnsiStringToUnicodeSize(&AnsiString);
        
        if (LenBytes > MAXUSHORT){
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpRetreiveMessageText: Lenth of ANSI to Unicode convert string too big (%u)\n",LenBytes));
            return(NULL);
        }        
    }

    //
    // If the caller gave a buffer, check its size.
    // Otherwise, allocate a buffer.
    //
    if(MessageText) {
        if(MessageTextBufferSize < LenBytes) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpRetreiveMessageText: buffer is too small (%u bytes, need %u)\n",MessageTextBufferSize,LenBytes));
            return(NULL);
        }
    } else {
        MessageText = SpMemAlloc(LenBytes);
        if(MessageText == NULL) {
            return(NULL);
        }
    }

    if(IsUnicode) {

        //
        // Message is already unicode; just copy it into the buffer.
        //
        wcscpy(MessageText,(PWSTR)MessageEntry->Text);

    } else {

        //
        // Message is not unicode; convert in into the buffer.
        //
        UnicodeString.Buffer = MessageText;
        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = (USHORT)LenBytes;

        RtlAnsiStringToUnicodeString(
            &UnicodeString,
            &AnsiString,
            FALSE
            );
    }

    return(MessageText);
}



VOID
vSpFormatMessageText(
    OUT PVOID    LargeBuffer,
    IN  ULONG    BufferSize,
    IN  PWSTR    MessageText,
    OUT PULONG   ReturnLength, OPTIONAL
    IN  va_list *arglist
    )
{
    NTSTATUS Status;

    Status = SpRtlFormatMessage(
                 MessageText,
                 0,                         // don't bother with maximum width
                 FALSE,                     // don't ignore inserts
                 FALSE,                     // args are unicode
                 FALSE,                     // args are not an array
                 arglist,
                 LargeBuffer,
                 BufferSize,
                 ReturnLength
                 );

    ASSERT(NT_SUCCESS(Status));
}



VOID
SpFormatMessageText(
    OUT PVOID   LargeBuffer,
    IN  ULONG   BufferSize,
    IN  PWSTR   MessageText,
    ...
    )
{
    va_list arglist;

    va_start(arglist,MessageText);

    vSpFormatMessageText(LargeBuffer,BufferSize,MessageText,NULL,&arglist);

    va_end(arglist);
}



VOID
vSpFormatMessage(
    OUT PVOID    LargeBuffer,
    IN  ULONG    BufferSize,
    IN  ULONG    MessageId,
    OUT PULONG   ReturnLength, OPTIONAL
    IN  va_list *arglist
    )
{
    PWCHAR MessageText;

    //
    // Get the message text.
    //
    MessageText = SpRetreiveMessageText(NULL,MessageId,NULL,0);
    ASSERT(MessageText);
    if(MessageText == NULL) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: vSpFormatMessage: SpRetreiveMessageText %u returned NULL\n",MessageId));
        return;
    }

    vSpFormatMessageText(LargeBuffer,BufferSize,MessageText,ReturnLength,arglist);

    SpMemFree(MessageText);
}



VOID
SpFormatMessage(
    OUT PVOID LargeBuffer,
    IN  ULONG BufferSize,
    IN  ULONG MessageId,
    ...
    )
{
    va_list arglist;

    va_start(arglist,MessageId);

    vSpFormatMessage(LargeBuffer,BufferSize,MessageId,NULL,&arglist);

    va_end(arglist);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spntfix.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Spntfix.c

Abstract:

    This module contains code to repair winnt installations.

Author:

    Shie-Lin Tzong (shielint) 27-Jan-1994

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop


//
//  Path to the ntuser.dat hive
//
#define DEFAULT_USER_PATH   L"Users\\Default User"


//
// Global variables control which repair options should be performed.
// Initialized to ALL options.  We explicitly use 1 and 0 for true and false.
//

#if defined(_AMD64_) || defined(_X86_)
ULONG RepairItems[RepairItemMax] = { 0, 0, 0};  // BCL - Seagate - removed one.
#else
ULONG RepairItems[RepairItemMax] = { 0, 0};     // BCL
#endif // defined(_AMD64_) || defined(_X86_)

PVOID RepairGauge = NULL;

//
// global variables for delayed driver CAB opening during
// repair
//
extern PWSTR    gszDrvInfDeviceName;
extern PWSTR    gszDrvInfDirName;
extern HANDLE   ghSif;


#define FILE_ATTRIBUTES_RHS (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)

//**************************************************************
// S E L E C T I N G    N T   T O   REPAIR    S T U F F
//**************************************************************

#define MENU_LEFT_X     3
#define MENU_WIDTH      (VideoVars.ScreenWidth-(2*MENU_LEFT_X))
#define LIST_BOX_WIDTH  50
#define LIST_BOX_HEIGHT RepairItemMax+1
#define HIVE_LIST_BOX_WIDTH  45
#define HIVE_LIST_BOX_HEIGHT RepairHiveMax+1
#define MENU_INDENT     4

VOID
SppGetRepairPathInformation(
    IN  PVOID LogFileHandle,
    OUT PWSTR *SystemPartition,
    OUT PWSTR *SystemPartitionDirectory,
    OUT PWSTR *WinntPartition,
    OUT PWSTR *WinntPartitionDirectory
    )
/*++

Routine Description:

    This goes through the list of NTs on the system and finds out which are
    repairable. Presents the information to the user.


Arguments:

    SifHandle  - Handle the txtsetup.sif

    SystemPartition - Supplies a variable to receive the name of System
                      partition.

    SystemPartitionDirectory - Supplies a variable to receive the name of
                      the osloader directory on the system partition.

    WinntPartition - Supplies a variable to receive the name of  winnt
                     partition.

    WinntPartitionDirectory - Supplies a variable to receive the winnt
                     directory.

Return Value:

    None.

--*/
{
    PWSTR KeyName = NULL;

    *SystemPartition = SpGetSectionKeyIndex (LogFileHandle,
                                             SIF_NEW_REPAIR_PATHS,
                                             SIF_NEW_REPAIR_PATHS_SYSTEM_PARTITION_DEVICE,
                                             0);
    if (*SystemPartition == NULL) {
        KeyName = SIF_NEW_REPAIR_PATHS_SYSTEM_PARTITION_DEVICE;
        goto ReportError;
    }
    *SystemPartitionDirectory = SpGetSectionKeyIndex (LogFileHandle,
                                             SIF_NEW_REPAIR_PATHS,
                                             SIF_NEW_REPAIR_PATHS_SYSTEM_PARTITION_DIRECTORY,
                                             0);
    if (*SystemPartitionDirectory == NULL) {
        KeyName = SIF_NEW_REPAIR_PATHS_SYSTEM_PARTITION_DIRECTORY;
        goto ReportError;
    }

    *WinntPartition = SpGetSectionKeyIndex ( LogFileHandle,
                                             SIF_NEW_REPAIR_PATHS,
                                             SIF_NEW_REPAIR_PATHS_TARGET_DEVICE,
                                             0);

    if (*WinntPartition == NULL) {
        KeyName = SIF_NEW_REPAIR_PATHS_TARGET_DEVICE;
        goto ReportError;
    }
    *WinntPartitionDirectory = SpGetSectionKeyIndex (LogFileHandle,
                                             SIF_NEW_REPAIR_PATHS,
                                             SIF_NEW_REPAIR_PATHS_TARGET_DIRECTORY,
                                             0);

    if (*WinntPartitionDirectory == NULL) {
        KeyName = SIF_NEW_REPAIR_PATHS_TARGET_DIRECTORY;
        goto ReportError;
    }
ReportError:

    if (KeyName) {

        //
        // Unable to find path information.  This indicates the setup.log
        // is bad.  Inform user and exit.
        //

        SpFatalSifError(LogFileHandle,SIF_NEW_REPAIR_PATHS,KeyName,0,0);
    }
}

BOOLEAN
SpFindNtToRepair(
    IN  PVOID        SifHandle,
    OUT PDISK_REGION *TargetRegion,
    OUT PWSTR        *TargetPath,
    OUT PDISK_REGION *SystemPartitionRegion,
    OUT PWSTR        *SystemPartitionDirectory,
    OUT PBOOLEAN     RepairableBootSetsFound
    )
/*++

Routine Description:

    This goes through the list of NTs on the system and finds out which are
    repairable. Presents the information to the user.


Arguments:

    SifHandle:    Handle the txtsetup.sif

    TargetRegion: Variable to receive the partition of the Windows NT to install
                  NULL if not chosen.

    TargetPath:   Variable to receive the target path of Windows NT.  NULL if
                  not decided.

    SystemPartitionRegion:
                  Variable to receive the system partition of the Windows NT

    SystemPartitionDirectory:
                  Variable to receive the osloader directory of the system
                  partition.

    RepairableBootSetsFound:
                  Indicates whether a repairable boot set was found. This
                  information can be used by the caller when the function
                  returns FALSE, so that the caller can determine if no
                  repairable disk was found, or if the user didn't select
                  any of the repairable systems found.

Return Value:

    A boolean value to indicate if selection has been made.

--*/
{
    NT_PRODUCT_TYPE ProductType;
    BOOLEAN  GoRepair = FALSE;
    NTSTATUS NtStatus;

    ULONG j, RepairBootSets = 0, MajorVersion, MinorVersion, BuildNumber, ProductSuiteMask;
    PSP_BOOT_ENTRY BootEntry;
    PSP_BOOT_ENTRY ChosenBootEntry;
    LCID LangId;

    UPG_PROGRESS_TYPE UpgradeProgressValue;

    //
    // Find all upgradeable boot entries. These are entries that are unique in
    // the boot entry list and are present on disk.
    //

    SpDetermineUniqueAndPresentBootEntries();

    for ( BootEntry = SpBootEntries; BootEntry != NULL ; BootEntry = BootEntry->Next ) {

        if (!BootEntry->Processable) {
            continue;
        }

        //
        // Reinitialize
        //

        BootEntry->Processable = FALSE;
        LangId = -1;

        //
        // try loading the registry and getting the following information
        // out of it:
        //
        // 1) Product type: WINNT | LANMANNT
        // 2) Major and Minor Version Number
        //
        // Based on the information, we will update the RepairableList.
        //

        NtStatus = SpDetermineProduct(
                     BootEntry->OsPartitionDiskRegion,
                     BootEntry->OsDirectory,
                     &ProductType,
                     &MajorVersion,
                     &MinorVersion,
                     &BuildNumber,
                     &ProductSuiteMask,
                     &UpgradeProgressValue,
                     NULL,
                     NULL,                   // Pid is not needed
                     NULL,                    // ignore eval variation flag
                     &LangId,                // Language Id
                     NULL                   // service pack not needed?
                     );

        if(NT_SUCCESS(NtStatus)) {

            //
            // make sure we only try to repair a build that matches the CD we have inserted
            //
            BootEntry->Processable = SpDoBuildsMatch(
                                        SifHandle,
                                        BuildNumber,
                                        ProductType,
                                        ProductSuiteMask,
                                        AdvancedServer,
                                        SuiteType,
                                        LangId
                                        );
            if( BootEntry->Processable ) {
                RepairBootSets++;
                ChosenBootEntry = BootEntry;
            }
        }
    }

    //
    // Find out how many valid boot sets there are which we can repair
    //

    *RepairableBootSetsFound = (RepairBootSets != 0);

    if ( RepairBootSets == 1 ) {

        //
        // If it is a fresh attempt at upgrade ask the user if he
        // wants to upgrade or not
        //

        GoRepair = SppSelectNTSingleRepair(
                          ChosenBootEntry->OsPartitionDiskRegion,
                          ChosenBootEntry->OsDirectory,
                          ChosenBootEntry->FriendlyName
                          );

    } else if (RepairBootSets > 1) {

        //
        // Find out if the user wants to upgrade one of the Windows
        // NT found
        //

        GoRepair = SppSelectNTMultiRepair(
                          &ChosenBootEntry
                          );
    }

    //
    // Depending on upgrade selection made do the setup needed before
    // we do the upgrade
    //

    if (GoRepair) {

        PWSTR    p1,p2,p3;
        ULONG    u;

        //
        // Return the region we are goint to repair
        //

        *TargetRegion          = ChosenBootEntry->OsPartitionDiskRegion;
        *TargetPath            = SpDupStringW(ChosenBootEntry->OsDirectory);
        *SystemPartitionRegion = ChosenBootEntry->LoaderPartitionDiskRegion;

        //
        // Process the osloader variable to extract the system partition path.
        // The var vould be of the form ...partition(1)\os\nt\... or
        // ...partition(1)os\nt\...
        // So we search forward for the first \ and then backwards for
        // the closest ) to find the start of the directory.  We then
        // search backwards in the resulting string for the last \ to find
        // the end of the directory.
        //
        p1 = ChosenBootEntry->LoaderFile;
        p2 = wcsrchr(p1, L'\\');
        if (p2 == NULL) {
            p2 = p1;
        }
        u = (ULONG)(p2 - p1);

        if(u == 0) {
            *SystemPartitionDirectory = SpDupStringW(L"");
        } else {
            p2 = p3 = SpMemAlloc((u+2)*sizeof(WCHAR));
            ASSERT(p3);
            if(*p1 != L'\\') {
                *p3++ = L'\\';
            }
            wcsncpy(p3, p1, u);
            p3[u] = 0;
            *SystemPartitionDirectory = p2;
        }
    }

    //
    // Do cleanup
    //

    CLEAR_CLIENT_SCREEN();
    return (GoRepair);
}

BOOLEAN
SppSelectNTSingleRepair(
    IN PDISK_REGION Region,
    IN PWSTR        OsLoadFileName,
    IN PWSTR        LoadIdentifier
    )

/*++

Routine Description:

    Inform a user that Setup has found a previous Windows NT installation.
    The user has the option to repair this or cancel.

Arguments:

    Region         - Region descriptor for the NT found

    OsLoadFileName - Directory for the NT found

    LoadIdentifier - Multi boot load identifier used for this NT.

Return Value:



--*/

{
    ULONG ValidKeys[] = { KEY_F3,ASCI_CR, ASCI_ESC, 0 };
    ULONG c;
    PWSTR TmpString = NULL;

    ASSERT(Region->PartitionedSpace);
    ASSERT(wcslen(OsLoadFileName) >= 2);

    if( Region->DriveLetter ) {
        swprintf( TemporaryBuffer,
                  L"%wc:%ws",
                  Region->DriveLetter,
                  OsLoadFileName );
        TmpString = SpDupStringW( TemporaryBuffer );
    }

    while(1) {

        SpStartScreen(
            SP_SCRN_WINNT_REPAIR,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            (Region->DriveLetter)? TmpString : OsLoadFileName,
            LoadIdentifier
            );

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_F3_EQUALS_EXIT,
            SP_STAT_ESC_EQUALS_CANCEL,
            SP_STAT_ENTER_EQUALS_REPAIR,
            0
            );

        if( TmpString != NULL ) {
            SpMemFree( TmpString );
        }

        switch(c=SpWaitValidKey(ValidKeys,NULL,NULL)) {

        case KEY_F3:
            SpConfirmExit();
            break;
        case ASCI_CR:
            return(TRUE);
        default:
            //
            // must have entered ESC
            //

            return(FALSE);
        }
    }
}

BOOLEAN
SppSelectNTMultiRepair(
    OUT PSP_BOOT_ENTRY *BootEntryChosen
    )
{
    PVOID Menu;
    ULONG MenuTopY;
    ULONG ValidKeys[] = { KEY_F3, ASCI_CR, ASCI_ESC, 0 };
    ULONG Keypress;
    PSP_BOOT_ENTRY BootEntry,FirstRepairSet;

    while(1) {

        //
        // Display the text that goes above the menu on the partitioning screen.
        //
        SpDisplayScreen(SP_SCRN_WINNT_REPAIR_LIST,3,CLIENT_TOP+1);

        //
        // Calculate menu placement.  Leave one blank line
        // and one line for a frame.
        //

        MenuTopY = NextMessageTopLine + (SplangQueryMinimizeExtraSpacing() ? 2 : 5);

        //
        // Create a menu.
        //

        Menu = SpMnCreate(
                    MENU_LEFT_X,
                    MenuTopY,
                    MENU_WIDTH,
                    VideoVars.ScreenHeight-MenuTopY-2-STATUS_HEIGHT
                    );

        ASSERT(Menu);

        //
        // Build up a menu of partitions and free spaces.
        //

        FirstRepairSet = NULL;
        for(BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next ) {
            if( BootEntry->Processable ) {
                if( BootEntry->OsPartitionDiskRegion->DriveLetter ) {
                    swprintf(
                        TemporaryBuffer,
                        L"%wc:%ws %ws",
                        BootEntry->OsPartitionDiskRegion->DriveLetter,
                        BootEntry->OsDirectory,
                        BootEntry->FriendlyName
                        );
                } else {
                    swprintf(
                        TemporaryBuffer,
                        L"%ws %ws",
                        BootEntry->OsDirectory,
                        BootEntry->FriendlyName
                        );
                }


                SpMnAddItem(Menu,
                            TemporaryBuffer,
                            MENU_LEFT_X+MENU_INDENT,
                            MENU_WIDTH-(2*MENU_INDENT),
                            TRUE,
                            (ULONG_PTR)BootEntry
                            );
                if(FirstRepairSet == NULL) {
                   FirstRepairSet = BootEntry;
                }
            }
        }

        //
        // Initialize the status line.
        //
        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_F3_EQUALS_EXIT,
            SP_STAT_ESC_EQUALS_CANCEL,
            SP_STAT_ENTER_EQUALS_REPAIR,
            0
            );

        //
        // Display the menu
        //

        SpMnDisplay(
            Menu,
            (ULONG_PTR)FirstRepairSet,
            TRUE,
            ValidKeys,
            NULL,
            NULL,
            NULL,
            &Keypress,
            (PULONG_PTR)BootEntryChosen
            );

        //
        // Now act on the user's selection.
        //

        switch(Keypress) {

        case KEY_F3:
            SpConfirmExit();
            break;

        case ASCI_CR:
            SpMnDestroy(Menu);
            return( TRUE );

        default:
            SpMnDestroy(Menu);
            return(FALSE);
        }
        SpMnDestroy(Menu);
    }

}

VOID
SppRepairScreenRepaint(
    IN PWSTR   FullSourcename,      OPTIONAL
    IN PWSTR   FullTargetname,      OPTIONAL
    IN BOOLEAN RepaintEntireScreen
    )
{
    UNREFERENCED_PARAMETER(FullTargetname);
    UNREFERENCED_PARAMETER(FullSourcename);

    //
    // Repaint the entire screen if necessary.
    //

    if(RepaintEntireScreen) {
        if( SpDrEnabled() ) {
            SpStartScreen( SP_SCRN_ASR_IS_EXAMINING,  0, 6, TRUE, FALSE, DEFAULT_ATTRIBUTE );
        }
        else {
            SpStartScreen( SP_SCRN_SETUP_IS_EXAMINING,0, 6, TRUE, FALSE, DEFAULT_ATTRIBUTE );
        }

        if(RepairGauge) {
            SpDrawGauge(RepairGauge);
        }
    }
}


BOOLEAN
SpErDiskScreen(
    BOOLEAN *HasErDisk
    )

/*++

Routine Description:

    Ask user if user has emergency repair disk.

Arguments:

    *HasErDisk - Indicates whether diskette will be used.

Return Value:

    TRUE - User chose disk or diskless.

    FALSE - User wants to return to previous screen.

--*/

{
    ULONG ValidKeys[] = { KEY_F3, ASCI_CR, ASCI_ESC, 0 };
    ULONG MnemonicKeys[] = { MnemonicLocate, 0 };
    BOOLEAN Choosing;
    ULONG c;

    for (Choosing = TRUE; Choosing; ) {

        SpDisplayScreen(SP_SCRN_REPAIR_ASK_REPAIR_DISK,3,4);

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            SP_STAT_L_EQUALS_LOCATE,
            SP_STAT_ESC_EQUALS_CANCEL,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        //
        // Wait for keypress.  Valid keys:
        //
        // L = Do not use ER diskette, locate on hard disk
        // F3 = exit
        // ENTER = Use ER diskette
        // ESC = cancel, return to previous screen
        //

        SpInputDrain();

        switch(c=SpWaitValidKey(ValidKeys,NULL,MnemonicKeys)) {

        case ASCI_CR:

            //
            // User wants express setup.
            //

            *HasErDisk = TRUE;
            Choosing = FALSE;
            break;

        case (MnemonicLocate | KEY_MNEMONIC):

            //
            // User wants repair without diskette.
            //

            *HasErDisk = FALSE;
            Choosing = FALSE;
            break;

        case KEY_F3:

            //
            // User wants to exit.
            //

            SpConfirmExit();
            break;

        default:

            //
            // must be ESC
            //

            *HasErDisk = FALSE;
            Choosing = FALSE;
            return( FALSE );
        }
    }

    return( TRUE );
}

BOOLEAN
SppRepairReportError(
    IN BOOLEAN AllowEsc,
    IN ULONG ErrorScreenId,
    IN ULONG SubErrorId,
    IN PWSTR SectionName,
    IN ULONG LineNumber,
    IN PBOOLEAN DoNotPromptAgain
    )

/*++

Routine Description:

    Inform a user that repair has encountered some kind of error.
    The user has the option to continue or exit.

Arguments:

    AllowEsc -  Supplies a BOOLEAN to indicate if ESC is allowed.

    ErrorScreenId - The SCREEN error message number.

    SubErrorId - the sub error number

    SectionName - the name of the section which error occured.

    LineNumber - the error line number within the specified section.

Return Value:

    FALSE if ESC was pressed.

--*/

{
    ULONG ValidKeys0[] = { KEY_F3, ASCI_CR, 0 };
    ULONG ValidKeys1[] = { KEY_F3, ASCI_CR, ASCI_ESC, 0 };
    ULONG MnemonicKeys[] = { MnemonicRepairAll, 0 };
    PULONG ValidKeys;
    PULONG  Mnemonics;
    ULONG c;
    PWSTR SubError;
    BOOLEAN rc;

    SubError = SpMemAlloc(512);

    //
    // Line numbers are 0-based.  Want to display to user as 1-based.
    //

    LineNumber++;

    //
    // Fetch/format the suberror.
    //

    SpFormatMessage(SubError, 512, SubErrorId, SectionName, LineNumber);

    //
    // Display the error screen.
    //

    SpStartScreen(
        ErrorScreenId,
        3,
        HEADER_HEIGHT+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE,
        SubError
        );

    SpMemFree(SubError);

    //
    // Display status options: enter to continue.
    //

    if (AllowEsc) {
        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
                               SP_STAT_ENTER_EQUALS_CONTINUE,
                               SP_STAT_A_EQUALS_REPAIR_ALL,
                               SP_STAT_ESC_EQUALS_SKIP_FILE,
                               SP_STAT_F3_EQUALS_EXIT,
                               0);
        ValidKeys = ValidKeys1;
        Mnemonics = MnemonicKeys;
        if( DoNotPromptAgain != NULL ) {
            *DoNotPromptAgain = FALSE;
        }
    } else {
        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
                               SP_STAT_ENTER_EQUALS_CONTINUE,
                               SP_STAT_F3_EQUALS_EXIT,
                               0);
        ValidKeys = ValidKeys0;
        Mnemonics = NULL;
    }

    //
    // Wait for the user to press enter.
    //

    switch(c=SpWaitValidKey(ValidKeys,NULL,Mnemonics)) {

    case KEY_F3:
        SpConfirmExit();
        break;
    case ASCI_CR:
        rc = TRUE;
        break;
    case ASCI_ESC:
        rc = FALSE;
        break;
    default:
        //
        // must be repair all mnemonic
        //
        ASSERT(c == (MnemonicRepairAll | KEY_MNEMONIC));
        if( DoNotPromptAgain != NULL ) {
            *DoNotPromptAgain = TRUE;
        }
        rc = TRUE;
        break;

    }
    CLEAR_CLIENT_SCREEN();
    return(rc);
}

BOOLEAN
SpLoadRepairLogFile(
    IN  PWCHAR  Filename,
    OUT PVOID  *Handle
    )

/*++

Routine Description:

    Load repair text file (setup.log) into memory.

Arguments:

    Filename - Supplies full filename (in NT namespace) of the file to
               be loaded.

    Handle - receives handle to loaded file, which can be
        used in subsequent calls to other text file services.

Return Value:

    BOOLEAN value to indicate if the setup.log is processed.

--*/

{
    NTSTATUS Status;
    PWSTR Version;
    ULONG ErrorSubId;
    ULONG ErrorLine;

    //
    // Load setup.log
    //

    Status = SpLoadSetupTextFile(
                Filename,
                NULL,                  // No image already in memory
                0,                     // Image size is empty
                Handle,
                &ErrorLine,
                TRUE,
                FALSE
                );

    if(!NT_SUCCESS(Status)) {
        if(Status == STATUS_UNSUCCESSFUL) {

            //
            // Syntax error in setup.log file
            //

            ErrorSubId = SP_TEXT_REPAIR_INF_ERROR_1;
        } else {

            //
            // Unable to load setup.log file
            //

            ErrorLine = 0;
            ErrorSubId = SP_TEXT_REPAIR_INF_ERROR_0;
        }

        SppRepairReportError(FALSE,
                             SP_SCRN_REPAIR_INF_ERROR,
                             ErrorSubId,
                             NULL,
                             ErrorLine,
                             NULL );

        *Handle = NULL;
        return (FALSE);
    }

    //
    // Check if this setup.log file is for Winnt 3.5
    //

    Version = SpGetSectionKeyIndex(*Handle,
                                   SIF_NEW_REPAIR_SIGNATURE,
                                   SIF_NEW_REPAIR_VERSION_KEY,
                                   0);      // should be moved to spsif.c
    if(Version == NULL) {
        SppRepairReportError(FALSE,
                             SP_SCRN_REPAIR_INF_ERROR,
                             SP_TEXT_REPAIR_INF_ERROR_2,
                             NULL,
                             0,
                             NULL);
    } else {
        if(!_wcsicmp(Version,SIF_NEW_REPAIR_NT_VERSION)) {
            return(TRUE);
        } else {
            SppRepairReportError(FALSE,
                                 SP_SCRN_REPAIR_INF_ERROR,
                                 SP_TEXT_REPAIR_INF_ERROR_5,
                                 NULL,
                                 0,
                                 NULL);
        }
    }

    //
    // Control comes here only when error occurs ...
    //

    SpFreeTextFile(*Handle);
    *Handle = NULL;
    return(FALSE);
}

VOID
SpRepairDiskette(
    OUT PVOID        *SifHandle,
    OUT PDISK_REGION *TargetRegion,
    OUT PWSTR        *TargetPath,
    OUT PDISK_REGION *SystemPartitionRegion,
    OUT PWSTR        *SystemPartitionDirectory
    )
/*++

Routine Description:

    This routine checks if there is a floppy drive.  If no, it returns
    silently.  Otherwise, it prompts user for Emergency Repair Disk.

Arguments:

    SifHandle - Supplies a variable to receive the setup.log file handle.

    TargetRegion - Supplies a variable to receive the pointer to the target
                installation region.

    TargetPath - Supplies a variable to receive the nt name of target path.

    SystemPartitionRegion - Supplies a variable to receive the pointer of the
                            system partition region.

    SystemPartitionDirectory - Supplies a variable to receive the osloader
                            directory name on the system partition.

Return Value:

    None.

--*/
{
    PWSTR szDiskName;
    BOOLEAN b, rc = FALSE;
    PWSTR FullLogFilename, p, FloppyDevicePath = L"\\device\\floppy0";
    PWSTR SystemPartition, WinntPartition;

    //
    // Assume failure.
    //

    *SifHandle = NULL;

    //
    // Always want to prompt for the disk in A:.
    // First, check if there is an A:.  If no floppy drive,
    // simply skip the request for ER diskette.
    //

    if(SpGetFloppyDriveType(0) == FloppyTypeNone) {
        return;
    }

    //
    // Fetch the generic repair disk name.
    //

    SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_TEXT_REPAIR_DISK_NAME);
    szDiskName = SpDupStringW(TemporaryBuffer);
    p = TemporaryBuffer;
    *p = 0;
    SpConcatenatePaths(p, FloppyDevicePath);
    SpConcatenatePaths(p, SETUP_LOG_FILENAME);
    FullLogFilename = SpDupStringW(p);

    while (rc == FALSE) {

        //
        // Prompt for the disk -- ignore what may be in the drive already,
        // and allow escape.
        //

        b = SpPromptForDisk(
                szDiskName,
                FloppyDevicePath,
                SETUP_LOG_FILENAME,
                TRUE,             // Always prompt for at least once
                TRUE,             // Allow user to cancel
                FALSE,            // No multiple prompts
                NULL              // don't care about redraw flag
                );


        //
        // If the user pressed escape at the disk prompt, bail out now.
        //

        if(!b) {
            rc = TRUE;            // User canceled. Skip repair floppy
        } else {
            rc = SpLoadRepairLogFile(FullLogFilename, SifHandle);
            if (rc) {

                //
                // Now we need to figure out the partition, path information
                // to update boot.ini.
                //

                SppGetRepairPathInformation(*SifHandle,
                                            &SystemPartition,
                                            SystemPartitionDirectory,
                                            &WinntPartition,
                                            TargetPath
                                            );

                *SystemPartitionRegion = SpRegionFromNtName(
                                            SystemPartition,
                                            PartitionOrdinalCurrent);
                if (*SystemPartitionRegion == NULL) {
                    SpFatalSifError(*SifHandle,
                                    SIF_NEW_REPAIR_PATHS,
                                    SIF_NEW_REPAIR_PATHS_SYSTEM_PARTITION_DEVICE,0,0);
                }
                *TargetRegion = SpRegionFromNtName(WinntPartition, PartitionOrdinalCurrent);
                if (*TargetRegion == NULL) {
                    SpFatalSifError(*SifHandle,
                                    SIF_NEW_REPAIR_PATHS,
                                    SIF_NEW_REPAIR_PATHS_TARGET_DEVICE,0,0);
                }
            }
        }
    }
    SpMemFree(szDiskName);
    SpMemFree(FullLogFilename);

    return;
}

VOID
SppRepairWinntFiles(
    IN PVOID LogFileHandle,
    IN PVOID MasterSifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice,
    IN PWSTR SystemPartition,
    IN PWSTR SystemPartitionDirectory,
    IN PWSTR WinntPartition,
    IN PWSTR WinntPartitionDirectory
    )

/*++

Routine Description:

    This routine goes through the system partition files and winnt files
    listed in the setup.log file and checks their validity.

Arguments:

    LogFileHandle - Handle of the setup.log

    MasterSifHandle - Handle of the txtsetup.sif

    SourceDevicePath - supplies the NT name of the source device

    DirectoryOnSourceDevice - supplies the directory on the source device
                       which contains source file.

Return Value:

    None.

--*/
{
    PWSTR SystemPartitionFiles = L"system partition files";
    PWSTR WinntFiles = L"WinNt files";
    ULONG TotalFileCount;
    BOOLEAN RepairWithoutConfirming;

    //
    // Create file repair gauge
    //

    TotalFileCount =  SpCountLinesInSection(LogFileHandle,SIF_NEW_REPAIR_SYSPARTFILES);
    TotalFileCount +=  SpCountLinesInSection(LogFileHandle,SIF_NEW_REPAIR_WINNTFILES);
    TotalFileCount +=  SpCountLinesInSection(LogFileHandle,SIF_NEW_REPAIR_FILES_IN_REPAIR_DIR);

    CLEAR_CLIENT_SCREEN();
    SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_TEXT_SETUP_IS_EXAMINING);
    RepairGauge = SpCreateAndDisplayGauge(TotalFileCount,0,15,TemporaryBuffer,NULL,GF_PERCENTAGE,0);
    ASSERT(RepairGauge);

    //
    // delay opening of driver inf and cab file till required
    //
    ghSif = MasterSifHandle;
    gszDrvInfDeviceName = SourceDevicePath;
    gszDrvInfDirName = DirectoryOnSourceDevice;


    SpDisplayStatusText(SP_STAT_PLEASE_WAIT,DEFAULT_STATUS_ATTRIBUTE);
    SppRepairScreenRepaint(NULL, NULL, TRUE);


    //
    // first recreate all of the directories we copy into
    //
    if (SystemPartition != NULL) {
        SpCreateDirectory(SystemPartition,NULL,SystemPartitionDirectory,0,0);
    }

    //
    // Create the nt tree.
    //
    SpCreateDirectoryStructureFromSif(MasterSifHandle,
                                      SIF_NTDIRECTORIES,
                                      WinntPartition,
                                      WinntPartitionDirectory);

    //
    // Verify and repair the files in [Files.InRepairDirectory].  If textmode
    // setup is executing a disaster recovery, do not prompt the user for the
    // files to repair.  Just go ahead and repair 'em.
    //

    RepairWithoutConfirming = SpDrEnabled() && SpDrIsRepairFast();

    SppVerifyAndRepairVdmFiles(LogFileHandle,
                               WinntPartition,
                               NULL,
                               &RepairWithoutConfirming);

    //
    // Verify and repair the files in [FIles.SystemPartition]
    //

    SppVerifyAndRepairFiles(LogFileHandle,
                            MasterSifHandle,
                            SIF_NEW_REPAIR_SYSPARTFILES,
                            SourceDevicePath,
                            DirectoryOnSourceDevice,
                            SystemPartition,
                            SystemPartitionDirectory,
                            TRUE,
                            &RepairWithoutConfirming);


    //
    // Verify and repair the files in [Files.WinNt]
    //

    SppVerifyAndRepairFiles(LogFileHandle,
                            MasterSifHandle,
                            SIF_NEW_REPAIR_WINNTFILES,
                            SourceDevicePath,
                            DirectoryOnSourceDevice,
                            WinntPartition,
                            NULL,
                            FALSE,
                            &RepairWithoutConfirming);

    SpDestroyGauge(RepairGauge);
    RepairGauge = NULL;
}


VOID
SppVerifyAndRepairFiles(
    IN PVOID LogFileHandle,
    IN PVOID MasterSifHandle,
    IN PWSTR SectionName,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice,
    IN PWSTR TargetDevicePath,
    IN PWSTR DirectoryOnTargetDevice,
    IN BOOLEAN SystemPartitionFiles,
    IN OUT PBOOLEAN RepairWithoutConfirming
    )

/*++

Routine Description:

    This routine goes through the files listed in the specified section of
    setup.log file and checks their validity.  If a file's checksum does
    not match the checksum listed in the setup.log file, we will prompt
    the user and recopy the file from original installation sources.

Arguments:

    LogFileHandle - Handle of the setup.log

    MasterSifHandle - Handle of the txtsetup.sif

    SectionName - Section in setup.log to be examined

    SourceDevicePath - supplies the NT name of the source device

    DirectoryOnSourceDevice - supplies the directory on the source device
                       which contains source file.

    TargetDevicePath - supplies the nt name of the target device

    DirectoryOnTargetDevice - the name of the winnt directory on target
                              device

    SystemPartitionFile - supplies a boolean value to indicate if the target
                          file is on system partition

    RepairWithoutConfirming - Pointer to a flag that indicates whether or not
                              setup should repair a damaged file without
                              asking the user to confirm.


Return Value:

    None.

--*/
{
    PWSTR FullTargetName, ChecksumString;
    PWSTR TargetDirectory, TargetFileName;
    PWSTR SourceFileName;
    ULONG Checksum, FileChecksum, PrefixLength, Length, Count, i;
    BOOLEAN IsNtImage, IsValid, RepairFile, SysPartNTFS = FALSE;
    BOOLEAN RedrawGauge = TRUE, ForceNoComp;
    FILE_TO_COPY FileToCopy;
    PWSTR OemDiskDescription, OemDiskTag, OemSourceDirectory;
    PWSTR DevicePath, Directory, q;
    PWSTR MediaShortName, PreviousMediaName = L"";
    PWSTR MediaDir;
    NTSTATUS    Status;

    //
    // Allocate a SMALL buffer for local use and init FileToCopy struct
    //

    TargetDirectory = NULL;
    FullTargetName = SpMemAlloc(1024);
    *FullTargetName = 0;
    FileToCopy.Next = NULL;
    FileToCopy.AbsoluteTargetDirectory = TRUE;

    FileToCopy.TargetDevicePath = TargetDevicePath;
    SpConcatenatePaths(FullTargetName,TargetDevicePath);

    if(SystemPartitionFiles) {

        PDISK_REGION    SystemPartitionRegion;

        //
        // We must find out whether the system partition is NTFS, because
        // if it is, then we might want to make sure it's not compressed.
        //
        if(SystemPartitionRegion = SpRegionFromNtName(TargetDevicePath,
                                                       PartitionOrdinalCurrent)) {
            SysPartNTFS = (SystemPartitionRegion->Filesystem == FilesystemNtfs);
        }

        //
        // For system partition files, we need to concatenate target
        // directory to FullTargetName.  Because the target filename
        // of system partition files do not have target directory.
        //

        FileToCopy.TargetDirectory = DirectoryOnTargetDevice;
        SpConcatenatePaths(FullTargetName,FileToCopy.TargetDirectory);
    }

    PrefixLength = wcslen(FullTargetName);

    Count = SpCountLinesInSection(LogFileHandle,SectionName);
    for (i = 0; i < Count; i++) {
        if (RedrawGauge) {
            SppRepairScreenRepaint(NULL, NULL, TRUE);
            RedrawGauge = FALSE;
        }
        SpTickGauge(RepairGauge);

        //
        // Initialize the 'ForceNoComp' flag to FALSE, thus allowing the
        // file to use NTFS compression.
        //
        ForceNoComp = FALSE;

        //
        // Initialize target fullname to be DevicePath+Directory for
        // system partition file or DevicePath for Winnt files
        //

        FullTargetName[PrefixLength] = (WCHAR)NULL;

        //
        // If we allocate space for TargetDirectory we must free it.
        //

        if (TargetDirectory) {
            SpMemFree(TargetDirectory);
            TargetDirectory = NULL;
        }
        TargetFileName = SpGetKeyName(LogFileHandle,SectionName,i);
        if(!TargetFileName) {
            SppRepairReportError(FALSE,
                                 SP_SCRN_REPAIR_INF_ERROR_0,
                                 SP_TEXT_REPAIR_INF_ERROR_1,
                                 SectionName,
                                 i,
                                 NULL);
            RedrawGauge = TRUE;
            continue;
        }

        //
        // If the target file name contains \system32\config\, it is
        // hive related file.  We simply ignore it.
        //

        q = SpDupStringW(TargetFileName);
        SpStringToUpper(q);
        if (wcsstr(q,L"\\SYSTEM32\\CONFIG\\")) {
            SpMemFree(q);
            continue;
        }
        SpMemFree(q);

        SpConcatenatePaths(FullTargetName,TargetFileName);
        SpDisplayStatusText(SP_STAT_EXAMINING_WINNT,
                            DEFAULT_STATUS_ATTRIBUTE,
                            TargetFileName);

        ChecksumString = SpGetSectionLineIndex(LogFileHandle,SectionName,i,1);
        if(!ChecksumString) {
            SppRepairReportError(FALSE,
                                 SP_SCRN_REPAIR_INF_ERROR_0,
                                 SP_TEXT_REPAIR_INF_ERROR_1,
                                 SectionName,
                                 i,
                                 NULL);
            RedrawGauge = TRUE;
            continue;
        }

        Checksum = (ULONG)SpStringToLong(ChecksumString, NULL, 16);

        //
        // Validate the security set on the file.
        // Note that we do not check the files in the system partition
        // on non-x86 systems since it is always FAT
        //
#if !defined(_AMD64_) && !defined(_X86_)
        if(!SystemPartitionFiles) {
#endif // !defined(_AMD64_) && !defined(_X86_)
            Status = SpVerifyFileAccess( FullTargetName,
                                         STANDARD_RIGHTS_READ |
                                         FILE_READ_ATTRIBUTES |
                                         FILE_WRITE_ATTRIBUTES |
                                         DELETE |
                                         WRITE_DAC |
                                         SYNCHRONIZE );


            if( !NT_SUCCESS( Status ) &&
                ((Status == STATUS_ACCESS_DENIED)||(Status == STATUS_PRIVILEGE_NOT_HELD)) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SETUP: Security of %ls, must be fixed. Status = %x\n", FullTargetName, Status ));
                Status = SpSetDefaultFileSecurity( FullTargetName );
                if( !NT_SUCCESS( Status ) ) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SETUP: unable to change security of %ls. Status = %x\n", FullTargetName, Status ));

                }
            }

#if !defined(_AMD64_) && !defined(_X86_)
        }
#endif // !defined(_AMD64_) && !defined(_X86_)

        //
        // If this is a system partition file and the system partition is NTFS,
        // then check to see whether this file can use NTFS compression, and
        // if not, force it to be uncompressed.
        //
        if((SysPartNTFS) &&
           IsFileFlagSet(MasterSifHandle,TargetFileName,FILEFLG_FORCENOCOMP))
        {
            ForceNoComp = TRUE;
            SpVerifyNoCompression(FullTargetName);
        }

        SpValidateAndChecksumFile(NULL,FullTargetName,&IsNtImage,&FileChecksum,&IsValid);

        //
        // If the image is invalid or the file on the target is not the
        // original file copied by setup, we will recopy it.
        //

        if (!IsValid || FileChecksum != Checksum) {

            //
            // Ask user if he wants to repair the file
            //
            if(*RepairWithoutConfirming) {
                RepairFile = TRUE;
            } else {
                RepairFile = SppRepairReportError(
                                TRUE,
                                SP_SCRN_REPAIR_FILE_MISMATCH,
                                SP_TEXT_REPAIR_INF_ERROR_4,
                                TargetFileName,
                                i,
                                RepairWithoutConfirming);
                RedrawGauge = TRUE;
            }

            if (!RepairFile) {
                continue;
            }
            SpDisplayStatusText(SP_STAT_REPAIR_WINNT,
                                DEFAULT_STATUS_ATTRIBUTE,
                                TargetFileName);

            if (SystemPartitionFiles) {
                FileToCopy.TargetFilename = TargetFileName;
            } else {

                //
                // For Winnt files, the TargetName contains path and filename.
                // We need to seperate them.
                //

                TargetDirectory = SpDupStringW(TargetFileName);
                Length = wcslen(TargetDirectory);
                while (Length) {
                    if (TargetDirectory[Length] == L'\\') {
                        TargetDirectory[Length] = 0;
                        TargetFileName = &TargetDirectory[Length + 1];
                        break;
                    } else {
                        Length--;
                    }
                }
                if (Length == 0) {
                    SppRepairReportError(FALSE,
                                         SP_SCRN_REPAIR_INF_ERROR_0,
                                         SP_TEXT_REPAIR_INF_ERROR_1,
                                         SectionName,
                                         i,
                                         NULL);
                    RedrawGauge = TRUE;
                    continue;
                }
                FileToCopy.TargetFilename = TargetFileName;
                FileToCopy.TargetDirectory = TargetDirectory;
            }
            SourceFileName = SpGetSectionLineIndex(LogFileHandle,SectionName,i,0);
            if (!SourceFileName) {
                SppRepairReportError(FALSE,
                                     SP_SCRN_REPAIR_INF_ERROR_0,
                                     SP_TEXT_REPAIR_INF_ERROR_1,
                                     SectionName,
                                     i,
                                     NULL);
                RedrawGauge = TRUE;
                continue;
            }


            FileToCopy.SourceFilename = NULL;
            q = SpDupStringW(SourceFileName);
            SpStringToUpper(q);
            if (wcsstr(q,L"DRIVER.CAB")) {
                SpMemFree(q);
                q = SpDupStringW(TargetFileName);
                SpStringToUpper(q);
                if (!wcsstr(q,L"DRIVER.CAB")) {
                    FileToCopy.SourceFilename = TargetFileName;
                }
            }
            SpMemFree(q);

            FileToCopy.SourceFilename = FileToCopy.SourceFilename
                                        ? FileToCopy.SourceFilename
                                        : SourceFileName;
            FileToCopy.Flags = COPY_ALWAYS | COPY_NOVERSIONCHECK | (ForceNoComp ? COPY_FORCENOCOMP : 0);


            //
            // The file may come from OEM diskette. We need to check if the
            // sources device is listed in log file.  If not, it must be
            // from MS setup sources.
            //

            OemSourceDirectory = SpGetSectionLineIndex(LogFileHandle,SectionName,i,2);
            OemDiskTag = NULL;
            if (OemSourceDirectory) {
                OemDiskDescription = SpGetSectionLineIndex(LogFileHandle,SectionName,i,3);
                if (OemDiskDescription) {
                    OemDiskTag = SpGetSectionLineIndex(LogFileHandle,SectionName,i,4);
                    if((OemDiskTag != NULL) &&
                       (wcslen(OemDiskTag) == 0)){
                        OemDiskTag = SourceFileName;
                    }
                }
            }

            if (OemDiskTag) {
                BOOLEAN rs;
                PWSTR   szDevicePath = SpDupStringW(L"\\device\\floppy0");

                //
                // Prompt for the disk, based on the setup media type.
                //

                rs = SpPromptForDisk(
                           OemDiskDescription,
                           szDevicePath,
                           OemDiskTag,
                           FALSE,          // don't ignore disk in drive
                           TRUE,           // allow escape
                           TRUE,           // warn about multiple prompts for same disk
                           NULL            // don't care redraw flag
                           );

                SpMemFree(szDevicePath);
                RedrawGauge = TRUE;

                if (rs == FALSE) {
                    continue;
                }

                DevicePath = L"\\device\\floppy0";
                Directory = OemSourceDirectory;
                MediaDir = NULL;
            } else {
                PWSTR   szDescription = 0, szTagFileName = 0;
                BOOLEAN bDiskFound = FALSE;

                //
                // Search SourceFileName against txtsetup.sif to figure out its
                // media name.
                //
                MediaShortName = SpLookUpValueForFile(
                                    MasterSifHandle,
                                    SourceFileName,
                                    INDEX_WHICHMEDIA,
                                    FALSE
                                    );

                if(MediaShortName) {
                    SpGetSourceMediaInfo(MasterSifHandle,MediaShortName,NULL,NULL,&MediaDir);
                } else {
                    SpNonFatalSifError(
                        MasterSifHandle,
                        SIF_FILESONSETUPMEDIA,
                        SourceFileName,
                        0,
                        INDEX_WHICHMEDIA,
                        SourceFileName
                        );
                    //
                    // If we returned from SpNonFatalSifError, then the user wants to
                    // skip the file.
                    //
                    RedrawGauge = TRUE;
                    continue;
                }

                //
                // Prompt user to insert the source media, if changed.
                //
                SpGetSourceMediaInfo(MasterSifHandle, MediaShortName,
                                        &szDescription, &szTagFileName, NULL);

                //
                // Prompt for the disk, based on the setup media type.
                //
                bDiskFound = SpPromptForDisk(
                                szDescription,
                                SourceDevicePath,
                                szTagFileName,
                                FALSE,          // don't ignore disk in drive
                                TRUE,           // don't allow escape
                                TRUE,           // warn about multiple prompts for same disk
                                NULL            // don't care redraw flag
                                );

                RedrawGauge = TRUE;

                //
                // user might have wanted to skip the file
                //
                if (!bDiskFound)
                    continue;

                DevicePath = SourceDevicePath;
                Directory = DirectoryOnSourceDevice;
            }

            //
            // Copy the file.
            //
            // If the file is listed for lock smashing then we need to smash it
            // if installing UP on x86 (we don't bother with the latter
            // qualifications here).
            //

            SpCopyFileWithRetry(
                &FileToCopy,
                DevicePath,
                Directory,
                MediaDir,
                NULL,                          // TargetRoot -> NULL
                SystemPartitionFiles ? FILE_ATTRIBUTES_RHS : 0,
                SppRepairScreenRepaint,
                NULL,                          // Do not want checksum
                NULL,                          // Do not want to know if file was skipped
                IsFileFlagSet(
                    MasterSifHandle,
                    FileToCopy.TargetFilename,
                    FILEFLG_SMASHLOCKS) ? COPY_SMASHLOCKS : 0
                );
        }
    }

    SpMemFree(FullTargetName);
    if (RedrawGauge) {
        SppRepairScreenRepaint(NULL, NULL, TRUE);
    }
}


BOOLEAN
SpDisplayRepairMenu(
    VOID
    )
/*++

Routine Description:

    This routine presents a list of repairable items to user and
    let user choose the items to be fixed among the list.

Arguments:

    None.

Return Value:

    None. Some global repare variables are set or cleared.

--*/

{
    PVOID Menu;
    ULONG MenuTopY;
    ULONG ValidKeys[] = { KEY_F3, ASCI_CR, ASCI_ESC, 0 };
    ULONG Keypress, MessageIds[RepairItemMax];
    ULONG i;
    ULONG_PTR OptionChosen, InitialHighlight;
    PWSTR MenuItem;
    ULONG ListBoxWidth, curLBEntryWidth;

    //
    // Initialize repair options to repair ALL.
    // Initialize repair menu item message id.
    //

    for (i = 0; i < RepairItemMax; i++) {
        RepairItems[i] = 1;
        if (i == 0) {
            MessageIds[i] = SP_REPAIR_MENU_ITEM_1;
        } else {
            MessageIds[i] = MessageIds[i - 1] + 1;
        }
    }

    while(1) {

        //
        // Display the text that goes above the menu on the partitioning screen.
        //

        SpDisplayScreen(SP_SCRN_REPAIR_MENU,3,CLIENT_TOP+1);

        //
        // Calculate menu placement.  Leave one blank line
        // and one line for a frame.
        //

        MenuTopY = NextMessageTopLine + (SplangQueryMinimizeExtraSpacing() ? 2 : 5);

        //
        // Create a menu.
        // First, find the longest string, so we can size the listbox accordingly
        //
        ListBoxWidth = LIST_BOX_WIDTH;   // It will be at least this wide
        for (i = 0; i <= RepairItemMax; i++ ) {
            if (i == RepairItemMax) {
                SpFormatMessage(TemporaryBuffer,
                                sizeof(TemporaryBuffer),
                                SP_REPAIR_MENU_ITEM_CONTINUE);
            } else {
#pragma prefast(suppress:201, "Logic takes care of the condition where buffer index refers beyond the buffer size")            
                SpFormatMessage(TemporaryBuffer,
                                sizeof(TemporaryBuffer),
                                MessageIds[i]);
            }
            if((curLBEntryWidth = SplangGetColumnCount(TemporaryBuffer)+(2*MENU_INDENT)) > ListBoxWidth) {
                ListBoxWidth = min(curLBEntryWidth, MENU_WIDTH);
            }
        }

        Menu = SpMnCreate(
                    MENU_LEFT_X,
                    MenuTopY,
                    ListBoxWidth,
                    LIST_BOX_HEIGHT
                    );

        if( !Menu )
            return FALSE;

        ASSERT(Menu);

        for (i = 0; i <= RepairItemMax; i++ ) {
            if (i == RepairItemMax) {
                SpFormatMessage(TemporaryBuffer,
                                sizeof(TemporaryBuffer),
                                SP_REPAIR_MENU_ITEM_CONTINUE);
            } else {
#pragma prefast(suppress:201, "Logic takes care of the condition where buffer index refers beyond the buffer size")                        
                SpFormatMessage(TemporaryBuffer,
                                sizeof(TemporaryBuffer),
                                MessageIds[i]);

                (TemporaryBuffer)[1] = RepairItems[i] ? L'X' : L' ';
            }
            SpMnAddItem(Menu,
                        TemporaryBuffer,
                        MENU_LEFT_X+MENU_INDENT,
                        ListBoxWidth-(2*MENU_INDENT),
                        TRUE,
                        i
                        );
        }
        InitialHighlight = RepairItemMax;

        //
        // Initialize the status line.
        //

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_F3_EQUALS_EXIT,
            SP_STAT_ESC_EQUALS_CANCEL,
            SP_STAT_ENTER_EQUALS_CHANGE,
            0
            );

DisplayMenu:

        //
        // Display the menu
        //

        SpMnDisplay(
            Menu,
            InitialHighlight,
            TRUE,
            ValidKeys,
            NULL,
            NULL,
            NULL,
            &Keypress,
            &OptionChosen
            );

        //
        // Now act on the user's selection.
        //

        switch(Keypress) {


            case KEY_F3:
                SpConfirmExit();
                break;

            case ASCI_CR:
                if (OptionChosen == RepairItemMax) {
                    SpMnDestroy(Menu);
                    return( TRUE );
                } else {
                    MenuItem = SpMnGetText(Menu, OptionChosen);
                    if( !MenuItem )
                        goto DisplayMenu;
                    RepairItems[OptionChosen] ^= 1;
                    if (RepairItems[OptionChosen]) {
                        MenuItem[1] = L'X';
                    } else {
                        MenuItem[1] = L' ';
                    }
                    InitialHighlight = OptionChosen;
                    goto DisplayMenu;
                }
                break;

            default:
                SpMnDestroy(Menu);
                return(FALSE);
        }
        SpMnDestroy(Menu);
    }
}

NTSTATUS
SppRepairFile(
    IN PVOID MasterSifHandle,
    IN PWSTR TargetPath,
    IN PWSTR TargetFilename,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice,
    IN PWSTR SourceFilename,
    IN BOOLEAN SystemPartitionFile
    )

/*++

Routine Description:

    This routine repairs ONE file and the source of the file MUST be on
    emergency repair diskette or on the repair directory of the winnt
    being repaired.

Arguments:

    MasterSifHandle - Hanle of the txtsetup.sif

    TargetPath - Supplies the target file path

    TargetFilename - supplies the name of the target file

    SourceDevicePath - supplies the NT name of the source device

    DirectoryOnSourceDevice - supplies the directory on the source device
                       which contains source file.

    SourceFilename - supplies the name of the source file

    SystemPartitionFile - supplies a boolean value to indicate if the target
                          file is on system partition

Return Value:

    NTSTATUS of the file copy.

--*/
{
    PWSTR szDiskName;
    PWSTR FullSourceFilename, FullTargetFilename;
    NTSTATUS Status;

    if (RepairFromErDisk) {

        //
        // Fetch the generic repair disk name.
        //

        SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),
                        SP_TEXT_REPAIR_DISK_NAME);
        szDiskName = SpDupStringW(TemporaryBuffer);

        //
        // Prompt for the disk -- do not ignore what may be in the drive
        // already, and dont allow escape.
        //

        SpPromptForDisk(
                szDiskName,
                SourceDevicePath,
                SETUP_LOG_FILENAME,
                FALSE,              // if disk is in already dont prompt
                FALSE,              // Do not allow user to cancel
                TRUE,               // warn for multiple prompts
                NULL                // don't care about redraw flag
                );


        SpMemFree(szDiskName);
    }

    //
    // Form the name of the source and target fullname.
    //

    wcscpy(TemporaryBuffer, TargetPath);
    SpConcatenatePaths(TemporaryBuffer, TargetFilename);
    FullTargetFilename = SpDupStringW(TemporaryBuffer);

    wcscpy(TemporaryBuffer, SourceDevicePath);
    SpConcatenatePaths(TemporaryBuffer, DirectoryOnSourceDevice);
    SpConcatenatePaths(TemporaryBuffer, SourceFilename);
    FullSourceFilename = SpDupStringW(TemporaryBuffer);

    //
    // Copy the file.
    //
    // If the file is listed for lock smashing then we need to smash it
    // if installing UP on x86 (we don't bother with the latter
    // qualifications here).
    //

    Status = SpCopyFileUsingNames(
               FullSourceFilename,
               FullTargetFilename,
               SystemPartitionFile ? FILE_ATTRIBUTES_RHS : 0,
               IsFileFlagSet(MasterSifHandle,TargetFilename,FILEFLG_SMASHLOCKS) ? COPY_SMASHLOCKS : 0
               );

    SpMemFree(FullSourceFilename);
    SpMemFree(FullTargetFilename);
    return(Status);
}

VOID
SppRepairStartMenuGroupsAndItems(
    IN PWSTR        WinntPartition,
    IN PWSTR        WinntDirectory
    )

/*++

Routine Description:

    This routine loads the software hive, and set a value on Winlogon key
    to indicate to Winlogon that it should recreate the Start Menu groups
    and items for the Default User.

Arguments:

    WinntPartition - supplies the NT name of the Winnt partition.

    WinntDirectory - Supplies the name of the Winnt directory.


Return Value:

    None.

--*/
{
    NTSTATUS          Status;
    PWSTR             p,q;
    PWSTR             LOCAL_MACHINE_KEY_NAME = L"\\registry\\machine";
    ULONG             Repair = 1;
    PWSTR             WINLOGON_KEY_NAME = L"Microsoft\\Windows NT\\CurrentVersion\\Winlogon";
    PWSTR             REPAIR_VALUE_NAME = L"Repair";
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING    UnicodeString;
    HANDLE            SoftwareKey;

    //
    // Put up a screen telling the user what we are doing.
    //

//    SpStartScreen(SP_SCRN_REPAIR_CHECK_HIVES,
//                  0,
//                  8,
//                  TRUE,
//                  FALSE,
//                  DEFAULT_ATTRIBUTE
//                  );
//
//    SpDisplayStatusText(SP_STAT_REG_LOADING_HIVES,DEFAULT_STATUS_ATTRIBUTE);

    //
    // Load the software hive
    //

    //
    // Form the name of the hive file.
    // This is WinntPartition + WinntDirectory + system32\config + the hive name.
    //
    p = NULL;
    q = NULL;
    wcscpy(TemporaryBuffer,WinntPartition);
    SpConcatenatePaths(TemporaryBuffer,WinntDirectory);
    SpConcatenatePaths(TemporaryBuffer,L"system32\\config\\software");
    p = SpDupStringW( TemporaryBuffer );

    //
    // Form the path of the key into which we will
    // load the hive.  We'll use the convention that
    // a hive will be loaded into \registry\machine\x<hivename>.
    //

    wcscpy(TemporaryBuffer,LOCAL_MACHINE_KEY_NAME);
    SpConcatenatePaths(TemporaryBuffer,L"x");
    wcscat(TemporaryBuffer,L"software");
    q = SpDupStringW( TemporaryBuffer );

    if( (p == NULL) || (q == NULL) ) {
        goto fix_strtmenu_cleanup_1;
    }

    //
    // Attempt to load the hive.
    //

    Status = SpLoadUnloadKey(NULL,NULL,q,p);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to load hive %ws to key %ws (%lx)\n",p,q,Status));
        goto fix_strtmenu_cleanup_1;
    }

    INIT_OBJA(&Obja,&UnicodeString,q);
    Status = ZwOpenKey(&SoftwareKey,KEY_ALL_ACCESS,&Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ws (%lx)\n",q,Status));
        goto fix_strtmenu_cleanup_2;
    }

    Status = SpOpenSetValueAndClose(
                SoftwareKey,
                WINLOGON_KEY_NAME,
                REPAIR_VALUE_NAME,
                REG_DWORD,
                &Repair,
                sizeof(ULONG)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set value %ws on key %ws. Status = %lx\n",REPAIR_VALUE_NAME,REPAIR_VALUE_NAME,Status));
        goto fix_strtmenu_cleanup_3;
    }
    Status = ZwFlushKey(SoftwareKey );

fix_strtmenu_cleanup_3:

    Status = ZwClose( SoftwareKey );

fix_strtmenu_cleanup_2:

    Status = SpLoadUnloadKey(NULL,NULL,q,NULL);

fix_strtmenu_cleanup_1:
    if( p != NULL ) {
        SpMemFree( p );
    }
    if( q != NULL ) {
        SpMemFree( q );
    }
}

VOID
SppInspectHives(
    IN PWSTR        PartitionPath,
    IN PWSTR        SystemRoot,
    OUT PULONG      HiveLoaded,
    IN PWSTR        *HiveNames
    )

/*++

Routine Description:

    This routine inspects setup hives by loading and unloading them and
    returns the loadable information in HiveLoaded[].

Arguments:

    PartitionPath - supplies the NT name of the Winnt partition.

    SystemRoot - Supplies the name of the Winnt System root.

    HiveLoaded - Supplies a pointer to a ULONG array to receive the
                 loadable information for each hive inspected.

    HIveNames - Supplies a pointer to a PWSTR array to receive the
                name of hives to inspect.

Return Value:

    None.  HiveLoaded array initialized.

--*/
{
    NTSTATUS Status;
    PWSTR pwstrTemp1,pwstrTemp2;
    int h;
    PWSTR   LOCAL_MACHINE_KEY_NAME = L"\\registry\\machine";

    //
    // Put up a screen telling the user what we are doing.
    //

    SpStartScreen(SP_SCRN_REPAIR_CHECK_HIVES,
                  0,
                  8,
                  TRUE,
                  FALSE,
                  DEFAULT_ATTRIBUTE
                  );

    SpDisplayStatusText(SP_STAT_REG_LOADING_HIVES,DEFAULT_STATUS_ATTRIBUTE);

    //
    // Load each template hive we care about from the target tree.
    //

    for (h = 0; h < RepairHiveMax; h++) {

        pwstrTemp1 = TemporaryBuffer;
        pwstrTemp2 = TemporaryBuffer + (sizeof(TemporaryBuffer) / sizeof(WCHAR) / 2);

        if( h != RepairHiveUser ) {
            //
            // Form the name of the hive file.
            // This is partitionpath + sysroot + system32\config + the hive name.
            //

            wcscpy(pwstrTemp1,PartitionPath);
            SpConcatenatePaths(pwstrTemp1,SystemRoot);
            SpConcatenatePaths(pwstrTemp1,L"system32\\config");
            SpConcatenatePaths(pwstrTemp1,HiveNames[h]);

        } else {
            wcscpy(pwstrTemp1,PartitionPath);
            SpConcatenatePaths(pwstrTemp1,DEFAULT_USER_PATH);
            SpConcatenatePaths(pwstrTemp1,HiveNames[h]);
        }

        //
        // First we must verify that the hive file exists.  We have to do
        // this because loading a hive will create one if it didn't already
        // exist!
        //
        if(!SpFileExists(pwstrTemp1, FALSE)) {
            HiveLoaded[h] = 0;
            continue;
        }

        //
        // Form the path of the key into which we will
        // load the hive.  We'll use the convention that
        // a hive will be loaded into \registry\machine\x<hivename>.
        //

        wcscpy(pwstrTemp2,LOCAL_MACHINE_KEY_NAME);
        SpConcatenatePaths(pwstrTemp2,L"x");
        wcscat(pwstrTemp2,HiveNames[h]);

        //
        // Attempt to load the hive.
        //

        HiveLoaded[h] = 0;
        Status = SpLoadUnloadKey(NULL,NULL,pwstrTemp2,pwstrTemp1);

        if (NT_SUCCESS(Status) || Status == STATUS_NO_MEMORY) {

            //
            // If the reason the hive did not load is because of not
            // enough memory.  We assume the hive is OK.
            //

            HiveLoaded[h] = 1;

            //
            // Unload the hive.
            //

            SpLoadUnloadKey(NULL,NULL,pwstrTemp2,NULL);
        }
    }

    //
    // Sam and security hives must be updated together.  If any one of
    // them failed to load, we must update both.
    //

    if ((HiveLoaded[RepairHiveSecurity] == 0) ||
        (HiveLoaded[RepairHiveSam] == 0)) {
        HiveLoaded[RepairHiveSam] = 0;
        HiveLoaded[RepairHiveSecurity] = 0;
    }
}

VOID
SppRepairHives(
    PVOID MasterSifHandle,
    PWSTR WinntPartition,
    PWSTR WinntPartitionDirectory,
    PWSTR SourceDevicePath,
    PWSTR DirectoryOnSourceDevice
    )
/*++

Routine Description:

    This routine inspects hives and let user choose the hives which he
    wants to repair.

Arguments:

    MasterSifHandle - The handle of textsetup.sif

    WinntPartition - The nt name of Winnt partition

    WinntPartitionDirectory - The directory name of winnt installation

    SourceDevicePath - The NT name of source device which contains hives

    DirectoryOnSourceDevice - The directory name of source device

Return Value:

    None.

--*/

{
    //
    //  Do not change the order of the files in 'HiveNames' array.
    //  If you do that, you also need to change the order of the
    //  enum 'RepairHive' in spntfix.h
    //
    PWSTR HiveNames[RepairHiveMax] = { L"system",L"software",L"default",L"ntuser.dat",L"security",L"sam"};
    ULONG HiveLoaded[RepairHiveMax];
    PVOID Menu;
    ULONG MenuTopY;
    ULONG ValidKeys[] = { KEY_F3, ASCI_CR, 0 };
    ULONG ValidKeys1[] = { KEY_F3, ASCI_CR, 0 };
    ULONG i;
    ULONG_PTR InitialHighlight, OptionChosen;
    PWSTR MenuItem, TargetPath, p;
    ULONG Keypress, MessageIds[RepairHiveMax];
    BOOLEAN Selectable;
    NTSTATUS Status;
    ULONG ListBoxWidth, curLBEntryWidth;
    BOOLEAN DetermineHivesToRepair;

    //
    // Inspect hives by loading hives to determine which hives need to be
    // fixed.
    //

    SppInspectHives(WinntPartition,
                    WinntPartitionDirectory,
                    HiveLoaded,
                    HiveNames);

    // BCL - Seagate: If doing ASR, don't do the menu.
    if ( SpDrEnabled() ) {
        goto UpdateTheHives;
    }

    //
    // Initialize hive menu item message id.
    //

    for (i = 0; i < RepairHiveMax; i++) {
        if (i == 0) {
            MessageIds[i] = SP_REPAIR_HIVE_ITEM_1;
        } else {
            MessageIds[i] = MessageIds[i - 1] + 1;
        }
    }


    DetermineHivesToRepair = TRUE;
    while(DetermineHivesToRepair) {
        //
        // Display the text that goes above the menu on the partitioning screen.
        //

        SpDisplayScreen(SP_SCRN_REPAIR_HIVE_MENU,3,CLIENT_TOP+1);

        //
        // Calculate menu placement.  Leave one blank line
        // and one line for a frame.
        //

        MenuTopY = NextMessageTopLine + (SplangQueryMinimizeExtraSpacing() ? 2 : 5);

        //
        // Create a menu.
        // First, find the longest string, so we can size the listbox accordingly
        //
        ListBoxWidth = HIVE_LIST_BOX_WIDTH;   // It will be at least this wide
        for (i = 0; i <= RepairHiveMax; i++ ) {
            if (i == RepairHiveMax) {
                SpFormatMessage(TemporaryBuffer,
                                sizeof(TemporaryBuffer),
                                SP_REPAIR_MENU_ITEM_CONTINUE);
            } else {
#pragma prefast(suppress:201, "Logic takes care of the condition where buffer index refers beyond the buffer size")            
                SpFormatMessage(TemporaryBuffer,
                                sizeof(TemporaryBuffer),
                                MessageIds[i]);
            }
            if((curLBEntryWidth = SplangGetColumnCount(TemporaryBuffer)+(2*MENU_INDENT)) > ListBoxWidth) {
                ListBoxWidth = min(curLBEntryWidth, MENU_WIDTH);
            }
        }

        Menu = SpMnCreate(
                    MENU_LEFT_X,
                    MenuTopY,
                    ListBoxWidth,
                    HIVE_LIST_BOX_HEIGHT
                    );

        ASSERT(Menu);

        //
        // Build up a menu of hives
        //

        for (i = 0; i <= RepairHiveMax; i++ ) {
            if (i == RepairHiveSam) {
                Selectable = FALSE;
            } else {
                Selectable = TRUE;
            }
            if (i == RepairHiveMax) {
                SpFormatMessage(TemporaryBuffer,
                                sizeof(TemporaryBuffer),
                                SP_REPAIR_MENU_ITEM_CONTINUE);
            } else {
#pragma prefast(suppress:201, "Logic takes care of the condition where buffer index refers beyond the buffer size")                       
                SpFormatMessage(TemporaryBuffer,
                                sizeof(TemporaryBuffer),
                                MessageIds[i]);
                p = TemporaryBuffer;
#pragma prefast(suppress:201, "Logic takes care of the condition where buffer index refers beyond the buffer size")                                       
                if (HiveLoaded[i] || ( i == RepairHiveSam )) {
                    p[1] = L' ';
                } else {
                    p[1] = L'X';
                }
            }
            SpMnAddItem(Menu,
                        TemporaryBuffer,
                        MENU_LEFT_X+MENU_INDENT,
                        ListBoxWidth-(2*MENU_INDENT),
                        Selectable,
                        i
                        );
        }
        InitialHighlight = RepairHiveMax;

        //
        // Initialize the status line.
        //

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_CHANGE,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

DisplayMenu:

        //
        // Display the menu
        //

        SpMnDisplay(
            Menu,
            InitialHighlight,
            TRUE,
            ValidKeys,
            NULL,
            NULL,
            NULL,
            &Keypress,
            &OptionChosen
            );

        //
        // Now act on the user's selection.
        //

        switch(Keypress) {


            case KEY_F3:
                SpConfirmExit();
                break;

            case ASCI_CR:
                if (OptionChosen == RepairHiveMax) {
                    SpMnDestroy(Menu);
                    DetermineHivesToRepair = FALSE;
                } else {
                    HiveLoaded[OptionChosen] ^= 1;
                    MenuItem = SpMnGetText(Menu, OptionChosen);
                    if ((HiveLoaded[OptionChosen] != 0) ||
                        (OptionChosen == RepairHiveSam)){
                        MenuItem[1] = L' ';
                    } else {
                        MenuItem[1] = L'X';
                    }

                    //
                    // Security and sam must go together.
                    //

                    HiveLoaded[RepairHiveSam] = HiveLoaded[RepairHiveSecurity];
                    InitialHighlight = OptionChosen;
                    goto DisplayMenu;
                }
                break;
        }
    }

UpdateTheHives:

    //
    // At this point user has decided which hives to repair.
    // We will copy the hives from repair disk to
    // Winnt\system32\config directory.
    //

    for (i = 0; i < RepairHiveMax; i++ ) {

        // BCL - Seagate: Don't do ntuser.dat. As of 4/17/98, there is no
        // copy of this file to copy from.
        if ( SpDrEnabled() && i == RepairHiveUser ) {
            continue;
        }

        if (HiveLoaded[i] == 0) {

            //
            // Form Target path
            //

            if( i != RepairHiveUser ) {
                wcscpy(TemporaryBuffer, WinntPartition);
                SpConcatenatePaths(TemporaryBuffer, WinntPartitionDirectory);
                SpConcatenatePaths(TemporaryBuffer, L"\\SYSTEM32\\CONFIG");
                TargetPath = SpDupStringW(TemporaryBuffer);
            } else {
                wcscpy(TemporaryBuffer, WinntPartition);
                SpConcatenatePaths(TemporaryBuffer, WinntPartitionDirectory);
                SpConcatenatePaths(TemporaryBuffer, DEFAULT_USER_PATH);
                TargetPath = SpDupStringW(TemporaryBuffer);
            }

            Status = SppRepairFile(MasterSifHandle,
                                   TargetPath,
                                   HiveNames[i],
                                   SourceDevicePath,
                                   DirectoryOnSourceDevice,
                                   HiveNames[i],
                                   FALSE
                                   );
            if (!NT_SUCCESS(Status)) {

                //
                // Tell user we couldn't do it.  Options are to continue or exit.
                //

                SpStartScreen(
                    SP_SCRN_REPAIR_HIVE_FAIL,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE
                    );

                SpDisplayStatusOptions(
                    DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_ENTER_EQUALS_CONTINUE,
                    SP_STAT_F3_EQUALS_EXIT,
                    0
                    );

                switch(SpWaitValidKey(ValidKeys1,NULL,NULL)) {
                    case ASCI_CR:
                         return;
                         break;

                    case KEY_F3:
                         SpConfirmExit();
                         break;
                }
            }
            SpMemFree(TargetPath);
        }
    }
}

VOID
SpRepairWinnt(
    IN PVOID LogFileHandle,
    IN PVOID MasterSifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice
    )

/*++

Routine Description:

    This is a the top level repair rutine.  It calls worker routines
    for each repair options that user selected.

Arguments:

    LogFileHandle - Handle of the setup.log

    MasterSifHandle - Handle of the txtsetup.sif

    SourceDevicePath - The NT name for the repair source device.

    DirectoryOnSourceDevice -  The directory name on the repair source
                               device which contains the source files.

Return Value:

    None.

--*/
{

    PWSTR SystemPartition, SystemPartitionDirectory;
    PWSTR WinntPartition, WinntPartitionDirectory;
    PWSTR HiveRepairSourceDevice, DirectoryOnHiveRepairSource;

    //
    // Initialize the diamond decompression engine.
    //
    SpdInitialize();

    //
    // Determine SystemPartition, SystemPartitionDirectory.
    // WinntParition and WinntPartitionDirectory of the WINNT
    // installation to be repaired.
    //

    SppGetRepairPathInformation(LogFileHandle,
                                &SystemPartition,
                                &SystemPartitionDirectory,
                                &WinntPartition,
                                &WinntPartitionDirectory
                                );

    //
    //  If repair involves disk access, then run autochk on Nt and system
    //  partitions.
    //
    if( RepairItems[RepairFiles]
#if defined(_AMD64_) || defined(_X86_)
        ||
        RepairItems[RepairNvram]
#endif // defined(_AMD64_) || defined(_X86_)
      ) {
        PDISK_REGION    SystemPartitionRegion;
        PDISK_REGION    WinntPartitionRegion;

        WinntPartitionRegion = SpRegionFromNtName( WinntPartition,
                                                    PartitionOrdinalCurrent);

        SystemPartitionRegion = SpRegionFromNtName( SystemPartition,
                                                     PartitionOrdinalCurrent);

        if( !RepairNoCDROMDrive ) {
            //
            //  If we know that the system doesn't have a CD-ROM drive,
            //  then don't even attempt to run autochk.
            //
            SpRunAutochkOnNtAndSystemPartitions( MasterSifHandle,
                                                 WinntPartitionRegion,
                                                 SystemPartitionRegion,
                                                 SourceDevicePath,
                                                 DirectoryOnSourceDevice,
                                                 NULL
                                                 );
        }
    }

    //
    // Verify and repair security of the directories that form the NT tree
    // This needs to be done before repairing the hives because the
    // system32\config directory might not be there anymore!
    //
    SppVerifyAndRepairNtTreeAccess(MasterSifHandle,
                                   WinntPartition,
                                   WinntPartitionDirectory,
                                   SystemPartition,
                                   SystemPartitionDirectory
                                   );

#if 0
// BCL - Seagate - the RepairHives member has been removed from the
// struct

    if (RepairItems[RepairHives]) {

        //
        // User has selected to repair hives.  If user has provided the
        // ER disk, we will copy the hive from ER disk to repair damaged
        // hives.  Otherwise we copy the hive from the directory where
        // setup.log was loaded.
        //

        if (RepairFromErDisk) {
            HiveRepairSourceDevice = L"\\device\\floppy0";
            DirectoryOnHiveRepairSource = L"";
        } else {
            HiveRepairSourceDevice = WinntPartition;
            wcscpy(TemporaryBuffer, WinntPartitionDirectory);
            SpConcatenatePaths(TemporaryBuffer, SETUP_REPAIR_DIRECTORY);
            DirectoryOnHiveRepairSource = SpDupStringW(TemporaryBuffer);
        }
        SppRepairHives(MasterSifHandle,
                       WinntPartition,
                       WinntPartitionDirectory,
                       HiveRepairSourceDevice,
                       DirectoryOnHiveRepairSource
                       );
        if (!RepairFromErDisk) {
            SpMemFree(DirectoryOnHiveRepairSource);
        }
    }
    if (RepairItems[RepairFiles]) {
        SppRepairWinntFiles(LogFileHandle,
                            MasterSifHandle,
                            SourceDevicePath,
                            DirectoryOnSourceDevice,
                            SystemPartition,
                            SystemPartitionDirectory,
                            WinntPartition,
                            WinntPartitionDirectory
                            );
    }
#endif

    //
    // The code to repair nvram variables and boot sector is
    // incorporated into SpStartSetup.
    //

    //
    //  Load the software hive, and and set the repair flag under Winlogon,
    //  so that winlogon can recreate the start menu groups and items for
    //  the default user.
    //
    SppRepairStartMenuGroupsAndItems( WinntPartition,
                                      WinntPartitionDirectory );

    //
    // Terminate diamond.
    //
    SpdTerminate();

}


VOID
SppVerifyAndRepairNtTreeAccess(
    IN PVOID MasterSifHandle,
    IN PWSTR TargetDevicePath,
    IN PWSTR DirectoryOnTargetDevice,
    IN PWSTR SystemPartition,
    IN PWSTR SystemPartitionDirectory
    )

/*++

Routine Description:

    This routine examines whether or not the directories that form the
    NT tree are accessible, and set the appropriate security descriptor
    in each directory, when necessary.

Arguments:

    MasterSifHandle - Hanle of the txtsetup.sif

    TargetDevicePath - supplies the nt name of the target device

    DirectoryOnTargetDevice - the name of the winnt directory on target
                              device

    SystemPartition - supplies the nt name of the target device (non-x86 platforms)

    SystemPartitionDirectory - the name of the winnt directory on target
                               device (non-x86 platforms)

Return Value:

    None.

--*/
{
    ULONG       Count, i;
    PWSTR       SectionName = L"WinntDirectories";
    PWSTR       DirectoryName;
    PWSTR       TargetPath;
    PWSTR       WinNtDirectory;
    NTSTATUS    Status;

    SpDisplayStatusText(SP_STAT_SETUP_IS_EXAMINING_DIRS, DEFAULT_STATUS_ATTRIBUTE);
    if(SpIsArc()){
    //
    // Make sure that on ARC platforms, the system partition directory
    // exists (re-create it if it doesn't exist)
    //
    SpCreateDirectory(SystemPartition,NULL,SystemPartitionDirectory,0,0);
    }

    WinNtDirectory = ( PWSTR )SpMemAlloc( ( wcslen( TargetDevicePath ) + 1 +
                                          wcslen( DirectoryOnTargetDevice ) + 1 +
                                          1 )*sizeof( WCHAR ) );
    TargetPath = ( PWSTR )SpMemAlloc( 1024 );
    if( ( WinNtDirectory == NULL ) ||
        ( TargetPath == NULL ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to allocate memory for WinNtDirectory \n"));
        if( WinNtDirectory != NULL ) {
            SpMemFree( WinNtDirectory );
        }
        if( TargetPath != NULL ) {
            SpMemFree( TargetPath );
        }
        return;
    }
    wcscpy( WinNtDirectory, TargetDevicePath );
    SpConcatenatePaths( WinNtDirectory, DirectoryOnTargetDevice );

    Count = SpCountLinesInSection(MasterSifHandle, SectionName);
    //
    //  Note that in the loop below, the maximum value for 'i' is 'Count'
    //  instead of 'Count-1'. This is because we need to create the directory
    //  'Profiles\\Default User' which cannot be listed in txtsetup.sif.
    //  This is due to pre-install requirements, and DOS limitation regarding
    //  long file names.
    //
    for (i = 0; i <= Count; i++) {
        if( i != Count ) {
            DirectoryName = SpGetSectionLineIndex(MasterSifHandle,SectionName,i,0);
        } else {
            //
            //  Due to pre-installation requirements, and DOS limitation
            //  regarding long file names, the "Default User" directory
            //  is not specified on txtsetup.sif, as the other directories.
            //  This directory is treated as a special case in the
            //  repair process.
            //
            DirectoryName = DEFAULT_USER_PATH;
        }
        if(!DirectoryName) {
            SppRepairReportError(FALSE,
                                 SP_SCRN_REPAIR_INF_ERROR_0,
                                 SP_TEXT_REPAIR_INF_ERROR_1,
                                 SectionName,
                                 i,
                                 NULL);
            continue;
        }
        wcscpy( TargetPath, WinNtDirectory );
        //
        //  Make sure that TargetPath doesn't contain '\' as the last character
        //
        if(!((DirectoryName[0] == L'\\') && (DirectoryName[1] == 0))) {
            SpConcatenatePaths( TargetPath, DirectoryName );
        }

        Status = SpVerifyFileAccess( TargetPath,
                                     STANDARD_RIGHTS_READ |
                                     FILE_READ_ATTRIBUTES |
                                     FILE_LIST_DIRECTORY |
                                     FILE_ADD_FILE |
                                     FILE_ADD_SUBDIRECTORY |
                                     FILE_TRAVERSE |
                                     WRITE_DAC |
                                     SYNCHRONIZE );

        //
        //  If unable to access the directory, try to determine why.
        //  If it is because of access denied, change the directory security.
        //  If it is because the directory doesn't exist, then create it.
        //
        if( !NT_SUCCESS( Status ) ) {
            if ((Status == STATUS_ACCESS_DENIED)||(Status == STATUS_PRIVILEGE_NOT_HELD) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SETUP: Security of %ls, must be fixed. Status = %x\n", TargetPath, Status ));
                Status = SpSetDefaultFileSecurity( TargetPath );
                if( !NT_SUCCESS( Status ) ) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SETUP: unable to change security of %ls. Status = %x\n", TargetPath, Status ));
                }
            } else if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
                if(((DirectoryName[0] == L'\\') && (DirectoryName[1] == 0))) {
                    //
                    //  Create the target directory
                    //
                    SpCreateDirectory( TargetDevicePath,
                                       NULL,
                                       DirectoryOnTargetDevice,
                                       0,
                                       0);
                } else {
                    SpCreateDirectory( TargetDevicePath,
                                       DirectoryOnTargetDevice,
                                       DirectoryName,
                                       0,
                                       0);
                }
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SETUP: Unable to access directory %ls. Status = %x\n", TargetPath, Status ));
            }
        }
    }

    if( WinNtDirectory != NULL ) {
        SpMemFree( WinNtDirectory );
    }
    if( TargetPath != NULL ) {
        SpMemFree( TargetPath );
    }
    return;
}

VOID
SppVerifyAndRepairVdmFiles(
    IN PVOID LogFileHandle,
    IN PWSTR TargetDevicePath,
    IN PWSTR DirectoryOnTargetDevice,
    IN PBOOLEAN RepairWithoutConfirming
    )

/*++

Routine Description:

    This routine repairs the Vdm configuration files listed on
    'Files.InRepairDirectory' of setup.log. Currently, such files are:
    autoexec.nt and config.nt. It is assumed that files in this section
    will be copied from the emergency repair disk, or from the repair
    directory.

Arguments:

    LogFileHandle - Handle of the setup.log

    TargetDevicePath - supplies the nt name of the target device

    DirectoryOnTargetDevice - the name of the winnt directory on target
                              device

    RepairWithoutConfirming - Pointer to a flag that indicates whether or not
                              setup should repair files without confirming
                              with the user.

Return Value:

    None.

--*/
{
    PWSTR FullTargetName, ChecksumString;
    PWSTR TargetDirectory, TargetFileName;
    PWSTR SourceFileName;
    ULONG Checksum, FileChecksum, PrefixLength, Length, Count, i;
    BOOLEAN IsNtImage, IsValid, RepairFile;
    BOOLEAN RedrawGauge = TRUE;
    FILE_TO_COPY FileToCopy;
    PWSTR DevicePath, Directory;
    PWSTR SectionName = SIF_NEW_REPAIR_FILES_IN_REPAIR_DIR;

    //
    // Allocate a SMALL buffer for local use and init FileToCopy struct
    //

    TargetDirectory = NULL;
    FullTargetName = SpMemAlloc(1024);
    *FullTargetName = 0;
    FileToCopy.Next = NULL;
    FileToCopy.Flags = COPY_ALWAYS;
    FileToCopy.AbsoluteTargetDirectory = TRUE;

    FileToCopy.TargetDevicePath = TargetDevicePath;
    SpConcatenatePaths(FullTargetName,TargetDevicePath);

    PrefixLength = wcslen(FullTargetName);

    Count = SpCountLinesInSection(LogFileHandle,SectionName);
    for (i = 0; i < Count; i++) {
        if (RedrawGauge) {
            SppRepairScreenRepaint(NULL, NULL, TRUE);
            RedrawGauge = FALSE;
        }
        SpTickGauge(RepairGauge);

        //
        // Initialize target fullname to be DevicePath+Directory for
        // system partition file or DevicePath for Winnt files
        //

        FullTargetName[PrefixLength] = (WCHAR)NULL;

        //
        // If we allocate space for TargetDirectory we must free it.
        //

        if (TargetDirectory) {
            SpMemFree(TargetDirectory);
            TargetDirectory = NULL;
        }
        TargetFileName = SpGetKeyName(LogFileHandle,SectionName,i);
        if(!TargetFileName) {
            SppRepairReportError(FALSE,
                                 SP_SCRN_REPAIR_INF_ERROR_0,
                                 SP_TEXT_REPAIR_INF_ERROR_1,
                                 SectionName,
                                 i,
                                 NULL);
            RedrawGauge = TRUE;
            continue;
        }

        SpConcatenatePaths(FullTargetName,TargetFileName);
        SpDisplayStatusText(SP_STAT_EXAMINING_WINNT,
                            DEFAULT_STATUS_ATTRIBUTE,
                            TargetFileName);

        ChecksumString = SpGetSectionLineIndex(LogFileHandle,SectionName,i,1);
        if(!ChecksumString) {
            SppRepairReportError(FALSE,
                                 SP_SCRN_REPAIR_INF_ERROR_0,
                                 SP_TEXT_REPAIR_INF_ERROR_1,
                                 SectionName,
                                 i,
                                 NULL);
            RedrawGauge = TRUE;
            continue;
        }

        Checksum = (ULONG)SpStringToLong(ChecksumString, NULL, 16);

        SpValidateAndChecksumFile(NULL,FullTargetName,&IsNtImage,&FileChecksum,&IsValid);

        //
        // If the image is invalid or the file on the target is not the
        // original file copied by setup, we will recopy it.
        //

        if (!IsValid || FileChecksum != Checksum) {

            //
            // Ask user if he wants to repair the file
            //

            RepairFile = ( *RepairWithoutConfirming )?
                         TRUE :
                         SppRepairReportError(
                                          TRUE,
                                          SP_SCRN_REPAIR_FILE_MISMATCH,
                                          SP_TEXT_REPAIR_INF_ERROR_4,
                                          TargetFileName,
                                          i,
                                          RepairWithoutConfirming);

            RedrawGauge = TRUE;
            if (!RepairFile) {
                continue;
            }
            SpDisplayStatusText(SP_STAT_REPAIR_WINNT,
                                DEFAULT_STATUS_ATTRIBUTE,
                                TargetFileName);


            //
            // TargetName contains path and filename.
            // We need to seperate them.
            //

            TargetDirectory = SpDupStringW(TargetFileName);
            Length = wcslen(TargetDirectory);
            while (Length) {
                if (TargetDirectory[Length] == L'\\') {
                    TargetDirectory[Length] = 0;
                    TargetFileName = &TargetDirectory[Length + 1];
                    break;
                } else {
                    Length--;
                }
            }
            if (Length == 0) {
                SppRepairReportError(FALSE,
                                     SP_SCRN_REPAIR_INF_ERROR_0,
                                     SP_TEXT_REPAIR_INF_ERROR_1,
                                     SectionName,
                                     i,
                                     NULL);
                RedrawGauge = TRUE;
                continue;
            }
            FileToCopy.TargetFilename = TargetFileName;
            FileToCopy.TargetDirectory = TargetDirectory;

            SourceFileName = SpGetSectionLineIndex(LogFileHandle,SectionName,i,0);
            if (!SourceFileName) {
                SppRepairReportError(FALSE,
                                     SP_SCRN_REPAIR_INF_ERROR_0,
                                     SP_TEXT_REPAIR_INF_ERROR_1,
                                     SectionName,
                                     i,
                                     NULL);
                RedrawGauge = TRUE;
                continue;
            }
            FileToCopy.SourceFilename = SourceFileName;

            //
            // Find out whether the source file should come from the
            // Emergency Repair Disk  or the Repair directory
            //

            if (RepairFromErDisk) {
                BOOLEAN rs;
                PWSTR   szDiskName;
                PWSTR   szDevicePath = SpDupStringW(L"\\device\\floppy0");

                //
                // Fetch the generic repair disk name.
                //

                SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),
                                SP_TEXT_REPAIR_DISK_NAME);
                szDiskName = SpDupStringW(TemporaryBuffer);

                //
                // Prompt for the disk, based on the setup media type.
                //

                rs = SpPromptForDisk(
                          szDiskName,
                          szDevicePath,
                          SETUP_LOG_FILENAME,
                          FALSE,              // if disk is in already dont prompt
                          FALSE,              // allow escape
                          TRUE,               // warn for multiple prompts
                          NULL                // don't care about redraw flag
                          );

                SpMemFree(szDiskName);
                SpMemFree(szDevicePath);

                RedrawGauge = TRUE;
                if (rs == FALSE) {
                    continue;
                }
                DevicePath = L"\\device\\floppy0";
                wcscpy( TemporaryBuffer, L"\\" );
                Directory = SpDupStringW(TemporaryBuffer);                 // OemSourceDirectory;
            } else {

                RedrawGauge = TRUE;
                DevicePath = TargetDevicePath;
                wcscpy( TemporaryBuffer, DirectoryOnTargetDevice );
                SpConcatenatePaths( TemporaryBuffer, SETUP_REPAIR_DIRECTORY );
                Directory = SpDupStringW(TemporaryBuffer);
            }

            //
            // Copy the file.
            //

            SpCopyFileWithRetry(
                &FileToCopy,
                DevicePath,
                Directory,
                NULL,
                NULL,                          // TargetRoot -> NULL
                0,                      // SystemPartitionFiles ? ATTR_RHS : 0,
                SppRepairScreenRepaint,
                NULL,                          // Do not want checksum
                NULL,                          // Do not want to know if file was skipped
                0
                );

            SpMemFree( Directory );
        }
    }

    SpMemFree(FullTargetName);
    if (RedrawGauge) {
        SppRepairScreenRepaint(NULL, NULL, TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spnetupg.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Spnetupg.h

Abstract:

    Configuration routines for the disabling the nework services

Author:

    Terry Kwan (terryk) 23-Nov-1993, provided code
    Sunil Pai  (sunilp) 23-Nov-1993, merged and modified code

Revision History:

--*/

#ifndef _SPNETUPG_H_
#define _SPNETUPG_H_

//
// Public functions
//

NTSTATUS SpDisableNetwork(
    IN PVOID  SifHandle,
    IN HANDLE hKeySoftwareHive,
    IN HANDLE hKeyControlSet
    );


//
// Private data structures and routines
//

typedef struct _NODE *PNODE;
typedef struct _NODE {
    PWSTR pszService;
    PNODE Next;
} NODE, *PNODE;


NTSTATUS
SppNetAddItem(
    PNODE *head,
    PWSTR psz
    );

NTSTATUS
SppNetAddList(
    PNODE *head,
    PWSTR psz
    );

VOID
SppNetClearList(
    PNODE *head
    );

NTSTATUS
SppNetAddToDisabledList(
    PWSTR pszService,
    HANDLE hKeySoftware
    );

NTSTATUS
SppNetGetAllNetServices(
    PVOID  SifHandle,
    PNODE *head,
    HANDLE hKeySoftware,
    HANDLE hKeyCCSet
    );

NTSTATUS
SppNetDisableServices(
    PNODE ServiceList,
    HANDLE hKeySoftware,
    HANDLE hKeyCCSet
    );

#endif // for _SPNETUPG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spnttree.c ===
#include "spprecmp.h"
#pragma hdrstop

/*++
Revision History
        Michael Peterson (Seagate Software)
        + Modified SpIsNtInDirectory() so that it always returns FALSE if DR is
          in effect.
--*/
PWSTR *NtDirectoryList;
ULONG  NtDirectoryCount;


BOOLEAN
SpNFilesExist(
    IN OUT PWSTR   PathName,
    IN     PWSTR  *Files,
    IN     ULONG   FileCount,
    IN     BOOLEAN Directories
    )
{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    ULONG i;
    PWSTR FilenamePart;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    //
    // No reason to call this routine to check for 0 files.
    //
    ASSERT(FileCount);

    //
    // Stick a backslash on the end of the path part if necessary.
    //
    SpConcatenatePaths(PathName,L"");
    FilenamePart = PathName + wcslen(PathName);

    //
    // Check each file.  If any one of then doesn't exist,
    // then return FALSE.
    //
    for(i=0; i<FileCount; i++) {

        //
        // Restore PathName and concatenate the new filename
        //
        *FilenamePart = L'\0';
        SpConcatenatePaths(PathName, Files[i]);


        INIT_OBJA(&Obja,&UnicodeString,PathName);

        Status = ZwCreateFile(
                    &Handle,
                    FILE_READ_ATTRIBUTES,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    0,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN,
                    FILE_OPEN_REPARSE_POINT | (Directories ? FILE_DIRECTORY_FILE : FILE_NON_DIRECTORY_FILE),
                    NULL,
                    0
                    );

        if(NT_SUCCESS(Status)) {
            ZwClose(Handle);
        } else {
            *FilenamePart = 0;
            return(FALSE);
        }
    }

    //
    // All exist.  Return TRUE.
    //
    *FilenamePart = 0;
    return(TRUE);
}


BOOLEAN
SpIsNtInDirectory(
    IN PDISK_REGION Region,
    IN PWSTR        Directory
    )

/*++

Routine Description:

    Determine whether Windows NT is present on a partition in one of a
    set of given directories.  This determination is based on the presence
    of certain windows nt system files and directories.

Arguments:

    Region - supplies the region descriptor for the partition to check.

    Directory - supplies the path to check for a windows nt installation.

Return Value:

    TRUE if we think we've found Windows NT in the given directory on
    the given partition.

--*/

{
    PWSTR NTDirectories[3] = { L"system32", L"system32\\drivers", L"system32\\config" };
    PWSTR NTFiles[2] = { L"system32\\ntoskrnl.exe", L"system32\\ntdll.dll" };
    PWSTR PaeNTFiles[2] = { L"system32\\ntkrnlpa.exe", L"system32\\ntdll.dll" };
    PWSTR OpenPath;
    BOOLEAN rc;

    if( SpDrEnabled() && ! RepairWinnt )
    {
        return( FALSE );
    }

    OpenPath = SpMemAlloc(1024);

    //
    // Place the fixed part of the name into the buffer.
    //
    SpNtNameFromRegion(
        Region,
        OpenPath,
        1024,
        PartitionOrdinalCurrent
        );

    SpConcatenatePaths(OpenPath,Directory);

    if(SpNFilesExist(OpenPath, NTDirectories, ELEMENT_COUNT(NTDirectories), TRUE) && 
            (SpNFilesExist(OpenPath, NTFiles, ELEMENT_COUNT(NTFiles), FALSE) ||
             SpNFilesExist(OpenPath, PaeNTFiles, ELEMENT_COUNT(PaeNTFiles), FALSE))) {
        rc = TRUE;
    } else {
        rc = FALSE;
    }

    SpMemFree(OpenPath);
    return(rc);
}




ULONG
SpRemoveInstallation(
    IN PDISK_REGION Region,
    IN PWSTR        PartitionPath,
    IN PWSTR        Directory
    )
{
    HANDLE Handle;
    NTSTATUS Status;
    PWSTR FileName;
    ULONG Space = 0;
    ULONG ClusterSize;
    ULONG bps;
    PVOID Gauge;
    PWSTR Filename;
    ULONG FileCount;
    ULONG FileSize;
    ULONG i;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG ErrLine;
    PVOID Inf;
    BOOLEAN OldFormatSetupLogFile;
    PWSTR   SectionName;
    HANDLE  TempHandle;
    ULONG   RootDirLength;
    PUCHAR UBuffer;
    PUCHAR Buffer;


    FileName = SpMemAlloc(1024);

    //
    // Fetch the number of bytes in a sector.
    //
    bps = HardDisks[Region->DiskNumber].Geometry.BytesPerSector;

    //
    // Get cluster size from the BPB.
    //
    ASSERT(Region->Filesystem >= FilesystemFirstKnown);

    Status = SpOpenPartition(
                HardDisks[Region->DiskNumber].DevicePath,
                SpPtGetOrdinal(Region,PartitionOrdinalCurrent),
                &Handle,
                FALSE
                );

    if(!NT_SUCCESS(Status)) {
        goto xx0;
    }

    UBuffer = SpMemAlloc(2*bps);
    Buffer = ALIGN(UBuffer,bps);
    Status = SpReadWriteDiskSectors(
                Handle,
                0,
                1,
                bps,
                Buffer,
                FALSE
                );

    if(!NT_SUCCESS(Status)) {
        ZwClose(Handle);
        SpMemFree(UBuffer);
        goto xx0;
    }

    //
    // Make sure this sector appears to hold a valid boot sector
    // for a hard disk.
    //
    // "55AA" was not presented by DOS 5.0 for NEC98,
    // so must not to check "55aa" in BPB,
    //
    if(((!IsNEC_98) &&
        ((Buffer[510] == 0x55) && (Buffer[511] == 0xaa) && (Buffer[21] == 0xf8))) ||
       ((IsNEC_98) && (Buffer[21] == 0xf8))) { //NEC98

        //
        // bps * spc.
        //
        ClusterSize = (ULONG)U_USHORT(Buffer+11) * (ULONG)Buffer[13];

    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpRemoveInstallation: sector 0 on %ws is invalid\n",PartitionPath));
        Status = STATUS_UNSUCCESSFUL;
    }

    ZwClose(Handle);
    SpMemFree(UBuffer);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpRemoveInstallation: can't get cluster size on %ws\n",PartitionPath));
        goto xx0;
    }

    //
    //  Find out if the repair directory exists, if it does exist load
    //  setup.log from the repair directory. Otherwise, load setup.log
    //  from the WinNt directory
    //
    wcscpy(FileName,PartitionPath);
    SpConcatenatePaths(FileName,Directory);
    RootDirLength = wcslen(FileName);

    SpConcatenatePaths(FileName,SETUP_REPAIR_DIRECTORY);
    INIT_OBJA( &Obja, &UnicodeString, FileName );
    Status = ZwOpenFile( &TempHandle,
                         FILE_LIST_DIRECTORY | SYNCHRONIZE,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_READ,
                         FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT
                       );

    if( !NT_SUCCESS( Status ) ) {
        FileName[ RootDirLength ] = L'\0';
    } else {
        ZwClose( TempHandle );
    }

    SpConcatenatePaths(FileName,SETUP_LOG_FILENAME);

    //
    // Load setup.log from the given path.
    //
    Status = SpLoadSetupTextFile(FileName,NULL,0,&Inf,&ErrLine,TRUE,FALSE);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpRemoveInstallation: can't load inf file %ws (%lx)\n",FileName,Status));

        while(1) {
            ULONG ks[2] = { ASCI_CR, 0 };

            SpStartScreen(
                SP_SCRN_CANT_LOAD_SETUP_LOG,
                3,
                HEADER_HEIGHT+2,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                FileName + wcslen(PartitionPath)    // skip \device\harddiskx\partitiony
                );

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_ENTER_EQUALS_CONTINUE,
                0
                );

            switch(SpWaitValidKey(ks,NULL,NULL)) {
            case ASCI_CR:
                goto xx0;
            }
        }
    }

    //
    // Go through all files in the [Repair.WinntFiles] section
    //

    SpStartScreen(
        SP_SCRN_WAIT_REMOVING_NT_FILES,
        0,
        8,
        TRUE,
        FALSE,
        DEFAULT_ATTRIBUTE
        );

    //
    //  Determine whether setup.log has the new or old style
    //
    if( OldFormatSetupLogFile = !IsSetupLogFormatNew( Inf ) ) {
        SectionName = SIF_REPAIRWINNTFILES;
    } else {
        SectionName = SIF_NEW_REPAIR_WINNTFILES;
    }

    FileCount = SpCountLinesInSection(Inf,SectionName);

    SpFormatMessage(
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        SP_TEXT_SETUP_IS_REMOVING_FILES
        );

    Gauge = SpCreateAndDisplayGauge(
                FileCount,
                0,
                VideoVars.ScreenHeight - STATUS_HEIGHT - (3*GAUGE_HEIGHT/2),
                TemporaryBuffer,
                NULL,
                GF_PERCENTAGE,
                0
                );

    //
    // Clear the status area.
    //
    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,0);

    //
    // Set the status text in the lower right portion of the screen
    // to "Removing:" in preparation for displaying filenames as
    // files are deleted.  The 12 is for an 8.3 name.
    //
    SpDisplayStatusActionLabel(SP_STAT_REMOVING,12);

    for(i=0; i<FileCount; i++) {

        if( OldFormatSetupLogFile ) {
            Filename = SpGetSectionLineIndex(Inf,SectionName,i,1);
        } else {
            Filename = SpGetKeyName(Inf,SectionName,i);
        }
        if(Filename) {

            PWCHAR p = wcsrchr(Filename,L'\\');

            if(p) {
                p++;
            } else {
                p = Filename;
            }

#if defined(_AMD64_) || defined(_X86_)
            {
                //
                // Don't remove files in the system directory.
                // We might have installed into the windows directory
                // so removing files in the system directory would
                // wipe out the user's fonts (which are shared between
                // 3.1 and nt).
                //
                PWSTR dup = SpDupStringW(Filename);
                SpStringToLower(dup);
                if(wcsstr(dup,L"\\system\\")) {
                    SpMemFree(dup);
                    SpTickGauge(Gauge);
                    continue;
                }
                SpMemFree(dup);
            }
#endif // defined(_AMD64_) || defined(_X86_)

            SpDisplayStatusActionObject(p);

            //
            // Form the full pathname of the file being deleted.
            //
            wcscpy(FileName,PartitionPath);
            SpConcatenatePaths(FileName,Filename);

            //
            // Open the file.
            //
            INIT_OBJA(&Obja,&UnicodeString,FileName);

            Status = ZwCreateFile(
                        &Handle,
                        FILE_READ_ATTRIBUTES,
                        &Obja,
                        &IoStatusBlock,
                        NULL,
                        0,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_OPEN,  // open if exists
                        FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT | FILE_SYNCHRONOUS_IO_NONALERT,
                        NULL,
                        0
                        );

            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpRemoveInstallation: unable to open %ws (%lx)\n",FileName,Status));
            } else {

                //
                // Get the file size.
                //
                Status = SpGetFileSize(Handle,&FileSize);
                if(!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpRemoveInstallation: unable to get %ws file size (%lx)\n",FileName,Status));
                    FileSize = 0;
                } else {

                    //
                    // Add the size of this file to the running total.
                    //
                    if(FileSize % ClusterSize) {

                        FileSize += ClusterSize - (FileSize % ClusterSize);
                    }

                    Space += FileSize;
                }

                ZwClose(Handle);

                //
                // Delete the file
                //
                Status = SpDeleteFile(FileName,NULL,NULL);
                if(!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to delete %ws (%lx)\n",FileName,Status));
                    Space -= FileSize;
                }
            }
        }

        SpTickGauge(Gauge);
    }

    SpFreeTextFile(Inf);

    SpDestroyGauge(Gauge);

    SpDisplayStatusActionLabel(0,0);

    xx0:

    SpMemFree(FileName);
    return(Space);
}



BOOLEAN
SpIsNtOnPartition(
    IN PDISK_REGION Region
    )

/*++

Routine Description:

    Determine whether there is any Windows NT installed on
    a given partition.

Arguments:

    PartitionPath - supplies NT path to partition on which we
        should look for NT installations.

Return Value:

    TRUE if any NT installations were found.
    FALSE if not.

--*/

{
    ULONG i;

    SpGetNtDirectoryList(&NtDirectoryList,&NtDirectoryCount);

    for(i=0; i<NtDirectoryCount; i++) {
        if(SpIsNtInDirectory(Region,NtDirectoryList[i])) {
            return(TRUE);
        }
    }

    return(FALSE);
}


BOOLEAN
SpAllowRemoveNt(
    IN  PDISK_REGION    Region,
    IN  PWSTR           DriveSpec,      OPTIONAL
    IN  BOOLEAN         RescanForNTs,
    IN  ULONG           ScreenMsgId,
    OUT PULONG          SpaceFreed
    )

/*++

Routine Description:


Arguments:

    ScreenMsgId - supplies the message id of the text that will be
        printed above the menu of located nt directories,
        to supply instructions, etc.

    SpaceFreed - receives amount of disk space created by removing a
        Windows NT tree, if this function returns TRUE.

Return Value:

    TRUE if any files were actually removed.
    FALSE otherwise.

    If an error occured, the user will have already been told about it.

--*/

{
    ULONG i;
    ULONG NtCount;
    PULONG MenuOrdinals;
    PWSTR *MenuItems;
    PWSTR *MenuTemp;
    BOOLEAN rc,b;
    BOOLEAN Add;
    ULONG MenuWidth,MenuLeftX;
    PVOID Menu;
    PWSTR PartitionPath;

    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_EXAMINING_DISK_CONFIG,DEFAULT_STATUS_ATTRIBUTE);

    PartitionPath = SpMemAlloc(512);

    //
    // Form the nt pathname for this partition.
    //
    SpNtNameFromRegion(
        Region,
        PartitionPath,
        512,
        PartitionOrdinalCurrent
        );

    //
    // Assume nothing deleted.
    //
    rc = FALSE;

    //
    // Go look for Windows NT installations.
    //
    if(RescanForNTs) {
        SpGetNtDirectoryList(&NtDirectoryList,&NtDirectoryCount);
    }

    if(!NtDirectoryCount) {
        goto xx0;
    }

    //
    // Determine whether any of the NT trees we found are
    // on the given partition, and build an association between
    // NT trees and their ordinal positions in the menu we will
    // present to the user, and the menu itself.
    //
    NtCount = 0;
    MenuOrdinals = SpMemAlloc((NtDirectoryCount+1)*sizeof(ULONG));
    MenuItems = SpMemAlloc((NtDirectoryCount+1)*sizeof(PWSTR));

    //
    // Eliminate potential duplicate entries in the menu
    // to be presented to the user.
    //
    MenuTemp = SpMemAlloc(NtDirectoryCount*sizeof(PWSTR));
    for(i=0; i<NtDirectoryCount; i++) {

        WCHAR FullName[128];
        ULONG j;

        _snwprintf(
            FullName,
            (sizeof(FullName)/sizeof(WCHAR))-1,
            L"%s%s",
            DriveSpec ? DriveSpec : L"",
            NtDirectoryList[i]
            );

        FullName[(sizeof(FullName)/sizeof(WCHAR))-1] = 0;

        //
        // If the name is not already in the list, then add it.
        //
        for(Add=TRUE,j=0; Add && (j<i); j++) {
            if(MenuTemp[j] && !_wcsicmp(FullName,MenuTemp[j])) {
                Add = FALSE;
            }
        }

        MenuTemp[i] = Add ? SpDupStringW(FullName) : NULL;
    }

    //
    // Construct the menu to be presented to the user by looking in the
    // list of directories constructed above.
    //
    for(i=0; i<NtDirectoryCount; i++) {

        if(MenuTemp[i] && SpIsNtInDirectory(Region,NtDirectoryList[i])) {

            MenuOrdinals[NtCount] = i;
            MenuItems[NtCount] = SpDupStringW(MenuTemp[i]);
            NtCount++;
        }
    }

    for(i=0; i<NtDirectoryCount; i++) {
        if(MenuTemp[i]) {
            SpMemFree(MenuTemp[i]);
        }
    }
    SpMemFree(MenuTemp);

    //
    // If we found any nt directories on this partition,
    // make a menu to present to the user.  Otherwise we
    // are done here.
    //
    if(!NtCount) {
        goto xx1;
    }

    MenuOrdinals = SpMemRealloc(MenuOrdinals,(NtCount+1) * sizeof(ULONG));
    MenuItems = SpMemRealloc(MenuItems,(NtCount+1) * sizeof(PWSTR));

    SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_TEXT_REMOVE_NO_FILES);
    MenuItems[NtCount] = SpDupStringW(TemporaryBuffer);

    //
    // Determine the width of the widest item.
    //
    MenuWidth = 0;
    for(i=0; i<=NtCount; i++) {
        if(SplangGetColumnCount(MenuItems[i]) > MenuWidth) {
            MenuWidth = SplangGetColumnCount(MenuItems[i]);
        }
    }
    //
    // Use 80-column screen here because that's how the screen text
    // above the menu will be formatted.
    //
    MenuLeftX = 40 - (MenuWidth/2);

    //
    // Create menu and populate it.
    //
    SpDisplayScreen(ScreenMsgId,3,HEADER_HEIGHT+1);

    Menu = SpMnCreate(
                MenuLeftX,
                NextMessageTopLine+(SplangQueryMinimizeExtraSpacing() ? 1 : 2),
                MenuWidth,
                VideoVars.ScreenHeight-STATUS_HEIGHT-NextMessageTopLine-(SplangQueryMinimizeExtraSpacing() ? 2 : 3)
                );

    for(i=0; i<=NtCount; i++) {
        SpMnAddItem(Menu,MenuItems[i],MenuLeftX,MenuWidth,TRUE,i);
    }

    //
    // Present the menu of installations available for removal
    // on this partition and await a choice.
    //

    b = TRUE;
    do {

        ULONG Keys[4] = { ASCI_CR,KEY_F3,ASCI_ESC,0 };
        ULONG Mnemonics[2] = { MnemonicRemoveFiles,0 };
        ULONG key;
        ULONG_PTR Choice;

        SpDisplayScreen(ScreenMsgId,3,HEADER_HEIGHT+1);
        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ESC_EQUALS_CANCEL,
            SP_STAT_ENTER_EQUALS_SELECT,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        nextkey:

        SpMnDisplay(Menu,
                    NtCount,
                    FALSE,
                    Keys,
                    NULL,
                    NULL,
                    NULL,
                    &key,
                    &Choice);

        if(key == KEY_F3) {
            SpConfirmExit();
        } else if(key == ASCI_ESC) {
            break;
        } else if(key == ASCI_CR) {

            if(Choice == NtCount) {
                b = FALSE;
            } else {

                BOOLEAN keys;
                ULONG ValidKeys2[3] = { KEY_F3,ASCI_ESC,0 };

                //
                // User wants to actually remove an installation.
                // Confirm and then do that here.
                //

                redraw2:

                SpStartScreen(
                    SP_SCRN_REMOVE_EXISTING_NT,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE,
                    MenuItems[Choice]
                    );

                SpDisplayStatusOptions(
                    DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_R_EQUALS_REMOVE_FILES,
                    SP_STAT_ESC_EQUALS_CANCEL,
                    SP_STAT_F3_EQUALS_EXIT,
                    0
                    );

                keys = TRUE;
                while(keys) {
                    switch(SpWaitValidKey(ValidKeys2,NULL,Mnemonics)) {
                    case KEY_F3:
                        SpConfirmExit();
                        goto redraw2;
                    case ASCI_ESC:
                        keys = FALSE;
                        break;
                    default:

                        //
                        // Must be r=remove files.
                        //
                        *SpaceFreed = SpRemoveInstallation(
                                        Region,
                                        PartitionPath,
                                        NtDirectoryList[MenuOrdinals[Choice]]
                                        );

                        rc = TRUE;

                        SpStartScreen(
                            SP_SCRN_DONE_REMOVING_EXISTING_NT,
                            4,
                            HEADER_HEIGHT+3,
                            FALSE,
                            FALSE,
                            DEFAULT_ATTRIBUTE,
                            *SpaceFreed
                            );

                        SpDisplayStatusOptions(
                            DEFAULT_STATUS_ATTRIBUTE,
                            SP_STAT_ENTER_EQUALS_CONTINUE,
                            0
                            );

                        while(SpInputGetKeypress() != ASCI_CR) ;
                        keys = FALSE;
                        b = FALSE;
                        break;
                    }
                }
            }

        } else {
            goto nextkey;
        }
    } while(b);

    SpMnDestroy(Menu);

    xx1:

    for(i=0; i<=NtCount; i++) {
        SpMemFree(MenuItems[i]);
    }

    SpMemFree(MenuItems);
    SpMemFree(MenuOrdinals);

    xx0:

    SpMemFree(PartitionPath);
    return(rc);
}


#if 0

typedef
VOID
(*PINSTALLATION_CALLBACK_ROUTINE)(
    IN PWSTR                       DirectoryPath,
    IN PFILE_DIRECTORY_INFORMATION FoundFileInfo
    );

//
// Stuff to reduce stack usage.
//
PINSTALLATION_CALLBACK_ROUTINE FileIterationCallback;
POBJECT_ATTRIBUTES FileIterationObja;
PIO_STATUS_BLOCK FileIterationIoStatusBlock;
PUNICODE_STRING FileIterationUnicodeString;

VOID
SpIterateInstallationFilesWorker(
    IN PWSTR FilenamePart1,
    IN PWSTR FilenamePart2
    )
{
    PVOID InfoBuffer;
    PWSTR FullPath;
    NTSTATUS Status;
    HANDLE hFile;
    BOOLEAN restart;
    #define DIRINFO(x) ((PFILE_DIRECTORY_INFORMATION)InfoBuffer)

    InfoBuffer = SpMemAlloc(1024);

    //
    // Form the full path name of the current directory.
    //
    FullPath = SpMemAlloc( ( wcslen(FilenamePart1)
                           + (FilenamePart2 ? wcslen(FilenamePart2) : 0),
                           + 2) * sizeof(WCHAR)
                           );

    wcscpy(FullPath,FilenamePart1);
    if(FilenamePart2) {
        SpConcatenatePaths(FullPath,FilenamePart2);
    }

    //
    // Open the directory for list access.
    //
    INIT_OBJA(FileIterationObja,FileIterationUnicodeString,FullPath);

    Status = ZwOpenFile(
                &hFile,
                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                FileIterationObja,
                FileIterationIoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if(NT_SUCCESS(Status)) {

        restart = TRUE;

        do {

            Status = ZwQueryDirectoryFile(
                        hFile,
                        NULL,
                        NULL,
                        NULL,
                        FileIterationIoStatusBlock,
                        InfoBuffer,
                        1024 - sizeof(WCHAR),   // leave room for nul
                        FileDirectoryInformation,
                        TRUE,                   // return single entry
                        NULL,                   // no file name (match all files)
                        restart
                        );

            restart = FALSE;

            if(NT_SUCCESS(Status)) {

                //
                // nul-terminate the filename just in case
                //
                DIRINFO->FileName[DIRINFO->FileNameLength/sizeof(WCHAR)] = 0;

                if(DIRINFO->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                    if(DIRINFO->FileName[0] != L'.') {

                        SpIterateInstallationFiles(
                            FullPath,
                            DIRINFO->FileName
                            );

                        FileIterationCallback(FullPath,InfoBuffer);
                    }
                } else {
                    FileIterationCallback(FullPath,InfoBuffer);
                }
            }

        } while(NT_SUCCESS(Status));

        ZwClose(hFile);

    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to open directory %ws for list access (%lx)\n",FullPath,Status));
    }

    SpMemFree(FullPath);
    SpMemFree(InfoBuffer);
}


VOID
SpIterateInstallationFiles(
    IN PWSTR                          FilenamePart1,
    IN PWSTR                          FilenamePart2,
    IN PINSTALLATION_CALLBACK_ROUTINE CallbackFunction
    )
{
    //
    // Set up stack-saving globals
    //
    FileIterationIoStatusBlock = SpMemAlloc(sizeof(IO_STATUS_BLOCK);
    FileIterationUnicodeString = SpMemAlloc(sizeof(UNICODE_STRING));
    FileIterationObja          = SpMemAlloc(sizeof(OBJECT_ATTRIBUTES);

    FileIterationCallback = CallbackFunction;

    //
    // Do the iteration.
    //
    SpIterateInstallationFilesWorker(FileNamePart1,FilenamePart2);

    //
    // Clean up.
    //
    SpMemFree(FileIterationObja);
    SpMemFree(FileIterationUnicodeString);
    SpMemFree(FileIterationIoStatusBlock);
}
#endif


BOOLEAN
IsSetupLogFormatNew(
    IN  PVOID   Inf
    )

/*++

Routine Description:

    Informs the caller whether or not the information on setup.log
    is in the new format.

Arguments:

    Inf -

Return Value:

    TRUE if the information is in the new format.
    FALSE otherwise.

--*/

{
    return( SpGetSectionKeyExists ( Inf,
                                    SIF_NEW_REPAIR_SIGNATURE,
                                    SIF_NEW_REPAIR_VERSION_KEY )
          );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spntupg.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Spntupg.c

Abstract:

    initializing and maintaining list of nts to upgrade

Author:

    Sunil Pai (sunilp) 10-Nov-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop


//
// Major/minor version numbers of the system we're upgrading *from*
// if upgrading.
//
ULONG OldMajorVersion,OldMinorVersion;

//**************************************************************
// S E L E C T I N G    N T   T O   U P G R A D E     S T U F F
//**************************************************************

#define MENU_LEFT_X     3
#define MENU_WIDTH      (VideoVars.ScreenWidth-(2*MENU_LEFT_X))
#define MENU_INDENT     4

    VOID
pSpStepUpValidate(
    VOID //IN BOOLEAN Server
    );

BOOLEAN
SpGetStepUpMode(
    IN PWSTR PidExtraData,
    BOOLEAN  *StepUpMode
    );
 
BOOLEAN
pSpGetCurrentInstallVariation(
    IN  PWSTR szPid20,
    OUT LPDWORD CurrentInstallVariation
    );
VOID
SpGetUpgDriveLetter(
    IN WCHAR  DriveLetter,
    IN PWCHAR Buffer,
    IN ULONG  BufferSize,
    IN BOOL   AddColon
    );

VOID
SpCantFindBuildToUpgrade(
    VOID
    );

#ifdef _X86_
BOOLEAN
SpIsWin9xMsdosSys(
    IN PDISK_REGION Region,
    OUT PSTR*       Win9xPath
    );
#endif

VOID
SpGetFileVersion(
    IN  PVOID      ImageBase,
    OUT PULONGLONG Version
    );

ENUMUPGRADETYPE
SpFindNtToUpgrade(
    IN  PVOID        SifHandle,
    OUT PDISK_REGION *TargetRegion,
    OUT PWSTR        *TargetPath,
    OUT PDISK_REGION *SystemPartitionRegion,
    OUT PWSTR        *SystemPartitionDirectory
    )
/*++

Routine Description:

    This goes through the list of NTs on the system and finds out which are
    upgradeable. Presents the information to the user and selects if he
    wishes to upgrade an installed NT / install a fresh NT into the same
    directory / select a different location for Windows NT.

    If the chosen target is too full user is offered to exit setup to create
    space/ choose new target.

Arguments:

    SifHandle:    Handle the txtsetup.sif

    TargetRegion: Variable to receive the partition of the Windows NT to install
                  NULL if not chosen.  Caller should not free.

    TargetPath:   Variable to receive the target path of Windows NT.  NULL if
                  not decided.  Caller can free.

    SystemPartitionRegion:
                  Variable to receive the system partition of the Windows NT
                  NULL if not chosen.  Caller should not free.


Return Value:

    UpgradeFull:         If user chooses to upgrade an NT

    UpgradeInstallFresh: If user chooses to install fresh into an existing NT
                         tree.

    DontUpgrade:         If user chooses to cancel upgrade and choose a fresh
                         tree for installation


--*/
{
    ENUMUPGRADETYPE UpgradeType;
    UPG_PROGRESS_TYPE UpgradeProgressValue;
    NTSTATUS NtStatus;
    ULONG i,j;
    ULONG UpgradeBootSets;
    ULONG PidIndex;
    PSP_BOOT_ENTRY BootEntry;
    PSP_BOOT_ENTRY ChosenBootEntry;
    PSP_BOOT_ENTRY MatchedSet = NULL;
    ULONG UpgradeOnlyBootSets;
    PVOID p;
    PWSTR Pid;
    ULONG TotalSizeOfFilesOnOsWinnt = 0;
    PWSTR UniqueIdFromSif;
    PWSTR UniqueIdFromReg;
    BOOLEAN Compliant;
    BOOLEAN WindowsUpgrade;
    BOOLEAN ComplianceChecked;
    PWSTR EulaComplete;
    DWORD Version = 0, BuildNumber = 0;

    DetermineSourceVersionInfo(&Version, &BuildNumber);

    //
    // If we know we're upgrading NT (chosen during winnt32) then fetch the
    // unique id from the parameters file. This will be used later to
    // find the system to be upgraded.
    //
    UniqueIdFromSif = NULL;
    p = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,WINNT_D_NTUPGRADE_W,0);
    if(p && !_wcsicmp(p,WINNT_A_YES_W)) {
        UniqueIdFromSif = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,SIF_UNIQUEID,0);
        if(!UniqueIdFromSif) {
            SpFatalSifError(WinntSifHandle,SIF_DATA,SIF_UNIQUEID,0,0);
        }
    }

    //
    // Go through all boot sets, looking for upgradeable ones.
    //
    SpDetermineUniqueAndPresentBootEntries();

    UpgradeBootSets = 0;
    UpgradeOnlyBootSets = 0;
    PidIndex = 0;
    for(BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next) {

        //
        // The set's upgradeable flag might already be 0, such as it if was
        // a duplicate entry in boot.ini/nv-ram.
        // After we've checked for this reset the upgradeable flag for this
        // boot set to FALSE in preparation for validating upgreadeability below.
        //
        if (!BootEntry->Processable) {
            continue;
        }

        BootEntry->Processable = FALSE;
        Pid = NULL;
        BootEntry->LangId = -1;

        //
        // Determine various things about the build identified by the
        // current boot set (product type -- srv, wks, etc; version and
        // build numbers, upgrade progress value, unique id winnt32 put
        // in there if any, etc).
        //
        // Based on the information, we will update the UpgradeableList and
        // initialize FailedUpgradeList.
        //
        NtStatus = SpDetermineProduct(
                     BootEntry->OsPartitionDiskRegion,
                     BootEntry->OsDirectory,
                     &BootEntry->ProductType,
                     &BootEntry->MajorVersion,
                     &BootEntry->MinorVersion,
                     &BootEntry->BuildNumber,
                     &BootEntry->ProductSuiteMask,
                     &UpgradeProgressValue,
                     &UniqueIdFromReg,
                     &Pid,
                     NULL,       // ignore eval variation flag
                     &BootEntry->LangId,
                     &BootEntry->ServicePack
                     );

        if(!NT_SUCCESS(NtStatus)) {
            continue;
        }

        //
        // Determine if this installation matches the one we're supposed
        // to upgrade (the one the user ran winnt32 on).  If this is
        // a winnt32 based installation, there is no need to do a
        // compliance test as this was already completed during winnt32.
        //
        if(UniqueIdFromReg) {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpFindNtToUpgrade: BootEntry = %p, RegId = %S, UniqueId = %S\n", BootEntry, UniqueIdFromReg, UniqueIdFromSif));

            if(UniqueIdFromSif && (MatchedSet == NULL)
            && !wcscmp(UniqueIdFromSif,UniqueIdFromReg)) {

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpFindNtToUpgrade:   found a match!\n"));
                MatchedSet = BootEntry;
                BootEntry->Processable = TRUE;
            }

            SpMemFree(UniqueIdFromReg);
            UniqueIdFromReg = NULL;
        }

        if (BootEntry->Processable == FALSE) {
            //
            // this is set to TRUE if this is the build we ran winnt32 upgrade
            // from -- in all other cases we need to do a compliance test
            // to determine if this is a valid build to upgrade
            //
            Compliant = pSpIsCompliant( Version,
                                        BuildNumber,
                                        BootEntry->OsPartitionDiskRegion,
                                        BootEntry->OsDirectory,
                                        &BootEntry->UpgradeOnlyCompliance );
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpFindNtToUpgrade says UpgradeableList[%p] compliance test is %s, upgrade only : %s\n",
                     BootEntry,
                     Compliant ? "TRUE" : "FALSE" ,
                     BootEntry->UpgradeOnlyCompliance ? "TRUE" : "FALSE"
                   ));

            BootEntry->Processable = Compliant;
            if (BootEntry->UpgradeOnlyCompliance) {

                UpgradeOnlyBootSets++;

            }
        }

        if(BootEntry->Processable) {

            UpgradeBootSets++;

            //
            // Save the Pid only if it is Pid20
            //
            if(wcslen(Pid) == 20) {
                BootEntry->Pid20Array = Pid;
            } else {
                SpMemFree(Pid);
            }
        } else {
            SpMemFree(Pid);
        }

        BootEntry->FailedUpgrade = (UpgradeProgressValue == UpgradeInProgress);


    }

    //
    // Winnt32 displays the EULA which signifies that compliance checking has been
    // completed
    //
    EulaComplete = SpGetSectionKeyIndex(WinntSifHandle, SIF_DATA,WINNT_D_EULADONE_W, 0);

    if(EulaComplete && SpStringToLong(EulaComplete, NULL, 10)) {
        ComplianceChecked = TRUE;
    } else {
        ComplianceChecked = FALSE;
    }

    //
    // don't try to validate if we are upgrading a Win3.X or Win9X installation
    //
#ifdef _X86_
    WindowsUpgrade = SpIsWindowsUpgrade(WinntSifHandle);
#else
    WindowsUpgrade = FALSE;
#endif // _X86_

    //
    // In step-up mode, we need to ensure that the user has a qualifiying product.
    //
    //
    // If we couldn't find it on the machine, go perform additional validation
    // steps.
    //
    if(StepUpMode && !UpgradeBootSets && !WindowsUpgrade && !ComplianceChecked) {
        pSpStepUpValidate();
    }

    //
    // If we are supposed to be upgrading NT then make sure we found
    // the system we're supposed to upgrade.
    //
    if(UniqueIdFromSif) {
        if(MatchedSet == NULL) {
            SpCantFindBuildToUpgrade();
        }

        ChosenBootEntry = MatchedSet;
        UpgradeType = UpgradeFull;

        OldMajorVersion = ChosenBootEntry->MajorVersion;
        OldMinorVersion = ChosenBootEntry->MinorVersion;

#if !defined(_AMD64_) && !defined(_X86_)
        //
        // On non-x86 platforms, especially alpha machines that in general
        // have small system partitions (~3 MB), we compute the size
        // of the files on \os\winnt (ie osloader.exe and hal.dll),
        // and consider this size as available disk space. We can do this
        // since these files will be overwritten by the new ones.
        // This fixes the problem that we see on Alpha, when the system
        // partition is too full.
        //
        SpFindSizeOfFilesInOsWinnt(
            SifHandle,
            ChosenBootEntry->LoaderPartitionDiskRegion,
            &TotalSizeOfFilesOnOsWinnt
            );

        //
        // Transform the size into KB
        //
        TotalSizeOfFilesOnOsWinnt /= 1024;
#endif // !defined(_AMD64_) && !defined(_X86_)

        //
        // If a previous upgrade attempt on this build failed
        // (say the power went out in the middle) then we will try to
        // upgrade it again. We can't offer to install a fresh build
        // because we're not sure we can reliably complete it
        // (for example winnt32.exe might copy down only a subset of files
        // across the net when it knows the user ios upgrading and so
        // initial install could fail because of missing files, etc).
        //
        // If the disk is too full then the user is hosed. Tell him and exit.
        //
        if(ChosenBootEntry->FailedUpgrade) {

            SppResumingFailedUpgrade(
                ChosenBootEntry->OsPartitionDiskRegion,
                ChosenBootEntry->OsDirectory,
                ChosenBootEntry->FriendlyName,
                FALSE
                );
        }
    } else {
        //
        // Not upgrading. However for PSS we allow the user to upgrade a build
        // "in place" as a sort of emergency repair thing. The build has to be
        // the same build number as the one we're installing.
        //
        UpgradeType = DontUpgrade;
        //
        // Also, if the user is upgrading Windows 95 or we're in unattended mode
        // then we don't ask the user anything.
        //
        p = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,WINNT_D_WIN95UPGRADE_W,0);
        if(!UnattendedOperation && (!p || _wcsicmp(p,WINNT_A_YES_W))) {

            //
            // Eliminate from the upgradeable list those builds which
            // don't match.
            //
            j = 0;
            for(BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next) {
                if(BootEntry->Processable) {

                    if (!SpDoBuildsMatch(
                                    SifHandle,
                                    BootEntry->BuildNumber,
                                    BootEntry->ProductType,
                                    BootEntry->ProductSuiteMask,
                                    AdvancedServer,
                                    SuiteType,
                                    BootEntry->LangId)) {
                        BootEntry->Processable = FALSE;
                        j++;
                    }
                }
            }
            UpgradeBootSets -= j;

            if(UpgradeBootSets) {
                //
                // Find out if the user wants to "upgrade" one of these.
                //
                UpgradeType = SppSelectNTToRepairByUpgrade(
                                  &ChosenBootEntry
                                  );

#if !defined(_AMD64_) && !defined(_X86_)
                SpFindSizeOfFilesInOsWinnt(
                    SifHandle,
                    ChosenBootEntry->LoaderPartitionDiskRegion,
                    &TotalSizeOfFilesOnOsWinnt
                    );

                TotalSizeOfFilesOnOsWinnt /= 1024;
#endif // !defined(_AMD64_) && !defined(_X86_)

                if(UpgradeType == UpgradeFull) {
                    //
                    // Check for resume case and inform user.
                    //
                    if(ChosenBootEntry->FailedUpgrade) {
                        //
                        // If user cancelled then lets try to do a
                        // clean install
                        //
                        if (!SppResumingFailedUpgrade(
                                    ChosenBootEntry->OsPartitionDiskRegion,
                                    ChosenBootEntry->OsDirectory,
                                    ChosenBootEntry->FriendlyName,
                                    TRUE
                                    )) {
                            UpgradeType = DontUpgrade;
                        }                            
                    } else {
                        //
                        // Everything is OK.
                        //
                        OldMajorVersion = ChosenBootEntry->MajorVersion;
                        OldMinorVersion = ChosenBootEntry->MinorVersion;
                    }
                }
            }
        }
    }

    //
    // Depending on upgrade selection made do the setup needed before
    // we do the upgrade
    //
    if(UpgradeType == UpgradeFull) {

        PWSTR p1,p2,p3;

        //
        // Set the upgrade status to upgrading in the current system hive
        //
        SpSetUpgradeStatus(
             ChosenBootEntry->OsPartitionDiskRegion,
             ChosenBootEntry->OsDirectory,
             UpgradeInProgress
             );

        //
        // Return the region we are installing onto
        //
        *TargetRegion          = ChosenBootEntry->OsPartitionDiskRegion;
        *TargetPath            = SpDupStringW(ChosenBootEntry->OsDirectory);
        *SystemPartitionRegion = ChosenBootEntry->LoaderPartitionDiskRegion;
        StandardServerUpgrade = ( AdvancedServer &&
                                  ( ChosenBootEntry->ProductType == NtProductWinNt ) ||
                                  ( ChosenBootEntry->ProductType == NtProductServer )
                                );

        //
        // Process the osloader variable to extract the system partition path.
        // The var could be of the form ...partition(1)\os\nt\... or
        // ...partition(1)os\nt\...
        // So we search forward for the first \ and then backwards for
        // the closest ) to find the start of the directory.  We then
        // search backwards in the resulting string for the last \ to find
        // the end of the directory.
        //
        p1 = ChosenBootEntry->LoaderFile;
        p2 = wcsrchr(p1, L'\\');
        if (p2 == NULL) {
            p2 = p1;
        }
        i = (ULONG)(p2 - p1);

        if(i == 0) {
            *SystemPartitionDirectory = SpDupStringW(L"");
        } else {
            p2 = p3 = SpMemAlloc((i+2)*sizeof(WCHAR));
            ASSERT(p3);
            if(*p1 != L'\\') {
                *p3++ = L'\\';
            }
            wcsncpy(p3, p1, i);
            p3[i] = 0;
            *SystemPartitionDirectory = p2;
        }
    }

    //
    // Clean up and return,
    //

    CLEAR_CLIENT_SCREEN();
    return(UpgradeType);
}

BOOLEAN
pSpGetCdInstallType(
    IN  PWSTR PathToCd,
    OUT PULONG CdInstallType,
    OUT PULONG CdInstallVersion
    )
{
    #define BuildMatch(_filename_,_type_,_ver_) \
        FileName = _filename_; \
        b = SpNFilesExist(PathToCd,&FileName,1,FALSE); \
        if (b) { \
            *CdInstallType    = _type_; \
            *CdInstallVersion = _ver_; \
        } \
            //return(TRUE); \


    BOOLEAN     b;
    //
    // Directories that are present on all known NT CD-ROM's.
    //

    //
    // ISSUE:2000/27/07:vijayj: this code seems really busted.  In looking at a handful of cd's, none
    // of the nt cd's seem to conform to these rules listed
    // also looks like there might be "per architecture" tag files as well.
    //

    //Check for both dirs to exist? Definitely nt4 has these. Some pre RTM w2k cds have them
    PWSTR ListAllPreNT5[] = { L"alpha", L"i386" }; 

    //wk2 RTM , whistler and nt4 have thse two dirs. They differ by tag file.
    PWSTR ListAllNT5[] = { L"i386", L"support" };

    PWSTR ListAllNec98[] = { L"pc98",L"support" }; //NEC98
    PWSTR ListAllEntNT4[] = { L"alpha", L"i386", L"SP3" };


    //
    // Directories which must be present if a CD is a 3.51 or a 4.0 CD-ROM,
    // workstation or server. Note that the ppc directory distinguishes
    // 3.51 from 3.5.
    //
    PWSTR List351_40[] = { L"mips", L"ppc" };

    //
    // directories which must be present if a CD is a win95 or win98 cd-rom.
    //
    PWSTR ListWin95[] = { L"win95", L"drivers" }; 
    PWSTR ListWin98[] = { L"win98", L"drivers" };
    PWSTR ListWinME[] = { L"win9x", L"drivers" };

    PWSTR FileName;


    //
    // check for NT4 enterprise
    //
    b = SpNFilesExist(
            PathToCd,
            ListAllEntNT4,
            sizeof(ListAllEntNT4)/sizeof(ListAllEntNT4[0]),
            TRUE
            );

    if (b) {
        BuildMatch(L"cdrom_s.40", COMPLIANCE_INSTALLTYPE_NTSE, 400);
        if (b) {
            return(TRUE);
        }
    }

    //
    // check for various subsets of NT < NT5
    //
    b = SpNFilesExist(
            PathToCd,
            (!IsNEC_98) ? ListAllPreNT5 : ListAllNec98, //NEC98
            (!IsNEC_98) ? sizeof(ListAllPreNT5)/sizeof(ListAllPreNT5[0]) : sizeof(ListAllNec98)/sizeof(ListAllNec98[0]), //NEC98
            TRUE
            );

    if(b) {
        //
        // hydra (terminal server) is a special case (since it does not
        // have mips and ppc directory).
        //
        BuildMatch(L"cdrom_ts.40", COMPLIANCE_INSTALLTYPE_NTS, 400);

        if (b) {
            return TRUE;
        }

        //
        // OK, it could be an NT CD of some kind, but it could be
        // 3.1, 3.5, 3.51, 4.0. It could also be
        // server or workstation. Narrow down to 3.51/4.0.
        //
        b = SpNFilesExist(PathToCd,List351_40,
                sizeof(List351_40)/sizeof(List351_40[0]),TRUE);

        if(b) {
            //
            // If we get here, we know it can only be either 3.51 or 4.0.
            // Look for 3.51.
            //
            BuildMatch(L"cdrom.s", COMPLIANCE_INSTALLTYPE_NTS, 351);
            if (b) {
                return(TRUE);
            }
            BuildMatch(L"cdrom.w", COMPLIANCE_INSTALLTYPE_NTW, 351);
            if (b) {
                return(TRUE);
            }
            //
            // Look for 4.0.
            //
            BuildMatch(L"cdrom_s.40", COMPLIANCE_INSTALLTYPE_NTS, 400);
            if (b) {
                return(TRUE);
            }
            BuildMatch(L"cdrom_w.40", COMPLIANCE_INSTALLTYPE_NTW, 400);
            if (b) {
                return(TRUE);
            }

        } else {
            // 
            // Find out if its one of the NT 4.0 service pack CDs
            //
            BuildMatch(L"cdrom_s.40", COMPLIANCE_INSTALLTYPE_NTS, 400);
            if (b) {
                return(TRUE);
            }
            
            BuildMatch(L"cdrom_w.40", COMPLIANCE_INSTALLTYPE_NTW, 400);
            if (b) {
                return(TRUE);
            }
            //
            // Not 3.51 or 4.0. Check for 5.0 beta 1 and beta2
            //
            //How is this possible to be 5.0 unless alpha dir exists on cd.
            //
            // Post beta 1 the tag files changed to support per architecture tags
            // but beta 2 still has alpha directories
            //
            // We could possibly just check to see if cdrom_w.50 isn't
            // there, but the NT3.1 CD would then pass so we need to
            // check explicitly for the 5.0 beta CDs.
            //
            BuildMatch(L"cdrom_s.5b1", COMPLIANCE_INSTALLTYPE_NTS, 500);
            if (b) {
                return(FALSE); //eval
            }
            BuildMatch(L"cdrom_w.5b1", COMPLIANCE_INSTALLTYPE_NTW, 500);
            if (b) {
                return(FALSE); //eval
            }
            BuildMatch(L"cdrom_s.5b2", COMPLIANCE_INSTALLTYPE_NTS, 500);
            if (b) {
                return(FALSE); //eval
            }
            BuildMatch(L"cdrom_w.5b2", COMPLIANCE_INSTALLTYPE_NTW, 500);
            if (b) {
                return(FALSE); //eval
            }
            BuildMatch(L"cdrom_s.5b3", COMPLIANCE_INSTALLTYPE_NTS, 500);
            if (b) {
                return(FALSE); //eval
            }
            BuildMatch(L"cdrom_w.5b3", COMPLIANCE_INSTALLTYPE_NTW, 500);
            if (b) {
                return(FALSE); //eval
            }

            BuildMatch(L"cdrom_is.5b2", COMPLIANCE_INSTALLTYPE_NTS, 500);
            if (b) {
                return(FALSE); //eval
            }
            BuildMatch(L"cdrom_iw.5b2", COMPLIANCE_INSTALLTYPE_NTW, 500);
            if (b) {
                return(FALSE); //eval
            }
            BuildMatch(L"cdrom_ie.5b2", COMPLIANCE_INSTALLTYPE_NTSE, 500);
            if (b) {
                return(FALSE); //eval
            }
            //Do we need to check for eval nt5.1 here? No since alpha dir doesnt exist on the cds.
            //
            // if we made it this far, it must be nt 3.1/3.5
            //
            // we just mark the version as 3.5 since we don't allow upgradescd o
            // from either type of install.
            //
            *CdInstallType = COMPLIANCE_INSTALLTYPE_NTW;
            *CdInstallVersion = 350;
            return(TRUE);
        }
    }

    //
    // look for various nt5 beta cds.
    // // Could also be nt5.1 since cd also contains same dir.
    //
    // note that we don't check 5.0 retail since that would allow the retail CD to
    // validate itself, which defeats the purpose entirely.
    //
    // Post NT5 beta 1 the tag files changed to support per architecture tags so we have
    // a massive ifdef below
    //
    //
    b = SpNFilesExist(
            PathToCd,
            ListAllNT5,
            sizeof(ListAllNT5)/sizeof(ListAllNT5[0]),
            TRUE
            );

    if (b) {
        //
        // we might have some flavour of NT5 beta cd, but we're not sure which one
        //
        BuildMatch(L"cdrom_s.5b1", COMPLIANCE_INSTALLTYPE_NTS, 500);
        if (b) {
            return(FALSE); //eval
        }
        BuildMatch(L"cdrom_w.5b1", COMPLIANCE_INSTALLTYPE_NTW, 500);
        if (b) {
            return(FALSE); //eval
        }
        BuildMatch(L"cdrom_is.5b2", COMPLIANCE_INSTALLTYPE_NTS, 500);
        if (b) {
            return(FALSE); //eval
        }
        BuildMatch(L"cdrom_iw.5b2", COMPLIANCE_INSTALLTYPE_NTW, 500);
        if (b) {
            return(FALSE); //eval
        }
        BuildMatch(L"cdrom_ie.5b2", COMPLIANCE_INSTALLTYPE_NTSE, 500);
        if (b) {
            return(FALSE); //eval
        }
        BuildMatch(L"cdrom_is.5b3", COMPLIANCE_INSTALLTYPE_NTS, 500);
        if (b) {
            return(FALSE); //eval
        }
        BuildMatch(L"cdrom_iw.5b3", COMPLIANCE_INSTALLTYPE_NTW, 500);
        if (b) {
            return(FALSE); //eval
        }
        BuildMatch(L"cdrom_ie.5b3", COMPLIANCE_INSTALLTYPE_NTSE, 500);
        if (b) {
            return(FALSE); //eval
        }
        BuildMatch(L"cdrom_nt.51", COMPLIANCE_INSTALLTYPE_NTW, 501);
        if (b) {
            return(FALSE); //pre beta1 whistler
        }
        BuildMatch(L"wen51.b1", COMPLIANCE_INSTALLTYPE_NTW, 501);
        if (b) {
            return(FALSE); //beta 1 whistler
        }
        BuildMatch(L"win51.b2", COMPLIANCE_INSTALLTYPE_NTW, 501);
        if (b) {
            return(FALSE); //beta 1 whistler
        }
        BuildMatch(L"win51.rc1", COMPLIANCE_INSTALLTYPE_NTW, 501);
        if (b) {
            return(FALSE); //rc1 whistler
        }
    }

    //
    // check for win95
    //
    b = SpNFilesExist(PathToCd, ListWin95, sizeof(ListWin95)/sizeof(ListWin95[0]),TRUE );

    if (b) {
      *CdInstallType    = COMPLIANCE_INSTALLTYPE_WIN9X;
      *CdInstallVersion = 950;

      return TRUE;
    }      

    //
    // check for win98
    //
    b = SpNFilesExist(PathToCd, ListWin98, sizeof(ListWin98)/sizeof(ListWin98[0]),TRUE );

    if (b) {
      *CdInstallType    = COMPLIANCE_INSTALLTYPE_WIN9X;
      *CdInstallVersion = 1998;

      return TRUE;
    }
    
    //
    // check for winME
    //
    b = SpNFilesExist(PathToCd, ListWinME, sizeof(ListWinME)/sizeof(ListWinME[0]),TRUE );

    if (b) {
      *CdInstallType    = COMPLIANCE_INSTALLTYPE_WIN9X;
      *CdInstallVersion = 3000;

      return TRUE;
    }
    //At this point we have rejected w2k beta cds. However we need to reject wk2 eval cds.
    //We should accept w2k stepup media so the next check is only for 5.1
    //Need to accept nt5.1 eval cds.!!Ask rajj to verify.
    // Need to reject nt5.1 step-up cds.
    // Need to reject nt5.1 rtm cds? Looks like we accept RTM FPP?
    //
    // could be NT 5.1 CD-ROM (make sure its not eval media)
    //
    if (!b) { //check is not needed.
        NTSTATUS    Status;
        CCMEDIA        MediaObj;
        WCHAR        InfDir[MAX_PATH];

        wcscpy(InfDir, PathToCd);
        SpConcatenatePaths(InfDir, (IsNEC_98 ? ListAllNec98[0] : ListAllNT5[0]));

        Status = SpGetMediaDetails(InfDir, &MediaObj);

        if (NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "Type=%lx, Variation=%lx, Version=%lx, Build=%lx, SetupMedia=%s\n",
                MediaObj.SourceType, MediaObj.SourceVariation, MediaObj.Version,
                MediaObj.BuildNumber,
                (MediaObj.StepUpMedia ? L"True" : L"False")));

            if( (MediaObj.Version == 500) && 
                (MediaObj.SourceVariation != COMPLIANCE_INSTALLVAR_EVAL) &&
                (MediaObj.BuildNumber == 2195)) {
                    *CdInstallType = MediaObj.SourceType;
                    *CdInstallVersion = MediaObj.Version;
                    return TRUE;
            }
            // At this point we should be current media 5.1
            if( MediaObj.Version == 501 ) {
                if( MediaObj.SourceVariation != COMPLIANCE_INSTALLVAR_EVAL) {
                    if( MediaObj.StepUpMedia == FALSE) {
                        *CdInstallType = MediaObj.SourceType;
                        *CdInstallVersion = MediaObj.Version;
                        return TRUE;
                    } else {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "pSpGetCdInstallType: SpGetMediaDetails succeeded but STEPUP media"
                                " cannot be used for validation\n", Status));
                    }
                } else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "pSpGetCdInstallType: SpGetMediaDetails succeeded but Eval media\n",
                                Status));
                }
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "pSpGetCdInstallType: SpGetMediaDetails succeeded but unrecognized version\n",
                            Status));
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "pSpGetCdInstallType: SpGetMediaDetails failed with %lx error code\n",
                        Status));
        }
    }


    //
    // not any system CD that we know about
    //
    return(FALSE);
}


VOID
pSpStepUpValidate(
    VOID
    )
{
    ULONG CdCount;
    ULONG i;
    BOOLEAN b;
    ULONG Prompt,SecondaryPrompt;
    ULONG ValidKeys[3] = { ASCI_CR, KEY_F3, 0 };
    LARGE_INTEGER DelayTime;
    PWSTR FileName;
    ULONG SourceSkuId;
    ULONG DontCare;
    ULONG CdInstallType;
    ULONG CdInstallVersion;

    //
    // Directories that are present on all known NT CD-ROM's.
    //
    PWSTR ListAll[] = { L"alpha", L"i386" };
    PWSTR ListAllNec98[] = { L"pc98",L"support" }; //NEC98

    //
    // Directories which must be present if a CD is a 3.51 or a 4.0 CD-ROM,
    // workstation or server. Note that the ppc directory distinguishes
    // 3.51 from 3.5.
    //
    PWSTR List351_40[] = { L"mips", L"ppc" };

    PWSTR ListWin95[] = { L"win95", L"autorun" };
    PWSTR ListWin98[] = { L"win98", L"autorun" };

    SourceSkuId = DetermineSourceProduct(&DontCare,NULL);

    Prompt = SP_SCRN_STEP_UP_NO_QUALIFY;

    switch (SourceSkuId) {
        case COMPLIANCE_SKU_NTW32U:
            SecondaryPrompt = SP_SCRN_STEP_UP_PROMPT_WKS;
            break;
        case COMPLIANCE_SKU_NTSU:
            SecondaryPrompt = SP_SCRN_STEP_UP_PROMPT_SRV;
            break;
        case COMPLIANCE_SKU_NTSEU:
            SecondaryPrompt = SP_SCRN_STEP_UP_PROMPT_ENT;
            break;
        default:
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "setup: Unexpected SKU %x, defaulting to workstation\n", SourceSkuId));
            SecondaryPrompt = SP_SCRN_STEP_UP_PROMPT_WKS;
            break;
    }

#if 0
    //
    // ntw upgrade is a special case because you have either win95 or an old NTW to
    // upgrade from
    //
    // might have to prompt for floppies
    //
    if (SourceSkuId == COMPLIANCE_SKU_NTWU) {



    }
        //
        // See if there is a CD-ROM drive. If not we can't continue.
        //
    else
#endif
        if(CdCount = IoGetConfigurationInformation()->CdRomCount) {

        while(1) {
            //
            // Tell the user what's going on. This screen also contains
            // a prompt to insert a qualifying CD-ROM.
            //
            while(1) {

                SpStartScreen(Prompt,3,HEADER_HEIGHT+1,FALSE,FALSE,DEFAULT_ATTRIBUTE);


                SpContinueScreen(
                    SecondaryPrompt,
                    3,
                    1,
                    FALSE,
                    DEFAULT_ATTRIBUTE
                    );

                SpContinueScreen(SP_SCRN_STEP_UP_INSTRUCTIONS,3,1,FALSE,DEFAULT_ATTRIBUTE);

                SpDisplayStatusOptions(
                    DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_ENTER_EQUALS_CONTINUE,
                    SP_STAT_F3_EQUALS_EXIT,
                    0
                    );

                if(SpWaitValidKey(ValidKeys,NULL,NULL) == KEY_F3) {
                    SpConfirmExit();
                } else {
                    break;
                }
            }

            CLEAR_CLIENT_SCREEN();
            SpDisplayStatusText(SP_STAT_PLEASE_WAIT,DEFAULT_STATUS_ATTRIBUTE);

            //
            // Wait 5 sec for the CD to become ready
            //
            DelayTime.HighPart = -1;
            DelayTime.LowPart = (ULONG)(-50000000);
            KeDelayExecutionThread(KernelMode,FALSE,&DelayTime);

            //
            // Check for relevent files/dirs on each CD-ROM drive.
            //
            for(i=0; i<CdCount; i++) {

                swprintf(TemporaryBuffer,L"\\Device\\Cdrom%u",i);

                if (pSpGetCdInstallType(TemporaryBuffer, &CdInstallType, &CdInstallVersion) ) {

                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "cd type : %x cd version : %d\n", CdInstallType, CdInstallVersion ));

                    switch (SourceSkuId) {
                        case COMPLIANCE_SKU_NTWPU:
                        case COMPLIANCE_SKU_NTW32U:
                            if ( (CdInstallType == COMPLIANCE_INSTALLTYPE_WIN9X) ||
                                 ( ((CdInstallType == COMPLIANCE_INSTALLTYPE_NTW) ||
                                     (CdInstallType == COMPLIANCE_INSTALLTYPE_NTWP)) &&
                                    (CdInstallVersion > 350)) ) {
                                  return;
                            }
                            break;
                        case COMPLIANCE_SKU_NTSU:
                            if ( (CdInstallType == COMPLIANCE_INSTALLTYPE_NTS) &&
                                 (CdInstallVersion > 350) ) {
                                 return;
                            }
                            break;
                        case COMPLIANCE_SKU_NTSEU:
                            if (CdInstallType == COMPLIANCE_INSTALLTYPE_NTSE) {
                                return;
                            }
                            break;

                        default:
                            return;
                    }

                }

            }

            
            Prompt = SP_SCRN_STEP_UP_BAD_CD;
        }
    }

    SpStartScreen(
        SP_SCRN_STEP_UP_FATAL,
        3,
        HEADER_HEIGHT+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE
        );

    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);
    SpInputDrain();
    while(SpInputGetKeypress() != KEY_F3);
    SpDone(0,FALSE,FALSE);
}


BOOLEAN
SppResumingFailedUpgrade(
    IN PDISK_REGION Region,
    IN LPCWSTR      OsLoadFileName,
    IN LPCWSTR      LoadIdentifier,
    IN BOOLEAN     AllowCancel
    )

/*++

Routine Description:

    Simple routine to inform the user that setup noticed that the build
    chosen for upgrade had been upgraded before, but the upgrade attempt
    failed. The user can continue or exit. If he continues the build will be
    upgraded (again).

Arguments:

    Region - supplies region containing the build being upgraded

    OsLoadFileName - supplies ARC OSLOADFILENAME var for the build (ie, sysroot)

    LoadIdentifier - supplies ARC LOADIDENTIFIER for the build (ie, human-
        readable description).

    AllowCancel - Indicates whether user can cancel out of this or not        

Return Value:

    TRUE, if the user wants to continue and attempt to upgrade again else
    FALSE.

--*/

{
    ULONG ValidKeys[] = { KEY_F3, ASCI_CR, 0, 0 };
    ULONG c;
    DRIVELTR_STRING UpgDriveLetter;
    ULONG MsgId;
    ULONG EscStatusId;
    BOOLEAN AllowUpgrade = TRUE;

    ASSERT(Region->PartitionedSpace);
    ASSERT(wcslen(OsLoadFileName) >= 2);

    SpGetUpgDriveLetter(Region->DriveLetter,
            UpgDriveLetter,
            sizeof(UpgDriveLetter),
            FALSE);

    if (AllowCancel) {
        ValidKeys[2] = ASCI_ESC;            
        MsgId = SP_SCRN_WINNT_FAILED_UPGRADE_ESC;
        EscStatusId = SP_STAT_ESC_EQUALS_CLEAN_INSTALL;
    } else {    
        MsgId = SP_SCRN_WINNT_FAILED_UPGRADE;
        EscStatusId = 0;
    }
    
    do {
        SpStartScreen(
            MsgId,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            UpgDriveLetter,
            OsLoadFileName,
            LoadIdentifier
            );

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_F3_EQUALS_EXIT,
            SP_STAT_ENTER_EQUALS_UPGRADE,
            EscStatusId,
            0
            );

        c = SpWaitValidKey(ValidKeys, NULL, NULL);
        
        switch (c) {
            case KEY_F3:
                SpConfirmExit();
                break;

            case ASCI_ESC:
                AllowUpgrade = FALSE;
                break;

            default:
                break;
        }
    } while (c == KEY_F3);

    return AllowUpgrade;
}

#define MAX_INT_STRING   30

VOID
SppUpgradeDiskFull(
    IN PDISK_REGION OsRegion,
    IN LPCWSTR      OsLoadFileName,
    IN LPCWSTR      LoadIdentifier,
    IN PDISK_REGION SysPartRegion,
    IN ULONG        MinOsFree,
    IN ULONG        MinSysFree,
    IN BOOLEAN      Fatal
    )

/*++

Routine Description:

    Inform the user that the nt tree chosen for upgrade can't be upgraded
    because the partition is too full.

Arguments:

    OsRegion - supplies region containing the nt tree.

    OsLoadFileName - supplies ARC OSLOADFILENAME var for the build (ie, sysroot)

    LoadIdentifier - supplies ARC LOADIDENTIFIER for the build (ie, human-
        readable description).

    SysPartRegion - supplies the region that is the ARC system partition
        for the build being upgraded

    MinOsFree - supplies the size in KB of the minimum amount of free space
        we require before attempting upgrade

    MinSysFree - supplies the size in KB of the minimum amount of free space
        we require on the system partition before attempting upgrade.

    Fatal - if TRUE then the only option is exit. If FALSE then this routine
        can return to its caller.

Return Value:

    None. MAY NOT RETURN, depending on Fatal.

--*/

{
    ULONG ValidKeys[] = { KEY_F3,0,0 };
    PWCHAR Drive1, Drive2;
    DRIVELTR_STRING OsRgnDrive, OsRgnDriveFull, SysRgnDriveFull;
    WCHAR Drive1Free[MAX_INT_STRING], Drive1FreeNeeded[MAX_INT_STRING];
    WCHAR Drive2Free[MAX_INT_STRING], Drive2FreeNeeded[MAX_INT_STRING];
    BOOLEAN FirstDefined = FALSE, SecondDefined = FALSE;

    ASSERT(OsRegion->PartitionedSpace);
    ASSERT(SysPartRegion->PartitionedSpace);
    ASSERT(wcslen(OsLoadFileName) >= 2);

    SpGetUpgDriveLetter(OsRegion->DriveLetter,OsRgnDrive,sizeof(OsRgnDrive),FALSE);
    if((OsRegion == SysPartRegion) || (OsRegion->FreeSpaceKB < MinOsFree)) {
        //
        // Then we'll be needing the full (colon added) version of
        // the drive letter
        //
        SpGetUpgDriveLetter(OsRegion->DriveLetter,OsRgnDriveFull,sizeof(OsRgnDrive),TRUE);
    }

    if(OsRegion == SysPartRegion) {
        Drive1 = OsRgnDriveFull;
        swprintf(Drive1Free,L"%d",OsRegion->FreeSpaceKB);
        swprintf(Drive1FreeNeeded,L"%d",MinOsFree);
        FirstDefined = TRUE;
    } else {
        if(SysPartRegion->FreeSpaceKB < MinSysFree) {
            SpGetUpgDriveLetter(SysPartRegion->DriveLetter,SysRgnDriveFull,sizeof(SysRgnDriveFull),TRUE);
            Drive1 = SysRgnDriveFull;
            swprintf(Drive1Free,L"%d",SysPartRegion->FreeSpaceKB);
            swprintf(Drive1FreeNeeded,L"%d",MinSysFree);
            FirstDefined = TRUE;
        }
        if(OsRegion->FreeSpaceKB < MinOsFree) {

            if(!FirstDefined) {
                Drive1 = OsRgnDriveFull;
                swprintf(Drive1Free,L"%d",OsRegion->FreeSpaceKB);
                swprintf(Drive1FreeNeeded,L"%d",MinOsFree);
                FirstDefined = TRUE;
            } else {
                Drive2 = OsRgnDriveFull;
                swprintf(Drive2Free,L"%d",OsRegion->FreeSpaceKB);
                swprintf(Drive2FreeNeeded,L"%d",MinOsFree);
                SecondDefined = TRUE;
            }
        }
    }

    if(!Fatal) {
        ValidKeys[1] = ASCI_CR;
    }

    while(1) {
        SpStartScreen(
            Fatal ? SP_SCRN_WINNT_DRIVE_FULL_FATAL : SP_SCRN_WINNT_DRIVE_FULL,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            OsRgnDrive,
            OsLoadFileName,
            LoadIdentifier,
            FirstDefined  ? Drive1           : L"",
            FirstDefined  ? Drive1FreeNeeded : L"",
            FirstDefined  ? Drive1Free       : L"",
            SecondDefined ? Drive2           : L"",
            SecondDefined ? Drive2FreeNeeded : L"",
            SecondDefined ? Drive2Free       : L""
            );

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_F3_EQUALS_EXIT,
            Fatal ? 0 : SP_STAT_ENTER_EQUALS_CONTINUE,
            0
            );

        if(SpWaitValidKey(ValidKeys,NULL,NULL) == KEY_F3) {
            if(Fatal) {
                SpDone(0,FALSE,TRUE);
            } else {
                SpConfirmExit();
            }
        } else {
            //
            // User hit CR in non-fatal case
            //
            return;
        }
    }
}


ENUMUPGRADETYPE
SppSelectNTToRepairByUpgrade(
    OUT PSP_BOOT_ENTRY *BootEntryChosen
    )
{
    PVOID Menu;
    ULONG MenuTopY;
    ULONG ValidKeys[] = { KEY_F3,ASCI_ESC,0 };
    ULONG Mnemonics[] = {MnemonicRepair,0 };
    ULONG Keypress;
    PSP_BOOT_ENTRY BootEntry,FirstUpgradeSet;
    BOOL bDone;
    ENUMUPGRADETYPE ret;

    //
    // Build up array of drive letters for all menu options
    //
    for(BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next) {
        if (BootEntry->Processable) {
            SpGetUpgDriveLetter(
                BootEntry->OsPartitionDiskRegion->DriveLetter,
                BootEntry->DriveLetterString,
                sizeof(DRIVELTR_STRING),
                FALSE
                );
        }
    }

    bDone = FALSE;
    while(!bDone) {

        //
        // Display the text that goes above the menu on the partitioning screen.
        //
        SpDisplayScreen(SP_SCRN_WINNT_REPAIR_BY_UPGRADE,3,CLIENT_TOP+1);

        //
        // Calculate menu placement.  Leave one blank line
        // and one line for a frame.
        //
        MenuTopY = NextMessageTopLine+2;

        //
        // Create a menu.
        //
        Menu = SpMnCreate(
                    MENU_LEFT_X,
                    MenuTopY,
                    MENU_WIDTH,
                    VideoVars.ScreenHeight-MenuTopY-2-STATUS_HEIGHT
                    );

        ASSERT(Menu);

        //
        // Build up a menu of partitions and free spaces.
        //
        FirstUpgradeSet = NULL;
        for(BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next) {
            if(BootEntry->Processable) {

                swprintf(
                    TemporaryBuffer,
                    L"%ws:%ws %ws",
                    BootEntry->DriveLetterString,
                    BootEntry->OsDirectory,
                    BootEntry->FriendlyName
                    );

                SpMnAddItem(
                    Menu,
                    TemporaryBuffer,
                    MENU_LEFT_X+MENU_INDENT,
                    MENU_WIDTH-(2*MENU_INDENT),
                    TRUE,
                    (ULONG_PTR)BootEntry
                    );
                if(FirstUpgradeSet == NULL) {
                   FirstUpgradeSet = BootEntry;
                }
            }
        }

        //
        // Initialize the status line.
        //
        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_F3_EQUALS_EXIT,
            SP_STAT_R_EQUALS_REPAIR,
            SP_STAT_ESC_EQUALS_NO_REPAIR,
            0
            );

        //
        // Display the menu
        //
        SpMnDisplay(
            Menu,
            (ULONG_PTR)FirstUpgradeSet,
            TRUE,
            ValidKeys,
            Mnemonics,
            NULL,
            NULL,
            &Keypress,
            (PULONG_PTR)BootEntryChosen
            );

        //
        // Now act on the user's selection.
        //
        switch(Keypress) {

        case KEY_F3:
            SpConfirmExit();
            break;

        case ASCI_ESC:
            ret = DontUpgrade;
            bDone = TRUE;
            break;

        default:
            //
            // Must be r=repair
            //
            ret = UpgradeFull;
            bDone = TRUE;
            break;
        }
        SpMnDestroy(Menu);
    }
    return(ret);
}


VOID
SpGetUpgDriveLetter(
    IN WCHAR  DriveLetter,
    IN PWCHAR Buffer,
    IN ULONG  BufferSize,
    IN BOOL   AddColon
    )
/*++

Routine Description:

    This returns a unicode string containing the drive letter specified by
    DriveLetter (if nonzero).  If DriveLetter is 0, then we assume that we
    are looking at a mirrored partition, and retrieve a localized string of
    the form '(Mirror)'.  If 'AddColon' is TRUE, then drive letters get a
    colon appended (eg, "C:").


Arguments:

    DriveLetter: Unicode drive letter, or 0 to denote a mirrored partition.

    Buffer:      Buffer to receive the unicode string

    BufferSize:  Size of the buffer.

    AddColon:    Boolean specifying whether colon should be added (has no
                 effect if DriveLetter is 0).


Returns:

    Buffer contains the formatted Unicode string.

--*/
{
    if(DriveLetter) {
        if(BufferSize >= 2) {
            *(Buffer++) = DriveLetter;
            if(AddColon && BufferSize >= 3) {
                *(Buffer++) = L':';
            }
        }
        *Buffer = 0;
    } else {
        SpFormatMessage(Buffer, BufferSize, SP_UPG_MIRROR_DRIVELETTER);
    }
}


BOOLEAN
SppWarnUpgradeWorkstationToServer(
    IN ULONG    MsgId
    )

/*++

Routine Description:

    Inform a user that that the installation that he/she selected to upgrade
    is an NT Workstation, and that after the upgrade it will become a
    Standard Server.
    The user has the option to upgrade this or specify that he wants to
    install Windows NT fresh.

Arguments:

    MsgId - Screen to be displayed to the user.

Return Value:

    BOOLEAN - Returns TRUE if the user wants to continue the upgrade, or
              FALSE if the user wants to select another system to upgrade or
              install fress.

--*/

{
    ULONG ValidKeys[] = { ASCI_CR, ASCI_ESC, 0 };
    ULONG c;

    while(1) {

        SpStartScreen(
            MsgId,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE
            );

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            SP_STAT_ESC_EQUALS_CANCEL,
            0
            );

        switch(c=SpWaitValidKey(ValidKeys,NULL,NULL)) {

        case KEY_F3:
            SpConfirmExit();
            break;

        case ASCI_ESC:
            return( FALSE );

        case ASCI_CR:
            return(TRUE);
        default:
            break;
        }
    }
}


VOID
SpCantFindBuildToUpgrade(
    VOID
    )

/*++

Routine Description:

    Inform the user that we were unable to locate the build from which
    he initiated unattended installation via winnt32.

    This is a fatal condition.

Arguments:

    None.

Return Value:

    Does not return.

--*/

{
    ULONG ValidKeys[2] = { KEY_F3, 0 };

    CLEAR_CLIENT_SCREEN();

    SpDisplayScreen(SP_SCRN_CANT_FIND_UPGRADE,3,HEADER_HEIGHT+1);
    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);

    SpWaitValidKey(ValidKeys,NULL,NULL);

    SpDone(0,FALSE,FALSE);
}


void
SpUpgradeToNT50FileSystems(
    PVOID SifHandle,
    PDISK_REGION SystemPartitionRegion,
    PDISK_REGION NTPartitionRegion,
    PWSTR SetupSourceDevicePath,
    PWSTR DirectoryOnSetupSource
    )

/*++

Routine Description:

    Perform any necessary upgrades of the file systems
    for the NT40 to NT50 upgrade case.

Arguments:

    SystemPartitionRegion   - Pointer to the structure that describes the
                              system partition.

    NTPartitionRegion       - Pointer to the structure that describes the
                              NT partition.

    SetupSourceDevicePath   - NT device path where autochk.exe is located

    DirectoryOnSourceDevice - Local source directory.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    PDISK_REGION Region;
    PUCHAR Win9xPath;
    ULONG i,j,k;
    PSP_BOOT_ENTRY BootEntry;
    PWSTR NtPath;
    BOOLEAN DoConvert = TRUE;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    PVOID ImageBase;
    HANDLE SectionHandle;
    ULONGLONG SourceVersion;
    HANDLE SourceHandle;
    UNICODE_STRING UnicodeString;
    BOOLEAN IssueWarning = FALSE;
    WCHAR SourceFile[MAX_PATH];
    PWSTR MediaShortName;
    PWSTR MediaDirectory;
    UCHAR SysId;


#if defined(REMOTE_BOOT)
    //
    // If this is a remote boot installation, do not try to convert -- the
    // NT partition in this case is on the remote boot server.
    //

    if (RemoteBootSetup && !RemoteInstallSetup) {
        ConvertNtVolumeToNtfs = FALSE;
        return;
    }
#endif // defined(REMOTE_BOOT)

    SpDetermineUniqueAndPresentBootEntries();

    for(BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next) {

        if (!BootEntry->Processable) {
            continue;
        }

        BootEntry->Processable = FALSE;

        wcscpy( TemporaryBuffer, BootEntry->OsPartitionNtName );
        SpConcatenatePaths( TemporaryBuffer, BootEntry->OsDirectory );
        SpConcatenatePaths( TemporaryBuffer, L"\\system32\\ntoskrnl.exe" );

        INIT_OBJA( &Obja, &UnicodeString, TemporaryBuffer );

        Status = ZwCreateFile(
            &SourceHandle,
            FILE_GENERIC_READ,
            &Obja,
            &IoStatusBlock,
            NULL,
            0,
            0,
            FILE_OPEN,
            FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
            NULL,
            0
            );
        if (NT_SUCCESS(Status)) {
            Status = SpMapEntireFile( SourceHandle, &SectionHandle, &ImageBase, FALSE );
            if (NT_SUCCESS(Status)) {
                SpGetFileVersion( ImageBase, &BootEntry->KernelVersion );
                BootEntry->Processable = TRUE;
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                    "SETUP: SpUpgradeToNT50FileSystems: Kernel %p: NT%d.%d(Build %d) %d\n",
                    BootEntry,
                    (USHORT)(BootEntry->KernelVersion>>48),
                    (USHORT)(BootEntry->KernelVersion>>32),
                    (USHORT)(BootEntry->KernelVersion>>16),
                    (USHORT)(BootEntry->KernelVersion)));
                SpUnmapFile( SectionHandle, ImageBase );
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpUpgradeToNT50FileSystems() could not map kernel image [%ws], %lx\n", TemporaryBuffer, Status ));
            }
            ZwClose(SourceHandle);
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpUpgradeToNT50FileSystems() corrupt boot config [%ws], %lx\n", TemporaryBuffer, Status ));
        }
    }

    //
    // count the number of "real" entries
    //

    k = 0;
    for(BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next) {
        if (BootEntry->Processable) {
            k += 1;
        }
    }

    //
    // check to see if a warning is necessary.
    //
    // If we're doing an upgrade, and there's only 1
    // boot set, then we don't need a warning.  However,
    // if we're doing a clean install and there's at least
    // 1 boot set, then warn (given the existing OS is
    // old enough).
    //

    if( ( ((NTUpgrade == UpgradeFull) && (k > 1)) ||
          ((NTUpgrade == DontUpgrade) && (k > 0)) ) &&
        ( !UnattendedOperation ) && (!SpDrEnabled())) {
        for(BootEntry = SpBootEntries; BootEntry != NULL && IssueWarning == FALSE; BootEntry = BootEntry->Next) {
            if (!BootEntry->Processable || (BootEntry->KernelVersion == 0)) {
                //
                // bogus boot entry
                //
            } else if ((BootEntry->KernelVersion >> 48) < 4) {
                IssueWarning = TRUE;
            } else if ((BootEntry->KernelVersion >> 48) == 4 && (BootEntry->KernelVersion & 0xffff) <= 4) {
                IssueWarning = TRUE;
            }
        }
    }

    // If there's any existing NT4.0 with servicepack less than 5 then warn.
    if( k > 0) {
        for(BootEntry = SpBootEntries; BootEntry != NULL && IssueWarning == FALSE; BootEntry = BootEntry->Next) {
            if (!BootEntry->Processable || (BootEntry->KernelVersion == 0)) {
                //
                // bogus boot entry
                //
            } else if (BootEntry->MajorVersion == 4 && BootEntry->MinorVersion == 0 && BootEntry->BuildNumber == 1381 && BootEntry->ServicePack < 500) {
                IssueWarning = TRUE;
            }
        }
    }

    if (IssueWarning) {

        ULONG WarnKeys[] = { KEY_F3, 0 };
        ULONG MnemonicKeys[] = { MnemonicContinueSetup, 0 };

        while (IssueWarning) {
            SpDisplayScreen(SP_SCRN_FSWARN,3,CLIENT_TOP+1);

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_C_EQUALS_CONTINUE_SETUP,
                SP_STAT_F3_EQUALS_EXIT,
                0
                );

            SpInputDrain();

            switch(SpWaitValidKey(WarnKeys,NULL,MnemonicKeys)) {
                case KEY_F3:
                    SpConfirmExit();
                    return;

                default:
                    IssueWarning = FALSE;
                    break;
            }
        }
    }

#if 0
    //
    // now lets upgrade any nt40+sp3 ntfs file systems
    //

    MediaShortName = SpLookUpValueForFile(
        SifHandle,
        L"ntfs40.sys",
        INDEX_WHICHMEDIA,
        TRUE
        );

    SpGetSourceMediaInfo( SifHandle, MediaShortName, NULL, NULL, &MediaDirectory );

    wcscpy( SourceFile, SetupSourceDevicePath );
    SpConcatenatePaths( SourceFile, DirectoryOnSetupSource );
    SpConcatenatePaths( SourceFile, MediaDirectory );
    SpConcatenatePaths( SourceFile, L"ntfs40.sys" );

    //
    // Initialize the diamond decompression engine.
    // This needs to be done, because SpCopyFileUsingNames() uses
    // the decompression engine.
    //
    SpdInitialize();

    for(BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next) {
        if (BootEntry->Processable &&
            ((BootEntry->KernelVersion >> 48) == 4) &&
            ((BootEntry->KernelVersion & 0xffff) == 4)) {

            wcscpy( TemporaryBuffer, BootEntry->OsPartitionNtName );
            SpConcatenatePaths( TemporaryBuffer, BootEntry->OsDirectory );
            SpConcatenatePaths( TemporaryBuffer, L"\\system32\\drivers\\ntfs.sys" );

            Status = SpCopyFileUsingNames(
                SourceFile,
                TemporaryBuffer,
                0,
                COPY_NOVERSIONCHECK
                );
            if (!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpUpgradeToNT50FileSystems() could not copy nt40 ntfs.sys driver, %lx\n", Status ));
            }

            SpMemFree(NtPath);
        }
    }

    // Terminate diamond
    SpdTerminate();
#endif

    return;
}

BOOLEAN
SpDoBuildsMatch(
    IN PVOID SifHandle,
    ULONG TestBuildNum,
    NT_PRODUCT_TYPE TestBuildType,
    ULONG TestBuildSuiteMask,
    BOOLEAN CurrentProductIsServer,
    ULONG CurrentSuiteMask,
    IN LCID LangId
    )
/*++

Routine Description:

    Checks if the current build the user is installing matches the build we're
    checking against.

    We check:

    1. do the build numbers match?
    2. do the build types match? (nt server and nt professional don't match)
    3. do the product suites match? (nt advanced server vs. data center)

Arguments:

    SifHandle - Handle to txtsetup.sif to find the source language
    TestBuildNum - The build number of the build we're checking against
    TestBuildType - The type of build we're checking against
    TestBuildSuiteMask - Type of product suite as mask we're checking against
    CurrentProductIsServer - If TRUE, the current build is NT Server
    CurrentSuiteMask - Type of suite mask
    LangId - System Language Id of the installation to check. If -1, Lang Id
             check is ignored.

Return Value:

    BOOLEAN - Returns TRUE if the builds match.

--*/
{
    #define PRODUCTSUITES_TO_MATCH ((  VER_SUITE_SMALLBUSINESS               \
                                     | VER_SUITE_ENTERPRISE                  \
                                     | VER_SUITE_BACKOFFICE                  \
                                     | VER_SUITE_COMMUNICATIONS              \
                                     | VER_SUITE_SMALLBUSINESS_RESTRICTED    \
                                     | VER_SUITE_EMBEDDEDNT                  \
                                     | VER_SUITE_DATACENTER                  \
                                     | VER_SUITE_PERSONAL))


    BOOLEAN retval;
    LANGID DefLangId = -1;
    DWORD Version = 0, BuildNumber = 0;

    if (!DetermineSourceVersionInfo(&Version, &BuildNumber)) {
      retval = FALSE;
      goto exit;
    }

    if(TestBuildNum != BuildNumber) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
          "SETUP: SpDoBuildsMatch() has build mismatch, %d != %d\n", 
          TestBuildNum, BuildNumber));
        retval = FALSE;
        goto exit;
    }

    //
    // build number test passed.  now check for server vs. professional
    //
    if (((TestBuildType == NtProductWinNt) && CurrentProductIsServer) ||
        ((TestBuildType == NtProductServer) && !CurrentProductIsServer)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
          "SETUP: SpDoBuildsMatch() has server/professional mismatch\n" ));
        retval = FALSE;
        goto exit;
    }

    //
    // now check product suites.
    // note that we don't check for all product suites, only
    // suites that have their own SKU
    //

    if ((CurrentSuiteMask & PRODUCTSUITES_TO_MATCH) != (TestBuildSuiteMask & PRODUCTSUITES_TO_MATCH)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
          "SETUP: SpDoBuildsMatch() has suite mismatch (dest = %x) (source = %x\n", 
          TestBuildSuiteMask,CurrentSuiteMask ));
        retval = FALSE;
        goto exit;
    }

    //
    // language IDs should also match (if requested)
    //
    if (LangId != -1) {
      PWSTR LangIdStr = SpGetSectionKeyIndex(SifHandle, SIF_NLS, SIF_DEFAULTLAYOUT, 0);
      PWSTR EndChar;

      if (LangIdStr)
        DefLangId = (LANGID)SpStringToLong(LangIdStr, &EndChar, 16);

      //
      // note : currently we are only interested in primary language IDs
      //
      retval = (PRIMARYLANGID(DefLangId) == PRIMARYLANGID(LangId)) ? TRUE : FALSE;
      goto exit;
    }

    retval = TRUE;

exit:
    return(retval);
}

NTSTATUS
SpGetMediaDetails(
    IN    PWSTR        CdInfDirPath,
    OUT    PCCMEDIA    MediaObj
    )
/*++

Routine Description:

    Gets the details of the current CD in CCMEDIA structure

Arguments:

    CdInfDirPath - The path to the inf directories on CD-ROM drive
    MediaObj     - The pointer to the media object in which the details
                    are returned

Return Value:

    Returns STATUS_SUCCESS if success otherwise appropriate status error code.

--*/
{
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;
    WCHAR        DosNetPath[MAX_PATH];
    WCHAR        SetuppIniPath[MAX_PATH];
    PVOID        SetuppIniHandle = 0;
    PVOID        DosNetHandle = 0;
    ULONG        ErrorLine = 0;
    WCHAR        Pid[32] = {0};
    WCHAR        PidData[256] = {0};
    PWSTR        TempPtr;
    BOOLEAN     UpgradeMode = FALSE;
    DWORD       Type = COMPLIANCE_INSTALLTYPE_UNKNOWN;
    DWORD       Variation = COMPLIANCE_INSTALLVAR_UNKNOWN;
    DWORD Version = 0, BuildNumber = 0;

    if (CdInfDirPath && MediaObj) {
        BOOLEAN VersionDetected = FALSE;
        
        wcscpy(DosNetPath, CdInfDirPath);
        wcscpy(SetuppIniPath, CdInfDirPath);

        SpConcatenatePaths(DosNetPath, L"dosnet.inf");
        SpConcatenatePaths(SetuppIniPath, L"setupp.ini");

        //
        // load setupp.ini file and parse it
        //
        Status = SpLoadSetupTextFile(
                    SetuppIniPath,
                    NULL,                  // No image already in memory
                    0,                     // Image size is empty
                    &SetuppIniHandle,
                    &ErrorLine,
                    TRUE,
                    FALSE
                    );

        if(NT_SUCCESS(Status)) {
            Status = STATUS_FILE_INVALID;

            //
            // get the PID
            //
            TempPtr = SpGetSectionKeyIndex(SetuppIniHandle, L"Pid", L"Pid", 0);

            if (TempPtr) {
                wcscpy(Pid, TempPtr);

                //
                // get PID ExtraData
                //
                TempPtr = SpGetSectionKeyIndex(SetuppIniHandle, L"Pid", L"ExtraData", 0);

                if (TempPtr) {
                    wcscpy(PidData, TempPtr);

                    //
                    // Get stepup mode & install variation based on PID
                    //
                    if (SpGetStepUpMode(PidData, &UpgradeMode) &&
                            pSpGetCurrentInstallVariation(Pid, &Variation)) {
                        Status = STATUS_SUCCESS;
                    } else {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SpGetMediaDetails: Could "
                                 "not find StepUp mode or variation of install CD\n"));
                    }
                } else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SpGetMediaDetails: Could not get "
                             "PidExtraData from Setupp.ini\n"));
                }
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SpGetMediaDetails: Could not get Pid from Setupp.ini\n"));
            }
        } else {
            //
            //  Silently fail if unable to read setupp.ini
            //
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SpGetMediaDetails: Unable to read setupp.ini. "
                     "Status = %lx \n", Status));
        }

        if (SetuppIniHandle)
            SpFreeTextFile(SetuppIniHandle);

        if (NT_SUCCESS(Status)) {
            //
            // load and parse dosnet.inf
            //
            Status = SpLoadSetupTextFile(
                        DosNetPath,
                        NULL,                  // No image already in memory
                        0,                     // Image size is empty
                        &DosNetHandle,
                        &ErrorLine,
                        TRUE,
                        FALSE
                        );

            if (NT_SUCCESS(Status)) {
                Status = STATUS_FILE_INVALID;

                //
                // get ProductType from Miscellaneous section
                //
                TempPtr = SpGetSectionKeyIndex(DosNetHandle, L"Miscellaneous",
                            L"ProductType", 0);

                if (TempPtr) {
                    UNICODE_STRING    UnicodeStr;
                    ULONG            Value = -1;

                    RtlInitUnicodeString(&UnicodeStr, TempPtr);
                    Status = RtlUnicodeStringToInteger(&UnicodeStr, 10, &Value);

                    switch (Value) {
                        case 0:
                            Type = COMPLIANCE_INSTALLTYPE_NTW;
                            break;

                        case 1:
                            Type  = COMPLIANCE_INSTALLTYPE_NTS;
                            break;

                        case 2:
                            Type  = COMPLIANCE_INSTALLTYPE_NTSE;
                            break;

                        case 3:
                            Type  = COMPLIANCE_INSTALLTYPE_NTSDTC;
                            break;

                        case 4:
                            Type = COMPLIANCE_INSTALLTYPE_NTWP;
                            break;

                        default:
                            break;
                    }

                    //
                    // Get the version also off from driverver in dosnet.inf
                    //
                    TempPtr = SpGetSectionKeyIndex(DosNetHandle, L"Version",
                                    L"DriverVer", 1);

                    if (TempPtr) {
                        if (NT_SUCCESS(SpGetVersionFromStr(TempPtr, 
                                                   &Version, &BuildNumber))) {
                            VersionDetected = TRUE;
                        }                            

                        Status = STATUS_SUCCESS;
                    } 
                    
                    if (Type != COMPLIANCE_INSTALLTYPE_UNKNOWN) {
                        Status = STATUS_SUCCESS;
                    } else {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpGetMediaDetails: Could not get product type"
                                 " from dosnet.inf\n"));
                    }
                } else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpGetMediaDetails: "
                             "Could not get ProductType from dosnet.inf\n"));
                }
            } else {
                //
                //  Silently fail if unable to read dosnet.inf
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpGetMediaDetails: Unable to read dosnet.inf. "
                         "Status = %lx \n", Status ));
            }
        }

        if (DosNetHandle)
            SpFreeTextFile(DosNetHandle);


        //
        // Fall back to old way of finding version, if we failed
        // to get one from dosnet.inf
        //
        if (NT_SUCCESS(Status) && !VersionDetected) {
          if (!DetermineSourceVersionInfo(&Version, &BuildNumber))
            Status = STATUS_FILE_INVALID;
        }


        //
        // fill in the media details
        //
        if (NT_SUCCESS(Status) &&
                ! CCMediaInitialize(MediaObj, Type, Variation, UpgradeMode, Version, BuildNumber)) {
            Status = STATUS_FILE_INVALID;
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spnetupg.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Spnetupg.c

Abstract:

    Configuration routines for the disabling the nework services

Author:

    Terry Kwan (terryk) 23-Nov-1993, provided code
    Sunil Pai  (sunilp) 23-Nov-1993, merged and modified code
    Michael Miller (MikeMi) 26-Jun-1997, updated to new model

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop

// TEXT MODE FLAGS
// Note: TMF_DISABLE and TMF_REMOTE_BOOT_CRITICAL are retired.
// The only TextModeFlag with meaning now is TMF_DISABLE_FOR_DELETION.
// This flag is set during winnt32.exe to prepare networking services for
// deletion during GUI mode setup.  The start type is not saved and restored
// any longer because GUI mode setup does not allow arbitrary services to
// be auto-started.
//
#define TMF_DISABLE_FOR_DELETION    0x00000004

// TEXT MODE START DISABLE VALUE
#define STARTVALUE_DISABLE 4

NTSTATUS
SpDisableNetwork(
    IN PVOID  SifHandle,
    IN HANDLE hKeySoftwareHive,
    IN HANDLE hKeyControlSet )
{
    NTSTATUS Status = STATUS_SUCCESS;

    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    UNICODE_STRING StringRegStartValueName;
    PWSTR pszServiceName;

    PUCHAR RegBuffer;
    const ULONG  cbRegBuffer = sizeof(KEY_VALUE_PARTIAL_INFORMATION)+MAX_PATH+1;
    DWORD  cbSize;
    HKEY hkeyServices;
    HKEY hkeyService;
    INT i;

    DWORD dwStart;
    DWORD dwNewStart = STARTVALUE_DISABLE;
    DWORD dwFlags;

    RtlInitUnicodeString(&StringRegStartValueName, L"Start");

    RegBuffer = SpMemAlloc(cbRegBuffer);
    pszServiceName = SpMemAlloc(MAX_PATH+1);

    // open services key
    //
    INIT_OBJA( &Obja, &UnicodeString, L"Services");
    Obja.RootDirectory = hKeyControlSet;

    Status = ZwOpenKey(&hkeyServices, KEY_ALL_ACCESS, &Obja);

    if (NT_SUCCESS(Status))
    {
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SpDisableNetwork: Disabling network services...\n"));
        // enumerate all services
        //
        for ( i = 0;
              STATUS_SUCCESS == ZwEnumerateKey(hkeyServices,
                        i,
                        KeyBasicInformation,
                        RegBuffer,
                        cbRegBuffer,
                        &cbSize);
              i++)
        {
            ((PKEY_BASIC_INFORMATION)RegBuffer)->Name[((PKEY_BASIC_INFORMATION)RegBuffer)->NameLength/sizeof(WCHAR)] = L'\0';
            wcscpy(pszServiceName, ((PKEY_BASIC_INFORMATION)RegBuffer)->Name);

            // open the service key
            //
            INIT_OBJA(&Obja, &UnicodeString, pszServiceName);
            Obja.RootDirectory = hkeyServices;

            Status = ZwOpenKey(&hkeyService, KEY_ALL_ACCESS, &Obja);

            if (NT_SUCCESS(Status))
            {
                //  read the TextModeFlags
                //
                RtlInitUnicodeString(&UnicodeString, L"TextModeFlags");

                Status = ZwQueryValueKey(hkeyService,
                        &UnicodeString,
                        KeyValuePartialInformation,
                        RegBuffer,
                        cbRegBuffer,
                        &cbSize);

                if (NT_SUCCESS(Status))
                {
                    // Should the service be disabled?
                    //
                    dwFlags = *((DWORD*)(&(((PKEY_VALUE_PARTIAL_INFORMATION)RegBuffer)->Data)));

                    if (dwFlags & TMF_DISABLE_FOR_DELETION)
                    {
                        Status = ZwSetValueKey(
                                    hkeyService,
                                    &StringRegStartValueName,
                                    0,
                                    REG_DWORD,
                                    &dwNewStart,
                                    sizeof(DWORD));
                    }
                }

                Status = STATUS_SUCCESS;

                ZwClose(hkeyService);
            }

            if (!NT_SUCCESS(Status))
            {
                break;
            }
        }

        ZwClose(hkeyServices);
    }

    SpMemFree(pszServiceName);
    SpMemFree(RegBuffer);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spnttree.h ===
#ifndef _SPNTTREE_
#define _SPNTTREE_

BOOLEAN
SpNFilesExist(
    IN OUT PWSTR   PathName,
    IN     PWSTR  *Files,
    IN     ULONG   FileCount,
    IN     BOOLEAN Directories
    );

BOOLEAN
SpIsNtOnPartition(
    IN PDISK_REGION Region
    );

BOOLEAN
SpIsNtInDirectory(
    IN PDISK_REGION Region,
    IN PWSTR        Directory
    );

BOOLEAN
SpAllowRemoveNt(
    IN  PDISK_REGION    Region,
    IN  PWSTR           DriveSpec,      OPTIONAL
    IN  BOOLEAN         RescanForNTs,
    IN  ULONG           ScreenMsgId,
    OUT PULONG          SpaceFreed
    );

BOOLEAN
IsSetupLogFormatNew(
    IN  PVOID   Inf
    );

#endif // ndef _SPNTTREE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spntupg.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    spntupg.h

Abstract:

    initializing and maintaining list of nts to upgrade

Author:

    Sunil Pai (sunilp) 26-Nov-1993

Revision History:

--*/

//
// Public functions
//

ENUMUPGRADETYPE
SpFindNtToUpgrade(
    IN PVOID        SifHandle,
    OUT PDISK_REGION *TargetRegion,
    OUT PWSTR        *TargetPath,
    OUT PDISK_REGION *SystemPartitionRegion,
    OUT PWSTR        *SystemPartitionDirectory
    );

BOOLEAN
SpDoBuildsMatch(
    IN PVOID SifHandle,
    ULONG TestBuildNum,
    NT_PRODUCT_TYPE TestBuildType,
    ULONG TestBuildSuiteMask,
    BOOLEAN CurrentProductIsServer,
    ULONG CurrentSuiteMask,
    IN LCID LangId
    );

BOOL
SpDetermineInstallationSource(
    IN  PVOID  SifHandle,
    OUT PWSTR *DevicePath,
    OUT PWSTR *DirectoryOnDevice,
    IN  BOOLEAN bEscape
    );    

//
// Private functions
//
BOOLEAN
SppResumingFailedUpgrade(
    IN PDISK_REGION Region,
    IN LPCWSTR      OsLoadFileName,
    IN LPCWSTR      LoadIdentifier,
    IN BOOLEAN     AllowCancel
    );

VOID
SppUpgradeDiskFull(
    IN PDISK_REGION OsRegion,
    IN LPCWSTR      OsLoadFileName,
    IN LPCWSTR      LoadIdentifier,
    IN PDISK_REGION SysPartRegion,
    IN ULONG        MinOsFree,
    IN ULONG        MinSysFree,
    IN BOOLEAN      Fatal
    );

ENUMUPGRADETYPE
SppSelectNTToRepairByUpgrade(
    OUT PSP_BOOT_ENTRY *BootSetChosen
    );

ENUMUPGRADETYPE
SppNTMultiFailedUpgrade(
    PDISK_REGION   OsPartRegion,
    PWSTR          OsLoadFileName,
    PWSTR          LoadIdentifier
    );

VOID
SppNTMultiUpgradeDiskFull(
    PDISK_REGION   OsRegion,
    PWSTR          OsLoadFileName,
    PWSTR          LoadIdentifier,
    PDISK_REGION   SysPartRegion,
    ULONG          MinOsFree,
    ULONG          MinSysFree
    );

VOID
SppBackupHives(
    PDISK_REGION TargetRegion,
    PWSTR        SystemRoot
    );

BOOLEAN
SppWarnUpgradeWorkstationToServer(
    IN ULONG    MsgId
    );

NTSTATUS
SpGetMediaDetails(
    IN  PWSTR     CdInfDirPath,
    OUT PCCMEDIA  MediaObj 
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spntfix.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    spntfix.h

Abstract:

    initializing and maintaining list of nts to repair

Author:

    Shie-Lin Tzong (shielint) 6-Feb-1994

Revision History:

--*/

#ifndef _SPNTFIX_H_
#define _SPNTFIX_H_

//
// Repair items -
//   defines the items which setup can repair
//   Note, the ordering must be the same as SP_REPAIR_MENU_ITEM_x defined in msg.mc.

typedef enum {
//    RepairHives,   // BCL - Seagate: hives will not be in the menu.
    RepairNvram,
    RepairFiles,
#if defined(_AMD64_) || defined(_X86_)
    RepairBootSect,
#endif // defined(_AMD64_) || defined(_X86_)
    RepairItemMax
} RepairItem;

//
// The hives that repair cares about.  We pass around the keys to the hives
// in an array.  Use the following enum values to access
// the hive members
// Note, the ordering of the hives must be the same as SP_REPAIE_HIVE_ITEM_x
// defined in msg.mc.
//

typedef enum {
    RepairHiveSystem,
    RepairHiveSoftware,
    RepairHiveDefault,
    RepairHiveUser,
    RepairHiveSecurity,
    RepairHiveSam,
    RepairHiveMax
} RepairHive;

//
// Public functions
//

BOOLEAN
SpDisplayRepairMenu(
    VOID
    );

BOOLEAN
SpFindNtToRepair(
    IN  PVOID        SifHandle,
    OUT PDISK_REGION *TargetRegion,
    OUT PWSTR        *TargetPath,
    OUT PDISK_REGION *SystemPartitionRegion,
    OUT PWSTR        *SystemPartitionDirectory,
    OUT PBOOLEAN     RepairableBootSetsFound
    );

VOID
SpRepairWinnt(
    IN PVOID LogFileHandle,
    IN PVOID MasterSifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice
    );

VOID
SpRepairDiskette(
    OUT PVOID        *SifHandle,
    OUT PDISK_REGION *TargetRegion,
    OUT PWSTR        *TargetPath,
    OUT PDISK_REGION *SystemPartitionRegion,
    OUT PWSTR        *SystemPartitionDirectory
    );

BOOLEAN
SpLoadRepairLogFile(
    IN  PWCHAR  Filename,
    OUT PVOID  *Handle
    );

BOOLEAN
SpErDiskScreen (
    BOOLEAN *HasErDisk
    );

//
// Private functions
//

BOOLEAN
SppSelectNTSingleRepair(
    IN PDISK_REGION Region,
    IN PWSTR        OsLoadFileName,
    IN PWSTR        LoadIdentifier
    );

BOOLEAN
SppSelectNTMultiRepair(
    OUT PSP_BOOT_ENTRY *BootSetChosen
    );

BOOLEAN
SppRepairReportError(
    IN BOOLEAN AllowEsc,
    IN ULONG ErrorScreenId,
    IN ULONG SubErrorId,
    IN PWSTR SectionName,
    IN ULONG LineNumber,
    IN PBOOLEAN DoNotPromptAgain
    );

VOID
SppVerifyAndRepairFiles(
    IN PVOID LogFileHandle,
    IN PVOID MasterSifHandle,
    IN PWSTR SectionName,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice,
    IN PWSTR TargetDevicePath,
    IN PWSTR DirectoryOnTargetDevice,
    IN BOOLEAN SystemPartitionFiles,
    IN OUT PBOOLEAN RepairWithoutConfirming
    );

VOID
SppVerifyAndRepairNtTreeAccess(
    IN PVOID MasterSifHandle,
    IN PWSTR TargetDevicePath,
    IN PWSTR DirectoryOnTargetDevice,
    IN PWSTR SystemPartition,
    IN PWSTR SystemPartitionDirectory
    );

VOID
SppVerifyAndRepairVdmFiles(
    IN PVOID LogFileHandle,
    IN PWSTR TargetDevicePath,
    IN PWSTR DirectoryOnTargetDevice,
    IN OUT PBOOLEAN RepairWithoutConfirming
    );

VOID
SppGetRepairPathInformation(
    IN  PVOID LogFileHandle,
    OUT PWSTR *SystemPartition,
    OUT PWSTR *SystemPartitionDirectory,
    OUT PWSTR *WinntPartition,
    OUT PWSTR *WinntPartitionDirectory
    );
   

//
// External functions
//

extern
VOID
SpCopyFilesScreenRepaint(
    IN PWSTR   FullSourcename,      OPTIONAL
    IN PWSTR   FullTargetname,      OPTIONAL
    IN BOOLEAN RepaintEntireScreen
    );

//
// External data references
//

extern PVOID RepairGauge;
extern ULONG RepairItems[RepairItemMax];
extern BOOLEAN RepairFromErDisk;
extern PVOID Gbl_HandleToSetupLog;
extern PWSTR Gbl_SystemPartitionName;
extern PWSTR Gbl_SystemPartitionDirectory;
extern PWSTR Gbl_BootPartitionName;
extern PWSTR Gbl_BootPartitionDirectory;

#endif // for _SPNTFIX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spprecmp.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    spprecmp.h

Abstract:

    precompiled header for textmode setup

Revision History:

--*/

#pragma once

#if !defined(NOWINBASEINTERLOCK)
#define NOWINBASEINTERLOCK
#endif

#include "sprtl.h"
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"

#include "msg.h"
#include "textmode.h"

#define ACTUAL_MAX_PATH 320
#define ARRAYSIZE(x) sizeof((x))/sizeof((x)[0])
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\sppart3.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spppart3.h

Abstract:

    Private header file for partitioning engine and UI.

Author:

    Matt Holle (matth) 1-December-1999

Revision History:

    Minor clean up  -   Vijay Jayaseelan (vijayj)

--*/


#ifndef _SPPART3_H_
#define _SPPART3_H_

//
// Macros.
//

//
// Macro to determine if the partition is OEM partition.
//
#define IS_OEM_PARTITION_GPT(PartitionAttributes) ((PartitionAttributes) & GPT_ATTRIBUTE_PLATFORM_REQUIRED)			

//
// Data structures.
//

//
// Function prototypes.
//
extern VOID
SpPtMenuCallback(
    IN ULONG_PTR UserData
    );

extern
BOOLEAN
SpPtIsNotReservedPartition(
    IN ULONG_PTR    UserData,
    IN ULONG        Key
    );


NTSTATUS
SpPtnInitializeDiskDrive(
    IN ULONG DiskId
    );

extern NTSTATUS
SpPtnInitializeDiskDrives(
    VOID
    );

extern NTSTATUS
SpPtnInitializeDiskAreas(
    IN ULONG DiskNumber
    );

extern NTSTATUS
SpPtnSortDiskAreas(
    IN ULONG DiskNumber
    );

extern NTSTATUS
SpPtnFillDiskFreeSpaceAreas(
    IN ULONG DiskNumber
    );

extern NTSTATUS
SpPtnPrepareDisks(
    IN  PVOID         SifHandle,
    OUT PDISK_REGION  *InstallRegion,
    OUT PDISK_REGION  *SystemPartitionRegion,
    IN  PWSTR         SetupSourceDevicePath,
    IN  PWSTR         DirectoryOnSetupSource,
    IN  BOOLEAN       RemoteBootRepartition
    );

extern BOOLEAN
SpPtnGenerateDiskMenu(
    IN  PVOID           Menu,
    IN  ULONG           DiskNumber,
    OUT PDISK_REGION    *FirstDiskRegion
    );


PDISK_REGION
SpPtnValidSystemPartition(
    VOID
    );

PDISK_REGION
SpPtnValidSystemPartitionArc(
    IN PVOID SifHandle,
    IN PWSTR SetupSourceDevicePath,
    IN PWSTR DirectoryOnSetupSource,
    IN BOOLEAN SysPartNeeded
    );    

BOOLEAN
SpPtnValidSystemPartitionArcRegion(
    IN PVOID SifHandle,
    IN PDISK_REGION Region
    );    
    

NTSTATUS
SpPtnInitRegionFromDisk(
    IN ULONG DiskNumber,
    OUT PDISK_REGION Region
    );
    
NTSTATUS
SpPtnInitializeDiskStyle(
    IN ULONG DiskId,
    IN PARTITION_STYLE Style,
    IN PCREATE_DISK DiskInfo OPTIONAL
    );

VOID
SpPtnFreeDiskRegions(
    IN ULONG DiskId
    );

NTSTATUS    
SpPtnMarkLogicalDrives(
    IN ULONG DiskId
    );


BOOLEAN
SpPtnDoCreate(
    IN  PDISK_REGION  pRegion,
    OUT PDISK_REGION *pActualRegion, OPTIONAL
    IN  BOOLEAN       ForNT,
    IN  ULONGLONG     DesiredMB OPTIONAL,
    IN  PPARTITION_INFORMATION_EX PartInfo OPTIONAL,
    IN  BOOLEAN       ConfirmIt
    );

BOOLEAN
SpPtnDoDelete(
    IN PDISK_REGION pRegion,
    IN PWSTR        RegionDescription,
    IN BOOLEAN      ConfirmIt
    );

ValidationValue
SpPtnGetSizeCB(
    IN ULONG Key
    );    

ULONG
SpPtnGetOrdinal(
    IN PDISK_REGION         Region,
    IN PartitionOrdinalType OrdinalType
    );

VOID
SpPtnGetSectorLayoutInformation(
    IN  PDISK_REGION Region,
    OUT PULONGLONG   HiddenSectors,
    OUT PULONGLONG   VolumeSectorCount
    );

BOOLEAN
SpPtnCreate(
    IN  ULONG         DiskNumber,
    IN  ULONGLONG     StartSector,
    IN  ULONGLONG     SizeInSectors,
    IN  ULONGLONG     SizeMB,
    IN  BOOLEAN       InExtended,
    IN  BOOLEAN       AlignToCylinder,
    IN  PPARTITION_INFORMATION_EX PartInfo,
    OUT PDISK_REGION *ActualDiskRegion OPTIONAL
    );

BOOLEAN
SpPtnDelete(
    IN ULONG        DiskNumber,
    IN ULONGLONG    StartSector
    );    

BOOL
SpPtnIsSystemPartitionRecognizable(
    VOID
    );

VOID
SpPtnMakeRegionActive(
    IN PDISK_REGION    Region
    );

NTSTATUS
SpPtnCommitChanges(
    IN  ULONG    DiskNumber,
    OUT PBOOLEAN AnyChanges
    );

NTSTATUS
SpMasterBootCode(
    IN  ULONG  DiskNumber,
    IN  HANDLE Partition0Handle,
    OUT PULONG NewNTFTSignature
    );    

BOOLEAN
SpPtMakeDiskRaw(
    IN ULONG DiskNumber
    );    

NTSTATUS
SpPtnUnlockDevice(
    IN PWSTR    DeviceName
    );

VOID
SpPtnAssignOrdinals(
    IN  ULONG   DiskNumber
    );   

VOID
SpPtnDeletePartitionsForRemoteBoot(
    PPARTITIONED_DISK pDisk,
    PDISK_REGION startRegion,
    PDISK_REGION endRegion,
    BOOLEAN Extended
    );    

VOID
SpPtnLocateDiskSystemPartitions(
    IN ULONG DiskNumber
    );    

VOID
SpPtnLocateSystemPartitions(
    VOID
    );    

BOOLEAN
SpPtnIsDiskStyleChangeAllowed(
    IN ULONG DiskNumber
    );

VOID
SpPtnPromptForSysPart(
    IN PVOID SifHandle
    );
    
NTSTATUS
SpPtnMakeRegionArcSysPart(
    IN PDISK_REGION Region
    );

ULONG
SpPtnGetPartitionCountDisk(
    IN ULONG DiskId
    );
    
ULONG
SpPtnCountPartitionsByFSType(
    IN ULONG DiskId,
    IN FilesystemType   FsType
    );

BOOLEAN
SpPtnIsDeleteAllowedForRegion(
    IN PDISK_REGION Region
    );    
    
PWSTR
SpPtnGetPartitionName(
    IN PDISK_REGION Region,
    IN OUT PWSTR NameBuffer,
    IN ULONG NameBufferSize
    );

NTSTATUS
SpPtnGetGuidNameForPartition(
    IN PWSTR NtPartitionName,
    IN OUT PWSTR VolumeName
    );

NTSTATUS
SpPtnCreateESP(
    IN BOOLEAN PromptUser
    );

NTSTATUS
SpPtnInitializeGPTDisk(
    IN ULONG DiskNumber
    );    

BOOLEAN
SpIsMSRPresentOnDisk(
    IN ULONG DiskNumber
    );

NTSTATUS
SpPtnInitializeGPTDisks(
    VOID    
    ); 

NTSTATUS
SpPtnRepartitionGPTDisk(
    IN  ULONG           DiskId,
    IN  ULONG           MinimumFreeSpaceKB,
    OUT PDISK_REGION    *RegionToInstall
    );    

BOOLEAN
SpPtnIsDynamicDisk(
    IN  ULONG   DiskIndex
    );

    
#endif // _SPPART3_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\sppartp.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    sppartp.h

Abstract:

    Private header file for partitioning engine and UI.

Author:

    Ted Miller (tedm) 16-Sep-1993

Revision History:

--*/



#ifndef _SPPARTITP_
#define _SPPARTITP_

#define MBR_SIGNATURE       0xaa55


BOOLEAN
SpPtDoPartitionSelection(
    IN OUT PDISK_REGION *Region,
    IN     PWSTR         RegionDescription,
    IN     PVOID         SifHandle,
    IN     BOOLEAN       Unattended,
    IN     PWSTR         SetupSourceDevicePath,
    IN     PWSTR         DirectoryOnSetupSource,
    IN     BOOLEAN       RemoteBootRepartition,
    OUT PBOOLEAN Win9xInstallationPresent
    );

BOOLEAN
SpPtDeterminePartitionGood(
    IN PDISK_REGION Region,
    IN ULONGLONG    RequiredKB,
    IN BOOLEAN      DisallowOtherInstalls
    );

BOOLEAN
SpPtDoCreate(
    IN  PDISK_REGION  pRegion,
    OUT PDISK_REGION *pActualRegion, OPTIONAL
    IN  BOOLEAN       ForNT,
    IN  ULONGLONG     DesiredMB OPTIONAL,
    IN  PPARTITION_INFORMATION_EX PartInfo OPTIONAL,
    IN  BOOLEAN       ConfirmIt
    );
    

VOID
SpPtDoDelete(
    IN PDISK_REGION pRegion,
    IN PWSTR        RegionDescription,
    IN BOOLEAN      ConfirmIt
    );

ULONG
SpComputeSerialNumber(
    VOID
    );

NTSTATUS
SpPtCommitChanges(
    IN  ULONG    DiskNumber,
    OUT PBOOLEAN AnyChanges
    );

VOID
SpPtDoCommitChanges(
    VOID
    );

VOID
FatalPartitionUpdateError(
    IN PWSTR DiskDescription
    );

NTSTATUS
FmtFillFormatBuffer(
    IN  ULONGLONG NumberOfSectors,
    IN  ULONG SectorSize,
    IN  ULONG SectorsPerTrack,
    IN  ULONG NumberOfHeads,
    IN  ULONGLONG NumberOfHiddenSectors,
    OUT PVOID    FormatBuffer,
    IN  ULONG    FormatBufferSize,
    OUT PULONGLONG SuperAreaSize,
    IN  PULONG   BadSectorsList,
    IN  ULONG    NumberOfBadSectors,
    OUT PUCHAR   SystemId
    );

VOID
SpPtMarkActive(
    IN ULONG TablePosition
    );

VOID
SpPtMakeRegionActive(
    IN PDISK_REGION Region
    );

BOOLEAN
SpPtValidateCColonFormat(
    IN PVOID        SifHandle,
    IN PWSTR        RegionDescr,
    IN PDISK_REGION Region,
    IN BOOLEAN      CheckOnly,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSetupSource
    );

PDISK_REGION
SpPtValidSystemPartition(
    VOID
    );

ULONG
SpDetermineDisk0(
    VOID
    );


PDISK_REGION
SpPtValidSystemPartitionArc(
    IN PVOID SifHandle,
    IN PWSTR SetupSourceDevicePath,
    IN PWSTR DirectoryOnSetupSource
    );


#endif // ndef _SPPARTITP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spprintf.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    spprintf.c

Abstract:

    safer sprintf variants

Author:

    Jay Krell (a-JayK) November 2000

Revision History:

--*/

#include "spprecmp.h"
#pragma hdrstop
#include <stdarg.h>
#include <stdio.h>
#include "spprintf.h"
#include "spcab.h"

//
// _snprintf and co. do not write a terminal nul when the string just fits.
// These function do.
//

void
SpFormatStringVaA(
    PSTR Buffer,
    SIZE_T Size,
    PCSTR Format,
    va_list Args
    )
{
    if (Buffer != NULL && Size != 0)
    {
        Buffer[0] = 0;
        Size -= 1;
        if (Size != 0)
            _vsnprintf(Buffer, Size, Format, Args);
        Buffer[Size] = 0;
    }
}

void
__cdecl
SpFormatStringA(
    PSTR Buffer,
    SIZE_T Size,
    PCSTR Format,
    ...
    )
{
    va_list Args;

    va_start(Args, Format);
    SpFormatStringVaA(Buffer, Size, Format, Args);
    va_end(Args);
}

void
SpFormatStringVaW(
    PWSTR Buffer,
    SIZE_T Size,
    PCWSTR Format,
    va_list Args
    )
{
    if (Buffer != NULL && Size != 0)
    {
        Buffer[0] = 0;
        Size -= 1;
        if (Size != 0)
            _vsnwprintf(Buffer, Size, Format, Args);
        Buffer[Size] = 0;
    }
}

void
__cdecl
SpFormatStringW(
    PWSTR Buffer,
    SIZE_T Size,
    PCWSTR Format,
    ...
    )
{
    va_list Args;

    va_start(Args, Format);
    SpFormatStringVaW(Buffer, Size, Format, Args);
    va_end(Args);
}

NTSTATUS
__cdecl
SpFormatStringWToA(
    PSTR Buffer,
    SIZE_T Size,
    PCWSTR Format,
    ...
    )
{
    va_list Args;
    UNICODE_STRING UnicodeBuffer = { 0 };
    ANSI_STRING AnsiBuffer = { 0 };
    NTSTATUS Status = STATUS_SUCCESS;

    va_start(Args, Format);

    UnicodeBuffer.Buffer = (PWSTR)SpMemAlloc(Size * sizeof(UnicodeBuffer.Buffer[0]));
    if (UnicodeBuffer.Buffer == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }
    if (Size != 0) {
        UnicodeBuffer.Buffer[0] = 0;
    }
    SpFormatStringVaW(UnicodeBuffer.Buffer, Size, Format, Args);

    UnicodeBuffer.Length = (USHORT)(wcslen(UnicodeBuffer.Buffer) + 1) * sizeof(UnicodeBuffer.Buffer[0]);
    AnsiBuffer.MaximumLength = (USHORT)Size * sizeof(AnsiBuffer.Buffer[0]);
    Status = SpUnicodeStringToAnsiString(&AnsiBuffer, &UnicodeBuffer, FALSE);

Exit:
    va_end(Args);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\sppart3.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sppart3.c

Abstract:

    Partitioning module for disks in textmode setup.

    Contains functions that initialize the in memory data structures,
    representing the extents on the disk.    

Author:

    Matt Holle (matth) 1-December-1999

Revision History:

    Vijay Jayaseelan (vijayj) 2-April-2000
        -   Clean up
        -   Added lookup and prompting for system partition on 
            ARC systems
        -   Added on disk ordinals for MBR disks            

--*/


#include "spprecmp.h"
#pragma hdrstop
#include <initguid.h>
#include <devguid.h>
#include <diskguid.h>
#include <oemtypes.h>
#include "sppart3.h"


#define         MAX_NTPATH_LENGTH   (2048)
#define         SUGGESTED_SYSTEMPARTIION_SIZE_MB (100)
#define         SUGGESTED_INSTALL_PARTITION_SIZE_MB (4*1024)

extern BOOLEAN ConsoleRunning;
extern BOOLEAN ForceConsole;
 
//
// Debugging Macros
//

//#define PERF_STATS  1
//#define TESTING_SYSTEM_PARTITION 1

NTSTATUS
SpPtnInitializeDiskDrive(
    IN ULONG DiskId
    )
/*++

Routine Description:

    Initializes the in memory disk region structures for
    the given disk number.

Arguments:

    DiskId  :   Disk ID

Return Value:

    STATUS_SUCCESS if successful otherwise appropriate
    error code

--*/    
{
    NTSTATUS    Status;


#ifdef PERF_STATS
    LARGE_INTEGER   StartTime, EndTime;
    ULONGLONG       Diff;

    KeQuerySystemTime(&StartTime);
#endif

    //
    // Send the event
    //
    SendSetupProgressEvent(PartitioningEvent, ScanDiskEvent, &DiskId);
    
    //
    // It would have been better to just have a pointer to a list
    // of PDISK_REGIONs off of HARD_DISK, but for some reason, someone
    // long ago decided to also maintain a list of PARTITIONED_DISK, which
    // *does* contain a list of PDISK_REGIONs.  I'm not sure of the use
    // of maintaining both HARD_DISKs and PARTITIONED_DISKs, but that's
    // the way the data structures are set, so we'll use those.
    //
    // But it doesn't end there.  Rather than assuming that HardDisk[i]
    // is describing the same disk as PartitionedDisks[i], we'll
    // keep a pointer out of PartitionedDisks[i] that points to the
    // corresponding HardDisk entry.  Oh well...
    //
    PartitionedDisks[DiskId].HardDisk = &HardDisks[DiskId];

    //
    // Initialize structures that are based on the partition tables.
    //
    Status = SpPtnInitializeDiskAreas(DiskId);

    //
    // Now we need to fill in additional Region structures
    // to represent empty space on the disk.  For example, assume
    // we have 2 partitions on the disk, but there's empty space
    // in between:
    // partition1: 0 - 200 sectors
    // <empty space>
    // partition2: 500 - 1000 sectors
    //
    // I need to create another Region structure to represent
    // this empty space (ensuring that it's marked as unpartitioned.
    // This will allow me to present a nice UI to the user when it's
    // time to ask for input.
    //

    //
    // Sort the Partitions based on their location on the disk.
    //
    if( NT_SUCCESS(Status) ) {
        Status = SpPtnSortDiskAreas(DiskId);
        
        //
        // Create place holders for all empty spaces on the disk.
        //
        if( NT_SUCCESS(Status) ) {    
            Status = SpPtnFillDiskFreeSpaceAreas(DiskId);

            if (NT_SUCCESS(Status)) {
                //
                // Mark logical drive's and its container, if any.
                //
                Status = SpPtnMarkLogicalDrives(DiskId);
            }
        }
    }

#ifdef PERF_STATS
    KeQuerySystemTime(&EndTime);
    
    Diff = EndTime.QuadPart - StartTime.QuadPart;
    Diff /= 1000000;

    KdPrint(("SETUP:SpPtInitializeDiskDrive(%d) took %I64d Secs\n",
            DiskId,
            Diff));    
#endif

    SpPtDumpDiskDriveInformation(TRUE);
    
    return Status;
}

NTSTATUS
SpPtnInitializeDiskDrives(
    VOID
    )
/*++

Routine Description:

    Initializes all the disk drive's in memory data structure
    representing the disk regions (extents)

Arguments:

    None

Return Value:

    STATUS_SUCCESS if successful other wise appropriate error
    code.

--*/    
{
    ULONG       disk;
    NTSTATUS    Status = STATUS_SUCCESS;
    NTSTATUS    ErrStatus = STATUS_SUCCESS;
    BOOLEAN     ValidHardDiskPresent = FALSE;

    //
    // If there are no hard disks, bail now.
    //
    if(!HardDiskCount) {

#if defined(REMOTE_BOOT)
        //
        // If this is a diskless remote boot setup, it's OK for there to be
        // no hard disks. Otherwise, this is a fatal error.
        //
        if (!RemoteBootSetup || RemoteInstallSetup)
#endif // defined(REMOTE_BOOT)
        {
            SpDisplayScreen(SP_SCRN_NO_HARD_DRIVES,3,HEADER_HEIGHT+1);
            SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);
            SpInputDrain();

            while(SpInputGetKeypress() != KEY_F3);

            SpDone(0,FALSE,TRUE);
        }
        
        return STATUS_SUCCESS;
    }

    CLEAR_CLIENT_SCREEN();

    //
    // Initialize all the RAW disks to platform specific
    // default disk styles
    // 
    for(disk=0, Status = STATUS_SUCCESS; 
        (disk < HardDiskCount); 
        disk++) {        

        if (SPPT_IS_RAW_DISK(disk) && SPPT_IS_BLANK_DISK(disk)) {
            PHARD_DISK HardDisk = SPPT_GET_HARDDISK(disk);
            PARTITION_STYLE Style = SPPT_DEFAULT_PARTITION_STYLE;

            //
            // Removable Media are always MBR (so don't bother)
            //
            if (HardDisk->Characteristics & FILE_REMOVABLE_MEDIA) {
                continue;
            }                            
            
            Status = SpPtnInitializeDiskStyle(disk, 
                        Style,
                        NULL);

            if (!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                    "SETUP:SpPtnInitializeDiskStyle(%d) failed with"
                    " %lx \n",
                    disk,
                    Status));
            }
        }                        
    }        


    //
    // Allocate an array for the partitioned disk descriptors.
    //
    PartitionedDisks = SpMemAlloc(HardDiskCount * sizeof(PARTITIONED_DISK));

    if(!PartitionedDisks) {
        return(STATUS_NO_MEMORY);
    }

    RtlZeroMemory( PartitionedDisks, HardDiskCount * sizeof(PARTITIONED_DISK) );

    //
    // Unlock the floppy if we booted off the ls-120 media
    //
    SpPtnUnlockDevice(L"\\device\\floppy0");

    //
    // Collect information about each partition.
    //
    for(disk=0, Status = ErrStatus = STATUS_SUCCESS; 
        (disk < HardDiskCount); 
        disk++) {
        
        //
        // Initialize the region structure for the given
        // disk
        //
        Status = SpPtnInitializeDiskDrive(disk);           

        //
        // TBD - In remote boot case the disk needs to have
        // a valid signature. I am assuming that setupldr
        // would have stamped the signature when booting off
        // the harddisk
        // 

        //
        // Save of the last error
        //
        if (!NT_SUCCESS(Status)){
            ErrStatus = Status;
        } else {
            ValidHardDiskPresent = TRUE;
        }
    }

    //
    // If no valid hard disk is present and this is not a remote boot setup
    // then we stop the setup.
    // 
    if (!ValidHardDiskPresent &&
        (!RemoteBootSetup || RemoteInstallSetup)){
        SpDisplayScreen(SP_SCRN_NO_HARD_DRIVES,
                        3,
                        HEADER_HEIGHT+1);
        
        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
                               SP_STAT_F3_EQUALS_EXIT,
                               0);
        
        SpInputDrain();

        while(SpInputGetKeypress() != KEY_F3);

        SpDone(0,FALSE,TRUE);
        return ErrStatus;
    }
    
#if defined(_IA64_)
    //
    // Go and figure out the ESP partitions and
    // initialize the MSR partitions on valid GPT
    // disks
    //
    if (SpIsArc() && !SpDrEnabled()) {    
        if (!ValidArcSystemPartition) {
            //
            // Create a system partition
            //
            Status = SpPtnCreateESP(TRUE);                    
        }            

        //
        // Initialize the GPT disks, to have MSR
        // partition
        //
        Status = SpPtnInitializeGPTDisks();
    }
#endif    

    return  ErrStatus;
}

NTSTATUS
SpPtnInitializeDiskAreas(
    IN ULONG DiskNumber
    )
/*++

Routine Description:

    Examine the disk for partitioning information and fill in our
    partition descriptors.

    We'll ask the volume manager for a list of partitions and fill
    in our descriptors from the information he provided us.


Arguments:

    DiskNumber - supplies the disk number of the disk whose partitions
                 we want to inspect for determining their types.

Return Value:

    NTSTATUS.  If all goes well, we should be returing STATUS_SUCCESS.

--*/
{
    NTSTATUS        Status = STATUS_SUCCESS;
    PDRIVE_LAYOUT_INFORMATION_EX   DriveLayoutEx;
    WCHAR           DevicePath[(sizeof(DISK_DEVICE_NAME_BASE)+sizeof(L"000"))/sizeof(WCHAR)];
    HANDLE          Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    PDISK_REGION    pDiskRegion = NULL;
    PFILE_FS_ATTRIBUTE_INFORMATION  pFSInfo = NULL;
    PFILE_FS_SIZE_INFORMATION       pSizeInfo = NULL;
    PFILE_FS_VOLUME_INFORMATION     pLabelInfo = NULL;
    PWCHAR          MyTempBuffer = NULL;
    ULONG           DriveLayoutSize,
                    i,
                    r;
    PWSTR           LocalSourceFiles[1] = { LocalSourceDirectory };
    PHARD_DISK          Disk = NULL;
    PPARTITIONED_DISK   PartDisk = NULL;
    ULONGLONG           *NewPartitions = NULL;
    ULONG               NewPartitionCount;
    
    Disk = SPPT_GET_HARDDISK(DiskNumber);
    PartDisk = SPPT_GET_PARTITIONED_DISK(DiskNumber);
    
    //
    // Give the user some indication of what we're doing.
    //
    SpDisplayStatusText( SP_STAT_EXAMINING_DISK_N,
                         DEFAULT_STATUS_ATTRIBUTE,
                         Disk->Description);

    //
    // If we are updating the local source region disk then
    // make sure we invalidate LocalSourceRegion
    //
    if (LocalSourceRegion && (LocalSourceRegion->DiskNumber == DiskNumber)) {
        LocalSourceRegion = NULL;
    }

    //
    // Save off the new partitions created 
    //
    NewPartitionCount = SpPtnCountPartitionsByFSType(DiskNumber, 
                            FilesystemNewlyCreated);                            

    if (NewPartitionCount) {
        PDISK_REGION    NewRegion = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);
        ULONG           Index;
        
        NewPartitions = (PULONGLONG) SpMemAlloc(sizeof(ULONGLONG) * NewPartitionCount);

        if (!NewPartitions) {
            return STATUS_NO_MEMORY;
        }
        
        RtlZeroMemory(NewPartitions, sizeof(ULONGLONG) * NewPartitionCount);

        Index = 0;
        
        while (NewRegion && (Index < NewPartitionCount)) {
            if (SPPT_IS_REGION_PARTITIONED(NewRegion) && 
                !SPPT_IS_REGION_MARKED_DELETE(NewRegion) &&
                (NewRegion->Filesystem == FilesystemNewlyCreated)) {
                
                NewPartitions[Index] = NewRegion->StartSector;
                Index++;
            }
            
            NewRegion = NewRegion->Next;
        }
    }
    
    //
    // Free the old regions we allocated, if there are any
    //
    SpPtnFreeDiskRegions(DiskNumber);
    
    //
    // ============================
    //
    // Open a handle to this hard disk
    //
    // ============================
    //

    //
    // Create a device path (NT style!) that will describe this disk.  This
    // will be of the form: \Device\Harddisk0
    //
    swprintf( DevicePath,
              L"\\Device\\Harddisk%u",
              DiskNumber );

    //
    // Open partition 0 on this disk..
    //
    Status = SpOpenPartition0( DevicePath,
                               &Handle,
                               FALSE );

    if(!NT_SUCCESS(Status)) {

        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                    "SETUP: SpPtInitializeDiskAreas: unable to open partition0 on device %ws (%lx)\n",
                    DevicePath,
                    Status ));

        if (NewPartitions) {
            SpMemFree(NewPartitions);
        }

        return( Status );
    }
    
    //
    // ============================
    //
    // Load the drive layout information.
    //
    // ============================
    //

    //
    // Get the disk's layout information.  We aren't
    // sure how big of a buffer we need, so brute-force it.
    //
    DriveLayoutSize = 0;
    DriveLayoutEx = NULL;
    Status = STATUS_BUFFER_TOO_SMALL;

    while ((Status == STATUS_BUFFER_TOO_SMALL) || 
           (Status == STATUS_BUFFER_OVERFLOW)) {

        if (DriveLayoutEx)
            SpMemFree(DriveLayoutEx);

        DriveLayoutSize += 1024;
        DriveLayoutEx = SpMemAlloc( DriveLayoutSize );
        
        if(!DriveLayoutEx) {
            KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                "SETUP: SpPtInitializeDiskAreas: SpMemAlloc failed!\n" ));

            if (NewPartitions) {
                SpMemFree(NewPartitions);
            }
            
            return  (STATUS_NO_MEMORY);
        }

        RtlZeroMemory( DriveLayoutEx, DriveLayoutSize );

        //
        // Attempt to get the disk's partition information.
        //
        Status = ZwDeviceIoControlFile( Handle,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &IoStatusBlock,
                                        IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                                        NULL,
                                        0,
                                        DriveLayoutEx,
                                        DriveLayoutSize );
    }                                        

    if(!NT_SUCCESS(Status)) {
        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
              "SETUP: SpPtInitializeDiskAreas: unable to query IOCTL_DISK_GET_DRIVE_LAYOUT_EX on device %ws (%lx)\n",
              DevicePath,
              Status ));

        if (NewPartitions) {
            SpMemFree(NewPartitions);
        }

        if (DriveLayoutEx)
            SpMemFree(DriveLayoutEx);

        if (Handle != INVALID_HANDLE_VALUE)
            ZwClose(Handle);

        return ( Status );
    }

    //
    // What kind of disk is this?
    //
    switch (DriveLayoutEx->PartitionStyle) {
        case PARTITION_STYLE_GPT:
            Disk->FormatType = DISK_FORMAT_TYPE_GPT;

            break;
            
        case PARTITION_STYLE_MBR:
            Disk->FormatType = DISK_FORMAT_TYPE_PCAT;
            Disk->Signature = DriveLayoutEx->Mbr.Signature;

#if defined(_IA64_)            
            //
            // Make sure that this is not a raw disk
            // which is being faked as MBR disk
            //
            if (SpPtnIsRawDiskDriveLayout(DriveLayoutEx)) {
                Disk->FormatType = DISK_FORMAT_TYPE_RAW;
                SPPT_SET_DISK_BLANK(DiskNumber, TRUE);
            }
#endif

            break;
            
        case PARTITION_STYLE_RAW:
            Disk->FormatType = DISK_FORMAT_TYPE_RAW;
            SPPT_SET_DISK_BLANK(DiskNumber, TRUE);

            break;

        default:
            Disk->FormatType = DISK_FORMAT_TYPE_UNKNOWN;

            break;            
    }

    SpAppendDiskTag(Disk);

    SpPtDumpDriveLayoutInformation(DevicePath, DriveLayoutEx);
    
    //
    // Don't need this guy anymore.
    //
    ZwClose( Handle );
    
    //
    // might need this while committing
    //
    Disk->DriveLayout = *DriveLayoutEx;

    Status = STATUS_SUCCESS;
    
    //
    // ============================
    //
    // Initialize partiton descriptors.
    //
    // ============================
    //    
    if(DriveLayoutEx->PartitionCount) {
        BOOLEAN SysPartFound = FALSE;
        ULONG   PartitionedSpaceCount = 1;
        
        //
        // Initialize an area entry for each partition
        // on the disk.
        //
        for( i = 0, pDiskRegion = NULL; i < DriveLayoutEx->PartitionCount; i++ ) {
            ULONG Count = 0;
            ULONG TypeNameId = SP_TEXT_UNKNOWN;
            LARGE_INTEGER DelayTime;
            BOOLEAN AssignDriveLetter = TRUE;

            PPARTITION_INFORMATION_EX PartInfo = DriveLayoutEx->PartitionEntry + i;
            
            //
            // IOCTL_DISK_GET_DRIVE_LAYOUT_EX may return us a list of entries that
            // are not used, so ignore these partitions.
            //
            if (// if its partition 0, which indicates whole disk
                (SPPT_IS_GPT_DISK(DiskNumber) && (PartInfo->PartitionNumber == 0)) ||
                (PartInfo->PartitionLength.QuadPart == 0) ||
                // if MBR entry not used or length is zero
                ((DriveLayoutEx->PartitionStyle == PARTITION_STYLE_MBR) &&
                 (PartInfo->Mbr.PartitionType == PARTITION_ENTRY_UNUSED) &&
                 (PartInfo->PartitionLength.QuadPart == 0)) ||
                // if unknown/unused GPT partition
                ((DriveLayoutEx->PartitionStyle == PARTITION_STYLE_GPT) &&
                 (!memcmp(&PartInfo->Gpt.PartitionType, 
                            &PARTITION_ENTRY_UNUSED_GUID, sizeof(GUID))))){
                continue;                                  
            }

            //
            // Allocate space for the next region.
            //
            if(pDiskRegion) {
                pDiskRegion->Next = SpMemAlloc( sizeof(DISK_REGION) );                
                pDiskRegion = pDiskRegion->Next;
            } else {
                //
                // First region allocation for harddisk so initialize 
                // the region list head for the hardisk
                //                
                ASSERT(PartDisk->PrimaryDiskRegions == NULL);
                
                pDiskRegion = SpMemAlloc(sizeof(DISK_REGION));
                PartDisk->PrimaryDiskRegions = pDiskRegion;
                SPPT_SET_DISK_BLANK(DiskNumber, FALSE);
            }

            if(!pDiskRegion) {
                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                    "SETUP: SpPtInitializeDiskAreas: SpMemAlloc failed!\n" ));
                                    
                Status = STATUS_NO_MEMORY;

                break;
            }
            
            RtlZeroMemory(pDiskRegion, sizeof(DISK_REGION));
            
            //
            // Start filling out our Region descriptor...
            //

            //
            // DiskNumber
            //
            pDiskRegion->DiskNumber = DiskNumber;

            //
            // Partition information
            //
            pDiskRegion->PartInfo = *PartInfo;

            //
            // StartSector
            //
            pDiskRegion->StartSector = PartInfo->StartingOffset.QuadPart /
                                        Disk->Geometry.BytesPerSector;

            //
            // SectorCount
            //
            pDiskRegion->SectorCount = PartInfo->PartitionLength.QuadPart /
                                        Disk->Geometry.BytesPerSector;


            //
            // PartitionNumber
            //
            pDiskRegion->PartitionNumber = PartInfo->PartitionNumber;
            
            if (SPPT_IS_MBR_DISK(DiskNumber) && (PartInfo->PartitionNumber == 0)) {
                if (IsContainerPartition(PartInfo->Mbr.PartitionType)) {
                    SPPT_SET_REGION_EPT(pDiskRegion, EPTContainerPartition);
                }

                //
                // nothing after this is really needed for container partition
                //
                continue;                  
            } else {
                //
                // PartitionedSpace
                //
                SPPT_SET_REGION_PARTITIONED(pDiskRegion, TRUE);
            }

            if (SPPT_IS_REGION_PARTITIONED(pDiskRegion)) {
                pDiskRegion->TablePosition = PartitionedSpaceCount++;
            }                

            //
            // Partition Number should be valid
            //
            ASSERT(pDiskRegion->PartitionNumber);
            
            //
            // IsSystemPartition (is it active)
            //
            if( DriveLayoutEx->PartitionStyle == PARTITION_STYLE_MBR ) {
                //
                // On IA64 systems don't use active MBR partitions as system 
                // partitions
                //
                if (!SpIsArc()) {
                    //
                    // He's an MBR disk, so we can rely on the BootIndicator field.
                    //
                    pDiskRegion->IsSystemPartition = PartInfo->Mbr.BootIndicator;
                } 

                //
                // Don't assign drive letters to OEM partitions
                //
                if (IsOEMPartition(SPPT_GET_PARTITION_TYPE(pDiskRegion))) {
                    AssignDriveLetter = FALSE;
                }
            } else {
                //
                // He's not MBR, look at his PartitionType (which is a GUID).
                //
                pDiskRegion->IsSystemPartition = FALSE;
                
                if(IsEqualGUID(&(PartInfo->Gpt.PartitionType), &(PARTITION_SYSTEM_GUID))) {
                    pDiskRegion->IsSystemPartition = TRUE;
                    AssignDriveLetter = FALSE;

#ifdef _IA64_
                    //
                    // We assign a Drive letter for ESP in the Recovery Console 
                    // for IA64
                    //
                    if (ForceConsole) {
                    	AssignDriveLetter = TRUE;                    	
                    }
#endif
                }
                              
            }

            if (SPPT_IS_REGION_SYSTEMPARTITION(pDiskRegion)) {
                SysPartFound = TRUE;
            }
                    
            
            //
            // FtPartition
            //
            if( DriveLayoutEx->PartitionStyle == PARTITION_STYLE_MBR ) {
                //
                // He's an MBR disk, so we can rely on the PartitionType field.
                //
                pDiskRegion->FtPartition = IsFTPartition(PartInfo->Mbr.PartitionType);
            } else {
                //
                // He's not MBR.  Assume he's GPT and look at his PartitionType (which is a GUID).
                //
                pDiskRegion->FtPartition = FALSE;
            }

            //
            // DynamicVolume
            // DynamicVolumeSuitableForOS
            //
            if( DriveLayoutEx->PartitionStyle == PARTITION_STYLE_MBR ) {
                //
                // He's an MBR disk, so we can rely on the PartitionType field.
                //
                pDiskRegion->DynamicVolume = (PartInfo->Mbr.PartitionType == PARTITION_LDM);
            } else {
                //
                // He's not MBR.  Assume he's GPT and look at his PartitionType (which is a GUID).
                //
                pDiskRegion->DynamicVolume = FALSE;
                
                if( !memcmp(&PartInfo->Gpt.PartitionType, 
                            &PARTITION_LDM_DATA_GUID, sizeof(GUID)) ) {
                    //
                    // The GUIDs match.
                    pDiskRegion->DynamicVolume = TRUE;
                }
            }

            if (pDiskRegion->DynamicVolume) {
                TypeNameId = SP_TEXT_PARTITION_NAME_DYNVOL;
            }

            //
            // if MSFT reserved partition (we need to keep track of it but
            // not process it)
            //
            if((DriveLayoutEx->PartitionStyle == PARTITION_STYLE_GPT) &&                
                (IsEqualGUID(&(PartInfo->Gpt.PartitionType), &PARTITION_MSFT_RESERVED_GUID) ||
                 IsEqualGUID(&(PartInfo->Gpt.PartitionType), &PARTITION_LDM_METADATA_GUID)  ||
                 IS_OEM_PARTITION_GPT(PartInfo->Gpt.Attributes))) {

                pDiskRegion->IsReserved = TRUE; 
                AssignDriveLetter = FALSE;

                //
                // Get the type name from the resources.
                //
                SpFormatMessage(pDiskRegion->TypeName,
                            sizeof(pDiskRegion->TypeName),
                            SP_TEXT_PARTNAME_RESERVED);
                
                continue;
            }               

            //
            // Assume we can't install on this dynamic volume.
            //
            pDiskRegion->DynamicVolumeSuitableForOS = FALSE;
            
            //
            // For the following entries, we need an Open handle to this partition.
            //            

            //
            // If the partition just got created, we may have to wait for
            // a few seconds before its actually available 
            //
            // Note : We wait for 20 secs at the max for each partition
            //
            for (Count = 0; (Count < 10); Count++) {
                //
                // Open the handle to the required partition
                //
                Status = SpOpenPartition( DevicePath,                
                                          PartInfo->PartitionNumber,
                                          &Handle,
                                          FALSE );

                if((Status == STATUS_NO_SUCH_DEVICE) ||
                   (Status == STATUS_OBJECT_NAME_NOT_FOUND)) {                    
                    KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                                "SETUP: SpPtInitializeDiskAreas: unable to open partition%d on device %ws (%lx)\n",
                                PartInfo->PartitionNumber,
                                DevicePath,
                                Status ));


                    DelayTime.HighPart = -1;                // relative time
                    DelayTime.LowPart = (ULONG)(-20000000);  // 2 secs in 100ns interval                     
                    
                    KeDelayExecutionThread(KernelMode, FALSE, &DelayTime);
                } else {
                    break;
                }
            }                

            //
            // Need the partition handle to continue
            //
            if (!NT_SUCCESS(Status)) {
                //
                // ignore the error while trying to open dynamic disks
                //
                if (SPPT_IS_REGION_DYNAMIC_VOLUME(pDiskRegion)) {
                    Status = STATUS_SUCCESS;
                }

                //
                // Get the type name from the resources.
                //
                SpFormatMessage(pDiskRegion->TypeName,
                            sizeof(pDiskRegion->TypeName),
                            TypeNameId);
                            
                continue;
            }                

            //
            // Check, if installtion can be done on the dynamic volume
            //
            if( pDiskRegion->DynamicVolume ) {
                //
                // Call disk manager to tell me if it's okay to
                // install on this dynamic volume.  If I get back
                // anything but STATUS_SUCCESS, then assume we
                // can't install here.
                //
                Status = ZwDeviceIoControlFile( 
                            Handle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            IOCTL_VOLUME_IS_PARTITION,
                            NULL,
                            0,
                            NULL,
                            0 );

                if( NT_SUCCESS(Status) ){
                    pDiskRegion->DynamicVolumeSuitableForOS = TRUE;
                }
            }
            
            //
            // Filesystem
            //
            pFSInfo = SpMemAlloc( sizeof(FILE_FS_ATTRIBUTE_INFORMATION) + (MAX_PATH*2) );

            if( !pFSInfo ) {
                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                    "SETUP: SpPtInitializeDiskAreas: SpMemAlloc failed!\n" ));
                    
                ZwClose( Handle );

                Status = STATUS_NO_MEMORY;
                break;
            }

            RtlZeroMemory( pFSInfo, sizeof(FILE_FS_ATTRIBUTE_INFORMATION) + (MAX_PATH*2) );

            Status = ZwQueryVolumeInformationFile( 
                        Handle, 
                        &IoStatusBlock,
                        pFSInfo,
                        sizeof(FILE_FS_ATTRIBUTE_INFORMATION) + (MAX_PATH*2),
                        FileFsAttributeInformation );
                                                                                                   
            if (!NT_SUCCESS(Status)) {
                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                    "SETUP: SpPtInitializeDiskAreas: Failed to retrieve partition attribute information (%lx)\n", 
                    Status ));
            } else {                
                if (!wcscmp(pFSInfo->FileSystemName, L"NTFS")) {
                    pDiskRegion->Filesystem = FilesystemNtfs;
                    TypeNameId = SP_TEXT_FS_NAME_3;
                } else if (!wcscmp(pFSInfo->FileSystemName, L"FAT")) {
                    pDiskRegion->Filesystem = FilesystemFat;
                    TypeNameId = SP_TEXT_FS_NAME_2;
                } else if (!wcscmp(pFSInfo->FileSystemName, L"FAT32")) {
                    pDiskRegion->Filesystem = FilesystemFat32;
                    TypeNameId = SP_TEXT_FS_NAME_4;
                } else if (TypeNameId == SP_TEXT_UNKNOWN){
                    ULONG   Index;

                    pDiskRegion->Filesystem = FilesystemUnknown;

                    //
                    // Make sure it was not already created new partition
                    //
                    for (Index = 0; Index < NewPartitionCount; Index++) {
                        if (pDiskRegion->StartSector == NewPartitions[Index]) {
                            pDiskRegion->Filesystem = FilesystemNewlyCreated;
                            TypeNameId = SP_TEXT_FS_NAME_1;

                            break;
                        }                       
                    }                                                    
                }
            }

            //
            // if we cannot determine the partition type, then try
            // to use the known name from partition id.
            //
            if ((TypeNameId == SP_TEXT_UNKNOWN) && SPPT_IS_MBR_DISK(DiskNumber)) {                
                ULONG PartitionType = SPPT_GET_PARTITION_TYPE(pDiskRegion);

                if (PartitionType < 256) {   
                    UCHAR NameId = PartitionNameIds[SPPT_GET_PARTITION_TYPE(pDiskRegion)];

                    if (NameId != 0xFF) {
                        TypeNameId = SP_TEXT_PARTITION_NAME_BASE + NameId;
                    }                                                
                }                        
            }                
                                                            

            //
            // Get the type name from the resources.
            //
            SpFormatMessage(pDiskRegion->TypeName,
                        sizeof(pDiskRegion->TypeName),
                        TypeNameId);

            SpMemFree( pFSInfo );

            //
            // FreeSpaceKB and BytesPerCluster (only if we know what FS it is)
            //
            if ((pDiskRegion->Filesystem != FilesystemUnknown) &&
                 (pDiskRegion->Filesystem != FilesystemNewlyCreated)) {
                //
                // Delete \pagefile.sys if it's there.  This makes disk free space
                // calculations a little easier.
                //
                MyTempBuffer = (PWCHAR)SpMemAlloc( MAX_NTPATH_LENGTH );

                if( !MyTempBuffer ) {
                    //
                    // No memory...
                    //
                    KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                        "SETUP: SpPtInitializeDiskAreas: SpMemAlloc failed!\n" ));

                    Status = STATUS_NO_MEMORY;
                    break;
                }

                SpNtNameFromRegion( pDiskRegion,
                                    MyTempBuffer,
                                    MAX_NTPATH_LENGTH,
                                    PrimaryArcPath );
                                    
                SpConcatenatePaths( MyTempBuffer, L"" );
                SpDeleteFile( MyTempBuffer, L"pagefile.sys", NULL );

                SpMemFree( MyTempBuffer );
                MyTempBuffer = NULL;

                pSizeInfo = SpMemAlloc( sizeof(FILE_FS_SIZE_INFORMATION) + (MAX_PATH*2) );

                if( !pSizeInfo ) {
                    KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                        "SETUP: SpPtInitializeDiskAreas: SpMemAlloc failed!\n" ));
                    
                    ZwClose( Handle );

                    Status = STATUS_NO_MEMORY;
                    break;
                }

                RtlZeroMemory( pSizeInfo, sizeof(FILE_FS_SIZE_INFORMATION) + (MAX_PATH*2) );

                Status = ZwQueryVolumeInformationFile( 
                            Handle, 
                            &IoStatusBlock,
                            pSizeInfo,
                            sizeof(FILE_FS_SIZE_INFORMATION) + (MAX_PATH*2),
                            FileFsSizeInformation );

                //
                // Waiting for another 2 secs for the volume to appear 
                //
                if (Status == STATUS_NO_SUCH_DEVICE) {
                    //
                    // Wait for 2 seconds
                    //
                    DelayTime.HighPart = -1;                // relative time
                    DelayTime.LowPart = (ULONG)(-20000000);  // 2 secs in 100ns interval                                     
                    KeDelayExecutionThread(KernelMode, FALSE, &DelayTime);
                    
                    RtlZeroMemory( pSizeInfo, sizeof(FILE_FS_SIZE_INFORMATION) + (MAX_PATH*2) );

                    Status = ZwQueryVolumeInformationFile( 
                                Handle, 
                                &IoStatusBlock,
                                pSizeInfo,
                                sizeof(FILE_FS_SIZE_INFORMATION) + (MAX_PATH*2),
                                FileFsSizeInformation );
                }
                            
                if (!NT_SUCCESS(Status)) {
                    KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                        "SETUP: SpPtInitializeDiskAreas: Failed to retrieve disk(%d)partition(%d) sizing information (%lx)\n", 
                        DiskNumber,
                        pDiskRegion->PartitionNumber,                        
                        Status ));
                } else {
                    LARGE_INTEGER FreeBytes;

                    FreeBytes = RtlExtendedIntegerMultiply( 
                                    pSizeInfo->AvailableAllocationUnits,
                                    pSizeInfo->SectorsPerAllocationUnit * pSizeInfo->BytesPerSector );

                    pDiskRegion->FreeSpaceKB = RtlExtendedLargeIntegerDivide( FreeBytes,
                                                                              1024, &r ).LowPart;
                    if(r >= 512) {
                        pDiskRegion->FreeSpaceKB++;
                    }

                    //
                    // Sigh...  Legacy stuff.  SpPtDeterminePartitionGood() will want this
                    // field so that he knows what the free-space+space_from_local_source is.
                    //
                    pDiskRegion->AdjustedFreeSpaceKB = pDiskRegion->FreeSpaceKB;

                    pDiskRegion->BytesPerCluster = 
                        pSizeInfo->SectorsPerAllocationUnit * pSizeInfo->BytesPerSector;
                }

                SpMemFree( pSizeInfo );

                //
                // VolumeLabel
                //
                pLabelInfo = SpMemAlloc( sizeof(FILE_FS_VOLUME_INFORMATION) + (MAX_PATH*2) );

                if( !pFSInfo ) {
                    KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                        "SETUP: SpPtInitializeDiskAreas: SpMemAlloc failed!\n" ));
                        
                    ZwClose( Handle );

                    Status = STATUS_NO_MEMORY;
                    break;
                }

                RtlZeroMemory( pLabelInfo, sizeof(FILE_FS_VOLUME_INFORMATION) + (MAX_PATH*2) );

                Status = ZwQueryVolumeInformationFile(
                            Handle, 
                            &IoStatusBlock,
                            pLabelInfo,
                            sizeof(FILE_FS_VOLUME_INFORMATION) + (MAX_PATH*2),
                            FileFsVolumeInformation );

                if (!NT_SUCCESS(Status)) {
                    KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                        "SETUP: SpPtInitializeDiskAreas: Failed to retrieve volume information (%lx)\n", Status));
                } else {
                    ULONG SaveCharCount;
                    
                    //
                    // We'll only save away the first <n> characters of
                    // the volume label.
                    //
                    SaveCharCount = min( pLabelInfo->VolumeLabelLength + sizeof(WCHAR),
                                         sizeof(pDiskRegion->VolumeLabel) ) / sizeof(WCHAR);

                    if(SaveCharCount) {
                        SaveCharCount--;  // allow for terminating NUL.
                    }

                    wcsncpy( pDiskRegion->VolumeLabel,
                             pLabelInfo->VolumeLabel,
                             SaveCharCount );
                             
                    pDiskRegion->VolumeLabel[SaveCharCount] = 0;

                }

                SpMemFree( pLabelInfo );
            } else {
                //
                // Free space is what ever the partition size is
                //
                pDiskRegion->FreeSpaceKB = (pDiskRegion->SectorCount * 
                                            Disk->Geometry.BytesPerSector) / 1024;

                pDiskRegion->AdjustedFreeSpaceKB = pDiskRegion->FreeSpaceKB;                                            
            }

            //
            // Assign the drive letter if required
            //
            if (AssignDriveLetter) {
                //
                // Retrieve nt pathname for this region.
                //
                MyTempBuffer = (PWCHAR)SpMemAlloc( MAX_NTPATH_LENGTH );

                if( !MyTempBuffer ) {
                    //
                    // No memory...
                    //
                    KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                        "SETUP: SpPtInitializeDiskAreas: SpMemAlloc failed!\n" ));

                    Status = STATUS_NO_MEMORY;
                    break;
                }
        
                SpNtNameFromRegion( pDiskRegion,
                                    MyTempBuffer,
                                    MAX_NTPATH_LENGTH,
                                    PrimaryArcPath );

                //
                // Assign the drive letter 
                //
                pDiskRegion->DriveLetter = SpGetDriveLetter( MyTempBuffer, NULL );

                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                    "SETUP: SpPtInitializeDiskAreas: Partition = %ls, DriveLetter = %wc: \n", 
                    MyTempBuffer, pDiskRegion->DriveLetter));

                SpMemFree( MyTempBuffer );
                MyTempBuffer = NULL;
            }                
            
            //
            // See if this guy has the local source.
            //
            //
            MyTempBuffer = (PWCHAR)SpMemAlloc( MAX_NTPATH_LENGTH );

            if( !MyTempBuffer ) {
                //
                // No memory...
                //
                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                    "SETUP: SpPtInitializeDiskAreas: SpMemAlloc failed!\n" ));
                    
                Status = STATUS_NO_MEMORY;
                break;
            }

            SpNtNameFromRegion( pDiskRegion,
                                MyTempBuffer,
                                MAX_NTPATH_LENGTH,
                                PrimaryArcPath );
                                
            SpConcatenatePaths( MyTempBuffer, L"" );

            //
            // Don't need this guy anymore.
            //
            ZwClose( Handle );


            if( WinntSetup && !WinntFromCd && !LocalSourceRegion &&
                    SpNFilesExist(MyTempBuffer, LocalSourceFiles, ELEMENT_COUNT(LocalSourceFiles), TRUE) ) {

                LocalSourceRegion = pDiskRegion;
                pDiskRegion->IsLocalSource = TRUE;

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                    "SETUP: %ws is the local source partition.\n", MyTempBuffer));
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                    "SETUP: %ws is not the local source partition.\n", MyTempBuffer));
            }

            SpMemFree( MyTempBuffer );
            MyTempBuffer = NULL;
            Status = STATUS_SUCCESS;
        }

        //
        // Go ahead and locate the system partitions on this disk
        //
        if (SpIsArc()) {
            if (!SysPartFound) {
                SpPtnLocateDiskSystemPartitions(DiskNumber);
            } else {
                ValidArcSystemPartition = TRUE;
            }
        }
    }

    //
    // Update the boot entries to reflect the 
    // new region pointers
    //
    SpUpdateRegionForBootEntries();

    if (NewPartitions) {
        SpMemFree(NewPartitions);
    }    

    SpMemFree( DriveLayoutEx );

    return Status;
}


NTSTATUS
SpPtnSortDiskAreas(
    IN ULONG DiskNumber
    )
/*++

Routine Description:

    Examine the partitions defined on this disk and sort them
    according to their location on the disk.

Arguments:

    DiskNumber - supplies the disk number of the disk whose partitions
                 we want to inspect.

Return Value:

    NTSTATUS.  If all goes well, we should be returing STATUS_SUCCESS.

--*/
{
    NTSTATUS        Status = STATUS_SUCCESS;
    PDISK_REGION    pTempDiskRegion = NULL;
    PDISK_REGION    pCurrentDiskRegion = NULL;
    PDISK_REGION    pPreviousDiskRegion = NULL;

    //
    // Get a pointer to the list of regions.
    //
    pCurrentDiskRegion = PartitionedDisks[DiskNumber].PrimaryDiskRegions;

    if( !pCurrentDiskRegion ) {
        //
        // Odd.  Either something is very wrong, or
        // this disk simply has no partitions, which is
        // certainly possible.  Assume the best.
        //
        return  STATUS_SUCCESS;
    }

    //
    // We got something.  Go sort the list.  There
    // can't be very many partitions, so just bubble-sort.
    //
    while( pCurrentDiskRegion->Next ) {
        //
        // There's another partition ahead of
        // us.  See if we need to switch places.
        //
        if( pCurrentDiskRegion->StartSector > pCurrentDiskRegion->Next->StartSector ) {
            //
            // Yes, we need to swap these 2 entries.
            // Fixup the pointers.
            //
            if( pPreviousDiskRegion ) {
                //
                // 1. Set the previous disk region to point to
                //    the region after us.
                //
                pPreviousDiskRegion->Next = pCurrentDiskRegion->Next;
            } else {
                //
                // We're at the very beginning of the linked
                // list.
                //

                //
                // 1. Set the disk's region pointer to point to
                //    the region after us.
                //
                PartitionedDisks[DiskNumber].PrimaryDiskRegions = pCurrentDiskRegion->Next;
            }

            //
            // 2. Set our our next region's Next pointer to
            //    come back to us.
            //
            pTempDiskRegion = pCurrentDiskRegion->Next->Next;
            pCurrentDiskRegion->Next->Next = pCurrentDiskRegion;

            //
            // 3. Set our own pointer to a couple of regions ahead.
            //
            pCurrentDiskRegion->Next = pTempDiskRegion;

            //
            // Now reset so we start the sort over again.
            //
            pCurrentDiskRegion = PartitionedDisks[DiskNumber].PrimaryDiskRegions;
            pPreviousDiskRegion = NULL;
        } else {
            //
            // No need to swap these two regions in our list.  Increment
            // our pointers and continue.
            //
            pPreviousDiskRegion = pCurrentDiskRegion;
            pCurrentDiskRegion = pCurrentDiskRegion->Next;
        }
    }

    return  Status;
}


NTSTATUS
SpPtnInitRegionFromDisk(
    IN ULONG DiskNumber,
    OUT PDISK_REGION Region
    )
/*++

Routine Description:

    Given the disk id, creates a disk region representing
    the whole disk

Arguments:

    DiskNumber  :   Disk Id

    Region      :   Region which gets initialized on return

Return Value:

    STATUS_SUCCESS if successful, otherwise STATUS_INVALID_PARAMETER

--*/    
{   
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    
    if (Region) {
        PHARD_DISK Disk = SPPT_GET_HARDDISK(DiskNumber);

        RtlZeroMemory(Region, sizeof(DISK_REGION));

        //
        // Note : Most of the fields below don't need to be initialized
        // because of the memset above, but its done for sake of
        // clarity
        //
        Region->DiskNumber = DiskNumber;
        Region->StartSector = Disk->Geometry.SectorsPerTrack;
        Region->SectorCount = Disk->DiskSizeSectors - Region->StartSector;
        SPPT_SET_REGION_PARTITIONED(Region, FALSE);
        Region->PartitionNumber = 0;
        Region->MbrInfo = NULL;
        Region->TablePosition = 0;
        Region->IsSystemPartition = FALSE;
        Region->IsLocalSource = FALSE;
        Region->Filesystem = FilesystemUnknown;
        Region->FreeSpaceKB = Disk->DiskSizeMB * 1024;
        Region->BytesPerCluster = -1;
        Region->AdjustedFreeSpaceKB = Region->FreeSpaceKB;
        Region->DriveLetter = 0;
        Region->FtPartition = FALSE;
        Region->DynamicVolume = FALSE;
        Region->DynamicVolumeSuitableForOS = FALSE;

        Status = STATUS_SUCCESS;
    }        

    return Status;
}    


NTSTATUS
SpPtnFillDiskFreeSpaceAreas(
    IN ULONG DiskNumber
    )
/*++

Routine Description:

    This function will go peruse all partitions on the disk.  If there are
    any free regions on the disk, we'll create a region entry and
    mark it as unformatted.

Arguments:

    DiskNumber - supplies the disk number of the disk whose partitions
                 we want to inspect.

Return Value:

    NTSTATUS.  If all goes well, we should be returing STATUS_SUCCESS.

--*/
{
    NTSTATUS        Status = STATUS_SUCCESS;
    PDISK_REGION    pTempDiskRegion;
    PDISK_REGION    pCurrentDiskRegion = NULL;
    ULONGLONG       NextStart;
    ULONGLONG       NextSize;
    PDISK_REGION    FirstContainer = NULL;

    //
    // Get a pointer to the list of regions.
    //
    pCurrentDiskRegion = PartitionedDisks[DiskNumber].PrimaryDiskRegions;

    if( !pCurrentDiskRegion ) {
        //
        // Odd.  Either something is very wrong, or
        // this disk simply has no partitions, which is
        // certainly possible.  Assume the best and
        // create one region entry that encompasses all
        // space on the disk, but is unpartitioned.
        //        
        pCurrentDiskRegion = SpMemAlloc(sizeof(DISK_REGION));

        if (pCurrentDiskRegion) {
            Status = SpPtnInitRegionFromDisk(DiskNumber, pCurrentDiskRegion);
        } else {
            Status = STATUS_NO_MEMORY;
        }            

        if (NT_SUCCESS(Status)) {
            ASSERT(!PartitionedDisks[DiskNumber].PrimaryDiskRegions);
            
            PartitionedDisks[DiskNumber].PrimaryDiskRegions =
                    pCurrentDiskRegion;

            SPPT_SET_DISK_BLANK(DiskNumber, TRUE);
        }                    
        
        return Status;
    }

    //
    // The regions are already sorted according to their relative
    // position on the disk, so before we go through them, let's
    // see if there's any empty space on the disk occurring *before*
    // the first partition.
    //
    if( pCurrentDiskRegion->StartSector > SPPT_DISK_TRACK_SIZE(DiskNumber) ) {
        //
        // Yep.  Make a region descriptor for this guy (if he is more than
        // one cylinder in size)
        //
        NextStart = SPPT_DISK_TRACK_SIZE(DiskNumber);
        NextSize = pCurrentDiskRegion->StartSector - NextStart;

        //
        // The first partition can start at first track offset. So this need not always
        // be of minimum cylinder size
        //
        if (NextSize >= (SPPT_DISK_CYLINDER_SIZE(DiskNumber) - SPPT_DISK_TRACK_SIZE(DiskNumber))) {        
            pTempDiskRegion = SpMemAlloc( sizeof(DISK_REGION) );

            if(!pTempDiskRegion) {
                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                        "SETUP: SpPtFillFreeSpaceAreas: SpMemAlloc failed!\n" ));
                        
                return  STATUS_NO_MEMORY;
            }

            RtlZeroMemory( pTempDiskRegion, sizeof(DISK_REGION) );

            pTempDiskRegion->DiskNumber = DiskNumber;
            pTempDiskRegion->StartSector = NextStart;
            pTempDiskRegion->SectorCount = NextSize;

            //
            // Put this region before the current region
            //
            pTempDiskRegion->Next = pCurrentDiskRegion;
            PartitionedDisks[DiskNumber].PrimaryDiskRegions = pTempDiskRegion;
        }            
    }

    //
    // Now go through the regions, inserting regions to account for any
    // empty space between the partitions.
    //
    while( pCurrentDiskRegion ) {
        if( !pCurrentDiskRegion->Next ) {            

            NextStart = 0;
            
            //
            // if this is container partition then all the space in this
            // container is free space
            //
            if (SPPT_IS_MBR_DISK(DiskNumber) && 
                IsContainerPartition(SPPT_GET_PARTITION_TYPE(pCurrentDiskRegion))) {
                PDISK_REGION ExtFree = NULL;

                ASSERT(FirstContainer == NULL);

                //
                // We add one here because we should be able to differentiate the starting
                // free region inside the extended partition from the extended partition
                // itself.
                //
                NextStart = pCurrentDiskRegion->StartSector + 1;
                NextSize = pCurrentDiskRegion->SectorCount;

                if (NextSize >= SPPT_DISK_CYLINDER_SIZE(DiskNumber)) {                
                    PDISK_REGION ExtFree = SpMemAlloc(sizeof(DISK_REGION));

                    if (!ExtFree) {
                        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                            "SETUP: SpPtFillFreeSpaceAreas: SpMemAlloc failed!\n" ));
                            
                        return  STATUS_NO_MEMORY;
                    }

                    RtlZeroMemory(ExtFree, sizeof(DISK_REGION));

                    ExtFree->DiskNumber = DiskNumber;
                    ExtFree->StartSector = NextStart;
                    ExtFree->SectorCount = NextSize;

                    pCurrentDiskRegion->Next = ExtFree;

                    //
                    // make the new region current region !!!
                    //
                    pCurrentDiskRegion = ExtFree;   

                    NextStart = NextStart + NextSize - 1;
                } else {
                    //
                    // Make sure that the free space after the extended 
                    // partition is accounted for
                    //
                    NextStart = 0;  
                }                    
            } 
            
            //                
            // There's nothing behind of us.  See if there's any
            // empty space back there that's unaccounted for.
            // 
            if (!NextStart) {
                NextStart = pCurrentDiskRegion->StartSector + 
                            pCurrentDiskRegion->SectorCount;
            }                            

            if (PartitionedDisks[DiskNumber].HardDisk->DiskSizeSectors > NextStart) {
                NextSize = PartitionedDisks[DiskNumber].HardDisk->DiskSizeSectors -
                                NextStart;
            } else {
                NextSize = 0;
            }

            //
            // For ASR, allow partition size on GPT disks to be >= 1 sector.  
            // In all other cases, partition size must be >= 1 cylinder.
            //
            if ((NextSize >= SPPT_DISK_CYLINDER_SIZE(DiskNumber))  || 
                (SpDrEnabled() && SPPT_IS_GPT_DISK(DiskNumber) && (NextSize >= 1))
                ) {
                //
                // Yes there is.  We need to make a region behind us that's
                // marked as unpartitioned.
                //                
                if (FirstContainer) {
                    //
                    // there could be free space at the end of the 
                    // extended partition. Mark is separately from
                    // the free space after the extended partition
                    //
                    ULONGLONG ExtEnd = FirstContainer->StartSector + 
                                        FirstContainer->SectorCount;
                    ULONGLONG ExtFreeStart = NextStart;
                    ULONGLONG ExtFreeSize = (ExtEnd > ExtFreeStart) ?
                                            ExtEnd - ExtFreeStart : 0;

                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                            "SETUP:SpPtnFillDiskFreeSpaces():EFS:%I64d,EFSize:%I64d,EE:%I64d\n",
                            ExtFreeStart,
                            ExtFreeSize,
                            ExtEnd));

                    if (ExtFreeSize >= SPPT_DISK_CYLINDER_SIZE(DiskNumber)) {
                        PDISK_REGION ExtFree = SpMemAlloc(sizeof(DISK_REGION));

                        if (!ExtFree) {
                            KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                                "SETUP: SpPtnFillFreeSpaceAreas: SpMemAlloc failed!\n" ));
                                
                            return  STATUS_NO_MEMORY;
                        }

                        RtlZeroMemory(ExtFree, sizeof(DISK_REGION));

                        ExtFree->DiskNumber = DiskNumber;
                        ExtFree->StartSector = ExtFreeStart;
                        ExtFree->SectorCount = ExtFreeSize;

                        pCurrentDiskRegion->Next = ExtFree;
                        pCurrentDiskRegion = ExtFree;

                        NextStart = ExtEnd;
                        NextSize = 0;

                        if (PartitionedDisks[DiskNumber].HardDisk->DiskSizeSectors > NextStart) {
                            NextSize = PartitionedDisks[DiskNumber].HardDisk->DiskSizeSectors -
                                        NextStart;
                        }                                                                                                            
                    } else {
                        //
                        // Get rid of any free space at the end which is lesser than a 
                        // cylinder partition inside the exteneded partition before
                        // we try to see if there is adequate space at the end of extended
                        // partition
                        //
                        NextStart += ExtFreeSize;
                        NextSize -= ExtFreeSize;
                    }
                }

                //
                // For ASR, allow partition size on GPT disks to be >= 1 sector.  
                // In all other cases, partition size must be >= 1 cylinder.
                //
                if ((NextSize >= SPPT_DISK_CYLINDER_SIZE(DiskNumber))  || 
                    (SpDrEnabled() && SPPT_IS_GPT_DISK(DiskNumber) && (NextSize >= 1))
                    ) {
                    pTempDiskRegion = SpMemAlloc( sizeof(DISK_REGION) );

                    if(!pTempDiskRegion) {
                        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                            "SETUP: SpPtnFillFreeSpaceAreas: SpMemAlloc failed!\n" ));
                            
                        return(STATUS_NO_MEMORY);
                    }

                    RtlZeroMemory( pTempDiskRegion, sizeof(DISK_REGION) );


                    pTempDiskRegion->DiskNumber = DiskNumber;
                    pTempDiskRegion->StartSector = NextStart;
                    pTempDiskRegion->SectorCount = NextSize;
                    pCurrentDiskRegion->Next = pTempDiskRegion;
                }                    
            }

            //
            // We just processed the last region.  If there was any free space
            // behind that partition, we just accounted for it, in which case
            // we're done with this disk.  If there wasn't any free space behind
            // that partition, then we're also done.
            //
            return( Status );
        } else {
            //
            // There's another partition ahead of us.
            // See if there's free space between them.
            //
            NextStart = pCurrentDiskRegion->StartSector + 
                        pCurrentDiskRegion->SectorCount;

            if (pCurrentDiskRegion->Next->StartSector > NextStart) {
                NextSize = pCurrentDiskRegion->Next->StartSector - NextStart;                        

                //
                // Check to see if its a container partition
                //
                if (!FirstContainer && SPPT_IS_MBR_DISK(DiskNumber) && 
                    IsContainerPartition(SPPT_GET_PARTITION_TYPE(pCurrentDiskRegion))) {
                    
                    FirstContainer = pCurrentDiskRegion; 
                    NextStart = pCurrentDiskRegion->StartSector + 1;
                    NextSize = pCurrentDiskRegion->Next->StartSector - NextStart;
                }

                if (FirstContainer) {
                    ULONGLONG   ExtEnd = FirstContainer->StartSector +  
                                         FirstContainer->SectorCount;
                    ULONGLONG   FreeEnd = pCurrentDiskRegion->Next->StartSector;
                    
                    //
                    // Split the free region into extended free and normal free region
                    // if needed
                    //
                    if (!SPPT_IS_REGION_CONTAINED(FirstContainer, pCurrentDiskRegion->Next) && 
                        (ExtEnd < FreeEnd)) {
                        
                        PDISK_REGION ExtFree = NULL;

                        //
                        // If the free space doesnt overlap the extended partition
                        // then do not subtract from extended end
                        //
                        if (NextStart < ExtEnd){
                            NextSize = ExtEnd - NextStart;
                        }
                        
                        if (NextSize >= SPPT_DISK_CYLINDER_SIZE(DiskNumber)) {
                            ExtFree = SpMemAlloc(sizeof(DISK_REGION));

                            if (!ExtFree) {
                                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                                    "SETUP: SpPtnFillFreeSpaceAreas: SpMemAlloc failed!\n" ));
                                    
                                return  STATUS_NO_MEMORY;
                            }

                            RtlZeroMemory(ExtFree, sizeof(DISK_REGION));

                            ExtFree->DiskNumber = DiskNumber;
                            ExtFree->StartSector = NextStart;
                            ExtFree->SectorCount = NextSize;

                            //
                            // insert the region after the current one
                            //
                            ExtFree->Next = pCurrentDiskRegion->Next;
                            pCurrentDiskRegion->Next = ExtFree;

                            //
                            // make the new region current
                            //
                            pCurrentDiskRegion = ExtFree;
                        }

                        //
                        // Fix the next free region start
                        //
                        NextStart += NextSize;

                        if (FreeEnd > NextStart) {
                            NextSize = FreeEnd - NextStart;
                        } else {
                            NextSize = 0;
                        }
                    }                    
                }                
            } else {
                //
                // skip container partitions (expect for starting free space
                // inside the container partition)
                //  
                NextSize = 0;
                
                if (SPPT_IS_MBR_DISK(DiskNumber) && 
                    IsContainerPartition(SPPT_GET_PARTITION_TYPE(pCurrentDiskRegion)) && 
                    (pCurrentDiskRegion->Next->StartSector > pCurrentDiskRegion->StartSector)) {

                    if (!FirstContainer) {
                        FirstContainer = pCurrentDiskRegion;
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                            "SETUP:SpPtnFillDiskFreeSpaces():%p is the first container\n", 
                            FirstContainer));
                    }                        
                    
                    //
                    // We add one here because we should be able to differentiate the starting
                    // free region inside the extended partition from the extended partition
                    // itself.
                    //
                    NextStart = pCurrentDiskRegion->StartSector + 1;            
                    NextSize = pCurrentDiskRegion->Next->StartSector - NextStart + 1;
                }
            }                

            //
            // For ASR, allow partition size on GPT disks to be >= 1 sector.  
            // In all other cases, partition size must be >= 1 cylinder.
            //
            if ((NextSize >= SPPT_DISK_CYLINDER_SIZE(DiskNumber))  || 
                (SpDrEnabled() && SPPT_IS_GPT_DISK(DiskNumber) && (NextSize >= 1))
                ) {
                //
                // Yes, there's free space and we need to insert
                // a region here to represent it.  Allocate a region
                // and initialize it as unpartitioned space.
                //
                pTempDiskRegion = SpMemAlloc( sizeof(DISK_REGION) );

                if(!pTempDiskRegion) {
                    KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                    "SETUP: SpPtnFillFreeSpaceAreas: SpMemAlloc failed!\n" ));
                    
                    return(STATUS_NO_MEMORY);
                }

                RtlZeroMemory( pTempDiskRegion, sizeof(DISK_REGION) );


                pTempDiskRegion->DiskNumber = DiskNumber;
                pTempDiskRegion->StartSector = NextStart;
                pTempDiskRegion->SectorCount = NextSize;
                
                pTempDiskRegion->Next = pCurrentDiskRegion->Next;
                pCurrentDiskRegion->Next = pTempDiskRegion;
                pCurrentDiskRegion = pTempDiskRegion;
            }
        }
        pCurrentDiskRegion = pCurrentDiskRegion->Next;
    }

    return  Status;
}


#ifdef NOT_USED_CURRENTLY

VOID
SpDeleteDiskDriveLetters(
    VOID
    )
/*++

Routine Description:

    This routine will delete all drive letters assigned to disks and CD-ROM drives. The deletion will
    occur only if setup was started booting from the CD or boot floppies (in which case drive letter
    migration does not take place), and only if the non-removable dissks have no partitioned spaces.
    This ensures that on a clean install from the CD or boot floppies, the drive letters assigned to
    partitions on removable disks and CD-ROM drives will always be greater than the drive letters assigned
    to partitions on non-removable disks (unless the partitions on the removable disks were created before
    the ones in the removable disks, during textmode setup).


Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG           DiskNumber;
    PDISK_REGION    pDiskRegion;
    PWCHAR          MyTempBuffer = NULL;
    unsigned        pass;
    BOOLEAN         PartitionedSpaceFound = FALSE;

    if( WinntSetup ) {
        //
        // If setup started from winnt32.exe then do not delete the drive letters since we want to preserve them
        //
        return;
    }

    //
    //  Setup started booting from a CD.
    //
    //  Find out if the disks contain at least one partition that is not a container.
    //  Note that we do not take into consideration partitions that are on removable media.
    //  This is to avoid the situation in which a newly created partition on a non-removable disk ends up with
    //  a drive letter that is greater than the one assigned to an existing partition on a removable disk.
    //
    for(DiskNumber = 0; !PartitionedSpaceFound && (DiskNumber<HardDiskCount); DiskNumber++) {

        if( PartitionedDisks[DiskNumber].HardDisk->Geometry.MediaType != RemovableMedia) {
            //
            // This disk isn't removable.  Let's look at all the areas and see
            // if there's anything that's partitioned.
            //
            pDiskRegion = PartitionedDisks[DiskNumber].PrimaryDiskRegions;

            while( pDiskRegion ) {
                if(SPPT_IS_REGION_PARTITIONED(pDiskRegion)) {
                    PartitionedSpaceFound = TRUE;
                }

                //
                // Now get the next region on this disk.
                //
                pDiskRegion = pDiskRegion->Next;
            }
        }
    }

    if( !PartitionedSpaceFound ) {
        //
        // There are no partitions on this machine.  Delete all drive letters
        // so that the drive letters for each CD-ROM drive also get deleted.
        //
        // We'll do this by sending an IOCTL to the MountManager and ask him
        // to whack all his knowledge of drive letters.
        //
        NTSTATUS                Status;
        OBJECT_ATTRIBUTES       Obja;
        IO_STATUS_BLOCK         IoStatusBlock;
        UNICODE_STRING          UnicodeString;
        HANDLE                  Handle;

        INIT_OBJA(&Obja,&UnicodeString,MOUNTMGR_DEVICE_NAME);

        Status = ZwOpenFile( &Handle,
                             (ACCESS_MASK)(FILE_GENERIC_READ | FILE_GENERIC_WRITE),
                             &Obja,
                             &IoStatusBlock,
                             FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_NON_DIRECTORY_FILE );

        if( NT_SUCCESS( Status ) ) {

            MOUNTMGR_MOUNT_POINT    MountMgrMountPoint;

            MountMgrMountPoint.SymbolicLinkNameOffset = 0;
            MountMgrMountPoint.SymbolicLinkNameLength = 0;
            MountMgrMountPoint.UniqueIdOffset = 0;
            MountMgrMountPoint.UniqueIdLength = 0;
            MountMgrMountPoint.DeviceNameOffset = 0;
            MountMgrMountPoint.DeviceNameLength = 0;

            Status = ZwDeviceIoControlFile( Handle,
                                            NULL,
                                            NULL,
                                            NULL,
                                            &IoStatusBlock,
                                            IOCTL_MOUNTMGR_DELETE_POINTS,
                                            &MountMgrMountPoint,
                                            sizeof( MOUNTMGR_MOUNT_POINT ),
                                            TemporaryBuffer,
                                            sizeof( TemporaryBuffer ) );
            if( !NT_SUCCESS( Status ) ) {
                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, 
                    "SETUP: Unable to delete drive letters. "
                    "ZwDeviceIoControl( IOCTL_MOUNTMGR_DELETE_POINTS ) failed."
                    "Status = %lx \n", Status));
            } else {
                //
                // If the drive letters got deleted then reset the drive letters assigned to all partitions.
                // Note that we only really care about resetting the drive letters on the partitions on the
                // removable disks, since, if we got that far, there won't be any partition on the non-removable
                // disks
                //
                for(DiskNumber = 0; DiskNumber<HardDiskCount; DiskNumber++) {

                    //
                    // This disk isn't removable.  Let's look at all the areas and see
                    // if there's anything that's partitioned.
                    //
                    pDiskRegion = PartitionedDisks[DiskNumber].PrimaryDiskRegions;

                    while( pDiskRegion ) {

                        pDiskRegion->DriveLetter = 0;

                        //
                        // Now get the next region on this disk.
                        //
                        pDiskRegion = pDiskRegion->Next;
                    }
                }
            }

            ZwClose( Handle );
        } else {
            KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, 
                "SETUP: Unable to delete drive letters. "
                "ZwOpenFile( %ls ) failed. Status = %lx \n", 
                MOUNTMGR_DEVICE_NAME, 
                Status));
        }
    }
}


NTSTATUS
SpAssignDiskDriveLetters(
    VOID
    )
/*++

Routine Description:



Arguments:


Return Value:


--*/    
{
    NTSTATUS        Status = STATUS_SUCCESS;
    ULONG           DiskNumber;
    PDISK_REGION      pDiskRegion;
    PWCHAR          MyTempBuffer = NULL;
    unsigned        pass;

    //
    // Before initializing the drive letters, delete them if necessary.
    // This is to get rid of the letters assigned to CD-ROM drives and removables, when the disks have no
    // partitioned space.
    //
    SpDeleteDiskDriveLetters();

    //
    // Initialize all drive letters to nothing.
    // If it the region is a partitioned space, then assign a drive letter also.
    //
    for( DiskNumber=0; DiskNumber<HardDiskCount; DiskNumber++ ) {
    
        pDiskRegion = PartitionedDisks[DiskNumber].PrimaryDiskRegions;

        while( pDiskRegion ) {
        
            pDiskRegion->DriveLetter = 0;
            
            if(SPPT_IS_REGION_PARTITIONED(pDiskRegion)) {
                //
                // Retrieve nt pathname for this region.
                //
                MyTempBuffer = (PWCHAR)SpMemAlloc( MAX_NTPATH_LENGTH );

                if( !MyTempBuffer ) {
                    //
                    // No memory...
                    //
                    KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                        "SETUP: SpPtAssignDriveLetters: SpMemAlloc failed!\n" ));
                        
                    return(STATUS_NO_MEMORY);
                }
                    
                SpNtNameFromRegion( pDiskRegion,
                                    MyTempBuffer,
                                    MAX_NTPATH_LENGTH,
                                    PrimaryArcPath );

                //
                // Assign the drive letter.
                //
                pDiskRegion->DriveLetter = SpGetDriveLetter( MyTempBuffer, NULL );

                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                    "SETUP: SpPtAssignDriveLetters: Partition = %ls, DriveLetter = %wc: \n", 
                    MyTempBuffer, pDiskRegion->DriveLetter));


                SpMemFree( MyTempBuffer );
                MyTempBuffer = NULL;
            }

            //
            // Now get the next region on this disk.
            //
            pDiskRegion = pDiskRegion->Next;
        }
    }

    return( Status );
}

#endif  // NOT_USED_CURRENTLY



//
// ============================================================================
// ============================================================================
//
// The following code provides support for disk/partition selection.
//
// ============================================================================
// ============================================================================
//
#define MENU_LEFT_X     3
#define MENU_WIDTH      (VideoVars.ScreenWidth-(2*MENU_LEFT_X))
#define MENU_INDENT     4

extern ULONG PartitionMnemonics[];


VOID
SpPtnAutoCreatePartitions(
    IN  PVOID         SifHandle,
    IN  PWSTR         SetupSourceDevicePath,
    IN  PWSTR         DirectoryOnSetupSource
    )
/*++

Routine Description:

    If there are no partitions on any disks, create some.


Arguments:

    SifHandle               :  Handle to txtsetup.sif

    SetupSourceDevicePath   :  Device from which setup was launced

    DirectoryOnSetupSource  :  Directory from where the kernel was loaded on
                               Setup device

Return Value:

    None.

--*/
{
    PDISK_REGION    p = NULL;
    PDISK_REGION    Region = NULL;
    ULONG           Index;
    BOOLEAN         Found = FALSE;
    WCHAR           RegionStr[128] = {0};
    NTSTATUS        FormatStatus;
    ULONG           MyPartitionSizeMB = 0;
    NTSTATUS        Status;



    KdPrintEx(( DPFLTR_SETUP_ID,
                DPFLTR_INFO_LEVEL,  
                "SETUP: SpPtnAutoCreatePartitions - Checking for any existing partitions.\n" ));


    Found = FALSE;

    for(Index = 0; (Index < HardDiskCount) && (!Found); Index++) {

        Region = SPPT_GET_PRIMARY_DISK_REGION( Index );

        while( (Region) && (!Found) ) {

            if( Region->PartitionedSpace && 
                !SPPT_IS_REGION_RESERVED_PARTITION(Region)) {

                //
                // He's got something on the disk.
                //
                Found = TRUE;
            }

            Region = Region->Next;
        }
    }

    if( !Found ) {

        //
        // The disks are all empty.  We need to go
        // create some partitions for the installation.
        //

        KdPrintEx(( DPFLTR_SETUP_ID,
                    DPFLTR_INFO_LEVEL,  
                    "SETUP: SpPtnAutoCreatePartitions - No existing partitions were found.\n" ));



        if (SpIsArc()) {
            //
            // If we're on an ARC machine, go create a system
            // partition first.
            //
            
            KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                "SETUP: SpPtnAutoCreatePartitions - About to "
                "auto-generate a system partition.\n" ));

#if defined(_IA64_)

            Status = SpPtnCreateESP(FALSE);

            if (!NT_SUCCESS(Status)) {
                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                    "SETUP: SpPtnAutoCreatePartitions - Could not "
                    "autocreate ESP : %lx\n",
                    Status));

                return;
            }
            
#endif            
        }

        //
        // Now create a partition to install the operating system.
        //
        // To do this, we're going to take the following steps:
        // 1. go find some free space on a disk that's big enough.
        // 2. create a partitions that's half of this guy's free space, (make the
        //    partition at least 4Gig).
        //

        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
            "SETUP: SpPtnAutoCreatePartitions - About to "
            "auto-generate an installation partition.\n" ));

        Found = FALSE;
        for(Index = 0; (Index < HardDiskCount) && (!Found); Index++) {

            Region = SPPT_GET_PRIMARY_DISK_REGION( Index );

            while( (Region) && (!Found) ) {

                if( (!Region->PartitionedSpace) &&
                    (SPPT_REGION_FREESPACE_KB(Region)/1024 >= (SUGGESTED_INSTALL_PARTITION_SIZE_MB)) ) {

                    KdPrintEx(( DPFLTR_SETUP_ID,
                                DPFLTR_INFO_LEVEL,  
                                "SETUP: SpPtnAutoCreatePartitions - I found an area big enough for an installation.\n" ));

                    MyPartitionSizeMB = max( (ULONG)(SPPT_REGION_FREESPACE_KB(Region)/(2*1024)), SUGGESTED_INSTALL_PARTITION_SIZE_MB );

                    if( SpPtnDoCreate( Region,
                                       &p,
                                       TRUE,
                                       MyPartitionSizeMB,
                                       NULL,
                                       FALSE ) ) {

                        KdPrintEx(( DPFLTR_SETUP_ID,
                                    DPFLTR_INFO_LEVEL,  
                                    "SETUP: SpPtnAutoCreatePartitions - I just created an installation partition.\n" ));

                        //
                        // Got it.
                        //
                        Found = TRUE;
                        Region = p;

                        //
                        // Now format it.
                        //
                        swprintf( RegionStr,
                                  L"\\Harddisk%u\\Partition%u",
                                  Region->DiskNumber,
                                  Region->PartitionNumber );

                        //
                        // Format the system region with NTFS file system
                        //
                        KdPrintEx(( DPFLTR_SETUP_ID,
                                    DPFLTR_INFO_LEVEL,  
                                    "SETUP: SpPtnAutoCreatePartitions - I'm about to go format the installation partition.\n" ));

                        FormatStatus = SpDoFormat( RegionStr,
                                                   Region,
                                                   FilesystemNtfs,
                                                   TRUE,
                                                   TRUE,
                                                   FALSE,
                                                   SifHandle,
                                                   0,          // default cluster size
                                                   SetupSourceDevicePath,
                                                   DirectoryOnSetupSource );



                        KdPrintEx(( DPFLTR_SETUP_ID,
                                    DPFLTR_INFO_LEVEL,  
                                    "SETUP: SpPtnAutoCreatePartitions - Format of an installation partition is complete.\n" ));


                    } else {
                        KdPrintEx(( DPFLTR_SETUP_ID,
                                    DPFLTR_INFO_LEVEL,  
                                    "SETUP: SpPtnAutoCreatePartitions - I failed to create an installation partition.\n" ));
                    }
                }

                Region = Region->Next;
            }
        }

    } else {

        // let 'em know
        KdPrintEx(( DPFLTR_SETUP_ID,
                    DPFLTR_INFO_LEVEL,  
                    "SETUP: SpPtnAutoCreatePartitions - Existing partitions were found.\n" ));
    }

}



NTSTATUS
SpPtnPrepareDisks(
    IN  PVOID         SifHandle,
    OUT PDISK_REGION  *InstallArea,
    OUT PDISK_REGION  *SystemPartitionArea,
    IN  PWSTR         SetupSourceDevicePath,
    IN  PWSTR         DirectoryOnSetupSource,
    IN  BOOLEAN       RemoteBootRepartition
    )
/*++

Routine Description:

    Shows the use the disk menu (with partitions) and locates
    the system and boot partition

Arguments:

    SifHandle               :  Handle to txtsetup.sif

    InstallArea             :  Place holder for boot partition

    SystemPartitionArea     :  Place holder for system partition

    SetupSourceDevicePath   :  Device from which setup was launced

    DirectoryOnSetupSource  :  Directory from where the kernel was loaded on
                               Setup device

    RemoteBootRePartition   :  Whether to repartition the disk for remote boot

Return Value:

    Appropriate status code

--*/
{
    NTSTATUS        Status = STATUS_SUCCESS;
    WCHAR           Buffer[256] = {0};
    ULONG           DiskNumber;
    PVOID           Menu;
    ULONG           MenuTopY;
    ULONG           ValidKeys[3] = { ASCI_CR, KEY_F3, 0 };
    ULONG           ValidKeysCmdCons[2] = { ASCI_ESC, 0 };
    ULONG           Keypress;
    PDISK_REGION    pDiskRegion;
    PDISK_REGION    FirstDiskRegion,DefaultDiskRegion;
    BOOLEAN         unattended = UnattendedOperation;
    BOOLEAN         OldUnattendedOperation;
    BOOLEAN         createdMenu;
    ULONG           LastUsedDisk = -1;
    BOOLEAN         Win9xPartition = FALSE;

    //
    // Do some special partitioning if there's nothing
    // on the disk and the user has asked us to do an express
    // installation.
    //
    if( (!CustomSetup) && (UnattendedOperation) && (HardDiskCount != 0)
#if defined(REMOTE_BOOT)
        && (!RemoteBootSetup) && (!RemoteInstallSetup)
#endif

     ) {

        //
        // See if we need to auto-generate some partitions for the
        // installation.
        //
        SpPtnAutoCreatePartitions( SifHandle,
                                   SetupSourceDevicePath,
                                   DirectoryOnSetupSource );

    }

    if (SpIsArc()) {
        //
        // Select a system partition from among those defined in NV-RAM.
        //
        *SystemPartitionArea = SpPtnValidSystemPartitionArc(SifHandle,
                                    SetupSourceDevicePath,
                                    DirectoryOnSetupSource, 
                                    FALSE);

        if (*SystemPartitionArea) {                                    
            (*SystemPartitionArea)->IsSystemPartition = TRUE;
        }            
    }

    //
    // If the user selected any accessibility option and wanted to choose partition, show the partition screen
    //
    if(AccessibleSetup && !AutoPartitionPicker) {
        unattended = FALSE;
    }

    //
    // Save the current unattended mode and put the temp one
    //
    OldUnattendedOperation = UnattendedOperation;
    UnattendedOperation = unattended;

    while(1) {

        createdMenu = FALSE;
        Keypress = 0;

#if defined(REMOTE_BOOT)
        if (RemoteBootSetup && !RemoteInstallSetup && HardDiskCount == 0) {

            //
            // If there are no hard disks, allow diskless install
            //

            pDiskRegion = NULL;

            //
            // Run through the rest of the code as if the user had just
            // hit enter to select this partition.
            //

            Keypress = ASCI_CR;

        } else
#endif // defined(REMOTE_BOOT)

        if (unattended && RemoteBootRepartition) {
            ULONG   DiskNumber;
            ULONG   DiskSpaceRequiredKB = 2 * 1024 * 1024;  // 2 GB

            //
            // What's the space we required for installation
            //
            SpFetchDiskSpaceRequirements(SifHandle,
                        4 * 1024,
                        &DiskSpaceRequiredKB,
                        NULL);

            //
            // Prepare the disk for remote boot installation. This involves
            // converting disk 0 into as big a partition as possible.
            //

            if (*SystemPartitionArea != NULL) {
                DiskNumber = (*SystemPartitionArea)->DiskNumber;
            } else {
                DiskNumber = SpDetermineDisk0();
            }

#ifdef _IA64_

            Status = SpPtnRepartitionGPTDisk(DiskNumber,
                            DiskSpaceRequiredKB,
                            &pDiskRegion);

#else                            

            Status = SpPtPartitionDiskForRemoteBoot(DiskNumber, 
                            &pDiskRegion);

#endif                            


            if (NT_SUCCESS(Status)) {

                SpPtRegionDescription(
                    &PartitionedDisks[pDiskRegion->DiskNumber],
                    pDiskRegion,
                    Buffer,
                    sizeof(Buffer)
                    );

                //
                // Run through the rest of the code as if the user had just
                // hit enter to select this partition.
                //
                Keypress = ASCI_CR;
            }
        }

        if (Keypress == 0) {

            //
            // Display the text that goes above the menu on the partitioning screen.
            //
            SpDisplayScreen(ConsoleRunning ? SP_SCRN_PARTITION_CMDCONS:SP_SCRN_PARTITION,
                    3,CLIENT_TOP+1);

            //
            // Calculate menu placement.  Leave one blank line
            // and one line for a frame.
            //
            MenuTopY = NextMessageTopLine + 2;

            //
            // Create a menu.
            //
            Menu = SpMnCreate(
                        MENU_LEFT_X,
                        MenuTopY,
                        MENU_WIDTH,
                        (VideoVars.ScreenHeight - MenuTopY -
                            (SplangQueryMinimizeExtraSpacing() ? 1 : 2) - STATUS_HEIGHT)
                        );

            if(!Menu) {
                UnattendedOperation = OldUnattendedOperation;
                return(STATUS_NO_MEMORY);
            }

            createdMenu = TRUE;

            //
            // Build up a menu of partitions and free spaces.
            //
            FirstDiskRegion = NULL;
            
            for(DiskNumber=0; DiskNumber<HardDiskCount; DiskNumber++) {
                if( !SpPtnGenerateDiskMenu(Menu, DiskNumber, &FirstDiskRegion) ) {
                    SpMnDestroy(Menu);

                    UnattendedOperation = OldUnattendedOperation;
                    return(STATUS_NO_MEMORY);
                }
            }

            ASSERT(FirstDiskRegion);

            //
            // If this is unattended operation, try to use the local source
            // region if there is one. If this fails, the user will have to
            // intervene manually.
            //
            if(!AutoPartitionPicker && unattended && LocalSourceRegion && CustomSetup &&
               (!LocalSourceRegion->DynamicVolume || LocalSourceRegion->DynamicVolumeSuitableForOS)) {
               
                pDiskRegion = LocalSourceRegion;

                Keypress = ASCI_CR;
                
            } else {            
                pDiskRegion = NULL;

                //
                // Unless we've been told not to, go look at each partition on each
                // disk and see if we can find anything suitable for an OS installation.
                //
                if( AutoPartitionPicker && !ConsoleRunning 
#if defined(REMOTE_BOOT)
                    && (!RemoteBootSetup || RemoteInstallSetup)
#endif // defined(REMOTE_BOOT)
                    ) {
                    
                    PDISK_REGION      pCurrentDiskRegion = NULL;
                    ULONG           RequiredKB = 0;
                    ULONG           SectorNo;

                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                        "SETUP: -------------------------------------------------------------\n" ));
                        
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                        "SETUP: Looking for an install partition\n\n" ));

                    for( DiskNumber=0; 
                        ((DiskNumber < HardDiskCount) && (!pCurrentDiskRegion)); 
                        DiskNumber++ ) {
                    
                        pCurrentDiskRegion = PartitionedDisks[DiskNumber].PrimaryDiskRegions;

                        while( pCurrentDiskRegion ) {
                            //
                            // Fetch the amount of free space required on the windows nt drive.
                            //
                            SpFetchDiskSpaceRequirements( SifHandle,
                                                          pCurrentDiskRegion->BytesPerCluster,
                                                          &RequiredKB,
                                                          NULL );

                            if( SpPtDeterminePartitionGood(pCurrentDiskRegion, RequiredKB, TRUE) ) {
                                //
                                // Got it.  Remember the partition and pretend the user
                                // hit the <enter> key.
                                //
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                                    "SETUP: Selected install partition = "
                                    "(DiskNumber:%d),(DriveLetter:%wc:),(%ws)\n",
                                    DiskNumber,pCurrentDiskRegion->DriveLetter,
                                    pCurrentDiskRegion->VolumeLabel));
                                    
                                pDiskRegion = pCurrentDiskRegion;
                                Keypress = ASCI_CR;
                                
                                break;
                            }

                            pCurrentDiskRegion = pCurrentDiskRegion->Next;
                        }
                    }
                    
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                        "SETUP: -------------------------------------------------------------\n" ));
                }


                if( !pDiskRegion ) {
                    //
                    // We didn't find any suitable partitions, which means we'll be putting up a
                    // menu very quickly.  Initialize the partition to highlight in the
                    // menu.
                    //
                    if (LastUsedDisk == -1) {
                        DefaultDiskRegion = FirstDiskRegion;
                    } else {
                        //
                        // Select the first region on the disk which the user last
                        // operated on
                        //
                        PDISK_REGION ValidRegion = SPPT_GET_PRIMARY_DISK_REGION(LastUsedDisk);

                        while (ValidRegion && SPPT_IS_REGION_CONTAINER_PARTITION(ValidRegion)) {
                            ValidRegion = ValidRegion->Next;
                        }                 

                        if (!ValidRegion)
                            ValidRegion = FirstDiskRegion;

                        DefaultDiskRegion = ValidRegion;
                    }                                                                                    

                    //
                    // Call the menu callback to initialize the status line.
                    //
                    SpPtMenuCallback( (ULONG_PTR)DefaultDiskRegion );                    

                    SpMnDisplay( Menu,
                                 (ULONG_PTR)DefaultDiskRegion,
                                 TRUE,
                                 ConsoleRunning ? ValidKeysCmdCons : ValidKeys,
                                 PartitionMnemonics,
                                 SpPtMenuCallback,
                                 SpPtIsNotReservedPartition,
                                 &Keypress,
                                 (PULONG_PTR)(&pDiskRegion) );
                }
            }
        }            

        LastUsedDisk = pDiskRegion ? pDiskRegion->DiskNumber : -1;

        //
        // Now act on the user's selection.
        //
        if(Keypress & KEY_MNEMONIC) {
            Keypress &= ~KEY_MNEMONIC;
        }



        //
        // Disallow certain operations on partitions that contain local source
        // or are the system partition (in the amd64/x86 floppiless case).
        //
        switch(Keypress) {
            case MnemonicCreatePartition:
            case MnemonicMakeSystemPartition:
            case MnemonicDeletePartition:
            case MnemonicChangeDiskStyle:
            if( (pDiskRegion->IsLocalSource) ||
                ((Keypress == MnemonicDeletePartition) && 
                 (SpPtnIsDeleteAllowedForRegion(pDiskRegion) == FALSE))
#if defined(_AMD64_) || defined(_X86_)
                || (IsFloppylessBoot &&
                    pDiskRegion == (SpRegionFromArcName(ArcBootDevicePath, PartitionOrdinalOriginal, NULL)))
#endif // defined(_AMD64_) || defined(_X86_)
              ) {

                //
                // Inform the user that we can't do this operation on this
                // partition.
                //
                ULONG MyValidKeys[] = { ASCI_CR };
                SpDisplayScreen(SP_SCRN_CONFIRM_INABILITY,3,HEADER_HEIGHT+1);

                SpDisplayStatusOptions(
                    DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_ENTER_EQUALS_CONTINUE,
                    0
                    );

                SpInputDrain();
                SpWaitValidKey(MyValidKeys,NULL,NULL);

                //
                // Now change the keypress so we'll fall through the next switch.
                //
                Keypress = MnemonicUnused;
            }
        }



        switch(Keypress) {

        case MnemonicCreatePartition:            
            SpPtnDoCreate(pDiskRegion, NULL, FALSE, 0, 0, TRUE);
            
            break;

        case MnemonicMakeSystemPartition: {
            //
            // Make sure we don't have any other system partition
            //
            if (SPPT_IS_REGION_SYSTEMPARTITION(pDiskRegion)) {
                ValidArcSystemPartition = TRUE;
            }
            
            if (!ValidArcSystemPartition && pDiskRegion->PartitionedSpace && SpIsArc() && 
                (pDiskRegion->Filesystem != FilesystemNtfs)) {            

                if (NT_SUCCESS(SpPtnMakeRegionArcSysPart(pDiskRegion))) {
                     PDISK_REGION SysPartRegion = NULL;
                        
                    //
                    // Ok format the partition if required
                    //
                    SysPartRegion = SpPtnValidSystemPartitionArc(SifHandle,
                                                                 SetupSourceDevicePath,
                                                                 DirectoryOnSetupSource,
                                                                 FALSE);                

                    if (SysPartRegion) {
                        ULONG SysPartDiskNumber = SysPartRegion->DiskNumber;                            
                        BOOLEAN Changes = FALSE;

                        if ((NT_SUCCESS(SpPtnCommitChanges(SysPartDiskNumber,
                                                &Changes))) &&
                           (NT_SUCCESS(SpPtnInitializeDiskDrive(SysPartDiskNumber)))) {
                            //
                            // create MSR partition if needed
                            //
                            SpPtnInitializeGPTDisk(SysPartDiskNumber);
                        }                                                
                    }

                } else {
                    ValidArcSystemPartition = FALSE;
                }                    
            }

            break;
        }            

        case MnemonicDeletePartition:   {
            BOOLEAN SysPartDeleted = FALSE;
            BOOLEAN DeletionResult;
        
            SysPartDeleted = SPPT_IS_REGION_SYSTEMPARTITION(pDiskRegion);            
        
            DeletionResult = SpPtnDoDelete(pDiskRegion, 
                                SpMnGetText(Menu,(ULONG_PTR)pDiskRegion),
                                TRUE);

            if (DeletionResult && SysPartDeleted && SpIsArc()) {
                //
                // Find out if there are any other
                // valid system partitions
                //
                SpPtnValidSystemPartitionArc(SifHandle,
                                SetupSourceDevicePath,
                                DirectoryOnSetupSource,
                                FALSE);
            }
                                     
            break;
        }            

        case MnemonicChangeDiskStyle: {
            //
            // Before changing style make sure, its allowed
            // on this platform for the selected disk
            //
            if (SpPtnIsDiskStyleChangeAllowed(pDiskRegion->DiskNumber)) {
                PARTITION_STYLE Style = SPPT_DEFAULT_PARTITION_STYLE;
            
                SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, 
                        SP_STAT_PLEASE_WAIT,
                        0);
                                    
                //
                // flip the style
                //
                if (!SPPT_IS_RAW_DISK(pDiskRegion->DiskNumber)) {
                    Style = SPPT_IS_GPT_DISK(pDiskRegion->DiskNumber) ?
                                PARTITION_STYLE_MBR : PARTITION_STYLE_GPT;
                }                            
                                
                Status = SpPtnInitializeDiskStyle(pDiskRegion->DiskNumber,
                                    Style, NULL);


                if (NT_SUCCESS(Status)) {
                    Status = SpPtnInitializeDiskDrive(pDiskRegion->DiskNumber);

#if defined(_IA64_)
                    //
                    // Go and figure out the ESP partitions and
                    // initialize the MSR partitions on valid GPT
                    // disks, if none present
                    //
                    if (Style == PARTITION_STYLE_GPT) {    
                        ULONG DiskNumber = pDiskRegion->DiskNumber;
                        
                        if (SpIsArc() && !ValidArcSystemPartition && !SpDrEnabled()) {                            
                            
                            //
                            // Create a system partition
                            //
                            Status = SpPtnCreateESP(TRUE);                    
                        }

                        //
                        // Initialize the GPT disks, to have MSR
                        // partition
                        //
                        Status = SpPtnInitializeGPTDisk(DiskNumber);                        
                    }                        
#endif                                        
                }
            }
            
            break;
        }            

        case KEY_F3:
            SpConfirmExit();
            break;

        case ASCI_ESC:
            if( ConsoleRunning ) {
                SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, 
                        SP_STAT_PLEASE_WAIT,
                        0);
            
                SpPtDoCommitChanges();
            }
            if (createdMenu) {
                SpMnDestroy(Menu);
            }
            UnattendedOperation = OldUnattendedOperation;
            return(STATUS_SUCCESS);

        case ASCI_CR:

            Win9xPartition = FALSE;

            if( SpPtDoPartitionSelection( &pDiskRegion,
                                          ((Buffer[0]) ? Buffer : SpMnGetText(Menu,(ULONG_PTR)pDiskRegion)),
                                          SifHandle,
                                          unattended,
                                          SetupSourceDevicePath,
                                          DirectoryOnSetupSource,
                                          RemoteBootRepartition,
                                          &Win9xPartition) ) {

                *InstallArea = pDiskRegion;
#if defined(REMOTE_BOOT)
                //
                // Set the install region differently if this is a remote
                // boot -- in that case, the install region is always remote.
                //
                if (RemoteBootSetup && !RemoteInstallSetup) {
                    *InstallArea = RemoteBootTargetRegion;
                }
#endif // defined(REMOTE_BOOT)

                //
                // We need to figure out where the system partition is.
                //
                if (!SpIsArc()) {
                    *SystemPartitionArea = SpPtnValidSystemPartition();
                } else {

                    PWSTR p;
                    NTSTATUS TempStatus;
                    
                    //
                    // Select a system partition from among those defined in NV-RAM.
                    // We have to do this again because the user may have deleted the
                    // system partition previously detected.
                    //
                    *SystemPartitionArea = SpPtnValidSystemPartitionArc(SifHandle,
                                                            SetupSourceDevicePath,
                                                            DirectoryOnSetupSource,
                                                            FALSE);

                    if (!(*SystemPartitionArea)) {                    
                        SpPtnPromptForSysPart(SifHandle);

                        break;  // user pressed escape to mark the system partition                            
                    }

                    //
                    // Make sure we can see the disk from the firmware/BIOS.
                    // If not then we need to put up a message asking to enable the
                    // ROM BIOS for the disabled disk containing the system partition
                    //					 
                    p = SpNtToArc( HardDisks[(*SystemPartitionArea)->DiskNumber].DevicePath,
                          PrimaryArcPath );            
                    if (p == NULL) {

                    	ULONG ValidKeys[] = { KEY_F3, ASCI_ESC,  0 };

                    	KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                               "SETUP: Enable the ROM BIOS for the Disk containing system partition\n" ));
                    	SpDisplayScreen(SP_ENABLE_ESP_DISK_IN_FIRMWARE, 3, HEADER_HEIGHT+1);
                    	SpDisplayStatusOptions(
                           DEFAULT_STATUS_ATTRIBUTE,
                           SP_STAT_F3_EQUALS_EXIT,
                           0);

                        //
                        // Wait for user input
                        //
                         SpInputDrain();
                    
                         switch (SpWaitValidKey(ValidKeys, NULL, NULL)){
				
                        	case KEY_F3 :
                         			
                         		// User has chosen to reboot
                         		SpDone(0,FALSE,FALSE);

	                       	case ASCI_ESC:
	                       		
                         		// User wants to go to the partitioning screen
                         		break;
                         }
                         break;
    			        
        			}

                    //
                    // Disallow installation onto ESP / MSR
                    //
                    if (SPPT_IS_REGION_EFI_SYSTEM_PARTITION(*InstallArea) ||
                        SPPT_IS_REGION_MSFT_RESERVED(*InstallArea)) {
                        ULONG ValidKeys[] = { ASCI_CR, 0 };

                        SpDisplayScreen(SP_ESP_INSTALL_PARTITION_SAME, 3, HEADER_HEIGHT+1);

                        SpDisplayStatusOptions(
                            DEFAULT_STATUS_ATTRIBUTE,
                            SP_STAT_ENTER_EQUALS_CONTINUE,
                            0);

                        //
                        // Wait for user input
                        //
                        SpInputDrain();
                        
                        SpWaitValidKey(ValidKeys, NULL, NULL);

                        break;
                    }

                    //
                    // Disallow non GPT ESPs
                    //
                    if (SpIsArc() && !SPPT_IS_GPT_DISK((*SystemPartitionArea)->DiskNumber)) {
                        ULONG ValidKeys[] = { ASCI_CR, 0 };

                        SpDisplayScreen(SP_NON_GPT_SYSTEM_PARTITION, 3, HEADER_HEIGHT+1);

                        SpDisplayStatusOptions(
                            DEFAULT_STATUS_ATTRIBUTE,
                            SP_STAT_ENTER_EQUALS_CONTINUE,
                            0);

                        //
                        // Wait for user input
                        //
                        SpInputDrain();
                        
                        SpWaitValidKey(ValidKeys, NULL, NULL);

                        break;
                    } 
                    
                    //
                    // Disallow installation if MSR does not exist on the disk containing the ESP.
                    //
                    TempStatus = SpPtnInitializeGPTDisk((*SystemPartitionArea)->DiskNumber);
                    if (NT_SUCCESS(TempStatus) && 
                        (!SpIsMSRPresentOnDisk((*SystemPartitionArea)->DiskNumber))){
                        ULONG ValidKeys[] = { ASCI_CR, 0 };

                        SpDisplayScreen(SP_MSR_NOT_PRESENT, 3, HEADER_HEIGHT+1);

                        SpDisplayStatusOptions(
                            DEFAULT_STATUS_ATTRIBUTE,
                            SP_STAT_ENTER_EQUALS_CONTINUE,
                            0);

                        //
                        // Wait for user input
                        //
                        SpInputDrain();
                        
                        SpWaitValidKey(ValidKeys, NULL, NULL);

                        break;
                    }
                    
                }

                //
                // We're done here.
                //
                if (createdMenu) {
                    SpMnDestroy(Menu);
                }                

#if defined(REMOTE_BOOT)
                ASSERT(*SystemPartitionArea ||
                       (RemoteBootSetup && !RemoteInstallSetup && (HardDiskCount == 0)));
#else
                ASSERT(*SystemPartitionArea);
                ASSERT((*SystemPartitionArea)->Filesystem >= FilesystemFat);
#endif // defined(REMOTE_BOOT)


#ifdef _X86_
                //
                // If we are installing on to the same partition as Win9x then
                // remove the boot entry for the old operating system
                //
                if (Win9xPartition) {
                    DiscardOldSystemLine = TRUE;
                }
#endif                

                UnattendedOperation = OldUnattendedOperation;
                return(STATUS_SUCCESS);

            } else {
                //
                // Something happened when we tried to select the
                // partition.  Make sure that autopartition-picker
                // doesn't invoke next time through our while loop.
                //
                AutoPartitionPicker = FALSE;
            }
            break;
        }

        if (createdMenu) {
            SpMnDestroy(Menu);
        }
        unattended = FALSE;
    }
}


BOOLEAN
SpPtnGenerateDiskMenu(
    IN  PVOID           Menu,
    IN  ULONG           DiskNumber,
    OUT PDISK_REGION    *FirstDiskRegion
    )
/*++

Routine Description:

    Examine the disk for partitioning information and fill in our
    menu.


Arguments:

    DiskNumber - supplies the disk number of the disk whose partitions
                 we want to inspect for determining their types.

Return Value:

    TRUE    Everything went okay.
    FALSE   Something horrible happened.

--*/
{
    WCHAR           Buffer[128];
    ULONG           MessageId;
    PDISK_REGION    Region = NULL;
    WCHAR           DriveLetter[3];
    WCHAR           PartitionName[128];
    ULONGLONG       FreeSpaceMB;
    ULONGLONG       AreaSizeMB;
    ULONGLONG       AreaSizeBytes;
    ULONGLONG       OneMB = 1024 * 1024;
    PHARD_DISK      Disk = SPPT_GET_HARDDISK(DiskNumber);
    PPARTITIONED_DISK   PartDisk = SPPT_GET_PARTITIONED_DISK(DiskNumber);

    //
    // Get a pointer to the list of regions.
    //
    Region = PartDisk->PrimaryDiskRegions;

    //
    // Add the disk name/description.
    //
    if(!SpMnAddItem(Menu, Disk->Description, MENU_LEFT_X, MENU_WIDTH, FALSE, 0)) {
        return(FALSE);
    }

    //
    // Only add a line between the disk name and partitions if we have space on
    // the screen. Not fatal if the space can't be added.
    //
    if(!SplangQueryMinimizeExtraSpacing()) {
        SpMnAddItem(Menu,L"",MENU_LEFT_X,MENU_WIDTH,FALSE,0);
    }

    //
    // If the disk is off-line, add a message indicating such.
    //    
    if((Disk->Status == DiskOffLine) || !Region) {
        MessageId = SP_TEXT_DISK_OFF_LINE;

        if( Disk->Characteristics & FILE_REMOVABLE_MEDIA ) {
            //
            // This is removable media, then just tell the user there's
            // no media in the drive.
            //
            MessageId = SP_TEXT_HARD_DISK_NO_MEDIA;
        }

        SpFormatMessage( Buffer,
                         sizeof(Buffer),
                         MessageId );

        return SpMnAddItem(Menu,
                            Buffer,
                            MENU_LEFT_X + MENU_INDENT,
                            MENU_WIDTH - (2 * MENU_INDENT),
                            FALSE,
                            0);
    }

    //
    // Now iterate through the areas on the disk and insert that info into the
    // menu.
    //
    while( Region ) {
        if (!SPPT_IS_REGION_CONTAINER_PARTITION(Region)) {            
            //
            // remember the very first area that we examine.
            //
            if(*FirstDiskRegion == NULL) {
                *FirstDiskRegion = Region;
            }

            //
            // Figure out how big this disk area is and how much
            // free space we've got.
            //
            if (Region->AdjustedFreeSpaceKB != -1) {
                FreeSpaceMB = Region->AdjustedFreeSpaceKB / 1024;
            } else {
                FreeSpaceMB = 0;
            }
            
            AreaSizeBytes = Region->SectorCount * Disk->Geometry.BytesPerSector;
            AreaSizeMB    = AreaSizeBytes / OneMB;

            if ((AreaSizeBytes % OneMB) > (OneMB / 2))
                AreaSizeMB++;

            /*
            SpPtDumpDiskRegion(Region);
            
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                "SETUP: Menu Item Details Free:%I64d,%I64d,%I64d\n",
                FreeSpaceMB, AreaSizeBytes, AreaSizeMB));
            */                
            
            //
            // See if this guy's partitioned.
            //
            if(SPPT_IS_REGION_PARTITIONED(Region)){                
                //
                // Pickup the driveletter
                //
                if( Region->DriveLetter ) {
                    DriveLetter[0] = Region->DriveLetter;
                } else {
                    DriveLetter[0] = L'-';
                }

                DriveLetter[1] = L':';
                DriveLetter[2] = 0;

                //
                // Format the partition name
                //
                PartitionName[0] = 0;
                
                SpPtnGetPartitionName(Region,
                    PartitionName,
                    sizeof(PartitionName)/sizeof(PartitionName[0]));

                SpFormatMessage( Buffer,
                                 sizeof( Buffer ),
                                 SP_TEXT_REGION_DESCR_1,
                                 DriveLetter,
                                 SplangPadString(-35, PartitionName),
                                 (ULONG)AreaSizeMB,
                                 (ULONG)FreeSpaceMB );                             
            } else {
                //
                // It's an unformatted area.  Use a different message.
                //
                SpFormatMessage( Buffer,
                                 sizeof( Buffer ),
                                 SP_TEXT_REGION_DESCR_3,
                                 (ULONG)AreaSizeMB );
            }

            //
            // Add the formatted information into the menu.
            //
            if(!SpMnAddItem(Menu, Buffer, MENU_LEFT_X + MENU_INDENT,
                    MENU_WIDTH - (2 * MENU_INDENT), TRUE, (ULONG_PTR)Region)) {
                return(FALSE);
            }
        }            

        Region = Region->Next;
    }


    return (SplangQueryMinimizeExtraSpacing() ? 
                TRUE : SpMnAddItem(Menu,L"",MENU_LEFT_X,MENU_WIDTH,FALSE,0));
}


PDISK_REGION
SpPtnValidSystemPartition(
    VOID
    )

/*++

Routine Description:

    Determine whether there is a valid disk partition suitable for use
    as the system partition on an amd64/x86 machine (ie, C:).

    A primary, recognized (1/4/6/7 type) partition on disk 0 is suitable.
    If there is a partition that meets these criteria that is marked active,
    then it is the system partition, regardless of whether there are other
    partitions that also meet the criteria.

Arguments:

    None.

Return Value:

    Pointer to a disk region descriptor for a suitable system partition (C:)
    for an amd64/x86 machine.
    NULL if no such partition currently exists.

--*/

{
    PDISK_REGION ActiveRegion , FirstRegion, CurrRegion;
    PHARD_DISK  Disk = NULL;
    ULONG DiskNumber;

    DiskNumber = SpDetermineDisk0();

#if defined(REMOTE_BOOT)
    //
    // If this is a diskless remote boot setup, there is no drive 0.
    //
    if ( DiskNumber == (ULONG)-1 ) {
        return NULL;
    }
#endif // defined(REMOTE_BOOT)

    if (!PartitionedDisks) {
        return NULL;
    }        

    //
    // Look for the active partition on drive 0
    // and for the first recognized primary partition on drive 0.
    //       
    CurrRegion = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);
    FirstRegion = NULL;
    ActiveRegion = NULL;

    while (CurrRegion) {
        if (SPPT_IS_REGION_PRIMARY_PARTITION(CurrRegion)) {
            UCHAR PartitionType = SPPT_GET_PARTITION_TYPE(CurrRegion);
            
            if(!IsContainerPartition(PartitionType) && 
                ((IsRecognizedPartition(PartitionType)) ||
                (CurrRegion->DynamicVolume && CurrRegion->DynamicVolumeSuitableForOS) ||
                ((RepairWinnt || WinntSetup || SpDrEnabled() ) && CurrRegion->FtPartition))) {

                if (!FirstRegion)
                    FirstRegion = CurrRegion;
                    
                if (!ActiveRegion && SPPT_IS_REGION_ACTIVE_PARTITION(CurrRegion)) {
                    ActiveRegion = CurrRegion;

                    break;
                }                    
            }
        }            
        
        CurrRegion = CurrRegion->Next;
    }

#ifdef TESTING_SYSTEM_PARTITION
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
        "%p Active, %p First\n", 
        ActiveRegion, 
        FirstRegion));
    
    if (ActiveRegion)
        FirstRegion = ActiveRegion;
        
    ActiveRegion = NULL;
#endif

    /*
    //
    // Don't do commit here as the multiple caller's are trying
    // to reuse the old region from the existing linked list
    // of regions for the disk after this
    //
    if (!ActiveRegion && FirstRegion) {
        BOOLEAN     Changes = FALSE;
        ULONGLONG   StartSector = FirstRegion->StartSector;

        SpPtnMakeRegionActive(FirstRegion);
        SPPT_MARK_REGION_AS_SYSTEMPARTITION(FirstRegion, TRUE);

        if (NT_SUCCESS(SpPtnCommitChanges(DiskNumber, &Changes)) && Changes) {
            SPPT_MARK_REGION_AS_ACTIVE(FirstRegion, TRUE);
            
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                "SETUP:SpPtnValidSystempartition():succeeded in marking\n"));
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                "SETUP:SpPtnValidSystempartition():Could not mark the first "
                "partition on primary disk as active\n"));
        }
    }
    */

    //
    // If there is an active, recognized region, use it as the
    // system partition.  Otherwise, use the first primary
    // we encountered as the system partition.  If there is
    // no recognized primary, then there is no valid system partition.
    //
    return  (ActiveRegion ? ActiveRegion : FirstRegion);
}

#if 0

ULONG
SpDetermineDisk0(
    VOID
    )

/*++

Routine Description:

    Determine the real disk 0, which may not be the same as \device\harddisk0.
    Consider the case where we have 2 scsi adapters and
    the NT drivers load in an order such that the one with the BIOS
    gets loaded *second* -- meaning that the system partition is actually
    on disk 1, not disk 0.

Arguments:

    None.

Return Value:

    NT disk ordinal suitable for use in generating nt device paths
    of the form \device\harddiskx.

--*/


{
    ULONG DiskNumber = SpArcDevicePathToDiskNumber(L"multi(0)disk(0)rdisk(0)");

#if defined(REMOTE_BOOT)
    //
    // If this is a diskless remote boot setup, there is no drive 0.
    //
    if ( RemoteBootSetup && (DiskNumber == (ULONG)-1) && (HardDiskCount == 0) ) {
        return DiskNumber;
    }
#endif // defined(REMOTE_BOOT)

    return((DiskNumber == (ULONG)(-1)) ? 0 : DiskNumber);
}

#endif

BOOL
SpPtnIsSystemPartitionRecognizable(
    VOID
    )
/*++

Routine Description:

    Determine whether the active partition is suitable for use
    as the system partition on an amd64/x86 machine (ie, C:).

    A primary, recognized (1/4/6/7 type) partition on disk 0 is suitable.

Arguments:

    None.

Return Value:

    TRUE - We found a suitable partition

    FALSE - We didn't find a suitable partition

--*/
{
    ULONG           DiskNumber;
    PDISK_REGION    Region = NULL;

    //
    // Any partitions on NEC98 are primary and active. So don't need to check on NEC98.
    //
    if( IsNEC_98 ) {
    	return TRUE;
    }

    DiskNumber = SpDetermineDisk0();

    //
    // Look for the active partition on drive 0
    // and for the first recognized primary partition on drive 0.
    //
    Region = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);

    if (SPPT_IS_GPT_DISK(DiskNumber)) {        
        //
        // On GPT we just need a valid formatted partition
        //
        while (Region) {    
            if (SPPT_IS_REGION_PARTITIONED(Region) &&
                SPPT_IS_RECOGNIZED_FILESYSTEM(Region->Filesystem)) {

                break;
            }                

            Region = Region->Next;
        }
    } else {
        //
        // On MBR we need a valid active formatted partition
        //
        while (Region) {    
            if (SPPT_IS_REGION_ACTIVE_PARTITION(Region) &&
                SPPT_IS_RECOGNIZED_FILESYSTEM(Region->Filesystem)) {

                break;
            }                

            Region = Region->Next;
        }
    }                
    
    return (Region) ? TRUE : FALSE;
}


BOOLEAN
SpPtnValidSystemPartitionArcRegion(
    IN PVOID SifHandle,
    IN PDISK_REGION Region
    )
{
    BOOLEAN Valid = FALSE;
    
    if (SPPT_IS_REGION_SYSTEMPARTITION(Region) &&
        (Region->FreeSpaceKB != -1) &&
        (Region->Filesystem == FilesystemFat)) {

        ULONG TotalSizeOfFilesOnOsWinnt = 0;
        ULONG RequiredSpaceKB = 0;  

        //
        //  On non-x86 platformrs, specially alpha machines that in general
        //  have small system partitions (~3 MB), we should compute the size
        //  of the files on \os\winnt (currently, osloader.exe and hall.dll),
        //  and consider this size as available disk space. We can do this
        //  since these files will be overwritten by the new ones.
        //  This fixes the problem that we see on Alpha, when the system
        //  partition is too full.
        //

        SpFindSizeOfFilesInOsWinnt( SifHandle,
                                    Region,
                                    &TotalSizeOfFilesOnOsWinnt );
        //
        // Transform the size into KB
        //
        TotalSizeOfFilesOnOsWinnt /= 1024;

        //
        // Determine the amount of free space required on a system partition.
        //
        SpFetchDiskSpaceRequirements( SifHandle,
                                      Region->BytesPerCluster,
                                      NULL,
                                      &RequiredSpaceKB );

        if ((Region->FreeSpaceKB + TotalSizeOfFilesOnOsWinnt) >= RequiredSpaceKB) {
            Valid = TRUE;
        }
    }

    return Valid;
}

PDISK_REGION
SpPtnValidSystemPartitionArc(
    IN PVOID SifHandle,
    IN PWSTR SetupSourceDevicePath,
    IN PWSTR DirectoryOnSetupSource,
    IN BOOLEAN SysPartNeeded
    )

/*++

Routine Description:

    Determine whether there is a valid disk partition suitable for use
    as the system partition on an ARC machine.

    A partition is suitable if it is marked as a system partition in nvram,
    has the required free space and is formatted with the FAT filesystem.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

Return Value:

    Pointer to a disk region descriptor for a suitable system partition.
    Does not return if no such partition exists.

--*/

{
    ULONG               RequiredSpaceKB = 0;
    PDISK_REGION        Region = NULL;
    PPARTITIONED_DISK   PartDisk;
    ULONG               Index;

    //
    // Go through all the regions.  The one that's maked system partition
    // or is valid system partition is used for further validation.
    //
    for(Index = 0; (Index < HardDiskCount) && (!Region); Index++) {
        PartDisk = SPPT_GET_PARTITIONED_DISK(Index);
        Region = SPPT_GET_PRIMARY_DISK_REGION(Index);

        while (Region) {
            if (SPPT_IS_REGION_PARTITIONED(Region) && 
                SPPT_IS_REGION_SYSTEMPARTITION(Region)) {
                break;  // found the required region                 
            }
            
            Region = Region->Next;
        }
    }

    //
    // If the region is there and not formatted format it as FAT
    // file system
    //
    if (Region && (Region->Filesystem < FilesystemFat)) {
        WCHAR       DriveLetterString[4] = {0};

        DriveLetterString[0] = Region->DriveLetter;
        
        if (!UnattendedOperation) {
            ULONG   ValidKeys[] = { KEY_F3, 0 };
            ULONG   Mnemonics[] = { MnemonicFormat, 0 };
            ULONG   KeyPressed;
            ULONG   EscKey = SysPartNeeded ? KEY_F3 : ASCI_ESC;

            ValidKeys[0] = SysPartNeeded ? KEY_F3 : ASCI_ESC;

            SpStartScreen(SysPartNeeded ? 
                            SP_SCRN_C_UNKNOWN_1 : SP_SCRN_C_UNKNOWN,
                          3,
                          HEADER_HEIGHT+1,
                          FALSE,
                          FALSE,
                          DEFAULT_ATTRIBUTE,
                          DriveLetterString
                          );       

            SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, 
                    SP_STAT_F_EQUALS_FORMAT,
                    SysPartNeeded ? 
                        SP_STAT_F3_EQUALS_EXIT : SP_STAT_ESC_EQUALS_CANCEL,
                    0);

            SpInputDrain();
                          
            KeyPressed = SpWaitValidKey(ValidKeys, NULL, Mnemonics);

            if (KeyPressed == EscKey) {
                Region = NULL;
            }                
        }

        if (Region) {
            WCHAR       RegionStr[128];
            NTSTATUS    FormatStatus;

            swprintf( RegionStr,
                      L"\\Harddisk%u\\Partition%u",
                      Region->DiskNumber,
                      Region->PartitionNumber );

            //
            // Format the system region with Fat file system
            //
            FormatStatus = SpDoFormat(RegionStr,
                                Region,
                                FilesystemFat,
                                TRUE,
                                TRUE,
                                FALSE,
                                SifHandle,
                                0,          // default cluster size
                                SetupSourceDevicePath,
                                DirectoryOnSetupSource);

            if (!NT_SUCCESS(FormatStatus)) {
                SpStartScreen(SP_SCRN_SYSPART_FORMAT_ERROR,
                              3,
                              HEADER_HEIGHT+1,
                              FALSE,
                              FALSE,
                              DEFAULT_ATTRIBUTE,
                              DriveLetterString
                              );
                              
                SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
                        SP_STAT_F3_EQUALS_EXIT,
                        0);
                        
                SpInputDrain();
                
                while(SpInputGetKeypress() != KEY_F3) ;
                
                SpDone(0, FALSE, TRUE);
            }

            //
            // Since we have formatted system partition, make sure
            // it has adequate space to hold the startup files
            //
            if(!SpPtnValidSystemPartitionArcRegion(SifHandle, Region))
                Region = NULL;  
        }                
    }              
    
    if (!Region && SysPartNeeded) {
        //
        // Make sure we don't look bad.
        //
        if( RequiredSpaceKB == 0 ) {
            SpFetchDiskSpaceRequirements( SifHandle,
                                          (32 * 1024),
                                          NULL,
                                          &RequiredSpaceKB );
        }

        //
        // No valid system partition.
        //
        SpStartScreen(
            SP_SCRN_NO_SYSPARTS,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            RequiredSpaceKB
            );

        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
                            SP_STAT_F3_EQUALS_EXIT,
                            0);

        SpInputDrain();

        //
        // wait for F3
        //
        while (SpInputGetKeypress() != KEY_F3) ;

        SpDone(0, FALSE, TRUE);
    }        

    ValidArcSystemPartition = (Region != NULL);

    return Region;
}    


NTSTATUS
SpPtnMarkLogicalDrives(
    IN ULONG DiskId
    )
/*++

Routine Description:

    Walks through the region linked list and marks the container
    partition and the logical drives. Also marks the free
    space inside container partition as contained space

Arguments:

    DiskId  : Disk to process

Return Value:

    STATUS_SUCCESS if successful, otherwise approprite error code

--*/    
{
    NTSTATUS Status = STATUS_SUCCESS;
    
    if (SPPT_IS_MBR_DISK(DiskId)) {
        PDISK_REGION    Region = SPPT_GET_PRIMARY_DISK_REGION(DiskId);
        PDISK_REGION    FirstContainer = NULL;
        PDISK_REGION    PrevContainer = NULL;

        while (Region) {
            if (SPPT_IS_REGION_CONTAINER_PARTITION(Region)) {
                if (!FirstContainer) {
                    FirstContainer = Region;
                    Region->Container = NULL;
                } else {
                    Region->Container = FirstContainer;
                }

                PrevContainer = Region;
            } else {
                if (PrevContainer) {
                    if (SPPT_IS_REGION_CONTAINED(PrevContainer, Region)) {
                        Region->Container = PrevContainer;

                        if (SPPT_IS_REGION_PARTITIONED(Region))
                            SPPT_SET_REGION_EPT(Region, EPTLogicalDrive);
                    } else {
                        if (SPPT_IS_REGION_CONTAINED(FirstContainer, Region))
                            Region->Container = FirstContainer;
                    }
                }
            }

            Region = Region->Next;
        }
    }    

    return Status;
}

ULONG
SpPtnGetOrdinal(
    IN PDISK_REGION         Region,
    IN PartitionOrdinalType OrdinalType
    )
/*++

Routine Description:

    Gets the Ordinal for the specified region of the specified
    type.
    
Arguments:

    Region      -   Region whose ordinal has to be found
    OrdinalType -   Type of ordinal for the region

Return Value:

    -1 if invalid request, otherwise appropriate ordinal number
    for the region.

--*/        
{
    ULONG   Ordinal = -1;
    
    if (Region && Region->PartitionNumber && SPPT_IS_REGION_PARTITIONED(Region)) {
        switch (OrdinalType) {
            case PartitionOrdinalOnDisk:
                if (SPPT_IS_MBR_DISK(Region->DiskNumber) && 
                    !SPPT_IS_REGION_CONTAINER_PARTITION(Region)) {
                    Ordinal = Region->TablePosition;
                } else if (SPPT_IS_GPT_DISK(Region->DiskNumber)) {
                    Ordinal = Region->TablePosition;
                }


                //
                // Ordinal zero is not valid
                //
                if (Ordinal == 0) {
                    Ordinal = -1;
                }

                break;

            default:
                Ordinal = Region->PartitionNumber;
                
                break;
        }                
    }        


    if( Ordinal == -1 ) {
        //
        // This is really bad.  We're about to
        // fall over.  Atleast try...
        //
        ASSERT(FALSE);
        Ordinal = 1;        

        KdPrintEx(( DPFLTR_SETUP_ID,
                    DPFLTR_INFO_LEVEL, 
                    "SETUP: SpPtnGetOrdinal: We didn't get an ordinal!  Force it.\n" ));
    }

    return Ordinal;        
}

VOID
SpPtnGetSectorLayoutInformation(
    IN  PDISK_REGION Region,
    OUT PULONGLONG   HiddenSectors,
    OUT PULONGLONG   VolumeSectorCount
    )
/*++

Routine Description:

    Gets the hidden sector and sector count for the formatted
    partitions (volumes)
    
Arguments:

    Region      -   The region for which the sector layout information
                    is needed
    HiddenSectors   -   Place holder to return the # of hidden sectors
                        for the region
    VolumeSectorCount-  Place holder to return the # of valid sectors                        
                        for the volume

Return Value:

    None

--*/        
{
    ULONGLONG   Hidden = 0;
    
    if (Region) {
        if (ARGUMENT_PRESENT(HiddenSectors)) {
            if (Region->PartInfo.PartitionStyle == PARTITION_STYLE_MBR)
                Hidden = Region->PartInfo.Mbr.HiddenSectors;
            else
                Hidden = 0;

            *HiddenSectors = Hidden;                
        }

        if (ARGUMENT_PRESENT(VolumeSectorCount)) {
            *VolumeSectorCount = Region->SectorCount - Hidden;
        }                        
    }
}

NTSTATUS
SpPtnUnlockDevice(
    IN PWSTR    DeviceName
    )
/*++

Routine Description:

    Attempts to unlock the media for the given device
    name (NT device pathname)
    
Arguments:

    DeviceName  :   The device for which the media needs to be
                    unlocked                    

Return Value:

    STATUS_SUCCESS if successful, otherwise appropriate error
    code

--*/        
{
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;

    if (DeviceName) {
        IO_STATUS_BLOCK     IoStatusBlock;
        OBJECT_ATTRIBUTES   ObjectAttributes;
        UNICODE_STRING      UnicodeString;
        HANDLE              Handle;
        PREVENT_MEDIA_REMOVAL   PMRemoval;

        INIT_OBJA(&ObjectAttributes, 
                    &UnicodeString, 
                    DeviceName);

        //
        // Open the device
        //
        Status = ZwCreateFile(
                    &Handle,
                    FILE_GENERIC_WRITE,
                    &ObjectAttributes,
                    &IoStatusBlock,
                    NULL,                           // allocation size
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_VALID_FLAGS,         // full sharing
                    FILE_OPEN,
                    FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,                           // no EAs
                    0
                    );

        if( NT_SUCCESS(Status) ) {
            //
            // Allow media removal
            //
            PMRemoval.PreventMediaRemoval = FALSE;
            
            Status = ZwDeviceIoControlFile(
                        Handle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        IOCTL_STORAGE_MEDIA_REMOVAL,
                        &PMRemoval,
                        sizeof(PMRemoval),
                        NULL,
                        0
                        );

            ZwClose(Handle);

            if( !NT_SUCCESS(Status) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                    "Setup: SpPtnUnlockDevice(%ws) - "
                    "Failed to tell the floppy to release its media.\n",
                    DeviceName));
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, 
                "Setup: SpPtnUnlockDevice(%ws) - Failed to open the device.\n",
                DeviceName));
        }        
    }

    return Status;
}

VOID
SpPtnAssignOrdinals(
    IN  ULONG   DiskNumber
    )
/*++

Routine Description:

    Assigns the on disk ordinal for the partitions for
    the requested disk. This on disk ordinal is used in
    the boot.ini (or NVRAM) ARC names to identify the
    boot and system partition devices.    
    
Arguments:

    DiskNumber  :   Disk Index for the disk which needs to
                    be assigned on disk ordinal for its
                    partitions

Return Value:

    None.

--*/        
{
    if ((DiskNumber < HardDiskCount)) {
        PDISK_REGION    Region = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);
        ULONG           OnDiskOrdinal = 1;

        if (SPPT_IS_MBR_DISK(DiskNumber)) {
            //
            // assign the ordinals to the primary partitions first
            //
            while (Region) {
                if (SPPT_IS_REGION_PRIMARY_PARTITION(Region)) {
                    Region->TablePosition = OnDiskOrdinal++;              
                }

                Region = Region->Next;
            }    

            Region = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);

            //
            // assign the ordinals to the logical drives next
            //
            while (Region) {
                if (SPPT_IS_REGION_LOGICAL_DRIVE(Region)) {
                    Region->TablePosition = OnDiskOrdinal++;
                }

                Region = Region->Next;
            }        
        } else {
            //
            // assign ordinals to the valid partition entries
            //
            while (Region) {
                if (SPPT_IS_REGION_PARTITIONED(Region)) {
                    Region->TablePosition = OnDiskOrdinal++;
                }

                Region = Region->Next;
            }
        }
    }
}

VOID
SpPtnLocateSystemPartitions(
    VOID
    )
/*++

Routine Description:

    Locates and marks the system partition, by looking into all the
    partitioned space on all the disks.

    For non ARC machines, locates and marks the system partition
    only on the primary disk 
    
Arguments:

    None

Return Value:

    None

--*/        
{
    ULONG DiskNumber;

    if (SpIsArc()) {
        for (DiskNumber = 0; DiskNumber < HardDiskCount; DiskNumber++) {
            SpPtnLocateDiskSystemPartitions(DiskNumber);
        }
    } else {
        DiskNumber = SpDetermineDisk0();

        if (DiskNumber != -1)
            SpPtnLocateDiskSystemPartitions(DiskNumber);
    }
}   


VOID
SpPtnLocateDiskSystemPartitions(
    IN ULONG DiskNumber
    )
/*++

Routine Description:

    Locates and marks the system partition for the requested
    disk (if none exists)

    For non ARC machine, only operates on primary disk
    
Arguments:

    DiskNumber  :   Disk index, for which system partition
                    needs to be located and marked.

Return Value:

    None.    

--*/        
{
    PDISK_REGION Region = NULL;
    
    if(!SpIsArc()) {
        //
        // Note: On amd64/X86 we currently don't allow system partitions to reside
        // on GPT disks
        //            
        if (SPPT_IS_MBR_DISK(DiskNumber) && (DiskNumber == SpDetermineDisk0())) {
            //
            // On x86 machines, we will mark any primary partitions on drive 0
            // as system partition, since such a partition is potentially bootable.
            //
            Region = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber); 

            while (Region && !SPPT_IS_REGION_SYSTEMPARTITION(Region)) {
                Region = Region->Next;
            }                

            if (!Region) {
                Region = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber); 

                while (Region) {
                    if (SPPT_IS_REGION_PRIMARY_PARTITION(Region)) {
                        SPPT_MARK_REGION_AS_SYSTEMPARTITION(Region, TRUE);
                        SPPT_SET_REGION_DIRTY(Region, TRUE);

                        break;
                    }
                    
                    Region = Region->Next;
                }
            }                
        }
    } else {
        PSP_BOOT_ENTRY BootEntry;

        //
        // Don't look for system partitions on MBR disks
        // on IA64
        //
        if (!SPPT_IS_GPT_DISK(DiskNumber)) {
            return;
        }

        //
        // On ARC machines, system partitions are specifically enumerated
        // in the NVRAM boot environment.
        //

        Region = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);

        while (Region) {
            //
            // Skip if not a partition or extended partition.
            //
            if(SPPT_IS_REGION_PARTITIONED(Region)) {
                //
                // Get the nt pathname for this region.
                //
                SpNtNameFromRegion(
                    Region,
                    TemporaryBuffer,
                    sizeof(TemporaryBuffer),
                    PartitionOrdinalOriginal
                    );

                //
                // Determine if it is a system partition.
                //
                for(BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next) {
                    if(!IS_BOOT_ENTRY_DELETED(BootEntry) &&
                       IS_BOOT_ENTRY_WINDOWS(BootEntry) &&                    
                       (BootEntry->LoaderPartitionNtName != 0) &&
                       !_wcsicmp(BootEntry->LoaderPartitionNtName,TemporaryBuffer)) {
                        if (!SPPT_IS_REGION_SYSTEMPARTITION(Region)) {
                            SPPT_MARK_REGION_AS_SYSTEMPARTITION(Region, TRUE);
                            SPPT_SET_REGION_DIRTY(Region, TRUE);
                            ValidArcSystemPartition = TRUE;
                        }
                        
                        break;
                    }
                }
            }

            Region = Region->Next;
        }            
    }


    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
        "SETUP:SpPtnLocateDiskSystemPartitions(%d):%p\n",
        DiskNumber,
        Region));

    if (Region) 
        SpPtDumpDiskRegion(Region);
}    

BOOLEAN
SpPtnIsDiskStyleChangeAllowed(
    IN ULONG DiskNumber
    )
/*++

Routine Description:

    Finds out whether disk style change is allowed for the
    given disk.

    On AXP machines disk style change is not allowed. On
    X-86 machines currently disk style change is disabled for
    primary disks. 
    
Arguments:

    DiskNumber  :   Disk, whose style needs to be changed.

Return Value:

    TRUE if disk style change is allowed, otherwise FALSE

--*/            
{
    BOOLEAN Result = FALSE;

    if (DiskNumber < HardDiskCount) {
#if defined(_AMD64_) || defined(_X86_)

        //
        // On non ARC x86 machines, the disk should be a clean
        // non-removable secondary disk
        //
        // Don't allow MBR to GPT disk conversion on X86
        //
        Result = (!SPPT_IS_REMOVABLE_DISK(DiskNumber) && 
                    SPPT_IS_BLANK_DISK(DiskNumber) && 
                    !SpIsArc() && SPPT_IS_GPT_DISK(DiskNumber));
                    
#elif defined (_IA64_)

        //
        // Don't allow conversion from GPT to MBR on IA-64
        //

        Result = !SPPT_IS_REMOVABLE_DISK(DiskNumber) &&
                    SPPT_IS_BLANK_DISK(DiskNumber) && 
                    SPPT_IS_MBR_DISK(DiskNumber);
        
#endif // defined(_AMD64_) || defined(_X86_)
    }


    return Result;
}


VOID
SpPtnPromptForSysPart(
    IN PVOID SifHandle
    )
/*++

Routine Description:

    Prompts the user about the absence of system partition
    while installating to another valid non-system partition.
    Allows the user to quit setup or continue (generally go
    back to the partitioning engine)
    
Arguments:

    SifHandle   :   Handle to txtsetup.sif (to do space calculation)

Return Value:

    None

--*/        
{    
    ULONG RequiredSpaceKB = 0;
    ULONG KeyPressed = 0;
    
    SpFetchDiskSpaceRequirements( SifHandle,
                                  (32 * 1024),
                                  NULL,
                                  &RequiredSpaceKB );

    //
    // No valid system partition.
    //
    SpStartScreen(
        SP_SCRN_MARK_SYSPART,
        3,
        HEADER_HEIGHT+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE,
        RequiredSpaceKB
        );

    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
                        SP_STAT_ESC_EQUALS_CANCEL,
                        SP_STAT_F3_EQUALS_EXIT,
                        0);

    SpInputDrain();

    //
    // wait for F3 or ESC key
    //
    while ((KeyPressed != KEY_F3) && (KeyPressed != ASCI_ESC)) {
        KeyPressed = SpInputGetKeypress();
    }        

    if (KeyPressed == KEY_F3) {
        SpDone(0, FALSE, TRUE);
    }         
}

BOOLEAN
SpPtnIsDeleteAllowedForRegion(
    IN PDISK_REGION Region
    )
/*++

Routine Description:

    Given a region this function tries to find out if the region
    can be deleted.
    
Arguments:

    Region :   Pointer to region which is to be checked for 
               deletion

Return Value:

    TRUE if the given region can be deleted otherwise FALSE

--*/
{
    BOOLEAN Result = FALSE;

    if (Region && SPPT_IS_REGION_PARTITIONED(Region)) {
        PDISK_REGION BootRegion = SpRegionFromNtName(NtBootDevicePath, 
                                    PartitionOrdinalCurrent);
        ULONG   DiskNumber = Region->DiskNumber;                                    

        if (SPPT_IS_REGION_DYNAMIC_VOLUME(Region)) {
            //
            // Don't delete the dynamic volume if its on
            // the same disk as local source or system partition
            //
            if (!(LocalSourceRegion && 
                 (LocalSourceRegion->DiskNumber == DiskNumber)) && 
                !(BootRegion && 
                 (BootRegion->DiskNumber == DiskNumber))) {                
                Result = TRUE;                 
            }                             
        } else {
            Result = ((BootRegion != Region) && (LocalSourceRegion != Region));
        }
    }

    return Result;
}


BOOLEAN
SpPtnIsRawDiskDriveLayout(
    IN PDRIVE_LAYOUT_INFORMATION_EX DriveLayout
    )
/*++

Routine Description:

    Given a drive layout tests whether the given drive layout
    could be for a raw disk

    NOTE : If all the partition entries are empty entries or
    if there are no partition entries then we assume the disk 
    to be RAW disk.
    
Arguments:

    DriveLayout : Drive layout information that needs to
    be tested

Return Value:

    TRUE if the given disk is RAW otherwise FALSE

--*/
{
    BOOLEAN Result = TRUE;

    if (DriveLayout && DriveLayout->PartitionCount && 
        (DriveLayout->PartitionStyle != PARTITION_STYLE_RAW)) {
        ULONG   Index;

        for (Index=0; Index < DriveLayout->PartitionCount; Index++) {
            PPARTITION_INFORMATION_EX   PartInfo = DriveLayout->PartitionEntry + Index;

            //
            // Partition is invalid partition if 
            //  - starting offset is 0 and
            //  - length is 0 and
            //  - partition number is 0
            //
            if ((PartInfo->StartingOffset.QuadPart) ||
                (PartInfo->PartitionLength.QuadPart) ||
                (PartInfo->PartitionNumber)) {
                Result = FALSE;

                break;  // found an valid partition entry
            }                        
        }
    }                

    return Result;
}

BOOLEAN
SpPtnIsDynamicDisk(
    IN  ULONG   DiskIndex
    )
/*++

Routine Description:

    Determines whether the given disk is dynamic i.e. it has
    atleast a single dynamic volume
        
Arguments:

    DiskIndex   -   Zero based index of the disk to test

Return Value:

    TRUE, if the disk has a dynamic volume otherwise FALSE

--*/
{
    BOOLEAN Result = FALSE;

    if ((DiskIndex < HardDiskCount) &&
        !SPPT_IS_REMOVABLE_DISK(DiskIndex)) {
        PDISK_REGION    Region = SPPT_GET_PRIMARY_DISK_REGION(DiskIndex);

        while (Region && !SPPT_IS_REGION_DYNAMIC_VOLUME(Region)) {
            Region = Region->Next;
        }

        if (Region) {
            Result = TRUE;
        }
    }

    return Result;
}


//
// Callback context structure for finding the Guid volume name
// for the specified NT partition name
//
typedef struct _NT_TO_GUID_VOLUME_NAME {
    WCHAR   NtName[MAX_PATH];
    WCHAR   GuidVolumeName[MAX_PATH];
} NT_TO_GUID_VOLUME_NAME, *PNT_TO_GUID_VOLUME_NAME;


static
BOOLEAN
SppPtnCompareGuidNameForPartition(
    IN PVOID Context,
    IN PMOUNTMGR_MOUNT_POINTS MountPoints,        
    IN PMOUNTMGR_MOUNT_POINT MountPoint
    )
/*++

Routine Description:

    Callback routine for searching the appropriate GUID
    volume name for the specified NT partition.
        
Arguments:

    Context  : PNT_TO_GUID_VOLUME_NAME pointer disguised as PVOID

    MountPoints : The MountPoints which were received from mountmgr.
                  NOTE : The only reason this is here is because
                  somebody created MOUNT_POINT structure abstraction
                  contained inside MOUNT_POINTS which has some fields
                  (like SymbolicNameOffset) which are relative to
                  the MOUNT_POINTS.

    MountPoint : The current mountpoint (as part of MountPoints)                          

Return Value:

    TRUE if we found a match and want to terminate the iteration else
    FALSE.

--*/
{
    BOOLEAN Result = FALSE;

    if (Context && MountPoint && MountPoint->SymbolicLinkNameLength) {
        WCHAR   CanonicalName[MAX_PATH];
        PWSTR   GuidName = NULL;
        UNICODE_STRING  String;
        PNT_TO_GUID_VOLUME_NAME Map = (PNT_TO_GUID_VOLUME_NAME)Context;

        GuidName = SpMemAlloc(MountPoint->SymbolicLinkNameLength + 2);

        if (GuidName) {
            //
            // Copy over the symbolic name and null terminate it
            // 
            RtlCopyMemory(GuidName, 
                ((PCHAR)MountPoints) + MountPoint->SymbolicLinkNameOffset,
                MountPoint->SymbolicLinkNameLength);

            GuidName[MountPoint->SymbolicLinkNameLength/sizeof(WCHAR)] = UNICODE_NULL;
            
            RtlInitUnicodeString(&String, GuidName); 

            //
            // We are only bothered about volume names & 
            // resolve the actual object name
            //
            if (MOUNTMGR_IS_VOLUME_NAME(&String) &&
                NT_SUCCESS(SpQueryCanonicalName(GuidName, 
                                -1, 
                                CanonicalName, 
                                sizeof(CanonicalName)))) {

                //
                // Do the names compare correctly
                //
                Result = (_wcsicmp(CanonicalName, Map->NtName) == 0);

                if (Result) {
                    //
                    // Copy the name to the result
                    //
                    RtlZeroMemory(Map->GuidVolumeName, 
                        sizeof(Map->GuidVolumeName));
                        
                    wcsncpy(Map->GuidVolumeName, 
                        GuidName, 
                        sizeof(Map->GuidVolumeName)/sizeof(WCHAR) - 1);
                        
                    Map->GuidVolumeName[sizeof(Map->GuidVolumeName)/sizeof(WCHAR) - 1] = UNICODE_NULL;
                }
            }                            

            SpMemFree(GuidName);
        }            
    }

    return Result;
}


NTSTATUS
SpPtnGetGuidNameForPartition(
    IN PWSTR NtPartitionName,
    IN OUT PWSTR VolumeName
    )
/*++

Routine Description:

    Gets the GUID volume name (in \\??\Volume{a-b-c-d} format) for
    the given NT partition name (in \Device\harddiskX\PartitionY format).
        
Arguments:

    NtPartitionName : NT partition name

    VolumeName  : Place holder buffer for receiving the GUID volume name.
                  Should be atlease MAX_PATH in length.

Return Value:

    Approriate NTSTATUS code.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (NtPartitionName && VolumeName) {
        NT_TO_GUID_VOLUME_NAME  Context = {0};

        //
        // Resolve the NT name to actual object name
        //
        Status = SpQueryCanonicalName(NtPartitionName, 
                            -1,
                            Context.NtName,
                            sizeof(Context.NtName));
                            
        if (NT_SUCCESS(Status)) {                            
            //
            // Iterate through mountpoints and try to
            // get the GUID volume name for the NT name
            //
            Status = SpIterateMountMgrMountPoints(&Context,
                        SppPtnCompareGuidNameForPartition);

            if (NT_SUCCESS(Status)) {
                if (Context.GuidVolumeName[0]) {
                    //
                    // Copy over the result
                    //
                    wcscpy(VolumeName, Context.GuidVolumeName);
                } else {
                    Status = STATUS_OBJECT_NAME_NOT_FOUND;
                }                
            }
        }            
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\sppart2.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    sppart2.c

Abstract:

    Second file for disk preparation UI;
    supplies routines to handle a user's selection
    of the partition onto which he wants to install NT.

Author:

    Ted Miller (tedm) 16-Sep-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop



#ifdef _X86_
BOOLEAN
SpIsWin9xMsdosSys(
    IN PDISK_REGION Region,
    OUT PSTR*       Win9xPath
    );
#endif

ULONG
SpFormattingOptions(
    IN BOOLEAN  AllowFatFormat,
    IN BOOLEAN  AllowNtfsFormat,
    IN BOOLEAN  AllowConvertNtfs,
    IN BOOLEAN  AllowDoNothing,
    IN BOOLEAN  AllowEscape
    );


BOOLEAN
SpPtRegionDescription(
    IN  PPARTITIONED_DISK pDisk,
    IN  PDISK_REGION      pRegion,
    OUT PWCHAR            Buffer,
    IN  ULONG             BufferSize
    );

typedef enum {
    FormatOptionCancel = 0,
    FormatOptionFat,
    FormatOptionNtfs,
    FormatOptionFatQuick,
    FormatOptionNtfsQuick,
    FormatOptionConvertToNtfs,
    FormatOptionDoNothing
} FormatOptions;

extern PSETUP_COMMUNICATION CommunicationParams;

//#ifdef TEST
#if defined(_AMD64_) || defined(_X86_)
BOOLEAN
SpIsExistsOs(
    IN PDISK_REGION CColonRegion
    );

extern NTSTATUS
pSpBootCodeIo(
    IN     PWSTR     FilePath,
    IN     PWSTR     AdditionalFilePath, OPTIONAL
    IN     ULONG     BytesToRead,
    IN     PUCHAR   *Buffer,
    IN     ULONG     OpenDisposition,
    IN     BOOLEAN   Write,
    IN     ULONGLONG Offset,
    IN     ULONG     BytesPerSector
    );

extern VOID
SpDetermineOsTypeFromBootSector(
    IN  PWSTR     CColonPath,
    IN  PUCHAR    BootSector,
    OUT PUCHAR   *OsDescription,
    OUT PBOOLEAN  IsNtBootcode,
    OUT PBOOLEAN  IsOtherOsInstalled,
    IN  WCHAR     DriveLetter
    );

extern BOOLEAN
SpHasMZHeader(
    IN PWSTR   FileName
    );
#endif // defined(_AMD64_) || defined(_X86_)
//#endif //TEST

BOOLEAN
SpPtIsForeignPartition(
    IN PDISK_REGION Region
    )
{
    BOOLEAN ForeignPartition = TRUE;   // for blank disks ?

    if (Region){
        UCHAR   SystemId;

        if (SPPT_IS_MBR_DISK(Region->DiskNumber)) {
            SystemId = SpPtGetPartitionType(Region);        

            ASSERT(SystemId != PARTITION_ENTRY_UNUSED);
            ASSERT(!IsContainerPartition(SystemId));
            
            ForeignPartition = ((PartitionNameIds[SystemId] != (UCHAR)(-1)) &&
                                (!Region->DynamicVolume || !Region->DynamicVolumeSuitableForOS));
        }

        if (SPPT_IS_GPT_DISK(Region->DiskNumber)) {
            //
            // If problem occurs of unattend case trying to install to an OEM partition
            // Add this condition (||(Region->IsReserved)) to block selection of OEM 
            // partition.
            //
            ForeignPartition = (Region->DynamicVolume && !Region->DynamicVolumeSuitableForOS);                                           
        }
    }
    return ForeignPartition;
}

BOOLEAN
SpPtDeterminePartitionGood(
    IN PDISK_REGION Region,
    IN ULONGLONG    RequiredKB,
    IN BOOLEAN      DisallowOtherInstalls
    )
{
    UCHAR SystemId;
    BOOLEAN NewlyCreated;
    ULONG PreconfirmFormatId;
    ULONG ValidKeys1[2] = { ASCI_CR ,0 };
    ULONG ValidKeys2[2] = { ASCI_ESC,0 };
    ULONG Mnemonics1[2] = { MnemonicContinueSetup, 0 };
    ULONG Mnemonics2[2] = { 0,0 };
    ULONGLONG RegionSizeKB;
    ULONG r;
#if defined(_AMD64_) || defined(_X86_)
    PDISK_REGION systemPartitionRegion;
#endif // defined(_AMD64_) || defined(_X86_)
    ULONG selection;
    NTSTATUS Status;
    ULONG Count;
    PWSTR p;
    PWSTR RegionDescr;
    LARGE_INTEGER temp;


    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
        "SETUP: SpPtDeterminePartitionGood(): Starting partition verification\n" ));

    //
    // Make sure we can see the disk from the firmware/bios.
    // If we can get an arc name for the disk, assume it's ok.
    // Otherwise, it ain't.
    //
    p = SpNtToArc( HardDisks[Region->DiskNumber].DevicePath,PrimaryArcPath );
    
    if (p == NULL) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
            "SETUP: SpPtDeterminePartitionGood(): Failed to create an arc name for this partition\n" ));
            
        return FALSE;
    }

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
        "SETUP: SpPtDeterminePartitionGood(): partition=[%ws]\n", p ));

    //
    // Make sure the partition is formatted.
    //
    if( Region->PartitionedSpace ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
            "SETUP: SpPtDeterminePartitionGood(): This partition is formated.\n"));
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
            "SETUP: SpPtDeterminePartitionGood(): This partition hasn't been formated.\n"));
            
        return FALSE;
    }

    //
    // I think he's formatted, but he better be of a format that I can read.
    // Make sure.
    //
    if( (Region->Filesystem == FilesystemFat)        ||
        (Region->Filesystem == FilesystemFirstKnown) ||
        (Region->Filesystem == FilesystemNtfs)       ||
        (Region->Filesystem == FilesystemFat32) ) {

        //
        // Life is grand.  Let's tell the user and keep going.
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
            "SETUP: SpPtDeterminePartitionGood(): This partition "
            "is formated with a known filesystem (%d).\n", Region->Filesystem ));
    } else {
        //
        // Darn!  We don't know how to read this filesystem.  Bail.
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
            "SETUP: SpPtDeterminePartitionGood(): This partition is "
            "formated with an unknown (or invalid for holding an installation) "
            "filesystem (%d).\n", Region->Filesystem ));
            
        return FALSE;
    }

#if defined(_AMD64_) || defined(_X86_)
    //
    // On amd64/x86 we don't allow disks that have LUN greater than 0
    //
    SpStringToLower( p );
    
    if( wcsstr( p, L"scsi(" ) &&
        wcsstr( p, L")rdisk(" ) ) {
        if( wcsstr( p, L")rdisk(0)" ) == NULL ) {
            SpMemFree(p);
            
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                "SETUP: SpPtDeterminePartitionGood(): Disks with "
                "a LUN greater than zero are not allowed\n" ));
                
            return FALSE;
        }
    }
#endif // defined(_AMD64_) || defined(_X86_)

    SpMemFree(p);

    //
    // Disallow installation to PCMCIA disks.
    //
    if(HardDisks[Region->DiskNumber].PCCard) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
            "SETUP: SpPtDeterminePartitionGood(): Cannot install to PCMCIA disk\n" ));
            
        return FALSE;
    }

    //
    // don't choose a removeable drive
    //

#if 0
    //
    // Allow installs to removable media...
    //
    if(HardDisks[Region->DiskNumber].Characteristics & FILE_REMOVABLE_MEDIA) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
            "SETUP: SpPtDeterminePartitionGood(): Cannot install to a removable disk\n" ));
            
        return FALSE;
    }
#endif

    //
    // Disallow installs to removable media or AT formatted drive, on NEC98.
    //
    if(IsNEC_98 &&	
       ((HardDisks[Region->DiskNumber].Characteristics & FILE_REMOVABLE_MEDIA) ||
	    (HardDisks[Region->DiskNumber].FormatType == DISK_FORMAT_TYPE_PCAT))) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
            "SETUP: SpPtDeterminePartitionGood(): Cannot install "
            "to a removable disk or  AT formatted disk\n" ));
            
        return  FALSE;
    }

    //
    // Calculate the size of the region in KB.
    //
    temp.QuadPart = UInt32x32To64(
                        Region->SectorCount,
                        HardDisks[Region->DiskNumber].Geometry.BytesPerSector
                        );

    RegionSizeKB = RtlExtendedLargeIntegerDivide(temp,1024,&r).LowPart;

    //
    // If the region is not large enough, bail
    //
    if (RegionSizeKB < RequiredKB) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
            "SETUP: SpPtDeterminePartitionGood(): Partition does not "
            "have enough free space: required=%ld, available=%ld\n", 
            RequiredKB, 
            RegionSizeKB ));
            
        return FALSE;
    }

    if (!Region->PartitionedSpace) {
        //
        // can't use a partition with just free space
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
            "SETUP: SpPtDeterminePartitionGood(): Partition does not "
            "have any partitioned space\n" ));
            
        return FALSE;
    }

    SystemId = SpPtGetPartitionType(Region);

    if (SystemId == PARTITION_ENTRY_UNUSED || IsContainerPartition(SystemId)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: SpPtDeterminePartitionGood(): Invalid partition type(1)\n" ));
        return FALSE;
    }

    if(SpPtIsForeignPartition(Region)) {
        
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
            "SETUP: SpPtDeterminePartitionGood(): Invalid partition type(2)\n" ));
            
        return FALSE;
    }

    //
    // The region is a partition that we recognize.
    // See whether it has enough free space on it.
    //
    if(Region->AdjustedFreeSpaceKB == (ULONG)(-1)) {

        //
        // If the partition was newly created during setup
        // then it is acceptable (because the check to see
        // if it is large enough was done above).
        //

        if(Region->Filesystem != FilesystemNewlyCreated) {
            //
            // Otherwise, we don't know how much space is
            // on the drive so reformat will be necessary.
            //
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                "SETUP: SpPtDeterminePartitionGood(): Format is necessary\n" ));
                
            return FALSE;
        }
    } else {
        if(Region->AdjustedFreeSpaceKB < RequiredKB) {
            //
            // If we get here, then the partition is large enough,
            // but there is definitely not enough free space on it.
            //
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                "SETUP: SpPtDeterminePartitionGood(): Partition does not have "
                "enough free space: required=%ld, available=%ld\n", 
                RequiredKB, Region->AdjustedFreeSpaceKB ));
                
            return FALSE;
        }
    }

#if defined(_AMD64_) || defined(_X86_)
    if(!SpIsArc())
    {
        //
        // On an amd64/x86 machine, make sure that we have a valid primary partition
        // on drive 0 (C:), for booting.
        //
        if (!IsNEC_98) { // this is a standard PC/AT type machine
            if((systemPartitionRegion = SpPtValidSystemPartition()) == NULL) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                    "SETUP: SpPtDeterminePartitionGood(): Not a valid primary partition\n" ));
                    
                return FALSE;
            }

            //
            // Make sure the system partition is active and all others are inactive.
            //
            SpPtMakeRegionActive(systemPartitionRegion);
        } else {
            //
            // Check existing system on target partition,
            // If it exists, don't choose it as target partition.
            //
            if (SpIsExistsOs(Region)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: SpPtDeterminePartitionGood(): OS already exists\n" ));
                return(FALSE);
            }

            //
            // All of partition is bootable on NEC98,
            // so we don't need to check system partition on C:.
            //
            systemPartitionRegion = Region;
        } //NEC98
    }
#endif // defined(_AMD64_) || defined(_X86_)

    if (DisallowOtherInstalls) {

        PUCHAR Win9xPath;

#ifdef _X86_
        if (SpIsWin9xMsdosSys( Region, &Win9xPath )) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: SpPtDeterminePartitionGood(): Cannot use a partition with WIN9x installed on it\n" ));
            return FALSE;
        }
#endif

        if (SpIsNtOnPartition(Region)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: SpPtDeterminePartitionGood(): Cannot use a partition with NT installed on it\n" ));
            return FALSE;
        }
    }

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: SpPtDeterminePartitionGood(): Parition is GOOD :)\n" ));

    return TRUE;
}

#if defined(_AMD64_) || defined(_X86_)
BOOLEAN
SpIsExistsOs(
    IN OUT PDISK_REGION CColonRegion
    )
{
    PUCHAR NewBootCode;
    ULONG BootCodeSize;
    PUCHAR ExistingBootCode;
    NTSTATUS Status;
    PUCHAR ExistingBootCodeOs;
    PWSTR CColonPath;
    HANDLE  PartitionHandle;
    BOOLEAN IsNtBootcode,OtherOsInstalled;
    UNICODE_STRING    UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK   IoStatusBlock;
    BOOLEAN BootSectorCorrupt = FALSE;
    ULONG   BytesPerSector;
    ULONG   ActualSectorCount, hidden_sectors, super_area_size;
    BOOLEAN IsExist = TRUE;

    ULONG   MirrorSector;
    PWSTR   *FilesToLookFor;
    ULONG   FileCount;
    PWSTR NtFiles[1] = { L"NTLDR" };
    PWSTR ChicagoFiles[1] = { L"IO.SYS" };

    ExistingBootCode = NULL;
    BytesPerSector = HardDisks[CColonRegion->DiskNumber].Geometry.BytesPerSector;

    switch(CColonRegion->Filesystem) {

    case FilesystemNewlyCreated:

        //
        // If the filesystem is newly-created, then there is
        // nothing to do, because there can be no previous
        // operating system.
        //
        IsExist = TRUE;
        return( IsExist );

    case FilesystemNtfs:

        NewBootCode = PC98NtfsBootCode;
        BootCodeSize = sizeof(PC98NtfsBootCode);
        ASSERT(BootCodeSize == 8192);
        break;

    case FilesystemFat:

        NewBootCode = PC98FatBootCode;
        BootCodeSize = sizeof(PC98FatBootCode);
        ASSERT(BootCodeSize == 512);
        break;

    case FilesystemFat32:

        //
        // Special hackage required for Fat32 because its NT boot code
        // is discontiguous.
        //
        ASSERT(sizeof(Fat32BootCode) == 1536);
        NewBootCode = PC98Fat32BootCode;
        BootCodeSize = 512;
        break;

    default:

        ASSERT(0);
        IsExist = TRUE;
        return( IsExist );
    }

    //
    // Form the device path to C: and open the partition.
    //

    SpNtNameFromRegion(CColonRegion,TemporaryBuffer,sizeof(TemporaryBuffer),PartitionOrdinalCurrent);
    CColonPath = SpDupStringW(TemporaryBuffer);
    INIT_OBJA(&Obja,&UnicodeString,CColonPath);

    Status = ZwCreateFile(
        &PartitionHandle,
        FILE_GENERIC_READ | FILE_GENERIC_WRITE,
        &Obja,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OPEN,
        FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0
        );

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to open the partition!\n"));
        ASSERT(0);
        IsExist = TRUE;
        return( IsExist );
    }


    //
    // Just use the existing boot code.
    //

    Status = pSpBootCodeIo(
                    CColonPath,
                    NULL,
                    BootCodeSize,
                    &ExistingBootCode,
                    FILE_OPEN,
                    FALSE,
                    0,
                    BytesPerSector
                    );

    if(CColonRegion->Filesystem == FilesystemNtfs) {
        MirrorSector = NtfsMirrorBootSector(PartitionHandle,BytesPerSector,NULL);
    }

    switch(CColonRegion->Filesystem) {

    case FilesystemFat:

        if(NT_SUCCESS(Status)) {

            //
            // Determine the type of operating system the existing boot sector(s) are for
            // and whether that os is actually installed.
            //

            SpDetermineOsTypeFromBootSector(
                CColonPath,
                ExistingBootCode,
                &ExistingBootCodeOs,
                &IsNtBootcode,
                &OtherOsInstalled,
                CColonRegion->DriveLetter
                );

            if (OtherOsInstalled == TRUE) {
                IsExist = TRUE;

            } else if (IsNtBootcode == TRUE) {
                wcscpy(TemporaryBuffer,CColonPath);
                FilesToLookFor = NtFiles;
                FileCount = ELEMENT_COUNT(NtFiles);

                if(SpNFilesExist(TemporaryBuffer,FilesToLookFor,FileCount,FALSE)) {
                    IsExist = TRUE;
                } else {
                    IsExist = FALSE;
                }

            } else {
                IsExist = FALSE;
            }

        } else {
            IsExist = TRUE;
        }
        break;

    case FilesystemFat32:

        wcscpy(TemporaryBuffer,CColonPath);
        FilesToLookFor = NtFiles;
        FileCount = ELEMENT_COUNT(NtFiles);

        if(SpNFilesExist(TemporaryBuffer,FilesToLookFor,FileCount,FALSE)) {
            IsExist = TRUE;
        }

        FilesToLookFor = ChicagoFiles;
        FileCount = ELEMENT_COUNT(ChicagoFiles);

        if(SpNFilesExist(TemporaryBuffer,FilesToLookFor,FileCount,FALSE)) {

            wcscpy(TemporaryBuffer, CColonPath);
            SpConcatenatePaths(TemporaryBuffer, L"IO.SYS");

            if(SpHasMZHeader(TemporaryBuffer)) {
                IsExist = TRUE;
            } else {
                IsExist = FALSE;
            }
        } else {
            IsExist = FALSE;
        }
        break;

    case FilesystemNtfs:

        wcscpy(TemporaryBuffer,CColonPath);
        FilesToLookFor = NtFiles;
        FileCount = ELEMENT_COUNT(NtFiles);

        if(SpNFilesExist(TemporaryBuffer,FilesToLookFor,FileCount,FALSE)) {
            IsExist = TRUE;
        } else {
            IsExist = FALSE;
        }
        break;

    default:

        ASSERT(0);
        IsExist = TRUE;
    }

    SpMemFree(CColonPath);
    ZwClose (PartitionHandle);
    return( IsExist );
}
#endif // defined(_AMD64_) || defined(_X86_)

BOOLEAN
SpPtDoPartitionSelection(
    IN OUT PDISK_REGION *Region,
    IN     PWSTR         RegionDescription,
    IN     PVOID         SifHandle,
    IN     BOOLEAN       Unattended,
    IN     PWSTR         SetupSourceDevicePath,
    IN     PWSTR         DirectoryOnSetupSource,
    IN     BOOLEAN       RemoteBootRepartition,
    OUT    PBOOLEAN      Win9xInstallationPresent    
    )
{
    ULONG RequiredKB;
    ULONG TempKB;
    UCHAR SystemId;
    BOOLEAN NewlyCreated;
    ULONG PreconfirmFormatId;
    ULONG ValidKeys1[2] = { ASCI_CR ,0 };
    ULONG ValidKeys2[2] = { ASCI_ESC,0 };
    ULONG Mnemonics1[2] = { MnemonicContinueSetup, 0 };
    ULONG Mnemonics2[2] = { 0,0 };
    ULONG RegionSizeKB;
    ULONG r;
#if defined(_AMD64_) || defined(_X86_)
    PDISK_REGION systemPartitionRegion;
#endif // defined(_AMD64_) || defined(_X86_)
    BOOLEAN AllowNtfsOptions;
    BOOLEAN AllowFatOptions;
    ULONG selection;
    NTSTATUS Status;
    ULONG   Count;
    PWSTR p;
    PWSTR RegionDescr;
    PDISK_REGION region = *Region;
    LARGE_INTEGER temp;
    BOOLEAN AllowFormatting;
    BOOLEAN QuickFormat = FALSE, OtherOSOnPartition;
    PSTR Win9xPath = NULL;
    PWCHAR Win9xPathW = NULL;

    if (Win9xInstallationPresent) {
        *Win9xInstallationPresent = FALSE;
    }                        

#if defined(REMOTE_BOOT)
    //
    // If this is a remote boot setup on a diskless machine, skip partition
    // selection (note that we check the RemoteBootSetup global flag, not
    // the passed-in RemoteBootRepartition flag).
    //
    if (RemoteBootSetup && (HardDiskCount == 0)) {
        return TRUE;
    }
#endif // defined(REMOTE_BOOT)

    //
    // Assume that if we need to format the drive, that
    // the user needs to confirm.
    //
    PreconfirmFormatId = 0;
    NewlyCreated = FALSE;
    AllowNtfsOptions = TRUE;
    AllowFatOptions = TRUE;

    //
    // Disallow installation to PCMCIA disks.
    //
    if(HardDisks[region->DiskNumber].PCCard) {
        SpDisplayScreen(SP_SCRN_CANT_INSTALL_ON_PCMCIA,3,HEADER_HEIGHT+1);
        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_ENTER_EQUALS_CONTINUE,0);
        SpWaitValidKey(ValidKeys1,NULL,NULL);
        return(FALSE);
    }

    //
    // Disallow installation to non-platform disk
    // on clean installs
    //
    // AMD64/X86  - Installs only to MBR disks
    // IA64 - Installs only to GPT disks
    //
    if (SPPT_GET_DISK_TYPE(region->DiskNumber) != SPPT_DEFAULT_DISK_STYLE) {
        SpDisplayScreen(SP_SCRN_INVALID_INSTALLPART, 3, HEADER_HEIGHT+1);        
        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_ENTER_EQUALS_CONTINUE,0);
        
        SpWaitValidKey(ValidKeys1,NULL,NULL);
    
        return FALSE;
    }

    //
    // Make sure we can see the disk from the firmware/bios.
    // If we can get an arc name for the disk, assume it's ok.
    // Otherwise, it ain't.
    //
    if(p = SpNtToArc(HardDisks[region->DiskNumber].DevicePath,PrimaryArcPath)) {
#if defined(_AMD64_) || defined(_X86_)
        //
        // On amd64/x86 we don't allow disks that have LUN greater than 0
        //
        SpStringToLower( p );
        if( wcsstr( p, L"scsi(" ) &&
            wcsstr( p, L")rdisk(" ) ) {
            if( wcsstr( p, L")rdisk(0)" ) == NULL ) {
                //
                // Tell the user that we can't install to that disk.
                //
                SpDisplayScreen(SP_SCRN_DISK_NOT_INSTALLABLE_LUN_NOT_SUPPORTED,
                                3,
                                HEADER_HEIGHT+1);
                SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_ENTER_EQUALS_CONTINUE,0);
                SpWaitValidKey(ValidKeys1,NULL,NULL);
                SpMemFree(p);
                return(FALSE);
            }
        }
#endif // defined(_AMD64_) || defined(_X86_)
        SpMemFree(p);
    } else {
        //
        // Tell the user that we can't install to that disk.
        //
        SpDisplayScreen(SP_SCRN_DISK_NOT_INSTALLABLE,3,HEADER_HEIGHT+1);
        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_ENTER_EQUALS_CONTINUE,0);
        SpWaitValidKey(ValidKeys1,NULL,NULL);
        return(FALSE);
    }

    //
    // Disallow installation of Personal onto dynamic disks 
    // since dynamic disks feature is not available on Personal
    //
    if (SpIsProductSuite(VER_SUITE_PERSONAL) && 
        SpPtnIsDynamicDisk(region->DiskNumber)) {    

        SpDisplayScreen(SP_NO_DYNAMIC_DISK_INSTALL, 
            3, 
            HEADER_HEIGHT + 1);
            
        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            0);
            
        SpWaitValidKey(ValidKeys1, NULL, NULL);        

        return FALSE;
    }

    //
    // Fetch the amount of free space required on the windows nt drive.
    //
    SpFetchDiskSpaceRequirements( SifHandle,
                                  region->BytesPerCluster,
                                  &RequiredKB,
                                  NULL);

    //
    // For remote install, we have not yet copied ~LS, so add that space
    // in also.
    //
    if (RemoteInstallSetup) {
        SpFetchTempDiskSpaceRequirements( SifHandle,
                                          region->BytesPerCluster,
                                          &TempKB,
                                          NULL);
        RequiredKB += TempKB;
    }

    //
    // Calculate the size of the region in KB.
    //
    temp.QuadPart = UInt32x32To64(
                        region->SectorCount,
                        HardDisks[region->DiskNumber].Geometry.BytesPerSector
                        );

    RegionSizeKB = RtlExtendedLargeIntegerDivide(temp,1024,&r).LowPart;

    //
    // If the region is not large enough, tell the user.
    //
    if(RegionSizeKB < RequiredKB) {

        SpStartScreen(
            SP_SCRN_REGION_TOO_SMALL,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            (RequiredKB / 1024) + 1
            );

        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_ENTER_EQUALS_CONTINUE,0);
        SpWaitValidKey(ValidKeys1,NULL,NULL);
        return(FALSE);
    }

    if(region->PartitionedSpace) {     

        if (SpPtIsForeignPartition(region)) {                                    
            SpStartScreen(
                SP_SCRN_FOREIGN_PARTITION,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE
                );

            SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_ENTER_EQUALS_CONTINUE,
                0);
                
            SpWaitValidKey(ValidKeys1,
                NULL,
                NULL);
                
            return FALSE;
        }


        if (!RemoteBootRepartition) {

            //
            // The region is a partition that we recognize.
            // See whether it has enough free space on it.
            //
            if(region->AdjustedFreeSpaceKB == (ULONG)(-1)) {

                //
                // If the partition was newly created during setup
                // then it acceptable (because the check to see
                // if it is large enough was done above).
                //

                if(region->Filesystem != FilesystemNewlyCreated) {

                    //
                    // Otherwise, we don't know how much space is
                    // on the drive so reformat will be necessary.
                    //
                    PreconfirmFormatId = SP_SCRN_UNKNOWN_FREESPACE;
                }
            } else {
                if(region->AdjustedFreeSpaceKB < RequiredKB) {

                    //
                    // If we get here, then the partition is large enough,
                    // but there is definitely not enough free space on it.
                    //

                    CLEAR_CLIENT_SCREEN();
                    SpDisplayStatusText(SP_STAT_EXAMINING_DISK_CONFIG,DEFAULT_STATUS_ATTRIBUTE);

                    //
                    // We check here to see if this partition is the partition we
                    // booted from (in floppyless case on amd64/x86).
                    //
                    // Also make sure we aren't trying to format the drive w/
                    // local source.
                    //
                    // If so, then the
                    // user can't format, and we give a generic 'disk too full'
                    // error.
                    //
                    if( ( region->IsLocalSource )
#if defined(_AMD64_) || defined(_X86_)
                        || ( (IsFloppylessBoot) &&
                             (region == (SpRegionFromArcName(ArcBootDevicePath, PartitionOrdinalOriginal, NULL))) )
#endif // defined(_AMD64_) || defined(_X86_)
                      ) {
                        SpStartScreen(
                            SP_SCRN_INSUFFICIENT_FREESPACE_NO_FMT,
                            3,
                            HEADER_HEIGHT+1,
                            FALSE,
                            FALSE,
                            DEFAULT_ATTRIBUTE,
                            (RequiredKB / 1024) + 1
                            );

                        SpDisplayStatusOptions(
                            DEFAULT_STATUS_ATTRIBUTE,
                            SP_STAT_ENTER_EQUALS_CONTINUE,
                            0
                            );

                        SpWaitValidKey(ValidKeys1,NULL,NULL);
                        return FALSE;
                    }
                    //
                    // To use the selected partition, we will have to reformat.
                    // Inform the user of that, and let him decide to bail
                    // right here if this is not acceptable.
                    //
                    PreconfirmFormatId = SP_SCRN_INSUFFICIENT_FREESPACE;
                }
            }

            if(PreconfirmFormatId) {

                //
                // Do a 'preconfirmation' that the user really wants
                // to reformat this drive.  We'll confirm again later
                // before actually reformatting anything.
                //

                SpStartScreen(
                    PreconfirmFormatId,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE,
                    (RequiredKB / 1024) + 1
                    );

                SpDisplayStatusOptions(
                    DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_C_EQUALS_CONTINUE_SETUP,
                    SP_STAT_ESC_EQUALS_CANCEL,
                    0
                    );

                if(SpWaitValidKey(ValidKeys2,NULL,Mnemonics1) == ASCI_ESC) {

                    //
                    // User decided to select a different partition.
                    //
                    return(FALSE);
                } // otherwise user decided to use the partition anyway.
            }
        }

    } else {

        //
        // The region is a free space. Attempt to create a partition
        // in the space.  The create routine will tell us whether this
        // was successful.  If it was not successful, then the create routine
        // will have already informed the user of why.
        //
        PDISK_REGION p;

        if(!SpPtDoCreate(region,&p,TRUE,0,0,TRUE)) {
            return(FALSE);
        }

        //
        // If we just created an extended partition and a logical drive,
        // we'll need to switch regions -- Region points to the extended partition
        // region, but we want to point to the logical drive region.
        //
        ASSERT(p);
        region = p;
        *Region = p;

        NewlyCreated = TRUE;
    }

    if(NewlyCreated) {
        SpPtRegionDescription(
            &PartitionedDisks[region->DiskNumber],
            region,
            TemporaryBuffer,
            sizeof(TemporaryBuffer)
            );

        RegionDescr = SpDupStringW(TemporaryBuffer);
    } else {
        RegionDescr = SpDupStringW(RegionDescription);
    }
    
    OtherOSOnPartition = FALSE;
    
    if( SpIsNtOnPartition( region ) )
        OtherOSOnPartition = TRUE;

#if defined(_AMD64_) || defined(_X86_)
    if(!SpIsArc())
    {
        //
        // On an amd64/x86 machine, make sure that we have a valid primary partition
        // on drive 0 (C:), for booting.
        //
        if (!IsNEC_98) { //NEC98
            if((systemPartitionRegion = SpPtValidSystemPartition()) == NULL) {

                SpStartScreen(
                    SP_SCRN_NO_VALID_C_COLON,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE,
                    HardDisks[SpDetermineDisk0()].Description
                    );

                SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_ENTER_EQUALS_CONTINUE,0);
                SpWaitValidKey(ValidKeys1,NULL,NULL);

                SpMemFree(RegionDescr);
                return(FALSE);
            }

            //
            // Make sure the system partition is active and all others are inactive.
            //
            SpPtMakeRegionActive(systemPartitionRegion);

            //
            // Warn user about win9x installations on same partition
            //
#if defined(_X86_)
            if( !OtherOSOnPartition && SpIsWin9xMsdosSys( systemPartitionRegion, &Win9xPath )){
                Win9xPathW = SpToUnicode(Win9xPath);

                if(SpIsWin4Dir(region, Win9xPathW)) {
                    OtherOSOnPartition = TRUE;

                    if (Win9xInstallationPresent) {
                        *Win9xInstallationPresent = TRUE;
                    }                        
                }
                
                SpMemFree(Win9xPathW);
            }
            
            if(Win9xPath) {
                SpMemFree(Win9xPath);
            }
#endif // defined(_X86_)
        } else {
            //
            // All of partition is bootable on NEC98,
            // so we don't need to check system partition on C:.
            //
            systemPartitionRegion = *Region;
        } //NEC98
    }
#endif // defined(_AMD64_) || defined(_X86_)

    //
    //  Display common warning for other OS on partition
    //
    if( OtherOSOnPartition && !Unattended ){

        SpDisplayScreen(SP_SCRN_OTHEROS_ON_PARTITION,3,HEADER_HEIGHT+1);

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_C_EQUALS_CONTINUE_SETUP,
            SP_STAT_ESC_EQUALS_CANCEL,
            0
            );

        if(SpWaitValidKey(ValidKeys2,NULL,Mnemonics1) == ASCI_ESC) {
            return(FALSE);
        }

        //
        // Remove the boot sets which are already present for
        // this partition in boot.ini, if any. This aids in
        // disabling the other OSes installed on the same
        // partition
        //
        //
        // NOTE : We want to really think about enforcing
        // single installs on a partition, so for the time
        // being disable it
        //
        // SpPtDeleteBootSetsForRegion(region);        
    }

    //
    // At this point, everything is fine, so commit any
    // partition changes the user may have made.
    // This won't return if an error occurs while updating the disk.
    //
    SpPtDoCommitChanges();

    //
    // Attempt to grow the partition the system will be on
    // if necessary.
    //
    if(PreInstall
    && Unattended
    && (p = SpGetSectionKeyIndex(UnattendedSifHandle,SIF_UNATTENDED,SIF_EXTENDOEMPART,0))
    && (Count = SpStringToLong(p,NULL,10))) {

        //
        // 1 means size it maximally, any other non-0 number means
        // extend by that many MB
        //
        ExtendingOemPartition = SpPtExtend(region,(Count == 1) ? 0 : Count);
    }

#if defined(_AMD64_) || defined(_X86_)
    if(!SpIsArc())
    {
    //
    // On an amd64/x86 machine, see whether we need to format C: and if so,
    // go ahead and do it.  If the system is going on C:, then don't
    // bother with this here because it will be covered in the options
    // for the target NT partition.
    //
    if(systemPartitionRegion != region) {

        PWSTR   SysPartRegionDescr;
        BOOLEAN bValidCColon;

        SpPtRegionDescription(
            &PartitionedDisks[systemPartitionRegion->DiskNumber],
            systemPartitionRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer)
            );

        SysPartRegionDescr = SpDupStringW(TemporaryBuffer);
        bValidCColon = SpPtValidateCColonFormat(SifHandle,
                                                SysPartRegionDescr,
                                                systemPartitionRegion,
                                                FALSE,
                                                SetupSourceDevicePath,
                                                DirectoryOnSetupSource);
        SpMemFree(SysPartRegionDescr);

        if(!bValidCColon) {
            SpMemFree(RegionDescr);
            return(FALSE);
        }
    }
    }else
#endif // defined(_AMD64_) || defined(_X86_)
    {
    //
    // If we are going to install on the system partition,
    // issue a special warning because it can't be converted to ntfs.
    //
    if((region->IsSystemPartition == 2) && !Unattended) {

        ULONG ValidKeys[3] = { ASCI_CR, ASCI_ESC, 0 };

        SpDisplayScreen(SP_SCRN_INSTALL_ON_SYSPART,3,HEADER_HEIGHT+1);

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            SP_STAT_ESC_EQUALS_CANCEL,
            0
            );

        if(SpWaitValidKey(ValidKeys,NULL,NULL) == ASCI_ESC) {
            SpMemFree(RegionDescr);
            return(FALSE);
        }

        AllowNtfsOptions = FALSE;
    }
    }

    if( SpPtSectorCountToMB( &(HardDisks[region->DiskNumber]),
                             region->SectorCount ) > 32*1024 ) {
        //
        //  If the partition size is greater than 32 GB, then we don't allow Fat formatting,
        //  because Fat32 does not support partitions that are that big.
        //
        AllowFatOptions = FALSE;
    }

    //
    // Present formatting/conversion options to the user.
    //

    //
    // If the partition was newly created, the only option is
    // to format the partition.  Ditto if the partition is
    // a 'bad' partition -- damaged, can't tell free space, etc.
    //
    if(NewlyCreated
    || (region->Filesystem < FilesystemFirstKnown)
    || (region->FreeSpaceKB == (ULONG)(-1))
    || (region->AdjustedFreeSpaceKB < RequiredKB)
    || RemoteBootRepartition)
    {
        if (RemoteBootRepartition) {

            //
            // For remote boot we always quick format as NTFS without
            // prompting the user.
            //

            selection = FormatOptionNtfs;
            QuickFormat = TRUE;

        } else {

            if(NewlyCreated) {

                SpStartScreen(
                    SP_SCRN_FORMAT_NEW_PART,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE,
                    HardDisks[region->DiskNumber].Description
                    );

            } else if(region->Filesystem == FilesystemNewlyCreated) {

                SpDisplayScreen(SP_SCRN_FORMAT_NEW_PART2,3,HEADER_HEIGHT+1);

            } else {

                SpStartScreen(
                    SP_SCRN_FORMAT_BAD_PART,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE,
                    RegionDescr,
                    HardDisks[region->DiskNumber].Description
                    );
            }

            selection = SpFormattingOptions(
                            AllowFatOptions,
                            AllowNtfsOptions,
                            FALSE,
                            FALSE,
                            TRUE
                            );

        }

        switch(selection) {
        case FormatOptionCancel:
            SpMemFree(RegionDescr);
            return(FALSE);

        default:
            //
            // Format the partition right here and now.
            //
            if ((selection == FormatOptionFatQuick) || (selection == FormatOptionNtfsQuick))
                QuickFormat = TRUE;
                
            Status = SpDoFormat(
                        RegionDescr,
                        region,
                        ((selection == FormatOptionNtfs) || (selection == FormatOptionNtfsQuick)) ? 
                            FilesystemNtfs : FilesystemFat,
                        FALSE,
                        TRUE,
                        QuickFormat,
                        SifHandle,
                        0,          // default cluster size
                        SetupSourceDevicePath,
                        DirectoryOnSetupSource
                        );

            SpMemFree(RegionDescr);
            return(NT_SUCCESS(Status));
        }
    }

    //
    // The partition is acceptable as-is.
    // Options are to reformat to fat or ntfs, or to leave as-is.
    // If it's FAT, converting to ntfs is an option
    // unless we're installing onto an ARC system partition.
    //
    SpStartScreen(
        SP_SCRN_FS_OPTIONS,
        3,
        HEADER_HEIGHT+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE,
        RegionDescr,
        HardDisks[region->DiskNumber].Description
        );

    //
    // If this is a winnt installation, don't want to let the user
    // reformat the local source partition!
    //
    // Also, don't let them reformat if this is the partition we booted
    // off of (in amd64/x86 floppyless boot case).
    //
    AllowFormatting = !region->IsLocalSource;
#if defined(_AMD64_) || defined(_X86_)
    if(AllowFormatting) {
        AllowFormatting = !(IsFloppylessBoot &&
               (region == (SpRegionFromArcName(ArcBootDevicePath, PartitionOrdinalOriginal, NULL))));
    }
#endif // defined(_AMD64_) || defined(_X86_)
    selection = SpFormattingOptions(
        (BOOLEAN)(AllowFormatting ? AllowFatOptions : FALSE),
        (BOOLEAN)(AllowFormatting ? AllowNtfsOptions : FALSE),
        (BOOLEAN)(AllowNtfsOptions && (BOOLEAN)(region->Filesystem != FilesystemNtfs)),
        TRUE,
        TRUE
        );

    switch(selection) {

    case FormatOptionDoNothing:
        SpMemFree(RegionDescr);
        return(TRUE);

    case FormatOptionFat:
    case FormatOptionFatQuick:
    case FormatOptionNtfs:
    case FormatOptionNtfsQuick:
        //
        // Confirm the format.
        //
        if( ( region->Filesystem != FilesystemFat ) ||
            ( ( region->Filesystem == FilesystemFat ) &&
              ( ( Count = SpGetNumberOfCompressedDrives( region ) ) == 0 ) )
            ) {

            SpStartScreen(
                SP_SCRN_CONFIRM_FORMAT,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                RegionDescr,
                HardDisks[region->DiskNumber].Description
                );

        } else {
            SpStartScreen(
                SP_SCRN_CONFIRM_FORMAT_COMPRESSED,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                RegionDescr,
                HardDisks[region->DiskNumber].Description,
                Count
                );

        }
        
        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_F_EQUALS_FORMAT,
            SP_STAT_ESC_EQUALS_CANCEL,
            0
            );

        Mnemonics2[0] = MnemonicFormat;

        if(SpWaitValidKey(ValidKeys2,NULL,Mnemonics2) == ASCI_ESC) {
            SpMemFree(RegionDescr);
            return(FALSE);
        }

        if  ((selection == FormatOptionNtfsQuick) || (selection == FormatOptionFatQuick))
            QuickFormat = TRUE;
            
        //
        // Format the partition right here and now.
        //
        Status = SpDoFormat(
                    RegionDescr,
                    region,
                    ((selection == FormatOptionNtfs) || (selection == FormatOptionNtfsQuick)) ?
                        FilesystemNtfs : FilesystemFat,
                    FALSE,
                    TRUE,
                    QuickFormat,
                    SifHandle,
                    0,          // default cluster size
                    SetupSourceDevicePath,
                    DirectoryOnSetupSource
                    );

        SpMemFree(RegionDescr);
        return(NT_SUCCESS(Status));

    case FormatOptionCancel:
        SpMemFree(RegionDescr);
        return(FALSE);

    case FormatOptionConvertToNtfs:

        if(!UnattendedOperation) {
            //
            // Confirm that the user really wants to do this.
            //
            if( ( Count = SpGetNumberOfCompressedDrives( region ) ) == 0 ) {

                SpStartScreen(
                    SP_SCRN_CONFIRM_CONVERT,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE,
                    RegionDescr,
                    HardDisks[region->DiskNumber].Description
                    );

            } else {

                SpStartScreen(
                    SP_SCRN_CONFIRM_CONVERT_COMPRESSED,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE,
                    RegionDescr,
                    HardDisks[region->DiskNumber].Description,
                    Count
                    );

            }
            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_C_EQUALS_CONVERT,
                SP_STAT_ESC_EQUALS_CANCEL,
                0
                );

            Mnemonics2[0] = MnemonicConvert;

            if(SpWaitValidKey(ValidKeys2,NULL,Mnemonics2) == ASCI_ESC) {
                SpMemFree(RegionDescr);
                return(FALSE);
            }
        }

        //
        // Remember that we need to convert the NT drive to NTFS.
        //
        ConvertNtVolumeToNtfs = TRUE;
        SpMemFree(RegionDescr);
        return(TRUE);
    }

    //
    // Should never get here.
    //
    SpMemFree(RegionDescr);
    ASSERT(FALSE);
    return(FALSE);
}


ULONG
SpFormattingOptions(
    IN BOOLEAN  AllowFatFormat,
    IN BOOLEAN  AllowNtfsFormat,
    IN BOOLEAN  AllowConvertNtfs,
    IN BOOLEAN  AllowDoNothing,
    IN BOOLEAN  AllowEscape
    )

/*++

Routine Description:

    Present a menu of formatting options and allow the user to choose
    among them.  The text describing the menu must already be present
    on-screen.

    The user may also press escape to indicate that he wants to select
    a different partition.

Arguments:

    AllowFatFormat - TRUE if the option to format the partition to
        FAT should be presented in the menu.

    AllowNtfsFormat - TRUE if the option to format the partition to
        NTFS should be presented in the menu.

    AllowConvertNtfs - TRUE if the option to convert the partition to
        NTFS should be presented in the menu.

    AllowDoNothing - TRUE if the option to leave the partition as-is
        should be presented in the menu.

Return Value:

    Value from the FormatOptions enum indicating the outcome of the
    user's interaction with the menu, which will be FormatOptionCancel
    if the user pressed escape.

--*/

{
    ULONG FatFormatOption = (ULONG)(-1);
    ULONG NtfsFormatOption = (ULONG)(-1);
    ULONG FatQFormatOption = (ULONG)(-1);
    ULONG NtfsQFormatOption = (ULONG)(-1);
    ULONG ConvertNtfsOption = (ULONG)(-1);
    ULONG DoNothingOption = (ULONG)(-1);
    ULONG OptionCount = 0;
    PVOID Menu;
    WCHAR FatQFormatText[128];
    WCHAR NtfsQFormatText[128];
    WCHAR FatFormatText[128];
    WCHAR NtfsFormatText[128];
    WCHAR ConvertNtfsText[128];
    WCHAR DoNothingText[128];
    WCHAR QuickText[128];
    ULONG MaxLength;
    ULONG Key;
    ULONG_PTR Selection;
    BOOLEAN Chosen;
    ULONG ValidKeys[4] = { ASCI_CR, KEY_F3, 0, 0 };

    if (AllowEscape) {
        ValidKeys[2] = ASCI_ESC;
    }        

    //
    // If the only thing we're allowed to do is nothing, just return.
    //
    if(!AllowFatFormat
    && !AllowNtfsFormat
    && !AllowConvertNtfs
    && AllowDoNothing) {

        return(FormatOptionDoNothing);
    }

    //
    // The FileSystem entry might be in the unattend section if we're
    // in unattend mode.  if we aren't in unattend mode, it may be in
    // the data section.
    //
    // If we fail to find it in either place, then if we're unattended
    // we return DoNothing.  If we're attended, fall through to the attended
    // case.
    //
    if( ( UnattendedSifHandle && (Menu = SpGetSectionKeyIndex(UnattendedSifHandle,SIF_UNATTENDED,L"Filesystem",0)) ) ||
        ( WinntSifHandle && (Menu = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,L"Filesystem",0)) ) ) {

        if(!_wcsicmp(Menu,L"FormatFat") && AllowFatFormat) {
            return(FormatOptionFat);
        }
        if(!_wcsicmp(Menu,L"FormatNtfs") && AllowNtfsFormat) {
            return(FormatOptionNtfs);
        }
        if(!_wcsicmp(Menu,L"ConvertNtfs") && AllowConvertNtfs) {
            return(FormatOptionConvertToNtfs);
        }
        if( (!_wcsicmp(Menu,L"ConvertNtfs")) &&
            (!AllowConvertNtfs)              &&
            (AllowDoNothing) ) {
            return(FormatOptionDoNothing);
        }
        if(!_wcsicmp(Menu,L"LeaveAlone") && AllowDoNothing) {
            return(FormatOptionDoNothing);
        }
    } else {
        if(UnattendedOperation && AllowDoNothing) {
            return(FormatOptionDoNothing);
        }
    }


    ASSERT(AllowFatFormat || AllowNtfsFormat || AllowConvertNtfs || AllowDoNothing);

    SpFormatMessage(FatFormatText  ,sizeof(FatFormatText),SP_TEXT_FAT_FORMAT);
    SpFormatMessage(NtfsFormatText ,sizeof(FatFormatText),SP_TEXT_NTFS_FORMAT);
    SpFormatMessage(ConvertNtfsText,sizeof(FatFormatText),SP_TEXT_NTFS_CONVERT);
    SpFormatMessage(DoNothingText  ,sizeof(FatFormatText),SP_TEXT_DO_NOTHING);    
    SpFormatMessage(QuickText, sizeof(QuickText), SP_TEXT_FORMAT_QUICK);

    wcscpy(FatQFormatText, FatFormatText);
    wcscat(FatQFormatText, QuickText);

    wcscpy(NtfsQFormatText, NtfsFormatText);
    wcscat(NtfsQFormatText, QuickText);

    //
    // Determine maximum length of the option strings.
    //
    MaxLength = wcslen(FatFormatText);
    MaxLength = max(wcslen(NtfsFormatText), MaxLength);
    MaxLength = max(wcslen(ConvertNtfsText), MaxLength);
    MaxLength = max(wcslen(DoNothingText), MaxLength);
    MaxLength = max(wcslen(FatQFormatText), MaxLength);
    MaxLength = max(wcslen(NtfsQFormatText), MaxLength);

    Menu = SpMnCreate(5,    
                NextMessageTopLine + 1,
                VideoVars.ScreenWidth - 5, 
                6);

    //
    // If we cannot create menu then cancel the formatting
    // request itself
    //
    if (!Menu) {
        return FormatOptionCancel;
    }

#ifdef NEW_PARTITION_ENGINE
    if(AllowNtfsFormat) {
        NtfsQFormatOption = OptionCount++;

        SpMnAddItem(Menu, 
            NtfsQFormatText,
            5,
            MaxLength,
            TRUE,
            NtfsQFormatOption);
    }

    if(AllowFatFormat) {
        FatQFormatOption = OptionCount++;

        SpMnAddItem(Menu,
            FatQFormatText,
            5,
            MaxLength,
            TRUE,
            FatQFormatOption);
    }
#endif    

    if(AllowNtfsFormat) {
        NtfsFormatOption = OptionCount++;

        SpMnAddItem(Menu,
            NtfsFormatText,
            5,
            MaxLength,
            TRUE,
            NtfsFormatOption);
    }

    if(AllowFatFormat) {
        FatFormatOption = OptionCount++;
        
        SpMnAddItem(Menu,
            FatFormatText,
            5,
            MaxLength,
            TRUE,
            FatFormatOption);
    }

    if(AllowConvertNtfs) {
        ConvertNtfsOption = OptionCount++;

        SpMnAddItem(Menu,
            ConvertNtfsText,
            5,
            MaxLength,
            TRUE,
            ConvertNtfsOption);
    }
    
    if(AllowDoNothing) {
        DoNothingOption = OptionCount++;

        SpMnAddItem(Menu,
            DoNothingText,
            5,
            MaxLength,
            TRUE,
            DoNothingOption);
    }

    //
    // Determine the default.
    // If do nothing if an option, then it is the default.
    // Otherwise, if fat format is allowed, it is the default.
    // Otherwise, the first item in the menu is the default.
    //
    if(AllowDoNothing) {
        Selection = DoNothingOption;
    } else {
        if(AllowNtfsFormat) {
            Selection = NtfsFormatOption;
        } else {
            Selection = 0;
        }
    }

    //
    // Display the menu.
    //
    Chosen = FALSE;

    do {

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            AllowEscape ? SP_STAT_ESC_EQUALS_CANCEL : 0,
            0
            );

        SpMnDisplay(Menu,
                    Selection,
                    FALSE,
                    ValidKeys,
                    NULL,
                    NULL,
                    NULL,
                    &Key,
                    &Selection);

        switch(Key) {

        case ASCI_CR:
            Chosen = TRUE;
            break;

        case ASCI_ESC:
            if (AllowEscape) {
                SpMnDestroy(Menu);
                return(FormatOptionCancel);
            }                
        }

    } while(!Chosen);

    SpMnDestroy(Menu);

    //
    // Convert chosen option to a meaningful value.
    //
    if(Selection == FatQFormatOption) {
        return(FormatOptionFatQuick);
    }

    if(Selection == NtfsQFormatOption) {
        return(FormatOptionNtfsQuick);
    }
    

    if(Selection == FatFormatOption) {
        return(FormatOptionFat);
    }

    if(Selection == NtfsFormatOption) {
        return(FormatOptionNtfs);
    }

    if(Selection == ConvertNtfsOption) {
        return(FormatOptionConvertToNtfs);
    }
    
    if(Selection == DoNothingOption) {
        return(FormatOptionDoNothing);
    }
    
    ASSERT(FALSE);
    return(FormatOptionCancel);
}

VOID
SpPtDoCommitChanges(
    VOID
    )
{
    NTSTATUS Status;
    ULONG i;
    BOOLEAN Changes;
    BOOLEAN AnyChanges = FALSE;

    CLEAR_CLIENT_SCREEN();

    //
    //  Update dblspace.ini, if necessary
    //
    SpUpdateDoubleSpaceIni();

    //
    // Iterate through the disks.
    //
    for(i=0; i<HardDiskCount; i++) {

        //
        // Tell the user what we're doing.
        // This is useful because if it hangs, there will be an
        // on-screen record of which disk we were updating.
        //
        SpDisplayStatusText(
            SP_STAT_UPDATING_DISK,
            DEFAULT_STATUS_ATTRIBUTE,
            HardDisks[i].Description
            );

        //
        // Commit any changes on this disk.
        //
        Status = SpPtCommitChanges(i,&Changes);

        //
        // If there were no changes, then we better have success.
        //
        ASSERT(NT_SUCCESS(Status) || Changes);
        if(Changes) {
            AnyChanges = TRUE;
        }

        //
        // Fatal error if we can't update the disks with
        // the new partitioning info.
        //
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPtDoCommitChanges: status %lx updating disk %u\n",Status,i));
            FatalPartitionUpdateError(HardDisks[i].Description);
        }
    }
}


VOID
FatalPartitionUpdateError(
    IN PWSTR DiskDescription
    )
{
    ULONG ValidKeys[2] = { KEY_F3,0 };

    while(1) {

        SpStartScreen(
            SP_SCRN_FATAL_FDISK_WRITE_ERROR,
            3,
            HEADER_HEIGHT+3,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            DiskDescription
            );

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        if(SpWaitValidKey(ValidKeys,NULL,NULL) == KEY_F3) {
            break;
        }
    }

    SpDone(0,FALSE,TRUE);
}


NTSTATUS
SpDoFormat(
    IN PWSTR        RegionDescr,
    IN PDISK_REGION Region,
    IN ULONG        FilesystemType,
    IN BOOLEAN      IsFailureFatal,
    IN BOOLEAN      CheckFatSize,
    IN BOOLEAN      QuickFormat,
    IN PVOID        SifHandle,
    IN DWORD        ClusterSize,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSetupSource
    )
{
    NTSTATUS Status;
    ULONGLONG RegionSizeMB;
    ULONG ValidKeys2[4] = { ASCI_CR, ASCI_ESC, KEY_F3, 0 };
    LONG Key;

    ASSERT( (FilesystemType == FilesystemFat)  ||
            (FilesystemType == FilesystemNtfs) ||
            (FilesystemType == FilesystemFat32));

    //
    // Under normal conditions, setup switches to Fat32 if the partition is big
    // enough (2GB as the cutoff). Before plowing ahead, though, we warn
    // the user that the drive will not be compatible with MS-DOS/Win95, etc.
    //

    if(FilesystemType == FilesystemFat) {
        RegionSizeMB = SpPtSectorCountToMB(
                            &(HardDisks[Region->DiskNumber]),
                            Region->SectorCount
                            );

        if(RegionSizeMB > 2048) {
            if(CheckFatSize) {
                do {
                    SpStartScreen(
                        SP_SCRN_OSPART_LARGE,
                        3,
                        HEADER_HEIGHT+1,
                        FALSE,
                        FALSE,
                        DEFAULT_ATTRIBUTE
                        );

                    SpDisplayStatusOptions(
                        DEFAULT_STATUS_ATTRIBUTE,
                        SP_STAT_ENTER_EQUALS_CONTINUE,
                        SP_STAT_ESC_EQUALS_CANCEL,
                        SP_STAT_F3_EQUALS_EXIT,
                        0
                        );

                    switch(Key = SpWaitValidKey(ValidKeys2,NULL,NULL)) {
                    case KEY_F3:
                        SpConfirmExit();
                        break;
                    case ASCI_ESC:
                        return(STATUS_UNSUCCESSFUL);
                    }
                } while(Key != ASCI_CR);
            }
            FilesystemType = FilesystemFat32;
        }
    }

    AutofrmtRunning = TRUE;
    
    Status = SpRunAutoFormat(
                SifHandle,
                RegionDescr,
                Region,
                FilesystemType,
                QuickFormat,
                ClusterSize,
                SetupSourceDevicePath,
                DirectoryOnSetupSource
                );

    AutofrmtRunning = FALSE;                

    if(!NT_SUCCESS(Status)) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to format (%lx)\n",Status));

        if(IsFailureFatal) {
            //
            // Then we can't continue (this means that the system partition
            // couldn't be formatted).
            //

            WCHAR   DriveLetterString[2];

            DriveLetterString[0] = Region->DriveLetter;
            DriveLetterString[1] = L'\0';
            SpStringToUpper(DriveLetterString);
            SpStartScreen(SP_SCRN_SYSPART_FORMAT_ERROR,
                          3,
                          HEADER_HEIGHT+1,
                          FALSE,
                          FALSE,
                          DEFAULT_ATTRIBUTE,
                          DriveLetterString
                          );
            SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);
            SpInputDrain();
            while(SpInputGetKeypress() != KEY_F3) ;
            SpDone(0,FALSE,TRUE);

        } else {
            //
            // Put up an error screen.
            //
            SpDisplayScreen(SP_SCRN_FORMAT_ERROR,3,HEADER_HEIGHT+1);
            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_ENTER_EQUALS_CONTINUE,
                0
                );

            SpInputDrain();
            while(SpInputGetKeypress() != ASCI_CR) ;

            return(Status);
        }
    } else {
        //
        //      Partition was successfuly formatted.
        //      Save the file system type on the region description.
        //
        Region->Filesystem = FilesystemType;
        SpFormatMessage( Region->TypeName,
                         sizeof(Region->TypeName),
                         SP_TEXT_FS_NAME_BASE + Region->Filesystem );
        //
        //  Reset the volume label
        //
        Region->VolumeLabel[0] = L'\0';

        // Clean up boot.ini entries that referred to this partition

        SpRemoveInstallationFromBootList(
            NULL,
            Region,
            NULL,
            NULL,
            NULL,
            PrimaryArcPath,
            NULL
            );

#if defined(_AMD64_) || defined(_X86_)
        // call again to delete the secondary Arc name
        SpRemoveInstallationFromBootList(
            NULL,
            Region,
            NULL,
            NULL,
            NULL,
            SecondaryArcPath,
            NULL
            );
#endif // defined(_AMD64_) || defined(_X86_)
    }

    return(STATUS_SUCCESS);
}

//
// dummy entry points for the cmd console
//

VOID
SpDetermineOsTypeFromBootSectorC(
    IN  PWSTR     CColonPath,
    IN  PUCHAR    BootSector,
    OUT PUCHAR   *OsDescription,
    OUT PBOOLEAN  IsNtBootcode,
    OUT PBOOLEAN  IsOtherOsInstalled,
    IN  WCHAR     DriveLetter
    )
{
#if defined(_AMD64_) || defined(_X86_)
    SpDetermineOsTypeFromBootSector(
        CColonPath,
        BootSector,
        OsDescription,
        IsNtBootcode,
        IsOtherOsInstalled,
        DriveLetter
        );
#else
    *OsDescription = NULL;
    *IsNtBootcode = FALSE;
    *IsOtherOsInstalled = FALSE;
    return;
#endif // defined(_AMD64_) || defined(_X86_)
}

NTSTATUS
pSpBootCodeIoC(
    IN     PWSTR     FilePath,
    IN     PWSTR     AdditionalFilePath, OPTIONAL
    IN     ULONG     BytesToRead,
    IN OUT PUCHAR   *Buffer,
    IN     ULONG     OpenDisposition,
    IN     BOOLEAN   Write,
    IN     ULONGLONG Offset,
    IN     ULONG     BytesPerSector
    )
{
#if defined(_AMD64_) || defined(_X86_)
    return pSpBootCodeIo(
        FilePath,
        AdditionalFilePath,
        BytesToRead,
        Buffer,
        OpenDisposition,
        Write,
        Offset,
        BytesPerSector
        );
#else
    return STATUS_NOT_IMPLEMENTED;
#endif // defined(_AMD64_) || defined(_X86_)
}


#ifdef OLD_PARTITION_ENGINE

VOID
SpPtMakeRegionActive(
    IN PDISK_REGION Region
    )

/*++

Routine Description:

    Make a partition active and make sure all other primary partitions
    are inactive.  The partition must be on disk 0.

    If a region is found active that is not the region we want to be active,
    tell the user that his other operating system will be disabled.

    NOTE: Any changes made here are not committed automatically!

Arguments:

    Region - supplies disk region descriptor for the partition to activate.
        This region must be on disk 0.

Return Value:

    None.

--*/

{
    ULONG i;
    static BOOLEAN WarnedOtherOs = FALSE;

    ASSERT(Region->DiskNumber == SpDetermineDisk0());
    if(Region->DiskNumber != SpDetermineDisk0()) {
        return;
    }

    //
    // Make sure the system partition is active and all others are inactive.
    // If we find Boot Manager, present a warning that we are going to disable it.
    // If we find some other operating system is active, present a generic warning.
    //
    for(i=0; i<PTABLE_DIMENSION; i++) {

        PON_DISK_PTE pte = &PartitionedDisks[Region->DiskNumber].MbrInfo.OnDiskMbr.PartitionTable[i];

        if(pte->ActiveFlag) {

            //
            // If this is not the region we want to be the system partition,
            // then investigate its type.
            //
            if(i != Region->TablePosition) {

                //
                // If this is boot manager, give a specific warning.
                // Otherwise, give a general warning.
                //
                if(!WarnedOtherOs && !UnattendedOperation) {

                    SpDisplayScreen(
                        (pte->SystemId == 10) ? SP_SCRN_BOOT_MANAGER : SP_SCRN_OTHER_OS_ACTIVE,
                        3,
                        HEADER_HEIGHT+1
                        );

                    SpDisplayStatusText(SP_STAT_ENTER_EQUALS_CONTINUE,DEFAULT_STATUS_ATTRIBUTE);

                    SpInputDrain();
                    while(SpInputGetKeypress() != ASCI_CR) ;

                    WarnedOtherOs = TRUE;
                }
            }
        }
    }

    ASSERT(Region->PartitionedSpace);
    ASSERT(Region->TablePosition < PTABLE_DIMENSION);
    SpPtMarkActive(Region->TablePosition);
}

#endif


BOOLEAN
SpPtValidateCColonFormat(
    IN PVOID        SifHandle,
    IN PWSTR        RegionDescr,
    IN PDISK_REGION Region,
    IN BOOLEAN      CheckOnly,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSetupSource
    )

/*++

Routine Description:

    Inspect C: to make sure it is formatted with a filesystem we
    recognize, and has enough free space on it for the boot files.

    If any of these tests fail, tell the user that we will have to
    reformat C: to continue, and give the option of returning to the
    partitioning screen or continuing anyway.

    If the user opts to continue, then format the partition to FAT
    before returning.

Arguments:

    SifHandle - supplies handle to txtsetup.sif.  This is used to fetch the
        value indicating how much space is required on C:.

    Region - supplies disk region descriptor for C:.

Return Value:

    TRUE if, upon returning from this routine, C: is acceptable.
    FALSE if not, which could mean that the user asked us not
    to format his C:, or that the format failed.

--*/

{
    ULONG MinFreeKB;
    ULONG ValidKeys[3] = { ASCI_ESC, KEY_F3, 0 };
    ULONG ValidKeys3[2] = { KEY_F3, 0 };
    ULONG ValidKeys4[4] = { ASCI_CR, ASCI_ESC, KEY_F3, 0 };
    ULONG Mnemonics[2] = { MnemonicFormat,0 };
    ULONG Key;
    BOOLEAN Confirm;
    BOOLEAN Fat32;
    NTSTATUS Status;
    ULONGLONG RegionSizeMB;
    WCHAR DriveLetterString[2];
    BOOLEAN QuickFormat = TRUE;
    ULONG FileSystem = FilesystemFat;
    BOOLEAN AllowFat = FALSE;

    //
    // Initialize the drive letter string, to be used in the various error messages
    //
    DriveLetterString[0] = Region->DriveLetter;
    DriveLetterString[1] = L'\0';
    SpStringToUpper(DriveLetterString);

    //
    // Get the minimum free space required for C:.
    //
    SpFetchDiskSpaceRequirements( SifHandle,
                                  Region->BytesPerCluster,
                                  NULL,
                                  &MinFreeKB );

  d1:
    //
    // If the user newly created the C: drive, no confirmation is
    // necessary.
    //
    if(Region->Filesystem == FilesystemNewlyCreated) {
        //
        // Shouldn't be newly created if we're checking
        // to see whether we should do an upgrade, because we
        // haven't gotten to the partitioning screen yet.
        //
        ASSERT(!CheckOnly);
        Confirm = FALSE;

    //
    // If we don't know the filesystem on C: or we can't determine the
    // free space, then we need to format the drive, and will confirm first.
    //
    } else if((Region->Filesystem == FilesystemUnknown) || (Region->FreeSpaceKB == (ULONG)(-1))) {
        if(CheckOnly) {
            return(FALSE);
        }
        SpStartScreen(SP_SCRN_C_UNKNOWN,
                      3,
                      HEADER_HEIGHT+1,
                      FALSE,
                      FALSE,
                      DEFAULT_ATTRIBUTE,
                      DriveLetterString
                      );
        Confirm = TRUE;

    //
    // If C: is too full, then we need to format over it.
    // Confirm first.
    //
    } else if(Region->FreeSpaceKB < MinFreeKB) {

        if(CheckOnly) {
            return(FALSE);
        }

        //
        // If this is a floppyless boot, then the user (probably) cannot
        // format, and has no choice but to exit Setup and free some space.
        //
        if( IsFloppylessBoot &&
           (Region == (SpRegionFromArcName(ArcBootDevicePath, PartitionOrdinalOriginal, NULL)))) {
            SpStartScreen(
                SP_SCRN_C_FULL_NO_FMT,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                MinFreeKB,
                DriveLetterString
                );

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_F3_EQUALS_EXIT,
                0
                );

            SpWaitValidKey(ValidKeys3,NULL,NULL);
            SpDone(0,FALSE,TRUE);
        }

        Confirm = TRUE;
        SpStartScreen(
            SP_SCRN_C_FULL,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            MinFreeKB,
            DriveLetterString
            );

    //
    // If all of the above tests fail, then the partition is acceptable as-is.
    //
    } else {
        return(TRUE);
    }

    //
    // If we are supposed to confirm, then do that here, forcing the
    // user to press F if he really wants to format or esc to bail.
    //
    if(Confirm) {

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ESC_EQUALS_CANCEL,
            SP_STAT_F_EQUALS_FORMAT,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        switch(SpWaitValidKey(ValidKeys,NULL,Mnemonics)) {

        case KEY_F3:

            SpConfirmExit();
            goto d1;

        case ASCI_ESC:

            //
            // User bailed.
            //
            return(FALSE);

        default:
            //
            // Must be F.
            //
            break;
        }
    }

    //
    // Whistler formats only 32GB Fat32 partitions
    //
    AllowFat = (SPPT_REGION_FREESPACE_GB(Region) <= 32);        

    //
    // Prompt the user for the formatting options
    //
    if (!UnattendedOperation) {
        ULONG Selection;

        SpDisplayScreen(SP_SCRN_FORMAT_NEW_PART3, 3, HEADER_HEIGHT+1);        

        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_SELECT,
            0);
            
        Selection = SpFormattingOptions(
                        AllowFat,
                        TRUE,
                        FALSE,
                        FALSE,
                        TRUE);
                        
        if ((Selection != FormatOptionFatQuick) &&
            (Selection != FormatOptionNtfsQuick)) {
            QuickFormat = FALSE;
        }

        if ((Selection == FormatOptionNtfs) ||
            (Selection == FormatOptionNtfsQuick)) {
            FileSystem = FilesystemNtfs;            
        }

        if (Selection == FormatOptionCancel) {
            return FALSE;   // user bailed out
        }
    } 

    if (!AllowFat && ((FileSystem == FilesystemFat) ||
            (FileSystem == FilesystemFat32))) {
        FileSystem = FilesystemNtfs;            
    }            

    if (FileSystem == FilesystemFat) {
        //
        // If the partition is larger than 2048MB then we want to make it
        // Fat32. Ask the user first.
        //
        Fat32 = FALSE;
        RegionSizeMB = SpPtSectorCountToMB(
                            &(HardDisks[Region->DiskNumber]),
                            Region->SectorCount
                            );

        if(RegionSizeMB > 2048) {

            do {
                SpStartScreen(
                    SP_SCRN_C_LARGE,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE,
                    DriveLetterString
                    );

                SpDisplayStatusOptions(
                    DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_ENTER_EQUALS_CONTINUE,
                    SP_STAT_ESC_EQUALS_CANCEL,
                    SP_STAT_F3_EQUALS_EXIT,
                    0
                    );

                switch(Key = SpWaitValidKey(ValidKeys4,NULL,NULL)) {
                case KEY_F3:
                    SpConfirmExit();
                    break;
                case ASCI_ESC:
                    return(FALSE);
                }
            } while(Key != ASCI_CR);

            Fat32 = TRUE;
        }

        FileSystem = Fat32 ? FilesystemFat32 : FilesystemFat;
    }        

    if(!Confirm) {
        //
        // Just put up an information screen so the user doesn't
        // go bonkers when we just start formatting his newly created C:.
        //
        SpStartScreen(SP_SCRN_ABOUT_TO_FORMAT_C,
                      3,
                      HEADER_HEIGHT+1,
                      FALSE,
                      FALSE,
                      DEFAULT_ATTRIBUTE,
                      DriveLetterString
                      );
                      
        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_ENTER_EQUALS_CONTINUE,0);
        SpInputDrain();
        
        while(SpInputGetKeypress() != ASCI_CR) ;
    }
    

    //
    // Do the format.
    //
    Status = SpDoFormat(
                RegionDescr,
                Region,
                FileSystem,
                TRUE,
                FALSE,
                QuickFormat,
                SifHandle,
                0,          // default cluster size
                SetupSourceDevicePath,
                DirectoryOnSetupSource
                );
                
    if(NT_SUCCESS(Status)) {
        //
        // At this point we must initialize the available free space on the partition. Otherwise,
        // SpPtValidateCColonFormat() will not recognized this partition, if it is called again.
        // This can happen if the user decides not format the partition (newly created or unformatted),
        // that he initially selected as the target partition.
        //
        SpPtDetermineRegionSpace(Region);
    }

    return(NT_SUCCESS(Status));
}

#ifndef NEW_PARTITION_ENGINE

PDISK_REGION
SpPtValidSystemPartition(
    VOID
    )

/*++

Routine Description:

    Determine whether there is a valid disk partition suitable for use
    as the system partition on an x86 machine (ie, C:).

    A primary, recognized (1/4/6/7 type) partition on disk 0 is suitable.
    If there is a partition that meets these criteria that is marked active,
    then it is the system partition, regardless of whether there are other
    partitions that also meet the criteria.

Arguments:

    None.

Return Value:

    Pointer to a disk region descriptor for a suitable system partition (C:)
    for an x86 machine.
    NULL if no such partition currently exists.

--*/

{
    PON_DISK_PTE pte;
    PDISK_REGION pRegion,pActiveRegion,pFirstRegion;
    ULONG DiskNumber;
    
    pActiveRegion = NULL;
    pFirstRegion = NULL;

    DiskNumber = SpDetermineDisk0();

#if defined(REMOTE_BOOT)
    //
    // If this is a diskless remote boot setup, there is no drive 0.
    //
    if ( DiskNumber == (ULONG)-1 ) {
        return NULL;
    }
#endif // defined(REMOTE_BOOT)

#ifdef GPT_PARTITION_ENGINE
    if (SPPT_IS_GPT_DISK(DiskNumber)) {
        return SpPtnValidSystemPartition();
    }        
#endif        
        
    //
    // Look for the active partition on drive 0
    // and for the first recognized primary partition on drive 0.
    //
    for(pRegion=PartitionedDisks[DiskNumber].PrimaryDiskRegions; pRegion; pRegion=pRegion->Next) {

        if(pRegion->PartitionedSpace) {
            UCHAR   TmpSysId;

            ASSERT(pRegion->TablePosition < PTABLE_DIMENSION);

            pte = &pRegion->MbrInfo->OnDiskMbr.PartitionTable[pRegion->TablePosition];
            ASSERT(pte->SystemId != PARTITION_ENTRY_UNUSED);

            //
            // Skip if not recognized.
            // In the repair case, we recognize FT partitions
            //
            TmpSysId = pte->SystemId;
            if( !IsContainerPartition(TmpSysId)
                && ( (PartitionNameIds[pte->SystemId] == (UCHAR)(-1)) ||
                     (pRegion->DynamicVolume && pRegion->DynamicVolumeSuitableForOS) ||
                     ((RepairWinnt || WinntSetup || SpDrEnabled() ) && pRegion->FtPartition )
                   )
              )
            {
                //
                // Remember it if it's active.
                //
                if((pte->ActiveFlag) && !pActiveRegion) {
                    pActiveRegion = pRegion;
                }

                //
                // Remember it if it's the first one we've seen.
                //
                if(!pFirstRegion) {
                    pFirstRegion = pRegion;
                }
            }
        }
    }

    //
    // If there is an active, recognized region, use it as the
    // system partition.  Otherwise, use the first primary
    // we encountered as the system partition.  If there is
    // no recognized primary, then there is no valid system partition.
    //
    return(pActiveRegion ? pActiveRegion : pFirstRegion);
}

#endif // ! NEW_PARTITION_ENGINE


ULONG
SpDetermineDisk0(
    VOID
    )

/*++

Routine Description:

    Determine the real disk 0, which may not be the same as \device\harddisk0.
    Consider the case where we have 2 scsi adapters and
    the NT drivers load in an order such that the one with the BIOS
    gets loaded *second* -- meaning that the system partition is actually
    on disk 1, not disk 0.

Arguments:

    None.

Return Value:

    NT disk ordinal suitable for use in generating nt device paths
    of the form \device\harddiskx.

--*/


{
    ULONG   DiskNumber = (ULONG)-1;
    ULONG   CurrentDisk = 0;
    WCHAR   ArcDiskName[MAX_PATH];

    //
    // Find the first harddisk (non-removable) media that the 
    // BIOS enumerated to be used for system partition
    //
    while (CurrentDisk < HardDiskCount) {
        swprintf(ArcDiskName, L"multi(0)disk(0)rdisk(%d)", CurrentDisk);       
        DiskNumber = SpArcDevicePathToDiskNumber(ArcDiskName);        

        if (DiskNumber != (ULONG)-1) {
            if (!SPPT_IS_REMOVABLE_DISK(DiskNumber)) {
                break;
            } else {
                DiskNumber = (ULONG)-1;
            }                
        }
        
        CurrentDisk++;            
    }
    
#if defined(REMOTE_BOOT)
    //
    // If this is a diskless remote boot setup, there is no drive 0.
    //
    if ( RemoteBootSetup && (DiskNumber == (ULONG)-1) && (HardDiskCount == 0) ) {
        return DiskNumber;
    }
#endif // defined(REMOTE_BOOT)

    return  (DiskNumber == (ULONG)-1) ? 0 : DiskNumber;
}


#ifdef OLD_PARTITION_ENGINE

BOOL
SpPtIsSystemPartitionRecognizable(
    VOID
    )
/*++

Routine Description:

    Determine whether the active partition is suitable for use
    as the system partition on an x86 machine (ie, C:).

    A primary, recognized (1/4/6/7 type) partition on disk 0 is suitable.

Arguments:

    None.

Return Value:

    TRUE - We found a suitable partition

    FALSE - We didn't find a suitable partition

--*/

{
    PON_DISK_PTE pte;
    PDISK_REGION pRegion;
    ULONG DiskNumber;

    //
    // Any partitions on NEC98 are primary and active. So don't need to check on NEC98.
    //
    if( IsNEC_98 ) {
	return TRUE;
    }

    DiskNumber = SpDetermineDisk0();

    //
    // Look for the active partition on drive 0
    // and for the first recognized primary partition on drive 0.
    //
    for(pRegion=PartitionedDisks[DiskNumber].PrimaryDiskRegions; pRegion; pRegion=pRegion->Next) {

        pte = &pRegion->MbrInfo->OnDiskMbr.PartitionTable[pRegion->TablePosition];

        if( (pRegion->PartitionedSpace) &&
            (pte->ActiveFlag) ) {
            //
            // We've hit the active partition.  Check its format.
            //
            if( (pRegion->Filesystem == FilesystemNtfs) ||
                (pRegion->Filesystem == FilesystemFat)  ||
                (pRegion->Filesystem == FilesystemFat32) ) {
                //
                // We recognize him.
                //
                return TRUE;
            }
        }
    }

    //
    // If we get here, we didn't find any active partitions
    // we recognize.
    //
    return FALSE;
}


PDISK_REGION
SpPtValidSystemPartitionArc(
    IN PVOID SifHandle,
    IN PWSTR SetupSourceDevicePath,
    IN PWSTR DirectoryOnSetupSource
    )

/*++

Routine Description:

    Determine whether there is a valid disk partition suitable for use
    as the system partition on an ARC machine.

    A partition is suitable if it is marked as a system partition in nvram,
    has the required free space and is formatted with the FAT filesystem.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

Return Value:

    Pointer to a disk region descriptor for a suitable system partition.
    Does not return if no such partition exists.

--*/

{
    ULONG RequiredSpaceKB = 0;
    ULONG disk,pass;
    PPARTITIONED_DISK pDisk;
    PDISK_REGION pRegion;

    //
    // Go through all the regions.  The first one that has enough free space
    // and is of the required filesystem becomes *the* system partition.
    //
    for(disk=0; disk<HardDiskCount; disk++) {

        pDisk = &PartitionedDisks[disk];

        for(pass=0; pass<2; pass++) {

            pRegion = pass ? pDisk->ExtendedDiskRegions : pDisk->PrimaryDiskRegions;
            for( ; pRegion; pRegion=pRegion->Next) {

                if(pRegion->IsSystemPartition
                && (pRegion->FreeSpaceKB != (ULONG)(-1))
                && (pRegion->Filesystem == FilesystemFat))
                {
                    ULONG TotalSizeOfFilesOnOsWinnt;

                    //
                    //  On non-x86 platformrs, specially alpha machines that in general
                    //  have small system partitions (~3 MB), we should compute the size
                    //  of the files on \os\winnt (currently, osloader.exe and hall.dll),
                    //  and consider this size as available disk space. We can do this
                    //  since these files will be overwritten by the new ones.
                    //  This fixes the problem that we see on Alpha, when the system
                    //  partition is too full.
                    //

                    SpFindSizeOfFilesInOsWinnt( SifHandle,
                                                pRegion,
                                                &TotalSizeOfFilesOnOsWinnt );
                    //
                    // Transform the size into KB
                    //
                    TotalSizeOfFilesOnOsWinnt /= 1024;

                    //
                    // Determine the amount of free space required on a system partition.
                    //
                    SpFetchDiskSpaceRequirements( SifHandle,
                                                  pRegion->BytesPerCluster,
                                                  NULL,
                                                  &RequiredSpaceKB );

                    if ((pRegion->FreeSpaceKB + TotalSizeOfFilesOnOsWinnt) >= RequiredSpaceKB) {
                       return(pRegion);
                    }
                }
            }
        }
    }

    //
    // Make sure we don't look bad.
    //
    if( RequiredSpaceKB == 0 ) {
        SpFetchDiskSpaceRequirements( SifHandle,
                                      (32 * 1024),
                                      NULL,
                                      &RequiredSpaceKB );
    }

    //
    // No valid system partition.
    //
    SpStartScreen(
        SP_SCRN_NO_SYSPARTS,
        3,
        HEADER_HEIGHT+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE,
        RequiredSpaceKB
        );

    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);

    SpInputDrain();
    while(SpInputGetKeypress() != KEY_F3) ;

    SpDone(0,FALSE,TRUE);

    //
    // Should never get here, but it keeps the compiler happy
    //

    return NULL;

}

#endif // OLD_PARTITION_ENGINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\sppartit.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    sppartit.h

Abstract:

    Public header file for partitioning module in text setup.

Author:

    Ted Miller (tedm) 27-Aug-1993

Revision History:

--*/


#ifndef _SPPARTIT_
#define _SPPARTIT_

//
// Number of entries in a partition table.
//
#define NUM_PARTITION_TABLE_ENTRIES_NEC98 16
//#if (NUM_PARTITION_TABLE_ENTRIES < NUM_PARTITION_TABLE_ENTRIES_NEC98)
#if defined(NEC_98) //NEC98
#define PTABLE_DIMENSION NUM_PARTITION_TABLE_ENTRIES_NEC98
# else //NEC98
#define PTABLE_DIMENSION NUM_PARTITION_TABLE_ENTRIES
# endif //NEC98


//
// The following table contains offsets from SP_TEXT_PARTITION_NAME_BASE
// to get the message id of the name of each type of partition.
//
extern UCHAR PartitionNameIds[256];

//
// Original ordinal is the ordinal the partition had when we started.
// OnDisk ordinal is the ordinal the partition will have when the system
//    is rebooted.
// Current ordinal is the ordinal the partition has now, if we want to
//    address it.  This may be different then OnDisk ordinal because of
//    how dynamic repartitioning is implemented.
//
typedef enum {
    PartitionOrdinalOriginal,
    PartitionOrdinalOnDisk,
    PartitionOrdinalCurrent
} PartitionOrdinalType;

//
// Define structure for an on-disk partition table entry.
//
typedef struct _REAL_DISK_PTE_NEC98 {

    UCHAR ActiveFlag;
    UCHAR SystemId;
    UCHAR Reserved[2];

    UCHAR IPLSector;
    UCHAR IPLHead;
    UCHAR IPLCylinderLow;
    UCHAR IPLCylinderHigh;

    UCHAR StartSector;
    UCHAR StartHead;
    UCHAR StartCylinderLow;
    UCHAR StartCylinderHigh;

    UCHAR EndSector;
    UCHAR EndHead;
    UCHAR EndCylinderLow;
    UCHAR EndCylinderHigh;

    UCHAR SystemName[16];
} REAL_DISK_PTE_NEC98, *PREAL_DISK_PTE_NEC98;

typedef struct _REAL_DISK_PTE {

    UCHAR ActiveFlag;

    UCHAR StartHead;
    UCHAR StartSector;
    UCHAR StartCylinder;

    UCHAR SystemId;

    UCHAR EndHead;
    UCHAR EndSector;
    UCHAR EndCylinder;

    UCHAR RelativeSectors[4];
    UCHAR SectorCount[4];

} REAL_DISK_PTE, *PREAL_DISK_PTE;


typedef struct _ON_DISK_PTE {

    UCHAR ActiveFlag;

    UCHAR StartHead;
    UCHAR StartSector;
    UCHAR StartCylinder;

    UCHAR SystemId;

    UCHAR EndHead;
    UCHAR EndSector;
    UCHAR EndCylinder;

    UCHAR RelativeSectors[4];
    UCHAR SectorCount[4];

#if defined(NEC_98) //NEC98
    //
    // add following entry for NEC98
    //
    UCHAR StartCylinderLow;  // add NEC98 original value
    UCHAR StartCylinderHigh; // not convert int13 format
    UCHAR EndCylinderLow;    // add NEC98 original value
    UCHAR EndCylinderHigh;   // not convert int13 format
    UCHAR IPLSector;         // add NEC98 original value
    UCHAR IPLHead;           //
    UCHAR IPLCylinderLow;    //
    UCHAR IPLCylinderHigh;   //
    UCHAR IPLSectors[4];     // for PC-PTOS
    UCHAR Reserved[2];       //
    UCHAR SystemName[16];    //
    UCHAR OldSystemId;       // reverse conversion for Sleep partition
    UCHAR RealDiskPosition;  // for Dynamic Partitioning on NEC98
#endif //NEC98
} ON_DISK_PTE, *PON_DISK_PTE;


//
// Define structure for an REAL on-disk master boot record.
//
typedef struct _REAL_DISK_MBR_NEC98 {

    UCHAR       JumpCode[4];

    UCHAR       IPLSignature[4];

    UCHAR       BootCode[502];

    UCHAR       AA55Signature[2];

    //REAL_DISK_PTE_NEC98 PartitionTable[NUM_PARTITION_TABLE_ENTRIES_NEC98];
    REAL_DISK_PTE_NEC98 PartitionTable[16];

} REAL_DISK_MBR_NEC98, *PREAL_DISK_MBR_NEC98;


//
// Define structure for an REAL on-disk master boot record.
//
typedef struct _REAL_DISK_MBR {

    UCHAR       BootCode[440];

    UCHAR       NTFTSignature[4];

    UCHAR       Filler[2];

    REAL_DISK_PTE PartitionTable[NUM_PARTITION_TABLE_ENTRIES];

    UCHAR       AA55Signature[2];

} REAL_DISK_MBR, *PREAL_DISK_MBR;


//
// Define structure for an DUMMY on-disk master boot record.
//
typedef struct _ON_DISK_MBR {

    UCHAR       BootCode[440];

    UCHAR       NTFTSignature[4];

    UCHAR       Filler[2];

    ON_DISK_PTE PartitionTable[PTABLE_DIMENSION];

    UCHAR       AA55Signature[2];

} ON_DISK_MBR, *PON_DISK_MBR;


typedef struct _MBR_INFO {

    struct _MBR_INFO *Next;

    ON_DISK_MBR OnDiskMbr;

    BOOLEAN     Dirty[PTABLE_DIMENSION];
    BOOLEAN     ZapBootSector[PTABLE_DIMENSION];

    USHORT      OriginalOrdinals[PTABLE_DIMENSION];
    USHORT      OnDiskOrdinals[PTABLE_DIMENSION];
    USHORT      CurrentOrdinals[PTABLE_DIMENSION];

    //
    // Fields that can be used locally for any purpose.
    //
    PVOID       UserData[PTABLE_DIMENSION];

    ULONGLONG   OnDiskSector;

} MBR_INFO, *PMBR_INFO;

typedef enum {
    EPTNone = 0,
    EPTContainerPartition,
    EPTLogicalDrive
} EXTENDED_PARTITION_TYPE;    


//
// Define structure that is used to track partitions and
// free (unpartitioned) spaces.
//
typedef struct _DISK_REGION {

    struct _DISK_REGION *Next;

    ULONG           DiskNumber;

    ULONGLONG       StartSector;
    ULONGLONG       SectorCount;

    BOOLEAN         PartitionedSpace;

    ULONG           PartitionNumber;

    //
    // The following fields are used only if PartitionedSpace is TRUE.
    //
    PMBR_INFO       MbrInfo;
    ULONG           TablePosition;

    BOOLEAN         IsSystemPartition;
    BOOLEAN         IsLocalSource;

    FilesystemType  Filesystem;
    WCHAR           TypeName[128];      // XENIX, FAT, NTFS, etc.
    ULONGLONG       FreeSpaceKB;        // -1 if can't determine.
    ULONG           BytesPerCluster;    // Number of bytes per cluster
                                        // (-1 if can't determine).
    ULONGLONG       AdjustedFreeSpaceKB; // -1 if can't determine.
                                        // if the region contains the Local Source
                                        // then this field should contain
                                        // FreeSpaceKB + LocalSourceSize
    WCHAR           VolumeLabel[20];    // First few chars of volume label
    WCHAR           DriveLetter;        // Always uppercase; 0 if none.

    BOOLEAN         FtPartition;
    BOOLEAN         DynamicVolume;
    BOOLEAN         DynamicVolumeSuitableForOS;

    EXTENDED_PARTITION_TYPE ExtendedType;
    struct _DISK_REGION     *Container;

    BOOLEAN                     Dirty;
    BOOLEAN                     Delete;
    PARTITION_INFORMATION_EX    PartInfo;
    BOOLEAN                     PartInfoDirty;
    BOOLEAN                     IsReserved;

    //
    //  The following fields are used to identify double space drives
    //  They are valid only if the file system type is FilesystemFat
    //  or FilesystemDoubleSpace
    //
    //  If the file system type is FilesystemFat and NextCompressed is not NULL,
    //  then the structure describes the host drive for compressed drives.
    //  In this case, the following fields are valid:
    //
    //      NextCompressed .... Points to a linked list of compressed drives
    //      HostDrive.......... Contains the drive letter for the drive represented
    //                          by this structure. Note that HostDrive will be
    //                          not necessarily be equal to DriveLetter
    //
    //  If the file system type is FilesystemDoubleSpace, then the structure
    //  describes a compressed drive.
    //  In this case the following fields are valid:
    //
    //      NextCompressed ..... Points to the next compressed drive in the
    //                           linked list
    //      PreviousCompressed.. Points to the previous compressed drive in
    //                           the linked list
    //      HostRegion ......... Points to the structure that describes the
    //                           host drive for the compressed drive represented
    //                           by this structure
    //      MountDrive ......... Drive letter of the drive described by this
    //                           structure (should be the same as HostRegion->HostDrive)
    //      HostDrive .......... Drive where the CVF file that represents the
    //                           this compressed drive is located.
    //      SeqNumber .......... Sequence number of the CVF file that representd
    //                           this compressed drive.
    //
    struct _DISK_REGION *NextCompressed;
    struct _DISK_REGION *PreviousCompressed;
    struct _DISK_REGION *HostRegion;
    WCHAR               MountDrive;
    WCHAR               HostDrive;
    USHORT              SeqNumber;

} DISK_REGION, *PDISK_REGION;


//
// There will be one of these structures per disk.
//
typedef struct _PARTITIONED_DISK {

    PHARD_DISK HardDisk;

    //
    //
    //
    BOOLEAN    MbrWasValid;

    //
    // We can just store the MBR here since there is only one of them.
    //
    MBR_INFO   MbrInfo;

    //
    // EBRs are stored in a linked list since there are an arbitrary number
    // of them. The one contained within this structure is a dummy and is
    // always zeroed out.
    //
    MBR_INFO  FirstEbrInfo;

    //
    // Lists of regions (partitions and free spaces)
    // on the disk and within the extended partition.
    //
    PDISK_REGION PrimaryDiskRegions;
    PDISK_REGION ExtendedDiskRegions;

} PARTITIONED_DISK, *PPARTITIONED_DISK;


extern PPARTITIONED_DISK PartitionedDisks;

//
// Disk region containing the local source directory
// in the winnt.exe setup case.
//
// If WinntSetup is TRUE, then this should be non-null.
// If it is not non-null, then we couldn't locate the local source.
//
extern PDISK_REGION LocalSourceRegion;


//
// GPT partition type strings
//
#define PARTITION_MSFT_RESERVED_STR L"Microsoft reserved partition"
#define PARTITION_LDM_METADATA_STR  L"LDM metadata partition"
#define PARTITION_LDM_DATA_STR      L"LDM data partition"
#define PARTITION_BASIC_DATA_STR    L"Basic data partition"
#define PARTITION_SYSTEM_STR        L"EFI system partition"


#if defined(REMOTE_BOOT)
//
// For remote boot, we create a fake disk region for the net(0) device.
//
extern PDISK_REGION RemoteBootTargetRegion;
#endif // defined(REMOTE_BOOT)


NTSTATUS
SpPtInitialize(
    VOID
    );

BOOLEAN
SpPtDelete(
    IN ULONG DiskNumber,
    IN ULONGLONG StartSector
    );

BOOLEAN
SpPtCreate(
    IN  ULONG         DiskNumber,
    IN  ULONGLONG     StartSector,
    IN  ULONGLONG     SizeMB,
    IN  BOOLEAN       InExtended,
    IN  PPARTITION_INFORMATION_EX PartInfo,
    OUT PDISK_REGION *ActualDiskRegion OPTIONAL
    );

BOOLEAN
SpPtExtend(
    IN PDISK_REGION Region,
    IN ULONGLONG    SizeMB      OPTIONAL
    );

VOID
SpPtQueryMinMaxCreationSizeMB(
    IN  ULONG   DiskNumber,
    IN  ULONGLONG StartSector,
    IN  BOOLEAN ForExtended,
    IN  BOOLEAN InExtended,
    OUT PULONGLONG  MinSize,
    OUT PULONGLONG  MaxSize,
    OUT PBOOLEAN ReservedRegion
    );

VOID
SpPtGetSectorLayoutInformation(
    IN  PDISK_REGION Region,
    OUT PULONGLONG   HiddenSectors,
    OUT PULONGLONG   VolumeSectorCount
    );

NTSTATUS
SpPtPrepareDisks(
    IN  PVOID         SifHandle,
    OUT PDISK_REGION *InstallRegion,
    OUT PDISK_REGION *SystemPartitionRegion,
    IN  PWSTR         SetupSourceDevicePath,
    IN  PWSTR         DirectoryOnSetupSource,
    IN  BOOLEAN       RemoteBootRepartition
    );

PDISK_REGION
SpPtAllocateDiskRegionStructure(
    IN ULONG    DiskNumber,
    IN ULONGLONG StartSector,
    IN ULONGLONG SectorCount,
    IN BOOLEAN   PartitionedSpace,
    IN PMBR_INFO MbrInfo,
    IN ULONG     TablePosition
    );

ULONG
SpPtGetOrdinal(
    IN PDISK_REGION         Region,
    IN PartitionOrdinalType OrdinalType
    );

ULONGLONG
SpPtSectorCountToMB(
    IN PHARD_DISK pHardDisk,
    IN ULONGLONG  SectorCount
    );

typedef BOOL
(*PSPENUMERATEDISKREGIONS)(
    IN PPARTITIONED_DISK Disk,
    IN PDISK_REGION Region,
    IN ULONG_PTR Context
    );

void
SpEnumerateDiskRegions(
    IN PSPENUMERATEDISKREGIONS EnumRoutine,
    IN ULONG_PTR Context
    );

BOOLEAN
SpPtRegionDescription(
    IN  PPARTITIONED_DISK pDisk,
    IN  PDISK_REGION      pRegion,
    OUT PWCHAR            Buffer,
    IN  ULONG             BufferSize
    );

PDISK_REGION
SpPtLookupRegionByStart(
    IN PPARTITIONED_DISK pDisk,
    IN BOOLEAN           ExtendedPartition,
    IN ULONGLONG         StartSector
    );    

ULONG
SpPtAlignStart(
    IN PHARD_DISK pHardDisk,
    IN ULONGLONG  StartSector,
    IN BOOLEAN    ForExtended
    );

VOID
SpPtInitializeCHSFields(
    IN  PHARD_DISK   HardDisk,
    IN  ULONGLONG    AbsoluteStartSector,
    IN  ULONGLONG    AbsoluteSectorCount,
    OUT PON_DISK_PTE pte
    );

VOID
SpPtAssignOrdinals(
    IN PPARTITIONED_DISK pDisk,
    IN BOOLEAN           InitCurrentOrdinals,
    IN BOOLEAN           InitOnDiskOrdinals,
    IN BOOLEAN           InitOriginalOrdinals
    );    


ULONG
SpGetMaxNtDirLen(VOID);

VOID
SpPtLocateSystemPartitions(VOID);

VOID
SpPtCountPrimaryPartitions(
    IN  PPARTITIONED_DISK   pDisk,
    OUT PULONG              TotalPrimaryPartitionCount,
    OUT PULONG              RecognizedPrimaryPartitionCount,
    OUT PBOOLEAN            ExtendedExists);

PDISK_REGION
SpRegionFromNtName(
    IN PWSTR                NtDeviceName,
    IN PartitionOrdinalType Type);

VOID
SppRepairWinntFiles(
    IN PVOID    LogFileHandle,
    IN PVOID    MasterSifHandle,
    IN PWSTR    SourceDevicePath,
    IN PWSTR    DirectoryOnSourceDevice,
    IN PWSTR    SystemPartition,
    IN PWSTR    SystemPartitionDirectory,
    IN PWSTR    WinntPartition,
    IN PWSTR    WinntPartitionDirectory);

VOID
SppRepairStartMenuGroupsAndItems(
    IN PWSTR    WinntPartition,
    IN PWSTR    WinntDirectory);

VOID
SppRepairHives(
    PVOID   MasterSifHandle,
    PWSTR   WinntPartition,
    PWSTR   WinntPartitionDirectory,
    PWSTR   SourceDevicePath,
    PWSTR   DirectoryOnSourceDevice);

NTSTATUS
SpDoFormat(
    IN PWSTR        RegionDescr,
    IN PDISK_REGION Region,
    IN ULONG        FilesystemType,
    IN BOOLEAN      IsFailureFatal,
    IN BOOLEAN      CheckFatSize,
    IN BOOLEAN      QuickFormat,
    IN PVOID        SifHandle,
    IN DWORD        ClusterSize,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSetupSource
    );

NTSTATUS
SpPtPartitionDiskForRemoteBoot(
    IN ULONG DiskNumber,
    OUT PDISK_REGION *RemainingRegion
    );

VOID
SpPtDeleteBootSetsForRegion(
    PDISK_REGION region
    );    

VOID
SpPtDeletePartitionsForRemoteBoot(
    PPARTITIONED_DISK pDisk,
    PDISK_REGION startRegion,
    PDISK_REGION endRegion,
    BOOLEAN Extended
    );    

WCHAR
SpGetDriveLetter(
    IN  PWSTR   DeviceName,
    OUT  PMOUNTMGR_MOUNT_POINT * MountPoint OPTIONAL
    );

WCHAR
SpDeleteDriveLetter(
    IN  PWSTR   DeviceName
    );
    
VOID
SpPtDeleteDriveLetters(
    VOID
    );    

BOOL
SpPtIsSystemPartitionRecognizable(
    VOID
    );

VOID
SpPtDetermineRegionSpace(
    IN PDISK_REGION pRegion
    );

VOID
SpCreateNewGuid(
    IN GUID *Guid
    );

UCHAR
SpPtGetPartitionType(
    IN PDISK_REGION Region
    );    

BOOLEAN
SpPtnIsRawDiskDriveLayout(
    IN PDRIVE_LAYOUT_INFORMATION_EX DriveLayout
    );

BOOLEAN
SpPtnIsRegionSpecialMBRPartition(
    IN PDISK_REGION Region
    );
    

extern ULONG    RandomSeed;
extern BOOLEAN  ValidArcSystemPartition;


//
// Only on IA64 by default the RAW disk is marked as GPT disk
//
#if defined(_IA64_)
#define SPPT_DEFAULT_PARTITION_STYLE  PARTITION_STYLE_GPT
#define SPPT_DEFAULT_DISK_STYLE DISK_FORMAT_TYPE_GPT
#else
#define SPPT_DEFAULT_PARTITION_STYLE  PARTITION_STYLE_MBR    
#define SPPT_DEFAULT_DISK_STYLE DISK_FORMAT_TYPE_PCAT
#endif

#define SPPT_MINIMUM_ESP_SIZE_MB    100
#define SPPT_MAXIMUM_ESP_SIZE_MB    1000

//
//
// Various Disk, Partition, Region related Macros
//
// NB. These are used, because it makes code more readable and
// in future these macros can represent potential interface for 
// accessing the opaque in memory partition structure
//
//
#define SPPT_GET_NEW_DISK_SIGNATURE() RtlRandom(&RandomSeed)

#define SPPT_DISK_CYLINDER_COUNT(_DiskId) (HardDisks[(_DiskId)].CylinderCount)
#define SPPT_DISK_TRACKS_PER_CYLINDER(_DiskId) (HardDisks[(_DiskId)].Geometry.TracksPerCylinder)

#define SPPT_DISK_CYLINDER_SIZE(_DiskId)  (HardDisks[(_DiskId)].SectorsPerCylinder)
#define SPPT_DISK_TRACK_SIZE(_DiskId)  (HardDisks[(_DiskId)].Geometry.SectorsPerTrack)
#define SPPT_DISK_SECTOR_SIZE(_DiskId)  (HardDisks[(_DiskId)].Geometry.BytesPerSector)
#define SPPT_DISK_IS_REMOVABLE(_DiskId) (HardDisks[(_DiskId)].Characteristics & FILE_REMOVABLE_MEDIA)

#define SPPT_REGION_SECTOR_SIZE(_Region) (SPPT_DISK_SECTOR_SIZE((_Region)->DiskNumber))

#define SPPT_DISK_SIZE(_DiskId)                     \
            (SPPT_DISK_SECTOR_SIZE((_DiskId)) *     \
             HardDisks[(_DiskId)].DiskSizeSectors)

#define SPPT_DISK_SIZE_KB(_DiskId)  (SPPT_DISK_SIZE((_DiskId)) / 1024)
#define SPPT_DISK_SIZE_MB(_DiskId)  (SPPT_DISK_SIZE_KB((_DiskId)) / 1024)
#define SPPT_DISK_SIZE_GB(_DiskId)  (SPPT_DISK_SIZE_MB((_DiskId)) / 1024)
             

#define SPPT_REGION_FREESPACE(_Region) \
            ((_Region)->SectorCount * SPPT_REGION_SECTOR_SIZE((_Region)))            
            
#define SPPT_REGION_FREESPACE_KB(_Region) (SPPT_REGION_FREESPACE((_Region)) / 1024)
#define SPPT_REGION_FREESPACE_MB(_Region) (SPPT_REGION_FREESPACE_KB((_Region)) / 1024)
#define SPPT_REGION_FREESPACE_GB(_Region) (SPPT_REGION_FREESPACE_MB((_Region)) / 1024)

#define SPPT_IS_REGION_PARTITIONED(_Region) \
            ((_Region)->PartitionedSpace)

#define SPPT_IS_REGION_FREESPACE(_Region)               \
            (((_Region)->PartitionedSpace == FALSE) &&  \
             ((_Region)->ExtendedType == EPTNone))
            
#define SPPT_SET_REGION_PARTITIONED(_Region, _Type) \
            ((_Region)->PartitionedSpace = (_Type))
            
#define SPPT_IS_REGION_DIRTY(_Region) ((_Region)->Dirty)
#define SPPT_SET_REGION_DIRTY(_Region, _Type) ((_Region)->Dirty = (_Type))

#define SPPT_GET_PARTITION_TYPE(_Region) ((_Region)->PartInfo.Mbr.PartitionType)
#define SPPT_SET_PARTITION_TYPE(_Region, _Type) \
            ((_Region)->PartInfo.Mbr.PartitionType = (_Type))

#define SPPT_IS_VALID_PRIMARY_PARTITION_TYPE(_TypeId)   \
            (IsRecognizedPartition((_TypeId)) && !IsFTPartition((_TypeId)))


#define SPPT_IS_REGION_SYSTEMPARTITION(_Region) \
            (SPPT_IS_REGION_PARTITIONED(_Region) && ((_Region)->IsSystemPartition))

#define SPPT_GET_PRIMARY_DISK_REGION(_HardDisk) \
            (PartitionedDisks[(_HardDisk)].PrimaryDiskRegions)

#define SPPT_GET_EXTENDED_DISK_REGION(_HardDisk)    \
            (PartitionedDisks[(_HardDisk)].ExtendedDiskRegions)            

#define SPPT_GET_HARDDISK(_DiskNumber) (HardDisks + (_DiskNumber))

#define SPPT_GET_PARTITIONED_DISK(_DiskNumber) (PartitionedDisks + (_DiskNumber))

#define SPPT_IS_RAW_DISK(_DiskNumber)   \
            (HardDisks[(_DiskNumber)].FormatType == DISK_FORMAT_TYPE_RAW)

#define SPPT_IS_GPT_DISK(_DiskNumber)   \
            (HardDisks[(_DiskNumber)].FormatType == DISK_FORMAT_TYPE_GPT)

#define SPPT_GET_DISK_TYPE(_DiskNumber) (HardDisks[(_DiskNumber)].FormatType)

#define SPPT_IS_MBR_DISK(_DiskNumber)   \
            (!SPPT_IS_GPT_DISK(_DiskNumber))

#define SPPT_IS_REMOVABLE_DISK(_DiskNumber) \
            (SPPT_GET_HARDDISK(_DiskNumber)->Geometry.MediaType == RemovableMedia)

#define SPPT_IS_REGION_EFI_SYSTEM_PARTITION(_Region)                        \
            (SPPT_IS_GPT_DISK((_Region)->DiskNumber) &&                     \
                (RtlEqualMemory(&((_Region)->PartInfo.Gpt.PartitionType),   \
                                    &PARTITION_SYSTEM_GUID,                 \
                                    sizeof(GUID))))

#define SPPT_IS_EFI_SYSTEM_PARTITION(_PartInfo)                         \
            (((_PartInfo)->PartitionStyle == PARTITION_STYLE_GPT) &&    \
                (RtlEqualMemory(&((_PartInfo)->Gpt.PartitionType),      \
                                    &PARTITION_SYSTEM_GUID,             \
                                    sizeof(GUID))))


#define SPPT_IS_REGION_RESERVED_PARTITION(_Region)      \
            (SPPT_IS_REGION_PARTITIONED(_Region) && ((_Region)->IsReserved))
            
                                                                        
#define SPPT_IS_REGION_MSFT_RESERVED(_Region)                               \
            (SPPT_IS_GPT_DISK((_Region)->DiskNumber) &&                     \
                (RtlEqualMemory(&((_Region)->PartInfo.Gpt.PartitionType),   \
                                    &PARTITION_MSFT_RESERVED_GUID,          \
                                    sizeof(GUID))))

#define SPPT_IS_PARTITION_MSFT_RESERVED(_PartInfo)                      \
            (((_PartInfo)->PartitionStyle == PARTITION_STYLE_GPT) &&    \
                (RtlEqualMemory(&((_PartInfo)->Gpt.PartitionType),      \
                                    &PARTITION_MSFT_RESERVED_GUID,      \
                                    sizeof(GUID))))

#define SPPT_PARTITION_NEEDS_NUMBER(_PartInfo)                              \
            ((((_PartInfo)->PartitionNumber == 0) &&                        \
              ((_PartInfo)->PartitionLength.QuadPart != 0)) &&              \
             (((_PartInfo)->PartitionStyle == PARTITION_STYLE_GPT) ?        \
                (SPPT_IS_PARTITION_MSFT_RESERVED((_PartInfo))) :            \
                ((IsContainerPartition((_PartInfo)->Mbr.PartitionType) == FALSE))))
                                    
#define SPPT_IS_BLANK_DISK(_DiskId) (SPPT_GET_HARDDISK((_DiskId))->NewDisk)
#define SPPT_SET_DISK_BLANK(_DiskId, _Blank) \
            (SPPT_GET_HARDDISK((_DiskId))->NewDisk = (_Blank))

#define SPPT_IS_REGION_LOGICAL_DRIVE(_Region)           \
            (SPPT_IS_MBR_DISK((_Region)->DiskNumber) && \
             ((_Region)->ExtendedType == EPTLogicalDrive))

#define SPPT_IS_REGION_CONTAINER_PARTITION(_Region)                 \
            (SPPT_IS_MBR_DISK((_Region)->DiskNumber) &&             \
             ((_Region)->ExtendedType == EPTContainerPartition) &&  \
              IsContainerPartition((_Region)->PartInfo.Mbr.PartitionType))

#define SPPT_IS_REGION_FIRST_CONTAINER_PARTITION(_Region)       \
            (SPPT_IS_REGION_CONTAINER_PARTITION((_Region)) &&   \
             ((_Region)->Container == NULL))

#define SPPT_IS_REGION_INSIDE_CONTAINER(_Region) ((_Region)->Container != NULL)             

#define SPPT_IS_REGION_INSIDE_FIRST_CONTAINER(_Region)          \
            (((_Region)->Container != NULL) && ((_Region)->Container->Container == NULL))

#define SPPT_IS_REGION_NEXT_TO_FIRST_CONTAINER(_Region)                         \
            ((_Region)->Container &&                                            \
             SPPT_IS_REGION_FIRST_CONTAINER_PARTITION((_Region)->Container) &&  \
             ((_Region)->Container->Next == (_Region)))
             
#define SPPT_IS_REGION_PRIMARY_PARTITION(_Region)       \
            (SPPT_IS_MBR_DISK((_Region)->DiskNumber) && \
             SPPT_IS_REGION_PARTITIONED((_Region)) &&   \
             ((_Region)->ExtendedType == EPTNone))

#define SPPT_SET_REGION_EPT(_Region, _Type) \
            ((_Region)->ExtendedType = (_Type))

#define SPPT_IS_REGION_ACTIVE_PARTITION(_Region)                  \
            (SPPT_IS_REGION_PRIMARY_PARTITION((_Region)) &&     \
             ((_Region)->PartInfo.Mbr.BootIndicator))

#define SPPT_GET_REGION_LASTSECTOR(_Region) \
            ((_Region)->StartSector + (_Region)->SectorCount)

#define SPPT_IS_REGION_DYNAMIC_VOLUME(_Region)  \
            ((_Region)->DynamicVolume)

#define SPPT_IS_REGION_LDM_METADATA(_Region) \
            (PARTITION_STYLE_GPT == (_Region)->PartInfo.PartitionStyle && \
            IsEqualGUID(&PARTITION_LDM_METADATA_GUID, &(_Region)->PartInfo.Gpt.PartitionType))

#define SPPT_IS_REGION_CONTAINED(_Container, _Contained)                    \
            (((_Container)->StartSector <= (_Contained)->StartSector) &&    \
             ((_Container)->SectorCount >= (_Contained)->SectorCount) &&    \
             (SPPT_GET_REGION_LASTSECTOR((_Container)) >                    \
                (_Contained)->StartSector))

#define SPPT_IS_REGION_MARKED_DELETE(_Region) ((_Region)->Delete)
#define SPPT_SET_REGION_DELETED(_Region, _Type) ((_Region)->Delete = (_Type))

#define SPPT_IS_VALID_SYSPART_FILESYSTEM(_FileSys)  \
            (((_FileSys) == FilesystemFat) ||       \
             ((_FileSys) == FilesystemFat32))             

#define SPPT_IS_RECOGNIZED_FILESYSTEM(_FileSys) \
            (((_FileSys) == FilesystemFat) ||   \
             ((_FileSys) == FilesystemFat32) || \
             ((_FileSys) == FilesystemNtfs))

#define SPPT_IS_REGION_FORMATTED(_Region)                           \
            (SPPT_IS_REGION_PARTITIONED(_Region) &&                 \
             SPPT_IS_RECOGNIZED_FILESYSTEM((_Region)->Filesystem))

#define SPPT_IS_NT_UPGRADE()    (IsNTUpgrade == UpgradeFull)

#define SPPT_MARK_REGION_AS_SYSTEMPARTITION(_Region, _Value)   \
            (_Region)->IsSystemPartition = (_Value)             

#define SPPT_MARK_REGION_AS_ACTIVE(_Region, _Value)             \
            (_Region)->PartInfo.Mbr.BootIndicator = (_Value)

#define SPPT_IS_REGION_RESERVED_GPT_PARTITION(_Region)      \
            (SPPT_IS_REGION_PARTITIONED(_Region) &&         \
             SPPT_IS_GPT_DISK((_Region)->DiskNumber) &&     \
             SPPT_IS_REGION_RESERVED_PARTITION(_Region))
__inline
ULONGLONG
SpPtnGetDiskMSRSizeMB(
    IN ULONG DiskId
    )
{
    return (SPPT_DISK_SIZE_GB(DiskId) >= 16) ? 128 : 32;
}

__inline
BOOLEAN
SpPtnIsValidMSRRegion(
    IN PDISK_REGION Region
    )
{
    return (Region && SPPT_IS_REGION_FREESPACE(Region) &&
            (SpPtnGetDiskMSRSizeMB(Region->DiskNumber) 
                <= SPPT_REGION_FREESPACE_MB(Region)));
}

__inline
ULONGLONG
SpPtnGetDiskESPSizeMB(
    IN  ULONG DiskId
    )
{
    return (max(SPPT_MINIMUM_ESP_SIZE_MB,
                min(SPPT_MAXIMUM_ESP_SIZE_MB,
                    SPPT_DISK_SIZE_MB(DiskId) / 100)));
}

__inline
BOOLEAN
SpPtnIsValidESPRegionSize(
    IN PDISK_REGION Region
    )
{
    BOOLEAN Result = FALSE;

    if (Region) {
        ULONGLONG EspSizeMB = SpPtnGetDiskESPSizeMB(Region->DiskNumber);
        ULONGLONG EspSizeSectors = (EspSizeMB * 1024 * 1024) / SPPT_DISK_SECTOR_SIZE(Region->DiskNumber);

        //
        // Align down required ESP size if possible
        //
        if (EspSizeSectors > SPPT_DISK_CYLINDER_SIZE(Region->DiskNumber)) {
            EspSizeSectors -= (EspSizeSectors % SPPT_DISK_CYLINDER_SIZE(Region->DiskNumber));            
        }
        //
        // Take into account that the partition may start on the second track of the disk
        //
        if(EspSizeSectors > SPPT_DISK_TRACK_SIZE(Region->DiskNumber)) {
            EspSizeSectors -= SPPT_DISK_TRACK_SIZE(Region->DiskNumber);
        }

        Result = (EspSizeSectors <= Region->SectorCount);
    }                

    return Result;
}

__inline
BOOLEAN 
SpPtnIsValidESPRegion(
    IN PDISK_REGION Region
    )
{
    return (Region && SPPT_IS_GPT_DISK(Region->DiskNumber) && 
            SPPT_IS_REGION_FREESPACE(Region) &&
            (Region == SPPT_GET_PRIMARY_DISK_REGION(Region->DiskNumber)) &&
            SpPtnIsValidESPRegionSize(Region));
}

__inline
BOOLEAN 
SpPtnIsValidESPPartition(
    IN PDISK_REGION Region
    )
{
    return (Region && SPPT_IS_GPT_DISK(Region->DiskNumber) && 
            SPPT_IS_REGION_PARTITIONED(Region) &&
            
            (Region == SPPT_GET_PRIMARY_DISK_REGION(Region->DiskNumber)) &&
            SpPtnIsValidESPRegionSize(Region));
}

__inline
VOID
SpPtnSetRegionPartitionInfo(
    IN PDISK_REGION Region,
    IN PPARTITION_INFORMATION_EX PartInfo
    )
{
    if (Region && PartInfo) {
        if (SPPT_IS_MBR_DISK(Region->DiskNumber)) {
            Region->PartInfo.Mbr.PartitionType = PartInfo->Mbr.PartitionType;
            Region->PartInfo.Mbr.BootIndicator = PartInfo->Mbr.BootIndicator;
            Region->PartInfoDirty = TRUE;
        } else if (SPPT_IS_GPT_DISK(Region->DiskNumber)) {
            Region->PartInfo.Gpt = PartInfo->Gpt;           
            Region->PartInfoDirty = TRUE;
        }
    }
}

__inline
PWSTR
SpPtnGetPartitionNameFromGUID(
    IN  GUID     *Guid,
    OUT PWSTR    NameBuffer
    )
{
    PWSTR   Name = NULL;
    
    if (Guid && NameBuffer) {
        PWSTR   PartitionName = NULL;
        
        if (IsEqualGUID(Guid, &PARTITION_MSFT_RESERVED_GUID)) {
            PartitionName = PARTITION_MSFT_RESERVED_STR;
        } else if (IsEqualGUID(Guid, &PARTITION_LDM_METADATA_GUID)) {
            PartitionName = PARTITION_LDM_METADATA_STR;
        } else if (IsEqualGUID(Guid, &PARTITION_LDM_DATA_GUID)) {
            PartitionName = PARTITION_LDM_DATA_STR;
        } else if (IsEqualGUID(Guid, &PARTITION_BASIC_DATA_GUID)) {
            PartitionName = PARTITION_BASIC_DATA_STR;
        } else if (IsEqualGUID(Guid, &PARTITION_SYSTEM_GUID)) {
            PartitionName = PARTITION_SYSTEM_STR;
        }

        if (PartitionName) {
            PARTITION_INFORMATION_GPT   GptPart;
            
            Name = NameBuffer;
            wcsncpy(NameBuffer, PartitionName, sizeof(GptPart.Name)/sizeof(WCHAR));
        } else {
            *NameBuffer = UNICODE_NULL;
        }            
    }                

    return Name;
}

#endif // ndef _SPPARTIT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\sppartit.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    sppartit.c

Abstract:

    Partitioning module in text setup.

Author:

    Ted Miller (tedm) 7-September-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop

#include <bootmbr.h>

//
// For NEC98 boot memu code.
//
#include <x86mboot.h> //NEC98

extern BOOLEAN DriveAssignFromA; //NEC98
extern BOOLEAN ConsoleRunning;
extern BOOLEAN ForceConsole;
extern BOOLEAN ValidArcSystemPartition;

extern PSETUP_COMMUNICATION  CommunicationParams;

PPARTITIONED_DISK PartitionedDisks;
//
// Disk region containing the local source directory
// in the winnt.exe setup case.
//
// If WinntSetup is TRUE and WinntFromCd is FALSE, then this
// should be non-null. If it is not non-null, then we couldn't locate
// the local source.
//
//
PDISK_REGION LocalSourceRegion;

#if defined(REMOTE_BOOT)
//
// For remote boot, we create a fake disk region for the net(0) device.
//
PDISK_REGION RemoteBootTargetRegion = NULL;
#endif // defined(REMOTE_BOOT)


//
//  RemoteBootSetup is true when Source and target paths are through the redirector
//  with possibly no system partition.
//
//  RemoteInstallSetup is true when we are doing a remote install.
//
//  RemoteSysPrepSetup is true when we are doing a remote install of a sys prep image.
//
//  RemoteSysPrepVolumeIsNtfs is true when the sysprep image we're copying down
//  represents an ntfs volume.
//

BOOLEAN RemoteBootSetup = FALSE;
BOOLEAN RemoteInstallSetup = FALSE;
BOOLEAN RemoteSysPrepSetup = FALSE;
BOOLEAN RemoteSysPrepVolumeIsNtfs = FALSE;

VOID
SpPtReadPartitionTables(
    IN PPARTITIONED_DISK pDisk
    );

VOID
SpPtInitializePartitionStructures(
    IN ULONG DiskNumber
    );

VOID
SpPtDeterminePartitionTypes(
    IN ULONG DiskNumber
    );

VOID
SpPtDetermineVolumeFreeSpace(
    IN ULONG DiskNumber
    );

VOID
SpPtLocateSystemPartitions(
    VOID
    );

VOID
SpPtDeleteDriveLetters(
    VOID
    );

ValidationValue
SpPtnGetSizeCB(
    IN ULONG Key
    );        

//begin NEC98
NTSTATUS
SpInitializeHardDisk_Nec98(
    PDISK_REGION
    );

VOID
SpReassignOnDiskOrdinals(
    IN PPARTITIONED_DISK pDisk
    );

VOID
ConvertPartitionTable(
    IN PPARTITIONED_DISK pDisk,
    IN PUCHAR            Buffer,
    IN ULONG             bps
    );
//end NEC98

NTSTATUS
SpMasterBootCode(
    IN  ULONG  DiskNumber,
    IN  HANDLE Partition0Handle,
    OUT PULONG NewNTFTSignature
    );

VOID
SpPtAssignDriveLetters(
    VOID
    );

//begin NEC98
VOID
SpPtRemapDriveLetters(
    IN BOOLEAN DriveAssign_AT
    );

VOID
SpPtUnAssignDriveLetters(
    VOID
    );

WCHAR
SpDeleteDriveLetter(
    IN  PWSTR   DeviceName
    );

VOID
SpTranslatePteInfo(
    IN PON_DISK_PTE   pPte,
    IN PREAL_DISK_PTE pRealPte,
    IN BOOLEAN        Write // into real PTE
    );

VOID
SpTranslateMbrInfo(
    IN PON_DISK_MBR   pMbr,
    IN PREAL_DISK_MBR pRealMbr,
    IN ULONG          bps,
    IN BOOLEAN        Write // into real MBR
    );

VOID
SpDetermineFormatTypeNec98(
    IN PPARTITIONED_DISK pDisk,
    IN PREAL_DISK_MBR_NEC98 pRealMbrNec98
    );
//end NEC98

PDISK_PARTITION
SpGetPartitionDescriptionFromRegistry(
    IN PVOID            Buffer,
    IN ULONG            DiskSignature,
    IN PLARGE_INTEGER   StartingOffset,
    IN PLARGE_INTEGER   Length
    );

VOID
SpPtFindLocalSourceRegionOnDynamicVolumes(
    VOID
    );

NTSTATUS
SpPtCheckDynamicVolumeForOSInstallation(
    IN PDISK_REGION Region
    );


#ifndef NEW_PARTITION_ENGINE

NTSTATUS
SpPtInitialize(
    VOID
    )
{
    ULONG             disk;
    PHARD_DISK        harddisk;
    PPARTITIONED_DISK partdisk;
    ULONG             Disk0Ordinal = 0;

    ASSERT(HardDisksDetermined);

    //
    // If there are no hard disks, bail now.
    //
    if(!HardDiskCount) {

#if defined(REMOTE_BOOT)
        //
        // If this is a diskless remote boot setup, it's OK for there to be
        // no hard disks. Otherwise, this is a fatal error.
        //
        if (!RemoteBootSetup || RemoteInstallSetup)
#endif // defined(REMOTE_BOOT)
        {
            SpDisplayScreen(SP_SCRN_NO_HARD_DRIVES,3,HEADER_HEIGHT+1);
            SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);
            SpInputDrain();
            while(SpInputGetKeypress() != KEY_F3) ;
            SpDone(0,FALSE,TRUE);
        }
        return STATUS_SUCCESS;
    }

    CLEAR_CLIENT_SCREEN();

#ifdef _X86_
    Disk0Ordinal = SpDetermineDisk0();


    //
    // If the user booted off of a high-density floppy (e.g. an ls-120), then
    // it's possible that we've locked the device in its bay.  For this
    // reason, we're going to tell the drive to unlock floppy0.
    //
    {
        NTSTATUS Status;
        IO_STATUS_BLOCK IoStatusBlock;
        OBJECT_ATTRIBUTES ObjectAttributes;
        UNICODE_STRING UnicodeString;
        HANDLE Handle;
        WCHAR OpenPath[64];
        PREVENT_MEDIA_REMOVAL   PMRemoval;

        wcscpy(OpenPath,L"\\device\\floppy0");
        INIT_OBJA(&ObjectAttributes,&UnicodeString,OpenPath);

        //
        // Open him.
        //
        Status = ZwCreateFile(
                    &Handle,
                    FILE_GENERIC_WRITE,
                    &ObjectAttributes,
                    &IoStatusBlock,
                    NULL,                           // allocation size
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_VALID_FLAGS,         // full sharing
                    FILE_OPEN,
                    FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,                           // no EAs
                    0
                    );

        if( NT_SUCCESS(Status) ) {

            //
            // Tell him to let go.
            //
            PMRemoval.PreventMediaRemoval = FALSE;
            Status = ZwDeviceIoControlFile(
                        Handle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        IOCTL_STORAGE_MEDIA_REMOVAL,
                        &PMRemoval,
                        sizeof(PMRemoval),
                        NULL,
                        0
                        );

            ZwClose(Handle);

            if( !NT_SUCCESS(Status) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "Setup: SpPtInitialize - Failed to tell the floppy to release its media.\n"));
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "Setup: SpPtInitialize - Failed to open the floppy.\n"));
        }

    }

#endif

    //
    // Allocate an array for the partitioned disk descriptors.
    //
    PartitionedDisks = SpMemAlloc(HardDiskCount * sizeof(PARTITIONED_DISK));
    if(!PartitionedDisks) {
        return(STATUS_NO_MEMORY);
    }

    RtlZeroMemory(PartitionedDisks,HardDiskCount * sizeof(PARTITIONED_DISK));


    //
    // For each hard disk attached to the system, read its partition table.
    //
    for(disk=0; disk<HardDiskCount; disk++) {
#ifdef GPT_PARTITION_ENGINE
        if (SPPT_IS_GPT_DISK(disk)) {
           SpPtnInitializeDiskDrive(disk);
           continue;
        }           
#endif

        harddisk = &HardDisks[disk];

        SpDisplayStatusText(
            SP_STAT_EXAMINING_DISK_N,
            DEFAULT_STATUS_ATTRIBUTE,
            harddisk->Description
            );

        partdisk = &PartitionedDisks[disk];

        partdisk->HardDisk = harddisk;

        //
        // Read the partition tables.
        //
        SpPtReadPartitionTables(partdisk);

        //
        // Initialize structures that are based on the partition tables.
        //
        SpPtInitializePartitionStructures(disk);

        //
        // Determine the type name for each partition on this disk.
        //
        SpPtDeterminePartitionTypes(disk);
    }

    //
    // Assign drive letters to the various partitions
    //
    SpPtAssignDriveLetters();

    //
    // DoubleSpace initialization.
    //

    //
    //  Load dblspace.ini file
    //
    if( SpLoadDblspaceIni() ) {
        SpDisplayStatusText(
            SP_STAT_EXAMINING_DISK_N,
            DEFAULT_STATUS_ATTRIBUTE,
            HardDisks[Disk0Ordinal].Description
            );

        //
        //  Build lists of compressed drives and add them to the DISK_REGION
        //  structures
        //
        SpInitializeCompressedDrives();
    }

    for(disk=0; disk<HardDiskCount; disk++) {

        SpDisplayStatusText(
            SP_STAT_EXAMINING_DISK_N,
            DEFAULT_STATUS_ATTRIBUTE,
            HardDisks[disk].Description
            );

        //
        // Determine the amount of free space on recognized volumes.
        //
        SpPtDetermineVolumeFreeSpace(disk);
    }

    if(WinntSetup && !WinntFromCd && !LocalSourceRegion) {
        //
        // If we got that far and we still don't know where the local source files are,
        // then serch for them in the dynamic volumes that are not listed on the MBR or EBR.
        //
        SpPtFindLocalSourceRegionOnDynamicVolumes();
    }

#ifdef _X86_
    //
    // If the mbr on disk 0 was not valid, inform the user that
    // continuing will mean the loss of whatever was on the disk.
    //
    // We won't actually write it out here.  We know that in order to
    // continue, the user will HAVE to create a C: partition on this drive
    // so we'll end up writing the master boot code when that change is comitted.
    //
    // Bootable partition on NEC98 is not only C: so don't check it.
    //
    // If doing a remote install or remote sysprep setup, don't check it.
    //
    if((!IsNEC_98) && //NEC98
       (!ForceConsole) &&
       (!(RemoteInstallSetup || RemoteSysPrepSetup)) &&
       (!PartitionedDisks[Disk0Ordinal].MbrWasValid)) {

        ULONG ValidKeys[2] = { KEY_F3, 0 };
        ULONG Mnemonics[2] = { MnemonicContinueSetup,0 };

        while(1) {

            SpDisplayScreen(SP_SCRN_INVALID_MBR_0,3,HEADER_HEIGHT+1);

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_C_EQUALS_CONTINUE_SETUP,
                SP_STAT_F3_EQUALS_EXIT,
                0
                );

            switch(SpWaitValidKey(ValidKeys,NULL,Mnemonics)) {
            case KEY_F3:
                SpConfirmExit();
                break;
            default:
                //
                // must be c=continue
                //
                goto x1;
            }
        }
    }

  x1:
#endif

    //
    // Figure out which partitions are system partitions.
    //
    SpPtLocateSystemPartitions();

    return(STATUS_SUCCESS);
}


VOID
SpPtDeterminePartitionTypes(
    IN  ULONG     DiskNumber
    )

/*++

Routine Description:

    Determine the partition types of each partition currently on a disk.

    The partition type is determined by the system id byte in the partition
    table entry.  If the partition type is one we recognize as a Windows NT
    compatible filesystem (types 1,4,6,7) then we dig a little deeper and
    actually determine the filesystem on the volume and use the result as
    the type name.

    Unused spaces are not given type names.

Arguments:

    DiskNumber - supplies the disk number of the disk whose partitions
        we want to inspect for determining their types.

Return Value:

    None.

--*/

{
    PPARTITIONED_DISK pDisk;
    PDISK_REGION pRegion;
    ULONG NameId;
    UCHAR SysId;
    FilesystemType FsType;
    unsigned pass;
    ULONG ValidKeys[3] = { KEY_F3,ASCI_CR,0 };

    pDisk = &PartitionedDisks[DiskNumber];

    for(pass=0; pass<2; pass++) {

        pRegion = pass ? pDisk->ExtendedDiskRegions : pDisk->PrimaryDiskRegions;
        for( ; pRegion; pRegion=pRegion->Next) {

            pRegion->TypeName[0] = 0;
            pRegion->Filesystem = FilesystemUnknown;

            //
            // If this is a free space, skip it.
            //
            if(!pRegion->PartitionedSpace) {
                continue;
            }

            //
            // Fetch the system id.
            //
//            SysId = pRegion->MbrInfo->OnDiskMbr.PartitionTable[pRegion->TablePosition].SystemId;
            SysId = SpPtGetPartitionType(pRegion);

            //
            // If this is the extended partition, skip it.
            //
            if(IsContainerPartition(SysId)) {
                continue;
            }

            //
            //  Initialize the FT related information
            //
            if( IsRecognizedPartition(SysId) &&
                (((SysId & VALID_NTFT) == VALID_NTFT) ||
                ((SysId & PARTITION_NTFT) == PARTITION_NTFT))
              ) {

                pRegion->FtPartition = TRUE;

            }

            //
            //  Initialize the dynamic volume relatated information
            //
            if( (SysId == PARTITION_LDM)
              ) {

                pRegion->DynamicVolume = TRUE;
                //
                //  Find out if the dynamic volume is suitable for OS installation
                //
                SpPtCheckDynamicVolumeForOSInstallation(pRegion);
            }

            //
            // If this is a 'recognized' partition type, then determine
            // the filesystem on it.  Otherwise use a precanned name.
            // Note that we also determine the file system type if this is an
            // FT partition of type 'mirror', that is not the mirror shadow.
            // We don't care about the shadow since we cannot determine
            // its file system anyway (we can't access sector 0 of the shadow).
            //
            if((PartitionNameIds[SysId] == (UCHAR)(-1)) ||
               ( pRegion->FtPartition ) ||
               ( pRegion->DynamicVolume )
              ) {

                FsType = SpIdentifyFileSystem(
                            HardDisks[DiskNumber].DevicePath,
                            HardDisks[DiskNumber].Geometry.BytesPerSector,
                            SpPtGetOrdinal(pRegion,PartitionOrdinalOnDisk)
                            );

                NameId = SP_TEXT_FS_NAME_BASE + FsType;

                pRegion->Filesystem = FsType;

            } else {

                NameId = SP_TEXT_PARTITION_NAME_BASE + (ULONG)PartitionNameIds[SysId];
            }

            //
            // Get the final type name from the resources.
            //
            SpFormatMessage(
                pRegion->TypeName,
                sizeof(pRegion->TypeName),
                NameId
                );
        }
    }
}

#endif // ! NEW_PARTITION_ENGINE


VOID
SpPtDetermineRegionSpace(
    IN PDISK_REGION pRegion
    )
{
    HANDLE Handle;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_SIZE_INFORMATION SizeInfo;
    ULONG r;
    NTSTATUS Status;
    WCHAR Buffer[512];
    struct LABEL_BUFFER {
        FILE_FS_VOLUME_INFORMATION VolumeInfo;
        WCHAR Label[256];
        } LabelBuffer;
    PFILE_FS_VOLUME_INFORMATION LabelInfo;
#ifdef _X86_
    static BOOLEAN LookForUndelete = TRUE;
    PWSTR UndeleteFiles[1] = { L"SENTRY" };
#endif
    PWSTR LocalSourceFiles[1] = { LocalSourceDirectory };
    ULONG ExtraSpace;

    //
    // Assume unknown.
    //
    pRegion->FreeSpaceKB = SPPT_REGION_FREESPACE_KB(pRegion);
    pRegion->AdjustedFreeSpaceKB = pRegion->FreeSpaceKB;
    pRegion->BytesPerCluster = (ULONG)(-1);

    //
    // If region is free space of an unknown type, skip it.
    //
    if(pRegion->Filesystem >= FilesystemFirstKnown) {

        //
        // Form the name of the root directory.
        //
        SpNtNameFromRegion(pRegion,Buffer,sizeof(Buffer),PartitionOrdinalCurrent);
        SpConcatenatePaths(Buffer,L"");

        //
        // Delete \pagefile.sys if it's there.  This makes disk free space
        // calculations a little easier.
        //
        SpDeleteFile(Buffer,L"pagefile.sys",NULL);

#ifdef _X86_
        //
        // Check to see if Undelete (dos 6) delete sentry or delete tracking
        // methods are in use.  If so, give a warning because the free space
        // value we will display for this drive will be off.
        //
        if(LookForUndelete
        && (pRegion->Filesystem == FilesystemFat)
        && SpNFilesExist(Buffer,UndeleteFiles,ELEMENT_COUNT(UndeleteFiles),TRUE)) {

           SpDisplayScreen(SP_SCRN_FOUND_UNDELETE,3,HEADER_HEIGHT+1);
           SpDisplayStatusText(SP_STAT_ENTER_EQUALS_CONTINUE,DEFAULT_STATUS_ATTRIBUTE);
           SpInputDrain();
           while(SpInputGetKeypress() != ASCI_CR) ;
           LookForUndelete = FALSE;
        }
#endif

        //
        // If this is a winnt setup, then look for the local source
        // on this drive if we haven't found it already.
        //
        if(WinntSetup && !WinntFromCd && !LocalSourceRegion
        && SpNFilesExist(Buffer,LocalSourceFiles,ELEMENT_COUNT(LocalSourceFiles),TRUE)) {

            PWSTR SifName;
            PVOID SifHandle;
            ULONG ErrorLine;
            NTSTATUS Status;
            PWSTR p;

            LocalSourceRegion = pRegion;
            pRegion->IsLocalSource = TRUE;

            ExtraSpace = 0;

            //
            // Open the small ini file that text setup put there to tell us
            // how much space is taken up by the local source.
            //
            wcscpy(TemporaryBuffer,Buffer);
            SpConcatenatePaths(TemporaryBuffer,LocalSourceDirectory);
            SpConcatenatePaths(TemporaryBuffer,L"size.sif");

            SifName = SpDupStringW(TemporaryBuffer);

            Status = SpLoadSetupTextFile(SifName,NULL,0,&SifHandle,&ErrorLine,TRUE,FALSE);
            if(NT_SUCCESS(Status)) {
                p = SpGetSectionKeyIndex(SifHandle,L"Data",L"Size",0);
                if(p) {
                    ExtraSpace = (ULONG)SpStringToLong(p,NULL,10);
                }
                SpFreeTextFile(SifHandle);
            }

            SpMemFree(SifName);

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: %ws is the local source (occupying %lx bytes)\n",Buffer,ExtraSpace));
        }

        //
        // Open the root directory on the partition's filesystem.
        //
        INIT_OBJA(&Obja,&UnicodeString,Buffer);
        Status = ZwCreateFile(
                    &Handle,
                    FILE_GENERIC_READ,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN,
                    FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0
                    );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ws (%lx)\n",Buffer,Status));
            //pRegion->Filesystem = FilesystemUnknown;
            return;
        }

        //
        // Fetch volume size info.
        //
        Status = ZwQueryVolumeInformationFile(
                    Handle,
                    &IoStatusBlock,
                    &SizeInfo,
                    sizeof(SizeInfo),
                    FileFsSizeInformation
                    );

        if(NT_SUCCESS(Status)) {

            LARGE_INTEGER FreeBytes;
            LARGE_INTEGER AdjustedFreeBytes;

            //
            // Calculate the amount of free space on the drive.
            // Use the Rtl multiply routine because there is a compiler
            // problem/chip errata on MIPS with 64-bit arithmetic
            // (tedm 2/28/96).
            //
            FreeBytes = RtlExtendedIntegerMultiply(
                            SizeInfo.AvailableAllocationUnits,
                            SizeInfo.SectorsPerAllocationUnit * SizeInfo.BytesPerSector
                            );

            AdjustedFreeBytes = FreeBytes;
            if(pRegion->IsLocalSource) {
                //
                // Only about 1/4 of the total space is moved during textmode.
                // Remember too that gui-mode copies the files, so only 25%
                // of this space is reusable during setup...
                //
                AdjustedFreeBytes.QuadPart += (ExtraSpace >> 2);
            }

            //
            // convert this to a number of KB.
            //
            pRegion->FreeSpaceKB = RtlExtendedLargeIntegerDivide(FreeBytes,1024,&r).LowPart;
            if(r >= 512) {
                pRegion->FreeSpaceKB++;
            }
            pRegion->AdjustedFreeSpaceKB = RtlExtendedLargeIntegerDivide(AdjustedFreeBytes,1024,&r).LowPart;
            if(r >= 512) {
                pRegion->AdjustedFreeSpaceKB++;
            }

            pRegion->BytesPerCluster = SizeInfo.SectorsPerAllocationUnit * SizeInfo.BytesPerSector;

            if( pRegion->Filesystem == FilesystemDoubleSpace ) {
                //
                //  If this the regison is a double space drive, then initialize
                //  sector count correctly, so that the drive size can be calculated
                //  correctly later on.
                //
                pRegion->SectorCount = (ULONG)(   SizeInfo.TotalAllocationUnits.QuadPart
                                                * SizeInfo.SectorsPerAllocationUnit
                                              );
            }

        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ZwQueryVolumeInformationFile for freespace failed (%lx)\n",Status));
        }

        //
        // Fetch volume label info.
        //
        Status = ZwQueryVolumeInformationFile(
                    Handle,
                    &IoStatusBlock,
                    &LabelBuffer,
                    sizeof(LabelBuffer),
                    FileFsVolumeInformation
                    );

        if(NT_SUCCESS(Status)) {

            ULONG SaveCharCount;

            LabelInfo = &LabelBuffer.VolumeInfo;

            //
            // We'll only save away the first <n> characters of
            // the volume label.
            //
            SaveCharCount = min(
                                LabelInfo->VolumeLabelLength + sizeof(WCHAR),
                                sizeof(pRegion->VolumeLabel)
                                )
                          / sizeof(WCHAR);

            if(SaveCharCount) {
                SaveCharCount--;  // allow for terminating NUL.
            }

            wcsncpy(pRegion->VolumeLabel,LabelInfo->VolumeLabel,SaveCharCount);
            pRegion->VolumeLabel[SaveCharCount] = 0;

        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ZwQueryVolumeInformationFile for label failed (%lx)\n",Status));
        }

        ZwClose(Handle);
    }
}


VOID
SpPtDetermineVolumeFreeSpace(
    IN ULONG DiskNumber
    )
{
    PPARTITIONED_DISK pDisk;
    PDISK_REGION pRegion;
    unsigned pass;
#ifdef FULL_DOUBLE_SPACE_SUPPORT
    PDISK_REGION CompressedDrive;
#endif // FULL_DOUBLE_SPACE_SUPPORT

    pDisk = &PartitionedDisks[DiskNumber];

    for(pass=0; pass<2; pass++) {

        pRegion = pass ? pDisk->ExtendedDiskRegions : pDisk->PrimaryDiskRegions;
        for( ; pRegion; pRegion=pRegion->Next) {

            SpPtDetermineRegionSpace( pRegion );
#ifdef FULL_DOUBLE_SPACE_SUPPORT
            if( ( pRegion->Filesystem == FilesystemFat ) &&
                ( pRegion->NextCompressed != NULL ) ) {
                //
                // If the region is a FAT partition that contains compressed
                // volumes, then determine the available space on each
                // compressed volume
                //
                for( CompressedDrive = pRegion->NextCompressed;
                     CompressedDrive;
                     CompressedDrive = CompressedDrive->NextCompressed ) {
                    SpPtDetermineRegionSpace( CompressedDrive );
                }
            }
#endif // FULL_DOUBLE_SPACE_SUPPORT
        }
    }
}

#ifdef OLD_PARTITION_ENGINE

VOID
SpPtLocateSystemPartitions(
    VOID
    )
{
    if(!SpIsArc()) {
        //
        // NEC98 must not write boot.ini on C:
        //
        if (!IsNEC_98) { //NEC98
            PDISK_REGION pRegion;
            ULONG Disk0Ordinal = SpDetermineDisk0();

            //
            // Note: On X86 we currently don't allow system partitions to reside
            // on GPT disks
            //            
            if (SPPT_IS_MBR_DISK(Disk0Ordinal)) {
                //
                // On x86 machines, we will mark any primary partitions on drive 0
                // as system partition, since such a partition is potentially bootable.
                //
                for(pRegion=PartitionedDisks[Disk0Ordinal].PrimaryDiskRegions; 
                    pRegion; 
                    pRegion=pRegion->Next) {
                    //
                    // Skip if free space or extended partition.
                    //
                    if(pRegion->PartitionedSpace && 
                        !IsContainerPartition(SpPtGetPartitionType(pRegion)) &&
                        (pRegion->ExtendedType == 0)) {
                        //
                        // It's a primary partition -- declare it a system partition.
                        //
                        pRegion->IsSystemPartition = TRUE;
                    }
                }
            }
        }            
    } else {
        PDISK_REGION        pRegion;
        PPARTITIONED_DISK   pDisk;
        unsigned pass;
        ULONG disk;
        PSP_BOOT_ENTRY BootEntry;

        //
        // On ARC machines, system partitions are specifically enumerated
        // in the NVRAM boot environment.
        //

        for(disk=0; disk<HardDiskCount; disk++) {

            if (SPPT_IS_GPT_DISK(disk)) {
#ifndef OLD_PARTITION_ENGINE            
                SpPtnLocateDiskSystemPartitions(disk);
#endif                
            } else {                
                pDisk = &PartitionedDisks[disk];

                for(pass=0; pass<2; pass++) {
                    pRegion = pass ? 
                        pDisk->ExtendedDiskRegions : pDisk->PrimaryDiskRegions;
                    
                    for( ; pRegion; pRegion=pRegion->Next) {
                        UCHAR SystemId = SpPtGetPartitionType(pRegion);
                        
                        //
                        // Skip if not a partition or extended partition.
                        //
                        if(pRegion->PartitionedSpace && !IsContainerPartition(SystemId)) {
                            //
                            // Get the nt pathname for this region.
                            //
                            SpNtNameFromRegion(
                                pRegion,
                                TemporaryBuffer,
                                sizeof(TemporaryBuffer),
                                PartitionOrdinalOriginal
                                );

                            //
                            // Determine if it is a system partition.
                            //
                            for(BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next) {
                                if((BootEntry->LoaderPartitionNtName != NULL) &&
                                   !_wcsicmp(BootEntry->LoaderPartitionNtName,TemporaryBuffer)) {
                                    pRegion->IsSystemPartition = TRUE;
                                    break;
                                }
                            }
                        }
                    }
                }
            }                
        }
    }
}

#endif


VOID
SpPtReadPartitionTables(
    IN PPARTITIONED_DISK pDisk
    )

/*++

Routine Description:

    Read partition tables from a given disk.

Arguments:

    pDisk - supplies pointer to disk descriptor to be filled in.

Return Value:

    None.

--*/

{
    NTSTATUS        Status;
    HANDLE          Handle;
    PUCHAR          Buffer;
    PUCHAR          UnalignedBuffer;
    PON_DISK_MBR    pBr;
    BOOLEAN         InMbr;
    ULONG           ExtendedStart;
    ULONG           NextSector;
    PMBR_INFO       pEbr,pLastEbr;
    BOOLEAN         FoundLink;
    ULONG           i,x;
    BOOLEAN         Ignore;
    ULONG           bps;
    ULONG           SectorsInBootrec;

    //
    // If this disk is off-line, nothing to do.
    //
    if(pDisk->HardDisk->Status != DiskOnLine) {
        return;
    }

    //
    // Open partition 0 of this disk.
    //
    Status = SpOpenPartition0(pDisk->HardDisk->DevicePath,&Handle,FALSE);

    if(!NT_SUCCESS(Status)) {
        pDisk->HardDisk->Status = DiskOffLine;
        return;
    }

    bps = pDisk->HardDisk->Geometry.BytesPerSector;
    if (!IsNEC_98) { //NEC98
        SectorsInBootrec = (512/bps) ? (512/bps) : 1;
    } else {
        // we read two sectors because 0 sector include BootCode , 1 sector include
        // PatitionTables. (In AT Machine,0 sector include BootCode and PartitionTable.)
        SectorsInBootrec = 2;
    } //NEC98

    //
    // Allocate and align a buffer for sector i/o.
    //
    // MBR size is not 512 on NEC98.
    //
    if (!IsNEC_98) {
        ASSERT(sizeof(ON_DISK_MBR)==512);
    }
    UnalignedBuffer = SpMemAlloc(2 * SectorsInBootrec * bps);
    Buffer = ALIGN(UnalignedBuffer,bps);

    //
    // Read the MBR (sector 0).
    //
    NextSector = 0;
#ifdef _X86_
    readmbr:
#endif
    Status = SpReadWriteDiskSectors(Handle,NextSector,SectorsInBootrec,bps,Buffer,FALSE);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to read mbr for disk %ws (%lx)\n",pDisk->HardDisk->DevicePath,Status));

        pDisk->HardDisk->Status = DiskOffLine;
        ZwClose(Handle);
        SpMemFree(UnalignedBuffer);
        return;
    }

    //
    // Move the data we just read into the partitioned disk descriptor.
    //
    if (!IsNEC_98) { //NEC98
        RtlMoveMemory(&pDisk->MbrInfo.OnDiskMbr,Buffer,sizeof(ON_DISK_MBR));

    } else {

        SpDetermineFormatTypeNec98(pDisk,(PREAL_DISK_MBR_NEC98)Buffer);

        if(pDisk->HardDisk->FormatType == DISK_FORMAT_TYPE_PCAT) {
            //
            // Move the data we just read into the partitioned disk descriptor.
            //
            SpTranslateMbrInfo(&pDisk->MbrInfo.OnDiskMbr,(PREAL_DISK_MBR)Buffer,bps,FALSE);

        } else {
            //
            // Translate patririon table information from NEC98 format to PC/AT format.
            //
            ConvertPartitionTable(pDisk,Buffer,bps);

            //
            // Read NTFT Signature at 16th sector to check if hard disk is valid.
            //
            RtlZeroMemory(Buffer,bps);
            SpReadWriteDiskSectors(Handle,16,1,bps,Buffer,FALSE);

            //
            // check "AA55" at the end of 16th sector.
            //
            if(((PUSHORT)Buffer)[bps/2 - 1] == BOOT_RECORD_SIGNATURE){
                U_ULONG(pDisk->MbrInfo.OnDiskMbr.NTFTSignature) = (((PULONG)Buffer)[0]);

            } else {
                U_ULONG(pDisk->MbrInfo.OnDiskMbr.NTFTSignature) = 0x00000000;
            }

        }
    } //NEC98

    //
    // If this MBR is not valid, initialize it.  Otherwise, fetch all logical drives
    // (EBR) info as well.
    //
    if(U_USHORT(pDisk->MbrInfo.OnDiskMbr.AA55Signature) == MBR_SIGNATURE) {

#ifdef _X86_
        //
        // No NEC98 supports EZ Drive.
        //
        if (!IsNEC_98) { //NEC98
            //
            // EZDrive support: if the first entry in the partition table is
            // type 0x55, then the actual partition table is on sector 1.
            //
            // Only for x86 because on non-x86, the firmware can't see EZDrive
            // partitions, so we don't want to install on them!
            //
            if(!NextSector && (pDisk->MbrInfo.OnDiskMbr.PartitionTable[0].SystemId == 0x55)) {
                NextSector = 1;
                pDisk->HardDisk->Int13Hooker = HookerEZDrive;
                goto readmbr;
            }
            //
            // Also check for on-track.
            //
            if(!NextSector && (pDisk->MbrInfo.OnDiskMbr.PartitionTable[0].SystemId == 0x54)) {
                pDisk->HardDisk->Int13Hooker = HookerOnTrackDiskManager;
            }
        } //NEC98
#endif

#if defined(REMOTE_BOOT)
        if (RemoteBootSetup && !RemoteInstallSetup &&
            (U_ULONG(pDisk->MbrInfo.OnDiskMbr.NTFTSignature) == 0)) {

            //
            // Uh, oh, we've got a case where the signature on the disk is 0, which is
            // bad for remote boot because we use 0 as flag for a diskless machine.  Let's
            // write a new signature on the disk.
            //
            U_ULONG(pDisk->MbrInfo.OnDiskMbr.NTFTSignature) = SpComputeSerialNumber();

            RtlMoveMemory(Buffer, &pDisk->MbrInfo.OnDiskMbr, sizeof(ON_DISK_MBR));

            Status = SpReadWriteDiskSectors(Handle,NextSector,SectorsInBootrec,bps,Buffer,TRUE);

            //
            // Ignore the status - if it failed, then it failed. The only thing that will
            // happen is that the user will get a warning that they need to reformat later.
            //
        }
#endif // defined(REMOTE_BOOT)

        pDisk->MbrWasValid = TRUE;

        pBr = &pDisk->MbrInfo.OnDiskMbr;
        InMbr = TRUE;
        ExtendedStart = 0;
        pLastEbr = NULL;

        do {

            //
            // Look at all the entries in the current boot record to see if there
            // is a link entry.
            //
            FoundLink = FALSE;

            for(i=0; i<PTABLE_DIMENSION; i++) {

                if(IsContainerPartition(pBr->PartitionTable[i].SystemId)) {

                    FoundLink = TRUE;
                    NextSector = ExtendedStart + U_ULONG(pBr->PartitionTable[i].RelativeSectors);

                    if(NextSector == 0) {
                        //
                        // Then we've got ourselves one seriously messed up boot record.  We'll
                        // just return, and present this mess as free space.
                        //
                        // NOTE: maybe we should warn the user that we are going to ignore
                        // partitions past this point because the structures are damaged.
                        //

                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Bad partition table for %ws\n",pDisk->HardDisk->DevicePath));
                        ZwClose(Handle);
                        SpMemFree(UnalignedBuffer);
                        return;
                    }

                    pEbr = SpMemAlloc(sizeof(MBR_INFO));
                    ASSERT(pEbr);
                    RtlZeroMemory(pEbr,sizeof(MBR_INFO));

                    //
                    // Sector number on the disk where this boot sector is.
                    //
                    pEbr->OnDiskSector = NextSector;

                    if(InMbr) {
                        ExtendedStart = NextSector;
                        InMbr = FALSE;
                    }

                    //
                    // Read the next boot sector and break out of the loop through
                    // the current partition table.
                    //

                    Status = SpReadWriteDiskSectors(
                                Handle,
                                NextSector,
                                SectorsInBootrec,
                                bps,
                                Buffer,
                                FALSE
                                );

                    if(!IsNEC_98) {
                        RtlMoveMemory(&pEbr->OnDiskMbr,Buffer,sizeof(ON_DISK_MBR));

                    } else {
                        if(pDisk->HardDisk->FormatType == DISK_FORMAT_TYPE_PCAT) {
                            SpTranslateMbrInfo(&pEbr->OnDiskMbr,(PREAL_DISK_MBR)Buffer,bps,FALSE);
                        } else {
                            ConvertPartitionTable(pDisk,Buffer,bps);
                        }
                    }

                    if(!NT_SUCCESS(Status)
                    || (U_USHORT(pEbr->OnDiskMbr.AA55Signature) != MBR_SIGNATURE))
                    {
                        //
                        // NOTE: maybe we should warn the user that we are going to ignore
                        // partitions part this point because we could not read the disk
                        // or the structures are damaged.
                        //

                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to read ebr on %ws at sector %lx (%lx)\n",pDisk->HardDisk->DevicePath,NextSector,Status));
                        ZwClose(Handle);
                        if(pLastEbr) {
                            SpMemFree(pEbr);
                        }
                        SpMemFree(UnalignedBuffer);
                        return;
                    }

                    pBr = &pEbr->OnDiskMbr;

                    //
                    // We just read the next boot sector.  If all that boot sector contains
                    // is a link entry, the only thing we need the boot sector for is to find
                    // the next boot sector. This happens when there is free space at the start
                    // of the extended partition.
                    //
                    Ignore = TRUE;
                    for(x=0; x<PTABLE_DIMENSION; x++) {
                        if((pBr->PartitionTable[x].SystemId != PARTITION_ENTRY_UNUSED)
                        && !IsContainerPartition(pBr->PartitionTable[x].SystemId)) {

                            Ignore = FALSE;
                            break;
                        }
                    }

                    //
                    // Link the Ebr into the logical volume list if we're not ignoring it.
                    //
                    if(!Ignore) {
                        if(pLastEbr) {
                            pLastEbr->Next = pEbr;
                        } else {
                            ASSERT(pDisk->FirstEbrInfo.Next == NULL);
                            pDisk->FirstEbrInfo.Next = pEbr;
                        }
                        pLastEbr = pEbr;
                    }

                    break;
                }
            }

        } while(FoundLink);

    } else {

        pDisk->MbrWasValid = FALSE;

        if(!IsNEC_98) {
            RtlZeroMemory(&pDisk->MbrInfo,sizeof(MBR_INFO));

        } else {
            RtlZeroMemory(Buffer,bps*SectorsInBootrec);
            SpTranslateMbrInfo(&pDisk->MbrInfo.OnDiskMbr,(PREAL_DISK_MBR)Buffer,bps,FALSE);
        }

        U_USHORT(pDisk->MbrInfo.OnDiskMbr.AA55Signature) = MBR_SIGNATURE;

        U_ULONG(pDisk->MbrInfo.OnDiskMbr.NTFTSignature) = SpComputeSerialNumber();
    }

#if 0
    if (IsNEC_98) { //NEC98
        //
        // Read NTFT Signature at 16th sector to check if hard disk is valid.
        // (I wish to replace below codes by HAL function later.)
        //
        RtlZeroMemory(Buffer,bps);
        SpReadWriteDiskSectors(Handle,
                               16,
                               1,
                               bps,
                               Buffer,
                               FALSE);
        if(((PUSHORT)Buffer)[bps/2 - 1] == BOOT_RECORD_SIGNATURE){
            U_ULONG(pDisk->MbrInfo.OnDiskMbr.NTFTSignature) = (((PULONG)Buffer)[0]);
        } else {
            U_ULONG(pDisk->MbrInfo.OnDiskMbr.NTFTSignature) = 0x00000000;
        }

    } //NEC98
#endif //0

    //
    // Close partition0.
    //
    ZwClose(Handle);

    SpMemFree(UnalignedBuffer);

    return;
}


PDISK_REGION
SpPtAllocateDiskRegionStructure(
    IN ULONG     DiskNumber,
    IN ULONGLONG StartSector,
    IN ULONGLONG SectorCount,
    IN BOOLEAN   PartitionedSpace,
    IN PMBR_INFO MbrInfo,
    IN ULONG     TablePosition
    )

/*++

Routine Description:

    Allcoate and initialize a structure of type DISK_REGION.

Arguments:

    Values to be filled into the fields of the newly allocated
    disk region structure.

Return Value:

    Pointer to new disk region structure.

--*/

{
    PDISK_REGION p;

    p = SpMemAlloc(sizeof(DISK_REGION));
    ASSERT(p);

    if(p) {

        RtlZeroMemory(p,sizeof(DISK_REGION));

        p->DiskNumber       = DiskNumber;
        p->StartSector      = StartSector;
        p->SectorCount      = SectorCount;
        p->PartitionedSpace = PartitionedSpace;
        p->MbrInfo          = MbrInfo;
        p->TablePosition    = TablePosition;
        p->FtPartition      = FALSE;
        p->DynamicVolume    = FALSE;
        p->DynamicVolumeSuitableForOS    = FALSE;
    }

    return(p);
}


VOID
SpPtInsertDiskRegionStructure(
    IN     PDISK_REGION  Region,
    IN OUT PDISK_REGION *ListHead
    )
{
    PDISK_REGION RegionCur,RegionPrev;

    //
    // Insert the region entry into the relevent list of region entries.
    // Note that these lists are kept sorted by start sector.
    //
    if(RegionCur = *ListHead) {

        if(Region->StartSector < RegionCur->StartSector) {

            //
            // Stick at head of list.
            //
            Region->Next = RegionCur;
            *ListHead = Region;

        } else {

            while(1) {

                RegionPrev = RegionCur;
                RegionCur = RegionCur->Next;

                if(RegionCur) {

                    if(RegionCur->StartSector > Region->StartSector) {

                        Region->Next = RegionCur;
                        RegionPrev->Next = Region;
                        break;
                    }

                } else {
                    //
                    // Stick at end of list.
                    //
                    RegionPrev->Next = Region;
                    break;
                }
            }

        }
    } else {
        *ListHead = Region;
    }
}



VOID
SpPtAssignOrdinals(
    IN PPARTITIONED_DISK pDisk,
    IN BOOLEAN           InitCurrentOrdinals,
    IN BOOLEAN           InitOnDiskOrdinals,
    IN BOOLEAN           InitOriginalOrdinals
    )
{
    PMBR_INFO pBrInfo;
    ULONG i;
    USHORT ordinal;

    ordinal = 0;

    for(pBrInfo=&pDisk->MbrInfo; pBrInfo; pBrInfo=pBrInfo->Next) {

        for(i=0; i<PTABLE_DIMENSION; i++) {

            PON_DISK_PTE pte = &pBrInfo->OnDiskMbr.PartitionTable[i];

            if((pte->SystemId != PARTITION_ENTRY_UNUSED)
            && !IsContainerPartition(pte->SystemId)) {

                ordinal++;

                if(InitCurrentOrdinals) {
                    pBrInfo->CurrentOrdinals[i]  = ordinal;
                }

                if(InitOnDiskOrdinals) {
                    pBrInfo->OnDiskOrdinals[i] = ordinal;
                }

                if(InitOriginalOrdinals) {
                    pBrInfo->OriginalOrdinals[i] = ordinal;
                }

            } else {

                if(InitCurrentOrdinals) {
                    pBrInfo->CurrentOrdinals[i] = 0;
                }

                if(InitOnDiskOrdinals) {
                    pBrInfo->OnDiskOrdinals[i] = 0;
                }

                if(InitOriginalOrdinals) {
                    pBrInfo->OriginalOrdinals[i] = 0;
                }
            }
        }
    }
}


VOID
SpPtInitializePartitionStructures(
    IN ULONG DiskNumber
    )

/*++

Routine Description:

    Perform additional initialization on the partition structures,
    beyond what has been performed in SpPtReadPartitionTables.

    Specifically, determine partition ordinals, offsets, and sizes.

Arguments:

    DiskNumber - disk ordinal of disk descriptor to be filled in.

Return Value:

    None.

--*/

{
    ULONG  i,pass;
    PMBR_INFO pBrInfo;
    BOOLEAN InMbr;
    ULONGLONG ExtendedStart = 0;
    ULONGLONG ExtendedEnd,ExtendedSize;
    ULONGLONG offset,size;
    ULONG bps;
    PDISK_REGION pRegion,pRegionCur,pRegionPrev;
    PPARTITIONED_DISK pDisk = &PartitionedDisks[DiskNumber];


    //
    // If this disk is off-line, nothing to do.
    //
    if(pDisk->HardDisk->Status != DiskOnLine) {
        return;
    }

    InMbr = TRUE;
    bps = pDisk->HardDisk->Geometry.BytesPerSector;

    //
    // Link the EBR chain to the MBR.
    //
    if(!IsNEC_98 || (pDisk->HardDisk->FormatType == DISK_FORMAT_TYPE_PCAT)) {
        pDisk->MbrInfo.Next = &pDisk->FirstEbrInfo;
    } else {
        //
        // There are no extended partition on NEC98.
        //
        pDisk->MbrInfo.Next = NULL;;
    } //NEC98

    for(pBrInfo=&pDisk->MbrInfo; pBrInfo; pBrInfo=pBrInfo->Next) {

        for(i=0; i<PTABLE_DIMENSION; i++) {

            PON_DISK_PTE pte = &pBrInfo->OnDiskMbr.PartitionTable[i];

            if(pte->SystemId != PARTITION_ENTRY_UNUSED) {

                if(IsContainerPartition(pte->SystemId)) {

                    //
                    // If we're in the MBR, ExtendedStart will be 0.
                    //
                    offset = ExtendedStart + U_ULONG(pte->RelativeSectors);

                    size   =  U_ULONG(pte->SectorCount);

                    //
                    // Track the start of the extended partition.
                    //

                    if(InMbr) {
                        ExtendedStart = U_ULONG(pte->RelativeSectors);
                        ExtendedEnd   = ExtendedStart + U_ULONG(pte->SectorCount);
                        ExtendedSize  = ExtendedEnd - ExtendedStart;
                    }

                } else {

                    //
                    // In the MBR, the relative sectors field is the sector offset
                    // to the partition.  In EBRs, the relative sectors field is the
                    // number of sectors between the start of the boot sector and
                    // the start of the filesystem data area.  We will consider such
                    // partitions to start with their boot sectors.
                    //
                    offset = InMbr ? U_ULONG(pte->RelativeSectors) : pBrInfo->OnDiskSector;

                    size   = U_ULONG(pte->SectorCount)
                           + (InMbr ? 0 : U_ULONG(pte->RelativeSectors));
                }

                if(InMbr || !IsContainerPartition(pte->SystemId)) {

                    //
                    // Create a region entry for this used space.
                    //
                    pRegion = SpPtAllocateDiskRegionStructure(
                                    DiskNumber,
                                    offset,
                                    size,
                                    TRUE,
                                    pBrInfo,
                                    i
                                    );

                    ASSERT(pRegion);

                    //
                    // Insert the region entry into the relevent list of region entries.
                    // Note that these lists are kept sorted by start sector.
                    //
                    SpPtInsertDiskRegionStructure(
                        pRegion,
                        InMbr ? &pDisk->PrimaryDiskRegions : &pDisk->ExtendedDiskRegions
                        );

                }
            }
        }

        if(InMbr) {
            InMbr = FALSE;
        }
    }


    //
    // Initialize partition ordinals.
    //
    SpPtAssignOrdinals(pDisk,TRUE,TRUE,TRUE);


    //
    // Now go through the regions for this disk and insert free space descriptors
    // where necessary.
    //
    // Pass 0 for the MBR; pass 1 for logical drives.
    //
    for(pass=0; pass<(ULONG)(ExtendedStart ? 2 : 1); pass++) {

        if(pRegionPrev = (pass ? pDisk->ExtendedDiskRegions : pDisk->PrimaryDiskRegions)) {

            ULONGLONG EndSector,FreeSpaceSize;

            ASSERT(pRegionPrev->PartitionedSpace);

            //
            // Handle any space occurring *before* the first partition.
            //
            if(pRegionPrev->StartSector != (pass ? ExtendedStart : 0)) {

                ASSERT(pRegionPrev->StartSector > (pass ? ExtendedStart : 0));

                pRegion = SpPtAllocateDiskRegionStructure(
                                DiskNumber,
                                pass ? ExtendedStart : 0,
                                pRegionPrev->StartSector - (pass ? ExtendedStart : 0),
                                FALSE,
                                NULL,
                                0
                                );

                ASSERT(pRegion);

                pRegion->Next = pRegionPrev;
                if(pass) {
                    // extended
                    pDisk->ExtendedDiskRegions = pRegion;
                } else {
                    // mbr
                    pDisk->PrimaryDiskRegions = pRegion;
                }
            }

            pRegionCur = pRegionPrev->Next;

            while(pRegionCur) {

                //
                // If the start of this partition plus its size is less than the
                // start of the next partition, then we need a new region.
                //
                EndSector     = pRegionPrev->StartSector + pRegionPrev->SectorCount;
                FreeSpaceSize = pRegionCur->StartSector - EndSector;

                if((LONG)FreeSpaceSize > 0) {

                    pRegion = SpPtAllocateDiskRegionStructure(
                                    DiskNumber,
                                    EndSector,
                                    FreeSpaceSize,
                                    FALSE,
                                    NULL,
                                    0
                                    );

                    ASSERT(pRegion);

                    pRegionPrev->Next = pRegion;
                    pRegion->Next = pRegionCur;
                }

                pRegionPrev = pRegionCur;
                pRegionCur = pRegionCur->Next;
            }

            //
            // Space at end of disk/extended partition.
            //
            EndSector     = pRegionPrev->StartSector + pRegionPrev->SectorCount;
            FreeSpaceSize = (pass ? ExtendedEnd : pDisk->HardDisk->DiskSizeSectors) - EndSector;

            if((LONG)FreeSpaceSize > 0) {

                pRegionPrev->Next = SpPtAllocateDiskRegionStructure(
                                        DiskNumber,
                                        EndSector,
                                        FreeSpaceSize,
                                        FALSE,
                                        NULL,
                                        0
                                        );

                ASSERT(pRegionPrev->Next);
            }

        } else {
            //
            // Show whole disk/extended partition as free.
            //
            if(pass) {
                //
                // Extended partition.
                //
                ASSERT(ExtendedStart);

                pDisk->ExtendedDiskRegions = SpPtAllocateDiskRegionStructure(
                                                DiskNumber,
                                                ExtendedStart,
                                                ExtendedSize,
                                                FALSE,
                                                NULL,
                                                0
                                                );

                ASSERT(pDisk->ExtendedDiskRegions);

            } else {
                //
                // MBR.
                //
                pDisk->PrimaryDiskRegions = SpPtAllocateDiskRegionStructure(
                                                DiskNumber,
                                                0,
                                                pDisk->HardDisk->DiskSizeSectors,
                                                FALSE,
                                                NULL,
                                                0
                                                );

                ASSERT(pDisk->PrimaryDiskRegions);
            }
        }
    }
}


VOID
SpPtCountPrimaryPartitions(
    IN  PPARTITIONED_DISK pDisk,
    OUT PULONG            TotalPrimaryPartitionCount,
    OUT PULONG            RecognizedPrimaryPartitionCount,
    OUT PBOOLEAN          ExtendedExists
    )
{
    ULONG TotalCount;
    ULONG RecognizedCount;
    ULONG u;
    UCHAR SysId;

    TotalCount = 0;
    RecognizedCount = 0;
    *ExtendedExists = FALSE;

    for(u=0; u<PTABLE_DIMENSION; u++) {

        SysId = pDisk->MbrInfo.OnDiskMbr.PartitionTable[u].SystemId;

        if(SysId != PARTITION_ENTRY_UNUSED) {

            TotalCount++;

            if(IsRecognizedPartition(SysId)
            && !(SysId & VALID_NTFT) && !(SysId & PARTITION_NTFT)) {
                RecognizedCount++;
            }

            if(IsContainerPartition(SysId)) {
                *ExtendedExists = TRUE;
            }
        }
    }

    *TotalPrimaryPartitionCount      = TotalCount;
    *RecognizedPrimaryPartitionCount = RecognizedCount;
}


PDISK_REGION
SpPtLookupRegionByStart(
    IN PPARTITIONED_DISK pDisk,
    IN BOOLEAN           ExtendedPartition,
    IN ULONGLONG         StartSector
    )

/*++

Routine Description:

    Locate a disk region, based on its starting sector.
    The starting sector must match the starting sector of an existing
    region EXACTLY for it to be considered a match.

Arguments:

    pDisk - supplies disk on which to look for the region.

    ExtendedPartition - if TRUE, then look in the extended partition to find
        a match.  Otherwise look in the main list.

    StartSector - supplies the sector number of the first sector of the region.

Return Value:

    NULL is region could not be found; otherwise a pointer to the matching
    disk region structure.

--*/

{
    PDISK_REGION Region = NULL;

#ifdef NEW_PARTITION_ENGINE

    ExtendedPartition = FALSE;
    
#else    

#ifdef GPT_PARTITION_ENGINE

    if (pDisk->HardDisk->DiskFormatType == DISK_FORMAT_TYPE_GPT))
        ExtendedPartition = FALSE;
        
#endif  // GPT_PARTITION_ENGINE

#endif  // NEW_PARTITION_ENGINE

    Region = (ExtendedPartition) ? 
                pDisk->ExtendedDiskRegions : pDisk->PrimaryDiskRegions;

    while (Region && (StartSector != Region->StartSector)) {
         Region = Region->Next;
    }

    return Region;
}


ULONG
SpPtAlignStart(
    IN PHARD_DISK pHardDisk,
    IN ULONGLONG  StartSector,
    IN BOOLEAN    ForExtended
    )

/*++

Routine Description:

    Snap a start sector to a cylinder boundary if it is not already
    on a cylinder boundary.  Any alignment that is necessary
    is performed towards the end of the disk.

    If the start sector is on cylinder 0, then alignment is to track 1
    for primary partitions, or to track 0 on cylinder 1 for extended partitions.

Arguments:

    pHardDisk - supplies disk descriptor for disk that the start sector is on.

    StartSector - supplies the sector number of the first sector of the region.

    ForExtended - if TRUE, then align the start sector as appropriate for creating
        an extended partition.  Otherwise align for a pimary partition or logical drive.

Return Value:

    New (aligned) start sector.  May or may not be different than StartSector.

--*/

{
    PDISK_GEOMETRY pGeometry;
    ULONGLONG r;
    ULONGLONG C,H,S;

    pGeometry = &pHardDisk->Geometry;

    //
    // Convert the start sector into cylinder, head, sector address.
    //
    C = StartSector / pHardDisk->SectorsPerCylinder;
    r = StartSector % pHardDisk->SectorsPerCylinder;
    H = r           / pGeometry->SectorsPerTrack;
    S = r           % pGeometry->SectorsPerTrack;

    //
    // Align as necessary.
    //
    if(C) {

        if(H || S) {

            H = S = 0;
            C++;
        }
    } else {

        //
        // Start cylinder is 0.  If the caller wants to create an
        // extended partition, bump the start cylinder up to 1.
        //
        if(ForExtended) {
            C = 1;
            H = S = 0;
        } else {

            if (!IsNEC_98 || (pHardDisk->FormatType == DISK_FORMAT_TYPE_PCAT)) { //NEC98
                //
                // Start cylinder is 0 and the caller does not want to
                // create an extended partition.  In this case, we want
                // to start the partition on cylinder 0, track 1.  If the
                // start is beyond this already, start on cylinder 1.
                //
                if((H == 0) || ((H == 1) && !S)) {
                    H = 1;
                    S = 0;
                } else {
                    H = S = 0;
                    C = 1;
                }
            } else {
                //
                // if Start cylinder is 0, force start Cylinder 1.
                //
                C = 1;
                H = S = 0;
            } //NEC98
        }
    }

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
        "SETUP:SpPtAlignStart():C:%I64d,H:%I64d,S:%I64d\n",
        C, H, S));
                            

    //
    // Now calculate and return the new start sector.
    //
    return (ULONG)((C * pHardDisk->SectorsPerCylinder) + (H * pGeometry->SectorsPerTrack) + S);
}


VOID
SpPtQueryMinMaxCreationSizeMB(
    IN  ULONG   DiskNumber,
    IN  ULONGLONG StartSector,
    IN  BOOLEAN ForExtended,
    IN  BOOLEAN InExtended,
    OUT PULONGLONG  MinSize,
    OUT PULONGLONG  MaxSize,
    OUT PBOOLEAN ReservedRegion
    )

/*++

Routine Description:

    Given the starting sector of an unpartitioned space on a disk,
    determine the minimum and maximum size in megabytes of the partition that can
    be created in the space, taking all alignment and rounding
    requirements into account.

Arguments:

    DiskNumber - ordinal of disk on which partition will be created.

    StartSector - starting sector of an unpartitioned space on the disk.

    ForExtended - if TRUE, then the caller wants to know how large an
        extended partition in that space could be.  This may be smaller
        than the general case, because an extended partition cannot start
        on cylinder 0.

    InExtended - if TRUE, then we want to create a logical drive.  Otherwise
        we want to create a primary (including extended) partition.
        If TRUE, ForExtended must be FALSE.

    MinSize - receives minimum size in megabytes for a partition in the space.

    MaxSize - receives maximum size in megabytes for a partition in the space.

    ReservedRegion - Receives a flag that indicates if the region is entirely
                     in the last cylinder. Because the last cylinder should be
                     reserved for dynamic volumes, this routine will return 0
                     as MaxSize, if the region is in such a cylinder

Return Value:

    None.

--*/

{
    PPARTITIONED_DISK pDisk;
    ULONGLONG AlignedStartSector;
    ULONGLONG AlignedEndSector;
    ULONGLONG SectorCount;
    PDISK_REGION pRegion;
    ULONGLONG MB, ByteSize;
    ULONGLONG Remainder;
    ULONGLONG LeftOverSectors;

    *MinSize = 0;
    *MaxSize = 0;
    *ReservedRegion = FALSE;

    ASSERT(DiskNumber < HardDiskCount);

    if(InExtended) {
        ASSERT(!ForExtended);
    }

    pDisk = &PartitionedDisks[DiskNumber];

    //
    // Look up this region.
    //
    pRegion = SpPtLookupRegionByStart(pDisk, InExtended, StartSector);
    ASSERT(pRegion);
    if(!pRegion) {
        return;
    }

    ASSERT(!pRegion->PartitionedSpace);
    if(pRegion->PartitionedSpace) {
        return;
    }

    //
    // If this is the first free space inside the extended partition
    // we need to decrement the StartSector so that while creating
    // first logical inside the extended we don't create the 
    // logical at one cylinder offset
    //
    if (SPPT_IS_REGION_NEXT_TO_FIRST_CONTAINER(pRegion) && StartSector) {        
        StartSector--;
    }

    //
    // Align the start to a proper boundary.
    //
    AlignedStartSector = SpPtAlignStart(pDisk->HardDisk,StartSector,ForExtended);

    //
    // Determine the maximum aligned end sector.
    //
    AlignedEndSector = StartSector + pRegion->SectorCount;

    if(LeftOverSectors = AlignedEndSector % pDisk->HardDisk->SectorsPerCylinder) {
        AlignedEndSector -= LeftOverSectors;
    }

    //
    //  Find out if last sector is in the last cylinder. If it is then align it down.
    //  This is because we should not allow the user to create a partition that contains the last cylinder.
    //  This is necessary so that we reserve a cylinder at the end of the disk, so that users
    //  can convert the disk to dynamic after the system is installed.
    //
    //  (guhans)  Don't align down if this is ASR.  ASR already takes this into account.
    //
    if(!DockableMachine && !SpDrEnabled() && SPPT_IS_MBR_DISK(DiskNumber) && (!pRegion->Next) &&
       (AlignedEndSector >= (pDisk->HardDisk->CylinderCount - 1) * pDisk->HardDisk->SectorsPerCylinder)) {
        
        AlignedEndSector -= pDisk->HardDisk->SectorsPerCylinder;

        if(AlignedEndSector == AlignedStartSector) {
            //
            // If after alignment, the partition size is zero, then the user was attempting to
            // create a partition in the last cylinder of the disk. Since this cylinder is
            // reserved for LDM (dynamic volume), just return 0 as maximum partition size, and
            // also indicate to the caller that the region is reserved.
            //
            *ReservedRegion = TRUE;
            *MinSize = 0;
            *MaxSize = 0;
            return;
        }
    }

    //
    // Calculate the number of sectors in the properly aligned space.
    //
    SectorCount = AlignedEndSector - AlignedStartSector;

    //
    // Convert sectors to MB.
    //
    ByteSize = SectorCount * pDisk->HardDisk->Geometry.BytesPerSector;
    MB = ByteSize / (1024 * 1024);
    Remainder = ByteSize % (1024 * 1024);

    //
    // If the remainder was greater than or equal to a half meg,
    // bump up the number of megabytes.
    //
    *MaxSize = (MB + ((Remainder >= (512 * 1024)) ? 1 : 0));

    //
    // The mimimum size is one cylinder except that if a cylinder
    // is smaller than 1 meg, the min size is 1 meg.
    //
    ByteSize = pDisk->HardDisk->SectorsPerCylinder *
                pDisk->HardDisk->Geometry.BytesPerSector;

    *MinSize = ByteSize / (1024 * 1024);
    Remainder = ByteSize % (1024 * 1024);

    if((*MinSize == 0) || (Remainder >= (512 * 1024))) {
        (*MinSize)++;
    }
}


ULONGLONG
SpPtSectorCountToMB(
    IN PHARD_DISK pHardDisk,
    IN ULONGLONG  SectorCount
    )
{
    ULONGLONG ByteCount;
    ULONGLONG MB,r;

    //
    // Calculate the number of bytes that this number of
    // sectors represents.
    //
    ByteCount = (pHardDisk->Geometry.BytesPerSector * SectorCount);

    //
    // Calculate the number of megabytes this represents.
    //
    r = ByteCount % (1024 * 1204);
    MB = ByteCount / (1024 * 1024);

    //
    // Round up if necessary.
    //
    if(r >= (512*1024)) {
        MB++;
    }

    return (MB);
}


VOID
SpPtInitializeCHSFields(
    IN  PHARD_DISK   HardDisk,
    IN  ULONGLONG    AbsoluteStartSector,
    IN  ULONGLONG    AbsoluteSectorCount,
    OUT PON_DISK_PTE pte
    )
{
    ULONGLONG sC,sH,sS,r;
    ULONGLONG eC,eH,eS;
    ULONGLONG LastSector;


    sC = AbsoluteStartSector / HardDisk->SectorsPerCylinder;
    r  = AbsoluteStartSector % HardDisk->SectorsPerCylinder;
    sH = r                   / HardDisk->Geometry.SectorsPerTrack;
    sS = r                   % HardDisk->Geometry.SectorsPerTrack;

    LastSector = AbsoluteStartSector + AbsoluteSectorCount - 1;

    eC = LastSector / HardDisk->SectorsPerCylinder;
    r  = LastSector % HardDisk->SectorsPerCylinder;
    eH = r          / HardDisk->Geometry.SectorsPerTrack;
    eS = r          % HardDisk->Geometry.SectorsPerTrack;

    //
    // If this partition extends past the 1024th cylinder,
    // place reasonable values in the CHS fields.
    //
#if defined(NEC_98) //NEC98
    if (!IsNEC_98 || (HardDisk->FormatType == DISK_FORMAT_TYPE_PCAT)) { //NEC98
#endif //NEC98
        if(eC >= 1024) {

            sC = 1023;
            sH = HardDisk->Geometry.TracksPerCylinder - 1;
            sS = HardDisk->Geometry.SectorsPerTrack - 1;

            eC = sC;
            eH = sH;
            eS = sS;
        }

        //
        // Pack the CHS values into int13 format.
        //
        pte->StartCylinder =  (UCHAR)sC;
        pte->StartHead     =  (UCHAR)sH;
        pte->StartSector   =  (UCHAR)((sS & 0x3f) | ((sC >> 2) & 0xc0)) + 1;

        pte->EndCylinder   =  (UCHAR)eC;
        pte->EndHead       =  (UCHAR)eH;
        pte->EndSector     =  (UCHAR)((eS & 0x3f) | ((eC >> 2) & 0xc0)) + 1;
#if defined(NEC_98) //NEC98
    } else {
        //
        // No NEC98 have "1024th cylinder limit".
        //
        pte->StartCylinderLow  = (UCHAR)sC;
        pte->StartCylinderHigh = (UCHAR)(sC >> 4);
        pte->StartHead         = (UCHAR)sH;
        pte->StartSector       = (UCHAR)sS;

        pte->EndCylinderLow    = (UCHAR)eC;
        pte->EndCylinderHigh   = (UCHAR)(eC >> 4);
        pte->EndHead           = (UCHAR)eH;
        pte->EndSector         = (UCHAR)eS;
    } //NEC98
#endif //NEC98

}


#ifndef NEW_PARTITION_ENGINE

BOOLEAN
SpPtCreate(
    IN  ULONG         DiskNumber,
    IN  ULONGLONG     StartSector,
    IN  ULONGLONG     SizeMB,
    IN  BOOLEAN       InExtended,
    IN  PPARTITION_INFORMATION_EX PartInfo,
    OUT PDISK_REGION *ActualDiskRegion OPTIONAL
    )
/*++

Routine Description:

    Create a partition in a given free space.
Arguments:

    DiskNumber - supplies the number of the disk on which we are
        creating the partition.

    StartSector - supplies the start sector of the free space in which
        the parititon is to be created.  This must exactly match the
        start sector of the free space, and can be in either the primary
        space list or the list of spaces in the extended partition.

    SizeMB - supplies the size in megabytes of the partition.

    InExtended - if TRUE, then the free space is within the extended partition,
        and thus we are creating a logical drive.  If FALSE, then the free
        space is an ordinary unpartitioned space, and we are creating a
        primary partition.

    SysId - supplies the system id to give the partition.  This may not
        be 5/f (PARTITION_EXTENDED) if InExtended is TRUE or is an extended
        partition already exists.  No other checks are performed on this value.

    ActualDiskRegion - if supplied, receives a pointer to the disk region in which
        the partition was created.

Return Value:

    TRUE if the partition was created successfully.
    FALSE otherwise.

--*/

{
    PPARTITIONED_DISK pDisk;
    ULONGLONG SectorCount;
    ULONGLONG AlignedStartSector;
    ULONGLONG AlignedEndSector;
    PDISK_REGION pRegion,pRegionPrev,pRegionNew,*pRegionHead;
    ULONGLONG LeftOverSectors;
    PMBR_INFO pBrInfo;
    ULONG slot,i,spt;
    PON_DISK_PTE pte;
    ULONGLONG ExtendedStart;
    UCHAR  SysId;

#ifdef GPT_PARTITION_ENGINE
    if (SPPT_IS_GPT_DISK(DiskNumber)) {
        return SpPtnCreate(DiskNumber,
                            StartSector,
                            0,  // SizeInSectors: Not used except in ASR
                            SizeMB,
                            InExtended,
                            TRUE,
                            PartInfo,
                            ActualDiskRegion);
    }                            
#endif                        

    SysId = PartInfo->Mbr.PartitionType;

    //
    // Look up the disk region that describes this free space.
    //
    pDisk = &PartitionedDisks[DiskNumber];
    pRegion = SpPtLookupRegionByStart(pDisk,InExtended,StartSector);
    ASSERT(pRegion);
    if(!pRegion) {
        return(FALSE);
    }

    if(ActualDiskRegion) {
        *ActualDiskRegion = pRegion;
    }

    ASSERT(!pRegion->PartitionedSpace);
    if(pRegion->PartitionedSpace) {
        return(FALSE);
    }

    if(InExtended) {
        ASSERT(!IsContainerPartition(SysId));

        //
        // Locate the start sector of the extended partition.
        //
        for(i=0; i<PTABLE_DIMENSION; i++) {
            if(IsContainerPartition(pDisk->MbrInfo.OnDiskMbr.PartitionTable[i].SystemId)) {
                ExtendedStart = U_ULONG(pDisk->MbrInfo.OnDiskMbr.PartitionTable[i].RelativeSectors);
                break;
            }
        }
        ASSERT(ExtendedStart);
        if(!ExtendedStart) {
            return(FALSE);
        }
    }


    //
    // Determine the number of sectors in the size passed in.
    // Note: the calculation is performed such that intermediate results
    // won't overflow a ULONG.
    //
    SectorCount = SizeMB * ((1024*1024)/pDisk->HardDisk->Geometry.BytesPerSector);

    //
    // Align the start sector.
    //
    AlignedStartSector = SpPtAlignStart(
                            pDisk->HardDisk,
                            StartSector,
                            (BOOLEAN)IsContainerPartition(SysId)
                            );

    //
    // Determine the end sector based on the size passed in.
    //
    AlignedEndSector = AlignedStartSector + SectorCount;

    //
    // Align the ending sector to a cylinder boundary.  If it is not already
    // aligned and is more than half way into the final cylinder, align it up,
    // otherwise align it down.
    //
    if(LeftOverSectors = AlignedEndSector % pDisk->HardDisk->SectorsPerCylinder) {
        AlignedEndSector -= LeftOverSectors;
        if(LeftOverSectors > pDisk->HardDisk->SectorsPerCylinder/2) {
            AlignedEndSector += pDisk->HardDisk->SectorsPerCylinder;
        }
    }

    //
    // If the ending sector is past the end of the free space, shrink it
    // so it fits.
    //
    while(AlignedEndSector > pRegion->StartSector + pRegion->SectorCount) {
        AlignedEndSector -= pDisk->HardDisk->SectorsPerCylinder;
    }

    //
    //  Find out if last sector is in the last cylinder. If it is then align it down.
    //  This is necessary so that we reserve a cylinder at the end of the disk, so that users
    //  can convert the disk to dynamic after the system is installed.
    //
    //  (guhans)  Don't align down if this is ASR.  ASR already takes this into account.
    //
    if( !DockableMachine && !SpDrEnabled() &&
        (AlignedEndSector > (pDisk->HardDisk->CylinderCount - 1) * pDisk->HardDisk->SectorsPerCylinder)
      ) {
            AlignedEndSector -= pDisk->HardDisk->SectorsPerCylinder;
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: End of partition was aligned down 1 cylinder \n"));
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     AlignedStartSector = %lx \n", AlignedStartSector));
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     AlignedEndSector   = %lx \n", AlignedEndSector));
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     SectorsPerCylinder = %lx \n", pDisk->HardDisk->SectorsPerCylinder));
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     CylinderCount = %lx \n", pDisk->HardDisk->CylinderCount));
    }


    ASSERT((LONG)AlignedEndSector > 0);
    if((LONG)AlignedEndSector < 0) {
        return(FALSE);
    }

    //
    // If we are creating a logical drive, create a new mbr structure
    // for it.
    //

    if(InExtended) {

        //
        // Create a boot record for this new logical drive; use slot #0
        // for the partition entry (and slot #1 for the extended record,
        // if necessary).
        //
        pBrInfo = SpMemAlloc(sizeof(MBR_INFO));
        ASSERT(pBrInfo);
        RtlZeroMemory(pBrInfo,sizeof(MBR_INFO));
        slot = 0;

    } else {

        //
        // Look for a free slot in the MBR's partition table.
        //
        pBrInfo = &pDisk->MbrInfo;
        for(slot=0; slot<PTABLE_DIMENSION; slot++) {

            if(pBrInfo->OnDiskMbr.PartitionTable[slot].SystemId == PARTITION_ENTRY_UNUSED) {
                break;
            }

        }

        if(slot == PTABLE_DIMENSION) {
            ASSERT(0);
            return(FALSE);
        }
    }


    //
    // Initialize the partition table entry.
    //
    spt = pDisk->HardDisk->Geometry.SectorsPerTrack;

    pte = &pBrInfo->OnDiskMbr.PartitionTable[slot];

    pte->ActiveFlag = 0;
    pte->SystemId   = SysId;

    U_ULONG(pte->RelativeSectors) = (ULONG)(InExtended ? spt : AlignedStartSector);

    U_ULONG(pte->SectorCount) = (ULONG)(AlignedEndSector - AlignedStartSector - (InExtended ? spt : 0));

    SpPtInitializeCHSFields(
        pDisk->HardDisk,
        AlignedStartSector + (InExtended ? spt : 0),
        AlignedEndSector - AlignedStartSector - (InExtended ? spt : 0),
        pte
        );

    //
    // If we're in the extended partition we mark all entries in the
    // boot record as dirty. Sometimes there is a turd boot record on
    // the disk already, and by setting all entries to dirty we get
    // the crud cleaned out if necessary. The only entries that should be
    // in an EBR are the type 6 or whatever and a type 5 if there are
    // additional logical drives in the extended partition.
    //
    if(InExtended) {
        for(i=0; i<PTABLE_DIMENSION; i++) {
            pBrInfo->Dirty[i] = TRUE;
        }
    } else {
        pBrInfo->Dirty[slot] = TRUE;
    }

    //
    // Don't zap the first sector of the extended partition,
    // as this wipes out the first logical drive, and precludes
    // access to all logical drives!
    //
    if(!IsContainerPartition(SysId)) {
        pBrInfo->ZapBootSector[slot] = TRUE;
    }

    //
    // Find the previous region (ie, the one that points to this one).
    // This region (if it exists) will be partitioned space (otherwise
    // it would have been part of the region we are trying to create
    // a partition in!)
    //
    pRegionHead = InExtended ? &pDisk->ExtendedDiskRegions : &pDisk->PrimaryDiskRegions;

    if(*pRegionHead == pRegion) {
        pRegionPrev = NULL;
    } else {
        for(pRegionPrev = *pRegionHead; pRegionPrev; pRegionPrev = pRegionPrev->Next) {
            if(pRegionPrev->Next == pRegion) {
                ASSERT(pRegionPrev->PartitionedSpace);
                break;
            }
        }
    }

    if(InExtended) {

        PMBR_INFO PrevEbr;

        //
        // The new logical drive goes immediately after the
        // previous logical drive (if any). Remember that if there is
        // a previous region, it will be partitioned space (otherwise
        // it would be a part of the region we are trying to create
        // a partition in).
        //
        PrevEbr = pRegionPrev ? pRegionPrev->MbrInfo : NULL;
        if(PrevEbr) {
            pBrInfo->Next = PrevEbr->Next;
            PrevEbr->Next = pBrInfo;
        } else {
            //
            // No previous EBR or region. This means we are creating
            // a logical drive at the beginning of the extended partition
            // so set the First Ebr pointer to point to the new Ebr.
            // Note that this does not mean that the extended partition
            // is empty; the Next pointer in the new Ebr structure is
            // set later.
            //
            pDisk->FirstEbrInfo.Next = pBrInfo;
            if(pRegion->Next) {
                //
                // If there is a region following the one we're creating
                // the partition in, it must be partitioned space, or else
                // it would be part of the region we're creating the partition in.
                //
                ASSERT(pRegion->Next->PartitionedSpace);
                ASSERT(pRegion->Next->MbrInfo);
                pBrInfo->Next = pRegion->Next->MbrInfo;
            } else {
                //
                // No more partitioned space in the extended partition;
                // the logical drive we are creating is the only one.
                //
                pBrInfo->Next = NULL;
            }
        }

        pBrInfo->OnDiskSector = AlignedStartSector;

        //
        // Create a link entry in the previous logical drive (if any).
        //
        if(PrevEbr) {

            //
            // If there is a link entry in there already, blow it away.
            //
            for(i=0; i<PTABLE_DIMENSION; i++) {
                if(IsContainerPartition(PrevEbr->OnDiskMbr.PartitionTable[i].SystemId)) {
                    RtlZeroMemory(&PrevEbr->OnDiskMbr.PartitionTable[i],sizeof(ON_DISK_PTE));
                    PrevEbr->Dirty[i] = TRUE;
                    break;
                }
            }

            //
            // Find a free slot for the link entry.
            //
            for(i=0; i<PTABLE_DIMENSION; i++) {

                pte = &PrevEbr->OnDiskMbr.PartitionTable[i];

                if(pte->SystemId == PARTITION_ENTRY_UNUSED) {

                    pte->SystemId = PARTITION_EXTENDED;
                    pte->ActiveFlag = 0;

                    U_ULONG(pte->RelativeSectors) = (ULONG)(AlignedStartSector - ExtendedStart);

                    U_ULONG(pte->SectorCount) = (ULONG)(AlignedEndSector - AlignedStartSector);

                    SpPtInitializeCHSFields(
                        pDisk->HardDisk,
                        AlignedStartSector,
                        U_ULONG(pte->SectorCount),
                        pte
                        );

                    PrevEbr->Dirty[i] = TRUE;

                    break;
                }
            }
        }

        //
        // Create a link entry in this new logical drive if necessary.
        //
        if(pBrInfo->Next) {

            //
            // Find the next entry's logical drive.
            //
            for(i=0; i<PTABLE_DIMENSION; i++) {

                if((pBrInfo->Next->OnDiskMbr.PartitionTable[i].SystemId != PARTITION_ENTRY_UNUSED)
                && !IsContainerPartition(pBrInfo->Next->OnDiskMbr.PartitionTable[i].SystemId))
                {
                    pte = &pBrInfo->OnDiskMbr.PartitionTable[1];

                    pte->SystemId = PARTITION_EXTENDED;
                    pte->ActiveFlag = 0;

                    U_ULONG(pte->RelativeSectors) = (ULONG)(pBrInfo->Next->OnDiskSector - ExtendedStart);

                    U_ULONG(pte->SectorCount) = U_ULONG(pBrInfo->Next->OnDiskMbr.PartitionTable[i].RelativeSectors)
                                              + U_ULONG(pBrInfo->Next->OnDiskMbr.PartitionTable[i].SectorCount);

                    SpPtInitializeCHSFields(
                        pDisk->HardDisk,
                        pBrInfo->Next->OnDiskSector,
                        U_ULONG(pte->SectorCount),
                        pte
                        );

                    break;
                }
            }
        }
    }

    //
    // If we just created a new extended partition, we need to
    // create a blank region descriptor for it in the extended region list.
    //
    if(!InExtended && IsContainerPartition(SysId)) {

        ASSERT(pDisk->ExtendedDiskRegions == NULL);

        pDisk->ExtendedDiskRegions = SpPtAllocateDiskRegionStructure(
                                        DiskNumber,
                                        AlignedStartSector,
                                        AlignedEndSector - AlignedStartSector,
                                        FALSE,
                                        NULL,
                                        0
                                        );

        ASSERT(pDisk->ExtendedDiskRegions);
    }

    //
    // Create a new disk region for the new free space at the
    // beginning and end of the free space, if any.
    //
    if(AlignedStartSector - pRegion->StartSector) {

        pRegionNew = SpPtAllocateDiskRegionStructure(
                        DiskNumber,
                        pRegion->StartSector,
                        AlignedStartSector - pRegion->StartSector,
                        FALSE,
                        NULL,
                        0
                        );

        ASSERT(pRegionNew);

        if(pRegionPrev) {
            pRegionPrev->Next = pRegionNew;
        } else {
            *pRegionHead = pRegionNew;
        }
        pRegionNew->Next = pRegion;
    }

    if(pRegion->StartSector + pRegion->SectorCount - AlignedEndSector) {

        pRegionNew = SpPtAllocateDiskRegionStructure(
                        DiskNumber,
                        AlignedEndSector,
                        pRegion->StartSector + pRegion->SectorCount - AlignedEndSector,
                        FALSE,
                        NULL,
                        0
                        );

        pRegionNew->Next = pRegion->Next;
        pRegion->Next = pRegionNew;
    }

    //
    // Adjust the current disk region.
    //
    pRegion->StartSector      = AlignedStartSector;
    pRegion->SectorCount      = AlignedEndSector - AlignedStartSector;
    pRegion->PartitionedSpace = TRUE;
    pRegion->TablePosition    = slot;
    pRegion->MbrInfo          = pBrInfo;

    pRegion->VolumeLabel[0] = 0;
    pRegion->Filesystem = FilesystemNewlyCreated;
    pRegion->FreeSpaceKB = (ULONG)(-1);
    pRegion->AdjustedFreeSpaceKB = (ULONG)(-1);
    SpFormatMessage(
        pRegion->TypeName,
        sizeof(pRegion->TypeName),
        SP_TEXT_FS_NAME_BASE + pRegion->Filesystem
        );

    SpPtCommitChanges(DiskNumber,(PUCHAR)&i);

    //
    // Adjust partition ordinals on this disk.
    //
    SpPtAssignOrdinals(pDisk,FALSE,FALSE,FALSE);

    //
    // Get the nt pathname for this region.
    //
    if (!IsContainerPartition(SysId)) {
        SpNtNameFromRegion(
            pRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer),
            PartitionOrdinalCurrent
            );
        //
        //  Assign a drive letter for this region
        //
        if (!SpDrEnabled()) {
            pRegion->DriveLetter = SpGetDriveLetter( TemporaryBuffer, NULL );
            if (pRegion->DriveLetter == 0) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpGetDriveLetter failed on %ls\n", TemporaryBuffer));
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Partition = %ls (%ls), DriveLetter = %wc: \n", TemporaryBuffer, (InExtended)? L"Extended" : L"Primary", pRegion->DriveLetter));
            }
        }
    }

    return(TRUE);
}


BOOLEAN
SpPtDelete(
    IN ULONG   DiskNumber,
    IN ULONGLONG  StartSector
    )
{
    PPARTITIONED_DISK pDisk;
    PDISK_REGION pRegion,pRegionPrev,*pRegionHead,pRegionNext;
    BOOLEAN InExtended;
    PON_DISK_PTE pte;
    PMBR_INFO pEbrPrev,pEbr;
    ULONG i,j;
    PHARD_DISK pHardDisk;
    ULONG PartitionOrdinal;
    NTSTATUS Status;
    HANDLE Handle;


#ifdef GPT_PARTITION_ENGINE

    if (SPPT_IS_GPT_DISK(DiskNumber))
        return SpPtnDelete(DiskNumber, StartSector);
        
#endif

    //
    // First try to look up this region in the extended partition.
    // If we can find it, assume it's a logical drive.
    //
    pDisk = &PartitionedDisks[DiskNumber];
    pRegion = SpPtLookupRegionByStart(pDisk,TRUE,StartSector);
    if(pRegion && pRegion->PartitionedSpace) {
        InExtended = TRUE;
    } else {
        InExtended = FALSE;
        pRegion = SpPtLookupRegionByStart(pDisk,FALSE,StartSector);
    }

    ASSERT(pRegion);
    if(!pRegion) {
        return(FALSE);
    }

    ASSERT(pRegion->PartitionedSpace);
    if(!pRegion->PartitionedSpace) {
        return(FALSE);
    }

    //
    // At this point, we dismount the volume (if it's not newly created),
    // so we don't run into problems later on when we go to format
    //
    if(pRegion->Filesystem > FilesystemNewlyCreated) {

        pHardDisk = &HardDisks[pRegion->DiskNumber];
        PartitionOrdinal = SpPtGetOrdinal(pRegion, PartitionOrdinalOnDisk);

        //
        // Open the partition for read/write access.
        // This shouldn't lock the volume so we need to lock it below.
        //
        Status = SpOpenPartition(
                    pHardDisk->DevicePath,
                    PartitionOrdinal,
                    &Handle,
                    TRUE
                    );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                "SETUP: SpPtDelete: unable to open %ws partition %u (%lx)\n",
                pHardDisk->DevicePath,
                PartitionOrdinal,
                Status
                ));
            goto AfterDismount;
        }

        //
        //  Lock the drive.
        //
        Status = SpLockUnlockVolume(Handle, TRUE);

        //
        //  We shouldn't have any file opened that would cause this volume
        //  to already be locked, so if we get failure (ie, STATUS_ACCESS_DENIED)
        //  something is really wrong.  This typically indicates something is
        //  wrong with the hard disk that won't allow us to access it.
        //
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPtDelete: status %lx, unable to lock drive\n", Status));
            ZwClose(Handle);
            goto AfterDismount;
        }

        //
        // Dismount the drive
        //
        Status = SpDismountVolume(Handle);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPtDelete: status %lx, unable to dismount drive\n", Status));
            SpLockUnlockVolume(Handle, FALSE);
            ZwClose(Handle);
            goto AfterDismount;
        }

        //
        // Unlock the drive
        //
        Status = SpLockUnlockVolume(Handle, FALSE);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPtDelete: status %lx, unable to unlock drive\n", Status));
        }

        ZwClose(Handle);
    }

AfterDismount:
    //
    // Find the previous region (ie, the one that points to this one).
    //
    pRegionHead = InExtended ? &pDisk->ExtendedDiskRegions : &pDisk->PrimaryDiskRegions;

    if(*pRegionHead == pRegion) {
        pRegionPrev = NULL;
    } else {
        for(pRegionPrev = *pRegionHead; pRegionPrev; pRegionPrev = pRegionPrev->Next) {
            if(pRegionPrev->Next == pRegion) {
                break;
            }
        }
    }

    //
    // Additional processing for logical drives.
    //
    if(InExtended) {

        //
        // Locate the previous and next logical drives (if any).
        //
        pEbr = pRegion->MbrInfo;

        for(pEbrPrev=pDisk->FirstEbrInfo.Next; pEbrPrev; pEbrPrev=pEbrPrev->Next) {
            if(pEbrPrev->Next == pEbr) {
                break;
            }
        }

        //
        // If there is a previous logical drive, blow aways its link
        // entry, because it points to the logical drive we're deleting.
        //
        if(pEbrPrev) {

            for(i=0; i<PTABLE_DIMENSION; i++) {

                pte = &pEbrPrev->OnDiskMbr.PartitionTable[i];

                if(IsContainerPartition(pte->SystemId)) {

                    RtlZeroMemory(pte,sizeof(ON_DISK_PTE));
                    pEbrPrev->Dirty[i] = TRUE;
                    break;
                }
            }
        }

        //
        // If there is a next logical drive and a previous logical drive,
        // set a new link entry in previous logical drive to point to
        // the next logical drive.
        //
        if(pEbrPrev && pEbr->Next) {

            //
            // Locate the link entry in the logical drive being deleted.
            //
            for(i=0; i<PTABLE_DIMENSION; i++) {

                if(IsContainerPartition(pEbr->OnDiskMbr.PartitionTable[i].SystemId)) {

                    //
                    // Locate an empty slot in the previous logical drive's boot record
                    // and copy the link entry
                    //
                    for(j=0; j<PTABLE_DIMENSION; j++) {
                        if(pEbrPrev->OnDiskMbr.PartitionTable[j].SystemId == PARTITION_ENTRY_UNUSED) {

                            //
                            // Copy the link entry and mark the new link entry dirty
                            // so it gets updated on-disk. We do this even though on the
                            // typical disk it will have been marked dirty above. This one here
                            // handles the case of a wierd situation where the type 6/7/whatever
                            // is in slot 0 and the link entry was in slot 2 or 3. In that case,
                            // the RtlZeroMemory code above will have cleaned out a slot that is
                            // different than the one we're using here for the new link entry.
                            //
                            RtlMoveMemory(
                                &pEbrPrev->OnDiskMbr.PartitionTable[j],
                                &pEbr->OnDiskMbr.PartitionTable[i],
                                sizeof(ON_DISK_PTE)
                                );

                            pEbrPrev->Dirty[j] = TRUE;

                            break;
                        }
                    }
                    break;
                }
            }
        }

        //
        // Remove the EBR for this logical drive.
        //
        if(pEbrPrev) {
            pEbrPrev->Next = pEbr->Next;
        } else {
            ASSERT(pDisk->FirstEbrInfo.Next == pEbr);
            pDisk->FirstEbrInfo.Next = pEbr->Next;
        }

        SpMemFree(pEbr);

    } else {

        ASSERT(pRegion->MbrInfo == &pDisk->MbrInfo);

        pte = &pRegion->MbrInfo->OnDiskMbr.PartitionTable[pRegion->TablePosition];

        ASSERT(pte->SystemId != PARTITION_ENTRY_UNUSED);

        //
        // Mark the entry dirty in the MBR.
        //
        pDisk->MbrInfo.Dirty[pRegion->TablePosition] = TRUE;

        //
        // If this is the extended partition, verify that it is empty.
        //
        if(IsContainerPartition(pte->SystemId)) {
            ASSERT(pDisk->ExtendedDiskRegions);
            ASSERT(pDisk->ExtendedDiskRegions->PartitionedSpace == FALSE);
            ASSERT(pDisk->ExtendedDiskRegions->Next == NULL);
            ASSERT(pDisk->FirstEbrInfo.Next == NULL);

            if(pDisk->ExtendedDiskRegions->Next || pDisk->FirstEbrInfo.Next) {
                return(FALSE);
            }

            //
            // Free the single disk region that covers the entire extended partition.
            //
            SpMemFree(pDisk->ExtendedDiskRegions);
            pDisk->ExtendedDiskRegions = NULL;
        }

        //
        // Adjust the PTE for this partition by zeroing it out.
        //
        RtlZeroMemory(pte,sizeof(ON_DISK_PTE));
    }


    //
    // Adjust fields in the region to describe this space as free.
    //
    pRegion->MbrInfo->ZapBootSector[pRegion->TablePosition] = FALSE;
    pRegion->PartitionedSpace = FALSE;
    pRegion->MbrInfo = NULL;
    pRegion->TablePosition = 0;
    pRegion->DriveLetter = L'\0';

    //
    // If previous region is free space, coalesce it and the region
    // we just made free.
    //
    if(pRegionPrev && !pRegionPrev->PartitionedSpace) {

        PDISK_REGION p;

        ASSERT(pRegionPrev->StartSector + pRegionPrev->SectorCount == pRegion->StartSector);

        pRegion->SectorCount = pRegion->StartSector + pRegion->SectorCount - pRegionPrev->StartSector;
        pRegion->StartSector = pRegionPrev->StartSector;

        //
        // Delete the previous region.
        //
        if(pRegionPrev == *pRegionHead) {
            //
            // The previous region was the first region.
            //
            *pRegionHead = pRegion;
        } else {

            for(p = *pRegionHead; p; p=p->Next) {
                if(p->Next == pRegionPrev) {
                    ASSERT(p->PartitionedSpace);
                    p->Next = pRegion;
                    break;
                }
            }
        }

        SpMemFree(pRegionPrev);
    }

    //
    // If the next region is free space, coalesce it and the region
    // we just made free.
    //
    if((pRegionNext = pRegion->Next) && !pRegionNext->PartitionedSpace) {

        ASSERT(pRegion->StartSector + pRegion->SectorCount == pRegionNext->StartSector);

        pRegion->SectorCount = pRegionNext->StartSector + pRegionNext->SectorCount - pRegion->StartSector;

        //
        // Delete the next region.
        //
        pRegion->Next = pRegionNext->Next;
        SpMemFree(pRegionNext);
    }

    SpPtCommitChanges(DiskNumber,(PUCHAR)&i);

    //
    // Adjust the partition ordinals on this disk.
    //
    SpPtAssignOrdinals(pDisk,FALSE,FALSE,FALSE);

    //
    //  No need to reassign drive letters
    //

    return(TRUE);
}

#endif  // !NEW_PARTITION_ENGINE


BOOLEAN
SpPtExtend(
    IN PDISK_REGION Region,
    IN ULONGLONG    SizeMB      OPTIONAL
    )

/*++

Routine Description:

    Extends a partition by claiming any free space immedately following it
    on the disk. The end boundary of the existing partition is adjusted
    so that the partition encompasses the free space.

    The partition may not be the extended partition and it may not be
    a logical drive within the extended partition.

    Note that no filesystem structures are manipulated or examined by
    this routine. Essentially it deals only with the partition table entry.

Arguments:

    Region - supplies the region descriptor for the partition to be
        extended. That partition must not be the extended partition and
        it cannot be a logical drive either.

    SizeMB - if specified, indicates the size in MB by which the partition
        will grow. If not specified, the partition grows to encompass all
        the free space in the adjacent free space.

Return Value:

    Boolean value indicating whether anything actually changed.

--*/

{
    PDISK_REGION NextRegion;
    PPARTITIONED_DISK pDisk;
    PMBR_INFO pBrInfo;
    PON_DISK_PTE pte;
    ULONG BytesPerSector;
    ULONGLONG NewEndSector;
    ULONGLONG SectorCount;
    PVOID UnalignedBuffer;
    PON_DISK_MBR AlignedBuffer;
    HANDLE Handle;
    NTSTATUS Status;

    //
    // We aren't going to support this anymore on NT5.  It's too messy.
    //
    return FALSE;

/*
    pDisk = &PartitionedDisks[Region->DiskNumber];
    BytesPerSector = pDisk->HardDisk->Geometry.BytesPerSector;

    ASSERT(Region->PartitionedSpace);
    if(!Region->PartitionedSpace) {
        return(FALSE);
    }

    pBrInfo = Region->MbrInfo;
    pte = &pBrInfo->OnDiskMbr.PartitionTable[Region->TablePosition];

    //
    // Make sure it's not the extended partition and is not
    // in the extended partition.
    //
    if(pBrInfo->OnDiskSector || IsContainerPartition(pte->SystemId)) {
        return(FALSE);
    }

    //
    // If there's no next region then there's nothing to do.
    // If there is a next region make sure it's empty.
    //
    NextRegion = Region->Next;
    if(!NextRegion) {
        return(FALSE);
    }
    if(NextRegion->PartitionedSpace) {
        return(FALSE);
    }

    //
    // Convert the passed in size to a sector count.
    //
    if(SizeMB) {
        SectorCount = SizeMB * ((1024*1024)/BytesPerSector);
        if(SectorCount > NextRegion->SectorCount) {
            SectorCount = NextRegion->SectorCount;
        }
    } else {
        SectorCount = NextRegion->SectorCount;
    }

    //
    // Claim the part of the free region we need and align the ending sector
    // to a cylinder boundary.
    //
    NewEndSector = NextRegion->StartSector + SectorCount;
    NewEndSector -= NewEndSector % pDisk->HardDisk->SectorsPerCylinder;

    //
    // Fix up the size and end CHS fields in the partition table entry
    // for the partition.
    //
    U_ULONG(pte->SectorCount) = NewEndSector - Region->StartSector;

    SpPtInitializeCHSFields(
        pDisk->HardDisk,
        Region->StartSector,
        NewEndSector - Region->StartSector,
        pte
        );

    //pBrInfo->Dirty[Region->TablePosition] = TRUE;

    //
    // If there is space left over at the end of the free region
    // we just stuck onto the end of the existing partition,
    // adjust the free region's descriptor. Else get rid of it.
    //
    if(NextRegion->StartSector + NextRegion->SectorCount == NewEndSector) {

        Region->Next = NextRegion->Next;
        SpMemFree(NextRegion);

    } else {

        NextRegion->SectorCount = NextRegion->StartSector + NextRegion->SectorCount - NewEndSector;
        NextRegion->StartSector = NewEndSector;
    }

    //
    // Now we have to something tricky. We don't want to inform the disk driver
    // about what we just did because he will delete the device object for
    // the partition, which causes problems the next time we hit the disk, say to
    // page in part of usetup.exe to get a message. We whack the partition table
    // entry directly, knowing that a) we've been called after SpPtCommitChanges
    // and b) no one cares about the new size until after we've rebooted.
    //
    UnalignedBuffer = SpMemAlloc(2*BytesPerSector);
    AlignedBuffer = ALIGN(UnalignedBuffer,BytesPerSector);

    Status = SpOpenPartition0(pDisk->HardDisk->DevicePath,&Handle,TRUE);
    if(NT_SUCCESS(Status)) {

        Status = SpReadWriteDiskSectors(Handle,0,1,BytesPerSector,AlignedBuffer,FALSE);
        if(NT_SUCCESS(Status)) {

            if(!IsNEC_98) {
                RtlMoveMemory(
                    &AlignedBuffer->PartitionTable[Region->TablePosition],
                    &Region->MbrInfo->OnDiskMbr.PartitionTable[Region->TablePosition],
                    sizeof(ON_DISK_PTE)
                    );

            } else {
                PREAL_DISK_MBR pRealBuffer = (PREAL_DISK_MBR)AlignedBuffer;

                ASSERT(pDisk->HardDisk->FormatType == DISK_FORMAT_TYPE_PCAT);
                SpTranslatePteInfo(
                    &Region->MbrInfo->OnDiskMbr.PartitionTable[Region->TablePosition],
                    &pRealBuffer->PartitionTable[Region->TablePosition],
                    TRUE
                    );
            }


            Status = SpReadWriteDiskSectors(Handle,0,1,BytesPerSector,AlignedBuffer,TRUE);
            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPtExtend: can't write sector 0, status %lx",Status));
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPtExtend: can't read sector 0, status %lx",Status));
        }

        ZwClose(Handle);
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPtExtend: can't open disk, status %lx",Status));
    }

    SpMemFree(UnalignedBuffer);

    if(!NT_SUCCESS(Status)) {
        FatalPartitionUpdateError(pDisk->HardDisk->Description);
    }

    return(TRUE);
*/    
}


VOID
SpPtMarkActive(
    IN ULONG TablePosition
    )

/*++

Routine Description:

    Mark a partition on drive 0 active, and deactivate all others.

Arguments:

    TablePosition - supplies offset within partition table (0-3)
        of the partition entry to be activated.

Return Value:

    None.

--*/

{
    ULONG i;
    PON_DISK_PTE pte;
    ULONG Disk0Ordinal;

    ASSERT(TablePosition < PTABLE_DIMENSION);

    Disk0Ordinal = SpDetermineDisk0();

    //
    // Deactivate all others.
    //
    for(i=0; i<PTABLE_DIMENSION; i++) {

        pte = &PartitionedDisks[Disk0Ordinal].MbrInfo.OnDiskMbr.PartitionTable[i];

        if((pte->SystemId != PARTITION_ENTRY_UNUSED)
        && pte->ActiveFlag
        && (i != TablePosition))
        {
            pte->ActiveFlag = 0;
            PartitionedDisks[0].MbrInfo.Dirty[i] = TRUE;
        }
    }

    //
    // Activate the one we want to activate.
    //
    pte = &PartitionedDisks[Disk0Ordinal].MbrInfo.OnDiskMbr.PartitionTable[TablePosition];
    ASSERT(pte->SystemId != PARTITION_ENTRY_UNUSED);
    ASSERT(!IsContainerPartition(pte->SystemId));

// @mtp - Original    ASSERT(( PartitionNameIds[pte->SystemId] == (UCHAR)(-1)) || (pte->SystemId == PARTITION_LDM));

    ASSERT((PartitionNameIds[pte->SystemId] == (UCHAR)(-1)) || (pte->SystemId == PARTITION_LDM) ||
            ( SpDrEnabled() &&
              IsRecognizedPartition(pte->SystemId) &&
              ( ((pte->SystemId & VALID_NTFT) == VALID_NTFT ) ||
                ((pte->SystemId & PARTITION_NTFT) == PARTITION_NTFT)
              )
            )
          );


    if(!pte->ActiveFlag) {
        pte->ActiveFlag = 0x80;
        PartitionedDisks[Disk0Ordinal].MbrInfo.Dirty[TablePosition] = TRUE;
    }
}

#ifndef NEW_PARTITION_ENGINE

NTSTATUS
SpPtCommitChanges(
    IN  ULONG    DiskNumber,
    OUT PBOOLEAN AnyChanges
    )
{
    PPARTITIONED_DISK pDisk;
    ULONG DiskLayoutSize;
    PDISK_REGION pRegion;
    PMBR_INFO pBrInfo;
    ULONG BootRecordCount;
    BOOLEAN NeedDummyEbr;
    PDRIVE_LAYOUT_INFORMATION DriveLayout;
    PPARTITION_INFORMATION PartitionInfo;
    ULONG PartitionEntry;
    ULONG bps;
    PON_DISK_PTE pte;
    ULONGLONG ExtendedStart;
    ULONGLONG Offset;
    NTSTATUS Status;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG i;
    ULONGLONG ZapSector;
    PUCHAR Buffer,UBuffer;
    ULONG NewSig;

    ULONGLONG RewriteSector[PTABLE_DIMENSION]; //NEC98
    ULONG cnt,RewriteCnt=0; //NEC98

#ifdef GPT_PARTITION_ENGINE

    if (SPPT_IS_GPT_DISK(DiskNumber))
        return SpPtnCommitChanges(DiskNumber, AnyChanges);

#endif
        

    ASSERT(DiskNumber < HardDiskCount);
    pDisk = &PartitionedDisks[DiskNumber];
    *AnyChanges = FALSE;
    bps = pDisk->HardDisk->Geometry.BytesPerSector;
    ExtendedStart = 0;

    //
    // Determine the number of boot records that will used on this disk.
    // There is one for the MBR, and one for each logical drive.
    //
    BootRecordCount = 1;
    for(pRegion=pDisk->ExtendedDiskRegions; pRegion; pRegion=pRegion->Next) {

        if(pRegion->PartitionedSpace) {
            BootRecordCount++;
        }
    }

    if (IsNEC_98) { //NEC98
        ZapSector = 0;

#if defined(NEC_98) //NEC98
        //
        // Set RealDiskPosition. This value will be valid after changing partition.
        //
        for(i=0,pRegion=pDisk->PrimaryDiskRegions; pRegion; pRegion=pRegion->Next) {
            if(pRegion->PartitionedSpace) {
                pRegion->MbrInfo->OnDiskMbr.PartitionTable[pRegion->TablePosition].RealDiskPosition = (UCHAR)i;
                i++;
            }
        }
#endif //NEC98
    } //NEC98

    //
    // Determine whether a dummy boot record is rquired at the start
    // of the extended partition.  This is the case when there is free
    // space at its start.
    //
    if(pDisk->ExtendedDiskRegions
    && !pDisk->ExtendedDiskRegions->PartitionedSpace
    && pDisk->ExtendedDiskRegions->Next)
    {
        NeedDummyEbr = TRUE;
        BootRecordCount++;
        *AnyChanges = TRUE;
    } else {
        NeedDummyEbr = FALSE;
    }

    //
    // Allocate a disk layout structure whose size is based on the
    // number of boot records.  This assumes that the structure contains
    // one partition information structure in its definition.
    //
    DiskLayoutSize = sizeof(DRIVE_LAYOUT_INFORMATION)
                   + (BootRecordCount * PTABLE_DIMENSION * sizeof(PARTITION_INFORMATION))
                   - sizeof(PARTITION_INFORMATION);

    DriveLayout = SpMemAlloc(DiskLayoutSize);
    ASSERT(DriveLayout);
    RtlZeroMemory(DriveLayout,DiskLayoutSize);

    //
    // Set up some of the fields of the drive layout structure.
    //
    DriveLayout->PartitionCount =
        (!IsNEC_98) ? (BootRecordCount * sizeof(PTABLE_DIMENSION))
                    : (BootRecordCount * PTABLE_DIMENSION); //NEC98

    //
    // Go through each boot record and initialize the matching
    // partition information structure in the drive layout structure.
    //
    for(PartitionEntry=0,pBrInfo=&pDisk->MbrInfo; pBrInfo; pBrInfo=pBrInfo->Next) {

        for(i=0; i<PTABLE_DIMENSION; i++) {
            pBrInfo->UserData[i] = NULL;
        }

        //
        // If we are going to need a dummy logical drive,
        // leave space for it here.
        //
        if(pBrInfo == &pDisk->FirstEbrInfo) {
            if(NeedDummyEbr) {
                PartitionEntry += PTABLE_DIMENSION;
            }
            continue;
        }

        ASSERT(PartitionEntry < BootRecordCount*PTABLE_DIMENSION);

        for(i=0; i<PTABLE_DIMENSION; i++) {

            //
            // Point to partition information structure within
            // drive layout structure.
            //
            PartitionInfo = &DriveLayout->PartitionEntry[PartitionEntry+i];

            //
            // Transfer this partition table entry
            // into the drive layout structure, field by field.
            //
            pte = &pBrInfo->OnDiskMbr.PartitionTable[i];

            //
            // If this is the extended partition, remember where it starts.
            //
            if((pBrInfo == &pDisk->MbrInfo)
            && IsContainerPartition(pte->SystemId)
            && !ExtendedStart)
            {
                ExtendedStart = U_ULONG(pte->RelativeSectors);
            }

            if(pte->SystemId != PARTITION_ENTRY_UNUSED) {

                if(!IsContainerPartition(pte->SystemId)) {
                    pBrInfo->UserData[i] = PartitionInfo;
                }

                //
                // Calculate starting offset.  If we are within
                // the extended parttion and this is a type 5 entry,
                // then the relative sector field counts the number of sectors
                // between the main extended partition's first sector and
                // the logical drive described by this entry.
                // Otherwise, the relative sectors field describes the number
                // of sectors between the boot record and the actual start
                // of the partition.
                //

                if((pBrInfo != &pDisk->MbrInfo) && IsContainerPartition(pte->SystemId)) {
                    ASSERT(ExtendedStart);
                    Offset = ExtendedStart + U_ULONG(pte->RelativeSectors);
                } else {
                    Offset = pBrInfo->OnDiskSector + U_ULONG(pte->RelativeSectors);
                }

                PartitionInfo->StartingOffset.QuadPart = UInt32x32To64(Offset,bps);

                //
                // Calculate size.
                //
                PartitionInfo->PartitionLength.QuadPart = UInt32x32To64(U_ULONG(pte->SectorCount),bps);

                //
                // Store start offset of newly created partition to clear sector later.
                //
                if(IsNEC_98 && pBrInfo->Dirty[i]) {
                    RewriteSector[RewriteCnt++] = Offset;
                }
            }

            //
            // Other fields.
            //
            PartitionInfo->PartitionType = pte->SystemId;
            PartitionInfo->BootIndicator = pte->ActiveFlag;
            PartitionInfo->RewritePartition = pBrInfo->Dirty[i];

            if(pBrInfo->Dirty[i]) {
                *AnyChanges = TRUE;
            }

            pBrInfo->Dirty[i] = FALSE;
        }

        PartitionEntry += PTABLE_DIMENSION;
    }

    //
    // If there are no changes, just return success now.
    //
    if(!(*AnyChanges)) {
        SpMemFree(DriveLayout);
        return(STATUS_SUCCESS);
    }

    //
    // If there is free space at the start of the extended partition,
    // then we need to generate a dummy boot record.
    //
    if(NeedDummyEbr) {

        pRegion = pDisk->ExtendedDiskRegions->Next;

        ASSERT(pRegion->PartitionedSpace);
        ASSERT(pRegion->StartSector == pRegion->MbrInfo->OnDiskSector);
        ASSERT(ExtendedStart == pDisk->ExtendedDiskRegions->StartSector);

        PartitionInfo = &DriveLayout->PartitionEntry[PTABLE_DIMENSION];

        PartitionInfo->StartingOffset.QuadPart = UInt32x32To64(pRegion->StartSector,bps);

        PartitionInfo->PartitionLength.QuadPart = UInt32x32To64(pRegion->SectorCount,bps);

        PartitionInfo->PartitionType = PARTITION_EXTENDED;
        PartitionInfo->RewritePartition = TRUE;
        //
        // Rewrite all other entries to ensure that if there was logica drive (first in the chain)
        // that was deleted, it will really go away. There won't be any effect if we overwrite a
        // logical drive that didn't exist
        //
        for( i = 1; i < PTABLE_DIMENSION; i ++ ) {
            PartitionInfo = &DriveLayout->PartitionEntry[PTABLE_DIMENSION + i];
            PartitionInfo->RewritePartition = TRUE;
        }
    }


    //
    // We now have everything set up. Open partition 0 on the disk.
    //
    Status = SpOpenPartition0(pDisk->HardDisk->DevicePath,&Handle,TRUE);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: committing changes, unable to open disk %u (%lx)\n",DiskNumber,Status));
        SpMemFree(DriveLayout);
        return(Status);
    }

    //
    // Make sure the mbr is valid before writing the changes.
    // Note that we slam in new boot code whenever any changes have been made.
    // We do this to guaranteee proper support for xint13 booting, etc.
    //

  if (!IsNEC_98) { //NEC98
    //
    // If MBR of target hard disk is invalid, initialize it when select target partition.
    // so don't rewrite MBR now.
    //
    Status = SpMasterBootCode(DiskNumber,Handle,&NewSig);
    if(NT_SUCCESS(Status)) {
        //
        // If a new NTFT signature was generated, propagate it.
        //
        if(NewSig) {
            U_ULONG(pDisk->MbrInfo.OnDiskMbr.NTFTSignature) = NewSig;
        }
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: committing changes on disk %u, SpMasterBootCode returns %lx\n",DiskNumber,Status));
        ZwClose(Handle);
        SpMemFree(DriveLayout);
        return(Status);
    }
  } //NEC98

    DriveLayout->Signature = U_ULONG(pDisk->MbrInfo.OnDiskMbr.NTFTSignature);

#if 0
    //
    //  We dump after the call to the IOCTL because it can change some of the data in the structure,
    //  such as PartitionNumber
    //
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Dumping DriveLayout before calling IOCTL_DISK_SET_DRIVE_LAYOUT: \n"));
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     DriveLayout->PartitionCount = %lx\n", DriveLayout->PartitionCount));
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     DriveLayout->Signature = %lx \n\n", DriveLayout->Signature));
    for(i = 0; i < DriveLayout->PartitionCount; i++) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].StartingOffset = 0x%08lx%08lx\n", i, DriveLayout->PartitionEntry[i].StartingOffset.u.HighPart, DriveLayout->PartitionEntry[i].StartingOffset.u.LowPart));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].PartitionLength = 0x%08lx%08lx\n", i, DriveLayout->PartitionEntry[i].PartitionLength.u.HighPart, DriveLayout->PartitionEntry[i].PartitionLength.u.LowPart));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].HiddenSectors = 0x%08lx\n", i, DriveLayout->PartitionEntry[i].HiddenSectors));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].PartitionNumber = %d\n", i, DriveLayout->PartitionEntry[i].PartitionNumber));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].PartitionType = 0x%02x\n", i, DriveLayout->PartitionEntry[i].PartitionType));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].BootIndicator = %ls\n", i, DriveLayout->PartitionEntry[i].BootIndicator? L"TRUE" : L"FALSE"));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].RecognizedPartition = %ls\n", i, DriveLayout->PartitionEntry[i].RecognizedPartition? L"TRUE" : L"FALSE"));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].RewritePartition = %ls\n\n", i, DriveLayout->PartitionEntry[i].RewritePartition? L"TRUE" : L"FALSE"));
    }
#endif
    //
    // Write the changes.
    //
    Status = ZwDeviceIoControlFile(
                Handle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_DISK_SET_DRIVE_LAYOUT,
                DriveLayout,
                DiskLayoutSize,
                DriveLayout,
                DiskLayoutSize
                );

    // Deferred freeing memory till later on because we still need info in this structure (lonnym)
    // SpMemFree(DriveLayout);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: committing changes on disk %u, ioctl returns %lx\n",DiskNumber,Status));
        SpMemFree(DriveLayout);
        ZwClose(Handle);
        return(Status);
    }

#if 0
    //
    //  We dump after the call to the IOCTL because it can change some of the data in the structure,
    //  such as PartitionNumber
    //
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Dumping DriveLayout after IOCTL_DISK_SET_DRIVE_LAYOUT was called: \n"));
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP:     DriveLayout->PartitionCount = %lx\n", DriveLayout->PartitionCount));
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP:     DriveLayout->Signature = %lx \n\n", DriveLayout->Signature));
    for(i = 0; i < DriveLayout->PartitionCount; i++) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].StartingOffset = 0x%08lx%08lx\n", i, DriveLayout->PartitionEntry[i].StartingOffset.u.HighPart, DriveLayout->PartitionEntry[i].StartingOffset.u.LowPart));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].PartitionLength = 0x%08lx%08lx\n", i, DriveLayout->PartitionEntry[i].PartitionLength.u.HighPart, DriveLayout->PartitionEntry[i].PartitionLength.u.LowPart));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].HiddenSectors = 0x%08lx\n", i, DriveLayout->PartitionEntry[i].HiddenSectors));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].PartitionNumber = %d\n", i, DriveLayout->PartitionEntry[i].PartitionNumber));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].PartitionType = 0x%02x\n", i, DriveLayout->PartitionEntry[i].PartitionType));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].BootIndicator = %ls\n", i, DriveLayout->PartitionEntry[i].BootIndicator? L"TRUE" : L"FALSE"));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].RecognizedPartition = %ls\n", i, DriveLayout->PartitionEntry[i].RecognizedPartition? L"TRUE" : L"FALSE"));
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP:     DriveLayout->PartitionEntry[%d].RewritePartition = %ls\n\n", i, DriveLayout->PartitionEntry[i].RewritePartition? L"TRUE" : L"FALSE"));
    }
#endif

    //
    // Allocate a buffer for zapping.
    //
    UBuffer = SpMemAlloc(2*bps);
    ASSERT(UBuffer);
    Buffer = ALIGN(UBuffer,bps);
    RtlZeroMemory(Buffer,bps);

    if (IsNEC_98) { //NEC98
        //
        // Clear 1st sector of target partition.
        //
        for(cnt = 0; cnt < RewriteCnt; cnt++){
            Status = SpReadWriteDiskSectors(Handle,
                                            RewriteSector[cnt],
                                            1,
                                            bps,
                                            Buffer,
                                            TRUE);

            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: clear sector %lx on disk %u returned %lx\n",ZapSector,DiskNumber,Status));
                SpMemFree(DriveLayout);
                SpMemFree(UBuffer);
                ZwClose(Handle);
                return(Status);
            }
        }
    } //NEC98

    for(pBrInfo=&pDisk->MbrInfo; pBrInfo; pBrInfo=pBrInfo->Next) {

        for(i=0; i<PTABLE_DIMENSION; i++) {

            //
            // Update current partition ordinals.
            //
            if (IsNEC_98) {
                pte = &pBrInfo->OnDiskMbr.PartitionTable[i];
            }

            if ((!IsNEC_98) ? (pBrInfo->UserData[i]) :
                              (PVOID)(pte->SystemId != PARTITION_ENTRY_UNUSED)) { //NEC98

#if defined(NEC_98) //NEC98
                PartitionInfo = (!IsNEC_98) ? (PPARTITION_INFORMATION)pBrInfo->UserData[i] :
                                              &DriveLayout->PartitionEntry[pte->RealDiskPosition]; //NEC98
#else
                PartitionInfo = (PPARTITION_INFORMATION)pBrInfo->UserData[i];
#endif

                //
                // The partition ordinal better be non-0!
                //
                if(PartitionInfo->PartitionNumber) {

                    //
                    // Update current partition ordinal.
                    //
                    pBrInfo->CurrentOrdinals[i] = (USHORT)PartitionInfo->PartitionNumber;

                } else {
                    SpBugCheck(
                        SETUP_BUGCHECK_PARTITION,
                        PARTITIONBUG_A,
                        DiskNumber,
                        pBrInfo->CurrentOrdinals[i]
                        );
                }
            }

          if (!IsNEC_98) { //NEC98
            //
            // If there were any newly created partitions in this boot record,
            // zap their filesystem boot sectors.
            //
            if(pBrInfo->ZapBootSector[i]) {
                //
                // We shouldn't be zapping any partitions that don't exist.
                //
                ASSERT(pBrInfo->OnDiskMbr.PartitionTable[i].SystemId != PARTITION_ENTRY_UNUSED);

                //
                // This calculation is correct for partitions and logical drives.
                //
                ZapSector = pBrInfo->OnDiskSector
                          + U_ULONG(pBrInfo->OnDiskMbr.PartitionTable[i].RelativeSectors);

                //
                // The consequences for messing up here are so huge that a special check
                // is warranted to make sure we're not clobbering the MBR.
                //
                ASSERT(ZapSector);
                if(ZapSector) {
                    Status = SpReadWriteDiskSectors(
                                Handle,
                                ZapSector,
                                1,
                                bps,
                                Buffer,
                                TRUE
                                );
                } else {
                    Status = STATUS_SUCCESS;
                }

                if(!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: zapping sector %lx on disk %u returned %lx\n",ZapSector,DiskNumber,Status));
                    SpMemFree(DriveLayout);
                    SpMemFree(UBuffer);
                    ZwClose(Handle);
                    return(Status);
                }

                pBrInfo->ZapBootSector[i] = FALSE;
            }
          } //NEC98
        }
    }

    SpMemFree(UBuffer);
    ZwClose(Handle);

    //
    // Reassign on-disk ordinals (but not original ones).
    //
    SpPtAssignOrdinals(pDisk,FALSE,TRUE,FALSE);
    if (IsNEC_98) { //NEC98
        //
        // If newly created partition's position is before existing partition,
        // OnDiskOrdinals is not equal number of volume infomation position on NEC98
        //
        SpReassignOnDiskOrdinals(pDisk);
    } //NEC98

    SpMemFree(DriveLayout);

    return(STATUS_SUCCESS);
}

#endif // ! NEW_PARTITION_ENGINE

NTSTATUS
SpMasterBootCode(
    IN  ULONG  DiskNumber,
    IN  HANDLE Partition0Handle,
    OUT PULONG NewNTFTSignature
    )

/*++

Routine Description:

    Write new master boot code onto a drive.

    If the mbr has a valid signature, the existing partition table
    and NTFT signature are preserved. Otherwise the partition table
    is zeroed out and a new ntft signature is generated.

Arguments:

    DiskNumber - supplies 0-based system ordinal for the disk.

    Partition0Handle - supplies an open handle for partition 0 on
        the disk. The handle must have read and write access.

    NewNTFTSignature - receives a value indicating the new NTFT signature,
        if one was generated and written to the disk. If 0 is received,
        then a new ntft signature was not generated and written.

Return Value:

    NT Status code indicating outcome.

--*/

{
    NTSTATUS Status;
    ULONG BytesPerSector;
    PUCHAR Buffer;
    ULONG SectorCount;
    PON_DISK_MBR Mbr;

    BytesPerSector = HardDisks[DiskNumber].Geometry.BytesPerSector;

    SectorCount = max(1,sizeof(ON_DISK_MBR)/BytesPerSector);

    *NewNTFTSignature = 0;

    //
    // Allocate and align a buffer.
    //
    Buffer = SpMemAlloc(2 * SectorCount * BytesPerSector);
    Mbr = ALIGN(Buffer,BytesPerSector);

    //
    // Read mbr
    //
    Status = SpReadWriteDiskSectors(
                Partition0Handle,
                (HardDisks[DiskNumber].Int13Hooker == HookerEZDrive) ? 1 : 0,
                SectorCount,
                BytesPerSector,
                Mbr,
                FALSE
                );

    if(NT_SUCCESS(Status)) {
        if(U_USHORT(Mbr->AA55Signature) == MBR_SIGNATURE) {
            //
            // Valid. Slam in new boot code if there's no int13 hooker.
            //
            if(HardDisks[DiskNumber].Int13Hooker == NoHooker) {

                ASSERT(&((PON_DISK_MBR)0)->BootCode == 0);
                RtlMoveMemory(Mbr,x86BootCode,sizeof(Mbr->BootCode));

                Status = SpReadWriteDiskSectors(
                            Partition0Handle,
                            0,
                            SectorCount,
                            BytesPerSector,
                            Mbr,
                            TRUE
                            );
            }
        } else {
            //
            // Invalid. Construct a boot sector.
            //
            ASSERT(X86BOOTCODE_SIZE == sizeof(ON_DISK_MBR));

            RtlMoveMemory(Mbr,x86BootCode,X86BOOTCODE_SIZE);

            *NewNTFTSignature = SpComputeSerialNumber();
            U_ULONG(Mbr->NTFTSignature) = *NewNTFTSignature;

            U_USHORT(Mbr->AA55Signature) = MBR_SIGNATURE;

            //
            // Write the sector(s).
            //
            Status = SpReadWriteDiskSectors(
                        Partition0Handle,
                        (HardDisks[DiskNumber].Int13Hooker == HookerEZDrive) ? 1 : 0,
                        SectorCount,
                        BytesPerSector,
                        Mbr,
                        TRUE
                        );

            if (NT_SUCCESS(Status)) {
                PHARD_DISK  Disk = SPPT_GET_HARDDISK(DiskNumber);

                Disk->Signature = Disk->DriveLayout.Mbr.Signature = *NewNTFTSignature;
            }                
        }
    }

    SpMemFree(Buffer);

    return(Status);
}


#ifndef NEW_PARTITION_ENGINE

VOID
SpPtGetSectorLayoutInformation(
    IN  PDISK_REGION Region,
    OUT PULONGLONG   HiddenSectors,
    OUT PULONGLONG   VolumeSectorCount
    )

/*++

Routine Description:

    Given a region describing a partition or logical drive, return information
    about its layout on disk appropriate for the BPB when the volume is
    formatted.

Arguments:

    Region - supplies a pointer to the disk region descriptor for the
        partition or logical drive in question.

    HiidenSectors - receives the value that should be placed in the
        hidden sectors field of the BPB when the volume is formatted.

    HiidenSectors - receives the value that should be placed in the
        sector count field of the BPB when the volume is formatted.

Return Value:

    None.

--*/

{
    PON_DISK_PTE pte;

#ifdef GPT_PARTITION_ENGINE

    if (SPPT_IS_GPT_DISK(Region->DiskNumber)) {
        SpPtnGetSectorLayoutInformation(Region, 
                                        HiddenSectors, 
                                        VolumeSectorCount);

        return;
    }        

#endif                                            

    ASSERT(Region->PartitionedSpace);

    pte = &Region->MbrInfo->OnDiskMbr.PartitionTable[Region->TablePosition];

    *HiddenSectors = U_ULONG(pte->RelativeSectors);

    *VolumeSectorCount = U_ULONG(pte->SectorCount);
}

ULONG
SpPtGetOrdinal(
    IN PDISK_REGION         Region,
    IN PartitionOrdinalType OrdinalType
    )
{
    ULONG ord;


#ifdef GPT_PARTITION_ENGINE

    if (SPPT_IS_GPT_DISK(Region->DiskNumber))
        return SpPtnGetOrdinal(Region, OrdinalType);        
        
#endif


    if(Region->PartitionedSpace && (!Region->DynamicVolume || Region->MbrInfo) ) {
        //
        //  This is either a basic volume, or a dynamic volume that is listed on the MBR/EBR
        //
        switch(OrdinalType) {

        case PartitionOrdinalOriginal:

            ord = Region->MbrInfo->OriginalOrdinals[Region->TablePosition];
            break;

        case PartitionOrdinalOnDisk:

            ord = Region->MbrInfo->OnDiskOrdinals[Region->TablePosition];
            break;

        case PartitionOrdinalCurrent:

            ord = Region->MbrInfo->CurrentOrdinals[Region->TablePosition];
            break;
        }
    } else {
        //
        //  Dynamic volume that is not listed on MBR or EBR
        //
        ord = Region->TablePosition;
    }
    return(ord);
}

#endif // NEW_PARTITION_ENGINE

#define MENU_LEFT_X     3
#define MENU_WIDTH      (VideoVars.ScreenWidth-(2*MENU_LEFT_X))
#define MENU_INDENT     4

BOOLEAN
SpPtRegionDescription(
    IN  PPARTITIONED_DISK pDisk,
    IN  PDISK_REGION      pRegion,
    OUT PWCHAR            Buffer,
    IN  ULONG             BufferSize
    )
{
    WCHAR DriveLetter[3];
    ULONGLONG RegionSizeMB;
    ULONGLONG FreeSpace;
    ULONG MessageId;
    WCHAR TypeName[((sizeof(pRegion->TypeName)+sizeof(pRegion->VolumeLabel))/sizeof(WCHAR))+4];
    BOOLEAN NewDescription = FALSE;

    //
    // Get the size of the region.
    //
    RegionSizeMB = SpPtSectorCountToMB(pDisk->HardDisk, pRegion->SectorCount);

    //
    // Don't show spaces smaller than 1 MB.
    //
    if(!RegionSizeMB) {
        return(FALSE);
    }

    //
    // Get the drive letter field, type of region, and amount of free space,
    // if this is a used region.
    //
    if(pRegion->PartitionedSpace) {

        if(pRegion->DriveLetter) {
            if( pRegion->Filesystem != FilesystemFat ) {
                DriveLetter[0] = pRegion->DriveLetter;
            } else {
                if( pRegion->NextCompressed == NULL ) {
                    DriveLetter[0] = pRegion->DriveLetter;
                } else {
                    DriveLetter[0] = pRegion->HostDrive;
                }
            }
            DriveLetter[1] = L':';
        } else {
            if( pRegion->Filesystem != FilesystemDoubleSpace ) {
                DriveLetter[0] = L'-';
                DriveLetter[1] = L'-';
            } else {
                DriveLetter[0] = pRegion->MountDrive;
                DriveLetter[1] = L':';
            }
        }
        DriveLetter[2] = 0;

#ifdef NEW_PARTITION_ENGINE

        NewDescription = TRUE;
        
#endif        

#ifdef GPT_PARTITION_ENGINE

        if (SPPT_IS_GPT_DISK(pRegion->DiskNumber)) {
            NewDescription = TRUE;
        } else {
            NewDescription = FALSE;
        }

#endif

        //
        // Format the partition name
        //
        TypeName[0] = 0;        

        if (SPPT_IS_REGION_PARTITIONED(pRegion)) {
            SpPtnGetPartitionName(pRegion,
                TypeName,
                sizeof(TypeName) / sizeof(TypeName[0]));
        } else {
            swprintf( TypeName,
                      L"\\Harddisk%u\\Partition%u",
                      pRegion->DiskNumber,
                      pRegion->PartitionNumber );            
        }                      
 
        //
        // Format the text based on whether we know the amount of free space.
        //
        if(pRegion->FreeSpaceKB == (ULONG)(-1)) {

            SpFormatMessage(
                Buffer,
                BufferSize,
                SP_TEXT_REGION_DESCR_2,
                DriveLetter,
                SplangPadString(-35,TypeName),
                (ULONG)RegionSizeMB
                );

        } else {
            ULONGLONG   AuxFreeSpaceKB;

            AuxFreeSpaceKB = (pRegion->IsLocalSource)? pRegion->AdjustedFreeSpaceKB :
                                                       pRegion->FreeSpaceKB;

            //
            // If there is less than 1 meg of free space,
            // then use KB as the units for free space.
            // Otherwise, use MB.
            //
            if(AuxFreeSpaceKB < 1024) {
                MessageId = SP_TEXT_REGION_DESCR_1a;
                FreeSpace = AuxFreeSpaceKB;
            } else {
                MessageId = SP_TEXT_REGION_DESCR_1;
                FreeSpace = AuxFreeSpaceKB / 1024;

                //
                // Make sure we don't look bad...
                //
                if( FreeSpace > RegionSizeMB ) {
                    FreeSpace = RegionSizeMB;
                }
            }

            SpFormatMessage(
                Buffer,
                BufferSize,
                MessageId,
                DriveLetter,
                SplangPadString(-35,TypeName),
                (ULONG)RegionSizeMB,
                (ULONG)FreeSpace
                );
        }

    } else {

        //
        // Not a used region, use a separate format string.
        //
        SpFormatMessage(Buffer,
                BufferSize,
                SP_TEXT_REGION_DESCR_3, 
                (ULONG)RegionSizeMB);
    }

    return(TRUE);
}



BOOLEAN
SpPtIterateRegionList(
    IN  PVOID             Menu,
    IN  PPARTITIONED_DISK pDisk,
    IN  PDISK_REGION      pRegion,
    IN  BOOLEAN           InMbr,
    OUT PDISK_REGION     *FirstRegion
    )
{
    WCHAR Buffer[256];
#ifdef FULL_DOUBLE_SPACE_SUPPORT
    PDISK_REGION    Pointer;
#endif // FULL_DOUBLE_SPACE_SUPPORT

    Buffer[0] = UNICODE_NULL;

    for( ;pRegion; pRegion=pRegion->Next) {

        PMBR_INFO pBrInfo = pRegion->MbrInfo;

        //
        // If this is the extended partition,
        // iterate its contents now.
        //
        if(pRegion->PartitionedSpace
        && IsContainerPartition(pBrInfo->OnDiskMbr.PartitionTable[pRegion->TablePosition].SystemId))
        {
            //
            // This better be in the MBR!
            //
            ASSERT(InMbr);

            if(!SpPtIterateRegionList(Menu,pDisk,pDisk->ExtendedDiskRegions,FALSE,FirstRegion)) {
                return(FALSE);
            }
        } else {

            //
            // Format a description of this region and add it to the menu.
            //
            if(SpPtRegionDescription(pDisk,pRegion,Buffer,sizeof(Buffer))) {

                if(*FirstRegion == NULL) {
                    *FirstRegion = pRegion;
                }

                if(!SpMnAddItem(Menu,Buffer,MENU_LEFT_X+MENU_INDENT,MENU_WIDTH-(2*MENU_INDENT),TRUE,(ULONG_PTR)pRegion)) {
                    return(FALSE);
                }
#ifdef FULL_DOUBLE_SPACE_SUPPORT
                if( ( pRegion->Filesystem == FilesystemFat ) &&
                    ( ( Pointer = pRegion->NextCompressed ) != NULL ) ) {
                    for( ; Pointer;
                         Pointer = Pointer->NextCompressed ) {
                        if(SpPtRegionDescription(pDisk,Pointer,Buffer,sizeof(Buffer))) {
                            if(!SpMnAddItem(Menu,Buffer,MENU_LEFT_X+MENU_INDENT,MENU_WIDTH-(2*MENU_INDENT),TRUE,(ULONG)Pointer)) {
                                return(FALSE);
                            }
                         }
                    }
                }
#endif // FULL_DOUBLE_SPACE_SUPPORT
            }
        }
    }

    return(TRUE);
}


BOOLEAN
SpPtGenerateMenu(
    IN  PVOID              Menu,
    IN  PPARTITIONED_DISK  pDisk,
    OUT PDISK_REGION      *FirstRegion
    )
{
    WCHAR Buffer[256];

    //
    // Add the disk name/description.
    //
    if(!SpMnAddItem(Menu,pDisk->HardDisk->Description,MENU_LEFT_X,MENU_WIDTH,FALSE,0)) {
        return(FALSE);
    }

    //
    // Only add a line between the disk anme and partitions if we have space on
    // the screen. Not fatal if the space can't be added.
    //
    if(!SplangQueryMinimizeExtraSpacing()) {
        SpMnAddItem(Menu,L"",MENU_LEFT_X,MENU_WIDTH,FALSE,0);
    }

    //
    // If the disk is off-line, add a message indicating such.
    //
    // Also disallow installation or create/delete partition into
    // removable meida on NEC98. Because NT cannot boot from it.
    //
    if(pDisk->HardDisk->Status == DiskOffLine) {

        SpFormatMessage(
            Buffer,
            sizeof(Buffer),
            (pDisk->HardDisk->Characteristics & FILE_REMOVABLE_MEDIA)
              ? (!IsNEC_98 ? SP_TEXT_HARD_DISK_NO_MEDIA : SP_TEXT_DISK_OFF_LINE)
              : SP_TEXT_DISK_OFF_LINE
            );

        return(SpMnAddItem(Menu,Buffer,MENU_LEFT_X+MENU_INDENT,MENU_WIDTH-(2*MENU_INDENT),FALSE,0));
    }
#if 0
    else if(IsNEC_98 && (pDisk->HardDisk->Characteristics & FILE_REMOVABLE_MEDIA)) {

        SpFormatMessage(Buffer,sizeof(Buffer),SP_TEXT_DISK_OFF_LINE);

        return(SpMnAddItem(Menu,Buffer,MENU_LEFT_X+MENU_INDENT,MENU_WIDTH-(2*MENU_INDENT),FALSE,0));
    }
#endif //0

    if(!SpPtIterateRegionList(Menu,pDisk,pDisk->PrimaryDiskRegions,TRUE,FirstRegion)) {
        return(FALSE);
    }

    return(SplangQueryMinimizeExtraSpacing() ? TRUE : SpMnAddItem(Menu,L"",MENU_LEFT_X,MENU_WIDTH,FALSE,0));
}


//
// We will change item #0 in the array below as appropriate for
// the currently highlighted region.
//
ULONG PartitionMnemonics[4] = {0};

VOID
SpPtMenuCallback(
    IN ULONG_PTR UserData
    )
{
    if (UserData){
        PDISK_REGION pRegion = (PDISK_REGION)UserData;

        //
        // Don't allow deletion of the partition if the 'partition' is really
        // a DoubleSpace drive.
        //

        if(pRegion->Filesystem == FilesystemDoubleSpace) {

            PartitionMnemonics[0] = 0;

            if (ConsoleRunning) {
                SpDisplayStatusOptions(
                    DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_ESC_EQUALS_CANCEL,
                    0
                    );
            } else {
                SpDisplayStatusOptions(
                    DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_ENTER_EQUALS_INSTALL,
                    SP_STAT_F3_EQUALS_EXIT,
                    0
                    );
            }

        } else {
            PHARD_DISK  Disk = SPPT_GET_HARDDISK(pRegion->DiskNumber);
            BOOLEAN     FlipStyle = FALSE;
            BOOLEAN     MakeSysPart = FALSE;
            FilesystemType  FsType = pRegion->Filesystem;

    #ifndef OLD_PARTITION_ENGINE

            FlipStyle = SpPtnIsDiskStyleChangeAllowed(pRegion->DiskNumber);

    #endif        

            //
            // If it is a Reserved (MSR/OEM) partition on a GPT disk do not provide an option of deleting 
            // it unless we are in Recovery Console
            //
            // NOTE: Here we do not check for IA64 specifically as this change is with respect to 
            //       GPT disks having reserved partitions and potentially even X86 machines can have 
            //       GPT disks in the future and we need to block installation to their reserved partitions.
            //

            PartitionMnemonics[0] = pRegion->PartitionedSpace ? 
                ((SPPT_IS_REGION_RESERVED_GPT_PARTITION(pRegion) && !ForceConsole) ? 
                    0 : MnemonicDeletePartition) : MnemonicCreatePartition;

            PartitionMnemonics[1] = FlipStyle ? MnemonicChangeDiskStyle : 0;                                       

    #ifdef NEW_PARTITION_ENGINE

            if (SPPT_IS_REGION_SYSTEMPARTITION(pRegion)) {
                ValidArcSystemPartition = TRUE;
            }
            
            if (!ValidArcSystemPartition && !FlipStyle && SpIsArc() && 
                (FsType != FilesystemNtfs) && SpPtnIsValidESPPartition(pRegion)) {
                //
                // Need to allow conversion to system partition
                //
                MakeSysPart = TRUE;
                PartitionMnemonics[1] = MnemonicMakeSystemPartition;
            }                            

    #endif                                                     
            if (ConsoleRunning) {
                if (MakeSysPart) {
                    SpDisplayStatusOptions(
                        DEFAULT_STATUS_ATTRIBUTE,
                        SP_STAT_ESC_EQUALS_CANCEL,
                        pRegion->PartitionedSpace ? 
                            SP_STAT_D_EQUALS_DELETE_PARTITION : SP_STAT_C_EQUALS_CREATE_PARTITION,
                        SP_STAT_M_EQUALS_MAKE_SYSPART, 
                        FlipStyle ? SP_STAT_S_EQUALS_CHANGE_DISK_STYLE : 0,
                        0
                        );
                } else {
                    SpDisplayStatusOptions(
                        DEFAULT_STATUS_ATTRIBUTE,
                        SP_STAT_ESC_EQUALS_CANCEL,
                        pRegion->PartitionedSpace ? 
                            SP_STAT_D_EQUALS_DELETE_PARTITION : SP_STAT_C_EQUALS_CREATE_PARTITION,
                        FlipStyle ? SP_STAT_S_EQUALS_CHANGE_DISK_STYLE : 0,
                        0
                        );
                }
            } else {
                if (FlipStyle) {
                    SpDisplayStatusOptions(
                        DEFAULT_STATUS_ATTRIBUTE,
                        SP_STAT_ENTER_EQUALS_INSTALL,
                        pRegion->PartitionedSpace ? 
                            SP_STAT_D_EQUALS_DELETE_PARTITION : SP_STAT_C_EQUALS_CREATE_PARTITION,
                        SP_STAT_S_EQUALS_CHANGE_DISK_STYLE,
                        SP_STAT_F3_EQUALS_EXIT,
                        0
                        );
                } else {
                    if (MakeSysPart) {
                        SpDisplayStatusOptions(
                            DEFAULT_STATUS_ATTRIBUTE,
                            SP_STAT_ENTER_EQUALS_INSTALL,
                            pRegion->PartitionedSpace ? 
                                SP_STAT_D_EQUALS_DELETE_PARTITION : SP_STAT_C_EQUALS_CREATE_PARTITION,
                            SP_STAT_M_EQUALS_MAKE_SYSPART,                                
                            SP_STAT_F3_EQUALS_EXIT,
                            0
                            );
                    } else {

                        //
                        // If it is a reserved partition (GPT (MSR/OEM)) partition do not display an option 
                        // for deleting it unless we are in Recovery Console
                        //
                        
                        SpDisplayStatusOptions(
                            DEFAULT_STATUS_ATTRIBUTE,
                            SP_STAT_ENTER_EQUALS_INSTALL,
                            pRegion->PartitionedSpace ? 
                                ((SPPT_IS_REGION_RESERVED_GPT_PARTITION(pRegion) && !ForceConsole) ? 
                                    SP_EMPTY_OPTION : SP_STAT_D_EQUALS_DELETE_PARTITION) : 
                                  SP_STAT_C_EQUALS_CREATE_PARTITION,
                            SP_STAT_F3_EQUALS_EXIT,
                            0
                            );
                    }
                }
            }
        }
    }
}


BOOLEAN
SpPtIsNotReservedPartition(
    IN ULONG_PTR    UserData,
    IN ULONG        Key
    )
{
    BOOLEAN Result = TRUE;     
    
    if ((ASCI_CR == Key) &&
        (NULL != (PDISK_REGION)UserData) &&
        (SPPT_IS_REGION_RESERVED_GPT_PARTITION((PDISK_REGION)UserData))) {
                
        Result = FALSE;
    }
    
   return Result;
}
    
void
SpEnumerateDiskRegions(
    IN PSPENUMERATEDISKREGIONS EnumRoutine,
    IN ULONG_PTR Context
    )
{
    ULONG DiskNo;
    PDISK_REGION pThisRegion;


    for(DiskNo=0; (DiskNo<HardDiskCount); DiskNo++) {
        for(pThisRegion=PartitionedDisks[DiskNo].PrimaryDiskRegions; pThisRegion; pThisRegion=pThisRegion->Next) {
            if (!EnumRoutine( &PartitionedDisks[DiskNo], pThisRegion, Context )) {
                return;
            }
        }
        for(pThisRegion=PartitionedDisks[DiskNo].ExtendedDiskRegions; pThisRegion; pThisRegion=pThisRegion->Next) {
            if (!EnumRoutine( &PartitionedDisks[DiskNo], pThisRegion, Context )) {
                return;
            }
        }
    }
}


#if DBG
void
SpPtDumpPartitionData(
    void
    )
{
    ULONG DiskNo;
    PDISK_REGION pThisRegion;


    for(DiskNo=0; (DiskNo<HardDiskCount); DiskNo++) {
        for(pThisRegion=PartitionedDisks[DiskNo].PrimaryDiskRegions; pThisRegion; pThisRegion=pThisRegion->Next) {
            if (pThisRegion->FreeSpaceKB != -1) {
                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: diskno=%d, sector-start=%d, sector-count=%d, free=%dKB\n",
                    pThisRegion->DiskNumber,
                    pThisRegion->StartSector,
                    pThisRegion->SectorCount,
                    pThisRegion->FreeSpaceKB
                    ));
            }
        }
    }
}
#endif

#ifdef OLD_PARTITION_ENGINE

NTSTATUS
SpPtPrepareDisks(
    IN  PVOID         SifHandle,
    OUT PDISK_REGION *InstallRegion,
    OUT PDISK_REGION *SystemPartitionRegion,
    IN  PWSTR         SetupSourceDevicePath,
    IN  PWSTR         DirectoryOnSetupSource,
    IN  BOOLEAN       RemoteBootRepartition
    )
{
    PPARTITIONED_DISK pDisk;
    WCHAR Buffer[256];
    ULONG DiskNo;
    PVOID Menu;
    ULONG MenuTopY;
    ULONG ValidKeys[3] = { ASCI_CR, KEY_F3, 0 };
    ULONG ValidKeysCmdCons[2] = { ASCI_ESC, 0 };
    ULONG Keypress;
    PDISK_REGION pRegion;
    PDISK_REGION FirstRegion,DefaultRegion;
    BOOLEAN unattended;
    BOOLEAN createdMenu;


    //SpPtDumpPartitionData();

    if (SpIsArc()) {
        //
        // Select a system partition from among those defined in NV-RAM.
        //
        *SystemPartitionRegion = SpPtValidSystemPartitionArc(SifHandle,
                                        SetupSourceDevicePath,
                                        DirectoryOnSetupSource);
                                        
        (*SystemPartitionRegion)->IsSystemPartition = 2;
    }

    unattended = UnattendedOperation;

    while(1) {

        createdMenu = FALSE;

        Keypress = 0;

#if defined(REMOTE_BOOT)
        if (RemoteBootSetup && !RemoteInstallSetup && HardDiskCount == 0) {

            //
            // If there are no hard disks, allow diskless install
            //

            pRegion = NULL;

            //
            // Run through the rest of the code as if the user had just
            // hit enter to select this partition.
            //

            Keypress = ASCI_CR;

        } else
#endif // defined(REMOTE_BOOT)

        if (unattended && RemoteBootRepartition) {

            ULONG DiskNumber;

            //
            // Prepare the disk for remote boot installation. This involves
            // converting disk 0 into as big a partition as possible.
            //

            if (*SystemPartitionRegion != NULL) {
                DiskNumber = (*SystemPartitionRegion)->DiskNumber;
            } else {
#ifdef _X86_
                DiskNumber = SpDetermineDisk0();
#else
                DiskNumber = 0;
#endif
            }

            if (NT_SUCCESS(SpPtPartitionDiskForRemoteBoot(DiskNumber, &pRegion))) {

                SpPtRegionDescription(
                    &PartitionedDisks[pRegion->DiskNumber],
                    pRegion,
                    Buffer,
                    sizeof(Buffer)
                    );

                //
                // Run through the rest of the code as if the user had just
                // hit enter to select this partition.
                //

                Keypress = ASCI_CR;
            }
        }

        if (Keypress == 0) {

            //
            // Display the text that goes above the menu on the partitioning screen.
            //
            SpDisplayScreen(ConsoleRunning?SP_SCRN_PARTITION_CMDCONS:SP_SCRN_PARTITION,3,CLIENT_TOP+1);

            //
            // Calculate menu placement.  Leave one blank line
            // and one line for a frame.
            //
            MenuTopY = NextMessageTopLine+2;

            //
            // Create a menu.
            //
            Menu = SpMnCreate(
                        MENU_LEFT_X,
                        MenuTopY,
                        MENU_WIDTH,
                        VideoVars.ScreenHeight-MenuTopY-(SplangQueryMinimizeExtraSpacing() ? 1 : 2)-STATUS_HEIGHT
                        );

            if(!Menu) {
                return(STATUS_NO_MEMORY);
            }

            createdMenu = TRUE;

            //
            // Build up a menu of partitions and free spaces.
            //
            FirstRegion = NULL;
            for(DiskNo=0; DiskNo<HardDiskCount; DiskNo++) {

                pDisk = &PartitionedDisks[DiskNo];

                if(!SpPtGenerateMenu(Menu,pDisk,&FirstRegion)) {

                    SpMnDestroy(Menu);
                    return(STATUS_NO_MEMORY);
                }
            }

            ASSERT(FirstRegion);

            //
            // If this is unattended operation, try to use the local source
            // region if there is one. If this fails, the user will have to
            // intervene manually.
            //
            if(unattended &&
               LocalSourceRegion &&
               (!LocalSourceRegion->DynamicVolume || LocalSourceRegion->DynamicVolumeSuitableForOS)
              ) {

                pRegion = LocalSourceRegion;
                Keypress = ASCI_CR;

            } else {

                pRegion = NULL;

                if (AutoPartitionPicker && !ConsoleRunning
#if defined(REMOTE_BOOT)
                    && (!RemoteBootSetup || RemoteInstallSetup)
#endif // defined(REMOTE_BOOT)
                    ) {
                    PDISK_REGION pThisRegion;
                    ULONG RequiredKB = 0;
                    ULONG SectorNo;
                    ULONG pass;

                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: -------------------------------------------------------------\n" ));
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: Looking for an install partition\n\n" ));
                    for(DiskNo=0; (DiskNo<HardDiskCount); DiskNo++) {
                        for( pass = 0; ((pass < 2) && (pRegion == NULL)); pass ++ ) {
                            for(pThisRegion= (pass == 0) ? PartitionedDisks[DiskNo].PrimaryDiskRegions : PartitionedDisks[DiskNo].ExtendedDiskRegions,SectorNo=0; pThisRegion; pThisRegion=pThisRegion->Next,SectorNo++) {

                                //
                                // Fetch the amount of free space required on the windows nt drive.
                                //
                                SpFetchDiskSpaceRequirements( SifHandle,
                                                              pThisRegion->BytesPerCluster,
                                                              &RequiredKB,
                                                              NULL);

                                if (SpPtDeterminePartitionGood(pThisRegion,RequiredKB,TRUE))
                                {
                                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Selected install partition = (%d,%d),(%wc:),(%ws)\n",
                                             DiskNo,SectorNo,pThisRegion->DriveLetter,pThisRegion->VolumeLabel));
                                    pRegion = pThisRegion;
                                    Keypress = ASCI_CR;
                                    break;
                                }
                            }

                        }
                    }
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: -------------------------------------------------------------\n" ));
                }


                if( !pRegion ) {
                    //
                    // If there is a local source, make it the default partition.
                    //
                    DefaultRegion = (LocalSourceRegion &&
                                     (!LocalSourceRegion->DynamicVolume || LocalSourceRegion->DynamicVolumeSuitableForOS))?
                                     LocalSourceRegion : FirstRegion;

                    //
                    // Call the menu callback to initialize the status line.
                    //
                    SpPtMenuCallback((ULONG_PTR)DefaultRegion);

                    SpMnDisplay(
                        Menu,
                        (ULONG_PTR)DefaultRegion,
                        TRUE,
                        ConsoleRunning?ValidKeysCmdCons:ValidKeys,
                        PartitionMnemonics,
                        SpPtMenuCallback,
                        SpPtIsNotReservedPartition,
                        &Keypress,
                        (PULONG_PTR)(&pRegion)
                        );
                }
            }
        }

        //
        // Now act on the user's selection.
        //
        if(Keypress & KEY_MNEMONIC) {
            Keypress &= ~KEY_MNEMONIC;
        }

        if (IsNEC_98) { //NEC98
            //
            // If target hard drive has no/wrong MBR, force initialize it right now.
            //
            PPARTITIONED_DISK pDisk;
            ULONG ValidKeysInit[] = {ASCI_ESC, 0 };
            ULONG MnemonicKeysInit[] = { MnemonicInitializeDisk, 0 };


            pDisk = &PartitionedDisks[pRegion->DiskNumber];

            if(!(pDisk->HardDisk->Characteristics & FILE_REMOVABLE_MEDIA) &&
               ((U_USHORT(pDisk->MbrInfo.OnDiskMbr.AA55Signature) != MBR_SIGNATURE) ||
                (pDisk->HardDisk->FormatType != DISK_FORMAT_TYPE_NEC98)) &&
               ((Keypress == MnemonicCreatePartition) ||
                (Keypress == MnemonicDeletePartition) || (Keypress == ASCI_CR))) {

                //SpDisplayScreen(SP_SCRN_INIT_DISK_NEC98,3,HEADER_HEIGHT+1);
                SpStartScreen(
                    SP_SCRN_INIT_DISK_NEC98,
                    3,
                    CLIENT_TOP+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE,
                    pDisk->HardDisk->Description
                    );

                SpDisplayStatusOptions(
                    DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_I_EQUALS_INIT_NEC98,
                    SP_STAT_ESC_EQUALS_CANCEL,
                    0
                    );

                if(SpWaitValidKey(ValidKeysInit,NULL,MnemonicKeysInit) == ASCI_ESC) {
                    SpMnDestroy(Menu);
                    continue;
                }

                //
                // It will be not return, if successfully complete.
                //
                return( SpInitializeHardDisk_Nec98(pRegion) );
            }
        } //NEC98


        switch(Keypress) {

        case MnemonicCreatePartition:

            SpPtDoCreate(pRegion,NULL,FALSE,0,0,TRUE);
            break;

        case MnemonicDeletePartition:

            SpPtDoDelete(pRegion,SpMnGetText(Menu,(ULONG_PTR)pRegion),TRUE);
            break;

        case KEY_F3:
            SpConfirmExit();
            break;

        case ASCI_ESC:
            if (ConsoleRunning) {
                SpPtDoCommitChanges();
            }
            if (createdMenu) {
                SpMnDestroy(Menu);
                return(STATUS_SUCCESS);
            }
            return(STATUS_SUCCESS);

        case ASCI_CR:

            if(SpPtDoPartitionSelection(&pRegion,
                                        (!createdMenu) ? Buffer :
                                          SpMnGetText(Menu,(ULONG_PTR)pRegion),
                                        SifHandle,
                                        unattended,
                                        SetupSourceDevicePath,
                                        DirectoryOnSetupSource,
                                        RemoteBootRepartition)) {
                //
                // We're done here.
                //
                if (createdMenu) {
                    SpMnDestroy(Menu);
                }

                *InstallRegion = pRegion;
#if defined(REMOTE_BOOT)
                //
                // Set the install region differently if this is a remote
                // boot -- in that case, the install region is always remote.
                //
                if (RemoteBootSetup && !RemoteInstallSetup) {
                    *InstallRegion = RemoteBootTargetRegion;
                }
#endif // defined(REMOTE_BOOT)

                if (!SpIsArc()) {
                if (!IsNEC_98) { //NEC98
                    *SystemPartitionRegion = SpPtValidSystemPartition();
                } else {
                    *SystemPartitionRegion = *InstallRegion;
                } //NEC98
                }else{
                //
                // Select a system partition from among those defined in NV-RAM.
                // We have to do this again because the user may have deleted the
                // system partition previously detected.
                // Note that SpPtValidSystemPartitionArc(SifHandle) will not return if
                // a valid system partition is not found.
                //
                *SystemPartitionRegion = SpPtValidSystemPartitionArc(SifHandle, 
                                                            SetupSourceDevicePath,
                                                            DirectoryOnSetupSource);
                }

#if defined(REMOTE_BOOT)
                ASSERT(*SystemPartitionRegion ||
                       (RemoteBootSetup && !RemoteInstallSetup && (HardDiskCount == 0)));
#else
                ASSERT(*SystemPartitionRegion);
#endif // defined(REMOTE_BOOT)

                return(STATUS_SUCCESS);
            } else {
                //
                // Something happened when we tried to select the
                // partition.  Make sure that autopartition-picker
                // doesn't invoke next time through our while loop.
                //
                AutoPartitionPicker = FALSE;
            }
            break;
        }

        if (createdMenu) {
            SpMnDestroy(Menu);
        }
        unattended = FALSE;
    }
}

VOID
SpPtDoDelete(
    IN PDISK_REGION pRegion,
    IN PWSTR        RegionDescription,
    IN BOOLEAN      ConfirmIt
    )
{
    ULONG ValidKeys[3] = { ASCI_ESC, ASCI_CR, 0 };          // do not change order
    ULONG Mnemonics[2] = { MnemonicDeletePartition2, 0 };
    ULONG k;
    BOOLEAN b;
    PPARTITIONED_DISK pDisk;
    BOOLEAN LastLogical;
    ULONG           Count;

#ifdef GPT_PARTITION_ENGINE
    if (SPPT_IS_GPT_DISK(pRegion->DiskNumber)) {
        SpPtnDoDelete(pRegion,
                    RegionDescription,
                    ConfirmIt);                

        return;
    }        
#endif

    //
    // Special warning if this is a system partition.
    //
    // Do not check system partition on NEC98.
    //
    if (!IsNEC_98) { //NEC98
        if(ConfirmIt && pRegion->IsSystemPartition) {

            SpDisplayScreen(SP_SCRN_CONFIRM_REMOVE_SYSPART,3,HEADER_HEIGHT+1);

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_ENTER_EQUALS_CONTINUE,
                SP_STAT_ESC_EQUALS_CANCEL,
                0
                );

            if(SpWaitValidKey(ValidKeys,NULL,NULL) == ASCI_ESC) {
                return;
            }
        }
    } //NEC98

    if(ConfirmIt && pRegion->DynamicVolume) {

        SpDisplayScreen(SP_SCRN_CONFIRM_REMOVE_DYNVOL,3,HEADER_HEIGHT+1);

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            SP_STAT_ESC_EQUALS_CANCEL,
            0
            );

        if(SpWaitValidKey(ValidKeys,NULL,NULL) == ASCI_ESC) {
            return;
        }
    }

    //
    // CR is no longer a valid key.
    //
    ValidKeys[1] = 0;

    pDisk = &PartitionedDisks[pRegion->DiskNumber];

    //
    // Put up the confirmation screen.
    //
    if (ConfirmIt) {
        if( ( pRegion->Filesystem == FilesystemFat ) &&
            ( pRegion->NextCompressed != NULL ) ) {
            //
            // Warn the user that the partition contains compressed volumes
            //

            Count = SpGetNumberOfCompressedDrives( pRegion );

            SpStartScreen(
                SP_SCRN_CONFIRM_REMOVE_PARTITION_COMPRESSED,
                3,
                CLIENT_TOP+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                RegionDescription,
                pDisk->HardDisk->Description,
                Count
                );
        } else {

            SpStartScreen(
                SP_SCRN_CONFIRM_REMOVE_PARTITION,
                3,
                CLIENT_TOP+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                RegionDescription,
                pDisk->HardDisk->Description
                );
        }
    }

    //
    // Display the staus text.
    //
    if (ConfirmIt) {
        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_L_EQUALS_DELETE,
            SP_STAT_ESC_EQUALS_CANCEL,
            0
            );

        k = SpWaitValidKey(ValidKeys,NULL,Mnemonics);

        if(k == ASCI_ESC) {
            return;
        }

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_PLEASE_WAIT,
            0);
        
    }

    //
    // User wants to go ahead.
    // Determine whether this is the last logical drive in the
    // extended partition.
    //
    if((pRegion->MbrInfo == pDisk->FirstEbrInfo.Next)
    && (pDisk->FirstEbrInfo.Next->Next == NULL))
    {
        LastLogical = TRUE;
    } else {
        LastLogical = FALSE;
    }
    
    //
    //  Get rid of the compressed drives, if any
    //
    if( pRegion->NextCompressed != NULL ) {
        SpDisposeCompressedDrives( pRegion->NextCompressed );
        pRegion->NextCompressed = NULL;
        pRegion->MountDrive  = 0;
        pRegion->HostDrive  = 0;
    }

    b = SpPtDelete(pRegion->DiskNumber,pRegion->StartSector);
    
    if (!b) {
        if (ConfirmIt) {
            SpDisplayScreen(SP_SCRN_PARTITION_DELETE_FAILED,3,HEADER_HEIGHT+1);
            SpDisplayStatusText(SP_STAT_ENTER_EQUALS_CONTINUE,DEFAULT_STATUS_ATTRIBUTE);
            SpInputDrain();
            while(SpInputGetKeypress() != ASCI_CR) ;
        }
        return;
    }

    //
    // If we deleted the last logical drive in the extended partition,
    // then remove the extended partition also.
    //
    // Do not check system partition on NEC98.
    //
    if (!IsNEC_98) { //NEC98
        if(LastLogical) {

            //
            // Locate the extended partition.
            //
            for(pRegion=pDisk->PrimaryDiskRegions; pRegion; pRegion=pRegion->Next) {

                if(pRegion->PartitionedSpace
                && IsContainerPartition(pRegion->MbrInfo->OnDiskMbr.PartitionTable[pRegion->TablePosition].SystemId))
                {
                    //
                    // Found it -- now delete it.
                    //
                    b = SpPtDelete(pRegion->DiskNumber,pRegion->StartSector);
                    ASSERT(b);
                    break;
                }
            }
        }
    } //NEC98

    //
    //  Delete the drive letters if the necessary. This is to ensure that the drive letters assigned to CD-ROM
    //  drives will go away, when the the disks have no partitioned space.
    //
    SpPtDeleteDriveLetters();
}

BOOLEAN
SpPtDoCreate(
    IN  PDISK_REGION  pRegion,
    OUT PDISK_REGION *pActualRegion, OPTIONAL
    IN  BOOLEAN       ForNT,
    IN  ULONGLONG     DesiredMB OPTIONAL,
    IN  PPARTITION_INFORMATION_EX PartInfo OPTIONAL,
    IN  BOOLEAN       ConfirmIt
    )
{
    ULONG ValidKeys[3] = { ASCI_ESC, ASCI_CR, 0 };
    BOOLEAN b;
    PPARTITIONED_DISK pDisk;
    ULONGLONG MinMB,MaxMB;
    ULONG TotalPrimary,RecogPrimary;
    BOOLEAN InExtended;
    UCHAR CreateSysId;
    UCHAR RealSysId;
    BOOLEAN ExtendedExists;
    ULONGLONG SizeMB,RealSizeMB;
    WCHAR Buffer[200];
    WCHAR SizeBuffer[10];
    BOOLEAN Beyond1024;
    BOOLEAN ReservedRegion;
    UCHAR DesiredSysId = 0;
    PARTITION_INFORMATION_EX NewPartInfo;

#ifdef GPT_PARTITION_ENGINE
    if (SPPT_IS_GPT_DISK(pRegion->DiskNumber)) {
        return SpPtnDoCreate(pRegion,
                        pActualRegion,
                        ForNT,
                        DesiredMB,
                        PartInfo,
                        ConfirmIt);
    }                                
#endif                        

    RtlZeroMemory(&NewPartInfo, sizeof(PARTITION_INFORMATION_EX));

    DesiredSysId = PartInfo ? PartInfo->Mbr.PartitionType : 0;

    ASSERT(!pRegion->PartitionedSpace);

    pDisk = &PartitionedDisks[pRegion->DiskNumber];

    //
    // Determine whether this space is within the extended partition.
    //

# if 0
    //
    // No NEC98 has Extended partition.
    // All of partition on NEC98 are Primary.
    //
    InExtended = (!IsNEC_98) ? (BOOLEAN)(SpPtLookupRegionByStart(pDisk,TRUE,pRegion->StartSector) != NULL) : FALSE; //NEC98
# endif //0
    InExtended = (BOOLEAN)(SpPtLookupRegionByStart(pDisk,TRUE,pRegion->StartSector) != NULL);
    Beyond1024 = SpIsRegionBeyondCylinder1024(pRegion);

    if( pDisk->HardDisk->Geometry.MediaType == RemovableMedia ) {
        ULONG           pass;
        PDISK_REGION    p;

        //
        // If the user is attempting to create a partition on a removable drive, then make sure that
        // the drive doesn't already contain a primary partition or a logical drive.
        //
        for( pass = 0; pass < 2; pass++ ) {
            for( p = (pass == 0)? pDisk->PrimaryDiskRegions : pDisk->ExtendedDiskRegions;
                 p;
                 p = p->Next ) {
                if( p->PartitionedSpace ) {
                    PON_DISK_PTE pte;
                    UCHAR   TmpSysId;

                    pte = &p->MbrInfo->OnDiskMbr.PartitionTable[p->TablePosition];
                    TmpSysId = pte->SystemId;
                    if( !IsContainerPartition(TmpSysId) ) {
                        ULONG ValidKeys1[2] = { ASCI_CR ,0 };

                        //
                        // Disk is already partitioned
                        //
                        SpDisplayScreen(SP_SCRN_REMOVABLE_ALREADY_PARTITIONED,3,HEADER_HEIGHT+1);
                        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_ENTER_EQUALS_CONTINUE,0);
                        SpWaitValidKey(ValidKeys1,NULL,NULL);
                        return( FALSE );
                    }
                }
            }
        }
    }

    //
    // Determine the type of partition to create for this space,
    // excluding any issues with extended partitions.
    //

    if (DesiredSysId != 0) {
        //
        // If the caller specified a partition type, use it unless it
        // won't work due to being beyond 1024 cylinders.
        //
#if 0
        RealSysId = DesiredSysId;
        if (Beyond1024) {
            if (RealSysId == PARTITION_FAT32) {
                RealSysId = PARTITION_FAT32_XINT13;
            } else {
                RealSysId = PARTITION_XINT13;
            }
        }
#else
        //
        // Keep this code in until I determine if we will be explicitly
        // creating extended partitions.
        //
        RealSysId = Beyond1024 ? PARTITION_XINT13 : PARTITION_HUGE;
#endif
    } else {
        RealSysId = Beyond1024 ? PARTITION_XINT13 : PARTITION_HUGE;
    }

    //
    // Determine the type of partition to create in the space.
    //
    // If the free space is within the extended partition, create
    // a logical drive.
    //
    // If there is no primary partition, create a primary partition.
    //
    // If there is a primary partition and no extended partition,
    // create an extended partition spanning the entire space and
    // then a logical drive within it of the size given by the user.
    //
    // If there is space in the partition table, create a primary partition.
    //
    if(InExtended) {

        CreateSysId = RealSysId;

    } else {

        //
        // Get statistics about primary partitions.
        //
        SpPtCountPrimaryPartitions(pDisk,&TotalPrimary,&RecogPrimary,&ExtendedExists);

        //
        // If there is no primary partition, create one.
        //
        if(!RecogPrimary) {

            CreateSysId = RealSysId;

        } else {

            //
            // Make sure we can create a new primary/extended partition.
            //
            if(TotalPrimary < PTABLE_DIMENSION) {

                //
                // If there is an extended partition, then we have no choice but
                // to create another primary.
                //
                if(ExtendedExists) {
                    CreateSysId = RealSysId;
                } else {
                    //
                    // Firmware doesn't understand type F link partitions.
                    // No great need to use on x86 either; assume that creating
                    // logical drives with the correct type is good enough.
                    //

                    //
                    // No NEC98 has PARTITION_EXTENDED, just PARTITION_HUGE only.
                    //
                    CreateSysId = (!IsNEC_98 ||
                                   (pDisk->HardDisk->FormatType == DISK_FORMAT_TYPE_PCAT))
                        ? PARTITION_EXTENDED : PARTITION_HUGE; //NEC98
                    if((CreateSysId == PARTITION_EXTENDED) && Beyond1024) {
                                    CreateSysId = PARTITION_XINT13_EXTENDED;
                    }
                }
            } else {
                if (ConfirmIt) {
                    while (TRUE) {
                        ULONG ks[2] = { ASCI_CR,0 };

                        SpDisplayScreen(SP_SCRN_PART_TABLE_FULL,3,CLIENT_HEIGHT+1);

                        SpDisplayStatusOptions(
                            DEFAULT_STATUS_ATTRIBUTE,
                            SP_STAT_ENTER_EQUALS_CONTINUE,
                            0
                            );

                        switch(SpWaitValidKey(ks,NULL,NULL)) {
                        case ASCI_CR:
                            return(FALSE);
                        }
                    }
                } else {
                    return TRUE;
                }
            }
        }
    }

    //
    // Get the mimimum and maximum sizes for the partition.
    //
    ReservedRegion = FALSE;
    SpPtQueryMinMaxCreationSizeMB(
        pRegion->DiskNumber,
        pRegion->StartSector,
        (BOOLEAN)IsContainerPartition(CreateSysId),
        InExtended,
        &MinMB,
        &MaxMB,
        &ReservedRegion
        );

    if( ReservedRegion ) {
        ULONG ValidKeys1[2] = { ASCI_CR ,0 };

        SpStartScreen(
            SP_SCRN_REGION_RESERVED,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE
            );

        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_ENTER_EQUALS_CONTINUE,0);
        SpWaitValidKey(ValidKeys1,NULL,NULL);
        return(FALSE);
    }

    if(ForNT) {

        //
        // If a size was requested then try to use that, otherwise use
        // the maximum.
        //
        if (DesiredMB != 0) {
            if (DesiredMB <= MaxMB) {
                SizeMB = DesiredMB;
            } else {
                return FALSE;
            }
        } else {
            SizeMB = MaxMB;
        }

    } else {

        //
        // Put up a screen displaying min/max size info.
        //
        SpStartScreen(
            SP_SCRN_CONFIRM_CREATE_PARTITION,
            3,
            CLIENT_TOP+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            pDisk->HardDisk->Description,
            MinMB,
            MaxMB
            );

        //
        // Display the staus text.
        //
        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_CREATE,
            SP_STAT_ESC_EQUALS_CANCEL,
            0
            );

        //
        // Get and display the size prompt.
        //
        SpFormatMessage(Buffer,sizeof(Buffer),SP_TEXT_SIZE_PROMPT);

        SpvidDisplayString(Buffer,DEFAULT_ATTRIBUTE,3,NextMessageTopLine);

        //
        // Get the size from the user.
        //
        do {

            swprintf(SizeBuffer,L"%u",MaxMB);
            if(!SpGetInput(SpPtnGetSizeCB,SplangGetColumnCount(Buffer)+5,NextMessageTopLine,5,SizeBuffer,TRUE, 0)) {

                //
                // User pressed escape and bailed.
                //
                return(FALSE);
            }

            SizeMB = (ULONG)SpStringToLong(SizeBuffer,NULL,10);

        } while((SizeMB < MinMB) || (SizeMB > MaxMB));
    }

    if(IsContainerPartition(CreateSysId)) {
        RealSizeMB = SizeMB;
        SizeMB = MaxMB;
    }

    NewPartInfo.PartitionStyle = PARTITION_STYLE_MBR;
    NewPartInfo.Mbr.PartitionType = CreateSysId;

    //
    // Create the partition.
    //
    b = SpPtCreate(
            pRegion->DiskNumber,
            pRegion->StartSector,
            SizeMB,
            InExtended,
            &NewPartInfo,
            pActualRegion
            );

    ASSERT(b);

    //
    // Create the logical drive if we just created the extended partition.
    //
    if(IsContainerPartition(CreateSysId)) {

        ASSERT(!InExtended);

        NewPartInfo.Mbr.PartitionType = RealSysId;

        b = SpPtCreate(
                pRegion->DiskNumber,
                pRegion->StartSector,
                RealSizeMB,
                TRUE,
                &NewPartInfo,
                pActualRegion
                );

        ASSERT(b);
    }

    return(TRUE);
}

#endif // NEW_PARTITION_ENGINE



//
// The following table contains offsets from SP_TEXT_PARTITION_NAME_BASE
// to get the message id of the name of each type of partition.
// A -1 entry means there is no name in the message file for this type
// of partition or that the filesystem should be determined instead.
//
//
#define PT(id)      ((UCHAR)((SP_TEXT_PARTITION_NAME_##id)-SP_TEXT_PARTITION_NAME_BASE))
#define UNKNOWN     PT(UNK)
#define M1          ((UCHAR)(-1))

UCHAR PartitionNameIds[256] = {

    M1,M1,PT(XENIX),PT(XENIX),                      // 00-03
    M1,M1,M1,M1,                                    // 04-07
    UNKNOWN,UNKNOWN,PT(BOOTMANAGER),M1,             // 08-0b
    M1,UNKNOWN,M1,M1,                               // 0c-0f
    UNKNOWN,UNKNOWN,PT(EISA),UNKNOWN,               // 10-13
    UNKNOWN,UNKNOWN,PT(BMHIDE),PT(BMHIDE),          // 14-17
    UNKNOWN,UNKNOWN,UNKNOWN,PT(BMHIDE),             // 18-1b
    PT(BMHIDE),UNKNOWN,UNKNOWN,UNKNOWN,             // 1c-1f
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 20-23
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 24-27
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 28-2b
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 2c-2f
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 30-33
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 34-37
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 38-3b
    PT(PWRQST),UNKNOWN,UNKNOWN,UNKNOWN,             // 3c-3f
    UNKNOWN,PT(PPCBOOT),PT(VERIT),PT(VERIT),        // 40-43
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 44-47
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 48-4b
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 4c-4f
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 50-53
    PT(ONTRACK),PT(EZDRIVE),UNKNOWN,UNKNOWN,        // 54-57
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 58-5b
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 5c-5f
    UNKNOWN,UNKNOWN,UNKNOWN,PT(UNIX),               // 60-63
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 64-67
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 68-6b
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 6c-6f
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 70-73
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 74-77
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 78-7b
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 7c-7f
    UNKNOWN,PT(NTFT),UNKNOWN,UNKNOWN,               // 80-83
    PT(NTFT),UNKNOWN,PT(NTFT),PT(NTFT),             // 84-87
    UNKNOWN,UNKNOWN,UNKNOWN,PT(NTFT),               // 88-8b
    PT(NTFT),UNKNOWN,PT(NTFT),UNKNOWN,              // 8c-8f
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 90-93
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 94-97
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 98-9b
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // 9c-9f
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // a0-a3
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // a4-a7
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // a8-ab
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // ac-af
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // b0-b3
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // b4-b7
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // b8-bb
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // bc-bf
    UNKNOWN,PT(NTFT),UNKNOWN,UNKNOWN,               // c0-c3
    PT(NTFT),UNKNOWN,PT(NTFT),PT(NTFT),             // c4-c7
    UNKNOWN,UNKNOWN,UNKNOWN,PT(NTFT),               // c8-cb
    PT(NTFT),UNKNOWN,PT(NTFT),UNKNOWN,              // cc-cf
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // d0-d3
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // d4-d7
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // d8-db
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // dc-df
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // e0-e3
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // e4-e7
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // e8-eb
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // ec-ef
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // f0-f3
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // f4-f7
    UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,                // f8-fb
    UNKNOWN,UNKNOWN,UNKNOWN,PT(XENIXTABLE)          // fc-ff
};


WCHAR
SpGetDriveLetter(
    IN  PWSTR   DeviceName,
    OUT  PMOUNTMGR_MOUNT_POINT * MountPoint OPTIONAL
    )

/*++

Routine Description:

    This routine returns the drive letter associated to a given device.

Arguments:

    DeviceName  - Supplies the device name.

    MountPoint  - If specified, causes the function to allocate a mount
                  manager point and fills it in.

Return Value:

    A drive letter, if one exists.

--*/

{
    NTSTATUS                        Status;
    OBJECT_ATTRIBUTES               Obja;
    UNICODE_STRING                  UnicodeString;
    IO_STATUS_BLOCK                 IoStatusBlock;
    HANDLE                          Handle;
    DWORD                           nameLen;
    DWORD                           mountPointSize;
    PMOUNTMGR_MOUNT_POINT           mountPoint;
    PMOUNTMGR_MOUNT_POINTS          mountPoints;
    PMOUNTMGR_TARGET_NAME           mountTarget;
    DWORD                           bytes;
    WCHAR                           driveLetter;
    DWORD                           i;
    PWSTR                           s;
    LARGE_INTEGER                   DelayTime;


    INIT_OBJA(&Obja,&UnicodeString,MOUNTMGR_DEVICE_NAME);

    Status = ZwOpenFile(
                &Handle,
                (ACCESS_MASK)(FILE_GENERIC_READ),
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE ,
                FILE_NON_DIRECTORY_FILE
              );

    if( !NT_SUCCESS( Status ) ) {
        return L'\0';
    }

    //
    // setup a good device name
    //

    nameLen = wcslen(DeviceName);
    mountPointSize = sizeof(MOUNTMGR_TARGET_NAME) + nameLen*sizeof(WCHAR) + 28;
    mountTarget = SpMemAlloc(mountPointSize);

    if (!mountTarget) {
        ZwClose(Handle);
        return L'\0';
    }

    RtlZeroMemory(mountTarget, mountPointSize);
    mountTarget->DeviceNameLength = (USHORT) nameLen*sizeof(WCHAR);
    RtlCopyMemory((PCHAR) &mountTarget->DeviceName, DeviceName, nameLen*sizeof(WCHAR));

    //
    // this loop is necessary as a synchronization
    // method.  we have previously committed changes, but
    // the volume manager has not had a chance to
    // do it's thing so here we wait......
    //

    for (i=0; i<20; i++) {
        Status = ZwDeviceIoControlFile(
                        Handle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION,
                        mountTarget,
                        mountPointSize,
                        NULL,
                        0
                        );
        if (!NT_SUCCESS( Status )) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION failed - %08x\n",Status));
            DelayTime.HighPart = -1;
            DelayTime.LowPart = (ULONG)(-5000000);
            KeDelayExecutionThread(KernelMode,FALSE,&DelayTime);
        } else {
            //
            //  On removable disks, a drive letter may not have been assigned yet.
            //  So make sure one is assigned on this case.
            //
            MOUNTMGR_DRIVE_LETTER_INFORMATION DriveLetterInformation;
            NTSTATUS                          Status1;

            Status1 = ZwDeviceIoControlFile(
                            Handle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER,
                            mountTarget,
                            mountPointSize,
                            &DriveLetterInformation,
                            sizeof(MOUNTMGR_DRIVE_LETTER_INFORMATION)
                            );
            if (!NT_SUCCESS( Status1 )) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER failed. Status = %lx \n",Status1));
            }
            break;
        }
    }

    if (!NT_SUCCESS( Status )) {
        SpMemFree(mountTarget);
        ZwClose(Handle);
        return L'\0';
    }

    SpMemFree(mountTarget);

    nameLen = wcslen(DeviceName);
    mountPointSize = sizeof(MOUNTMGR_MOUNT_POINT) + nameLen*sizeof(WCHAR) + 28;
    mountPoint = SpMemAlloc(mountPointSize);
    if (!mountPoint) {
        ZwClose(Handle);
        return L'\0';
    }

    RtlZeroMemory(mountPoint, mountPointSize);
    mountPoint->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    mountPoint->DeviceNameLength = (USHORT) nameLen*sizeof(WCHAR);

    RtlCopyMemory((PCHAR) mountPoint + sizeof(MOUNTMGR_MOUNT_POINT),
               DeviceName, nameLen*sizeof(WCHAR));

    mountPoints = SpMemAlloc( 4096 );
    if (!mountPoints) {
        SpMemFree(mountPoint);
        ZwClose(Handle);
        return L'\0';
    }

    Status = ZwDeviceIoControlFile(
                    Handle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    IOCTL_MOUNTMGR_QUERY_POINTS,
                    mountPoint,
                    mountPointSize,
                    mountPoints,
                    4096
                    );

    if (!NT_SUCCESS( Status )) {
        if (Status == STATUS_BUFFER_OVERFLOW) {
            bytes = mountPoints->Size;
            SpMemFree(mountPoints);
            mountPoints = SpMemAlloc(bytes);
            if (!mountPoints) {
                SpMemFree(mountPoint);
                ZwClose(Handle);
                return L'\0';
            }

            Status = ZwDeviceIoControlFile(
                            Handle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            IOCTL_MOUNTMGR_QUERY_POINTS,
                            mountPoint,
                            mountPointSize,
                            mountPoints,
                            bytes
                          );

            if (!NT_SUCCESS( Status )) {
                SpMemFree(mountPoints);
                SpMemFree(mountPoint);
                ZwClose(Handle);
                return L'\0';
            }
        } else {
            mountPoints->NumberOfMountPoints = 0;
        }
    }

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
        "SETUP: IOCTL_MOUNTMGR_QUERY_POINTS : Number = %d \n",
        mountPoints->NumberOfMountPoints));
    

    driveLetter = 0;
    
    for (i = 0; i < mountPoints->NumberOfMountPoints; i++) {

        if (mountPoints->MountPoints[i].SymbolicLinkNameLength != 28) {
            continue;
        }

        s = (PWSTR) ((PCHAR) mountPoints +
                     mountPoints->MountPoints[i].SymbolicLinkNameOffset);

        if (s[0] != L'\\' ||
            (s[1] != L'D' && s[1] != L'd') ||
            (s[2] != L'O' && s[2] != L'o') ||
            (s[3] != L'S' && s[3] != L's') ||
            (s[4] != L'D' && s[4] != L'd') ||
            (s[5] != L'E' && s[5] != L'e') ||
            (s[6] != L'V' && s[6] != L'v') ||
            (s[7] != L'I' && s[7] != L'i') ||
            (s[8] != L'C' && s[8] != L'c') ||
            (s[9] != L'E' && s[9] != L'e') ||
            (s[10]!= L'S' && s[10]!= L's') ||
            s[11] != L'\\' ||
            s[13] != L':') {

            continue;
        }

        if (s[12] < ((!IsNEC_98) ? L'C' : L'A') || s[12] > L'Z') { //NEC98
            continue;
        }

        driveLetter = s[12];

        if (ARGUMENT_PRESENT( MountPoint )) {

            ULONG newMountPointSize;
            PMOUNTMGR_MOUNT_POINT newMountPoint, oldMountPoint;
            ULONG currentOffset;

            //
            // The caller wants us to return the actual mount point information.
            //

            oldMountPoint = &mountPoints->MountPoints[i];

            newMountPointSize = sizeof(MOUNTMGR_MOUNT_POINT) +
                                oldMountPoint->SymbolicLinkNameLength +
                                oldMountPoint->UniqueIdLength +
                                oldMountPoint->DeviceNameLength;
            newMountPoint = SpMemAlloc(newMountPointSize);
            if (newMountPoint) {

                currentOffset = sizeof(MOUNTMGR_MOUNT_POINT);

                newMountPoint->SymbolicLinkNameLength = oldMountPoint->SymbolicLinkNameLength;
                newMountPoint->SymbolicLinkNameOffset = currentOffset;
                memcpy((PCHAR)newMountPoint + newMountPoint->SymbolicLinkNameOffset,
                       (PCHAR)mountPoints + oldMountPoint->SymbolicLinkNameOffset,
                       oldMountPoint->SymbolicLinkNameLength);
                currentOffset += oldMountPoint->SymbolicLinkNameLength;

                newMountPoint->UniqueIdLength = oldMountPoint->UniqueIdLength;
                newMountPoint->UniqueIdOffset = currentOffset;
                memcpy((PCHAR)newMountPoint + newMountPoint->UniqueIdOffset,
                       (PCHAR)mountPoints + oldMountPoint->UniqueIdOffset,
                       oldMountPoint->UniqueIdLength);
                currentOffset += oldMountPoint->UniqueIdLength;

                newMountPoint->DeviceNameLength = oldMountPoint->DeviceNameLength;
                newMountPoint->DeviceNameOffset = currentOffset;
                memcpy((PCHAR)newMountPoint + newMountPoint->DeviceNameOffset,
                       (PCHAR)mountPoints + oldMountPoint->DeviceNameOffset,
                       oldMountPoint->DeviceNameLength);

                *MountPoint = newMountPoint;
            }
        }
        break;
    }

    SpMemFree(mountPoints);
    SpMemFree(mountPoint);
    ZwClose(Handle);

    return driveLetter;
}

WCHAR
SpDeleteDriveLetter(
    IN  PWSTR   DeviceName
    )

/*++

Routine Description:

    This routine returns the drive letter associated to a given device.

Arguments:

    DeviceName  - Supplies the device name.

Return Value:

    A drive letter, if one exists.

--*/

{
    NTSTATUS                        Status;
    OBJECT_ATTRIBUTES               Obja;
    UNICODE_STRING                  UnicodeString;
    IO_STATUS_BLOCK                 IoStatusBlock;
    HANDLE                          Handle;
    DWORD                           nameLen;
    DWORD                           mountPointSize;
    PMOUNTMGR_MOUNT_POINT           mountPoint;
    PMOUNTMGR_MOUNT_POINTS          mountPoints;
    DWORD                           bytes;
    WCHAR                           driveLetter;


    INIT_OBJA(&Obja,&UnicodeString,MOUNTMGR_DEVICE_NAME);

    Status = ZwOpenFile(
                &Handle,
                (ACCESS_MASK)(FILE_GENERIC_READ),
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE ,
                FILE_NON_DIRECTORY_FILE
              );

    if( !NT_SUCCESS( Status ) ) {
        return L'\0';
    }

    nameLen = wcslen(DeviceName);
    mountPointSize = sizeof(MOUNTMGR_MOUNT_POINT) + nameLen*sizeof(WCHAR) + 28;
    mountPoint = SpMemAlloc(mountPointSize);
    if (!mountPoint) {
        ZwClose(Handle);
        return L'\0';
    }

    RtlZeroMemory(mountPoint, sizeof(MOUNTMGR_MOUNT_POINT));
    mountPoint->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    mountPoint->DeviceNameLength = (USHORT) nameLen*sizeof(WCHAR);

    RtlCopyMemory((PCHAR) mountPoint + sizeof(MOUNTMGR_MOUNT_POINT),
               DeviceName, nameLen*sizeof(WCHAR));

    mountPoints = SpMemAlloc( 4096 );
    if (!mountPoints) {
        SpMemFree(mountPoint);
        ZwClose(Handle);
        return L'\0';
    }

    Status = ZwDeviceIoControlFile(
                    Handle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    IOCTL_MOUNTMGR_DELETE_POINTS,
                    mountPoint,
                    mountPointSize,
                    mountPoints,
                    4096
                    );



    if (!NT_SUCCESS( Status )) {
        if (Status == STATUS_BUFFER_OVERFLOW) {
            bytes = mountPoints->Size;
            SpMemFree(mountPoints);
            mountPoints = SpMemAlloc(bytes);
            if (!mountPoints) {
                SpMemFree(mountPoint);
                ZwClose(Handle);
                return L'\0';
            }

            Status = ZwDeviceIoControlFile(
                            Handle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            IOCTL_MOUNTMGR_DELETE_POINTS,
                            mountPoint,
                            mountPointSize,
                            mountPoints,
                            bytes
                          );

            if (!NT_SUCCESS( Status )) {
                SpMemFree(mountPoints);
                SpMemFree(mountPoint);
                ZwClose(Handle);
                return L'\0';
            }
        } else {
            mountPoints->NumberOfMountPoints = 0;
        }
    }

    driveLetter = 0;

    SpMemFree(mountPoints);
    SpMemFree(mountPoint);
    ZwClose(Handle);

    return driveLetter;
}

VOID
SpPtDeleteDriveLetters(
    VOID
    )

/*++

Routine Description:

    This routine will delete all drive letters assigned to disks and CD-ROM drives. The deletion will
    occur only if setup was started booting from the CD or boot floppies (in which case drive letter
    migration does not take place), and only if the non-removable dissks have no partitioned spaces.
    This ensures that on a clean install from the CD or boot floppies, the drive letters assigned to
    partitions on removable disks and CD-ROM drives will always be greater than the drive letters assigned
    to partitions on non-removable disks (unless the partitions on the removable disks were created before
    the ones in the removable disks, during textmode setup).


Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG disk;
    PDISK_REGION pRegion;
    unsigned pass;
    BOOLEAN PartitionedSpaceFound = FALSE;

    if( WinntSetup ) {
        //
        // If setup started from winnt32.exe then do not delete the drive letters since we want to preserve them
        //
        return;
    }

    //
    //  Setup started booting from a CD or from the boot floppies
    //  Find out if the disks contain at least one partition that is not a container.
    //  Note that we do not take into consideration partitions that are on removable media.
    //  This is to avoid the situation in which a newly created partition on a non-removable disk ends up with
    //  a drive letter that is greater than the one assigned to an existing partition on a removable disk.
    //
    for(disk = 0;
        !PartitionedSpaceFound &&
        (disk<HardDiskCount);
        disk++) {
        if((PartitionedDisks[disk].HardDisk)->Geometry.MediaType != RemovableMedia) {
            for(pass=0; !PartitionedSpaceFound && (pass<2); pass++) {
                pRegion = pass ? PartitionedDisks[disk].ExtendedDiskRegions : PartitionedDisks[disk].PrimaryDiskRegions;
                for( ; !PartitionedSpaceFound && pRegion; pRegion=pRegion->Next) {
                    UCHAR SystemId = PARTITION_ENTRY_UNUSED;

#ifdef OLD_PARTITION_TABLE                    
                    SystemId = pRegion->MbrInfo->OnDiskMbr.PartitionTable[pRegion->TablePosition].SystemId;
#else
                    if (SPPT_IS_MBR_DISK(disk) && SPPT_IS_REGION_PARTITIONED(pRegion)) {
                        SystemId = SPPT_GET_PARTITION_TYPE(pRegion);
                    } 
#endif                    
                                        
                    if(pRegion->PartitionedSpace && !IsContainerPartition(SystemId)) {
                        PartitionedSpaceFound = TRUE;
                    }
                }
            }
        }
    }

    if( !PartitionedSpaceFound ) {
        //
        //  If the disks have no partitioned regions that are not a container,
        //  then delete all drive letters, so that the drive letters for each CD-ROM drive
        //  also get deleted.
        //

        NTSTATUS                Status;
        OBJECT_ATTRIBUTES       Obja;
        IO_STATUS_BLOCK         IoStatusBlock;
        UNICODE_STRING          UnicodeString;
        HANDLE                  Handle;

        INIT_OBJA(&Obja,&UnicodeString,MOUNTMGR_DEVICE_NAME);

        Status = ZwOpenFile( &Handle,
                             (ACCESS_MASK)(FILE_GENERIC_READ | FILE_GENERIC_WRITE),
                             &Obja,
                             &IoStatusBlock,
                             FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_NON_DIRECTORY_FILE );

        if( NT_SUCCESS( Status ) ) {

            MOUNTMGR_MOUNT_POINT    MountMgrMountPoint;

            MountMgrMountPoint.SymbolicLinkNameOffset = 0;
            MountMgrMountPoint.SymbolicLinkNameLength = 0;
            MountMgrMountPoint.UniqueIdOffset = 0;
            MountMgrMountPoint.UniqueIdLength = 0;
            MountMgrMountPoint.DeviceNameOffset = 0;
            MountMgrMountPoint.DeviceNameLength = 0;

            Status = ZwDeviceIoControlFile( Handle,
                                            NULL,
                                            NULL,
                                            NULL,
                                            &IoStatusBlock,
                                            IOCTL_MOUNTMGR_DELETE_POINTS,
                                            &MountMgrMountPoint,
                                            sizeof( MOUNTMGR_MOUNT_POINT ),
                                            TemporaryBuffer,
                                            sizeof( TemporaryBuffer ) );
            if( !NT_SUCCESS( Status ) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to delete drive letters. ZwDeviceIoControl( IOCTL_MOUNTMGR_DELETE_POINTS ) failed. Status = %lx \n", Status));
            } else {
                //
                // If the drive letters got deleted then reset the drive letters assigned to all partitions.
                // Note that we only really care about resetting the drive letters on the partitions on the
                // removable disks, since, if we got that far, there won't be any partition on the non-removable
                // disks
                //
                for(disk = 0; (disk<HardDiskCount); disk++) {
                    if ((PartitionedDisks[disk].HardDisk)->Geometry.MediaType == RemovableMedia) {
                        for(pass=0; pass<2; pass++) {
                            pRegion = pass ? PartitionedDisks[disk].ExtendedDiskRegions : PartitionedDisks[disk].PrimaryDiskRegions;
                            for( ; pRegion; pRegion=pRegion->Next) {
                                UCHAR SystemId = SpPtGetPartitionType(pRegion);
                            
                                if(pRegion->PartitionedSpace && !IsContainerPartition(SystemId)) {
                                   pRegion->DriveLetter = 0;
                                }
                            }
                        }
                    }
                }
            }

            ZwClose( Handle );

        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to delete drive letters. ZwOpenFile( %ls ) failed. Status = %lx \n", MOUNTMGR_DEVICE_NAME, Status));
        }
    }
}

VOID
SpPtAssignDriveLetters(
    VOID
    )
{
    ULONG disk;
    PDISK_REGION pRegion;
    unsigned pass;

    //
    // Before initializing the drive letters, delete them if necessary.
    // This is to get rid of the letters assigned to CD-ROM drives and removables, when the disks have no
    // partitioned space.
    //
    SpPtDeleteDriveLetters();

    //
    // Initialize all drive letters to nothing.
    // If it the region is a partitioned space, then assign a drive letter also.
    //
    for(disk=0; disk<HardDiskCount; disk++) {
        // assign drive letters for removeable media also for command console
        if(ForceConsole || ((PartitionedDisks[disk].HardDisk)->Geometry.MediaType != RemovableMedia)) {
            for(pass=0; pass<2; pass++) {
                pRegion = pass ? PartitionedDisks[disk].ExtendedDiskRegions : PartitionedDisks[disk].PrimaryDiskRegions;
                for( ; pRegion; pRegion=pRegion->Next) {
                    UCHAR SystemId = SpPtGetPartitionType(pRegion);
                    
                    pRegion->DriveLetter = 0;
                    
                    if(pRegion->PartitionedSpace && !IsContainerPartition(SystemId)) {
                        //
                        // Get the nt pathname for this region.
                        //
                        SpNtNameFromRegion(
                            pRegion,
                            TemporaryBuffer,
                            sizeof(TemporaryBuffer),
                            PartitionOrdinalCurrent
                            );
                        //
                        //  Assign a drive letter for this region
                        //
                        pRegion->DriveLetter = SpGetDriveLetter( TemporaryBuffer, NULL );
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Partition = %ls (%ls), DriveLetter = %wc: \n", TemporaryBuffer, (pass)? L"Extended" : L"Primary", pRegion->DriveLetter));
                    }
                }
            }
        }
    }
}


VOID
SpPtRemapDriveLetters(
    IN BOOLEAN DriveAssign_AT
    )
{
    PWSTR p;
    NTSTATUS Status;
    UNICODE_STRING StartDriveLetterFrom;
    UNICODE_STRING Dummy;
    STRING ntDeviceName;
    UCHAR deviceNameBuffer[256] = "\\Device\\Harddisk0\\Partition1";
    UCHAR systemRootBuffer[256] = "C:\\$WIN_NT$.~BT";
    ANSI_STRING ansiString;
    BOOLEAN ForceUnmap = FALSE;

    RTL_QUERY_REGISTRY_TABLE SetupTypeTable[]=
        {
          {NULL,
           RTL_QUERY_REGISTRY_DIRECT,
           L"DriveLetter",
           &StartDriveLetterFrom,
           REG_SZ,
           &Dummy,
           0
           },
          {NULL,0,NULL,NULL,REG_NONE,NULL,0}
        };

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: DriveAssign_AT = %d.\n",(DriveAssign_AT ? 1 : 0)));


    //
    //  Determin whether how to drive assign is 98 (HD start is A) or
    //  AT (HD start C).
    //
    RtlInitUnicodeString(&StartDriveLetterFrom, NULL);
    RtlInitUnicodeString(&Dummy, NULL);

    Status = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE,
                         L"\\Registry\\MACHINE\\SYSTEM\\Setup",
                         SetupTypeTable,
                         NULL,
                         NULL);

    if (NT_SUCCESS(Status)) {
        if ((StartDriveLetterFrom.Buffer[0] == L'C') ||
        (StartDriveLetterFrom.Buffer[0] == L'c')) {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: DriveLetter is in setupreg.hiv.\n"));
            if (!DriveAssign_AT) {

                //
                // Delete hive value "DriveLetter".
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Re-assign as NEC assign.\n"));
                Status = RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                                L"\\Registry\\MACHINE\\SYSTEM\\Setup",
                                                L"DriveLetter");
                if (!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Fail to delete KEY DriveLetter.\n"));
                }
            }
        } else {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: There is no DriveLetter.\n"));
            if (DriveAssign_AT) {

                //
                // Add hive value "DriveLetter" as "C".
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Re-assign as AT assign.\n"));
                Status = RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                               L"\\Registry\\Machine\\System\\Setup",
                                               L"DriveLetter",
                                               REG_SZ,
                                               L"C",
                                               sizeof(L"C")+sizeof(WCHAR));
                if (!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Fail to add KEY DriveLetter.\n"));
                }
            }
        }
        ForceUnmap = TRUE;
    }

    //
    // Cancel all drive letters and Remap drive letters.
    //
    if (ForceUnmap) {

    SpPtUnAssignDriveLetters();

    ntDeviceName.Buffer = deviceNameBuffer;
    ntDeviceName.MaximumLength = sizeof(deviceNameBuffer);
    ntDeviceName.Length = 0;

        ansiString.MaximumLength = sizeof(systemRootBuffer);
        ansiString.Length = 0;
        ansiString.Buffer = systemRootBuffer;

    IoAssignDriveLetters( *(PLOADER_PARAMETER_BLOCK *)KeLoaderBlock,
                  &ntDeviceName,
                  ansiString.Buffer,
                  &ansiString );
    }

    RtlFreeUnicodeString(&StartDriveLetterFrom);
    RtlFreeUnicodeString(&Dummy);
}


VOID
SpPtUnAssignDriveLetters(
    VOID
    )
{
    ULONG disk;
    PDISK_REGION pRegion;
    unsigned pass;
    ULONG CdCount, cdrom, dlet;
    UNICODE_STRING linkString;
    WCHAR  tempBuffer[] = L"\\DosDevices\\A:";

    //
    // Release all drive letters of device.
    // If it the region is a partitioned space, then assign a drive letter also.
    //
    for(disk=0; disk<HardDiskCount; disk++) {
        for(pass=0; pass<2; pass++) {
            pRegion = pass ? PartitionedDisks[disk].ExtendedDiskRegions : PartitionedDisks[disk].PrimaryDiskRegions;
            for( ; pRegion; pRegion=pRegion->Next) {
                UCHAR SystemId = SpPtGetPartitionType(pRegion);

                //pRegion->DriveLetter = 0;
                if(pRegion->PartitionedSpace && !IsContainerPartition(SystemId)) {
                    //
                    // Get the nt pathname for this region.
                    //
                    SpNtNameFromRegion(
                        pRegion,
                        TemporaryBuffer,
                        sizeof(TemporaryBuffer),
                        PartitionOrdinalOriginal
                        );
                    //
                    //  Assign a drive letter for this region
                    //
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: delete Partition = %ls (%ls), DriveLetter = %wc: \n", TemporaryBuffer, (pass)? L"Extended" : L"Primary", pRegion->DriveLetter));
                    SpDeleteDriveLetter( TemporaryBuffer );
                    pRegion->DriveLetter = 0;
                }
            }
        }
    }

    if(CdCount = IoGetConfigurationInformation()->CdRomCount) {

        //
        // Unlink CD-ROM drive letters.
        //
        for(cdrom=0; cdrom<CdCount; cdrom++) {
            swprintf(TemporaryBuffer,L"\\Device\\Cdrom%u",cdrom);
            SpDeleteDriveLetter( TemporaryBuffer );
        }
    }

    //
    // Delete all symbolic link related in drive letter.
    //
    for (dlet=0; dlet<26; dlet++) {
        tempBuffer[12] = (WCHAR)(L'A' + dlet);
        RtlInitUnicodeString( &linkString, tempBuffer);
        IoDeleteSymbolicLink (&linkString);
    }

}



#ifndef NEW_PARTITION_ENGINE

VOID
SpPtDeletePartitionsForRemoteBoot(
    PPARTITIONED_DISK pDisk,
    PDISK_REGION startRegion,
    PDISK_REGION endRegion,
    BOOLEAN Extended
    )
{
    PDISK_REGION pRegion;
    PDISK_REGION pNextDeleteRegion;
    BOOLEAN passedEndRegion = FALSE;
    BOOLEAN b;


#ifdef GPT_PARTITION_ENGINE

    if (pDisk->HardDisk->FormatType == DISK_FORMAT_TYPE_GPT) {
        SpPtnDeletePartitionsForRemoteBoot(pDisk,
                startRegion,
                endRegion,
                Extended);

        return;                
    }

#endif    
    
    //
    // Delete all disk regions from startRegion to endRegion.
    //

    pRegion = startRegion;

    while (pRegion) {

        //
        // Before deleting this region, we need to save the next region
        // to delete, since the list may get modified as a result of
        // deleting this one (but a partitioned region won't get
        // changed, only free ones). Note that endRegion might
        // be unpartitioned so we need to be careful to check for
        // the exit case.
        //

        pNextDeleteRegion = pRegion->Next;

        while (pNextDeleteRegion) {
            if (pNextDeleteRegion->PartitionedSpace) {
                break;
            } else {
                if (pNextDeleteRegion == endRegion) {
                    passedEndRegion = TRUE;
                }
                pNextDeleteRegion = pNextDeleteRegion->Next;
            }
        }

        //
        // If this is the extended partition, first kill all the
        // logical drives.
        //

        if (IsContainerPartition(pRegion->MbrInfo->OnDiskMbr.PartitionTable[pRegion->TablePosition].SystemId)) {

            ASSERT(!Extended);

            SpPtDeletePartitionsForRemoteBoot(
                pDisk,
                pDisk->ExtendedDiskRegions,
                NULL,
                TRUE   // used to check for another recursion
                );

        }

        //
        // Remove any boot entries pointing to this region.
        //

        SpPtDeleteBootSetsForRegion(pRegion);

        //
        //  Get rid of the compressed drives, if any
        //

        if( pRegion->NextCompressed != NULL ) {
            SpDisposeCompressedDrives( pRegion->NextCompressed );
            pRegion->NextCompressed = NULL;
            pRegion->MountDrive  = 0;
            pRegion->HostDrive  = 0;
        }

        if (pRegion->PartitionedSpace) {
            b = SpPtDelete(pRegion->DiskNumber,pRegion->StartSector);
        }

        ASSERT(b);

        if ((pRegion == endRegion) ||
            passedEndRegion) {

            break;
        }

        pRegion = pNextDeleteRegion;

    }
}

#endif  // ! NEW_PARTITION_ENGINE


NTSTATUS
SpPtPartitionDiskForRemoteBoot(
    IN ULONG DiskNumber,
    OUT PDISK_REGION *RemainingRegion
    )
{
    PPARTITIONED_DISK pDisk;
    PDISK_REGION pRegion;
    ULONG PartitionCount = 0;
    ULONGLONG firstRegionStartSector;
    PDISK_REGION firstRegion = NULL, lastRegion = NULL;
    BOOLEAN IsGPTDisk = FALSE;

    pDisk = &PartitionedDisks[DiskNumber];

    IsGPTDisk = SPPT_IS_GPT_DISK(DiskNumber);
    
    //
    // Scan through the disk and see how many contiguous recognized
    // partitions there are.
    //

    if (pDisk->HardDisk->Status == DiskOffLine) {
        return STATUS_DEVICE_OFF_LINE;
    }

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
        "SpPtPartitionDiskForRemoteBoot: cylinder size is %lx\n", 
        pDisk->HardDisk->SectorsPerCylinder));

    pRegion = pDisk->PrimaryDiskRegions;

    for( ; pRegion; pRegion=pRegion->Next) {

        if (!pRegion->PartitionedSpace) {
            //
            // If the region is not partitioned, then add it to our list
            // to merge if we have one.
            //
            if (firstRegion) {
                //
                // If this is a final free region covering the last
                // partial cylinder on the disk, then don't add it.
                //
                if ((pRegion->Next == NULL) &&
                    (pRegion->SectorCount < pDisk->HardDisk->SectorsPerCylinder) &&
                    ((pRegion->StartSector % pDisk->HardDisk->SectorsPerCylinder) == 0)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                        "Skipping final partial cylinder free region %lx for %lx\n",
                        pRegion->StartSector, pRegion->SectorCount));
                } else {
                    lastRegion = pRegion;
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                        "Adding free region %lx for %lx\n",
                        pRegion->StartSector, pRegion->SectorCount));
                }
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                    "Skipping free region %lx for %lx\n",
                    pRegion->StartSector, pRegion->SectorCount));
            }
        } else {
            PON_DISK_PTE    pte;
            UCHAR           SystemId = 0;

            if (IsGPTDisk) {
                if (SPPT_IS_RECOGNIZED_FILESYSTEM(pRegion->Filesystem)) {
                    //
                    // TBD : Fix for cases where FT / Dynamic volumes can
                    // reside on the GPT disk
                    //
                    SystemId = PARTITION_FAT32;
                } else {
                    SystemId = PARTITION_ENTRY_UNUSED;
                }                    
            } else {                                
                SystemId = SpPtGetPartitionType(pRegion);
            }

            if (IsContainerPartition(SystemId)) {
                //
                // If this is the extended partition, we want to remove it.
                //

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                    "Adding extended region [type %d] %lx for %lx\n",
                    SystemId, pRegion->StartSector, pRegion->SectorCount));
                    
                if (!firstRegion) {
                    firstRegion = pRegion;
                }
                
                lastRegion = pRegion;
            } else if ((PartitionNameIds[SystemId] == (UCHAR)(-1)) ||
                       (PartitionNameIds[SystemId] == PT(VERIT))) {
                //
                // For a recognized partition, remove it if we have already found
                // a firstRegion; otherwise we will start our list with this
                // region.
                //

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                    "Adding recognized region [type %d] %lx for %lx\n",
                    SystemId, pRegion->StartSector, pRegion->SectorCount));
                    
                if (!firstRegion) {
                    firstRegion = pRegion;
                }
                
                lastRegion = pRegion;
            } else {
                //
                // If the partition is *not* recognized, and we have a list we
                // have been keeping, then stop before this one, otherwise
                // skip it.
                //

                if (firstRegion) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                        "Stopping at unrecognized region [type %d] %lx for %lx\n",
                        SystemId, pRegion->StartSector, pRegion->SectorCount));
                        
                    break;
                } else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                        "Skipping unrecognized region [type %d] %lx for %lx\n",
                        SystemId, pRegion->StartSector, pRegion->SectorCount));
                }
            }
        }
    }

    //
    // We should have found at least one region. If we didn't then the
    // disk is alternating unpartitioned and unrecognized regions. In this
    // case, use the largest unpartitioned region.
    //

    if (firstRegion == NULL) {

        ULONGLONG BiggestUnpartitionedSectorCount = 0;

        pRegion = pDisk->PrimaryDiskRegions;
        
        for( ; pRegion; pRegion=pRegion->Next) {
            if (!pRegion->PartitionedSpace) {
                if (pRegion->SectorCount > BiggestUnpartitionedSectorCount) {
                    firstRegion = pRegion;
                    BiggestUnpartitionedSectorCount = pRegion->SectorCount;
                }
            }
        }
        
        if (firstRegion == NULL) {
            return STATUS_DEVICE_OFF_LINE;
        }
        
        lastRegion = firstRegion;

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
            "Adding single free region %lx for %lx\n",
            firstRegion->StartSector, firstRegion->SectorCount));
    }

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
        "first is %lx, last is %lx\n", firstRegion, lastRegion));

    //
    // If we found exactly one region and it has a known filesystem on
    // it, then we don't need to do any repartitioning. We still delete
    // if the filesystem is unknown because later in setup there are
    // some checks that the Filesystem is valid for this region, so by
    // deleting it here we will ensure that Filesystem becomes
    // NewlyCreated which is considered acceptable.
    //
    // We also don't need to repartition if we have just one region
    // and it is already unpartitioned.
    //

    if (firstRegion == lastRegion) {

        SpPtDeleteBootSetsForRegion(firstRegion);

        if (!firstRegion->PartitionedSpace) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                "One region, unpartitioned, not repartitioning\n"));
                
            *RemainingRegion = firstRegion;
            
            return STATUS_SUCCESS;
            
        } else if ((firstRegion->Filesystem == FilesystemNtfs) ||
                   (firstRegion->Filesystem == FilesystemFat) ||
                   (firstRegion->Filesystem == FilesystemFat32)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                "One region, filesystem %d, not repartitioning\n", 
                firstRegion->Filesystem));
                
            *RemainingRegion = firstRegion;
            
            return STATUS_SUCCESS;
        }
    }

    //
    // We need to remove all the regions between firstRegion and
    // lastRegion. Save the start sector of firstRegion for later,
    // since after this call firstRegion may be invalid.
    //

    firstRegionStartSector = firstRegion->StartSector;

    SpPtDeletePartitionsForRemoteBoot(
        pDisk,
        firstRegion,
        lastRegion,
        FALSE       // these are not extended regions
        );

    //
    // Now we need to find the region occupying the space we have
    // freed. We scan for the region that includes firstRegionStartSector
    // (the region we find may start before then if there was a small free
    // region before it).
    //

    for (pRegion = pDisk->PrimaryDiskRegions;
         pRegion;
         pRegion=pRegion->Next) {

        if (pRegion->StartSector <= firstRegionStartSector) {
            firstRegion = pRegion;
        } else {
            break;
        }
    }

    //
    // Return this -- SpPtPrepareDisks handles the case where the
    // selected region is free.
    //

    *RemainingRegion = firstRegion;

    return STATUS_SUCCESS;
}


//
// Hard Disk Inialize data for NEC98
//
#define IPL_SIZE 0x8000 //NEC98


NTSTATUS
SpInitializeHardDisk_Nec98(
    IN PDISK_REGION     pRegionDisk
)

{
    PHARD_DISK      pHardDisk;
    WCHAR DevicePath[(sizeof(DISK_DEVICE_NAME_BASE)+sizeof(L"000"))/sizeof(WCHAR)];
    ULONG i,bps;
    HANDLE Handle;
    NTSTATUS Sts;
    PUCHAR Buffer,UBuffer;
    ULONG       buffersize;
    ULONG       sectoraddress;
    PUCHAR      HdutlBuffer;
    IO_STATUS_BLOCK IoStatusBlock;

    pHardDisk = &HardDisks[pRegionDisk->DiskNumber];
    bps = HardDisks[pRegionDisk->DiskNumber].Geometry.BytesPerSector;
    Sts = SpOpenPartition0(pHardDisk->DevicePath,&Handle,TRUE);
    if(!NT_SUCCESS(Sts)) {
        return(Sts);
    }

    //
    // Initialize Hard Disk
    //

    if(bps==256){
        bps=512;
    }

    HdutlBuffer = SpMemAlloc(IPL_SIZE);
    if(!HdutlBuffer) {
        SpMemFree(HdutlBuffer);
        ZwClose(Handle);
        return(STATUS_NO_MEMORY);
    }
    RtlZeroMemory(HdutlBuffer,IPL_SIZE);

    //
    // Clear head of hard drive, instead of Physical Format.
    //
    Sts = SpReadWriteDiskSectors(Handle,0,(ULONG)(IPL_SIZE/bps),bps,HdutlBuffer,TRUE);
    if(!NT_SUCCESS(Sts)) {
        SpMemFree(HdutlBuffer);
        ZwClose(Handle);
        return(Sts);
    }

    //
    // Set IPL Information
    //

    //
    // Write Boot Code
    //
    sectoraddress=0;
    switch(bps){
        case    2048:   buffersize=0x800; break;
        case    1024:   buffersize=0x400; break;
        case     256:   buffersize=0x100; break;
        case     512:   buffersize=0x200; break;
        default     :   buffersize=0x800; //***max***
                        bps=0x800;
    }
    Sts = SpReadWriteDiskSectors(Handle,sectoraddress,(ULONG)(buffersize/bps),bps,x86PC98BootCode,TRUE);
    if(!NT_SUCCESS(Sts)) {
        SpMemFree(HdutlBuffer);
        ZwClose(Handle);
        return(Sts);
    }

    //
    // Write Volume Info
    //
    sectoraddress=1;
    switch(bps){
        case    2048:    buffersize=0x800; break;        //***1sec***
        case    1024:    buffersize=0xc00; break;        //***3sec***
        case     256:    buffersize=0x300; break;        //***3sec***
        case     512:    buffersize=0x200; break;        //***1sec***
        default     :    buffersize=0x800;               //***max****
    }
    Sts = SpReadWriteDiskSectors(Handle,sectoraddress,(ULONG)(buffersize/bps),bps,HdutlBuffer,TRUE);
    if(!NT_SUCCESS(Sts)) {
        SpMemFree(HdutlBuffer);
        ZwClose(Handle);
        return(Sts);
    }

    //
    // Write Boot Menu
    //
    switch(bps){
        case    2048:    buffersize=0x2000;    //***8KB***
                         sectoraddress=2;
                         break;
        case    1024:    buffersize=0x2000;    //***8KB***
                         sectoraddress=4;
                         break;
        case     256:    buffersize=0x1c00;    //***7KB***
                         sectoraddress=4;
                         break;
        case     512:    buffersize=0x1c00;    //***7KB***
                         sectoraddress=2;
                         break;
        default     :    buffersize=0x1c00;    //***min***
    }
    Sts = SpReadWriteDiskSectors(Handle,sectoraddress,(ULONG)(buffersize/bps),bps,x86PC98BootMenu,TRUE);
    if(!NT_SUCCESS(Sts)) {
        SpMemFree(HdutlBuffer);
        return(Sts);
    }

    //
    // Write NTFT Signature.
    //
    RtlZeroMemory(HdutlBuffer,bps);
    ((PULONG)HdutlBuffer)[0] = SpComputeSerialNumber();
    ((PUSHORT)HdutlBuffer)[bps/2 - 1] = BOOT_RECORD_SIGNATURE;

    Sts = SpReadWriteDiskSectors(Handle,16,1,bps,HdutlBuffer,TRUE);
    if(!NT_SUCCESS(Sts)) {
        SpMemFree(HdutlBuffer);
        ZwClose(Handle);
        return(Sts);
    }
    SpMemFree(HdutlBuffer);
    ZwClose(Handle);

    //
    //  Do ShutDown
    //

    SpDisplayScreen(SP_SCRN_INIT_REQUIRES_REBOOT_NEC98,3,4);
    SpDisplayStatusOptions(
        DEFAULT_STATUS_ATTRIBUTE,
        SP_STAT_F3_EQUALS_REBOOT,
        0
        );

    SpInputDrain();
    while(SpInputGetKeypress() != KEY_F3) ;
    HalReturnToFirmware(HalRebootRoutine);

    return(STATUS_SUCCESS);

}


VOID
SpReassignOnDiskOrdinals(
    IN PPARTITIONED_DISK pDisk
    )
{
#if defined(NEC_98) //NEC98
    PMBR_INFO pBrInfo;
    ULONG i;

    for(pBrInfo=&pDisk->MbrInfo; pBrInfo; pBrInfo=pBrInfo->Next) {

        for(i=0; i<PTABLE_DIMENSION; i++) {

            PON_DISK_PTE pte = &pBrInfo->OnDiskMbr.PartitionTable[i];

            if((pte->SystemId != PARTITION_ENTRY_UNUSED)
            && !IsContainerPartition(pte->SystemId)) {

                //
                // Reset real disk potition into OnDiskordinals.
                // RealDiskPosition value is zero origin, but partition
                // number start one.
                //
                pBrInfo->OnDiskOrdinals[i] = pte->RealDiskPosition + 1;

            } else {

                pBrInfo->OnDiskOrdinals[i] = 0;

            }
        }
    }
#endif //NEC98
}


//
// Now, only for NEC98.
//
VOID
SpTranslatePteInfo(
    IN PON_DISK_PTE   pPte,
    IN PREAL_DISK_PTE pRealPte,
    IN BOOLEAN        Write // into real PTE
    )
{
    ASSERT(pRealPte);
    ASSERT(pPte);

    if( Write ) {
        //
        // Initialize PTE
        //
        RtlZeroMemory(pRealPte, sizeof(REAL_DISK_PTE));

        //
        // Copy PTE entries from real on-disk PTE.
        //
        pRealPte->ActiveFlag    = pPte->ActiveFlag;
        pRealPte->StartHead     = pPte->StartHead;
        pRealPte->StartSector   = pPte->StartSector;
        pRealPte->StartCylinder = pPte->StartCylinder;
        pRealPte->SystemId      = pPte->SystemId;
        pRealPte->EndHead       = pPte->EndHead;
        pRealPte->EndSector     = pPte->EndSector;
        pRealPte->EndCylinder   = pPte->EndCylinder;

        RtlMoveMemory(&pRealPte->RelativeSectors, &pPte->RelativeSectors,
                      sizeof(pPte->RelativeSectors)); //4

        RtlMoveMemory(&pRealPte->SectorCount, &pPte->SectorCount,
                      sizeof(pPte->SectorCount)); //4

    } else {
        //
        // Initialize PTE
        //
        RtlZeroMemory(pPte, sizeof(ON_DISK_PTE));

        //
        // Copy PTE entries from real on-disk PTE.
        //
        pPte->ActiveFlag    = pRealPte->ActiveFlag;
        pPte->StartHead     = pRealPte->StartHead;
        pPte->StartSector   = pRealPte->StartSector;
        pPte->StartCylinder = pRealPte->StartCylinder;
        pPte->SystemId      = pRealPte->SystemId;
        pPte->EndHead       = pRealPte->EndHead;
        pPte->EndSector     = pRealPte->EndSector;
        pPte->EndCylinder   = pRealPte->EndCylinder;

        RtlMoveMemory(&pPte->RelativeSectors, &pRealPte->RelativeSectors,
                      sizeof(pRealPte->RelativeSectors)); //4

        RtlMoveMemory(&pPte->SectorCount, &pRealPte->SectorCount,
                      sizeof(pPte->SectorCount)); //4
    }
}


//
// Now, only for NEC98.
//
VOID
SpTranslateMbrInfo(
    IN PON_DISK_MBR   pMbr,
    IN PREAL_DISK_MBR pRealMbr,
    IN ULONG          bps,
    IN BOOLEAN        Write // into real MBR
    )
{
    PREAL_DISK_PTE      pRealPte;
    PON_DISK_PTE        pPte;
    ULONG               TmpData;
    ULONG               i;


    pRealPte    = pRealMbr->PartitionTable;
    pPte        = pMbr->PartitionTable;

    ASSERT(pRealMbr);
    ASSERT(pMbr);

    if( Write ) {
        //
        // Initialize REAL_DISK_MBR
        //
        RtlZeroMemory(pRealMbr, sizeof(REAL_DISK_MBR));

        //
        // Copy MBR entries into real on-disk MBR.
        //
        RtlMoveMemory(&pRealMbr->BootCode, &pMbr->BootCode,
                      sizeof(pMbr->BootCode)); //440
        RtlMoveMemory(&pRealMbr->NTFTSignature, &pMbr->NTFTSignature,
                      sizeof(pMbr->NTFTSignature)); //4
        RtlMoveMemory(&pRealMbr->Filler, &pMbr->Filler,
                      sizeof(pMbr->Filler)); //2
        RtlMoveMemory(&pRealMbr->AA55Signature, &pMbr->AA55Signature,
                      sizeof(pMbr->AA55Signature)); //2

    } else {
        //
        // Initialize ON_DISK_MBR
        //
        RtlZeroMemory(pMbr, sizeof(ON_DISK_MBR));

        //
        // Copy MBR entries from real on-disk MBR.
        //
        RtlMoveMemory(&pMbr->BootCode, &pRealMbr->BootCode,
                      sizeof(pMbr->BootCode)); //440
        RtlMoveMemory(&pMbr->NTFTSignature, &pRealMbr->NTFTSignature,
                      sizeof(pMbr->NTFTSignature)); //4
        RtlMoveMemory(&pMbr->Filler, &pRealMbr->Filler,
                      sizeof(pMbr->Filler)); //2
        RtlMoveMemory(&pMbr->AA55Signature, &pRealMbr->AA55Signature,
                      sizeof(pMbr->AA55Signature)); //2
    }

    //
    // Translate PTEs from real on-disk PTEs.
    //
    for(i=0; i<NUM_PARTITION_TABLE_ENTRIES; i++) {
        SpTranslatePteInfo(&pPte[i], &pRealPte[i], Write);
    }
}


VOID
ConvertPartitionTable(
    IN PPARTITIONED_DISK pDisk,
    IN PUCHAR            Buffer,
    IN ULONG             bps
    )
{
#if defined(NEC_98) //NEC98
    PREAL_DISK_PTE_NEC98  PteNec;
    PON_DISK_PTE      p;
    ULONG             TmpData;
    ULONG             i;

    PteNec = (PREAL_DISK_PTE_NEC98)(Buffer + bps);
    p      = pDisk->MbrInfo.OnDiskMbr.PartitionTable;

    for(i=0; i<PTABLE_DIMENSION; i++) {

        switch  (PteNec[i].SystemId){

        case 0x00: // not use
            p[i].SystemId = PARTITION_ENTRY_UNUSED;
            break;

        case 0x01: // FAT 12bit
        case 0x81:
            p[i].SystemId = PARTITION_FAT_12;
            break;

        case 0x11: // FAT 16bit
        case 0x91:
            p[i].SystemId = PARTITION_FAT_16;
            break;

        case 0x21: // FAT huge
        case 0xa1:
            p[i].SystemId = PARTITION_HUGE;
            break;

        case 0x31: // IFS
        case 0xb1:
            p[i].SystemId = PARTITION_IFS;
            break;

        case 0x41: // IFS 2nd,orphan
        case 0xc1:
            p[i].SystemId = (PARTITION_IFS | PARTITION_NTFT);
            break;

        case 0x51: // IFS deleted
        case 0xd1:
            p[i].SystemId = (PARTITION_IFS | VALID_NTFT);
            break;

        case 0x61: // FAT32
        case 0xe1:
            p[i].SystemId = PARTITION_FAT32;
            break;

        case 0x08: // FAT 12bit 2nd,orphan
        case 0x88:
            p[i].SystemId = (PARTITION_FAT_12 | PARTITION_NTFT);
            break;

        case 0x18: // FAT 12bit deleted
        case 0x98:
            p[i].SystemId = (PARTITION_FAT_12 | VALID_NTFT);
            break;

        case 0x28: // FAT 16bit 2nd,orphan
        case 0xa8:
            p[i].SystemId = (PARTITION_FAT_16 | PARTITION_NTFT);
            break;

        case 0x38: // FAT 16bit deleted
        case 0xb8:
            p[i].SystemId = (PARTITION_FAT_16 | VALID_NTFT);
            break;

        case 0x48: // FAT huge 2nd,orphan
        case 0xc8:
            p[i].SystemId = (PARTITION_HUGE | PARTITION_NTFT);
            break;

        case 0x58: // FAT huge deleted
        case 0xd8:
            p[i].SystemId = (PARTITION_HUGE | VALID_NTFT);
            break;

        case 0x68: // LDM partition
        case 0xe8:
            p[i].SystemId = PARTITION_LDM;
            break;

        default: // other
            p[i].SystemId = PARTITION_XENIX_1;
        }

        if(p[i].SystemId == PARTITION_ENTRY_UNUSED) {
            p[i].ActiveFlag         = 0x00;
            p[i].StartHead          = 0x00;
            p[i].StartSector        = 0x00;
            p[i].StartCylinderLow   = 0x00;
            p[i].StartCylinderHigh  = 0x00;
            p[i].EndHead            = 0x00;
            p[i].EndSector          = 0x00;
            p[i].EndCylinderLow     = 0x00;
            p[i].EndCylinderHigh    = 0x00;
            p[i].RelativeSectors[0] = 0x00;
            p[i].RelativeSectors[1] = 0x00;
            p[i].RelativeSectors[2] = 0x00;
            p[i].RelativeSectors[3] = 0x00;
            p[i].SectorCount[0]     = 0x00;
            p[i].SectorCount[1]     = 0x00;
            p[i].SectorCount[2]     = 0x00;
            p[i].SectorCount[3]     = 0x00;
            p[i].IPLSector          = 0x00;
            p[i].IPLHead            = 0x00;
            p[i].IPLCylinderLow     = 0x00;
            p[i].IPLCylinderHigh    = 0x00;
            //p[i].Reserved[2]        = 0x00;
            p[i].Reserved[0]        = 0x00;
            p[i].Reserved[1]        = 0x00;
            p[i].OldSystemId        = 0x00;
            memset(p[i].SystemName,0,16);

        } else {

            p[i].ActiveFlag         = (PteNec[i].ActiveFlag & 0x80);
            p[i].StartHead          = PteNec[i].StartHead;
            p[i].StartSector        = PteNec[i].StartSector;
            p[i].StartCylinderLow   = PteNec[i].StartCylinderLow;
            p[i].StartCylinderHigh  = PteNec[i].StartCylinderHigh;
            p[i].EndHead            = PteNec[i].EndHead;
            p[i].EndSector          = PteNec[i].EndSector;
            p[i].EndCylinderLow     = PteNec[i].EndCylinderLow;
            p[i].EndCylinderHigh    = PteNec[i].EndCylinderHigh;
            p[i].IPLSector          = PteNec[i].IPLSector;
            p[i].IPLHead            = PteNec[i].IPLHead;
            p[i].IPLCylinderLow     = PteNec[i].IPLCylinderLow;
            p[i].IPLCylinderHigh    = PteNec[i].IPLCylinderHigh;
            p[i].Reserved[0]        = PteNec[i].Reserved[0];
            p[i].Reserved[1]        = PteNec[i].Reserved[1];
            p[i].OldSystemId        = PteNec[i].SystemId;

            memcpy(p[i].SystemName , PteNec[i].SystemName , 16);

            TmpData =  (ULONG)PteNec[i].StartCylinderLow;
            TmpData |= ((ULONG)PteNec[i].StartCylinderHigh << 8);
            U_ULONG(p[i].RelativeSectors) = RtlEnlargedUnsignedMultiply(TmpData,
                                                pDisk->HardDisk->SectorsPerCylinder).LowPart;


            TmpData =  (ULONG)(PteNec[i].EndCylinderLow + 1);
            // In case of Low is 0xFF, Overflowed bit will be loss by OR.
            TmpData += ((ULONG)PteNec[i].EndCylinderHigh << 8);
            U_ULONG(p[i].SectorCount) = RtlEnlargedUnsignedMultiply(TmpData,
                                            pDisk->HardDisk->SectorsPerCylinder).LowPart - U_ULONG(p[i].RelativeSectors);

            //
            // Set Ipl Address
            //
            TmpData =  (ULONG)PteNec[i].IPLCylinderLow;
            TmpData |= ((ULONG)PteNec[i].IPLCylinderHigh << 8);
            TmpData = RtlEnlargedUnsignedMultiply(TmpData,pDisk->HardDisk->SectorsPerCylinder).LowPart;
            TmpData += (ULONG)(PteNec[i].IPLHead * pDisk->HardDisk->Geometry.SectorsPerTrack);
            TmpData += PteNec[i].IPLSector;
            U_ULONG(p[i].IPLSectors) = TmpData;

        }
    }

    U_USHORT(pDisk->MbrInfo.OnDiskMbr.AA55Signature) = ((PUSHORT)Buffer)[bps/2 - 1];
    if(bps == 256){
        U_USHORT(pDisk->MbrInfo.OnDiskMbr.AA55Signature) = 0x0000;
    }
#endif //NEC98
}


#define IPL_SIGNATURE_NEC98 "IPL1"

VOID
SpDetermineFormatTypeNec98(
    IN PPARTITIONED_DISK pDisk,
    IN PREAL_DISK_MBR_NEC98 pRealMbrNec98
    )
{
    UCHAR FormatType;

    if(!IsNEC_98) {
        FormatType = DISK_FORMAT_TYPE_PCAT;

    } else {
        if(pDisk->HardDisk->Characteristics & FILE_REMOVABLE_MEDIA) {
            //
            // All removable media are AT format.
            //
            FormatType = DISK_FORMAT_TYPE_PCAT;

        } else {
            if(U_USHORT(pRealMbrNec98->AA55Signature) == MBR_SIGNATURE) {
                if(!_strnicmp(pRealMbrNec98->IPLSignature,IPL_SIGNATURE_NEC98,
                              sizeof(IPL_SIGNATURE_NEC98)-1)) {
                    //
                    // NEC98-format requires AA55Signature and "IPL1".
                    //
                    FormatType = DISK_FORMAT_TYPE_NEC98;

                } else {
                    FormatType = DISK_FORMAT_TYPE_PCAT;

                }
            } else {
                FormatType = DISK_FORMAT_TYPE_UNKNOWN;

            }
        }
    }

    pDisk->HardDisk->FormatType = FormatType;
#if 0
    pDisk->HardDisk->MaxPartitionTables = ((FormatType == DISK_FORMAT_TYPE_PCAT) ?
        NUM_PARTITION_TABLE_ENTRIES : NUM_PARTITION_TABLE_ENTRIES_NEC98);
#endif //0

    return;
}



NTSTATUS
SpPtSearchLocalSourcesInDynamicDisk(
    IN ULONG    disk
    )
{
    NTSTATUS          Status;
    UNICODE_STRING    UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE            DirectoryHandle;
    BOOLEAN           RestartScan;
    ULONG             Context;
    BOOLEAN           MoreEntries;
    POBJECT_DIRECTORY_INFORMATION DirInfo;


    //
    // Open the \ArcName directory.
    //
    INIT_OBJA(&Obja,&UnicodeString,HardDisks[disk].DevicePath);

    Status = ZwOpenDirectoryObject(&DirectoryHandle,DIRECTORY_ALL_ACCESS,&Obja);

    if(NT_SUCCESS(Status)) {

        RestartScan = TRUE;
        Context = 0;
        MoreEntries = TRUE;

        do {

            Status = SpQueryDirectoryObject(
                        DirectoryHandle,
                        RestartScan,
                        &Context
                        );

            if(NT_SUCCESS(Status)) {
                PWSTR   DirectoryName;

                DirInfo = (POBJECT_DIRECTORY_INFORMATION)
                            ((PSERVICE_QUERY_DIRECTORY_OBJECT)&CommunicationParams->Buffer)->Buffer;

                wcsncpy(TemporaryBuffer,DirInfo->Name.Buffer,DirInfo->Name.Length / sizeof(WCHAR));
                (TemporaryBuffer)[DirInfo->Name.Length/sizeof(WCHAR)] = 0;
                DirectoryName = SpDupStringW(TemporaryBuffer);
                SpStringToLower(TemporaryBuffer);
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Checking directory object %ws\\%ws \n", HardDisks[disk].DevicePath, DirectoryName));
                if( _wcsicmp(TemporaryBuffer,L"partition0") &&
                    wcsstr(TemporaryBuffer,L"partition") ) {

                    FilesystemType  FsType;
                    WCHAR           FsName[32];
                    ULONG           NameId;
                    ULONG           PartitionNumber;

                    PartitionNumber = SpStringToLong( DirectoryName + ((sizeof(L"partition") - sizeof(WCHAR)) / sizeof(WCHAR)),
                                                      NULL,
                                                      10 );
                    FsType = SpIdentifyFileSystem( HardDisks[disk].DevicePath,
                                                   HardDisks[disk].Geometry.BytesPerSector,
                                                   PartitionNumber );
                    NameId = SP_TEXT_FS_NAME_BASE + FsType;
                    SpFormatMessage( FsName,
                                     sizeof(FsName),
                                     NameId );

                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: File system in dynamic volume %ws\\%ws is %ws. \n", HardDisks[disk].DevicePath, DirectoryName, FsName));
                    if( FsType >= FilesystemFirstKnown ) {
                        PWSTR LocalSourceFiles[1] = { LocalSourceDirectory };

                        wcscpy( TemporaryBuffer,HardDisks[disk].DevicePath );
                        SpConcatenatePaths( TemporaryBuffer,DirectoryName );

                        if(SpNFilesExist(TemporaryBuffer,LocalSourceFiles,ELEMENT_COUNT(LocalSourceFiles),TRUE)) {
                            //
                            //  Found local source directory
                            //
                            PDISK_REGION pRegion;

                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Found %ws in dynamic volume %ws\\%ws. \n", LocalSourceDirectory, HardDisks[disk].DevicePath, DirectoryName));
                            pRegion = SpPtAllocateDiskRegionStructure( disk,
                                                                       0,
                                                                       0,
                                                                       TRUE,
                                                                       NULL,
                                                                       PartitionNumber );
                            pRegion->DynamicVolume = TRUE;
                            pRegion->DynamicVolumeSuitableForOS = FALSE;
                            pRegion->IsLocalSource = TRUE;
                            pRegion->Filesystem = FsType;
                            LocalSourceRegion = pRegion;
                            MoreEntries = FALSE;
                        }
                    }
                }
                SpMemFree( DirectoryName );
            } else {

                MoreEntries = FALSE;
                if(Status == STATUS_NO_MORE_ENTRIES) {
                    Status = STATUS_SUCCESS;
                }
            }

            RestartScan = FALSE;

        } while(MoreEntries);

        ZwClose(DirectoryHandle);

    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ws directory. Status = %lx\n", HardDisks[disk].DevicePath, Status));
    }
    return( Status );
}


VOID
SpPtFindLocalSourceRegionOnDynamicVolumes(
    VOID
    )
{
    ULONG             disk;
    PPARTITIONED_DISK partdisk;
    PDISK_REGION      pRegion;
    BOOLEAN           DiskIsDynamic;
    ULONG             pass;

    ASSERT(HardDisksDetermined);


    //
    // For each hard disk attached to the system, read its partition table.
    //
    for(disk=0; disk<HardDiskCount && !LocalSourceRegion; disk++) {
        partdisk = &PartitionedDisks[disk];
        DiskIsDynamic = FALSE;
        for( pass=0;
             (pass < 2) &&  !DiskIsDynamic;
             pass++ ) {
            for( pRegion = ((pass == 0)? partdisk->PrimaryDiskRegions : partdisk->ExtendedDiskRegions);
                 pRegion && !DiskIsDynamic;
                 pRegion = pRegion->Next ) {
                if( pRegion->DynamicVolume ) {
                    //
                    //  This is a dynamic disk.
                    //
                    DiskIsDynamic = TRUE;
                    //
                    // Scan all dynamic volumes in the disk for the $win_nt$.~ls
                    //
                    SpPtSearchLocalSourcesInDynamicDisk( disk );
                }
            }
        }
    }
}



NTSTATUS
SpPtCheckDynamicVolumeForOSInstallation(
    IN PDISK_REGION Region
    )
{
    NTSTATUS Status;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    PARTITION_INFORMATION PartitionInfo;
    ULONG bps;
    ULONG r;
    ULONG StartSector;
    ULONG SectorCount;
    ULONG RelativeSectors;

    ASSERT(Region->DynamicVolume);

    Status = SpOpenPartition( HardDisks[Region->DiskNumber].DevicePath,
                              SpPtGetOrdinal(Region,PartitionOrdinalOnDisk),
                              &Handle,
                              FALSE );

#if DBG
    SpNtNameFromRegion( Region,
                        TemporaryBuffer,
                        sizeof(TemporaryBuffer),
                        PartitionOrdinalOnDisk);
#endif

    if( !NT_SUCCESS(Status) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open dynamic volume %ws. Status = %lx\n",TemporaryBuffer, Status));
        return(Status);
    }
    
    Status = ZwDeviceIoControlFile(
                Handle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_DISK_GET_PARTITION_INFO,
                NULL,
                0,
                &PartitionInfo,
                sizeof(PartitionInfo)
                );

    if(NT_SUCCESS(Status)) {
        bps = HardDisks[Region->DiskNumber].Geometry.BytesPerSector;
        RelativeSectors = 0;

        if( SpPtLookupRegionByStart(&PartitionedDisks[Region->DiskNumber],
                                    TRUE,
                                    Region->StartSector) == Region ) {
            //
            //  The region is on an extended partition (logical drive)
            //

            PON_DISK_PTE pte;

            //
            // TBD : fix this
            //
            pte = &Region->MbrInfo->OnDiskMbr.PartitionTable[Region->TablePosition];
            RelativeSectors = U_ULONG(pte->RelativeSectors);
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Dynamic volume %ws is logical drive on extended partition. RelativeSectors = %lx \n",TemporaryBuffer, RelativeSectors));
        }

        StartSector = RtlExtendedLargeIntegerDivide(PartitionInfo.StartingOffset,bps,&r).LowPart;
        SectorCount = RtlExtendedLargeIntegerDivide(PartitionInfo.PartitionLength,bps,&r).LowPart;
        Region->DynamicVolumeSuitableForOS = ((Region->StartSector + RelativeSectors) == StartSector) &&
                                             ((Region->SectorCount - RelativeSectors) == SectorCount);

        if( Region->DynamicVolumeSuitableForOS ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Dynamic volume %ws is suitable for OS installation\n",TemporaryBuffer));
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Dynamic volume %ws is not suitable for OS installation\n",TemporaryBuffer));
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:    StartSector = %lx (from MBR)\n", Region->StartSector));
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:    SectorCount = %lx (from MBR)\n", Region->SectorCount));
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:    StartSector = %lx (from IOCTL_DISK_GET_PARTITION_INFO)\n", StartSector));
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:    SectorCount = %lx (from IOCTL_DISK_GET_PARTITION_INFO)\n", SectorCount));
        }
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to get partition info for dynamic volume %ws. Status = %lx\n",TemporaryBuffer, Status));
    }

    ZwClose(Handle);
    return(Status);
}


UCHAR
SpPtGetPartitionType(
    IN PDISK_REGION Region
    )
{
    UCHAR   SystemId = PARTITION_ENTRY_UNUSED;

    if (!Region->PartitionedSpace)
        return SystemId;

#ifdef OLD_PARTITION_ENGINE
    SystemId = Region->MbrInfo->OnDiskMbr.PartitionTable[Region->TablePosition].SystemId;
#endif      

#ifdef NEW_PARTITION_ENGINE
    SystemId = PARTITION_FAT32;

    if (SPPT_IS_MBR_DISK(Region->DiskNumber)) {
        SystemId = SPPT_GET_PARTITION_TYPE(Region);   
    }        
#endif                                

#ifdef GPT_PARTITION_ENGINE
    SystemId = PARTITION_FAT32;
    
    if (SPPT_IS_MBR_DISK(Region->DiskNumber)) {
        SystemId = Region->MbrInfo->OnDiskMbr.PartitionTable[Region->TablePosition].SystemId;
    }
#endif    

    return SystemId;
}    

BOOLEAN
SpPtnIsRegionSpecialMBRPartition(
    IN PDISK_REGION Region
    )
{   
    BOOLEAN Result = FALSE;

    if (Region && SPPT_IS_MBR_DISK(Region->DiskNumber) && 
        SPPT_IS_REGION_PARTITIONED(Region)) {

        UCHAR PartId = PartitionNameIds[SPPT_GET_PARTITION_TYPE(Region)];
        
        Result = (PartId != (UCHAR)0xFF) && 
                 (SPPT_GET_PARTITION_TYPE(Region) != PARTITION_LDM) &&
                 ((PartId + SP_TEXT_PARTITION_NAME_BASE) != 
                    SP_TEXT_PARTITION_NAME_UNK);
    }

    return Result;
}              

PWSTR
SpPtnGetPartitionName(
    IN PDISK_REGION Region,
    IN OUT PWSTR NameBuffer,
    IN ULONG NameBufferSize
    )
/*++

Routine Description:

    Formats the name of the partition, with volume label
    and file system type and returns it.

    Note : Region is assumed to be of partitioned type

Arguments:

    Region - The region whose name is to be formatted

    NameBuffer - Buffer in which the name needs to be formatted

    NameBuffer - The size of the NameBuffer (in characters)

Return Value:

    Formatted partition name for the region, if any.

--*/
{
    BOOLEAN SpecialPartition = FALSE;
    
    if (NameBuffer) {
        if (Region) {
            if (SpPtnIsRegionSpecialMBRPartition(Region)) {
                WCHAR Buffer[128];

                SpFormatMessage(Buffer, sizeof(Buffer),
                    SP_TEXT_PARTITION_NAME_BASE + 
                        PartitionNameIds[SPPT_GET_PARTITION_TYPE(Region)]);
                    
                SpFormatMessage(TemporaryBuffer,
                    sizeof(TemporaryBuffer),
                    SP_TEXT_PARTNAME_DESCR_3,
                    Region->PartitionNumber,
                    Buffer);                    
            } else if (Region->VolumeLabel[0]) {
                SpFormatMessage(TemporaryBuffer,
                    sizeof(TemporaryBuffer),
                    SP_TEXT_PARTNAME_DESCR_1,
                    Region->PartitionNumber,
                    Region->VolumeLabel,
                    Region->TypeName);
            } else {
                SpFormatMessage(TemporaryBuffer,
                    sizeof(TemporaryBuffer),
                    SP_TEXT_PARTNAME_DESCR_2,
                    Region->PartitionNumber,
                    Region->TypeName);
            }

            wcsncpy(NameBuffer, TemporaryBuffer, NameBufferSize - 1);
            NameBuffer[NameBufferSize - 1] = 0; // Null terminate
        } else {
            *NameBuffer = 0;    // Null terminate
        }
    }

    return NameBuffer;            
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spprintf.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    spprintf.h

Abstract:

    safer sprintf variants

Author:

    Jay Krell (a-JayK) November 2000

Revision History:

--*/
#pragma once
#include <stdarg.h>

//
// _snprintf and co. do not write a terminal nul when the string just fits.
// These function do.
//

// use instead of VsNprintf or Vsprintf
// VN V
void         SpFormatStringVaA(PSTR Buffer, SIZE_T Size,  PCSTR Format, va_list Args);

// use instead of sNprintf or sprintf
// N .
void __cdecl SpFormatStringA(PSTR Buffer, SIZE_T Size,  PCSTR Format, ...);

// use instead of VsNWprintf or VsWprintf
// VNW VW
void         SpFormatStringVaW(PWSTR Buffer, SIZE_T Size, PCWSTR Format, va_list Args);

// use instead of sNWprintf or sWprintf
// NW W
void __cdecl SpFormatStringW(PWSTR Buffer, SIZE_T Size, PCWSTR Format, ...);

NTSTATUS __cdecl SpFormatStringWToA(PSTR Buffer, SIZE_T Size, PCWSTR Format, ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spptdump.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    spptdump.h

Abstract:

    Various dump routines for partition, disk and
    file system information

Author:

    Vijay Jayaseelan    (vijayj)

Revision History:

    None

--*/


#ifndef _SPPTDUMP_H_
#define _SPPTDUMP_H_

#define SPPT_GET_PARTITION_STYLE_STR(_Style) \
    (((_Style) == PARTITION_STYLE_MBR) ? (L"MBR") : \
        (((_Style) == PARTITION_STYLE_GPT) ? (L"GPT") : (L"UNKNOWN")))

PWSTR
SpPtGuidToString(
    IN GUID* Guid,
    IN OUT PWSTR Buffer
    );


VOID
SpPtDumpDiskRegion(
    IN PDISK_REGION Region
    );
    
VOID
SpPtDumpDiskRegionInformation(
    IN ULONG    DiskNumber,
    IN BOOLEAN  ExtendedRegionAlso
    );

VOID
SpPtDumpDiskDriveInformation(
    IN BOOLEAN ExtenedRegionAlso
    );

VOID
SpPtDumpPartitionInformation(
    IN PPARTITION_INFORMATION_EX PartInfo
    );

VOID
SpPtDumpDriveLayoutInformation(
    IN PWSTR DevicePath,
    IN PDRIVE_LAYOUT_INFORMATION_EX DriveLayout
    );

VOID
SpPtDumpFSAttributes(
    IN PFILE_FS_ATTRIBUTE_INFORMATION  FsAttrs
    );

VOID
SpPtDumpFSSizeInfo(
    IN PFILE_FS_SIZE_INFORMATION FsSize
    );

VOID
SpPtDumpFSVolumeInfo(
    IN PFILE_FS_VOLUME_INFORMATION FsVolInfo
    );
   
#endif // for _SPPTDUMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spreg.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spvideo.h

Abstract:

    Public header file for spreg.c.

Author:

    Ted Miller (tedm) 8-October-1993

Revision History:

--*/


#ifndef _SPREG_DEFN_
#define _SPREG_DEFN_

#define GUID_STRING_LEN (39)

#define REGSTR_VALUE_DRVINST    TEXT("DrvInst")
#define REGSTR_VALUE_GUID       TEXT("GUID")
#define REGSTR_VALUE_TYPE       TEXT("Type")
#define REGSTR_VALUE_HWIDS      TEXT("HwIDs")
#define REGSTR_VALUE_CIDS       TEXT("CIDs")

NTSTATUS
SpCreateServiceEntry(
    IN PWCHAR ImagePath,
    IN OUT PWCHAR *ServiceKey
    );

NTSTATUS
SpDeleteServiceEntry(
    IN PWCHAR ServiceKey
    );

NTSTATUS
SpLoadDeviceDriver(
    IN PWSTR Description,
    IN PWSTR PathPart1,
    IN PWSTR PathPart2,     OPTIONAL
    IN PWSTR PathPart3      OPTIONAL
    );

#endif // def _SPREG_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spptdump.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    spptdump.c

Abstract:

    Various dump routines for partition, disk and
    file system information

Author:

    Vijay Jayaseelan    (vijayj)


Revision History:

    None

--*/


#include "spprecmp.h"
#pragma hdrstop
#include <initguid.h>
#include <devguid.h>
#include <diskguid.h>


//
// The dump level for dump routines
//
//#define PARTITION_DUMP_LEVEL    DPFLTR_ERROR_LEVEL
#define PARTITION_DUMP_LEVEL    DPFLTR_INFO_LEVEL

ULONG SPPT_DUMP_LEVEL = PARTITION_DUMP_LEVEL;

PWSTR
SpPtGuidToString(
    IN GUID* Guid,
    IN OUT PWSTR Buffer
    )
/*++

Routine Description:

    Converts a given GUID to string representation    
    
Arguments:

    Guid    -   The GUID that needs string representation
    Buffer  -   Place holder for string version of the GUID

Return Value:

    Returns the converted string version of the given GUID

--*/            
{
    if (Guid && Buffer) {
        swprintf(Buffer, L"(%x-%x-%x-%x%x%x%x%x%x%x%x)",
                   Guid->Data1, Guid->Data2,
                   Guid->Data3,
                   Guid->Data4[0], Guid->Data4[1],
                   Guid->Data4[2], Guid->Data4[3],
                   Guid->Data4[4], Guid->Data4[5],
                   Guid->Data4[6], Guid->Data4[7]);
    }        

    if (!Guid && Buffer)
        *Buffer = UNICODE_NULL;

    return Buffer;
}

VOID
SpPtDumpDiskRegion(
    IN PDISK_REGION Region
    )
/*++

Routine Description:

    Dumps the details for the given disk region
    
Arguments:

    Region  -   The region whose information needs to be
                dumped

Return Value:

    None

--*/           
{
    if (Region) {
        KdPrintEx(( DPFLTR_SETUP_ID, SPPT_DUMP_LEVEL, 
            "SETUP: Region:%p,DiskNumber=%d,PartitionNumber=%d,Sector-Start=%I64d,"
            "Sector-Count=%I64d,\nFreeSpace=%I64dKB,AdjustedFreeSpace=%I64dKB,"
            "FileSystem=%d,Partitioned:%d,Dirty:%d,Deleted:%d,EPType=%d,Container=%p,Sys:%d\n,"
            "DynVol=%d,DynVolSuitable=%d\n",
            Region,
            Region->DiskNumber,
            Region->PartitionNumber,
            Region->StartSector,
            Region->SectorCount,
            Region->FreeSpaceKB,
            Region->AdjustedFreeSpaceKB,
            Region->Filesystem,
            Region->PartitionedSpace,
            Region->Dirty,
            Region->Delete,
            Region->ExtendedType,
            Region->Container,
            Region->IsSystemPartition,
            Region->DynamicVolume,
            Region->DynamicVolumeSuitableForOS
            ));            
    }            
}


VOID
SpPtDumpDiskRegionInformation(
    IN ULONG    DiskNumber,
    IN BOOLEAN  ExtendedRegionAlso
    )
/*++

Routine Description:

    Dumps all the regions for the given disk
    
Arguments:

    DiskNumber  :   Disk whose regions need to be dumped
    ExtenededRegionAlso :   Whether the extended region also
                            needs to be dumped.

Return Value:

    None

--*/            
{
    if (DiskNumber < HardDiskCount) {
        PDISK_REGION    Region = PartitionedDisks[DiskNumber].PrimaryDiskRegions;

        KdPrintEx(( DPFLTR_SETUP_ID, SPPT_DUMP_LEVEL, 
            "SETUP: Dumping Primary Regions for DiskNumber=%d\n",
            DiskNumber));

        while (Region) {
            SpPtDumpDiskRegion(Region);
            Region = Region->Next;                                                    
        }

        if (ExtendedRegionAlso) {
            KdPrintEx(( DPFLTR_SETUP_ID, SPPT_DUMP_LEVEL, 
                "SETUP: Dumping Extended Regions for DiskNumber=%d\n",
                DiskNumber));

            Region = PartitionedDisks[DiskNumber].ExtendedDiskRegions;                           
                
            while (Region) {
                SpPtDumpDiskRegion(Region);
                Region = Region->Next;                                                    
            }
        }
    }       
}

VOID
SpPtDumpDiskDriveInformation(
    IN BOOLEAN ExtenedRegionAlso
    )
/*++

Routine Description:

    Dumps the region information for all the disks
    
Arguments:

    ExtendedRegionAlso  :   Indicates whether to dump the
                            regions in the exteneded region
                            or not

Return Value:

    None
    
--*/            
{
    ULONG           DiskNumber;
    PDISK_REGION    pDiskRegion;

    for ( DiskNumber=0; DiskNumber<HardDiskCount; DiskNumber++ ) {
        SpPtDumpDiskRegionInformation(DiskNumber, ExtenedRegionAlso);
    }
}

VOID
SpPtDumpPartitionInformation(
    IN PPARTITION_INFORMATION_EX PartInfo
    )
/*++

Routine Description:

    Dumps all the information in the given PARTITION_INFORMATION_EX
    structure (header all the partition entries)
            
Arguments:

    PartInfo    -   The partition information structure that needs to
                    be dumped

Return Value:

    None

--*/            
{
    if (PartInfo) {        
        PPARTITION_INFORMATION_MBR  MbrInfo;
        PPARTITION_INFORMATION_GPT  GptInfo;
        WCHAR   GuidBuffer1[256];
        WCHAR   GuidBuffer2[256];
        
        KdPrintEx(( DPFLTR_SETUP_ID, SPPT_DUMP_LEVEL, 
            "SETUP: PartitionInformation = Number:%d, Style:%ws,"
            "Start=%I64u, Length = %I64u, Rewrite:%d\n",
            PartInfo->PartitionNumber,
            SPPT_GET_PARTITION_STYLE_STR(PartInfo->PartitionStyle),
            PartInfo->StartingOffset.QuadPart,
            PartInfo->PartitionLength.QuadPart,
            PartInfo->RewritePartition));    

        switch (PartInfo->PartitionStyle) {
            case PARTITION_STYLE_MBR:
                MbrInfo = &(PartInfo->Mbr);
                
                KdPrintEx(( DPFLTR_SETUP_ID, SPPT_DUMP_LEVEL,
                            "Type:%d,Active:%d,Recognized:%d,HiddenSectors:%d\n",
                            MbrInfo->PartitionType,
                            MbrInfo->BootIndicator,
                            MbrInfo->RecognizedPartition,
                            MbrInfo->HiddenSectors));
                            
                break;
        
            case PARTITION_STYLE_GPT:
                GptInfo = &(PartInfo->Gpt);

                KdPrintEx(( DPFLTR_SETUP_ID, SPPT_DUMP_LEVEL,
                            "Type:%ws,Id:%ws,Attributes:%I64X,Name:%ws\n",
                            SpPtGuidToString(&GptInfo->PartitionType, GuidBuffer1),
                            SpPtGuidToString(&GptInfo->PartitionId, GuidBuffer2),
                            GptInfo->Attributes,
                            GptInfo->Name));
                                                            
                break;

            default:
                break;
        }
    }
}

VOID
SpPtDumpDriveLayoutInformation(
    IN PWSTR DevicePath,
    IN PDRIVE_LAYOUT_INFORMATION_EX DriveLayout
    )
/*++

Routine Description:

    Dumps the drive layout information for the given
    device
    
Arguments:

    DevicePath  -  The device whose drive layout is being 
                    dumped

    DriveLayout -   The drive layout structure that needs to
                    be dumped

Return Value:

    None

--*/            
{
    if (DriveLayout) {
        ULONG Index;

        KdPrintEx(( DPFLTR_SETUP_ID, SPPT_DUMP_LEVEL,  
              "\nSETUP: Drive layout for %ws with %d partitions (%ws)\n",
              DevicePath,
              DriveLayout->PartitionCount,
              SPPT_GET_PARTITION_STYLE_STR(DriveLayout->PartitionStyle)
              ));

        if (DriveLayout->PartitionStyle == PARTITION_STYLE_MBR) {
            KdPrintEx(( DPFLTR_SETUP_ID, SPPT_DUMP_LEVEL,  
              "Signature:%X\n", DriveLayout->Mbr.Signature));
        } else {
            WCHAR   GuidBuffer[256];
            PDRIVE_LAYOUT_INFORMATION_GPT Gpt = &(DriveLayout->Gpt);
            
            KdPrintEx(( DPFLTR_SETUP_ID, SPPT_DUMP_LEVEL,  
              "Disk Guid:%ws,Starting Usable Offset:%I64d,Usable Length:%I64d,"
              "MaxPartitionCount:%u\n",
              SpPtGuidToString(&Gpt->DiskId, GuidBuffer),
              Gpt->StartingUsableOffset.QuadPart,
              Gpt->UsableLength.QuadPart,
              Gpt->MaxPartitionCount));
        }

        for (Index=0; Index < DriveLayout->PartitionCount; Index++) {
            SpPtDumpPartitionInformation(&(DriveLayout->PartitionEntry[Index]));
        }

        KdPrintEx(( DPFLTR_SETUP_ID, SPPT_DUMP_LEVEL, "\n"));        
    }
}


VOID
SpPtDumpFSAttributes(
    IN PFILE_FS_ATTRIBUTE_INFORMATION  FsAttrs
    )
/*++

Routine Description:

    Dumps the given file system attribute information
    structure.    
    
Arguments:

    FsAttrs :   The file system attribute information structure
                that needs to be dumped

Return Value:

    None

--*/            
{
    if (FsAttrs) {
        KdPrintEx(( DPFLTR_SETUP_ID, SPPT_DUMP_LEVEL,  
              "SETUP: File System Attributes = Attrs:%lX,MaxCompNameLen=%d,Name:%ws\n",
              FsAttrs->FileSystemAttributes,
              FsAttrs->MaximumComponentNameLength,
              FsAttrs->FileSystemName));
    }
}

VOID
SpPtDumpFSSizeInfo(
    IN PFILE_FS_SIZE_INFORMATION FsSize
    )
/*++

Routine Description:

   Dumps the give file size information structure    
    
Arguments:

    FsSize  :   The file size information structure that needs to
                be dumped

Return Value:

    None

--*/            
{
    if (FsSize) {
        KdPrintEx(( DPFLTR_SETUP_ID, SPPT_DUMP_LEVEL,  
              "SETUP: File System Size Info = TotalUnits:%I64u, AvailUnits:%I64u,"
              "Sectors/Unit:%u,Bytes/Sector:%u\n",
              FsSize->TotalAllocationUnits.QuadPart,
              FsSize->AvailableAllocationUnits.QuadPart,
              FsSize->SectorsPerAllocationUnit,
              FsSize->BytesPerSector
              ));    
    }
}
   

VOID
SpPtDumpFSVolumeInfo(
    IN PFILE_FS_VOLUME_INFORMATION FsVolInfo
    )
/*++

Routine Description:

    Dumps the give volume information structure
        
Arguments:

    FsVolInfo   :   The volume information structure that
                    needs to be dumped

Return Value:

    None

--*/            
{
    if (FsVolInfo) {
        KdPrintEx(( DPFLTR_SETUP_ID, SPPT_DUMP_LEVEL,  
              "SETUP: File System Vol Info = CreationTime:%I64X, Serial#:%d\n",
              "SupportsObject:%d, Name:%ws\n",
              FsVolInfo->VolumeCreationTime.QuadPart,
              FsVolInfo->VolumeSerialNumber,
              FsVolInfo->SupportsObjects,
              FsVolInfo->VolumeLabel
              ));    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\sprtl.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sprtl.h

Abstract:

    support for copy/pasting code from base\ntos\rtl and base\ntdll
    instead of linking to static .libs

Author:

    Jay Krell (JayKrell) May 2002

Revision History:

--*/

#define RtlpEnsureBufferSize SpRtlpEnsureBufferSize
#define RtlMultiAppendUnicodeStringBuffer SpRtlMultiAppendUnicodeStringBuffer
#define RtlInitAnsiStringBuffer SpRtlInitAnsiStringBuffer
#define RtlFreeAnsiStringBuffer SpRtlFreeAnsiStringBuffer
#define RtlAssignAnsiStringBufferFromUnicodeString SpRtlAssignAnsiStringBufferFromUnicodeString
#define RtlAssignAnsiStringBufferFromUnicode SpRtlAssignAnsiStringBufferFromUnicode
#define RtlUnicodeStringBufferEnsureTrailingNtPathSeperator SpRtlUnicodeStringBufferEnsureTrailingNtPathSeperator
#define RtlGetLastNtStatus SpGetLastNtStatus
#define RtlGetLastWin32Error SpGetLastWin32Error
#define RtlSetLastWin32Error SpSetLastWin32Error
#define RtlSetLastWin32ErrorAndNtStatusFromNtStatus SpSetLastWin32ErrorAndNtStatusFromNtStatus
#define dllimport /* nothing */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spreg.c ===
#include "spprecmp.h"
#pragma hdrstop



NTSTATUS
SpDeleteServiceEntry(
    IN PWCHAR ServiceKey
    )
{
    NTSTATUS Status;
    HANDLE KeyHandle;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;

    RtlInitUnicodeString(&UnicodeString,ServiceKey);
    InitializeObjectAttributes(&Obja,&UnicodeString,OBJ_CASE_INSENSITIVE,NULL,NULL);
    Status = ZwOpenKey(&KeyHandle,KEY_WRITE|DELETE,&Obja);

    if(NT_SUCCESS(Status)) {
        Status = ZwDeleteKey(KeyHandle);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: warning: ZwDeleteKey of %ws returned %lx\n",ServiceKey,Status));
        }
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: warning: ZwOpenKey of %ws returned %lx\n",ServiceKey,Status));
    }

    return(Status);
}


NTSTATUS
SpCreateServiceEntry(
    IN  PWCHAR  ImagePath,
    IN OUT PWCHAR *ServiceKey
    )

/*++

Routine Description:

    Create an services entry in the registry suitable for loading
    a given device driver file.

Arguments:

    ImagePath - supplies the fully-qualified pathname of the device driver.

    ServiceKey - If *ServiceKey is not NULL, then it specifies the registry
        path to the service node for this driver. If it is NULL, then it
        receives a pointer to a buffer containing the name of the
        service node created by this routine.  The caller must free this
        buffer via SpMemFree when finished.

Return Value:

    Status code indicating outcome.

--*/

{
    WCHAR KeyName[128];
    WCHAR FilePart[32];
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE KeyHandle;
    ULONG u;
    NTSTATUS Status;
    PWSTR p;
    BYTE DataBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD)];
    ULONG ResultLength;
    
    if (*ServiceKey) {
        wcscpy(KeyName, *ServiceKey);
    } else {
        //
        // Isolate the name of the device driver file from its path.
        //
        if(p = wcsrchr(ImagePath,L'\\')) {
            p++;
        } else {
            p = ImagePath;
        }
        wcsncpy(FilePart,p,(sizeof(FilePart)/sizeof(FilePart[0]))-1);
        FilePart[(sizeof(FilePart)/sizeof(FilePart[0]))-1] = 0;
        if(p=wcsrchr(FilePart,L'.')) {
            *p = 0;
        }

        //
        // Form a unique key name in
        // HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services.
        //

        swprintf(
            KeyName,
            L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\%ws",
            FilePart
            );
    }

    //
    // Attempt to create the key for the service.
    //
    RtlInitUnicodeString(&UnicodeString,KeyName);
    InitializeObjectAttributes(&Obja,&UnicodeString,OBJ_CASE_INSENSITIVE,NULL,NULL);

    Status = ZwCreateKey(
                &KeyHandle,
                KEY_READ | KEY_WRITE,
                &Obja,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCreateServiceEntry: ZwCreateKey %ws returns %lx\n",KeyName,Status));
        return(Status);
    }


    //
    // Set the ImagePath value in the service key.
    //
    RtlInitUnicodeString(&UnicodeString,L"ImagePath");
    Status = ZwSetValueKey(
                KeyHandle,
                &UnicodeString,
                0,
                REG_SZ,
                ImagePath,
                (wcslen(ImagePath) + 1) * sizeof(WCHAR)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set ImagePath value in key %ws (%lx)\n",KeyName,Status));
        goto cs1;
    }

    //
    // Set the Type value in the service key. If the type is preset in the registry to SERVICE_FILE_SYSTEM_DRIVER
    // leave it alone.  Otherwise set it to SERVICE_KERNEL_DRIVER.
    //
    RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_TYPE);
 
    ResultLength = 0;
    Status = ZwQueryValueKey(KeyHandle,
                             &UnicodeString,
                             KeyValuePartialInformation,
                             (PKEY_VALUE_PARTIAL_INFORMATION)DataBuffer,
                             sizeof(DataBuffer),
                             &ResultLength);

    if( NT_SUCCESS(Status) && 
        ResultLength &&
        ( (INT) ( (PKEY_VALUE_PARTIAL_INFORMATION) DataBuffer)->Type == REG_DWORD ) &&
        ( (INT) *(( (PKEY_VALUE_PARTIAL_INFORMATION) DataBuffer)->Data) == SERVICE_FILE_SYSTEM_DRIVER ) ) {
    
        u = SERVICE_FILE_SYSTEM_DRIVER;
    }
    else { 
        //
        // If the type is not preset in the registry to SERVICE_FILE_SYSTEM_DRIVER set it to SERVICE_KERNEL_DRIVER by default.
        //
        u = SERVICE_KERNEL_DRIVER;
    }
    
    Status = ZwSetValueKey(
                KeyHandle,
                &UnicodeString,
                0,
                REG_DWORD,
                &u,
                sizeof(ULONG)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set Type value in key %ws (%lx)\n",KeyName,Status));
        goto cs1;
    }

    //
    // Set the Start value in the service key.
    //
    u = SERVICE_DEMAND_START;
    RtlInitUnicodeString(&UnicodeString,L"Start");
    Status = ZwSetValueKey(
                KeyHandle,
                &UnicodeString,
                0,
                REG_DWORD,
                &u,
                sizeof(ULONG)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set Start value in key %ws (%lx)\n",KeyName,Status));
        goto cs1;
    }


  cs1:

    //
    // If we were not entirely successful creating the service,
    // we'll want to clean it out here.  Otherwise duplicate the KeyName
    // string to return to the caller, if it was not passed in.
    //
    if(NT_SUCCESS(Status)) {

        if (*ServiceKey == NULL) {
            if((*ServiceKey = SpDupStringW(KeyName)) == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    if(!NT_SUCCESS(Status)) {

        NTSTATUS s;

        //
        // Remove the key we just created.
        //
        s = ZwDeleteKey(KeyHandle);
        if(!NT_SUCCESS(s)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: warning: ZwDeleteKey of %ws returned %lx\n",KeyName,s));
        }
    }

    NtClose(KeyHandle);

    return(Status);
}




NTSTATUS
SpLoadDeviceDriver(
    IN PWSTR Description,
    IN PWSTR PathPart1,
    IN PWSTR PathPart2,     OPTIONAL
    IN PWSTR PathPart3      OPTIONAL
    )

/*++

Routine Description:

    Load a device driver by creating a services entry for the driver and
    then calling the I/O subsystem.

Arguments:

    Description - supplies a human-readable description of the driver
        or hardware that the driver targets.

    PathPart1 - supplies first part of full pathname to driver file.

    PathPart2 - if specified, supplies the second part of the full pathname;
        PathPart2 will be concatenated to PathPart1. If not specified,
        then PathPart1 is the full path.

    PathPart3 - if specified, supplies a third part of the full pathname;
        PathPart3 will be concatenated to PathPart1 and PathPart2.

Return Value:

    Status code indicating outcome.

--*/

{
    PWCHAR FullName;
    NTSTATUS Status;
    PWCHAR ServiceKey;
    UNICODE_STRING ServiceKeyU;
    PWSTR pwstr;

    SpDisplayStatusText(
        SP_STAT_LOADING_DRIVER,
        DEFAULT_STATUS_ATTRIBUTE,
        Description
        );

    pwstr = TemporaryBuffer;

    //
    // Form the full name of the device driver file.
    //
    wcscpy(pwstr,PathPart1);
    if(PathPart2) {
        SpConcatenatePaths(pwstr,PathPart2);
    }
    if(PathPart3) {
        SpConcatenatePaths(pwstr,PathPart3);
    }

    FullName = SpDupStringW(pwstr);

    //
    // Create a service entry for the driver.
    //
    ServiceKey = NULL;
    Status = SpCreateServiceEntry(FullName,&ServiceKey);
    if(NT_SUCCESS(Status)) {

        RtlInitUnicodeString(&ServiceKeyU,ServiceKey);

        //
        // Attempt to load the driver.
        //
        Status = ZwLoadDriver(&ServiceKeyU);
        if(!NT_SUCCESS(Status)) {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ZwLoadDriver %ws returned %lx\n",FullName,Status));

            //
            // Remove the service entry we created in the registry.
            //
            SpDeleteServiceEntry(ServiceKey);
        }

        SpMemFree(ServiceKey);
    }

    SpMemFree(FullName);

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spptwrt.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    spptwrt.c

Abstract:

    Creates, Deletes and Commits the partitions 
    to the disk.

Author:

    Vijay Jayaseelan    (vijayj)

Revision History:

    None

--*/


#include "spprecmp.h"
#pragma hdrstop
#include "sppart3.h"
#include <oemtypes.h>

//
// If we are testing commit then we don't commit on
// disk zero (i.e. primary disk) where we have our
// NT and recovery console installation
//
//#define TESTING_COMMIT          1

#if 0
//
// To test GPT partitions using existing loader
//
//#define STAMP_MBR_ON_GPT_DISK   1
#endif

//
// Variable to selectively trun on/off commits to
// the disk
//
BOOLEAN DoActualCommit = TRUE;


ULONG
SpPtnGetContainerPartitionCount(
    IN ULONG DiskId
    )
/*++

Routine Description:

    Counts the number of container partitions in the region 
    list for the given disk
    
Arguments:

    DiskId  :   Disk ID

Return Value:

    Count of the container partitions for the disk

--*/        
{
    ULONG Count = 0;

    if (SPPT_IS_MBR_DISK(DiskId)) {
        PDISK_REGION Region = SPPT_GET_PRIMARY_DISK_REGION(DiskId);

        while (Region) {
            if (SPPT_IS_REGION_CONTAINER_PARTITION(Region))
                Count++;

            Region = Region->Next;            
        }
    }        

    return Count;
}

ULONG
SpPtnGetLogicalDriveCount(
    IN ULONG DiskId
    )
/*++

Routine Description:

    Counts the number of logical drives in the regions list
    for the given disk
    
Arguments:

    DiskId  :   Disk ID

Return Value:

    Count of the logical drives for the disk

--*/        
{
    ULONG Count = 0;

    if (SPPT_IS_MBR_DISK(DiskId)) {
        PDISK_REGION Region = SPPT_GET_PRIMARY_DISK_REGION(DiskId);

        while (Region) {
            if (SPPT_IS_REGION_LOGICAL_DRIVE(Region))
                Count++;

            Region = Region->Next;            
        }
    }        

    return Count;
}        

ULONG
SpPtnGetPartitionCountDisk(
    IN ULONG DiskId
    )
/*++

Routine Description:

    Counts the number of partitions for the given
    disk.
    
Arguments:

    DiskId  : Disk ID

Return Value:

    Count of number of partitions for the disk   

--*/        
{
    ULONG PartCount = 0;
    
    if (DiskId < HardDiskCount) {
        PDISK_REGION Region = SPPT_GET_PRIMARY_DISK_REGION(DiskId);

        while (Region) {
            if (SPPT_IS_REGION_PARTITIONED(Region))
                PartCount++;
                
            Region = Region->Next;
        }

        Region = SPPT_GET_EXTENDED_DISK_REGION(DiskId);

        while (Region) {
            if (SPPT_IS_REGION_PARTITIONED(Region))
                PartCount++;
                
            Region = Region->Next;
        }
    }

    return PartCount;
}

ULONG
SpPtnGetDirtyPartitionCountDisk(
    IN ULONG DiskId
    )
/*++

Routine Description:

    Counts the number of dirty partitions for the given
    disk.

    NB: A partition is dirty if it needs to be commit
    to the disk with some new information
    
Arguments:

    DiskId  :   Disk ID

Return Value:

    Count of the number of dirty partitions for the given
    disk

--*/        
{
    ULONG PartCount = 0;
    
    if (DiskId < HardDiskCount) {
        PDISK_REGION Region = SPPT_GET_PRIMARY_DISK_REGION(DiskId);

        while (Region) {
            if (SPPT_IS_REGION_DIRTY(Region))
                PartCount++;

            Region = Region->Next;
        }

        Region = SPPT_GET_EXTENDED_DISK_REGION(DiskId);

        while (Region) {
            if (SPPT_IS_REGION_DIRTY(Region))
                PartCount++;
                
            Region = Region->Next;
        }
    }

    return PartCount;
}

VOID
SpPtnGetPartitionTypeCounts(
    IN ULONG DiskId,
    IN BOOLEAN SkipDeleted,
    IN PULONG PrimaryPartitions,    OPTIONAL
    IN PULONG ContainerPartitions,  OPTIONAL
    IN PULONG LogicalDrives,        OPTIONAL
    IN PULONG KnownPrimaryCount,    OPTIONAL
    IN PULONG KnownLogicalCount     OPTIONAL
    )
/*++

Routine Description:

    Counts various partition types for the given disk.
    
Arguments:

    DiskId          :   Disk ID
    
    SkipDeleted     :   Whether to skip the partitions marked
                        deleted or not

    PrimaryPartitions   :   Place holder for primary partition count

    ContainerPartitions :   Place holder for container partition count

    LogicalDrives       :   Place holder for logical drives count

Return Value:

    None

--*/        
{   
    if (SPPT_IS_MBR_DISK(DiskId) &&
        (ARGUMENT_PRESENT(PrimaryPartitions) || 
         ARGUMENT_PRESENT(ContainerPartitions) ||
         ARGUMENT_PRESENT(LogicalDrives))) {

        ULONG   Primary = 0, Container = 0, Logical = 0;    
        ULONG   ValidPrimary = 0, ValidLogical = 0;
        PDISK_REGION Region = SPPT_GET_PRIMARY_DISK_REGION(DiskId);

        while (Region) {
            if (!(SkipDeleted && SPPT_IS_REGION_MARKED_DELETE(Region))) {
                if (SPPT_IS_REGION_CONTAINER_PARTITION(Region)) {
                    Container++;            
                    
                    ASSERT(SPPT_IS_REGION_LOGICAL_DRIVE(Region) == FALSE);
                    ASSERT(SPPT_IS_REGION_PRIMARY_PARTITION(Region) == FALSE);
                    
                } else if (SPPT_IS_REGION_LOGICAL_DRIVE(Region)) {
                    UCHAR SystemId = SPPT_GET_PARTITION_TYPE(Region);
                    
                    Logical++;

                    if(SPPT_IS_VALID_PRIMARY_PARTITION_TYPE(SystemId)) {
                        ValidLogical++;
                    }                    
                    
                    ASSERT(SPPT_IS_REGION_CONTAINER_PARTITION(Region) == FALSE);
                    ASSERT(SPPT_IS_REGION_PRIMARY_PARTITION(Region) == FALSE);
                    
                } else if (SPPT_IS_REGION_PRIMARY_PARTITION(Region)) {
                    UCHAR SystemId = SPPT_GET_PARTITION_TYPE(Region);
                    
                    Primary++;                   

                    if(SPPT_IS_VALID_PRIMARY_PARTITION_TYPE(SystemId)) {
                        ValidPrimary++;
                    }                    
                    
                    ASSERT(SPPT_IS_REGION_CONTAINER_PARTITION(Region) == FALSE);
                    ASSERT(SPPT_IS_REGION_LOGICAL_DRIVE(Region) == FALSE);
                }
            }                

            Region = Region->Next;
        }

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
            "SETUP:SpPtnGetPartitionTypeCounts(%d):P:%d,C:%d,L:%d,VP:%d,VL:%d\n",
            DiskId,
            Primary,
            Container,
            Logical,
            ValidPrimary,
            ValidLogical));
                                
        ASSERT((Logical <= Container) && (Primary <= PTABLE_DIMENSION));

        if (ARGUMENT_PRESENT(PrimaryPartitions))
            *PrimaryPartitions = Primary;

        if (ARGUMENT_PRESENT(ContainerPartitions))
            *ContainerPartitions = Container;

        if (ARGUMENT_PRESENT(LogicalDrives))
            *LogicalDrives = Logical;

        if (ARGUMENT_PRESENT(KnownPrimaryCount))
            *KnownPrimaryCount = ValidPrimary;

        if (ARGUMENT_PRESENT(KnownLogicalCount))
            *KnownLogicalCount = ValidLogical;
    }            
}

VOID
SpPtnFreeDiskRegions(
    IN ULONG DiskId
    )
/*++

Routine Description:

    Free the disk region linked list. Its assumed that
    this list has all the regions allocated in heap
    
Arguments:

    DiskId  :   Disk ID
    
Return Value:

    None
    
--*/        
{
    NTSTATUS Status;
    PPARTITIONED_DISK  Disk = SPPT_GET_PARTITIONED_DISK(DiskId);
    PDISK_REGION Region = Disk->PrimaryDiskRegions;
    PDISK_REGION Temp;

    while (Region) {
        Temp = Region;
        Region = Region->Next;

        SpMemFree(Temp);
    }            

    Disk->PrimaryDiskRegions = NULL;

    //
    // Mark the disk blank since we don't have any regions
    // for the disk currently
    //
    SPPT_SET_DISK_BLANK(DiskId, TRUE);
}

NTSTATUS
SpPtnZapSectors(
    IN HANDLE DiskHandle,
    IN ULONG BytesPerSector,
    IN ULONGLONG StartSector,
    IN ULONG SectorCount
    )
/*++

Routine Description:

    Zaps (zeros) the requested sector(s).
    
Arguments:

    DiskHandle  :   Open Handle to disk with R/W permissions

    StartSector :   Starting sector to Zap

    Sector Count:   Number of sectors to Zap 
                    (includes starting sector also)
    
Return Value:

    Appropriate status code.

--*/        
{
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;

    if (SectorCount && BytesPerSector) {
        ULONG       BufferSize = (BytesPerSector * 2);    
        PVOID       UBuffer = SpMemAlloc(BufferSize);    
        ULONGLONG   SectorIdx = StartSector;

        if (UBuffer) {
            PVOID Buffer ;
            
            RtlZeroMemory(UBuffer, BufferSize);
            
            Buffer = ALIGN(UBuffer, BytesPerSector);

            Status = STATUS_SUCCESS;
            
            while (NT_SUCCESS(Status) && SectorCount) {
                Status = SpReadWriteDiskSectors(DiskHandle,
                                SectorIdx,
                                1,
                                BytesPerSector,
                                Buffer,
                                TRUE);
                SectorIdx++;
                SectorCount--;
            }                
                                                
            SpMemFree(UBuffer);
        } else {
            Status = STATUS_NO_MEMORY;
        }
    }        

    return Status;
}

NTSTATUS
SpPtnZapRegionBootSector(
    IN HANDLE DiskHandle,
    IN PDISK_REGION Region
    )
/*++

Routine Description:

    Zaps (zeros) the starting sector for the given
    region. Generally used to zap the boot sector after 
    creating a new partition

    Currently skips the zapping for Container partitions
    
Arguments:

    DiskHandle  :   Open Handle to disk with R/W permissions

    Region      :   The region, whose boot sector (starting sector)
                    needs to be zapped

Return Value:

    Appropriate status code.

--*/        
{
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;

    if (Region) {
        if (!SPPT_IS_REGION_CONTAINER_PARTITION(Region)) {
            Status = SpPtnZapSectors(DiskHandle,
                            SPPT_DISK_SECTOR_SIZE(Region->DiskNumber),
                            Region->StartSector,
                            1);
        } else {
            Status = STATUS_SUCCESS;
        }            
    } 

    return Status;
}


#if 0

NTSTATUS
SpPtnStampMBROnGptDisk(
    IN HANDLE DiskHandle,
    IN ULONG DiskId,
    IN PDRIVE_LAYOUT_INFORMATION_EX LayoutInfo
    )    
/*++

Routine Description:

    Stamps the first 3 partitions as primary partitions in the
    MBR of the GPT disk (for testing)
    
Arguments:

    DiskHandle  :   Open Handle to disk with R/W permissions

    DiskId      :   The disk which we are operating on.

    LayoutInfo  :   The partition information for the disk

Return Value:

    Appropriate status code.

--*/        
{
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;
    
    if ((DiskId < HardDiskCount) && LayoutInfo && SPPT_IS_GPT_DISK(DiskId)) {
        PPARTITION_INFORMATION_EX   PartInfo;
        ON_DISK_PTE                 PartEntries[4];
        BOOLEAN                     WriteMBR = FALSE;
        PHARD_DISK                  Disk = SPPT_GET_HARDDISK(DiskId);
        ULONG                       BytesPerSector = Disk->Geometry.BytesPerSector;
        ULONG Index;        

        RtlZeroMemory(PartEntries, sizeof(ON_DISK_PTE) * 4);

        //
        // Go through the partitions and pick up the partitions
        // whose number are less than 4 (and not zero)
        //
        for (Index = 0; Index < LayoutInfo->PartitionCount; Index++) {
            ULONG PartIndex = 0;

            PartInfo = LayoutInfo->PartitionEntry + Index;
            PartIndex = PartInfo->PartitionNumber;

            if ((PartIndex > 0) && (PartIndex < 4)) {
                ULONGLONG   SectorStart = (PartInfo->StartingOffset.QuadPart / 
                                            BytesPerSector);
                ULONGLONG   SectorCount = (PartInfo->PartitionLength.QuadPart / 
                                            BytesPerSector);
                ULONGLONG   SectorEnd = SectorStart + SectorCount;                                            
                
                
                WriteMBR = TRUE;    // need to write MBR

                SpPtInitializeCHSFields(Disk,
                        SectorStart,
                        SectorEnd,
                        PartEntries + PartIndex);

                U_ULONG(&(PartEntries[PartIndex].RelativeSectors)) = (ULONG)SectorStart;
                U_ULONG(&(PartEntries[PartIndex].SectorCount)) = (ULONG)SectorCount;
                PartEntries[PartIndex].SystemId = PARTITION_HUGE;
            }
        }
        
        if (WriteMBR) {
            PUCHAR          UBuffer;
            PUCHAR          Buffer;
            PON_DISK_MBR    DummyMbr;

            UBuffer = SpMemAlloc(BytesPerSector * 2);

            if (UBuffer) {
            
                RtlZeroMemory(UBuffer, BytesPerSector * 2);

                //
                // align the buffer on sector boundary
                //
                Buffer = ALIGN(UBuffer, BytesPerSector);                


                //
                // Read sector 0 (for existing boot code)
                //
                Status = SpReadWriteDiskSectors(
                            DiskHandle,
                            (Disk->Int13Hooker == HookerEZDrive) ? 1 : 0,
                            1,
                            BytesPerSector,
                            Buffer,
                            FALSE
                            );

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                    "SETUP:SpPtnStampMBROnGptDisk():Read MBR on an GPT Disk for testing (%lx)\n",
                    Status));                            

                if (NT_SUCCESS(Status)) {
                    ASSERT(512 == BytesPerSector);

                    DummyMbr = (PON_DISK_MBR)Buffer;

                    //
                    // copy the 3 entries in partition table (which we created eariler)
                    //
                    RtlCopyMemory(DummyMbr->PartitionTable + 1, PartEntries + 1,
                                    sizeof(PartEntries) - sizeof(ON_DISK_PTE));
                                                    
                    //
                    // Write the sector(s).
                    //
                    Status = SpReadWriteDiskSectors(
                                DiskHandle,
                                (Disk->Int13Hooker == HookerEZDrive) ? 1 : 0,
                                1,
                                BytesPerSector,
                                Buffer,
                                TRUE
                                );

                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                        "SETUP:SpPtnStampMBROnGtpDisk():Wrote MBR on an GPT Disk for testing (%lx)\n",
                        Status));                            
                }                                

                SpMemFree(UBuffer);
            } else {
                Status = STATUS_NO_MEMORY;
            }                
        } else {
            Status = STATUS_SUCCESS;            
        }
    }

    return Status;
}

#endif // 0, comment out

NTSTATUS
SpPtnAssignPartitionNumbers(
    IN PDRIVE_LAYOUT_INFORMATION_EX LayoutEx
    )
/*++

Routine Description:

    Given a drive layout structure with number of partitions,
    walks through each partitions assigning a partition number
    if one is not already assigned.

    Does not assign partition number to container partitions
    
Arguments:

    LayoutEx  - Contains all the partitions some of which needs
                partition numbers

Return Value:

    Appropriate error code.

--*/        
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (LayoutEx && LayoutEx->PartitionCount) {
        ULONG       Index;
        PBOOLEAN    UsedArray;
        ULONG       PartCount = LayoutEx->PartitionCount;
        ULONG       Size = PartCount;
        ULONG       MaxPartAssigned;
        PPARTITION_INFORMATION_EX PartInfo = LayoutEx->PartitionEntry;

        //
        // Find out the space needed for boolean array
        //
        for (Index = 0, MaxPartAssigned = 0; Index < PartCount; Index++) {
            if (PartInfo[Index].PartitionNumber > MaxPartAssigned)
                MaxPartAssigned = PartInfo[Index].PartitionNumber;
        }

        Size = max(MaxPartAssigned, PartCount);
        Size++;

        UsedArray = (PBOOLEAN)SpMemAlloc(sizeof(BOOLEAN) * Size);

        if (UsedArray) {
            BOOLEAN Assign = FALSE;
            
            RtlZeroMemory(UsedArray, (sizeof(BOOLEAN) * Size));
            UsedArray[0] = TRUE;    // don't assign '0' to any partition

            //
            // Mark the already assigned partition numbers
            //
            for (Index = 0; Index < PartCount; Index++) {
                if (PartInfo[Index].PartitionNumber != 0) 
                    UsedArray[PartInfo[Index].PartitionNumber] = TRUE;
                else 
                    Assign = TRUE;
            }

            if (Assign) {
                ULONG   NextFreeEntry;

                //
                // Find the next available partition number for assignment
                //
                for (Index = 1, NextFreeEntry = 0; Index < Size; Index++) {
                    if (!UsedArray[Index]) {
                        NextFreeEntry = Index;

                        break;
                    }                        
                }

                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                    "SETUP: SpPtnAssignPartitionNumber : NextFreeEntry = %d\n",
                    NextFreeEntry));                

                //
                // Assign the partition numbers for the needed partitions
                //
                for (Index = 0; (Index < PartCount); Index++) {
                    if (SPPT_PARTITION_NEEDS_NUMBER(PartInfo + Index)) {
                        PartInfo[Index].PartitionNumber = NextFreeEntry; 
                        UsedArray[NextFreeEntry] = TRUE;

                        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                            "SETUP: SpPtnAssignPartitionNumber : Assigning = %d to %d\n",
                            NextFreeEntry, Index));                

                        while ((NextFreeEntry < Size) && UsedArray[NextFreeEntry])
                            NextFreeEntry++;
                    }                        
                }
            }

            Status = STATUS_SUCCESS;

            SpMemFree(UsedArray);                
        } else {
            Status = STATUS_NO_MEMORY;
        }            
    }

    return Status;
}


NTSTATUS
SpPtnInitializeDiskStyle(
    IN ULONG DiskId,
    IN PARTITION_STYLE Style,
    IN PCREATE_DISK DiskInfo OPTIONAL
    )
/*++

Routine Description:

    Given the disk, changes the disk style (MBR/GPT) as
    requested.

    For RAW disks, uses the default partition type style
    which can differ from platform to platform.
    
Arguments:

    DiskId      :   Disk ID

    Style       :   Partition Style

    DiskInfo    :   Disk information which needs to be used,
                    while initializing the disk
                    
Return Value:

    Appropriate error code

--*/        
{
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;

#ifdef COMMIT_TESTING
    if (!DiskId)
        return STATUS_SUCCESS;
#endif
        

    if (SPPT_IS_BLANK_DISK(DiskId) && 
        ((Style == PARTITION_STYLE_GPT) || (Style == PARTITION_STYLE_MBR))) {        
        WCHAR    DiskPath[MAX_PATH];
        HANDLE   DiskHandle;

        //
        // form the name
        //
        swprintf(DiskPath, L"\\Device\\Harddisk%u", DiskId);        

        //
        // Open partition 0 on this disk..
        //
        Status = SpOpenPartition0(DiskPath, &DiskHandle, TRUE);

        if (NT_SUCCESS(Status)) {
            IO_STATUS_BLOCK IoStatusBlock;
            NTSTATUS InitStatus;


            if (Style == PARTITION_STYLE_GPT) {
                CREATE_DISK  CreateInfo;

                RtlZeroMemory(&CreateInfo, sizeof(CREATE_DISK));

                if (DiskInfo) {
                    CreateInfo = *DiskInfo;
                    CreateInfo.PartitionStyle = Style;
                } else {
                    CreateInfo.PartitionStyle = Style; 
                    SpCreateNewGuid(&(CreateInfo.Gpt.DiskId));
                    CreateInfo.Gpt.MaxPartitionCount = 0;  // will be 128 actually
                }                    

                Status = ZwDeviceIoControlFile( DiskHandle,
                                            NULL,
                                            NULL,
                                            NULL,
                                            &IoStatusBlock,
                                            IOCTL_DISK_CREATE_DISK,
                                            &CreateInfo,
                                            sizeof(CREATE_DISK),
                                            NULL,
                                            0);

            } else {
                //
                // Note : This is needed since CREATE_DISK doesn't work for
                // MBR disks :(
                //
                ULONG LayoutSize;
                PDRIVE_LAYOUT_INFORMATION_EX DriveLayout;
                PHARD_DISK  Disk;

                Disk = SPPT_GET_HARDDISK(DiskId);

                LayoutSize = sizeof(DRIVE_LAYOUT_INFORMATION_EX) +
                                (3 * sizeof(PARTITION_INFORMATION_EX));
                                
                DriveLayout = (PDRIVE_LAYOUT_INFORMATION_EX)SpMemAlloc(LayoutSize);

                if (DriveLayout) {
                    RtlZeroMemory(DriveLayout, LayoutSize);

                    DriveLayout->PartitionStyle = PARTITION_STYLE_MBR;
                    DriveLayout->PartitionCount = 4;

                    if (DiskInfo) {
                        Disk->Signature = DriveLayout->Mbr.Signature = 
                            DiskInfo->Mbr.Signature;
                    } else {                    
                        Disk->Signature = DriveLayout->Mbr.Signature = 
                            SPPT_GET_NEW_DISK_SIGNATURE();
                    }                        

                    DriveLayout->PartitionEntry[0].RewritePartition = TRUE;
                    DriveLayout->PartitionEntry[1].RewritePartition = TRUE;
                    DriveLayout->PartitionEntry[2].RewritePartition = TRUE;
                    DriveLayout->PartitionEntry[3].RewritePartition = TRUE;

                    Status = ZwDeviceIoControlFile( DiskHandle,
                                                    NULL,
                                                    NULL,
                                                    NULL,
                                                    &IoStatusBlock,
                                                    IOCTL_DISK_SET_DRIVE_LAYOUT_EX,
                                                    DriveLayout,
                                                    LayoutSize,
                                                    NULL,
                                                    0);                    

                    if (NT_SUCCESS(Status)) {                    
                        ULONG   Signature = 0;

                        //
                        // Zero out sector 1 & 2 also since it might contain
                        // stale GPT information
                        //
                        if (!SPPT_IS_REMOVABLE_DISK(DiskId)) {
                            SpPtnZapSectors(DiskHandle, 
                                        SPPT_DISK_SECTOR_SIZE(DiskId),
                                        1, 
                                        2);
                        }                            
                                                                
                        Status = SpMasterBootCode(DiskId, DiskHandle, &Signature);
                    }

                    SpMemFree(DriveLayout);                                                
                } else {
                    Status = STATUS_NO_MEMORY;
                }                
            }            

            ZwClose(DiskHandle);
        }
    }

    if (!NT_SUCCESS(Status)) {
        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
            "SETUP: SpPtnInitializeDiskStyle (%d, %d) failed with (%lx)\n",
            DiskId, Style, Status));
    }

    SpAppendDiskTag(SPPT_GET_HARDDISK(DiskId));    
    
    return Status;
}

BOOLEAN
SpPtnRegionToPartitionInfoEx(
    IN  PDISK_REGION Region,
    OUT PPARTITION_INFORMATION_EX PartInfo
    )
/*++

Routine Description:

    Fills in the PartInfo structure from the given region.

    NB. If the region is not dirty uses the cached partition 
    information to fill the structure.
    
Arguments:

    Region      -   Which has the details to be filled 
                    into PartInfo

    PartInfo    -   The structure which needs to filled

Return Value:

    TRUE if successful, otherwise FALSE

--*/        
{
    BOOLEAN Result = FALSE;
    
    if (Region && PartInfo && 
        (SPPT_IS_REGION_CONTAINER_PARTITION(Region) || SPPT_IS_REGION_PARTITIONED(Region))) {
        if (SPPT_IS_REGION_DIRTY(Region)) {            
            PHARD_DISK  Disk = SPPT_GET_HARDDISK(Region->DiskNumber);
            
            PartInfo->StartingOffset.QuadPart = Region->StartSector * 
                    Disk->Geometry.BytesPerSector;

            PartInfo->PartitionLength.QuadPart = Region->SectorCount *
                    Disk->Geometry.BytesPerSector;

            PartInfo->PartitionNumber = Region->PartitionNumber;                
            PartInfo->RewritePartition = TRUE;

            if (SPPT_IS_GPT_DISK(Region->DiskNumber)) {                        
                PPARTITION_INFORMATION_GPT  GptInfo;

                PartInfo->PartitionStyle = PARTITION_STYLE_GPT;
                GptInfo = &(PartInfo->Gpt);

                if (Region->PartInfoDirty) {
                    //
                    // User specified partition attributes
                    //
                    *GptInfo = Region->PartInfo.Gpt;
                } else {                  
                    GptInfo->Attributes = 0;

                    if (SPPT_IS_REGION_SYSTEMPARTITION(Region)) {
                        GptInfo->PartitionType = PARTITION_SYSTEM_GUID;
                    } else {
                        GptInfo->PartitionType = PARTITION_BASIC_DATA_GUID;                        
                    }
                    
                    SpCreateNewGuid(&(GptInfo->PartitionId));
                }                    

                SpPtnGetPartitionNameFromGUID(&(GptInfo->PartitionType),
                    GptInfo->Name);                
            } else {
                PPARTITION_INFORMATION_MBR  MbrInfo;

                PartInfo->PartitionStyle = PARTITION_STYLE_MBR;
                MbrInfo = &(PartInfo->Mbr);

                MbrInfo->PartitionType = SPPT_GET_PARTITION_TYPE(Region); 

                if (!MbrInfo->PartitionType)
                    MbrInfo->PartitionType = PARTITION_IFS;        

                MbrInfo->BootIndicator = SPPT_IS_REGION_ACTIVE_PARTITION(Region);

                //
                // System partition must be active partition for MBR disks
                // on Non-ARC machines
                //
                if (SPPT_IS_REGION_SYSTEMPARTITION(Region) && !SpIsArc() ) {
                    ASSERT(MbrInfo->BootIndicator);
                }
                
                MbrInfo->RecognizedPartition = 
                    IsRecognizedPartition(MbrInfo->PartitionType);

                MbrInfo->HiddenSectors = 0;                     
            }                                    
        } else {
            *PartInfo = Region->PartInfo;
        }

        Result = TRUE;
    }

    return Result;
}


BOOLEAN
SpPtnInitDiskInfo(
    IN PDRIVE_LAYOUT_INFORMATION_EX LayoutInfo,
    OUT PCREATE_DISK CreateInfo
    )
/*++

Routine Description:

    Fills the information needed for creating a disk,
    form the given drive layout structure

    NB. If the LayoutInfo is marked as RAW disk style
    then used the default partition style for the disk.
    This default style can vary from platform to platform
    
Arguments:

    LayoutInfo  -   The drive layout information to use

    CreateInfo  -   The disk information to be filled in

Return Value:

    TRUE if successful otherwise FALSE.1

--*/        
{
    BOOLEAN Result = FALSE;

    if (LayoutInfo && CreateInfo) {
        RtlZeroMemory(CreateInfo, sizeof(CREATE_DISK));

        CreateInfo->PartitionStyle = LayoutInfo->PartitionStyle;

        switch (CreateInfo->PartitionStyle) {
            case PARTITION_STYLE_MBR:
                CreateInfo->Mbr.Signature = LayoutInfo->Mbr.Signature;
                Result = TRUE;

                break;

            case PARTITION_STYLE_GPT:
                CreateInfo->Gpt.DiskId = LayoutInfo->Gpt.DiskId;

                CreateInfo->Gpt.MaxPartitionCount = 
                        LayoutInfo->Gpt.MaxPartitionCount;

                Result = TRUE;                        

                break;


            case PARTITION_STYLE_RAW:
                CreateInfo->PartitionStyle = SPPT_DEFAULT_PARTITION_STYLE;

                if (CreateInfo->PartitionStyle == PARTITION_STYLE_GPT) {
                    SpCreateNewGuid(&(CreateInfo->Gpt.DiskId));      
                } else {
                    CreateInfo->Mbr.Signature = SPPT_GET_NEW_DISK_SIGNATURE();
                }

                Result = TRUE;

                break;

            default:
                break;
        }
    }

    return Result;
}


NTSTATUS
SpPtnCommitChanges(
    IN  ULONG    DiskNumber,
    OUT PBOOLEAN AnyChanges
    )
/*++

Routine Description:

    Given the disk, commits the in memory disk region structures
    to the disk as partitions.

    The commit happens only if atlease a single disk region for the
    given disk is dirty.
    
Arguments:

    DiskNumber  :   Disk to commit for.

    AnyChanges  :   Place holder, indicating if any thing was committed
                    or not.
    
Return Value:

    Appropriate error code.

--*/        
{
    NTSTATUS    Status;
    ULONG       LayoutSize;
    HANDLE      Handle = NULL;
    ULONG       Index;
    ULONG       PartitionCount;    
    ULONG       DirtyCount;
    WCHAR       DevicePath[MAX_PATH];
    BOOLEAN     ProcessExtended;
    PHARD_DISK  Disk;
    PDISK_REGION    Region;
    IO_STATUS_BLOCK IoStatusBlock;    
    PPARTITION_INFORMATION_EX       PartInfo;
    PDRIVE_LAYOUT_INFORMATION_EX    DriveLayoutEx;

    //
    // For the time being lets not commit the primary disk
    // where we have our OS/RC installed
    //
#ifdef TESTING_COMMIT    
    if (!DiskNumber)
        return STATUS_SUCCESS;
#endif        
    
    if (DiskNumber >= HardDiskCount)
        return STATUS_INVALID_PARAMETER;

    *AnyChanges = FALSE;

    SpPtDumpDiskRegionInformation(DiskNumber, TRUE);
    
    //
    // Check to see if we need to commit
    //    
    DirtyCount = SpPtnGetDirtyPartitionCountDisk(DiskNumber);
    
    if (DoActualCommit && !DirtyCount)
        return STATUS_SUCCESS;

    *AnyChanges = TRUE;

    if (!SpPtnGetContainerPartitionCount(DiskNumber)) {
        //
        // Recreate the DRIVE_LAYOUT_INFORMATION_EX structure
        //
        PartitionCount = SpPtnGetPartitionCountDisk(DiskNumber);    
        LayoutSize = sizeof(DRIVE_LAYOUT_INFORMATION_EX);

        if (PartitionCount == 0) { 
            CREATE_DISK DiskInfo;

            SpPtnInitDiskInfo(&(SPPT_GET_HARDDISK(DiskNumber)->DriveLayout), 
                             &DiskInfo);

            SPPT_SET_DISK_BLANK(DiskNumber, TRUE);                                                                      

            Status = SpPtnInitializeDiskStyle(DiskNumber, 
                        DiskInfo.PartitionStyle, &DiskInfo);

            SpPtnFreeDiskRegions(DiskNumber);

            //
            // Update the boot entries to point to null regions
            // (if any)
            //
            SpUpdateRegionForBootEntries();            

            return Status;                                        
        } 
        
        if (PartitionCount > 1) {    
            LayoutSize += ((PartitionCount  - 1) * sizeof(PARTITION_INFORMATION_EX));
        }                        

        if (PartitionCount < 4) {
            LayoutSize += ((4 - PartitionCount) * sizeof(PARTITION_INFORMATION_EX));
        }
        
        DriveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX)SpMemAlloc(LayoutSize);

        if (!DriveLayoutEx)
            return STATUS_NO_MEMORY;

        RtlZeroMemory(DriveLayoutEx, LayoutSize);

        RtlCopyMemory(DriveLayoutEx, &(HardDisks[DiskNumber].DriveLayout),
                    FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION_EX, PartitionEntry));
         
        DriveLayoutEx->PartitionCount = PartitionCount;                
                
        PartInfo = DriveLayoutEx->PartitionEntry;
        Region = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);
        ProcessExtended = TRUE;

        //
        // Initialize stray partitions
        //
        if (SPPT_IS_MBR_DISK(DiskNumber) && (PartitionCount < 4)) {        
            ULONG Index = PartitionCount;
            
            DriveLayoutEx->PartitionStyle = PARTITION_STYLE_MBR;
            DriveLayoutEx->PartitionCount = 4;        

            while (Index < 4) {
                DriveLayoutEx->PartitionEntry[Index].PartitionStyle = PARTITION_STYLE_MBR;
                DriveLayoutEx->PartitionEntry[Index].RewritePartition = TRUE;                    
                Index++;
            }
        }
        
        //
        // Make PARTITION_INFORMATION_EXs from DISK_REGIONs for all non deleted
        // partitions
        //
        for (Index=0; (Region && (Index < PartitionCount));) {
            if (SPPT_IS_REGION_PARTITIONED(Region) && 
                (!SPPT_IS_REGION_MARKED_DELETE(Region))) {
                
                Status = SpPtnRegionToPartitionInfoEx(Region, PartInfo + Index);
                
                ASSERT(NT_SUCCESS(Status));
                Index++;
            } 
            
            Region = Region->Next;
        }
    } else {
        //
        // The disk has container partitions and possibly logical
        // drives
        //
        ULONG   PrimaryCount = 0, ContainerCount = 0, LogicalCount = 0;
        ULONG   TotalPartitions;

        //SpPtDumpDiskRegionInformation(DiskNumber, TRUE);

        SpPtnGetPartitionTypeCounts(DiskNumber, 
                    TRUE, 
                    &PrimaryCount, 
                    &ContainerCount, 
                    &LogicalCount, 
                    NULL, 
                    NULL);
                    
        TotalPartitions = PrimaryCount + ContainerCount + LogicalCount;

        if (TotalPartitions == 0) {            
            CREATE_DISK DiskInfo;
            
            SpPtnInitDiskInfo(&(SPPT_GET_HARDDISK(DiskNumber)->DriveLayout), 
                             &DiskInfo);

            SPPT_SET_DISK_BLANK(DiskNumber, TRUE);                             
        
            Status = SpPtnInitializeDiskStyle(DiskNumber, 
                        DiskInfo.PartitionStyle, &DiskInfo);

            SpPtnFreeDiskRegions(DiskNumber);                        

            //
            // Update the boot entries to point to null regions
            // (if any)
            //
            SpUpdateRegionForBootEntries();            
            
            return Status;                        
        } else {
            BOOLEAN FirstContainer = FALSE;

            //
            // allocate adequate space for the drive layout information
            //
            PartitionCount = (4 * (ContainerCount + 1));            

            LayoutSize = FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION_EX, PartitionEntry) +
                            (PartitionCount * sizeof(PARTITION_INFORMATION_EX));

            DriveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX)SpMemAlloc(LayoutSize);

            if (!DriveLayoutEx)
                return STATUS_NO_MEMORY;

            //
            // initialize the drive layout information
            //
            RtlZeroMemory(DriveLayoutEx, LayoutSize);

            RtlCopyMemory(DriveLayoutEx, &(HardDisks[DiskNumber].DriveLayout),
                    FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION_EX, PartitionEntry));

            DriveLayoutEx->PartitionCount = PartitionCount;                    

            PartInfo = DriveLayoutEx->PartitionEntry;
            Region = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);           

            //SpPtDumpDiskRegionInformation(DiskNumber, TRUE);

            //
            // first pickup the primary partitions and the first
            // container partition and put them in the drive layout 
            // information 
            //
            for (Index=0; (Region && (Index < 4)); ) {
                if (!SPPT_IS_REGION_MARKED_DELETE(Region)){
                    if (!FirstContainer && 
                         SPPT_IS_REGION_CONTAINER_PARTITION(Region)) {                         
                        FirstContainer = TRUE;
                        Status = SpPtnRegionToPartitionInfoEx(Region, PartInfo + Index);
                        ASSERT(NT_SUCCESS(Status));                        
                        Index++;
                    } else if (SPPT_IS_REGION_PRIMARY_PARTITION(Region)) {
                        Status = SpPtnRegionToPartitionInfoEx(Region, PartInfo + Index);
                        ASSERT(NT_SUCCESS(Status));                        
                        Index++;
                    }
                }

                Region = Region->Next;
            }

            //SpPtDumpDriveLayoutInformation(NULL, DriveLayoutEx);

            //
            // further container and logical drives need to start at
            // multiple of 4 index, in drive layout
            //
            if (Index)
                Index = 4;

            Region = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);                

            //
            // pickup the remaining valid container and logical drives
            // and put them in the drive layout information except
            // for the first container partition, which we have
            // already processed
            //
            while (Region && (Index < PartitionCount)) {
                if ((!SPPT_IS_REGION_FIRST_CONTAINER_PARTITION(Region)) &&
                    (!SPPT_IS_REGION_MARKED_DELETE(Region)) &&
                    (!SPPT_IS_REGION_PRIMARY_PARTITION(Region)) &&
                    (SPPT_IS_REGION_PARTITIONED(Region) || 
                     SPPT_IS_REGION_CONTAINER_PARTITION(Region))) {
                    
                    Status = SpPtnRegionToPartitionInfoEx(Region, PartInfo + Index);
                    ASSERT(NT_SUCCESS(Status));                   

                    if (SPPT_IS_REGION_CONTAINER_PARTITION(Region) && 
                        (Region->Next) &&
                        SPPT_IS_REGION_LOGICAL_DRIVE(Region->Next)) {

                        //
                        // think about this ;)                                
                        //
                        if (Index % 4)
                            Index += 3; 
                        else
                            Index += 4;
                    } else {
                        Index++;
                    }
                }

                Region = Region->Next;
            }
        }
    }

    //
    // Assign proper partition numbers
    //
    // TBD : Needed ?
    // Status = SpPtnAssignPartitionNumbers(DriveLayoutEx);
    //
    Status = STATUS_SUCCESS;

    if (NT_SUCCESS(Status)) {    
        //
        // Need to rewrite all the partitions
        //
        for (Index = 0; Index < DriveLayoutEx->PartitionCount; Index++)
            PartInfo[Index].RewritePartition = TRUE;      

        //
        // Commit the Partition changes
        //

        //
        // Create a device path (NT style!) that will describe this disk.  This
        // will be of the form: \Device\Harddisk0
        //
        swprintf(DevicePath, L"\\Device\\Harddisk%u", DiskNumber);


        //SpPtDumpDriveLayoutInformation(DevicePath, DriveLayoutEx);

        //
        // Open partition 0 on this disk..
        //
        Status = SpOpenPartition0(DevicePath, &Handle, TRUE);

        if(NT_SUCCESS(Status)){
            if (DoActualCommit) {
                // write the drive layout information
                Status = ZwDeviceIoControlFile( Handle,
                                                NULL,
                                                NULL,
                                                NULL,
                                                &IoStatusBlock,
                                                IOCTL_DISK_SET_DRIVE_LAYOUT_EX,
                                                DriveLayoutEx,
                                                LayoutSize,
                                                NULL,
                                                0);

                if(NT_SUCCESS(Status)) {
                    Region = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);

                    KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                          "SETUP: SpPtnCommitChanges : Commited partitions "
                          "successfully on %ws (%lx)\n",                          
                          DevicePath));

                    if (NT_SUCCESS(Status)) {                       
                        ULONG   Signature = 0;
                        ULONG   Count = 0;

                        if (SPPT_IS_MBR_DISK(DiskNumber)) {
                            Status = SpMasterBootCode(DiskNumber,
                                            Handle,
                                            &Signature);

                            if (!NT_SUCCESS(Status)) {                                        
                                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                                      "SETUP: SpPtnCommitChanges : Unable to write "
                                      "master boot code (%lx)\n",                          
                                      Status));
                            }                                                                          
                        }                                                            
                        
                        while (Region && NT_SUCCESS(Status)) {
                            if (Region->Filesystem == FilesystemNewlyCreated) {                        
                               Status = SpPtnZapRegionBootSector(Handle, Region);
                               Count++;
                            }

                            Region = Region->Next;
                        }

                        if (!NT_SUCCESS(Status)) {
                            KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                                  "SETUP: SpPtnCommitChanges : Error in Zapping\n"));

                            //SpPtDumpDiskRegion(Region);                            
                        } else {
                            KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  
                                  "SETUP: SpPtnCommitChanges : Zapped %d sectors :)\n",
                                  Count));

#ifdef STAMP_MBR_ON_GPT_DISK                                  
                            Status = ZwDeviceIoControlFile( Handle,
                                                            NULL,
                                                            NULL,
                                                            NULL,
                                                            &IoStatusBlock,
                                                            IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                                                            NULL,
                                                            0,
                                                            DriveLayoutEx,
                                                            LayoutSize);  

                            if (NT_SUCCESS(Status)) {
                                Status = SpPtnStampMBROnGptDisk(Handle,
                                            DiskNumber,
                                            DriveLayoutEx);
                            }
#endif                            
                        }
                    }                        
                } else {
                    KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                          "SETUP: SpPtnCommitChanges : unable to do "
                          "IOCTL_DISK_SET_DRIVE_LAYOUT_EX on device %ws (%lx)\n",
                          DevicePath,
                          Status));
                }
            } else {
                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                    "SETUP: SpPtnCommitChanges : Skipping acutal commit to disk "
                    "for %ws\n",
                    DevicePath));
            }

            ZwClose(Handle);                            
        } else {
            KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                "SETUP: SpPtnCommitChanges : unable to open "
                "partition0 on device %ws (%lx)\n",
                DevicePath,
                Status ));
        }
    } else {
        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
            "SETUP: SpPtnCommitChanges : unable to assign "
            "partition numbers for %ws (%lx)\n",
            DevicePath,
            Status ));
    }
    
    SpMemFree(DriveLayoutEx);

    return Status;
}

NTSTATUS
SpPtnRemoveLogicalDrive(
    IN PDISK_REGION LogicalDrive
    )
/*++

Routine Description:

    Manipulates the in memory region data structure
    so as to mark the logical drive as deleted.

    NB. When a logical drive gets deleted, the container
    partition needs to be deleted based on some
    conditions.
    
Arguments:

    LogicalDrive :  The region representing the logical
                    drive which needs to be deleted.

Return Value:

    Approprate error code

--*/        
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (SPPT_IS_REGION_LOGICAL_DRIVE(LogicalDrive) && 
            (LogicalDrive->Container)){
        PDISK_REGION ContainerRegion = LogicalDrive->Container;
        BOOLEAN LastLogicalDrive = 
                    (SpPtnGetLogicalDriveCount(LogicalDrive->DiskNumber) == 1);

        SPPT_SET_REGION_DELETED(LogicalDrive, TRUE);
        SPPT_SET_REGION_DIRTY(LogicalDrive, TRUE);
        SPPT_SET_REGION_PARTITIONED(LogicalDrive, FALSE);

        if (LastLogicalDrive) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                "SETUP:SpPtnRemoveLogicalDrive(%p) is the last"
                " logical drive\n", LogicalDrive));        
        }                                 

        if (ContainerRegion->Container) {            
            PDISK_REGION    Region = NULL;
            
            SPPT_SET_REGION_DELETED(ContainerRegion, TRUE);      
            SPPT_SET_REGION_DIRTY(ContainerRegion, TRUE);
            SPPT_SET_REGION_PARTITIONED(ContainerRegion, FALSE);            

            //
            // if this was the last logical drive then delete the
            // first container region also
            //
            if (LastLogicalDrive) {
                ASSERT(SPPT_IS_REGION_CONTAINER_PARTITION(
                        ContainerRegion->Container));
                        
                SPPT_SET_REGION_DELETED(ContainerRegion->Container, TRUE);      
                SPPT_SET_REGION_DIRTY(ContainerRegion->Container, TRUE);
                SPPT_SET_REGION_PARTITIONED(ContainerRegion->Container, FALSE);            
            }
        } else {
            if (LastLogicalDrive) {
                //
                // No trailing region, so delete the first container region
                //
                SPPT_SET_REGION_DELETED(ContainerRegion, TRUE);      
                SPPT_SET_REGION_DIRTY(ContainerRegion, TRUE);
                SPPT_SET_REGION_PARTITIONED(ContainerRegion, FALSE);            
            }
        }            

        Status = STATUS_SUCCESS;
    }

    return Status;
}


BOOLEAN
SpPtnDelete(
    IN ULONG        DiskNumber,
    IN ULONGLONG    StartSector
    )
/*++

Routine Description:

    Removes the requested partition for the given disk.

    Also updates the region structure when returns.
    
Arguments:

    DiskNumber  :   Disk where the partition needs to be
                    deleted.

    StartSector :   Start sector of the partition/region
                    which needs to be deleted.

Return Value:

    TRUE if successful otherwise FALSE.

--*/        
{
    BOOLEAN Result = FALSE;
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    PDISK_REGION Region;
    PPARTITIONED_DISK PartDisk;    
    NTSTATUS InitStatus;

#ifdef TESTING_COMMIT
    if (DiskNumber == 0)
        return TRUE;
#endif
  
    PartDisk = SPPT_GET_PARTITIONED_DISK(DiskNumber);
    Region = SpPtLookupRegionByStart(PartDisk, FALSE, StartSector);

    if (Region) {        
        if (SPPT_IS_REGION_DYNAMIC_VOLUME(Region) || SPPT_IS_REGION_LDM_METADATA(Region)) {
            //
            // delete all the regions on this disk
            //
            PDISK_REGION CurrRegion = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);


            if (SPPT_IS_MBR_DISK(DiskNumber)) {
                //
                // Skip OEM partitions on MBR disk since they will always be
                // hard partitions
                //
                // NOTE : Assumes that all the OEM partitions are primary
                //        partitions (which also indicates they are hard partitions)
                //
                while (CurrRegion) {                
                    if (!IsOEMPartition(SPPT_GET_PARTITION_TYPE(CurrRegion))) {
                        SPPT_SET_REGION_PARTITIONED(CurrRegion, FALSE);
                        SPPT_SET_REGION_DELETED(CurrRegion, TRUE);
                        SPPT_SET_REGION_DIRTY(CurrRegion, TRUE);
                    }   

                    CurrRegion = CurrRegion->Next;
                }
            } else {
                while (CurrRegion) {    
                    //
                    // Skip ESP & MSR partitions since they will always be
                    // hard partitions
                    //
                    if (!SPPT_IS_REGION_EFI_SYSTEM_PARTITION(CurrRegion) &&
                        !SPPT_IS_REGION_MSFT_RESERVED(CurrRegion)) {
                        SPPT_SET_REGION_PARTITIONED(CurrRegion, FALSE);
                        SPPT_SET_REGION_DELETED(CurrRegion, TRUE);
                        SPPT_SET_REGION_DIRTY(CurrRegion, TRUE);
                    }                        

                    CurrRegion = CurrRegion->Next;
                }
            }   

            Status = STATUS_SUCCESS;
        } else if (SPPT_IS_REGION_LOGICAL_DRIVE(Region)) {
            Status = SpPtnRemoveLogicalDrive(Region);
        } else {
            SPPT_SET_REGION_PARTITIONED(Region, FALSE);
            SPPT_SET_REGION_DELETED(Region, TRUE);
            SPPT_SET_REGION_DIRTY(Region, TRUE);
            
            Status = STATUS_SUCCESS;
        }

        if (NT_SUCCESS(Status)) {
            Status = SpPtnCommitChanges(DiskNumber, &Result);

            if (!(Result && NT_SUCCESS(Status))) {
                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                    "SETUP: SpPtnDelete(%u, %I64u) failed to commit changes (%lx)\n",
                    DiskNumber, StartSector, Status));                                
            }                      
        } else {
            KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                "SETUP: SpPtnDelete(%u, %I64u) failed to delete logical drive (%lx)\n",
                DiskNumber, StartSector, Status));
        }
    }

    Result = Result && NT_SUCCESS(Status);

    //
    // Reinitialize regions irrespective of commit's status
    //
    InitStatus = SpPtnInitializeDiskDrive(DiskNumber);
    
    if (!NT_SUCCESS(InitStatus)) {
        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
            "SETUP: SpPtnDelete(%u, %I64u) failed to reinit regions\n", 
            DiskNumber, 
            StartSector));

        Result = FALSE;
    }    

    return Result;
}    


ValidationValue
SpPtnGetSizeCB(
    IN ULONG Key
    )
/*++

Routine Description:

    Key stroke filter for getting the partition size
    from the user
    
Arguments:

    Key -   The key stroke

Return Value:

    One of the enumerated types of ValidationValue, indicating
    whether to accept / reject / terminate / ignore the key
    stroke.

--*/        
{
    if(Key == ASCI_ESC) {
        //
        // User wants to bail.
        //
        return(ValidateTerminate);
    }


    if(Key & KEY_NON_CHARACTER) {
        return(ValidateIgnore);
    }

    //
    // Allow only digits.
    //
    return(((Key >= L'0') && (Key <= L'9')) ? ValidateAccept : ValidateReject);
}

BOOLEAN
SpPtnGetSizeFromUser(
    IN PHARD_DISK   Disk,
    IN ULONGLONG    MinMB,
    IN ULONGLONG    MaxMB,
    OUT PULONGLONG  SizeMB
    )
/*++

Routine Description:

    Gets the size from user, after showing him the minimum
    and maximum values
    
Arguments:

    Disk    -   Disk for which the partition size is being
                requested

    MinMB   -   Minimum partition size

    MaxMB   -   Maximim patitions size

    SizeMB  -   Place holder for user entered size

Return Value:

    TRUE if the input was valid or FALSE if the user 
    cancelled the input dialog using ESC.

--*/        
{
    BOOLEAN     Result;
    WCHAR       Buffer[200];
    WCHAR       SizeBuffer[32] = {0};

    *SizeMB = 0;
    
    //
    // Put up a screen displaying min/max size info.
    //
    SpStartScreen(
        SP_SCRN_CONFIRM_CREATE_PARTITION,
        3,
        CLIENT_TOP + 1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE,
        Disk->Description,
        (ULONG)MinMB,
        (ULONG)MaxMB
        );

    //
    // Display the staus text.
    //
    SpDisplayStatusOptions(
        DEFAULT_STATUS_ATTRIBUTE,
        SP_STAT_ENTER_EQUALS_CREATE,
        SP_STAT_ESC_EQUALS_CANCEL,
        0
        );

    //
    // Get and display the size prompt.
    //
    SpFormatMessage(Buffer, sizeof(Buffer), SP_TEXT_SIZE_PROMPT);

    SpvidDisplayString(Buffer, DEFAULT_ATTRIBUTE, 3, NextMessageTopLine);

    Result = TRUE;
    
    //
    // Get the size from the user.
    //
    do {
        swprintf(SizeBuffer,L"%u", (ULONG)MaxMB);
        
        if(!SpGetInput(SpPtnGetSizeCB, 
                    SplangGetColumnCount(Buffer) + 5,
                    NextMessageTopLine,
                    8,                      // at the max 99999999
                    SizeBuffer,
                    TRUE,
                    0)) {
            //
            // User pressed escape and bailed.
            //
            Result = FALSE;
            break;
        }

        *SizeMB = SpStringToLong(SizeBuffer, NULL, 10);
    } 
    while(((*SizeMB) < MinMB) || ((*SizeMB) > MaxMB));

    return Result;
}


VOID
SpPtnAlignPartitionStartAndEnd(
    IN  PHARD_DISK  Disk,
    IN  ULONGLONG   SizeMB,
    IN  ULONGLONG   StartSector,
    IN  PDISK_REGION Region,
    IN  BOOLEAN     ForExtended,
    OUT PULONGLONG  AlignedStartSector,
    OUT PULONGLONG  AlignedEndSector
    )
/*++

Routine Description:

    Aligns the partition start and end sector
    
Arguments:

    Disk    -   Partition's disk for which alignment needs to be
                done.

    SizeMB  -   The partition's size

    StartSector - The start sector of the partition

    Region  -   The region representing the partition

    ForExtended -   Whether this partition needs to be aligned
                    for creating a container partition.

    AlignedStartSector  - Place holder for the aligned start sector

    AlignedEndSector    - Place holder fot the aligned end sector


Return Value:

    None

--*/        
{
    ULONGLONG   SectorCount;
    ULONGLONG   LeftOverSectors;
    
    //
    // Determine the number of sectors in the size passed in.
    //
    SectorCount = SizeMB * ((1024 * 1024) / Disk->Geometry.BytesPerSector);

    //
    // If this is the first free space inside the extended partition
    // we need to decrement the StartSector so that while creating
    // first logical inside the extended we don't create the 
    // logical at one cylinder offset
    //
    if (SPPT_IS_REGION_NEXT_TO_FIRST_CONTAINER(Region) && StartSector) {        
        StartSector--;
    }

    //
    // Align the start sector.
    //
    (*AlignedStartSector) = SpPtAlignStart(Disk, StartSector, ForExtended);

    //
    // Determine the end sector based on the size passed in.
    //
    (*AlignedEndSector) = (*AlignedStartSector) + SectorCount;

    //
    // Align the ending sector to a cylinder boundary.  If it is not already
    // aligned and is more than half way into the final cylinder, align it up,
    // otherwise align it down.
    //
    LeftOverSectors = (*AlignedEndSector) % Disk->SectorsPerCylinder;

    if (LeftOverSectors) {
        (*AlignedEndSector) -= LeftOverSectors;
        
        if (LeftOverSectors > (Disk->SectorsPerCylinder / 2)) {
            (*AlignedEndSector) += Disk->SectorsPerCylinder;
        }
    }

    //
    // If the ending sector is past the end of the free space, shrink it
    // so it fits.
    //
    while((*AlignedEndSector) > StartSector + Region->SectorCount) {
        (*AlignedEndSector) -= Disk->SectorsPerCylinder;
    }

    //
    //  Find out if last sector is in the last cylinder. If it is then align it down.
    //  This is necessary so that we reserve a cylinder at the end of the disk, so that users
    //  can convert the disk to dynamic after the system is installed.
    //
    //  (guhans)  Don't align down if this is ASR.  ASR already takes this into account.
    //
    if( !DockableMachine && !SpDrEnabled() &&
        ((*AlignedEndSector) > ((Disk->CylinderCount - 1) * Disk->SectorsPerCylinder))) {
            (*AlignedEndSector) -= Disk->SectorsPerCylinder;
            
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                "SETUP: End of partition was aligned down 1 cylinder \n"));
                
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                "SETUP:     AlignedStartSector = %I64x \n", AlignedStartSector));
                
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                "SETUP:     AlignedEndSector   = %I64x \n", AlignedEndSector));
                
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                "SETUP:     SectorsPerCylinder = %lx \n", Disk->SectorsPerCylinder));
                
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                "SETUP:     CylinderCount = %lx \n", Disk->CylinderCount));
    }

    ASSERT((*AlignedEndSector) > 0);

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
            "SETUP:SpPtnAlignPartitionStartAndEnd:S/C:%d,Size:%I64d,"
            "StartSector:%I64d,RSS:%I64d,FE:%d,AS:%I64d,AE:%I64d\n"
            "LeftOverSectors:%I64d\n",            
            Disk->SectorsPerCylinder,
            SizeMB,
            StartSector,
            Region->StartSector,
            ForExtended,
            *AlignedStartSector,
            *AlignedEndSector,
            LeftOverSectors));            
}



BOOLEAN
SpPtnCreateLogicalDrive(
    IN  ULONG         DiskNumber,
    IN  ULONGLONG     StartSector,
    IN  ULONGLONG     SizeInSectors,    // Used ONLY in the ASR case
    IN  BOOLEAN       ForNT,    
    IN  BOOLEAN       AlignToCylinder,
    IN  ULONGLONG     DesiredMB OPTIONAL,
    IN  PPARTITION_INFORMATION_EX PartInfo OPTIONAL,
    OUT PDISK_REGION *ActualDiskRegion OPTIONAL
    )
/*++

Routine Description:

    Creates logical drive.

    To create a logical drive we need to create the
    logical drive's container partition also first.


    Algorithm:

    if (first logical drive) {
        1.  create an extended partition encompassing the
            whole free space in region        
        2.  create a logical drive at one track offset
            from the extened partition of the required size
    } else {
        1.  create an extended partition encompassing the 
            given space
        2.  create a logical drive of the maximim size
            inside the created extended partition
    }
    
Arguments:

    DiskNumber  -   Disk on which logical drive nedds to be
                    created.

    StartSector -   The starting sector for the region, which
                    will contain the container & logical drive

    ForNT       -   Indicating whether to use the given 
                    Desired Size or not

    AlignToCylinder - Indicating whether the partition should
                    be aligned on a cylinder boundary (Usually set 
                    to TRUE, except in a few specific ASR cases).


    PartInfo    -   Partition Information which needs to be
                    used while creating the partition (like
                    Partition Type on MBR disks and GUID
                    for Partition Id on GPT disks)

    ActualDiskRegion    -   Place holder for returning, the
                            region which indicates the new
                            partition in memory

Return Value:

    TRUE is successful otherwise FALSE.

--*/        
{
    BOOLEAN         Result = FALSE;
    NTSTATUS        Status;
    NTSTATUS        InitStatus;
    UCHAR           PartitionType = 0;
    ULONG           Primary = 0, Container = 0, Logical = 0;
    BOOLEAN         FirstLogical = FALSE;
    BOOLEAN         ReservedRegion = FALSE;
    BOOLEAN         CreateContainer = TRUE;
    BOOLEAN         Beyond1024;
    BOOLEAN         FreeRegions = FALSE;
    ULONGLONG       MinMB = 0, MaxMB = 0, SizeMB = 0;
    ULONGLONG       LogicalSize = 0;
    ULONGLONG       CylinderMB = 0;
    PDISK_REGION    Region;
    ULONGLONG       SectorCount, LeftOverSectors;    
    ULONGLONG       AlignedStartSector, AlignedEndSector;
    ULONGLONG       LogicalStartSector, LogicalEndSector;
    
    PHARD_DISK          Disk = SPPT_GET_HARDDISK(DiskNumber);
    PPARTITIONED_DISK   PartDisk = SPPT_GET_PARTITIONED_DISK(DiskNumber);
    PDISK_REGION        NewContainer = NULL, NewLogical = NULL;

    //
    // get hold of the region
    //
    Region = SpPtLookupRegionByStart(PartDisk, FALSE, StartSector);

    if (!Region)
        return Result;

    //
    // should be free
    //
    ASSERT(SPPT_IS_REGION_PARTITIONED(Region) == FALSE);              

    //
    // get the various partition type count on the disk
    //
    SpPtnGetPartitionTypeCounts(DiskNumber, 
                            TRUE, 
                            &Primary, 
                            &Container, 
                            &Logical,
                            NULL,
                            NULL);

    //
    // first logical indicates, what we will be creating the first
    // container partition which will consume the whole free space
    // available
    //
    FirstLogical = !(Logical || Container);

    //
    // Some times there might be just an extended partition and we
    // might be creating the partition in the starting free space inside
    // this extended partition. For this case we want to make sure that 
    // we don't create another container partition
    //
    if (!FirstLogical && SPPT_IS_REGION_NEXT_TO_FIRST_CONTAINER(Region)) {        
        CreateContainer = FALSE;
    }        

    //
    // Create an extened partition
    //
    SpPtQueryMinMaxCreationSizeMB(DiskNumber,
                                Region->StartSector,
                                CreateContainer,
                                !CreateContainer,
                                &MinMB,
                                &MaxMB,
                                &ReservedRegion
                                );

    if (ReservedRegion) {
        ULONG ValidKeys[2] = {ASCI_CR , 0};

        SpStartScreen(
            SP_SCRN_REGION_RESERVED,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE
            );

        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_ENTER_EQUALS_CONTINUE,
                    0);
                    
        SpWaitValidKey(ValidKeys, NULL, NULL);
        
        return FALSE;
    }
             
    if (ForNT) {
        //
        // If a size was requested then try to use that, otherwise use
        // the maximum.
        //
        if (DesiredMB) {
            if (DesiredMB <= MaxMB) {
                SizeMB = DesiredMB;
            } else {
                return FALSE;   // don't have the space user requested
            }
        } else {
            SizeMB = MaxMB;
        }
    } else {            
        if (SpPtnGetSizeFromUser(Disk, MinMB, MaxMB, &SizeMB)) {
            DesiredMB = SizeMB;
        } else {
            return FALSE;   // user didn't want to proceed
        }            

        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, 
                SP_STAT_PLEASE_WAIT,
                0);        
    }

    //
    // get the aligned start and end sector for exteneded/logical partition
    //
    if (AlignToCylinder) {
        SpPtnAlignPartitionStartAndEnd(Disk,
                                FirstLogical ? MaxMB : SizeMB,
                                StartSector,
                                Region,
                                CreateContainer,
                                &AlignedStartSector,
                                &AlignedEndSector); 
    }
    else {
        AlignedStartSector = StartSector;

        if (SpDrEnabled()) {
            AlignedEndSector = StartSector + SizeInSectors;

        }
        else {
            AlignedEndSector = StartSector + 
                (SizeMB * ((1024 * 1024) / Disk->Geometry.BytesPerSector));
        }
    }


    if (CreateContainer) {
        //
        // Logical drive start is always at 1 track offset from extended start
        //
        LogicalStartSector = AlignedStartSector + SPPT_DISK_TRACK_SIZE(DiskNumber);

        if (FirstLogical) {
            ULONGLONG   SectorCount = (SizeMB * 1024 * 1024) / SPPT_DISK_SECTOR_SIZE(DiskNumber);
            ULONGLONG   Remainder = 0;
            if (SpDrEnabled()) {
                SectorCount = SizeInSectors;
            }
            
            LogicalEndSector = LogicalStartSector + SectorCount;
            if (AlignToCylinder) {
                Remainder = LogicalEndSector % SPPT_DISK_CYLINDER_SIZE(DiskNumber);
                LogicalEndSector -= Remainder;

                if (Remainder > (SPPT_DISK_CYLINDER_SIZE(DiskNumber) / 2))
                    LogicalEndSector += SPPT_DISK_CYLINDER_SIZE(DiskNumber);
            }

            if (LogicalEndSector > AlignedEndSector)
                LogicalEndSector = AlignedEndSector;
        } else {
            LogicalEndSector = AlignedEndSector;
        }
    } else {
        //
        // The first free region (inside first extended) is at the offset 
        // of 1 sector from the previous exteneded region. Since we are not 
        // using the aligned start sector some times this first logical 
        // will be greater than the requested size i.e. 
        // end is aligned but start may not be aligned
        //
        LogicalStartSector = StartSector - 1 + SPPT_DISK_TRACK_SIZE(DiskNumber);
        LogicalEndSector = AlignedEndSector;
    }

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
            "SETUP:SpPtnCreateLogicalDrive():"
            "CMB:%I64d,CS:%I64d,CE:%I64d,LS:%I64d,LE:%I64d\n",
            CylinderMB,                
            AlignedStartSector,
            AlignedEndSector,
            LogicalStartSector,
            LogicalEndSector));

    //
    // allocate the new regions
    //
    if (CreateContainer) {
        //
        // allocate the container region
        //
        NewContainer = (PDISK_REGION)SpMemAlloc(sizeof(DISK_REGION));

        if (!NewContainer)
            return FALSE;
            
        RtlZeroMemory(NewContainer, sizeof(DISK_REGION));
    }

    //
    // allocate the logical drive region
    //
    NewLogical = (PDISK_REGION)SpMemAlloc(sizeof(DISK_REGION));

    if (!NewLogical) {
        SpMemFree(NewContainer);

        return FALSE;
    }

    RtlZeroMemory(NewLogical, sizeof(DISK_REGION));

    //
    // put the new regions in the list
    //
    if (CreateContainer) {    
        NewContainer->Next = NewLogical;
        NewLogical->Next = Region->Next;
        Region->Next = NewContainer;
    } else {
        //
        // This is the first logical inside the
        // already existing extended partition 
        //
        ASSERT(Region->Container->Next == Region);
        
        NewLogical->Next = Region->Next;
        Region->Container->Next = NewLogical;
    }

    //
    // fill the container disk region.
    //
    if (CreateContainer) {
        ASSERT(AlignedStartSector < AlignedEndSector);
        
        NewContainer->DiskNumber = DiskNumber;
        NewContainer->StartSector = AlignedStartSector;
        NewContainer->SectorCount = AlignedEndSector - AlignedStartSector;

        if (!FirstLogical) {
            PDISK_REGION    FirstContainer = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);

            while (FirstContainer && !SPPT_IS_REGION_FIRST_CONTAINER_PARTITION(FirstContainer))
                FirstContainer = FirstContainer->Next;

            ASSERT(FirstContainer);
            
            NewContainer->Container = FirstContainer;
        }

        SPPT_SET_REGION_PARTITIONED(NewContainer, FALSE);
        SPPT_SET_REGION_DIRTY(NewContainer, TRUE);
        SPPT_SET_REGION_EPT(NewContainer, EPTContainerPartition);

        NewContainer->FreeSpaceKB = (ULONG)(-1);
        NewContainer->AdjustedFreeSpaceKB = (ULONG)(-1);    

        Beyond1024 = SpIsRegionBeyondCylinder1024(NewContainer);

        //
        // Only mark the first extended (container) partition as XINT13_EXTENDED
        // if beyond 1024 cylinders, for backward compatability with Win9x
        //
        PartitionType = (Beyond1024 && FirstLogical) ? PARTITION_XINT13_EXTENDED : PARTITION_EXTENDED;    
        SPPT_SET_PARTITION_TYPE(NewContainer, PartitionType);
    }        

    //
    // fill in the logical disk region
    //    
    ASSERT(LogicalStartSector < LogicalEndSector);

    if (CreateContainer) {        
        ASSERT((AlignedStartSector + SPPT_DISK_TRACK_SIZE(DiskNumber)) == LogicalStartSector);
    
        if (LogicalStartSector != (AlignedStartSector + SPPT_DISK_TRACK_SIZE(DiskNumber))) {
            LogicalStartSector = AlignedStartSector + SPPT_DISK_TRACK_SIZE(DiskNumber);
        }
    }        
    
    ASSERT(LogicalEndSector <= AlignedEndSector);

    if (LogicalEndSector > AlignedEndSector) {
        LogicalEndSector = AlignedEndSector;
    }        
        
    NewLogical->DiskNumber = DiskNumber;
    NewLogical->StartSector = LogicalStartSector;
    NewLogical->SectorCount = LogicalEndSector - LogicalStartSector;

    if (CreateContainer) {
        NewLogical->Container = NewContainer;   // the new logical drive's container !!!
    } else {
        ASSERT(Region->Container);
        
        NewLogical->Container = Region->Container;
    }        

    SPPT_SET_REGION_PARTITIONED(NewLogical, TRUE);
    SPPT_SET_REGION_DIRTY(NewLogical, TRUE);
    SPPT_SET_REGION_EPT(NewLogical, EPTLogicalDrive);

    NewLogical->FreeSpaceKB = (ULONG)(-1);
    NewLogical->AdjustedFreeSpaceKB = (ULONG)(-1);    

    Beyond1024 = SpIsRegionBeyondCylinder1024(NewLogical);
    PartitionType = Beyond1024 ? PARTITION_XINT13 : PARTITION_HUGE;    

    //
    // If the argument is specified and is valid partition type
    // then use that making the assumption the caller knows exactly
    // what he wants
    //
    if (ARGUMENT_PRESENT(PartInfo) && !IsContainerPartition(PartInfo->Mbr.PartitionType)) {
        PartitionType = PartInfo->Mbr.PartitionType;
    }        
        
    SPPT_SET_PARTITION_TYPE(NewLogical, PartitionType);    
    NewLogical->Filesystem = FilesystemNewlyCreated;    // to zap boot sector
                   
    SpFormatMessage(Region->TypeName, 
                sizeof(Region->TypeName),
                SP_TEXT_FS_NAME_BASE + Region->Filesystem);
                    
    //
    // commit to the disk
    //
    Status = SpPtnCommitChanges(DiskNumber, &Result);

    if (!(NT_SUCCESS(Status) && Result)) {                
        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
            "SETUP: SpPtnDelete(%u, %I64u) failed to commit changes (%lx)\n",
            DiskNumber, 
            StartSector, 
            Status));
    }

    Result = Result && NT_SUCCESS(Status);

    //
    // Reinitialize irrespective of commit's status
    //
    InitStatus = SpPtnInitializeDiskDrive(DiskNumber);
    
    if (!NT_SUCCESS(InitStatus)) {
        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
            "SETUP: SpPtnCreateLogicalDrive(%u, %I64u) failed to reinit regions\n", 
            DiskNumber, 
            StartSector));

        Result = FALSE;
    }

    if (Result && ARGUMENT_PRESENT(ActualDiskRegion)) {
        *ActualDiskRegion = SpPtLookupRegionByStart(PartDisk, 
                                                    FALSE, 
                                                    LogicalStartSector);
            
        //SpPtDumpDiskRegion(*ActualDiskRegion);                                                    
    }


    //
    // We don't need to free the regions which we allocated above
    // as the above commit and init would have done that already
    //
    
    return Result;
}

BOOLEAN
SpPtnCreate(
    IN  ULONG         DiskNumber,
    IN  ULONGLONG     StartSector,
    IN  ULONGLONG     SizeInSectors,    // Used ONLY in the ASR case
    IN  ULONGLONG     SizeMB,
    IN  BOOLEAN       InExtended,
    IN  BOOLEAN       AlignToCylinder,
    IN  PPARTITION_INFORMATION_EX PartInfo,
    OUT PDISK_REGION *ActualDiskRegion OPTIONAL
    )
/*++

Routine Description:

    Creates a primary partition of the requested size on the
    given disk (either MBR/GPT).
    
Arguments:

    DiskNumber  :   Disk on which the partition needs to be
                    created

    StartSector :   Start sector of the region, which represents
                    the free space in which the partition needs
                    to be created

    SizeMB      :   The size of the partition

    InExtended  :   Whether to create an logical drive
                    or not (currently NOT USED except in the ASR case)

    AlignToCylinder : Indicating whether the partition should
                    be aligned on a cylinder boundary (Usually set 
                    to TRUE, except in a few specific ASR cases).

    PartInfo    :   Partition attributes to use                    

    ActualDiskRegion    :   Place holder for the actual disk
                            region which will represent the created
                            partition                    

Return Value:

    TRUE if successful, otherwise FALSE

--*/        
{
    BOOLEAN             Result = FALSE;
    PDISK_REGION        Region;
    ULONGLONG           SectorCount, AlignedStartSector;
    ULONGLONG           AlignedEndSector, LeftOverSectors;
    PPARTITIONED_DISK   PartDisk = SPPT_GET_PARTITIONED_DISK(DiskNumber);
    PHARD_DISK          Disk = SPPT_GET_HARDDISK(DiskNumber);
    PDISK_REGION        PrevRegion;
    PDISK_REGION        NewRegion = NULL;
    NTSTATUS            Status;
    NTSTATUS            InitStatus;
    BOOLEAN             FirstLogical = TRUE;

    //
    // Verify that the optional attributes specified
    // are correct
    //
    if (PartInfo) {
        if ((SPPT_IS_MBR_DISK(DiskNumber) && 
             (PartInfo->PartitionStyle != PARTITION_STYLE_MBR)) ||
            (SPPT_IS_GPT_DISK(DiskNumber) &&
             (PartInfo->PartitionStyle != PARTITION_STYLE_GPT))) {

            return FALSE;
        }            
    }
    
    Region = SpPtLookupRegionByStart(PartDisk, FALSE, StartSector);

    if (!Region)
        return Result;
                       
    ASSERT(SPPT_IS_REGION_PARTITIONED(Region) == FALSE);            

    SpPtDumpDiskRegion(Region);

    //
    // Determine the number of sectors in the size passed in.
    //
    if (SpDrEnabled()) {
        SectorCount = SizeInSectors;
    }
    else {
        SectorCount = SizeMB * ((1024 * 1024) / Disk->Geometry.BytesPerSector);
    }
    

    //
    // Align the start sector.
    //
    if (AlignToCylinder){
        if (!SpDrEnabled()) {
            AlignedStartSector = SpPtAlignStart(Disk, StartSector, FALSE);
        }
        else {
            AlignedStartSector = SpPtAlignStart(Disk, StartSector, InExtended);
        }
    }
    else {
        AlignedStartSector = StartSector;
    }

    //
    // Determine the end sector based on the size passed in.
    //
    AlignedEndSector = AlignedStartSector + SectorCount;

    //
    // Align the ending sector to a cylinder boundary.  If it is not already
    // aligned and is more than half way into the final cylinder, align it up,
    // otherwise align it down.
    //
    if (AlignToCylinder) {
        LeftOverSectors = AlignedEndSector % Disk->SectorsPerCylinder;

        if (LeftOverSectors) {
            AlignedEndSector -= LeftOverSectors;
        
            if (LeftOverSectors > (Disk->SectorsPerCylinder / 2)) {
                AlignedEndSector += Disk->SectorsPerCylinder;
            }
        }

    }
    
    //
    // If the ending sector is past the end of the free space, shrink it
    // so it fits.
    //
    while(AlignedEndSector > Region->StartSector + Region->SectorCount) {
        AlignedEndSector -= Disk->SectorsPerCylinder;
    }

    //
    //  Find out if last sector is in the last cylinder. If it is then align it down.
    //  This is necessary so that we reserve a cylinder at the end of the disk, so that users
    //  can convert the disk to dynamic after the system is installed.
    //
    //  (guhans)  Don't align down if this is ASR.  ASR already takes this into account.
    //
    if( !DockableMachine && !SpDrEnabled() && SPPT_IS_MBR_DISK(DiskNumber) &&
        (AlignedEndSector > ((Disk->CylinderCount - 1) * Disk->SectorsPerCylinder))) {
            AlignedEndSector -= Disk->SectorsPerCylinder;
            
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                "SETUP: End of partition was aligned down 1 cylinder \n"));
                
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                "SETUP:     AlignedStartSector = %I64x \n", AlignedStartSector));
                
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                "SETUP:     AlignedEndSector   = %I64x \n", AlignedEndSector));
                
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                "SETUP:     SectorsPerCylinder = %lx \n", Disk->SectorsPerCylinder));
                
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                "SETUP:     CylinderCount = %lx \n", Disk->CylinderCount));
    }

    ASSERT(AlignedEndSector > 0);

    //
    // Find the previous region 
    //
    PrevRegion = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);

    if(PrevRegion == Region) {
        PrevRegion = NULL;
    } else {
        while (PrevRegion) {
            if(PrevRegion->Next == Region) {                
                break;
            }

            PrevRegion = PrevRegion->Next;
        }
    }
    
    //
    // Create a new disk region for the new free space at the
    // beginning and end of the free space, if any.
    //
    if(AlignedStartSector - Region->StartSector) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
            "SETUP:SpPtnCreate():Previous:OS:%I64d,AS:%I64d,DIFF:%I64d,S/P:%d\n",
            Region->StartSector,
            AlignedStartSector,
            (ULONGLONG)(AlignedStartSector - Region->StartSector),
            Disk->SectorsPerCylinder));
            
        NewRegion = SpPtAllocateDiskRegionStructure(
                        DiskNumber,
                        Region->StartSector,
                        AlignedStartSector - Region->StartSector,
                        FALSE,
                        NULL,
                        0
                        );

        ASSERT(NewRegion);

        if(PrevRegion) {
            PrevRegion->Next = NewRegion;
        } else {
            ASSERT(Region == SPPT_GET_PRIMARY_DISK_REGION(DiskNumber));
            
            PartDisk->PrimaryDiskRegions = NewRegion;
        }

        NewRegion->Next = Region;
    }

    if(Region->StartSector + Region->SectorCount - AlignedEndSector) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
            "SETUP:SpPtnCreate():Next:OE:%I64d,AE:%I64d,DIFF:%I64d,S/P:%d\n",
            (ULONGLONG)(Region->StartSector + Region->SectorCount),
            AlignedEndSector,
            (ULONGLONG)(Region->StartSector + Region->SectorCount - AlignedEndSector),
            Disk->SectorsPerCylinder));
            
        NewRegion = SpPtAllocateDiskRegionStructure(
                        DiskNumber,
                        AlignedEndSector,
                        Region->StartSector + Region->SectorCount - 
                            AlignedEndSector,
                        FALSE,
                        NULL,
                        0
                        );

        NewRegion->Next = Region->Next;
        Region->Next = NewRegion;
    }

    //
    // fill the current disk region.
    //
    Region->DiskNumber = DiskNumber;
    Region->StartSector = AlignedStartSector;
    Region->SectorCount = AlignedEndSector - AlignedStartSector;
    SPPT_SET_REGION_PARTITIONED(Region, TRUE);
    SPPT_SET_REGION_DIRTY(Region, TRUE);
    Region->VolumeLabel[0] = 0;
    Region->Filesystem = FilesystemNewlyCreated;                    
    Region->FreeSpaceKB = (ULONG)(-1);
    Region->AdjustedFreeSpaceKB = (ULONG)(-1);

    //
    // Set the passed in partition information
    //
    if (PartInfo) {
        SpPtnSetRegionPartitionInfo(Region, PartInfo);
    }        
                
    SpFormatMessage(Region->TypeName, 
                sizeof(Region->TypeName),
                SP_TEXT_FS_NAME_BASE + Region->Filesystem);
                
    //
    // commit to the disk
    //
    Status = SpPtnCommitChanges(DiskNumber, &Result);   

    if (!(Result && NT_SUCCESS(Status))) {
        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
            "SETUP: SpPtnCreate(%u, %I64u) failed to commit changes to"
            "the drive (%lx)\n",
            DiskNumber, 
            StartSector, 
            Status));
    }
    
    Result = Result && NT_SUCCESS(Status);

    //
    // Reinitialize irrespective of commit's status
    //
    InitStatus = SpPtnInitializeDiskDrive(DiskNumber);

    if (!NT_SUCCESS(InitStatus)){
        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
            "SETUP: SpPtnCreate(%u, %I64u) failed to reinitialize regions\n", 
            DiskNumber, 
            StartSector));

        Result = FALSE;            
    }

    if (Result && ARGUMENT_PRESENT(ActualDiskRegion)) {
        *ActualDiskRegion = SpPtLookupRegionByStart(PartDisk, 
                                                    FALSE, 
                                                    AlignedStartSector);                                                    
    }
    
    return Result;
}


BOOLEAN
SpPtnDoCreate(
    IN  PDISK_REGION  Region,
    OUT PDISK_REGION  *ActualRegion, OPTIONAL
    IN  BOOLEAN       ForNT,
    IN  ULONGLONG     DesiredMB OPTIONAL,
    IN  PPARTITION_INFORMATION_EX PartInfo OPTIONAL,
    IN  BOOLEAN       ConfirmIt
    )
/*++

Routine Description:

    Given the region which was selected by the user,
    this routine creates the appropriate partition in
    it.

    This routine decides whether to create a primary or
    container partition on MBR disks.


    Algorithm:

    if (RemoveableMedia && already partition exists) {
        1.  put up a warning for the user
        2.  return with error
    }
    
    if ((MBR disk) && ((there is no space for primary partition) ||
            (region is in a container space)){
        1.  create a logical drive using SpPtnCreateLogicalDrive()    
    } else {    
        1. align the start sector.
        2. create the required GPT/MBR partition.
    }                
       
Arguments:

    Region  -   The region representing the free space on disk
                where the partition needs to be created.

    ActualRegion    - Place holder, for the region which will
                        represent the actual partition after
                        creating it.

    ForNT       -   Indicates whether to use the given desired size
                    argument or not.                    

    DesiredSize -   The size of the partition to created

    PartInfo    -   The partition attributes to use while creating
                    the new partition

    ConfirmIt   -   Whether to pop up error dialogs, if something
                    goes wrong while creating the partition

Return Value:

    TRUE if successful otherwise FALSE

--*/        
{
    BOOLEAN     Result = FALSE;
    ULONG       DiskNumber = Region->DiskNumber;
    ULONGLONG   MinMB = 0, MaxMB = 0;
    ULONGLONG   SizeMB = 0;
    BOOLEAN     ReservedRegion = FALSE;
    PHARD_DISK  Disk = SPPT_GET_HARDDISK(DiskNumber);    
    

    if (SPPT_IS_MBR_DISK(DiskNumber)) {
        ULONG   PrimaryCount = 0;
        ULONG   ContainerCount = 0;
        ULONG   LogicalCount = 0;
        ULONG   ValidPrimaryCount = 0;
        BOOLEAN InContainer = FALSE;
        BOOLEAN FirstContainer = FALSE;

        SpPtnGetPartitionTypeCounts(DiskNumber, 
                            TRUE,
                            &PrimaryCount, 
                            &ContainerCount, 
                            &LogicalCount,
                            &ValidPrimaryCount,
                            NULL);

   
        //
        // Create a logical drive if we have a valid primary
        // or there is no more space for another primary
        // and the number of primary partitions do not exceed
        // the partition table size (Partition Table not full)
        //
        FirstContainer =((ContainerCount == 0) && 
                         (ValidPrimaryCount > 0) && 
                         (PrimaryCount < PTABLE_DIMENSION));                             

        InContainer = (Region->Container != NULL);                            

        //
        // We allow only one partition on the removable media (?)
        //
        if (SPPT_IS_REMOVABLE_DISK(DiskNumber)) {
            if (PrimaryCount || ContainerCount || LogicalCount) {
                ULONG ValidKeys[2] = { ASCI_CR ,0 };

                //
                // Disk is already partitioned
                //
                SpDisplayScreen(SP_SCRN_REMOVABLE_ALREADY_PARTITIONED,
                                3,
                                HEADER_HEIGHT + 1);
                                
                SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
                                SP_STAT_ENTER_EQUALS_CONTINUE,
                                0);
                                
                SpWaitValidKey(ValidKeys, NULL, NULL);
                
                return  FALSE;
            }
        } else {
            if (FirstContainer || InContainer) {
                //
                // create the logical drive
                //
                Result = SpPtnCreateLogicalDrive(DiskNumber,
                                Region->StartSector,
                                0,          // SizeInSectors: used only in the ASR case
                                ForNT,
                                TRUE,       // AlignToCylinder
                                DesiredMB,
                                PartInfo,
                                ActualRegion);

                if (!Result) {
                    KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                        "SETUP: SpPtnCreateLogicalDrive() failed\n"));            
                }


                return Result;
            }     

            //
            // check to see if there is no space in the partition table
            //
            if (PrimaryCount >= (PTABLE_DIMENSION - 1)) {                            
                //
                // Let the user know that the partition table is full
                //
                if (ConfirmIt) {
                    while (TRUE) {
                        ULONG Keys[2] = {ASCI_CR, 0};

                        SpDisplayScreen(SP_SCRN_PART_TABLE_FULL,
                                        3,
                                        CLIENT_TOP + 1);

                        SpDisplayStatusOptions(
                            DEFAULT_STATUS_ATTRIBUTE,
                            SP_STAT_ENTER_EQUALS_CONTINUE,
                            0
                            );

                        if (SpWaitValidKey(Keys, NULL, NULL) == ASCI_CR)
                            return  FALSE;
                    }
                } else {
                    return TRUE;
                }
            }                
        }            
    } 

    //
    // need to create the primary / GPT partition
    //
    SpPtQueryMinMaxCreationSizeMB(DiskNumber,
                                Region->StartSector,
                                FALSE,
                                TRUE,
                                &MinMB,
                                &MaxMB,
                                &ReservedRegion
                                );

    if (ReservedRegion) {
        ULONG ValidKeys[2] = {ASCI_CR , 0};

        SpStartScreen(
            SP_SCRN_REGION_RESERVED,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE
            );

        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_ENTER_EQUALS_CONTINUE,
                    0);
                    
        SpWaitValidKey(ValidKeys, NULL, NULL);
        
        return FALSE;
    }

    if (ForNT) {
        //
        // If a size was requested then try to use that, otherwise use
        // the maximum.
        //
        if (DesiredMB) {
            if (DesiredMB <= MaxMB) {
                SizeMB = DesiredMB;
            } else {
                return FALSE;   // don't have the space user requested
            }
        } else {
            SizeMB = MaxMB;
        }
    } else {
        if (!SpPtnGetSizeFromUser(Disk, MinMB, MaxMB, &SizeMB))
            return FALSE;   // user didn't want to proceed

        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, 
                SP_STAT_PLEASE_WAIT,
                0);
    }

    //SpPtDumpDiskRegionInformation(DiskNumber, FALSE);
    
    //
    // Create the partition.
    //
    Result = SpPtnCreate(
                Region->DiskNumber,
                Region->StartSector,
                0,          // SizeInSectors: used only in the ASR case
                SizeMB,
                FALSE,
                TRUE,       // AlignToCylinder
                PartInfo,
                ActualRegion
                );
                            
    //SpPtDumpDiskRegionInformation(DiskNumber, FALSE);

    if (!Result) {
        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
            "SETUP: SpPtnCreate() failed \n"));
    }
    
    return Result;
}

    
BOOLEAN
SpPtnDoDelete(
    IN PDISK_REGION pRegion,
    IN PWSTR        RegionDescription,
    IN BOOLEAN      ConfirmIt
    )
/*++

Routine Description:

    Given the region which was selected by the user,
    this routine prompts the user then calls the
    actual deletion routine

Argument:
    pRegion -   Region selected by the user which
                needs to be deleted

    RegionDescription   -   Description of the
                            region

    ConfirmIt   -   Whether the deletion needs to be
                    confirmed
                    
Return Value:

    TRUE if deletion was carried out and was successful.
    
    FALSE if deletion was cancelled or could not be carried
    out because of some other error.
    
++*/                    

{
    ULONG ValidKeys[3] = { ASCI_ESC, ASCI_CR, 0 };          // do not change order
    ULONG Mnemonics[2] = { MnemonicDeletePartition2, 0 };    
    PHARD_DISK  Disk;
    ULONG Key;
    BOOLEAN Result = FALSE;


    //
    // Prompt for MSR deletion
    //
    if (SPPT_IS_GPT_DISK(pRegion->DiskNumber) &&
        SPPT_IS_REGION_MSFT_RESERVED(pRegion) && ConfirmIt) {

        SpDisplayScreen(SP_SCRN_CONFIRM_REMOVE_MSRPART, 3, HEADER_HEIGHT+1);

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            SP_STAT_ESC_EQUALS_CANCEL,
            0
            );

        if(SpWaitValidKey(ValidKeys,NULL,NULL) == ASCI_ESC) {
            return Result;
        }        
    }

    //
    // Special warning if this is a system partition.
    //
    // Do not check system partition on NEC98.
    //
    if (!IsNEC_98) { //NEC98
        if(ConfirmIt && pRegion->IsSystemPartition) {

            SpDisplayScreen(SP_SCRN_CONFIRM_REMOVE_SYSPART,3,HEADER_HEIGHT+1);

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_ENTER_EQUALS_CONTINUE,
                SP_STAT_ESC_EQUALS_CANCEL,
                0
                );

            if(SpWaitValidKey(ValidKeys,NULL,NULL) == ASCI_ESC) {
                return Result;
            }
        }
    } //NEC98

    if(ConfirmIt && (pRegion->DynamicVolume || SPPT_IS_REGION_LDM_METADATA(pRegion))) {

        SpDisplayScreen(SP_SCRN_CONFIRM_REMOVE_DYNVOL,3,HEADER_HEIGHT+1);

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            SP_STAT_ESC_EQUALS_CANCEL,
            0
            );

        if(SpWaitValidKey(ValidKeys,NULL,NULL) == ASCI_ESC) {
            return Result;
        }
    }

    //
    // CR is no longer a valid key.
    //
    ValidKeys[1] = 0;

    //
    // Display the staus text.
    //
    if (ConfirmIt) {
        Disk = SPPT_GET_HARDDISK(pRegion->DiskNumber);
        
        SpStartScreen(
            SP_SCRN_CONFIRM_REMOVE_PARTITION,
            3,
            CLIENT_TOP+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            RegionDescription,
            Disk->Description
            );
            
        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_L_EQUALS_DELETE,
            SP_STAT_ESC_EQUALS_CANCEL,
            0
            );

        Key = SpWaitValidKey(ValidKeys,NULL,Mnemonics);

        if(Key == ASCI_ESC) {
            return Result;
        }

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_PLEASE_WAIT,
            0);        
    }

    //
    // Delete the bootset, if any, for the region
    //
    SpPtDeleteBootSetsForRegion(pRegion);

    //
    // Now go ahead and delete it.
    //
    Result = SpPtDelete(pRegion->DiskNumber,pRegion->StartSector);
    
    if (!Result) {
        if (ConfirmIt) {
            SpDisplayScreen(SP_SCRN_PARTITION_DELETE_FAILED,3,HEADER_HEIGHT+1);
            SpDisplayStatusText(SP_STAT_ENTER_EQUALS_CONTINUE,DEFAULT_STATUS_ATTRIBUTE);
            SpInputDrain();
            
            while(SpInputGetKeypress() != ASCI_CR) ;
        }
        
        return Result;
    }


    //
    //  Delete the drive letters if the necessary. This is to ensure that 
    //  the drive letters assigned to CD-ROM drives will go away, 
    //  when the the disks have no partitioned space.
    //
    SpPtDeleteDriveLetters();

    return Result;
}

VOID
SpPtnMakeRegionActive(
    IN PDISK_REGION Region
    )
/*++

Routine Description:

    Makes the given region active (i.e. converts into system partition).
    Is valid only for MBR disks. Makes all the other regions
    inactive on the disk
    
Arguments:

    Region  -   The region (primary partition) which needs to made
                active.

Return Value:

    None.

--*/        
{
    static BOOLEAN WarnedOtherOS = FALSE;
    
    if (Region && SPPT_IS_REGION_PRIMARY_PARTITION(Region)) {
        PDISK_REGION    CurrRegion = SPPT_GET_PRIMARY_DISK_REGION(Region->DiskNumber);

        while (CurrRegion) {            
            if ((Region != CurrRegion) && 
                SPPT_IS_REGION_ACTIVE_PARTITION(CurrRegion)) {
                 
                //
                // Give the warning for the first time
                //
                if (!WarnedOtherOS && !UnattendedOperation) {        
                    SpDisplayScreen((SPPT_GET_PARTITION_TYPE(CurrRegion) == 10) ? 
                                        SP_SCRN_BOOT_MANAGER : SP_SCRN_OTHER_OS_ACTIVE,
                                    3,
                                    HEADER_HEIGHT + 1);

                    SpDisplayStatusText(SP_STAT_ENTER_EQUALS_CONTINUE,
                            DEFAULT_STATUS_ATTRIBUTE);

                    SpInputDrain();

                    while (SpInputGetKeypress() != ASCI_CR) ;

                    WarnedOtherOS = TRUE;            
                }

                SPPT_MARK_REGION_AS_ACTIVE(CurrRegion, FALSE);
                SPPT_SET_REGION_DIRTY(CurrRegion, TRUE);
            }

            CurrRegion = CurrRegion->Next;
        }
        
        SPPT_MARK_REGION_AS_ACTIVE(Region, TRUE);
        SPPT_SET_REGION_DIRTY(Region, TRUE);        
    }                
}


BOOLEAN
SpPtMakeDiskRaw(
    IN ULONG DiskNumber
    )
/*++

Routine Description:

    Converts the given disk to RAW i.e. Zaps couple of first
    sectors which have information about the disk format
    
Arguments:

    DiskNumber  :   Disk Index, to converted into RAW

Return Value:

    TRUE, if successful, otherwise FALSE

--*/        
{
    BOOLEAN Result = FALSE;

    if (DiskNumber < HardDiskCount) {
        HANDLE      DiskHandle;
        NTSTATUS    Status;
        WCHAR       DiskName[256];

        swprintf(DiskName, L"\\Device\\Harddisk%u", DiskNumber);        

        //
        // Open partition 0 on this disk..
        //
        Status = SpOpenPartition0(DiskName, &DiskHandle, TRUE);

        if(NT_SUCCESS(Status)){
            PHARD_DISK  Disk = SPPT_GET_HARDDISK(DiskNumber);
            ULONG       BytesPerSector = Disk->Geometry.BytesPerSector;
            ULONG       BufferSize = (BytesPerSector * 2);
            PVOID       UBuffer = SpMemAlloc(BufferSize);    

            if (UBuffer) {
                PVOID Buffer = UBuffer;
                
                RtlZeroMemory(UBuffer, BufferSize);
                
                Buffer = ALIGN(Buffer, BytesPerSector);

                //
                // Wipe out 0'th sector
                //
                Status = SpReadWriteDiskSectors(DiskHandle,
                                0,
                                1,
                                BytesPerSector,
                                Buffer,
                                TRUE);


                if (NT_SUCCESS(Status)) {                                
                    //
                    // Wipe out 1st sector
                    //
                    Status = SpReadWriteDiskSectors(DiskHandle,
                                    1,
                                    1,
                                    BytesPerSector,
                                    Buffer,
                                    TRUE);
                                    
                    if (NT_SUCCESS(Status)) {                                
                        //
                        // Wipe out 2nd sector
                        //
                        Status = SpReadWriteDiskSectors(DiskHandle,
                                        2,
                                        1,
                                        BytesPerSector,
                                        Buffer,
                                        TRUE);
                    }                                                                                    
                }                    
            } else {
                Status = STATUS_NO_MEMORY;
            }

            ZwClose(DiskHandle);
        }            

        Result = NT_SUCCESS(Status);
    }


    if (Result) {
        SpPtnFreeDiskRegions(DiskNumber);
    }                

    return Result;
}


VOID
SpPtnDeletePartitionsForRemoteBoot(
    PPARTITIONED_DISK PartDisk,
    PDISK_REGION StartRegion,
    PDISK_REGION EndRegion,
    BOOLEAN Extended
    )
/*++

Routine Description:

    Deletes the specified start region and end region partitions
    and all the partitions in between them.
    
Arguments:

    PartDisk    :   The partitioned disk
    StartRegion :   The starting region for deletion
    EndRegion   :   The Ending region for deletion
    Extended    :   Not used (for backward compatability)

Return Value:

    None

--*/        
{
    PDISK_REGION    CurrRegion = StartRegion;
    BOOLEAN         FirstContainerDeleted = FALSE;
    ULONG           DiskNumber = StartRegion ? 
                        StartRegion->DiskNumber : EndRegion->DiskNumber;
    BOOLEAN         Changes = FALSE;                                
    NTSTATUS        Status;
    NTSTATUS        InitStatus;

    //
    // Mark all the regions which need to be deleted
    //
    while (CurrRegion && (CurrRegion != EndRegion)) {
        if (!SPPT_IS_REGION_FREESPACE(CurrRegion)) {
            SPPT_SET_REGION_DELETED(CurrRegion, TRUE);
            SPPT_SET_REGION_DIRTY(CurrRegion, TRUE);

            if (SPPT_IS_REGION_FIRST_CONTAINER_PARTITION(CurrRegion))
                FirstContainerDeleted = TRUE;
                
            //
            // Remove any boot sets pointing to this region.
            //
            SpPtDeleteBootSetsForRegion(CurrRegion);

            //
            //  Get rid of the compressed drives, if any
            //

            if( CurrRegion->NextCompressed != NULL ) {
                SpDisposeCompressedDrives( CurrRegion->NextCompressed );
                CurrRegion->NextCompressed = NULL;
                CurrRegion->MountDrive  = 0;
                CurrRegion->HostDrive  = 0;
            }
        }

        CurrRegion = CurrRegion->Next;
    }

    if (EndRegion && CurrRegion && (CurrRegion == EndRegion)){
        if (!SPPT_IS_REGION_FREESPACE(CurrRegion)) {
            SPPT_SET_REGION_DELETED(CurrRegion, TRUE);
            SPPT_SET_REGION_DIRTY(CurrRegion, TRUE);

            if (SPPT_IS_REGION_FIRST_CONTAINER_PARTITION(CurrRegion))
                FirstContainerDeleted = TRUE;

            //
            // Remove any boot sets pointing to this region.
            //
            SpPtDeleteBootSetsForRegion(CurrRegion);

            //
            //  Get rid of the compressed drives, if any
            //

            if( CurrRegion->NextCompressed != NULL ) {
                SpDisposeCompressedDrives( CurrRegion->NextCompressed );
                CurrRegion->NextCompressed = NULL;
                CurrRegion->MountDrive  = 0;
                CurrRegion->HostDrive  = 0;
            }
        }
    }            

    //
    // If the first container partition was deleted then delete
    // all the container and logical partitions,
    //
    if (FirstContainerDeleted) {
        CurrRegion = PartDisk->PrimaryDiskRegions;

        while (CurrRegion) {
            if (SPPT_IS_REGION_CONTAINER_PARTITION(CurrRegion) ||
                SPPT_IS_REGION_LOGICAL_DRIVE(CurrRegion)) {
                
                SPPT_SET_REGION_DELETED(CurrRegion, TRUE);
                SPPT_SET_REGION_DIRTY(CurrRegion, TRUE);                

                //
                // Remove any boot sets pointing to this region.
                //
                SpPtDeleteBootSetsForRegion(CurrRegion);

                //
                //  Get rid of the compressed drives, if any
                //

                if( CurrRegion->NextCompressed != NULL ) {
                    SpDisposeCompressedDrives( CurrRegion->NextCompressed );
                    CurrRegion->NextCompressed = NULL;
                    CurrRegion->MountDrive  = 0;
                    CurrRegion->HostDrive  = 0;
                }                
            }

            CurrRegion = CurrRegion->Next;
        }
    }

    //
    // Commit the changes
    //
    Status = SpPtnCommitChanges(DiskNumber, &Changes);

    //
    // Initialize region structure for the disk again
    //
    InitStatus = SpPtnInitializeDiskDrive(DiskNumber);

    if (!NT_SUCCESS(Status) || !Changes || !NT_SUCCESS(InitStatus)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
            "SETUP:SpPtnDeletePartitionsForRemoteBoot(%p, %p, %p, %d) failed "
            "with %lx status\n",
            PartDisk,
            StartRegion,
            EndRegion,
            Extended,
            Status));
    }
}


NTSTATUS
SpPtnMakeRegionArcSysPart(
    IN PDISK_REGION Region
    )
/*++

Routine Description:

    Makes the given region a system partition on ARC machines
    
Arguments:

    Region  -   The region which needs to be convered to system 
                partition

Return Value:

    STATUS_SUCCESS if successful, otherwise appropriate error
    code.

--*/        
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (Region && SpIsArc() && !ValidArcSystemPartition) {
        if (SPPT_IS_MBR_DISK(Region->DiskNumber)) {
            if (SPPT_IS_REGION_PRIMARY_PARTITION(Region)) {
                SpPtnMakeRegionActive(Region);    
                SPPT_MARK_REGION_AS_SYSTEMPARTITION(Region, TRUE);
                SPPT_SET_REGION_DIRTY(Region, TRUE);                
                Status = STATUS_SUCCESS;
            }                
        } else {
            WCHAR   RegionName[MAX_PATH];
            
            SPPT_MARK_REGION_AS_SYSTEMPARTITION(Region, TRUE);
            SPPT_SET_REGION_DIRTY(Region, TRUE);

            //
            // Remove the drive letter also
            //
            swprintf(RegionName, 
                L"\\Device\\Harddisk%u\\Partition%u",
                Region->DiskNumber,
                Region->PartitionNumber);
                
            SpDeleteDriveLetter(RegionName);            
            Region->DriveLetter = 0;
            
            Status = STATUS_SUCCESS;
        }
    }
    
    return Status;
}


ULONG
SpPtnCountPartitionsByFSType(
    IN ULONG DiskId,
    IN FilesystemType   FsType
    )
/*++

Routine Description:

    Counts the partition based on the file system type. 

    Note : The partitions which are marked 
           deleted are skipped.
    
Arguments:

    DiskId  :   The disk on which the partitions need to be
                counted

    FsType  :   File system type which needs to present on
                the partitions

Return Value:

    Number of partitions containing the requested file system

--*/        
{
    ULONG   Count = 0;

    if ((FsType < FilesystemMax) && (DiskId < HardDiskCount)) {
        PDISK_REGION    Region = SPPT_GET_PRIMARY_DISK_REGION(DiskId);

        while (Region) {
            if (SPPT_IS_REGION_PARTITIONED(Region) && 
                !SPPT_IS_REGION_MARKED_DELETE(Region) &&
                (Region->Filesystem == FsType)) {

                Count++;
            }           
            
            Region = Region->Next;
        }
    }
    
    return Count;
}


PDISK_REGION
SpPtnLocateESP(
    VOID
    )
{
    PDISK_REGION    EspRegion = NULL;
    ULONG Index;

    for (Index=0; (Index < HardDiskCount) && (!EspRegion); Index++) {
        if (SPPT_IS_GPT_DISK(Index)) {
            PDISK_REGION CurrRegion = SPPT_GET_PRIMARY_DISK_REGION(Index);

            while (CurrRegion) {
                if (SPPT_IS_REGION_PARTITIONED(CurrRegion) &&
                        SPPT_IS_REGION_EFI_SYSTEM_PARTITION(CurrRegion)) {
                    EspRegion = CurrRegion;

                    break;  // found the first ESP
                }                    

                CurrRegion = CurrRegion->Next;
            }
        }
    }

    return EspRegion;
}


NTSTATUS
SpPtnCreateESPForDisk(
    IN ULONG   DiskId
    )
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PDISK_REGION EspCandidateRegion = SPPT_GET_PRIMARY_DISK_REGION(DiskId);

    if (EspCandidateRegion && SpPtnIsValidESPRegion(EspCandidateRegion)) {        
        ULONG DiskId = EspCandidateRegion->DiskNumber;
        ULONGLONG   SizeMB = SpPtnGetDiskESPSizeMB(DiskId);
        PARTITION_INFORMATION_EX PartInfo;            
        PDISK_REGION EspRegion = NULL;
        BOOLEAN CreateResult;

        RtlZeroMemory(&PartInfo, sizeof(PARTITION_INFORMATION_EX));
        PartInfo.PartitionStyle = PARTITION_STYLE_GPT;
        PartInfo.Gpt.Attributes = 1;    // required ???
        PartInfo.Gpt.PartitionType = PARTITION_SYSTEM_GUID;
        SpCreateNewGuid(&(PartInfo.Gpt.PartitionId));
                
        CreateResult = SpPtnCreate(DiskId,
                            EspCandidateRegion->StartSector,
                            0,          // SizeInSectors: used only in the ASR case
                            SizeMB,
                            FALSE,
                            TRUE,
                            &PartInfo,
                            &EspRegion);
                    
                    
        if (CreateResult) {
            //
            // format this region
            //
            WCHAR   RegionDescr[128];
            
            //
            // Mark this region as ESP
            //
            SPPT_MARK_REGION_AS_SYSTEMPARTITION(EspRegion, TRUE);
            SPPT_SET_REGION_DIRTY(EspRegion, TRUE);
            ValidArcSystemPartition = TRUE;
            
            SpPtRegionDescription(
                SPPT_GET_PARTITIONED_DISK(EspRegion->DiskNumber),
                EspRegion,
                RegionDescr,
                sizeof(RegionDescr));

            if (!SetupSourceDevicePath || !DirectoryOnSetupSource) {                
                SpGetWinntParams(&SetupSourceDevicePath, &DirectoryOnSetupSource);                    
            }

            Status = SpDoFormat(RegionDescr,
                        EspRegion,
                        FilesystemFat,
                        TRUE,
                        TRUE,
                        FALSE,
                        SifHandle,
                        0,  // default cluster size
                        SetupSourceDevicePath,
                        DirectoryOnSetupSource);

            if (!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                    "SETUP:SpPtnCreateESP() failed to"
                    " format ESP partition for %p region (%lx)\n",
                    EspRegion,
                    Status));
            } else {
                BOOLEAN AnyChanges = FALSE;

                Status = SpPtnCommitChanges(EspRegion->DiskNumber,
                                &AnyChanges);   

                if (!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                        "SETUP:SpPtnCreateESP() failed to"
                        " commit changes to disk (%lx)\n",
                        Status));
                }                  
                
                Status = SpPtnInitializeDiskDrive(EspRegion->DiskNumber);

                if (!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                        "SETUP:SpPtnCreateESP() failed to"
                        " reinitialize disk regions (%lx)\n",
                        Status));
                }                                      
            }
        } else {
            Status = STATUS_UNSUCCESSFUL;
            
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                "SETUP:SpPtnCreateESP() failed to"
                " create ESP partition for %p region (%lx)\n",
                EspRegion,
                Status));
        }
    }                
    
    return Status;
}

NTSTATUS
SpPtnCreateESP(
    IN  BOOLEAN PromptUser
    )
{
    NTSTATUS Status = STATUS_CANCELLED;
    BOOLEAN Confirmed = FALSE;

    if (ValidArcSystemPartition) {
        Status = STATUS_SUCCESS;

        return Status;
    }

    if (UnattendedOperation) {
        Confirmed = TRUE;
    } else {
        if (PromptUser) {
            //
            // Prompt the user for confirmation
            //
            ULONG ValidKeys[] = { ASCI_CR, ASCI_ESC, 0 };
            ULONG UserOption = ASCI_CR;

            SpDisplayScreen(SP_AUTOCREATE_ESP, 3, HEADER_HEIGHT+1);

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_ENTER_EQUALS_CONTINUE,
                SP_STAT_ESC_EQUALS_CANCEL,
                0);

            //
            // Wait for user input
            //
            SpInputDrain();
            
            UserOption = SpWaitValidKey(ValidKeys, NULL, NULL);

            if (UserOption == ASCI_CR) {
                Confirmed = TRUE;
            }            
        } else {
            Confirmed = TRUE;
        }            
    }

    if (Confirmed) {
        WCHAR ArcDiskName[MAX_PATH];
        ULONG DiskNumber;
        ULONG ArcDiskNumber;
        PDISK_REGION EspCandidateRegion = NULL;

        //
        // Find the first harddisk (non-removable) media that the 
        // BIOS enumerated to be used for system partition
        //
        for (DiskNumber = 0, Status = STATUS_UNSUCCESSFUL;
            (!NT_SUCCESS(Status) && (DiskNumber < HardDiskCount));
            DiskNumber++) {         

            swprintf(ArcDiskName, L"multi(0)disk(0)rdisk(%d)", DiskNumber);       
            ArcDiskNumber = SpArcDevicePathToDiskNumber(ArcDiskName);        

            //
            // Make sure its not removable disk and its reachable by firmware
            //
            if ((ArcDiskNumber == (ULONG)-1) || SPPT_IS_REMOVABLE_DISK(ArcDiskNumber)) {
                continue;   // get to the next disk                
            }

            Status = SpPtnCreateESPForDisk(ArcDiskNumber);
        }

        if (PromptUser && !NT_SUCCESS(Status)) {
            ULONG ValidKeys[] = { ASCI_CR, 0 };

            ValidArcSystemPartition = FALSE;

            SpDisplayScreen(SP_AUTOCREATE_ESP_FAILED, 3, HEADER_HEIGHT+1);

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_ENTER_EQUALS_CONTINUE,
                0);

            //
            // Wait for user input
            //
            SpInputDrain();
            
            SpWaitValidKey(ValidKeys, NULL, NULL);
        }        
    } else {
        Status = STATUS_CANCELLED;
    }        
    
    return Status;
}

NTSTATUS
SpPtnInitializeGPTDisk(
    IN ULONG DiskNumber
    )
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if ((DiskNumber < HardDiskCount) && (SPPT_IS_GPT_DISK(DiskNumber))) {
        PDISK_REGION CurrRegion = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);
        PDISK_REGION EspRegion = NULL;
        PDISK_REGION MsrRegion = NULL;

        while (CurrRegion && ((NULL == EspRegion) || (NULL == MsrRegion))) {
            if (SPPT_IS_REGION_EFI_SYSTEM_PARTITION(CurrRegion)) {
                EspRegion = CurrRegion;
            } else if (SPPT_IS_REGION_MSFT_RESERVED(CurrRegion)) {
                MsrRegion = CurrRegion;
            }                                
            
            CurrRegion = CurrRegion->Next;
        }

        if (!MsrRegion) {
            PDISK_REGION MsrCandidate = NULL;
            
            if (EspRegion) {
                MsrCandidate = EspRegion->Next;
            } else {
                MsrCandidate = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);
            }

            if (MsrCandidate && SpPtnIsValidMSRRegion(MsrCandidate)) {
                PARTITION_INFORMATION_EX PartInfo;            
                PDISK_REGION MsrRegion = NULL;
                ULONGLONG SizeMB = SpPtnGetDiskMSRSizeMB(DiskNumber);
                BOOLEAN CreateResult;

                RtlZeroMemory(&PartInfo, sizeof(PARTITION_INFORMATION_EX));
                PartInfo.PartitionStyle = PARTITION_STYLE_GPT;
                PartInfo.Gpt.Attributes = 0;    // required ???
                PartInfo.Gpt.PartitionType = PARTITION_MSFT_RESERVED_GUID;
                SpCreateNewGuid(&(PartInfo.Gpt.PartitionId));
                                
                CreateResult = SpPtnCreate(DiskNumber,
                                    MsrCandidate->StartSector,
                                    0,          // SizeInSectors: used only in the ASR case
                                    SizeMB,
                                    FALSE,
                                    TRUE,
                                    &PartInfo,
                                    &MsrRegion);

                Status = CreateResult ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
                            
                if (!NT_SUCCESS(Status)) {                                
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                        "SETUP:SpPtnInitializeGPTDisk() failed with "
                        " (%lx)\n",
                        Status));
                }
            } else {
                Status = STATUS_SUCCESS;
            }
        } else {
            Status = STATUS_SUCCESS;
        }
    }

    return Status;
}

BOOLEAN
SpIsMSRPresentOnDisk(
    IN ULONG DiskNumber
    )
/*++

  Routine Description:

    Determines if the Disk containing the ESP has a MSR.
    
  Arguments:
    
    DiskNumber - Disk Number of the Disk containing the ESP.
    
  Return Value:

    TRUE/FALSE depending on presence/absence of MSR.
    
--*/
{
    BOOLEAN MsrPresent = FALSE;

    if ((DiskNumber < HardDiskCount) && (SPPT_IS_GPT_DISK(DiskNumber))) {
        PDISK_REGION CurrRegion = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);

        while (CurrRegion) {
            if (SPPT_IS_REGION_MSFT_RESERVED(CurrRegion)) {
                MsrPresent = TRUE;
                break;
            }                                
            
            CurrRegion = CurrRegion->Next;
        }
    }
    return(MsrPresent);
}
    
ULONG
SpGetSystemDiskNumber(
    VOID
    )
/*++

  Routine Description:

    Finds the NT Disk number of the disk that was detected first and
    is selected to contain the ESP.
        
  Arguments:

    None.

  Return Value:
    ULONG - NT Disk number of the disk containing the ESP.

--*/
{
    WCHAR ArcDiskName[MAX_PATH];
    ULONG NtDiskNumber;
    NTSTATUS Status;
    ULONG DiskNumber;
    
    //
    // Find the first harddisk (non-removable) media that the 
    // BIOS enumerated to be used for system partition
    //
    for (DiskNumber = 0; DiskNumber < HardDiskCount; DiskNumber++) {         

        swprintf(ArcDiskName, L"multi(0)disk(0)rdisk(%d)", DiskNumber);       
        NtDiskNumber = SpArcDevicePathToDiskNumber(ArcDiskName);        

        //
        // Make sure its not removable disk and its reachable by firmware
        //
        if (((ULONG)-1 != NtDiskNumber) && 
            (!SPPT_IS_REMOVABLE_DISK(NtDiskNumber))) {
            break;   
        }

    }

    ASSERT((NtDiskNumber < HardDiskCount) &&
           (-1 != NtDiskNumber));
    
    return(NtDiskNumber);
}

NTSTATUS
SpPtnInitializeGPTDisks(
    VOID
    )
{
    NTSTATUS LastError = STATUS_SUCCESS;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG DiskNumber;
    ULONG SystemDiskNumber = SpGetSystemDiskNumber();
    for (DiskNumber = 0; (DiskNumber < HardDiskCount); DiskNumber++) {
        
        //
        // Create an MSR on the System Partition Disk only if a ESP exists.
        // If an ESP does not exist on the disk that the BIOS enumerated to be
        // used for creating ESP, then do not create an MSR on that disk.
        //
        if (SPPT_IS_GPT_DISK(DiskNumber) && 
            ((DiskNumber != SystemDiskNumber) || ValidArcSystemPartition)) {
            Status = SpPtnInitializeGPTDisk(DiskNumber);

            if (!NT_SUCCESS(Status)) {
                LastError = Status;
            }
        }            
    }

    return LastError;
}


NTSTATUS
SpPtnRepartitionGPTDisk(
    IN ULONG           DiskId,
    IN ULONG           MinimumFreeSpaceKB,
    OUT PDISK_REGION   *RegionToInstall
    )
/*++

Routine Description:

    Repartitions a given disk for unattended and remote
    boot install case
    
Arguments:

    DiskId  :   The disk which needs to be repartitioned

    MinimumFreeSpace : Minimum space required in KB

    RegionToInstall : Place holder for the region which
                      will be selected for installation.


Return Value:

    Appropriate status code.

--*/        
{
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;

    if ((DiskId < HardDiskCount) && !SPPT_IS_REMOVABLE_DISK(DiskId)) {
        PDISK_REGION    CurrentRegion = SPPT_GET_PRIMARY_DISK_REGION(DiskId);
        BOOLEAN         Changes = FALSE;

        //
        // Mark all the existing partitioned space on the disk
        // for deletion
        //
        while (CurrentRegion) {
            if (SPPT_IS_REGION_PARTITIONED(CurrentRegion)) {
                SPPT_SET_REGION_DELETED(CurrentRegion, TRUE);
                SPPT_SET_REGION_DIRTY(CurrentRegion, TRUE);
                Changes = TRUE;
            }
            
            CurrentRegion = CurrentRegion->Next;
        }

        //
        // Delete all the partitioned space on the disk
        //
        if (Changes) {
            Status = SpPtnCommitChanges(DiskId, &Changes);
        } else {
            Status = STATUS_SUCCESS;
        }            

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        //
        // Update the in memory region structure for the disk
        //
        Status = SpPtnInitializeDiskDrive(DiskId);

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        //
        // Reinitialize the disk style to GPT to be sure its
        // GPT disk
        //
        SPPT_SET_DISK_BLANK(DiskId, TRUE);

        Status = SpPtnInitializeDiskStyle(DiskId,
                    PARTITION_STYLE_GPT,
                    NULL);

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        //
        // Update the in memory region structure for the disk
        //
        Status = SpPtnInitializeDiskDrive(DiskId);

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        //
        // First create the ESP on the disk
        //
        Status = SpPtnCreateESPForDisk(DiskId);

        if (!NT_SUCCESS(Status)) {
            return Status;
        }        

        //
        // Create the MSR partition 
        //
        Status = SpPtnInitializeGPTDisk(DiskId);

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        //
        // Find the first free space region with adequate space
        //       
        CurrentRegion = SPPT_GET_PRIMARY_DISK_REGION(DiskId);

        while (CurrentRegion) {
            if (SPPT_IS_REGION_FREESPACE(CurrentRegion) &&
                (SPPT_REGION_FREESPACE_KB(CurrentRegion) >= MinimumFreeSpaceKB)) {

                break;                
            }

            CurrentRegion = CurrentRegion->Next;
        }

        if (CurrentRegion) {
            *RegionToInstall = CurrentRegion;   
        } else {
            Status = STATUS_UNSUCCESSFUL;
        }            
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spsetup.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spsetup.c

Abstract:

    Main module for character-base setup (ie, text setup).

Author:

    Ted Miller (tedm) 29-July-1993

--*/

#include "spprecmp.h"
#pragma hdrstop
#include "spcmdcon.h"
#include <initguid.h>
#include <pnpmgr.h>
#include <devguid.h>
#include <remboot.h>
#include <hdlsblk.h>
#include <hdlsterm.h>
#ifdef _X86_
#include "spwin9xuninstall.h"
#endif

#if !defined(SETUPBLK_FLAGS_ROLLBACK)
#define SETUPBLK_FLAGS_ROLLBACK 0
#endif

#if defined(REMOTE_BOOT)
VOID
IoStartCscForTextmodeSetup(
    IN BOOLEAN Upgrade
    );
#endif // defined(REMOTE_BOOT)

BOOL
SpDetermineBootPartitionEnumNec98(
    IN PPARTITIONED_DISK Disk,
    IN PDISK_REGION Region,
    IN ULONG_PTR Context
    );

VOID
SpCantFindBuildToUpgrade(
    VOID
    );


//
// TRUE if setup should run in the step-up upgrade mode.
// In this mode, setup is not allowed to do clean install,
// and is not allowed to upgrade workstation to server.
// Also, evaluation time in minutes, read from the setup hive.
// This value is passed through to GUI mode.
//
BOOLEAN StepUpMode;
DWORD EvaluationTime = 0;
ULONG RestrictCpu;
ULONG SuiteType;

//
// TRUE if user chose Custom Setup.
//
BOOLEAN CustomSetup = TRUE;

//
// Non-0 if gui setup is supposed to be restartable.
// This causes us to do special stuff with hives in spconfig.c.
//
BOOLEAN RestartableGuiSetup = TRUE;

//
// TRUE if user chose repair winnt
//

BOOLEAN RepairWinnt = FALSE;

//
// TRUE if this is a command console only boot
//
BOOLEAN ForceConsole = FALSE;
BOOLEAN ConsoleRunning = FALSE;
BOOLEAN ConsoleFromWinnt32 = FALSE;

//
// TRUE if repair from ER diskette
//

BOOLEAN RepairFromErDisk = TRUE;

//
// TRUE if this is advanced server we're setting up.
//
BOOLEAN AdvancedServer;

//
// Windows NT Version.
//
ULONG WinntMajorVer;
ULONG WinntMinorVer;

//
// Win9x uninstall
//
BOOLEAN Win9xRollback = FALSE;
BOOLEAN g_Win9xBackup = FALSE;

#ifdef PRERELEASE
//
// Test hooks
//

INT g_TestHook;
#endif

//
// True if NOLS = 1 in winnts.sif
//
BOOLEAN NoLs = FALSE;

//
// NTUpgrade - Whether we are upgrading an existing NT and if we are
//             what type of an upgrade it is.  Valid values are:
//
//    - DontUpgrade:         If we are not upgrading
//    - UpgradeFull:         Full upgrade
//    - UpgradeInstallFresh: There was a failed upgrade, so we want to install
//                           fresh into this, saving the hives
//
//
ENUMUPGRADETYPE NTUpgrade = DontUpgrade;

//
// Indicates whether actually NT was being upgraded
// to partitioning engine, so that on IA64 it can
// treat active MBR partitions as system partitions
//
ENUMUPGRADETYPE IsNTUpgrade = DontUpgrade;

//
// TRUE if upgrading Workstation to Standard Server, or upgrading
// existing Standard Server
//
BOOLEAN StandardServerUpgrade = FALSE;

//
// Contains the type of windows upgrade, if any (win31 or win95)
//
ENUMNONNTUPRADETYPE WinUpgradeType = NoWinUpgrade;

//
// TRUE if this setup was started with winnt.exe or winnt32.exe.
// Also a flag indicating whether the local source was not created and we
// should get files from the CD instead.
//
BOOLEAN WinntSetup = FALSE;
BOOLEAN WinntFromCd = FALSE;

//
// TRUE if floppyless boot
//
BOOLEAN IsFloppylessBoot = FALSE;

//
// TRUE if textmode is to pick a partition
//
BOOLEAN AutoPartitionPicker;

//
// Preferred installation dir
//
PWSTR PreferredInstallDir;

//
// If this is an unattended setup, this value will be a non-NULL
// handle to the SIF file with setup parameters.
// *Note*: Before referencing UnattendedSifHandle, you must first check
//         UnattendedOperation is not FALSE.
//
BOOLEAN UnattendedOperation = FALSE;
BOOLEAN UnattendedGuiOperation = FALSE;
PVOID UnattendedSifHandle = NULL;
PVOID WinntSifHandle = NULL;
PVOID ASRPnPSifHandle = NULL;
PVOID WinntMigrateInfHandle = NULL;
PVOID WinntUnsupDrvInfHandle = NULL;
BOOLEAN AccessibleSetup = FALSE;

//
// this value is a non-null pointer to the drvindex.inf file.  It is
// initialized on startup.  The list of files that are present in our
// driver cab file are indexed in this inf, so we can quickly look if a
// file is present in the cab
//
PVOID DriverInfHandle;

//
// this is a non-null pointer to the driver cab file.  It is also initialzied
// on startup.  The list of files in this cab is indexed in drvindex.inf.  this is
// the only cab file that textmode setup knows to look into.
//
CABDATA *CabData;

//
// pointer to delta.inf, an INF for private testing
//
PVOID PrivateInfHandle;

//
//  This is a handle to txtsetup.oem, used on pre-install mode.
//
PVOID PreinstallOemSifHandle = NULL;

//
// If this flag is true, we ignore files that are not present on the source
// when copying. This is used internally for people who don't build the
// entire system and don't care that a whole bunch of help files,
// device drivers, etc, aren't there.
//
BOOLEAN SkipMissingFiles;
BOOLEAN HideWinDir;

//
// On unattended mode, indicates whether OEM files
// that have same name as Microsoft files released
// with the product should be overwritten.
//
BOOLEAN UnattendedOverwriteOem = TRUE;

//
// On unattended mode, indicates that this is is
// an OEM pre-installation
//
BOOLEAN PreInstall = FALSE;

//
// In unattended mode, indicates whether to wait
// for reboot
//
BOOLEAN UnattendWaitForReboot = FALSE;

//
// On pre-install mode, indicates whether or not an OEM component needs
// to be pre-installed (txtsetup.oem needs to be loaded).
//
// BOOLEAN PreinstallOemComponents = FALSE;

//
//  On pre-install mode, the variables below point to the various lists of
//  drivers to pre-install
//
// PPREINSTALL_DRIVER_INFO PreinstallDisplayDriverList = NULL;
// PPREINSTALL_DRIVER_INFO PreinstallKeyboardDriverList = NULL;
// PPREINSTALL_DRIVER_INFO PreinstallPointingDeviceDriverList = NULL;
// PPREINSTALL_DRIVER_INFO PreinstallKeyboardLayout = NULL;

//
//  On pre-install mode, points to the directory that contains the files
//  that need to be copied during textmode setup
//
PWSTR   PreinstallOemSourcePath = NULL;

//
// Virtual OEM source devices (accessible through RAM disk driver)
//
PVIRTUAL_OEM_SOURCE_DEVICE VirtualOemSourceDevices = NULL;

//
//  Flags that indicate the type of mice detected in the machine.
//  Note that more than one type of mice may be present.
//
BOOLEAN UsbMouseDetected = FALSE;
BOOLEAN PS2MouseDetected = FALSE;
BOOLEAN SerMouseDetected = FALSE;

//
//  Flags that indicate the type of keyboard detected in the machine.
//  Note that more than one type of keyborad may be present.
//
BOOLEAN UsbKeyboardDetected = FALSE;
BOOLEAN StdKeyboardDetected = FALSE;

//
// Gets set to TRUE if the user elects to convert or format to ntfs.
// And a flag indicating whether we are doing a dirty sleazy hack
// for oem preinstall.
//
BOOLEAN ConvertNtVolumeToNtfs = FALSE;
BOOLEAN ExtendingOemPartition = FALSE;

//
// Variable used during the repair process, that indicates that the
// system has no CD-ROM drive.
// This is a hack that we did for World Bank so that they can repair
// the hives even if they don't have a CD-ROM drive.
//
BOOLEAN RepairNoCDROMDrive = FALSE;

//
// Indicates whether or not winnt32 detected at least one
// FT partition in the system.
// Note that on boot floppies install on x86 machines,
// or setupldr/CD install on ARC machines, this flag will always be
// set to FALSE
//
BOOLEAN FtPartitionDetected = FALSE;

//
// Filename of local source directory.
//
PWSTR LocalSourceDirectory = L"\\$win_nt$.~ls";

LIST_ENTRY MigratedDriversList;

//
// Platform-specific extension, used when creating names of sections
// in sif/inf files.
//
#if defined(_AMD64_)
PWSTR PlatformExtension = L".amd64";
#elif defined(_X86_)
PWSTR PlatformExtension = L".x86";
#elif defined(_IA64_)
PWSTR PlatformExtension = L".ia64";
#else
#error "No Target Architecture"
#endif

WCHAR TemporaryBuffer[16384];
const UNICODE_STRING TemporaryBufferUnicodeString = { 0, sizeof(TemporaryBuffer), TemporaryBuffer };

//
// This global structure contains non-pointer values passed to us by setupldr
// in the setup loader parameter block.
//
// This structure is initialized during SpInitialize0().
//
SETUP_LOADER_BLOCK_SCALARS SetupParameters;

//
// These values are set during SpInitialize0() and are the ARC pathname
// of the device from which we were started and the directory within the device.
// DirectoryOnBootDevice will always be all uppercase.
//
PWSTR ArcBootDevicePath,DirectoryOnBootDevice;

//
// Representation of the boot device path in the nt namespace.
//
PWSTR NtBootDevicePath;


//
// Dynamic update boot driver path in NT namespace
//
PWSTR DynUpdtBootDriverPath = NULL;


//
// Global parameter block for command console
//
CMDCON_BLOCK Block = {0};

//
// Setupldr loads a text setup information file and passes us the buffer
// so that we don't have to reload it from disk. During SpInitialize0()
// we allocate some pool and store the image away for later use.
//
PVOID SetupldrInfoFile;
ULONG SetupldrInfoFileSize;

//
// During remote boot setup, setupldr also loads winnt.sif.
//
PVOID SetupldrWinntSifFile;
ULONG SetupldrWinntSifFileSize;

//
// Setupldr loads asrpnp.sif.
//
PVOID SetupldrASRPnPSifFile;
ULONG SetupldrASRPnPSifFileSize;

//
// Setupldr may load an inf that contains registry information that needs to be
// migrated to the setup hive. This file will be processed during SpInitialize0().
//
PVOID SetupldrMigrateInfFile;
ULONG SetupldrMigrateInfFileSize;

//
// Setupldr may load an inf that contains information about unsupported SCSI
// drivers that need to work during textmode setup.
// This file will be processed during SpInitialize0().
//
PVOID SetupldrUnsupDrvInfFile;
ULONG SetupldrUnsupDrvInfFileSize;

#if defined(REMOTE_BOOT)
//
// Setupldr passes in the hal name on remote boot.  Store them here
// before the loader block goes away.
//
UCHAR NetBootHalName[MAX_HAL_NAME_LENGTH + 1];
#endif // defined(REMOTE_BOOT)

//
// The name of the SIF file used by remote boot. This is saved since
// it needs to be deleted later.
//
PWSTR NetBootSifPath = NULL;

PDISK_SIGNATURE_INFORMATION DiskSignatureInformation;

//
// Setupldr passes in the path to IMirror.dat, store it here before the loader
// block goes away.
//
PUCHAR RemoteIMirrorFilePath;

//
// For remote install, save the NT boot path from the loader block, because
// DirectoryOnBootDevice becomes something else.
//
PWSTR RemoteIMirrorBootDirectoryPrefix;

//
// The file version and memory version of the IMirror.dat information
// (the memory version is modified to match this actual machine).
//
PMIRROR_CFG_INFO_FILE RemoteIMirrorFileData = NULL;
PMIRROR_CFG_INFO_MEMORY RemoteIMirrorMemoryData = NULL;

//
// Setupldr passes in the IP address of the server we are talking to.
//
ULONG RemoteServerIpAddress;

//
// setupldr may pass us the administrator password in a remote install
// if the user is prompted for the password.
//
PWSTR NetBootAdministratorPassword = NULL;

BOOLEAN GeneralInitialized = FALSE;

BOOLEAN PcmciaLoaded = FALSE;

BOOLEAN AtapiLoaded = FALSE;

//
//  Array with the PIDs of all NT greater than 4.x found in the machine (PID 2.0)
//  The values in this array will be saved under Setup\PidList key in the registry,
//  and will be used during GUI setup
//
PWSTR*  Pid20Array = NULL;

//
//  Product Id read from setupp.ini
//
PWSTR   PidString = NULL;

//
// Plug & Play notification handle
//
PVOID   NotificationEntry = NULL;

//
// Plug & Play hardware ID database (unicode)
//
PSETUP_PNP_HARDWARE_ID SetupHardwareIdDatabase = NULL;

//
//  Guid strings to identify mouse and keyboard
//
PWSTR MouseGuidString = NULL;
PWSTR KeyboardGuidString = NULL;

//
// This flag identifies "dockable" machines (portables)
// so that we can disble dynamic volumes on them
//
BOOLEAN DockableMachine = FALSE;

//
// Pointer to block of interesting values and other stuff
// passed to spcmdcon.sys
//
PCMDCON_BLOCK gpCmdConsBlock = NULL;

//begin NEC98
PDISK_REGION    TargetRegion_Nec98 = NULL;
#define WINNT_D_DRIVEASSIGN_NEC98_W L"DriveAssign_Nec98"
#define WINNT_D_DRIVEASSIGN_NEC98_A "DriveAssign_Nec98"

#ifdef UNICODE
#define WINNT_D_DRIVEASSIGN_NEC98 WINNT_D_DRIVEASSIGN_NEC98_W
#else
#define WINNT_D_DRIVEASSIGN_NEC98 WINNT_D_DRIVEASSIGN_NEC98_A
#endif


//
// Legacy drive assign for NEC98, HD start from A:
// but it is only case of upgrade from NT4.0 or Win9x.
//
BOOLEAN DriveAssignFromA = FALSE;     //PC-AT assign.


//
// Indicates whether we have a system partition or not
// on Arc Machines
//
BOOLEAN ValidArcSystemPartition = FALSE;

#ifdef _X86_
//
// NEC98
//
BOOLEAN
SpReInitializeBootVars_Nec98(
    VOID
);
#endif

VOID
SpSetAutoBootFlag(
    IN PDISK_REGION TargetRegion,
    IN BOOLEAN    SetBootPosision
    );
//end NEC98

VOID
SpTerminate(
    VOID
    );

VOID
SpInitialize0a(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID          Context,
    IN ULONG          ReferenceCount
    );

VOID
SpDetermineProductType(
    IN PVOID SifHandle
    );

BOOL
SpDetermineInstallationSource(
    IN  PVOID  SifHandle,
    OUT PWSTR *DevicePath,
    OUT PWSTR *DirectoryOnDevice,
    IN  BOOLEAN bEscape
    );

VOID
SpCompleteBootListConfig(
    WCHAR   DriveLetter
    );

VOID
SpInitializePidString(
    IN HANDLE       MasterSifHandle,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice
    );


BOOLEAN
SpGetStepUpMode(
    IN PWSTR PidExtraData,
    BOOLEAN  *StepUpMode
    );

NTSTATUS
SpCreateDriverRegistryEntries(
    IN PHARDWARE_COMPONENT  DriverList
    );


#if defined(REMOTE_BOOT)

NTSTATUS
SpFixupRemoteBootLoader(
    PWSTR RemoteBootTarget
    );

NTSTATUS
SpCreateRemoteBootCfg(
    IN PWSTR RemoteBootTarget,
    IN PDISK_REGION SystemPartitionRegion
    );

NTSTATUS
SpEraseCscCache(
    IN PDISK_REGION SystemPartitionRegion
    );
#endif // defined(REMOTE_BOOT)

#if defined HEADLESS_ATTENDEDTEXTMODE_UNATTENDEDGUIMODE

VOID SpGetServerType(
    )
{
    int ServerTypes, i;
    PWSTR Server[] = {
        L"Web Server",
        L"File Server",
        L"DHCP Server"
    };
    ULONG MenuTopY;
    ULONG MenuHeight;
    ULONG MenuWidth;
    PVOID Menu;
    ULONG CurrentServer;
    ULONG ValidKeys[] = {ASCI_CR};
    ULONG KeyPress;

    ServerTypes = 3;
    SpStartScreen(
        SP_SCRN_GET_SERVER_TYPE,
        3,
        CLIENT_TOP+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE
        );

    MenuTopY =NextMessageTopLine + 2;
    Menu = SpMnCreate(3,
                      MenuTopY,
                      VideoVars.ScreenWidth -6,
                      ServerTypes);
    if (Menu==NULL) {
        return;
    }
    for (i=0;i<ServerTypes;i++) {
        CurrentServer = (ULONG) i;
        SpMnAddItem(Menu,
                    Server[i],
                    3,
                    VideoVars.ScreenWidth -6,
                    TRUE,
                    CurrentServer
                    );
    }
    SpMnDisplay(Menu,
                0,
                TRUE,
                ValidKeys,
                NULL,
                NULL,
                NULL,
                &KeyPress,
                &CurrentServer
                );

    switch(KeyPress){
    case ASCI_CR:
        SpMnDestroy(Menu);
        break;
    default:
        SpMnDestroy(Menu);
    }

    // Add information to the inf file to setup the correct server

    return;
}


VOID
SpGetServerDetails(
    )
{
    // Get the type of server that needs to be installed on the machine.
    WCHAR *Constants[1];

    // Assume licenses are purchased per seat

    Constants[0]=L"PERSEAT";
    SpAddLineToSection(WinntSifHandle,L"LicenseFilePrintData",L"AutoMode",Constants,1);

    //Turn on Terminal Services
    Constants[0] = L"ON";
    SpAddLineToSection(WinntSifHandle,L"Components",L"TSEnable",Constants,1);

    // In order that the terminal server comes up properly, we need to make sure
    // that the network cards are properly configured. In the case of a multihomed
    // NIC or cases we cannot use dhcp, we need to statically configure addresses.
    // will try to do this in the GUI setup. now try to determine the type of server
    // to install.

    SpGetServerType();
    return;
}



VOID
SpGetTimeZone(
    )

{
    ULONG MenuTopY;
    ULONG MenuHeight;
    ULONG MenuWidth;
    PVOID Menu;
    ULONG ValidKeys[] = {ASCI_CR};
    ULONG KeyPress;
    int i,TimeZones;
    ULONG CurrentTimeZone=4;
    WCHAR *Constants[1];
    WCHAR Temp[20];
    PWSTR TimeZone[] = {
        L" -12:00   Dateline : Eniwetok, Kwajalein",
        L" -11:00   Samoa : Midway Island, Samoa",
        L" -10:00   Hawaiian : Hawaii",
        L" -09:00   Alaskan : Alaska",
        L" -08:00   Pacific : Pacific Time (US & Canada); Tijuana",
        L" -07:00   Mountain : Mountain Time (US & Canada)",
        L" -07:00   US Mountain : Arizona",
        L" -06:00   Central : Central Time (US & Canada)",
        L" -06:00   Canada Central : Saskatchewan",
        L" -06:00   Mexico : Mexico City, Tegucigalpa",
        L" -05:00   Eastern : Eastern Time (US & Canada)",
        L" -05:00   US Eastern : Indiana (East)",
        L" -05:00   SA Pacific : Bogota, Lima, Quito",
        L" -04:00   Atlantic : Atlantic Time (Canada)",
        L" -04:00   SA Western : Caracas, La Paz",
        L" -03:30   Newfoundland : Newfoundland",
        L" -03:00   E. South America : Brasilia",
        L" -03:00   SA Eastern : Buenos Aires, Georgetown",
        L" -02:00   Mid-Atlantic : Mid-Atlantic",
        L" -01:00   Azores: Azores, Cape Verde Is.",
        L"  00:00   GMT : Greenwich Mean Time : Dublin, Edinburgh, Lisbon, London",
        L"  00:00   Greenwich : Casablanca, Monrovia",
        L" +01:00   Central Europe : Belgrade, Bratislava, Budapest, Ljubljana, Prague",
        L" +01:00   Central European : Sarajevo, Skopje, Sofija, Warsaw, Zagreb",
        L" +01:00   Romance : Brussels, Copenhagen, Madrid, Paris, Vilnius",
        L" +01:00   W. Europe : Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna",
        L" +02:00   E. Europe : Bucharest",
        L" +02:00   Egypt : Cairo",
        L" +02:00   FLE : Helsinki, Riga, Tallinn",
        L" +02:00   GTB : Athens, Istanbul, Minsk",
        L" +02:00   Israel : IsraeL",
        L" +02:00   South Africa : Harare, Pretoria",
        L" +03:00   Russian : Moscow, St. Petersburg, Volgograd",
        L" +03:00   Arab : Baghdad, Kuwait, Riyadh",
        L" +03:00   E. Africa : Nairobi",
        L" +03:30   Iran : Tehran",
        L" +04:00   Arabian : Abu Dhabi, Muscat",
        L" +04:00   Caucasus : Baku, Tbilisi",
        L" +04:30   Afghanistan : KabuL",
        L" +05:00   Ekaterinburg : Ekaterinburg",
        L" +05:00   West Asia : Islamabad, Karachi, Tashkent",
        L" +05:30   India : Bombay, Calcutta, Madras, New Delhi",
        L" +06:00   Central Asia : Almaty, Dhaka",
        L" +06:00   Sri Lanka : Colombo",
        L" +07:00   SE Asia : Bangkok, Hanoi, Jakarta",
        L" +08:00   China : Beijing, Chongqing, Hong Kong, Urumqi",
        L" +08:00   Singapore : Singapore",
        L" +08:00   Taipei : Taipei",
        L" +08:00   W. Australia : Perth",
        L" +09:00   Korea : SeouL",
        L" +09:00   Tokyo : Osaka, Sapporo, Tokyo",
        L" +09:00   Yakutsk : Yakutsk",
        L" +09:30   AUS Central : Darwin",
        L" +09:30   Cen. Australia : Adelaide",
        L" +10:00   AUS Eastern : Canberra, Melbourne, Sydney",
        L" +10:00   E. Australia : Brisbane",
        L" +10:00   Tasmania : Hobart",
        L" +10:00   Vladivostok : Vladivostok",
        L" +10:00   West Pacific : Guam, Port Moresby",
        L" +11:00   Central Pacific : Magadan, Solomon Is., New Caledonia",
        L" +12:00   Fiji: Fiji, Kamchatka, Marshall Is.",
        L" +12:00   New Zealand : Auckland, Wellington"
        };
    ULONG TimeZoneIndex[] = {
        0,
        1,
        2,
        3,
        4,
        10,
        15,
        20,
        25,
        30,
        35,
        40,
        45,
        50,
        55,
        60,
        65,
        70,
        75,
        80,
        85,
        90,
        95,
        100,
        105,
        110,
        115,
        120,
        125,
        130,
        135,
        140,
        145,
        150,
        155,
        160,
        165,
        170,
        175,
        180,
        185,
        190,
        195,
        200,
        205,
        210,
        215,
        220,
        225,
        230,
        235,
        240,
        245,
        250,
        255,
        260,
        265,
        270,
        275,
        280,
        285,
        290
    };


    TimeZones = sizeof(TimeZoneIndex)/sizeof(ULONG);
    SpStartScreen(
        SP_SCRN_GET_TIME_ZONE,
        3,
        CLIENT_TOP+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE
        );

    MenuTopY =NextMessageTopLine + 2;
    Menu = SpMnCreate(
                      3,
                      MenuTopY,
                      VideoVars.ScreenWidth -6,
                      10);
    if (Menu==NULL) {
        Constants[0] = L"4";
        SpAddLineToSection(WinntSifHandle,WINNT_GUIUNATTENDED_W,
                            L"TimeZone",Constants,1);
        return;
    }
    for (i=0;i<TimeZones;i++) {
        SpMnAddItem(Menu,
                    TimeZone[i],
                    3,
                    VideoVars.ScreenWidth -6,
                    TRUE,
                    TimeZoneIndex[i]
                    );
    }
    SpMnDisplay(Menu,
                0,
                TRUE,
                ValidKeys,
                NULL,
                NULL,
                NULL,
                &KeyPress,
                &CurrentTimeZone
                );

    switch(KeyPress){
    case ASCI_CR:
        SpMnDestroy(Menu);
        break;
    default:
        SpMnDestroy(Menu);
    }
    swprintf(Temp,L"%ld",CurrentTimeZone);
    Constants[0] = Temp;
    SpAddLineToSection(WinntSifHandle,WINNT_GUIUNATTENDED_W,
                        L"TimeZone",Constants,1);
    return;
}

ValidationValue
SpGetAsciiCB(
    IN ULONG Key
    )
{
    if (Key & KEY_NON_CHARACTER) {
        return(ValidateReject);
    }
    return(ValidateAccept);

}

VOID
SpGetNecessaryParameters(
    )
/*+++
      Reads in the necessary input values to allow GUI mode setup to proceed
      unattended.
      1. Name of person
      2. Computer Name
      3. Organization
      4. Timezone
---*/
{
    /*+++
          Get Full Name of the User and the Organization
    ---*/


    WCHAR *Buffer[3];
    WCHAR *InputBuffer[3];
    WCHAR CompBuffer[200], NameBuffer[200], OrgBuffer[200];
    WCHAR Comp[40], Name[40], Org[40];
    ULONG Top[3];
    int index=0;
    int i;
    BOOLEAN notdone = TRUE;
    BOOLEAN status;
    WCHAR *Constants[1];

    Buffer[0] = NameBuffer;
    Buffer[1] = OrgBuffer;
    Buffer[2] = CompBuffer;

    InputBuffer[0] = Name;
    InputBuffer[1] = Org;
    InputBuffer[2] = Comp;

    for(i=0;i<3;i++){
        swprintf(Buffer[i],L"");
        swprintf(InputBuffer[i],L"");
    }
    do{
        notdone= FALSE;
        SpStartScreen(
            SP_SCRN_GET_GUI_STUFF,
            3,
            CLIENT_TOP+1,
               FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE
            );

        SpFormatMessage(NameBuffer,sizeof(NameBuffer),SP_TEXT_NAME_PROMPT);
        //SpvidDisplayString(Buffer[0],DEFAULT_ATTRIBUTE,3,NextMessageTopLine);
        SpContinueScreen(SP_TEXT_NAME_PROMPT,3,3,FALSE, DEFAULT_ATTRIBUTE);
        Top[0] = NextMessageTopLine - 1;

        SpFormatMessage(OrgBuffer,sizeof(OrgBuffer),SP_TEXT_ORG_PROMPT);
        //SpvidDisplayString(Buffer[1],DEFAULT_ATTRIBUTE,3,NextMessageTopLine);
        SpContinueScreen(SP_TEXT_ORG_PROMPT,3,3,FALSE, DEFAULT_ATTRIBUTE);
        Top[1] = NextMessageTopLine - 1;

        SpFormatMessage(CompBuffer,sizeof(CompBuffer),SP_TEXT_COMPUTER_PROMPT);
        //SpvidDisplayString(Buffer[2],DEFAULT_ATTRIBUTE,3,NextMessageTopLine);
        SpContinueScreen(SP_TEXT_COMPUTER_PROMPT,3,3,FALSE, DEFAULT_ATTRIBUTE);
        Top[2] = NextMessageTopLine - 1;

        index = 0;
        do{
            status = SpGetInput(SpGetAsciiCB,
                                SplangGetColumnCount(Buffer[index])+5,
                                Top[index],
                                20,
                                InputBuffer[index],
                                FALSE,
                                0
                                );
            index = (index+1) %3;
        }while (index != 0);
        for(i=0;i<3;i++){
            if (wcscmp(InputBuffer[i],L"")==0) {
                notdone=TRUE;
            }
        }

    }while(notdone);

    SpAddLineToSection(WinntSifHandle,WINNT_USERDATA_W,
                       WINNT_US_FULLNAME_W,InputBuffer,1);
    SpAddLineToSection(WinntSifHandle,WINNT_USERDATA_W,
                       WINNT_US_ORGNAME_W,&(InputBuffer[1]),1);
    SpAddLineToSection(WinntSifHandle,WINNT_USERDATA_W,
                       WINNT_US_COMPNAME_W,&(InputBuffer[2]),1);
    Constants[0] = L"1";
    SpAddLineToSection(WinntSifHandle,WINNT_GUIUNATTENDED_W,
                       L"OemSkipWelcome",Constants,1);
    SpAddLineToSection(WinntSifHandle,WINNT_GUIUNATTENDED_W,
                       L"OemSkipRegional",Constants,1);

    // Get the Timezone Information
    SpGetTimeZone();

    Constants[0] =L"*";
    SpAddLineToSection(WinntSifHandle,WINNT_GUIUNATTENDED_W, L"AdminPassword",Constants,1);
    Constants[0]=L"Yes";
    SpAddLineToSection(WinntSifHandle,WINNT_GUIUNATTENDED_W,L"AutoLogon",Constants,1);
    SpAddLineToSection(WinntSifHandle,L"Networking",L"ProcessPageSections",Constants,1);
    Constants[0]=L"Dummy";
    SpAddLineToSection(WinntSifHandle,L"Identification",L"JoinWorkgroup",Constants,1);
    Constants[0] = L"%systemroot%\\rccser\\rccser.exe";
    SpAddLineToSection(WinntSifHandle,L"GuiRunOnce",NULL,Constants,1);
    return;
}

#endif

NTSTATUS
SpRenameSetupAPILog(
    PDISK_REGION TargetRegion,
    PCWSTR       TargetPath
    );

NTSTATUS
SpProcessMigrateInfFile(
    IN  PVOID InfHandle
    );

NTSTATUS
SpProcessUnsupDrvInfFile(
    IN  PVOID InfHandle
    );

NTSTATUS
SpCheckForDockableMachine(
    );

VOID
SpCheckForBadBios(
    );

void
SpUpgradeToNT50FileSystems(
    PVOID SifHandle,
    PDISK_REGION SystemPartitionRegion,
    PDISK_REGION NTPartitionRegion,
    PWSTR SetupSourceDevicePath,
    PWSTR DirectoryOnSetupSource
    );

//
// From spcopy.c.
//

BOOLEAN
SpDelEnumFile(
    IN  PCWSTR                     DirName,
    IN  PFILE_BOTH_DIR_INFORMATION FileInfo,
    OUT PULONG                     ret,
    IN  PVOID                      Pointer
    );

//begin NEC98
VOID
SpCheckHiveDriveLetters(
    VOID
    );

VOID
SpSetHiveDriveLetterNec98(
    BOOLEAN DriveAssign_AT
    );

VOID
SpDeleteDriveLetterFromNTFTNec98(
    VOID
    );

VOID
SpDeleteDriveLetterFromNTFTWorkerNec98(
    VOID
    );

NTSTATUS
SpDiskRegistryQueryRoutineNec98(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    );

extern VOID
SpPtRemapDriveLetters(
    IN BOOLEAN DriveAssign_AT
    );

extern VOID
SpPtAssignDriveLetters(
    VOID
    );
//end NEC98

ValidationValue
SpValidateAdminPassword(
    IN ULONG Key
    )
{
    
    //
    // if the user hits F3,
    // then bail the SpGetInput so that
    //      we can restart the process of getting
    //      the admin's password again
    //
    if( Key == KEY_F3 ) {
        
        //
        // see if the user wants to exit setup
        //
        SpConfirmExit();
        
        //
        // we didnt exit, so bail from SpGetInput
        // 
        return ValidateTerminate;
    
    }

    if( (Key > 0x20) && (Key < 0x7F) ) {
        // The key fits our criteria.
        return(ValidateAccept);
    }
    
    return(ValidateReject);
}


BOOLEAN
SpGetAdministratorPassword( 
    PWCHAR   AdministratorPassword,
    ULONG    MaxPasswordLength
    )
/*++

Routine Description:

    This routine asks the user for an administrator password.
    
    The contents of the response are checked to ensure the password
    is reasonable.  If the response is not deemed reasonable, then
    the user is informed and requeried.

Arguments:

    AdministratorPassword - Pointer to a string which holds the password.

    MaxPasswordLength - size of the AdministratorPassword buffer.

Return Value:

    Returns TRUE if the password is successfully retrieved.
    
    FALSE otherwise.

--*/
{
    #define     MY_MAX_PASSWORD_LENGTH (20)
    BOOLEAN     Done = FALSE;
    WCHAR       ConfirmAdministratorPassword[MY_MAX_PASSWORD_LENGTH+1];
    ULONG       AdminValidKeys[] = { KEY_F3, ASCI_CR };
    BOOLEAN     GotAPassword;
    
    if( (AdministratorPassword == NULL) || (MaxPasswordLength == 0) ) {
        return FALSE;
    }

    //
    // Keep asking the user until we get what we want.
    //
    Done = FALSE;
    
    do {
        SpDisplayStatusOptions( DEFAULT_STATUS_ATTRIBUTE,
                                SP_STAT_F3_EQUALS_EXIT,
                                0 );
        SpDisplayScreen( SP_SCRN_GET_ADMIN_PASSWORD, 3, 4 );
        
        SpInputDrain();

        AdministratorPassword[0] = TEXT('\0');
        
        GotAPassword = SpGetInput(
            SpValidateAdminPassword,
            27,                     // left edge of edit field.
            NextMessageTopLine - 1,
            (MaxPasswordLength < MY_MAX_PASSWORD_LENGTH) ? MaxPasswordLength : MY_MAX_PASSWORD_LENGTH,
            AdministratorPassword,
            FALSE,
            L'*' );

        if( GotAPassword && wcscmp( AdministratorPassword, TEXT("") ) ) {
        
            //
            // Ask them to re-enter the password so we can make
            // sure we got it right.
            //

            SpDisplayScreen( SP_SCRN_GET_ADMIN_PASSWORD_CONFIRM, 3, 4 );

            SpInputDrain();
            
            ConfirmAdministratorPassword[0] = TEXT('\0');
            
            GotAPassword = SpGetInput( 
                SpValidateAdminPassword,
                27,                     // left edge of edit field.
                NextMessageTopLine - 1,
                MY_MAX_PASSWORD_LENGTH,
                ConfirmAdministratorPassword,
                FALSE,
                L'*' );

            //
            // if the user exited normaly - pressed return,
            // then process the password
            // else recycle back to the first admin password screen
            //
            if (GotAPassword) {
                
                if( !wcscmp(AdministratorPassword, ConfirmAdministratorPassword) ) {
                    //
                    // They match and they're not empty.
                    //
                    Done = TRUE;
                } else {
                    //
                    // They didn't enter the same password.
                    //

                    SpDisplayScreen( SP_SCRN_GET_ADMIN_PASSWORD_FAILURE, 3, 4 );

                    SpDisplayStatusOptions(
                        DEFAULT_STATUS_ATTRIBUTE,
                        SP_STAT_ENTER_EQUALS_CONTINUE,
                        SP_STAT_F3_EQUALS_EXIT,
                        0
                        );
                    SpInputDrain();

                    switch(SpWaitValidKey(AdminValidKeys,NULL,NULL)) {

                        //
                        // User wants to continue.
                        //
                        case ASCI_CR:
                            break;

                        //
                        // User wants to exit.
                        //
                        case KEY_F3:
                            SpConfirmExit();
                            break;
                    }
                }
            }
        }

    } while ( !Done );
    
    
    return TRUE;
}



VOID
SpMigrateDeviceInstanceData(
    VOID
    )
{
    NTSTATUS    status;
    PVOID       tmpWinntSifHandle = NULL;
    ULONG       lineCount, errorLine, lineIndex;
    PWSTR       keyName, keyValue;
    ULONG       ulDisposition, drvInst;
    DWORD       valueData;
    UNICODE_STRING unicodeString, valueName, drvInstString;
    OBJECT_ATTRIBUTES obja;
    HANDLE      hControlClassKey, hClassGuidKey, hClassGuidSubkey;
    HANDLE      hEnumKey, hEnumeratorKey, hDeviceKey, hInstanceKey, hLogConfKey;
    PWSTR       classGuid, classGuidSubkey;
    PWSTR       enumerator, device, instance;

    //
    // Use the asrpnp.sif file, if present, otherwise use winnt.sif.
    //
    if (SetupldrASRPnPSifFileSize != 0) {
        status = SpLoadSetupTextFile(NULL,
                                     SetupldrASRPnPSifFile,
                                     SetupldrASRPnPSifFileSize,
                                     &tmpWinntSifHandle,
                                     &errorLine,
                                     FALSE,
                                     TRUE
                                     );
    } else {
        status = SpLoadSetupTextFile(NULL,
                                     SetupldrWinntSifFile,
                                     SetupldrWinntSifFileSize,
                                     &tmpWinntSifHandle,
                                     &errorLine,
                                     FALSE,
                                     TRUE
                                     );
    }

    if (!NT_SUCCESS(status)) {
        return;
    }

    //
    // Process the section for hash values to migrate
    //
    lineCount = SpCountLinesInSection(tmpWinntSifHandle,
                                      WINNT_DEVICEHASHVALUES_W);
    if (lineCount != 0) {
        //
        // There are hash values in the sif file that need to be migrated.
        // Open the Enum branch of the registry.
        //
        INIT_OBJA(&obja,
                  &unicodeString,
                  L"\\Registry\\Machine\\System\\CurrentControlSet\\Enum");

        status = ZwCreateKey(&hEnumKey,
                             KEY_ALL_ACCESS,
                             &obja,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             &ulDisposition);

        if (NT_SUCCESS(status)) {

            //
            // Make sure that the Enum key has already been created by
            // kernel-mode PnP.  This is important because kernel-mode PnP
            // creates the key with special ACLs.
            //
            ASSERT(ulDisposition == REG_OPENED_EXISTING_KEY);

            for (lineIndex = 0; lineIndex < lineCount; lineIndex++) {

                //
                // key name is the hash value name
                //
                keyName = SpGetKeyName(tmpWinntSifHandle,
                                       WINNT_DEVICEHASHVALUES_W,
                                       lineIndex);
                if ((keyName == NULL) || (wcslen(keyName) == 0)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                               "SETUP: Unable to get the hash value, Section = %ls \n",
                               WINNT_DEVICEHASHVALUES_W));
                    continue;
                }

                //
                // key value index == 0 is the hash value data
                //
                keyValue = SpGetSectionKeyIndex(tmpWinntSifHandle,
                                                WINNT_DEVICEHASHVALUES_W,
                                                keyName, 0);

                if ((keyValue == NULL) || (wcslen(keyValue) == 0)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                               "SETUP: Unable to get the hash value data, Section = %ls, hash = %ls\n",
                               WINNT_DEVICEHASHVALUES_W, keyName));
                    continue;
                }

                RtlInitUnicodeString(&unicodeString, keyValue);
                status = RtlUnicodeStringToInteger(&unicodeString,
                                                   0, // base 10 (or as specified)
                                                   &valueData);
                if (NT_SUCCESS(status)) {
                    RtlInitUnicodeString(&valueName, SpDupStringW(keyName));

                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                               "SETUP: Migrating hash value: %ls = %ls\n",
                               keyName, keyValue));

                    //
                    // Create the hash value under the Enum branch
                    //
                    status = ZwSetValueKey(hEnumKey,
                                           &valueName,
                                           0, // XXX TITLE_INDEX_VALUE
                                           REG_DWORD,
                                           &valueData,
                                           sizeof(DWORD));
                }

                if (!NT_SUCCESS(status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                               "SETUP: Unable to set hash value entry %ws\n",
                               valueName.Buffer));
                }

                SpMemFree(valueName.Buffer);
            }

            //
            // Close the Enum key
            //
            ZwClose(hEnumKey);

        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                       "SETUP: Unable to open Enum key, status == %08lx\n",
                       status));
        }
    }


    //
    // Process the section for class keys to migrate
    //
    lineCount = SpCountLinesInSection(tmpWinntSifHandle,
                                      WINNT_CLASSKEYS_W);
    if (lineCount != 0) {
        //
        // Open the Class key of the registry
        //
        INIT_OBJA(&obja,
                  &unicodeString,
                  L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Class");

        status = ZwCreateKey(&hControlClassKey,
                             KEY_ALL_ACCESS,
                             &obja,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             &ulDisposition);

        if (NT_SUCCESS(status)) {
            //
            // Verify that the key was already present
            //
            ASSERT(ulDisposition == REG_OPENED_EXISTING_KEY);

            //
            // Migrate the Class keys in the sif file
            //
            for (lineIndex = 0; lineIndex < lineCount; lineIndex++) {

                //
                // Index == 0 of each line in the classkeys section is the name
                // of a Class subkey to be created
                //
                keyName = SpGetSectionLineIndex(tmpWinntSifHandle,
                                                WINNT_CLASSKEYS_W,
                                                lineIndex, 0);

                if (keyName == NULL) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                               "SETUP: Unable to get the Class subkey, Section = %ls \n",
                               WINNT_CLASSKEYS_W));
                    continue;
                }

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Migrating class key = %ls. \n", keyName));

                //
                // Make a copy of the class subkey path
                //
                classGuid = SpDupStringW(keyName);
                if (!classGuid) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                               "SETUP: Cannot create the migrated Class subkey %ws\n",
                               keyName));
                    continue;
                }

                //
                // Separate the class GUID key and subkey strings
                //
                classGuidSubkey = wcschr(classGuid, L'\\');
                ASSERT(classGuidSubkey);
                if (classGuidSubkey == NULL) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                               "SETUP: Cannot create the migrated Class subkey %ws\n",
                               keyName));
                    SpMemFree(classGuid);
                    continue;
                }

                *classGuidSubkey = L'\0';
                classGuidSubkey++;

                //
                // Create/open the class GUID key under the Control\Class key
                //
                INIT_OBJA(&obja,
                          &unicodeString,
                          classGuid);

                obja.RootDirectory = hControlClassKey;

                status = ZwCreateKey(&hClassGuidKey,
                                     KEY_ALL_ACCESS,
                                     &obja,
                                     0,
                                     NULL,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL);

                if (NT_SUCCESS(status)) {
                    //
                    // Create/open the class GUID subkey under the class GUID key
                    //
                    INIT_OBJA(&obja,
                              &unicodeString,
                              classGuidSubkey);

                    obja.RootDirectory = hClassGuidKey;

                    status = ZwCreateKey(&hClassGuidSubkey,
                                         KEY_ALL_ACCESS,
                                         &obja,
                                         0,
                                         NULL,
                                         REG_OPTION_NON_VOLATILE,
                                         NULL);

                    if (NT_SUCCESS(status)) {
                        //
                        // Close the Class GUID subkey
                        //
                        ZwClose(hClassGuidSubkey);

                    } else {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                                   "SETUP: Unable to create subkey %ws for class %ws, status == %08lx\n",
                                   classGuid, classGuidSubkey, status));
                    }

                    //
                    // Close the Class GUID key
                    //
                    ZwClose(hClassGuidKey);


                } else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                               "SETUP: Unable to create class key %ws, status == %08lx\n",
                               classGuid, status));
                }

                //
                // Free the allocated string
                //
                SpMemFree(classGuid);

            }

            //
            // Close the Control\Class key
            //
            ZwClose(hControlClassKey);

        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                       "SETUP: Unable to open Control\\Class key, status == %08lx\n",
                       status));
        }
    }


    //
    // Process the section for device instances to migrate
    //
    lineCount = SpCountLinesInSection(tmpWinntSifHandle,
                                      WINNT_DEVICEINSTANCES_W);

    if (lineCount != 0) {
        //
        // Open the Enum key of the registry
        //
        INIT_OBJA(&obja,
                  &unicodeString,
                  L"\\Registry\\Machine\\System\\CurrentControlSet\\Enum");

        status = ZwCreateKey(&hEnumKey,
                             KEY_ALL_ACCESS,
                             &obja,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             &ulDisposition);

        //
        // Verify that the Enum key was already present
        //
        ASSERT(ulDisposition == REG_OPENED_EXISTING_KEY);

        for (lineIndex = 0; lineIndex < lineCount; lineIndex++) {
            //
            // Index == 0 of each line in the deviceinstances section is a
            // device instance key to be created
            //
            keyName = SpGetSectionLineIndex(tmpWinntSifHandle,
                                            WINNT_DEVICEINSTANCES_W,
                                            lineIndex, 0);
            if (keyName == NULL) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                           "SETUP: Unable to get the device instance path, Section = %ls \n",
                           WINNT_DEVICEINSTANCES_W));
                continue;
            }

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Migrating device instance = %ls. \n", keyName));

            //
            // Make a copy of the device instance path
            //
            enumerator = SpDupStringW(keyName);
            if (!enumerator) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                           "SETUP: Cannot copy device instance path %ws\n",
                           keyName));
                continue;
            }

            //
            // Separate the enumerator and device strings
            //
            device = wcschr(enumerator, L'\\');
            ASSERT(device);
            if (device == NULL) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                           "SETUP: Cannot separate device string from device instance path %ws\n",
                           enumerator));
                SpMemFree(enumerator);
                continue;
            }

            *device = L'\0';
            device++;

            //
            // Separate the device and instance strings
            //
            instance = wcschr(device, L'\\');
            ASSERT(instance);
            if (instance == NULL) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                           "SETUP: Cannot separate instance string from device instance path %ws\n",
                           enumerator));
                SpMemFree(enumerator);
                continue;
            }

            *instance = L'\0';
            instance++;

            //
            // Create/open the enumerator key under the Enum key
            //
            INIT_OBJA(&obja,
                      &unicodeString,
                      enumerator);

            obja.RootDirectory = hEnumKey;

            status = ZwCreateKey(&hEnumeratorKey,
                                 KEY_ALL_ACCESS,
                                 &obja,
                                 0,
                                 NULL,
                                 REG_OPTION_NON_VOLATILE,
                                 NULL);

            if (NT_SUCCESS(status)) {
                //
                // Create/open the device subkey under the enumerator key
                //
                INIT_OBJA(&obja,
                          &unicodeString,
                          device);

                obja.RootDirectory = hEnumeratorKey;

                status = ZwCreateKey(&hDeviceKey,
                                     KEY_ALL_ACCESS,
                                     &obja,
                                     0,
                                     NULL,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL);

                //
                // Close the enumerator key
                //
                ZwClose(hEnumeratorKey);

                if (NT_SUCCESS(status)) {
                    //
                    // Create/open the instance subkey under the device key
                    //
                    INIT_OBJA(&obja,
                              &unicodeString,
                              instance);

                    obja.RootDirectory = hDeviceKey;

                    status = ZwCreateKey(&hInstanceKey,
                                         KEY_ALL_ACCESS,
                                         &obja,
                                         0,
                                         NULL,
                                         REG_OPTION_NON_VOLATILE,
                                         &ulDisposition);

                    //
                    // Close the device key
                    //
                    ZwClose(hDeviceKey);

                    if (NT_SUCCESS(status)) {

                        //
                        // If this instance key was newly created, set a value
                        // indicating that it is a special migrated key.
                        //
                        if (ulDisposition == REG_CREATED_NEW_KEY) {
                            valueData = 1;
                            RtlInitUnicodeString(&valueName, L"Migrated");
                            status = ZwSetValueKey(hInstanceKey,
                                                   &valueName,
                                                   0, // XXX TITLE_INDEX_VALUE
                                                   REG_DWORD,
                                                   &valueData,
                                                   sizeof(DWORD));
                            if (!NT_SUCCESS(status)) {
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                                           "SETUP: Unable to set Migrated == 1 for %ws, status == %08lx\n",
                                           keyName, status));
                            }
                        }

                        //
                        // Index == 1 is the UniqueParentID
                        //
                        keyValue = SpGetSectionLineIndex(tmpWinntSifHandle,
                                                         WINNT_DEVICEINSTANCES_W,
                                                         lineIndex, 1);

                        if (keyValue && (wcslen(keyValue) != 0)) {
                            // temporarily use unicodeString for conversion
                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                                       "SETUP:\tUniqueParentID = %ls. \n",
                                       keyValue));
                            RtlInitUnicodeString(&unicodeString, keyValue);
                            status = RtlUnicodeStringToInteger(&unicodeString,
                                                               16,  // base 16
                                                               &valueData);
                            if (NT_SUCCESS(status)) {
                                RtlInitUnicodeString(&valueName, L"UniqueParentID");
                                status = ZwSetValueKey(hInstanceKey,
                                                       &valueName,
                                                       0, // XXX TITLE_INDEX_VALUE
                                                       REG_DWORD,
                                                       &valueData,
                                                       sizeof(DWORD));
                            }
                            if (!NT_SUCCESS(status)) {
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                                           "SETUP: Unable to set UniqueParentID value for %ws, status == %08lx\n",
                                           keyName, status));
                            }
                        }

                        //
                        // Index == 2 is the parent id prefix
                        //
                        keyValue = SpGetSectionLineIndex(tmpWinntSifHandle,
                                                         WINNT_DEVICEINSTANCES_W,
                                                         lineIndex, 2);

                        if (keyValue && (wcslen(keyValue) != 0)) {
                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                                       "SETUP:\tParentIdPrefix = %ls. \n",
                                       keyValue));
                            RtlInitUnicodeString(&unicodeString, keyValue);
                            RtlInitUnicodeString(&valueName, L"ParentIdPrefix");
                            status = ZwSetValueKey(hInstanceKey,
                                                   &valueName,
                                                   0, // XXX TITLE_INDEX_VALUE
                                                   REG_SZ,
                                                   unicodeString.Buffer,
                                                   unicodeString.Length + sizeof(UNICODE_NULL));
                            if (!NT_SUCCESS(status)) {
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                                           "SETUP: Unable to set ParentIdPrefix value for %ws, status == %08lx\n",
                                           keyName, status));
                            }
                        }

                        //
                        // Index == 3 is the class key name
                        //
                        keyValue = SpGetSectionLineIndex(tmpWinntSifHandle,
                                                         WINNT_DEVICEINSTANCES_W,
                                                         lineIndex, 3);

                        if (keyValue && (wcslen(keyValue) > GUID_STRING_LEN)) {
                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:\tClass key = %ls. \n", keyValue));

                            RtlInitUnicodeString(&valueName, REGSTR_VAL_DRIVER);
                            status = ZwSetValueKey(
                                hInstanceKey,
                                &valueName,
                                0,
                                REG_SZ,
                                keyValue,
                                (wcslen(keyValue) + 1) * sizeof(WCHAR));
                            if (!NT_SUCCESS(status)) {
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                                           "SETUP: Unable to set Driver value for %ws, status == %08lx\n",
                                           keyName, status));
                            }

                            //
                            // Migrate the ClassGUID value also (implied from
                            // the class key name), otherwise the class key name
                            // value may be considered invalid.
                            //
                            instance = wcschr(keyValue, L'\\');
                            ASSERT(instance);
                            ASSERT((instance - keyValue + 1) == GUID_STRING_LEN);
                            if ((instance != NULL) && ((instance - keyValue + 1) == GUID_STRING_LEN)) {
                                //
                                // Separate the instance subkey from the class GUID.
                                //
                                *instance = L'\0';

                                RtlInitUnicodeString(&valueName, REGSTR_VAL_CLASSGUID);

                                status = ZwSetValueKey(
                                    hInstanceKey,
                                    &valueName,
                                    0,
                                    REG_SZ,
                                    keyValue,
                                    GUID_STRING_LEN * sizeof(WCHAR));
                                if (!NT_SUCCESS(status)) {
                                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                                               "SETUP: Unable to set ClassGUID value for %ws, status == %08lx\n",
                                               keyName, status));
                                }
                            } else {
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                                           "SETUP: Cannot separate instance string class GUID for %ws\n",
                                           keyName));
                            }
                        }

                        //
                        // Index == 4 is the Service name, migrated for ROOT
                        // enumerated device instances only.
                        //
                        keyValue = SpGetSectionLineIndex(tmpWinntSifHandle,
                                                         WINNT_DEVICEINSTANCES_W,
                                                         lineIndex, 4);

                        if (keyValue && (wcslen(keyValue) != 0)) {
                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:\tService = %ls. \n", keyValue));
                            RtlInitUnicodeString(&unicodeString, keyValue);
                            RtlInitUnicodeString(&valueName, REGSTR_VAL_SERVICE);
                            status = ZwSetValueKey(hInstanceKey,
                                                   &valueName,
                                                   0, // XXX TITLE_INDEX_VALUE
                                                   REG_SZ,
                                                   unicodeString.Buffer,
                                                   unicodeString.Length + sizeof(UNICODE_NULL));
                            if (!NT_SUCCESS(status)) {
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                                           "SETUP: Unable to set Service value for %ws, status == %08lx\n",
                                           keyName, status));
                            }
                        }

                        //
                        // Index == 5 is the BootConfig data, migrated for ROOT
                        // enumerated device instances only.
                        //
                        keyValue = SpGetSectionLineIndex(tmpWinntSifHandle,
                                                         WINNT_DEVICEINSTANCES_W,
                                                         lineIndex, 5);

                        if (keyValue && (wcslen(keyValue) != 0)) {
                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                                       "SETUP:\tBootConfig = %ls. \n",
                                       keyValue));
                            //
                            // Create/open the non-volatile LogConf subkey,
                            // under the instance key.
                            //
                            INIT_OBJA(&obja,
                                      &unicodeString,
                                      L"LogConf");

                            obja.RootDirectory = hInstanceKey;

                            status = ZwCreateKey(&hLogConfKey,
                                                 KEY_ALL_ACCESS,
                                                 &obja,
                                                 0,
                                                 NULL,
                                                 REG_OPTION_NON_VOLATILE,
                                                 &ulDisposition);
                            if (NT_SUCCESS(status) && (ulDisposition == REG_CREATED_NEW_KEY)) {
                                DWORD i, length;
                                WCHAR szByte[3];
                                ULONG ulByte;
                                PBYTE pBootConfig = NULL;

                                //
                                // Since each character is just a nibble, make
                                // sure we have an even number of characters,
                                // else we won't have a whole number of bytes.
                                //
                                length = wcslen(keyValue);
                                ASSERT((length % 2) == 0);

                                pBootConfig = SpMemAlloc(length/2);
                                if (pBootConfig) {
                                    //
                                    // Convert the BootConfig string buffer data
                                    // to bytes.
                                    //
                                    for (i = 0; i < length; i+=2) {
                                        szByte[0] = keyValue[i];
                                        szByte[1] = keyValue[i+1];
                                        szByte[2] = UNICODE_NULL;

                                        RtlInitUnicodeString(&unicodeString, szByte);

                                        status = RtlUnicodeStringToInteger(&unicodeString,
                                                                           16,
                                                                           &ulByte);
                                        ASSERT(NT_SUCCESS(status));
                                        ASSERT(ulByte <= 0xFF);

                                        pBootConfig[i/2] = (BYTE)ulByte;

                                    }

                                    RtlInitUnicodeString(&valueName, REGSTR_VAL_BOOTCONFIG);
                                    status = ZwSetValueKey(hLogConfKey,
                                                           &valueName,
                                                           0, // XXX TITLE_INDEX_VALUE
                                                           REG_RESOURCE_LIST,
                                                           pBootConfig,
                                                           length/2);
                                    if (!NT_SUCCESS(status)) {
                                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                                                   "SETUP: Unable to set BootConfig value for %ws, status == %08lx\n",
                                                   keyName, status));
                                    }

                                    //
                                    // Free the allocated BootConfig buffer.
                                    //
                                    SpMemFree(pBootConfig);

                                } else {
                                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                                               "SETUP: Unable to allocate BootConfig buffer for %ws\n",
                                               keyName));
                                }
                                //
                                // Close the LogConf key
                                //
                                ZwClose(hLogConfKey);
                            }
                        }

                        //
                        // Index == 6 is the FirmwareIdentified value, migrated for ROOT
                        // enumerated device instances only.
                        //
                        keyValue = SpGetSectionLineIndex(tmpWinntSifHandle,
                                                         WINNT_DEVICEINSTANCES_W,
                                                         lineIndex, 6);

                        if (keyValue && (wcslen(keyValue) != 0)) {
                            // temporarily use unicodeString for conversion
                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                                       "SETUP:\tFirmwareIdentified = %ls. \n",
                                       keyValue));
                            RtlInitUnicodeString(&unicodeString, keyValue);
                            valueData = 0;
                            status = RtlUnicodeStringToInteger(&unicodeString,
                                                               16,  // base 16
                                                               &valueData);
                            if (NT_SUCCESS(status) && valueData != 0) {
                                RtlInitUnicodeString(&valueName, L"FirmwareIdentified");
                                status = ZwSetValueKey(hInstanceKey,
                                                       &valueName,
                                                       0, // XXX TITLE_INDEX_VALUE
                                                       REG_DWORD,
                                                       &valueData,
                                                       sizeof(DWORD));
                            }
                            if (!NT_SUCCESS(status)) {
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                                           "SETUP: Unable to set FirmwareIdentified value for %ws, status == %08lx\n",
                                           keyName, status));
                            }
                        }

                        //
                        // Close the instance key
                        //
                        ZwClose(hInstanceKey);

                    } else {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                                   "SETUP: Unable to create instance subkey %ws for device %ws, status == %08lx\n",
                                   instance, device, status));
                    }



                } else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                               "SETUP: Unable to create device subkey %ws for enumerator %ws, status == %08lx\n",
                               device, enumerator, status));
                }

            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                           "SETUP: Unable to create enumerator subkey %ws, status == %08lx\n",
                           enumerator, status));
            }

            //
            // Free the allocated device instance path string
            //
            SpMemFree(enumerator);
        }

        //
        // Close the Enum key
        //
        ZwClose(hEnumKey);
    }

    //
    // Free the loaded sif file
    //
    SpFreeTextFile(tmpWinntSifHandle);
}

BOOL
SpGetPnPDeviceInfo(
    IN PWSTR DeviceId,
    IN PSETUP_PNP_HARDWARE_ID HardwareIdDatabase,
    OUT PWSTR*  ServiceName,
    OUT PWSTR*  ClassGuid
    )
/*++

Routine Description:

    This routine searches the hardware id database, for an entry that matches
    the hardware id passed as parameter.
    If an entry is found, then the function returns the name of the service
    associated to the hardware id, and its ClassGUID (if any).

    Since this function is called by SpPnpNotificationCallback, it should not
    use TemporaryBuffer.
    If a temporary buffer is needed, then this function should allocate its own.

Arguments:

    HardwareId - Pointer to a hardware id string.

    ServiceName - On return, it will contain the pointer to the service name
                  for the device.

    ClassGuid - On return, it will contain the pointer the class GUID for
                the device.

Return Value:

    Returns TRUE if the HardwareId was found on the database,
    or FALSE otherwise.

--*/
{
    PWCHAR s,lastsep;
    BOOLEAN DeviceFound;
    PSETUP_PNP_HARDWARE_ID p;


    lastsep = DeviceId;
    for(s=DeviceId; *s; s++) {
        if((*s == L'*') || (*s == L'\\')) {
            lastsep = s+1;
        }
    }

    DeviceFound = FALSE;
    for(p=HardwareIdDatabase; p; p=p->Next) {
        //
        // Check for a direct match
        //
        if(!_wcsicmp(p->Id,DeviceId)) {
            *ServiceName = p->DriverName;
            *ClassGuid = p->ClassGuid;
            DeviceFound = TRUE;
            break;
        }

        //
        // If there was a '*' check for a component match
        //
        if((p->Id[0] == L'*') && !_wcsicmp(p->Id+1,lastsep)) {
            *ServiceName = p->DriverName;
            *ClassGuid = p->ClassGuid;
            DeviceFound = TRUE;
            break;
        }
    }

    return(DeviceFound);
}


NTSTATUS
SpPnPNotificationCallBack(
    IN PVOID    NotificationStructure,
    IN PVOID    Context
    )

/*++

Routine Description:

    This is the callback function called by P&P, to inform textmode
    setup of a new hardware detected.

Arguments:

    NotificationStructure - Pointer to a structure of type
                            SETUP_DEVICE_ARRIVAL_NOTIFICATION.

    Context - Context information that textmode setup provided during
              notification registration.


Return Value:

    Status is returned.

--*/

{
    NTSTATUS            Status;
    UNICODE_STRING      UnicodeString;
    HANDLE              hKey;
    ULONG               Length;
    PWSTR               Data = NULL;
    ULONG               DataSize;
    PWSTR               ServiceName = NULL;
    PWSTR               ClassGuid = NULL;
    PWSTR               p;
    PWSTR               HardwareID = NULL;
    ULONG               i;
    BOOLEAN             SerialPortDetected = FALSE;
    PVOID               Buffer = NULL;
    ULONG               BufferSize;
    PWSTR               ValueNames[] = {
                                       REGSTR_VAL_HARDWAREID,
                                       REGSTR_VAL_COMPATIBLEIDS
                                       };
    HARDWAREIDLIST     *MyHardwareIDList = HardwareIDList;


    if (!((PSETUP_DEVICE_ARRIVAL_NOTIFICATION)NotificationStructure)->InstallDriver) {
        return STATUS_SUCCESS;
    }


    //
    //  Retrieve the service name for the device detected.
    //  To do this, we need to get each each hardware id, and determine
    //  if there is a service name associated with the id. If there is
    //  no service associated with any of the hardware ids, then we try
    //  find a service name associated the compatible id.
    //  If we can't find a service name for this device at all, then we don't
    //  need this device during textmode setup (ie, we don't install this
    //  device during textmode setup).
    //

    //
    //  Allocate a big buffer to read the registry value (service name).
    //  Note that this function should not use TemporaryBuffer, since
    //  this function can be called asyncronously at any point during setup,
    //  and TemporaryBuffer may be in use.
    //
    BufferSize = 4*1024;
    Buffer = SpMemAlloc( BufferSize );
    if( Buffer == NULL ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPnPNotificationCallBack() failed to allocate memory.\n"));
        Status = STATUS_NO_MEMORY;
        goto CleanUp;
    }
    for( i = 0; i < sizeof(ValueNames)/sizeof(PWSTR); i++ ) {

        RtlInitUnicodeString(&UnicodeString, ValueNames[i]);

        Status = ZwQueryValueKey(((PSETUP_DEVICE_ARRIVAL_NOTIFICATION)NotificationStructure)->EnumEntryKey,
                                 &UnicodeString,
                                 KeyValuePartialInformation,
                                 Buffer,
                                 BufferSize,
                                 &Length
                                 );

        if( !NT_SUCCESS(Status) && ( Status == STATUS_BUFFER_OVERFLOW ) ) {
            BufferSize = Length;
            Buffer = SpMemRealloc( Buffer, BufferSize );
            Status = ZwQueryValueKey(((PSETUP_DEVICE_ARRIVAL_NOTIFICATION)NotificationStructure)->EnumEntryKey,
                                     &UnicodeString,
                                     KeyValuePartialInformation,
                                     Buffer,
                                     Length,
                                     &Length
                                    );
        }

        if( !NT_SUCCESS(Status) ) {
            if( i == 0 ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpPnPNotificationCallBack() failed to retrieve HardwareID. Status = %lx \n", Status));
                continue;
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpPnPNotificationCallBack() failed to retrieve HardwareID and CompatibleID. Status = %lx \n", Status));
                SpMemFree( Buffer );
                goto CleanUp;
            }
        }
        Data = (PWCHAR)(((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data);
        DataSize = ((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->DataLength;
        for( p = Data;
             (p < (PWSTR)((PUCHAR)Data + DataSize) && (*p != (WCHAR)'\0'));
             p += wcslen( p ) + 1 ) {
            //
            //  Retrieve the service name for this device
            //
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: HardwareID = %ls. \n", p));
            ServiceName = NULL;
            ClassGuid = NULL;

            //
            // Now remember our list of devices for later use.
            //
            MyHardwareIDList = SpMemAlloc( sizeof(HARDWAREIDLIST) );
            MyHardwareIDList->HardwareID = SpDupStringW( p );
            MyHardwareIDList->Next = HardwareIDList;
            HardwareIDList = MyHardwareIDList;


            if( SpGetPnPDeviceInfo(p,
                                   (PSETUP_PNP_HARDWARE_ID)Context,
                                   &ServiceName,
                                   &ClassGuid) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: HardwareID = %ls, ServiceName = %ls. \n", p, ServiceName));

                if (RemoteSysPrepSetup) {
                    HardwareID = SpMemAlloc((wcslen(p) + 1) * sizeof(WCHAR));
                    if (HardwareID != NULL) {
                        wcscpy(HardwareID, p);
                    }
                }

                break;
            }
        }
        if( ServiceName != NULL ) {
            break;
        }
    }
    if( ServiceName == NULL ) {
        //
        //  We just don't care about this device during text setup phase
        //
        SpMemFree( Buffer );
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto CleanUp;
    }

    //
    //  Find out if this device is a mouse or a USB keyboard
    //
    if( !_wcsicmp( ServiceName, L"i8042prt" ) ) {
        if( !_wcsicmp( ClassGuid, KeyboardGuidString ) ) {
            //
            //  This is a keyboard
            //
            StdKeyboardDetected = TRUE;
        } else if( !_wcsicmp( ClassGuid, MouseGuidString ) ) {
            //
            //  This is a Mouse Port compatible mouse
            //
            PS2MouseDetected = TRUE;
        }
    } else if( !_wcsicmp( ServiceName, L"sermouse" ) ) {
        SerMouseDetected = TRUE;
    } else if( !_wcsicmp( ServiceName, L"mouhid" ) ) {
        UsbMouseDetected = TRUE;
    } else if( !_wcsicmp( ServiceName, L"kbdhid" ) ) {
        UsbKeyboardDetected = TRUE;
    } else if( !_wcsicmp( ServiceName, L"serial" ) ) {
        SerialPortDetected = TRUE;
    }


    //
    // At this point Buffer is no longer needed, so we free it.
    //
    SpMemFree( Buffer );
    BufferSize = 0;
    Buffer = NULL;

    //
    //  If the driver for this device was already loaded, then the device may
    //  be needed during textmode setup.
    //  Create a value entry called "Service" of type REG_SZ, with the name
    //  of the service associated with this device only if the service string is not
    //  empty as we allow inserting only a GUID.
    //
    if((NULL != ServiceName) && (UNICODE_NULL != ServiceName[0])){

        RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_SERVICE);
        Status = ZwSetValueKey( ((PSETUP_DEVICE_ARRIVAL_NOTIFICATION)NotificationStructure)->EnumEntryKey,
                                &UnicodeString,
                                0,
                                REG_SZ,
                                ServiceName,
                                (wcslen( ServiceName ) + 1)*sizeof(WCHAR) );

    }

    if(NT_SUCCESS( Status ) && ( NULL != ClassGuid ) ) {


        RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_CLASSGUID);
        Status = ZwSetValueKey( ((PSETUP_DEVICE_ARRIVAL_NOTIFICATION)NotificationStructure)->EnumEntryKey,
                                &UnicodeString,
                                0,
                                REG_SZ,
                                ClassGuid,
                                (wcslen(ClassGuid) + 1) * sizeof(WCHAR));
    }


    if( NT_SUCCESS( Status ) ) {
        //
        // If we successfully set the controlling service value, then we should also set
        // the CONFIGFLAG_FINISH_INSTALL config flag, so that we'll finish the installation
        // of this device later (i.e., when we're in user-mode and have access to the device
        // installer APIs, class installers, etc.)
        //
        ULONG ConfigFlags = 0x00000400;     // CONFIGFLAG_FINISH_INSTALL from sdk\inc\regstr.h

        RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_CONFIGFLAGS);
        Status = ZwSetValueKey( ((PSETUP_DEVICE_ARRIVAL_NOTIFICATION)NotificationStructure)->EnumEntryKey,
                                &UnicodeString,
                                0,
                                REG_DWORD,
                                &ConfigFlags,
                                sizeof(ConfigFlags) );

        if( !NT_SUCCESS( Status ) ) {
            goto CleanUp;
        }

        //
        // If we are doing an installation of a SysPrep image, then we want to
        // remember this device so that we can transfer it as a 'CriticalDevice'
        // to the SysPrep hives in SpPatchSysPrepImage()
        //
        if (RemoteSysPrepSetup && (HardwareID != NULL)) {

            OBJECT_ATTRIBUTES Obj;
            HANDLE TmpHandle;
            HANDLE NodeHandle;
            PWCHAR pwch;

            BufferSize = 4*1024;
            Buffer = SpMemAlloc( BufferSize );

            if( Buffer == NULL ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPnPNotificationCallBack() failed to allocate memory.\n"));
                goto CleanSysPrepSetup;
            }

            INIT_OBJA(&Obj,
                      &UnicodeString,
                      L"\\Registry\\Machine\\System\\CurrentControlSet\\Control"
                     );

            Status = ZwOpenKey(&TmpHandle, KEY_ALL_ACCESS, &Obj);

            if( !NT_SUCCESS(Status) ) {
                goto CleanSysPrepSetup;
            }

            INIT_OBJA(&Obj, &UnicodeString, L"CriticalDeviceDatabase");

            Obj.RootDirectory = TmpHandle;

            Status = ZwCreateKey(&NodeHandle,
                                 KEY_ALL_ACCESS,
                                 &Obj,
                                 0,
                                 NULL,
                                 0,
                                 NULL
                                );

            ZwClose(TmpHandle);

            if( !NT_SUCCESS(Status) ) {
                goto CleanSysPrepSetup;
            }

            //
            // Now create subkey with the device name
            //

            for (pwch = HardwareID; *pwch != UNICODE_NULL; pwch++) {
                if (*pwch == L'\\') {
                    *pwch = L'#';
                }
            }

            INIT_OBJA(&Obj, &UnicodeString, HardwareID);

            Obj.RootDirectory = NodeHandle;

            Status = ZwCreateKey(&TmpHandle,
                                 KEY_ALL_ACCESS,
                                 &Obj,
                                 0,
                                 NULL,
                                 0,
                                 NULL
                                );

            ZwClose(NodeHandle);

            if( !NT_SUCCESS(Status) ) {
                goto CleanSysPrepSetup;
            }

            //
            // Fill in service value now
            //
            RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_SERVICE);
            ZwSetValueKey(TmpHandle,
                          &UnicodeString,
                          0,
                          REG_SZ,
                          ServiceName,
                          (wcslen( ServiceName ) + 1)*sizeof(WCHAR)
                         );

            if (ClassGuid != NULL) {

                RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_CLASSGUID);
                ZwSetValueKey(TmpHandle,
                              &UnicodeString,
                              0,
                              REG_SZ,
                              ClassGuid,
                              (wcslen( ClassGuid ) + 1)*sizeof(WCHAR)
                             );

            }

            ZwClose(TmpHandle);

CleanSysPrepSetup:

            if (Buffer != NULL) {
                SpMemFree( Buffer );
                BufferSize = 0;
                Buffer = NULL;
            }

        }

        //
        //  Hack for serial
        //
        if( SerialPortDetected ) {
            // DWORD   PollingPeriod = 0x32;
            WCHAR   SerialUpperFilters[] = L"serenum\0";

#if 0       // remove polling, will be enabled after NT5.0
            Status = IoOpenDeviceRegistryKey( ((PSETUP_DEVICE_ARRIVAL_NOTIFICATION)NotificationStructure)->PhysicalDeviceObject,
                                              PLUGPLAY_REGKEY_DEVICE,
                                              MAXIMUM_ALLOWED,
                                              &hKey );

            if( !NT_SUCCESS( Status ) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: IoOpenDeviceRegistryKey() failed. Status = %lx. \n", Status));
                goto CleanUp;
            }

            RtlInitUnicodeString(&UnicodeString, L"PollingPeriod");
            Status = ZwSetValueKey( hKey,
                                    &UnicodeString,
                                    0,
                                    REG_DWORD,
                                    &PollingPeriod,
                                    sizeof(PollingPeriod) );
            ZwClose( hKey );

            if( !NT_SUCCESS( Status ) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ZwSetValueKey() failed to create PollingPeriod. Status = %lx. \n", Status));
                goto CleanUp;
            }
#endif

            RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_UPPERFILTERS);
            Status = ZwSetValueKey( ((PSETUP_DEVICE_ARRIVAL_NOTIFICATION)NotificationStructure)->EnumEntryKey,
                                    &UnicodeString,
                                    0,
                                    REG_MULTI_SZ,
                                    SerialUpperFilters,
                                    sizeof(SerialUpperFilters) );

            if( !NT_SUCCESS( Status ) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ZwSetValueKey() failed to create SerialUpperFilters. Status = %lx. \n", Status));
                goto CleanUp;
            }
        }
    }

CleanUp:

    if (HardwareID != NULL) {
        SpMemFree(HardwareID);
    }
    return Status;
}


PCOMMAND_INTERPRETER_ROUTINE _CmdRoutine;


#ifdef _IA64_

VOID    
SpAssignDriveLetterToESP(
    VOID
    )
/*++

Routine Description:

    This routine assigns a drive letter to ESP to make it accessible 
    from the Recovery Console   

Arguments:
    
    None

Return Value:
    
    None

--*/                    
{
    PDISK_REGION    SystemPartitionArea = NULL;
    ULONG           Index;
    
    //
    // Select a system partition from among those defined in NV-RAM.
    //
    for(Index = 0; (Index < HardDiskCount) && (!SystemPartitionArea); Index++) {
        SystemPartitionArea = SPPT_GET_PRIMARY_DISK_REGION(Index);

        while (SystemPartitionArea) {

            if (SPPT_IS_REGION_SYSTEMPARTITION(SystemPartitionArea)) {
                break;  // found the required region                 
            }
            
            SystemPartitionArea = SystemPartitionArea->Next;
        }
    }


    //
    // If a system partition exists
    //
    if (SystemPartitionArea) {
        PWCHAR MyTempBuffer = NULL;

        //
        // Retrieve NT pathname for this region.
        //
        MyTempBuffer = (PWCHAR)SpMemAlloc(MAX_PATH);

        if (MyTempBuffer) {
            MyTempBuffer[0] = UNICODE_NULL;
            
            SpNtNameFromRegion(SystemPartitionArea,
                               MyTempBuffer,
                               MAX_PATH,
                               PrimaryArcPath);
            //
            // Assign the drive letter to the ESP
            //
            SystemPartitionArea->DriveLetter = SpGetDriveLetter(MyTempBuffer, NULL);
            
            SpMemFree(MyTempBuffer);
        } else {
            //
            // No memory...
            //
            KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                "SETUP: SpPtInitializeDiskAreas: SpMemAlloc failed!\n" )); 
        }
    }        
}

#endif

VOID
CommandConsoleInterface(
    PCOMMAND_INTERPRETER_ROUTINE CmdRoutine
    )
{
    _CmdRoutine = CmdRoutine;
}


ULONG
SpStartCommandConsole(
    PVOID SifHandle,
    PWSTR SetupSourceDevicePath,
    PWSTR DirectoryOnSetupSource
    )
{
    #define CMDCONS_NAME L"SPCMDCON.SYS"
    NTSTATUS            Status;
    static BOOLEAN      Loaded = FALSE;
    PWCHAR              FullName;
    PWCHAR              ServiceKey;
    UNICODE_STRING      ServiceKeyU;
    PWSTR               pwstr;
    ULONG               rc;
    BOOLEAN             b;
    OBJECT_ATTRIBUTES   objectAttributes;
    UNICODE_STRING      unicodeString;
    IO_STATUS_BLOCK     ioStatusBlock;
    HANDLE              hFile;
    PWSTR               Tagfile;
    PWSTR               Description;
    PWSTR               MediaShortName;
    ULONG               MediaType=INDEX_WHICHBOOTMEDIA;
    ULONG               LoadCount;

    extern PVOID KeyboardTable;


    //
    // Let JPN/KOR user select keyboard type before running Command Console.
    //
    // SplangSelectKeyboard & SplangReinitializeKeyboard are from spddlang.sys.
    //
    // These two functions only affect JPN/KOR builds.
    //
    // They are stub functions on US build and do nothing.
    //
    // 0xFF in SplangSelectKeyboard is a tag, such that it knows this is
    // called from Command Console.
    //

    if (ConsoleFromWinnt32) {
        SplangSelectKeyboard(
            FALSE,
            NULL,
            0xFF,
            SifHandle,
            HardwareComponents
        );

        SplangReinitializeKeyboard(
            FALSE,
            SifHandle,
            DirectoryOnBootDevice,
            &KeyboardTable,
            HardwareComponents
        );
    }

    pwstr = TemporaryBuffer;

    //
    // Form the full name of the device driver file.
    //
    wcscpy(pwstr,NtBootDevicePath);
    SpConcatenatePaths(pwstr,DirectoryOnBootDevice);
    SpConcatenatePaths(pwstr,CMDCONS_NAME);
    FullName = SpDupStringW(pwstr);

    //
    // check to see if the file exists on the source media
    // if not then prompt for the correct media
    //

    SpStringToLower(pwstr);
    if(wcsstr(pwstr,L"cdrom"))
        MediaType = INDEX_WHICHMEDIA;
    else if(wcsstr(pwstr,L"floppy"))
        MediaType = INDEX_WHICHBOOTMEDIA;

    INIT_OBJA(&objectAttributes,&unicodeString,FullName);

    MediaShortName = SpLookUpValueForFile(SifHandle,CMDCONS_NAME,MediaType,TRUE);
    SpGetSourceMediaInfo(SifHandle,MediaShortName,&Description,&Tagfile,NULL);


    LoadCount = 0;

    do {
        Status = ZwOpenFile(
            &hFile,
            FILE_GENERIC_READ,
            &objectAttributes,
            &ioStatusBlock,
            0,
            0
            );

        if (NT_SUCCESS(Status)) {
            ZwClose(hFile);
        } else {
            if (!SpPromptForDisk(
                    Description,
                    NtBootDevicePath,
                    CMDCONS_NAME,
                    TRUE,             // Always prompt for at least once
                    TRUE,             // Allow user to cancel
                    FALSE,            // No multiple prompts
                    NULL              // don't care about redraw flag
                    ))
            {
              break;
            }

            //
            // try once more after prompting for disk
            //
            LoadCount++;
        }
    } while (!NT_SUCCESS(Status) && (LoadCount < 2));

    if (!NT_SUCCESS(Status)) {
      SpStartScreen(
              SP_CMDCONS_NOT_FOUND,
              0,
              0,
              TRUE,
              TRUE,
              ATT_FG_INTENSE | ATT_FG_WHITE | ATT_BG_BLACK
              );

      SpInputDrain();
      while(SpInputGetKeypress() != KEY_F3);

      SpMemFree(FullName);

      return 0;
    }

    //
    // Create a service entry for the driver.
    //
    ServiceKey = NULL;
    Status = SpCreateServiceEntry(FullName,&ServiceKey);

    SpMemFree(FullName);

    if(!NT_SUCCESS(Status)) {
        return 0;
    }

    RtlInitUnicodeString(&ServiceKeyU,ServiceKey);

again:
    if(!Loaded) {

        Status = ZwLoadDriver(&ServiceKeyU);

        if(NT_SUCCESS(Status)) {
            Loaded = TRUE;
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to load %s (%lx)\n",CMDCONS_NAME,Status));
        }
    }

    if(Loaded) {
        Block.VideoVars = &VideoVars;
        Block.TemporaryBuffer = TemporaryBuffer;
        Block.TemporaryBufferSize = sizeof(TemporaryBuffer);
        Block.UsetupProcess = UsetupProcess;
        Block.BootDevicePath = NtBootDevicePath;
        Block.DirectoryOnBootDevice = DirectoryOnBootDevice;
        Block.SifHandle = SifHandle;
        Block.SetupSourceDevicePath = SetupSourceDevicePath;
        Block.DirectoryOnSetupSource = DirectoryOnSetupSource;

        if (HeadlessTerminalConnected) {
            Block.VideoVars->ScreenHeight = HEADLESS_SCREEN_HEIGHT+1;
        }

        // make the global variable point to the block
        gpCmdConsBlock = &Block;

        ConsoleRunning = TRUE;

#ifdef _IA64_
        //
        // Make the ESP visible so that it can be accessed from
        // Recovery Console.
        //
        SpAssignDriveLetterToESP();
#endif
      
        rc = _CmdRoutine(&Block);
        ConsoleRunning = FALSE;

        if (rc == 1) {
            Status = ZwUnloadDriver(&ServiceKeyU);
            if(NT_SUCCESS(Status)) {
                Loaded = FALSE;
                goto again;
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to un-load %s (%lx)\n",CMDCONS_NAME,Status));
            }
        }

#if 0
        // why is this here? -matth 02/12/2001
        //
        // In the non-local case, this gets sent to a remote console,
        // then stays there until the machine reboots and pasts post.
        // This can take a really long time and confuses end users.
        //
        SpDisplayHeaderText(
            SpGetHeaderTextId(),
            DEFAULT_ATTRIBUTE
            );
#endif

    }

    SpMemFree(ServiceKey);
    return 0;
}


NTSTATUS
SpInitialize0(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Initialize the setup device driver.  This includes initializing
    the memory allocator, saving away pieces of the os loader block,
    and populating the registry with information about device drivers
    that setupldr loaded for us.

Arguments:

    DriverObject - supplies pointer to driver object for setupdd.sys.

Return Value:

    Status is returned.

--*/

{
    PLOADER_PARAMETER_BLOCK loaderBlock;
    PSETUP_LOADER_BLOCK setupLoaderBlock;
    PLIST_ENTRY nextEntry;
    PBOOT_DRIVER_LIST_ENTRY bootDriver;
    PWSTR ServiceName;
    NTSTATUS Status = STATUS_SUCCESS;
    PWSTR imagePath;
    PWSTR registryPath;

    UNICODE_STRING  GuidString;

    //
    // Fetch a pointer to the os loader block and setup loader block.
    //
    loaderBlock = *(PLOADER_PARAMETER_BLOCK *)KeLoaderBlock;
    setupLoaderBlock = loaderBlock->SetupLoaderBlock;

    if ( (setupLoaderBlock->Flags & SETUPBLK_FLAGS_CONSOLE) != 0 ) {
        ForceConsole = TRUE;
    }

    if (setupLoaderBlock->Flags & SETUPBLK_FLAGS_ROLLBACK) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Rollback enabled through osloadoptions"));
        Win9xRollback = TRUE;
    }


    //
    // Phase 0 display initialization.
    //
    SpvidInitialize0(loaderBlock);

    //
    // Make a copy of the ARC pathname from which we booted.
    // This is guaranteed to be the ARC equivalent of \systemroot.
    //
    ArcBootDevicePath = SpToUnicode(loaderBlock->ArcBootDeviceName);

    if ( (setupLoaderBlock->Flags & SETUPBLK_FLAGS_IS_REMOTE_BOOT) != 0 ) {

        PUCHAR p;
        PUCHAR q;

        //
        // This is a remote boot setup. NtBootPathName is of the form
        // \<server>\<share>\setup\<install-directory>\<platform>.
        // System initialization (in ntos\fstub\drivesup.c, routine
        // xHalIoAssignDriveLetters) has assigned the C: drive to point to
        // \Device\LanmanRedirector\<server>\<share>\setup\<install-directory>.
        // DirectoryOnBootDevice should contain the path that needs to be
        // added to C: in order to access files from user mode. So to
        // calculate it, we want to start at the backslash before <platform>.
        //
        // N.B. We know that the strrchr calls below will not return NULL,
        //      because xHalIoAssignDriveLetters would have bugchecked if
        //      the string in NtBootPathName was malformed.
        //

        ASSERT( _stricmp( loaderBlock->ArcBootDeviceName, "net(0)" ) == 0 );

        RemoteBootSetup = TRUE;

        if (setupLoaderBlock->Flags & SETUPBLK_FLAGS_SYSPREP_INSTALL) {
            RemoteSysPrepSetup = TRUE;
            RemoteIMirrorFilePath = SpDupString(setupLoaderBlock->NetBootIMirrorFilePath);
            RemoteServerIpAddress = setupLoaderBlock->ServerIpAddress;
            RtlCopyMemory(&RemoteSysPrepNetCardInfo, setupLoaderBlock->NetbootCardInfo, sizeof(NET_CARD_INFO));
        }

        p = strrchr( loaderBlock->NtBootPathName, '\\' );
        ASSERT( p != NULL );
        if (!p)
        return STATUS_OBJECT_PATH_INVALID;
        if ( *(p+1) == 0 ) {

            //
            // NtBootPathName ends with a backslash, so we need to back up
            // to the previous backslash.
            //

            q = p;
            *q = 0;
            p = strrchr( loaderBlock->NtBootPathName, '\\' );   // find last separator
            ASSERT( p != NULL );
            *q = '\\';
        }

        if (!p)
        return STATUS_OBJECT_PATH_INVALID; // shut up PREfix.
        DirectoryOnBootDevice = SpToUnicode(p);
        SpStringToUpper(DirectoryOnBootDevice);

        //
        // Save this -- it is the part of loaderBlock->NtBootPathName that
        // is before the part we just copied to DirectoryOnBootDevice,
        // of the form \<server>\<share>\setup\<install-directory>.
        // NtBootDeviceName will be initially set up as \Device\LanmanRedirector
        // and DirectoryOnBootDevice was just set to be be only \<platform>
        // (so user-mode access works, see discussion above). We save the
        // intervening path and append it to NtBootDeviceName, so that
        // kernel-mode access that uses NtBootDeviceName + DirectoryOnBootDevice
        // will go to the correct path.
        //

        *p = 0;
        RemoteIMirrorBootDirectoryPrefix = SpToUnicode(loaderBlock->NtBootPathName);
        *p = '\\';

        if (setupLoaderBlock->NetBootAdministratorPassword[0] != '\0') {

            //
            // The Admin password that came through the setupldr block may not be terminated.
            // Copy it into a temporary buffer, terminate it, and then SpToUnicode it.
            //
            UCHAR TmpNetBootAdministratorPassword[NETBOOT_ADMIN_PASSWORD_LEN+1] = {0};

            RtlMoveMemory( TmpNetBootAdministratorPassword, 
                           setupLoaderBlock->NetBootAdministratorPassword,
                           NETBOOT_ADMIN_PASSWORD_LEN );
            TmpNetBootAdministratorPassword[NETBOOT_ADMIN_PASSWORD_LEN] = '\0';
            NetBootAdministratorPassword =
                    SpToUnicode( TmpNetBootAdministratorPassword );
        } else if (setupLoaderBlock->NetBootAdministratorPassword[NETBOOT_ADMIN_PASSWORD_LEN-1] == 0xFF) {
            //
            // this indicates that the administrator password was blank.
            //
            NetBootAdministratorPassword = SpToUnicode( "" );
        }

    } else {
        DirectoryOnBootDevice = SpToUnicode(loaderBlock->NtBootPathName);
        SpStringToUpper(DirectoryOnBootDevice);
    }


    //
    // Make a copy of the image of the setup information file.
    //
    SetupldrInfoFileSize = setupLoaderBlock->IniFileLength;
    SetupldrInfoFile = SpMemAlloc(SetupldrInfoFileSize);
    RtlMoveMemory(SetupldrInfoFile,setupLoaderBlock->IniFile,SetupldrInfoFileSize);

    SP_SET_UPGRADE_GRAPHICS_MODE(FALSE);

    //
    // Make a copy of the image of the winnt.sif file.
    //
    SetupldrWinntSifFileSize = setupLoaderBlock->WinntSifFileLength;

    if ( SetupldrWinntSifFileSize != 0 ) {
        NTSTATUS    Status;
        ULONG       ErrorLine;

        SetupldrWinntSifFile = SpMemAlloc(SetupldrWinntSifFileSize);
        RtlMoveMemory(SetupldrWinntSifFile,setupLoaderBlock->WinntSifFile,SetupldrWinntSifFileSize);

        Status = SpLoadSetupTextFile(NULL,
                    SetupldrWinntSifFile,
                    SetupldrWinntSifFileSize,
                    &WinntSifHandle,
                    &ErrorLine,
                    FALSE,
                    TRUE);

        if (NT_SUCCESS(Status)) {
            PWSTR NtUpgradeValue = SpGetSectionKeyIndex(WinntSifHandle,
                                        SIF_DATA, WINNT_D_NTUPGRADE_W, 0);

            if(NtUpgradeValue && !_wcsicmp(NtUpgradeValue, WINNT_A_YES_W)) {
                SP_SET_UPGRADE_GRAPHICS_MODE(TRUE);
                IsNTUpgrade = UpgradeFull;
            } else {
                PWSTR Win9xUpgradeValue = SpGetSectionKeyIndex(WinntSifHandle,
                                            SIF_DATA, WINNT_D_WIN95UPGRADE_W, 0);

                if (Win9xUpgradeValue && !_wcsicmp(Win9xUpgradeValue, WINNT_A_YES_W)) {
                    SP_SET_UPGRADE_GRAPHICS_MODE(TRUE);
                }
            }
        } else {
            WinntSifHandle = NULL;
        }
    } else {
        SetupldrWinntSifFile = NULL;
    }

#ifdef _GRAPHICS_TESTING_

    SP_SET_UPGRADE_GRAPHICS_MODE(TRUE);

#endif

    //
    // Make a copy of the image of the asrpnp.sif file.
    //
    SetupldrASRPnPSifFileSize = setupLoaderBlock->ASRPnPSifFileLength;
    if (SetupldrASRPnPSifFileSize != 0) {
        SetupldrASRPnPSifFile = SpMemAlloc(SetupldrASRPnPSifFileSize);
        RtlMoveMemory(SetupldrASRPnPSifFile,setupLoaderBlock->ASRPnPSifFile,SetupldrASRPnPSifFileSize);
        //
        // If user provided asrpnp.sif, he wants ASR.
        //
        SpAsrSetAsrMode(ASRMODE_NORMAL);
        RepairWinnt = FALSE;
    } else {
        SetupldrASRPnPSifFile = NULL;
        //
        // user didn't provide asrpnp.sif, he doesn't want ASR.
        //
        SpAsrSetAsrMode(ASRMODE_NONE);
    }

    //
    // Make a copy of the image of the migrate.inf file.
    //
    SetupldrMigrateInfFileSize = setupLoaderBlock->MigrateInfFileLength;
    if ( SetupldrMigrateInfFileSize != 0 ) {
        SetupldrMigrateInfFile = SpMemAlloc(SetupldrMigrateInfFileSize);
        RtlMoveMemory(SetupldrMigrateInfFile,setupLoaderBlock->MigrateInfFile,SetupldrMigrateInfFileSize);
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: migrate.inf was loaded. Address = %lx, size = %d \n", SetupldrMigrateInfFile, SetupldrMigrateInfFileSize));
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Couldn't load migrate.inf \n"));
        SetupldrMigrateInfFile = NULL;
    }

    //
    // NEC98 need to decide drive assign method right away(before IoAssignDriveLetters())..
    //
    // NEC98 has 2 kind of drive mapping method.
    // One is NEC98 legacy style assign that mapping hard drive begining from A:,
    // other is same as PC/AT.
    //
    if (IsNEC_98) { //NEC98
        //
        // If no winnt.sif present, we don't need to check hive.
        //
        if ( SetupldrWinntSifFileSize != 0 ) {
            SpCheckHiveDriveLetters();
        }
    } //NEC98

    if ((SetupldrWinntSifFileSize != 0) || (SetupldrASRPnPSifFileSize != 0)) {
        SpMigrateDeviceInstanceData();
    }

    //
    // Make a copy of the image of the unsupdrv.inf file.
    //
    SetupldrUnsupDrvInfFileSize = setupLoaderBlock->UnsupDriversInfFileLength;
    if ( SetupldrUnsupDrvInfFileSize != 0 ) {
        SetupldrUnsupDrvInfFile = SpMemAlloc(SetupldrUnsupDrvInfFileSize);
        RtlMoveMemory(SetupldrUnsupDrvInfFile,setupLoaderBlock->UnsupDriversInfFile,SetupldrUnsupDrvInfFileSize);
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: driver.inf was loaded. Address = %lx, size = %d \n", SetupldrUnsupDrvInfFile, SetupldrUnsupDrvInfFileSize));
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Couldn't load unsupdrv.inf \n"));
        SetupldrUnsupDrvInfFile = NULL;
    }


    //
    // Make a copy of the scalar portions of the setup loader block.
    //
    SetupParameters = setupLoaderBlock->ScalarValues;

    //
    // Save away remote boot information.
    //
    if (RemoteBootSetup) {
#if defined(REMOTE_BOOT)
        memcpy(NetBootHalName, setupLoaderBlock->NetBootHalName, sizeof(NetBootHalName));
#endif // defined(REMOTE_BOOT)
        if (setupLoaderBlock->NetBootSifPath) {
            NetBootSifPath = SpToUnicode(setupLoaderBlock->NetBootSifPath);
        }
    }

    //
    //  Find out if the machine is dockable
    //  Note that at this point we could remove dmio.sys, dmboot.sys and dmload.sys from our lists
    //  if we determine that the this is a dockable machine. In this way, dynamic volumes would be
    //  disable during textmode setup. This should be done in the future.
    //
    SpCheckForDockableMachine();

    //
    // Remember migrated boot drivers
    //
    InitializeListHead (&MigratedDriversList);
    SpRememberMigratedDrivers(&MigratedDriversList, setupLoaderBlock->ScsiDevices);
    //
    // Save away the hardware information passed to us by setupldr.
    //
    HardwareComponents[HwComponentDisplay] = SpSetupldrHwToHwDevice(&setupLoaderBlock->VideoDevice);
    HardwareComponents[HwComponentKeyboard] = SpSetupldrHwToHwDevice(setupLoaderBlock->KeyboardDevices);
    HardwareComponents[HwComponentComputer] = SpSetupldrHwToHwDevice(&setupLoaderBlock->ComputerDevice);
    ScsiHardware = SpSetupldrHwToHwDevice(setupLoaderBlock->ScsiDevices);
    BootBusExtenders = SpSetupldrHwToHwDevice(setupLoaderBlock->BootBusExtenders);
    BusExtenders = SpSetupldrHwToHwDevice(setupLoaderBlock->BusExtenders);
    InputDevicesSupport = SpSetupldrHwToHwDevice(setupLoaderBlock->InputDevicesSupport);

    //
    // For each driver loaded by setupldr, we need to go create a service list entry
    // for that driver in the registry.
    //
    for( nextEntry = loaderBlock->BootDriverListHead.Flink;
         nextEntry != &loaderBlock->BootDriverListHead;
         nextEntry = nextEntry->Flink)
    {
        bootDriver = CONTAINING_RECORD(nextEntry,BOOT_DRIVER_LIST_ENTRY,Link);

        //
        // Get the image path.
        //
        imagePath = SpMemAlloc(bootDriver->FilePath.Length + sizeof(WCHAR));

        wcsncpy(
            imagePath,
            bootDriver->FilePath.Buffer,
            bootDriver->FilePath.Length / sizeof(WCHAR)
            );

        imagePath[bootDriver->FilePath.Length / sizeof(WCHAR)] = 0;

        //
        // If provided, get the registry path, otherwise it will
        // be created by SpCreateServiceEntry.
        //
        if (bootDriver->RegistryPath.Length > 0) {
            registryPath = SpMemAlloc(bootDriver->RegistryPath.Length + sizeof(WCHAR));

            wcsncpy(
                registryPath,
                bootDriver->RegistryPath.Buffer,
                bootDriver->RegistryPath.Length / sizeof(WCHAR)
                );

            registryPath[bootDriver->RegistryPath.Length / sizeof(WCHAR)] = 0;

            ServiceName = registryPath;
        } else {
            registryPath = NULL;
            ServiceName = NULL;
        }

        Status = SpCreateServiceEntry(imagePath,&ServiceName);

        //
        // If this operation fails, nothing to do about it here. If we did
        // not provide the registry path, then save the returned one.
        //
        if(NT_SUCCESS(Status)) {
            if (bootDriver->RegistryPath.Length == 0) {
                bootDriver->RegistryPath.MaximumLength =
                bootDriver->RegistryPath.Length = wcslen(ServiceName)*sizeof(WCHAR);
                bootDriver->RegistryPath.Buffer = ServiceName;
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: warning: unable to create service entry for %ws (%lx)\n",imagePath,Status));
        }

        SpMemFree(imagePath);
        if (registryPath) {
            SpMemFree(registryPath);
        }
    }


    if (NT_SUCCESS(Status)) {
        //
        // Create the virtual floppy (RAM driver) parameter entries
        // 
        // NOTE: We ignore the error here since we can't do much here
        // other than bug check the machine. The error
        // will be handled properly while copying the files
        // from the non existent OEM source devices
        //
        SpInitVirtualOemDevices(setupLoaderBlock, &VirtualOemSourceDevices);
    }                    
    
    //
    // Create the thirdy party OEM SCSI driver entries
    //
    SpCreateDriverRegistryEntries(ScsiHardware);

#ifdef FULL_DOUBLE_SPACE_SUPPORT
    if(NT_SUCCESS(Status)) {

        OBJECT_ATTRIBUTES Obja;
        UNICODE_STRING UnicodeString;
        HANDLE hKey;
        ULONG val = 1;

        //
        // Make sure we are automounting DoubleSpace
        //

        INIT_OBJA(
            &Obja,
            &UnicodeString,
            L"\\registry\\machine\\system\\currentcontrolset\\control\\doublespace"
            );

        Status = ZwCreateKey(
                    &hKey,
                    KEY_ALL_ACCESS,
                    &Obja,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    NULL
                    );

        if(NT_SUCCESS(Status)) {
            RtlInitUnicodeString(&UnicodeString,L"AutomountRemovable");
            Status = ZwSetValueKey(hKey,&UnicodeString,0,REG_DWORD,&val,sizeof(ULONG));
            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: init0: unable to create DoubleSpace automount value (%lx)\n",Status));
            }
            ZwClose(hKey);
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: init0: unable to create DoubleSpace key (%lx)\n",Status));
        }
    }
#endif

    //
    // Save arc disk info
    //
    if(NT_SUCCESS(Status)) {

        PARC_DISK_INFORMATION ArcInformation;
        PARC_DISK_SIGNATURE DiskInfo;
        PLIST_ENTRY ListEntry;
        PDISK_SIGNATURE_INFORMATION myInfo,prev;

        ArcInformation = loaderBlock->ArcDiskInformation;
        ListEntry = ArcInformation->DiskSignatures.Flink;

        prev = NULL;

        while(ListEntry != &ArcInformation->DiskSignatures) {

            DiskInfo = CONTAINING_RECORD(ListEntry,ARC_DISK_SIGNATURE,ListEntry);

            myInfo = SpMemAlloc(sizeof(DISK_SIGNATURE_INFORMATION));

            myInfo->Signature = DiskInfo->Signature;
            myInfo->ArcPath = SpToUnicode(DiskInfo->ArcName);
            myInfo->CheckSum = DiskInfo->CheckSum;
            myInfo->ValidPartitionTable = DiskInfo->ValidPartitionTable;
            myInfo->xInt13 = DiskInfo->xInt13;
            myInfo->IsGPTDisk = DiskInfo->IsGpt;
            myInfo->Next = NULL;

            if(prev) {
                prev->Next = myInfo;
            } else {
                DiskSignatureInformation = myInfo;
            }
            prev = myInfo;

            ListEntry = ListEntry->Flink;
        }
    }
    //
    //  Create the registry keys listed in migrate.inf.
    //
    if(NT_SUCCESS(Status)) {
        if ( SetupldrMigrateInfFile != NULL ) {
            ULONG   ErrorLine;

            Status = SpLoadSetupTextFile(
                        NULL,
                        SetupldrMigrateInfFile,
                        SetupldrMigrateInfFileSize,
                        &WinntMigrateInfHandle,
                        &ErrorLine,
                        FALSE,
                        TRUE
                        );
            if( NT_SUCCESS(Status) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpLoadSetupTextFile( migrate.inf ) succeeded.\n"));
                Status = SpProcessMigrateInfFile( WinntMigrateInfHandle );
                if( !NT_SUCCESS(Status) ) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Failed to process migrate.inf. Status = %lx\n",Status));
                }
#ifdef _X86_
                //
                // Delete drive letter information from registry that
                // translated from migrate.inf.
                //
                if( IsNEC_98 ) {
                    if( NT_SUCCESS(Status) ) {
                        SpDeleteDriveLetterFromNTFTNec98();
                    }
                }
#endif //NEC98
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpLoadSetupTextFile( migrate.inf ) failed. Status = %lx\n",Status));
            }
        }

        if ( (NT_SUCCESS(Status)) && (SetupldrUnsupDrvInfFile != NULL) ) {
            ULONG   ErrorLine;

            Status = SpLoadSetupTextFile(
                        NULL,
                        SetupldrUnsupDrvInfFile,
                        SetupldrUnsupDrvInfFileSize,
                        &WinntUnsupDrvInfHandle,
                        &ErrorLine,
                        FALSE,
                        TRUE
                        );
            if( NT_SUCCESS(Status) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpLoadSetupTextFile( driver.inf ) succeeded.\n"));

                Status = SpProcessUnsupDrvInfFile( WinntUnsupDrvInfHandle );
                if( !NT_SUCCESS(Status) ) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to process driver.inf. Status = %lx\n",Status));
                }
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpLoadSetupTextFile( driver.inf ) failed. Status = %lx\n",Status));
            }
        }
    }

    SetupHardwareIdDatabase = SpSetupldrPnpDatabaseToSetupPnpDatabase( setupLoaderBlock->HardwareIdDatabase );

    if(NT_SUCCESS(Status)) {
        //
        //  Initialize keyboard Guid string
        //
        Status = RtlStringFromGUID( &GUID_DEVCLASS_KEYBOARD, &GuidString );
        if( NT_SUCCESS( Status ) ) {
            KeyboardGuidString = SpDupStringW( GuidString.Buffer );
            if( KeyboardGuidString == NULL ) {
                Status = STATUS_NO_MEMORY;
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: cannot create a GUID string for keyboard device. Status = %lx \n", Status ));
            }
            RtlFreeUnicodeString( &GuidString );
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: cannot create a GUID string for keyboard device. Status = %lx \n", Status ));
        }
    }
    if(NT_SUCCESS(Status)) {
        //
        //  Initialize mouse Guid strings
        //
        Status = RtlStringFromGUID( &GUID_DEVCLASS_MOUSE, &GuidString );
        if( NT_SUCCESS( Status ) ) {
            MouseGuidString = SpDupStringW( GuidString.Buffer );
            if( MouseGuidString == NULL ) {
                Status = STATUS_NO_MEMORY;
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: cannot create a GUID string for mouse device. Status = %lx \n", Status ));
            }
            RtlFreeUnicodeString( &GuidString );
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: cannot create a GUID string for mouse device. Status = %lx \n", Status ));
        }
    }

    if(NT_SUCCESS(Status)) {
        //
        //  Register for Plug & Play notification
        //
        Status = IoRegisterPlugPlayNotification ( EventCategoryReserved,
                                                  0,
                                                  NULL,
                                                  DriverObject,
                                                  SpPnPNotificationCallBack,
                                                  SetupHardwareIdDatabase,
                                                  &NotificationEntry );
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: init0: unable to register for PnP notification (%lx)\n",Status));
        }

        //
        // Register for reinitialization.
        //
        if(NT_SUCCESS(Status)) {
            IoRegisterDriverReinitialization(DriverObject,SpInitialize0a,loaderBlock);
        }
    }

    return(Status);
}


VOID
SpInitialize0a(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID          Context,
    IN ULONG          ReferenceCount
    )
{
    PLOADER_PARAMETER_BLOCK LoaderBlock;
    PLIST_ENTRY nextEntry;
    PBOOT_DRIVER_LIST_ENTRY bootDriver;
    PKLDR_DATA_TABLE_ENTRY driverEntry;
    PHARDWARE_COMPONENT pHw,pHwPrev,pHwTemp;
    BOOLEAN ReallyLoaded;
    PUNICODE_STRING name;

    ULONG   i;
    PHARDWARE_COMPONENT* HwArray[] = {
                                     &ScsiHardware,
                                     &BootBusExtenders,
                                     &BusExtenders,
                                     &InputDevicesSupport,
                                     };


    UNREFERENCED_PARAMETER(DriverObject);
    UNREFERENCED_PARAMETER(ReferenceCount);

    //
    // Context points to the os loader block.
    //
    LoaderBlock = Context;

    //
    //  Find out if the machine is dockable.
    //  We do this once more because some machines may not have provided this info in the first
    //  time we attempted to retrieve this information.
    //
    SpCheckForDockableMachine();

    //
    // Iterate all scsi hardware and bus enumerators we think we detected
    // and make sure the driver really initialized.
    //
    for( i = 0; i < sizeof(HwArray)/sizeof(PHARDWARE_COMPONENT*); i++ ) {
        pHwPrev = NULL;
        for(pHw=*(HwArray[i]); pHw; ) {

            //
            // Assume not really loaded.
            //
            ReallyLoaded = FALSE;

            //
            // Scan the boot driver list for this driver's entry.
            //
            nextEntry = LoaderBlock->BootDriverListHead.Flink;
            while(nextEntry != &LoaderBlock->BootDriverListHead) {

                bootDriver = CONTAINING_RECORD( nextEntry,
                                                BOOT_DRIVER_LIST_ENTRY,
                                                Link );

                driverEntry = bootDriver->LdrEntry;
                name = &driverEntry->BaseDllName;

                if(!_wcsnicmp(name->Buffer,pHw->BaseDllName,name->Length/sizeof(WCHAR))) {

                    //
                    // This is the driver entry we need.
                    //
                    if(!(driverEntry->Flags & LDRP_FAILED_BUILTIN_LOAD)
                      ) {
                        ReallyLoaded = TRUE;
                    }

                    break;
                }

                nextEntry = nextEntry->Flink;
            }

            //
            // If the driver didn't initialize properly,
            // then it's not really loaded.
            //
            if(ReallyLoaded) {
                if( !pHw->MigratedDriver ) {
                    //
                    // not a migrated driver, continue on
                    // processing with the next node
                    //
                    pHwPrev = pHw;
                    pHw = pHw->Next;
                } else {
                    //
                    // Migrated driver, remove & free the
                    // node from the linked list
                    //
                    pHwTemp = pHw->Next;

                    if(pHwPrev) {
                        pHwPrev->Next = pHwTemp;
                    } else {
                        *(HwArray[i]) = pHwTemp;
                    }
                    SpFreeHwComponent(&pHw,FALSE);
                    pHw = pHwTemp;
                }
            } else {
                //
                // Remove and free the node or link it to unsupported driver
                // list if its a migrated driver
                //
                pHwTemp = pHw->Next;

                if(pHwPrev) {
                    pHwPrev->Next = pHwTemp;
                } else {
                    *(HwArray[i]) = pHwTemp;
                }

                if( ( HwArray[i] == &ScsiHardware ) && ( pHw->MigratedDriver ) ) {
                    //
                    //  If this is an unsupported migrated driver that failed to initialize, then
                    //  remember it so that we can disable it later on. This can happen if the
                    //  system contains a driver that controls the unsupported device, but winnt32
                    //  winnt32 couldn't figure it out.
                    //
                    pHw->Next = UnsupportedScsiHardwareToDisable;
                    UnsupportedScsiHardwareToDisable = pHw;
                } else {
                    SpFreeHwComponent(&pHw,FALSE);
                }

                pHw = pHwTemp;
            }
        }
    }

    //
    //  Find the pcmcia and atapi drivers and make sure these drivers really
    //  initialized
    //

    //
    // Assume not really loaded.
    //
    PcmciaLoaded = FALSE;
    AtapiLoaded  = FALSE;

    //
    // Scan the boot driver list for this driver's entry.
    //
    nextEntry = LoaderBlock->BootDriverListHead.Flink;
    while(nextEntry != &LoaderBlock->BootDriverListHead) {

        bootDriver = CONTAINING_RECORD( nextEntry,
                                        BOOT_DRIVER_LIST_ENTRY,
                                        Link );

        driverEntry = bootDriver->LdrEntry;
        name = &driverEntry->BaseDllName;

        if(!_wcsnicmp(name->Buffer,L"pcmcia.sys",name->Length/sizeof(WCHAR))) {

            //
            // This is the driver entry we need.
            //
            if(!(driverEntry->Flags & LDRP_FAILED_BUILTIN_LOAD)) {
                PcmciaLoaded = TRUE;
            }
        } else if(!_wcsnicmp(name->Buffer,L"atapi.sys",name->Length/sizeof(WCHAR))) {

            //
            // This is the driver entry we need.
            //
            if(!(driverEntry->Flags & LDRP_FAILED_BUILTIN_LOAD)) {
                AtapiLoaded = TRUE;
            }
        }

        nextEntry = nextEntry->Flink;
    }

}


VOID
SpInitialize1(
    VOID
    )
{
    ASSERT(!GeneralInitialized);

    if(GeneralInitialized) {
        return;
    }

    SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_MNEMONICS);

    MnemonicValues = SpMemAlloc((wcslen(TemporaryBuffer)+1)*sizeof(WCHAR));

    wcscpy(MnemonicValues,TemporaryBuffer);

    GeneralInitialized = TRUE;
}


VOID
SpTerminate(
    VOID
    )
{
    ASSERT(GeneralInitialized);

    if(GeneralInitialized) {
        if(MnemonicValues) {
            SpMemFree(MnemonicValues);
            MnemonicValues = NULL;
        }
        GeneralInitialized = FALSE;
    }
}


VOID
SpInvalidSystemPartition(
    VOID
    )

/*++

Routine Description:

    Display a screen telling the user that we think his system
    partition is invalid.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG EvaluationInstallKeys[] = { KEY_F3, ASCI_CR };

    SpDisplayScreen(SP_SCRN_SYSTEMPARTITION_INVALID, 3, 4 );

    SpDisplayStatusOptions(
        DEFAULT_STATUS_ATTRIBUTE,
        SP_STAT_ENTER_EQUALS_CONTINUE,
        SP_STAT_F3_EQUALS_EXIT,
        0
        );

    //
    // Wait for keypress.  Valid keys:
    //
    // ENTER = continue
    //

    SpInputDrain();

    switch(SpWaitValidKey(EvaluationInstallKeys,NULL,NULL)) {

        //
        // User wants to continue.
        //
        case ASCI_CR:
            break;

        //
        // User wants to exit.
        //
        case KEY_F3:
            SpConfirmExit();
            break;
    }
}


VOID
SpNotifyEvaluationInstall(
    VOID
    )

/*++

Routine Description:

    Display a screen telling the user we're about to install a demo
    version.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG EvaluationInstallKeys[] = { KEY_F3, ASCI_CR };

    SpDisplayScreen(SP_SCRN_EVALUATION_NOTIFY, 3, 4 );

    SpDisplayStatusOptions(
        DEFAULT_STATUS_ATTRIBUTE,
        SP_STAT_ENTER_EQUALS_CONTINUE,
        SP_STAT_F3_EQUALS_EXIT,
        0
        );

    //
    // Wait for keypress.  Valid keys:
    //
    // ENTER = continue
    //

    SpInputDrain();

    switch(SpWaitValidKey(EvaluationInstallKeys,NULL,NULL)) {

        //
        // User wants to continue.
        //
        case ASCI_CR:
            break;

        //
        // User wants to exit.
        //
        case KEY_F3:
            SpConfirmExit();
            break;
    }


}





VOID
SpWelcomeScreen(
    VOID
    )

/*++

Routine Description:

    Display a screen welcoming the user and allow him to choose among
    some options (help, exit, aux. menu, continue, repair).

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG WelcomeKeys[] = { KEY_F3, ASCI_CR, ASCI_ESC, KEY_F10, 0 };
    ULONG MnemonicKeys[] = { MnemonicRepair, 0 };
    BOOLEAN Welcoming;

    //
    // Welcome the user.
    //
    for(Welcoming = TRUE; Welcoming; ) {

        if (SpIsERDisabled()) {
            SpDisplayScreen(SP_SCRN_WELCOME_1, 3, 4);

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_ENTER_EQUALS_CONTINUE,
                SP_STAT_R_EQUALS_REPAIR,
                SP_STAT_F3_EQUALS_EXIT,
                0
                );
        } else {
            SpDisplayScreen(SP_SCRN_WELCOME,3,4);

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_ENTER_EQUALS_CONTINUE,
                SP_STAT_R_EQUALS_REPAIR,
                SP_STAT_F3_EQUALS_EXIT,
                0
                );

        }

        //
        // Wait for keypress.  Valid keys:
        //
        // F1 = help
        // F3 = exit
        // ENTER = continue
        // R = Repair Winnt
        // ESC = auxillary menu.
        //

        SpInputDrain();

        switch(SpWaitValidKey(WelcomeKeys,NULL,MnemonicKeys)) {

        case ASCI_ESC:

            //
            // User wants auxillary menu.
            //
            break;

        case ASCI_CR:

            //
            // User wants to continue.
            //
            RepairWinnt = FALSE;
            Welcoming = FALSE;
            break;


        case KEY_F3:

            //
            // User wants to exit.
            //
            SpConfirmExit();
            break;

        case KEY_F10:
            Welcoming = FALSE;
            ForceConsole = TRUE;
            break;

        default:

            //
            // Must be repair mnemonic
            //
            SpAsrSetAsrMode(ASRMODE_NORMAL);
            RepairWinnt = TRUE;
            Welcoming = FALSE;
            break;
        }
    }
}


VOID
SpDisplayEula (
    IN HANDLE       MasterSifHandle,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice
    )

/*++

Routine Description:

    Display the End User Licensing Agreement.

Arguments:

    MasterSifHandle - Handle to txtsetup.sif.

    SetupSourceDevicePath - Path to the device that contains the source media.

    DirectoryOnSourceDevice - Directory on the media where EULA is located.

Return Value:

    None.  Does not return if user does not accept licensing agreement or if
    the licensing agreement cannot be opened.

--*/

{
    PWSTR       MediaShortName;
    PWSTR       MediaDirectory;
    PWSTR       EulaPath;
    NTSTATUS    Status;
    PVOID       BaseAddress;
    ULONG       FileSize;
    HANDLE      hFile, hSection;
    ULONG       ValidKeys[2] = { KEY_F3,0 };
    PWSTR       Eula;
    ULONG       EulaSize;
    PWSTR       p;

    if (PreInstall) {
        return;
    }

    //
    // Winnt32 displays the EULA now so we might be able to skip it
    //
    p = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,WINNT_D_EULADONE_W,0);
    if(p && SpStringToLong(p,NULL,10)) {
       return;
    }

    //
    // Figure out the path to eula.txt
    //
    MediaShortName = SpLookUpValueForFile(
        MasterSifHandle,
        L"eula.txt",
        INDEX_WHICHMEDIA,
        TRUE
        );
    SpPromptForSetupMedia(
        MasterSifHandle,
        MediaShortName,
        SetupSourceDevicePath
        );


    if (UnattendedOperation && CustomSetup) {
        return;
    }


    SpGetSourceMediaInfo(
        MasterSifHandle,MediaShortName,NULL,NULL,&MediaDirectory);

    wcscpy( TemporaryBuffer, SetupSourceDevicePath );
    SpConcatenatePaths( TemporaryBuffer, DirectoryOnSourceDevice );
    SpConcatenatePaths( TemporaryBuffer, MediaDirectory );
    SpConcatenatePaths( TemporaryBuffer, L"eula.txt" );
    EulaPath = SpDupStringW( TemporaryBuffer );

    //
    // Open and map the file for read access.
    //
    hFile = 0;  // use EulaPath instead
    Status = SpOpenAndMapFile(
        EulaPath,
        &hFile,
        &hSection,
        &BaseAddress,
        &FileSize,
        FALSE
        );

    if(!NT_SUCCESS(Status)) {
        //
        // Display a message indicating that there was a fatal error while trying
        // to open the EULA file.
        //
        SpStartScreen(
            SP_SCRN_FATAL_ERROR_EULA_NOT_FOUND,
            3,
            HEADER_HEIGHT+3,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE
            );
        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,
            0);
        SpWaitValidKey(ValidKeys,NULL,NULL);
        SpDone(0,FALSE,TRUE);
    }

    //
    // Convert the text to Unicode.
    //
    Eula = SpMemAlloc ((FileSize+1) * sizeof(WCHAR));
    ASSERT (Eula);

    Status = RtlMultiByteToUnicodeN (
        Eula,
        FileSize * sizeof(WCHAR),
        &EulaSize,
        BaseAddress,
        FileSize
        );
    ASSERT (NT_SUCCESS(Status));
    Eula[EulaSize / sizeof(WCHAR)] = (WCHAR)'\0';

    //
    // Show text to user.
    //
    SpHelp(
        0,
        Eula,
        SPHELP_LICENSETEXT
        );

    //
    // Clean up
    //
    if (UnattendedOperation && !CustomSetup) {
        PWSTR   szOne = L"1";
        //
        // Remember that we displayed it here.
        //
        SpAddLineToSection(WinntSifHandle, SIF_DATA, WINNT_D_EULADONE_W, &szOne, 1);
    }

    SpMemFree (EulaPath);
    SpMemFree (Eula);
    SpUnmapFile(hSection,BaseAddress);
    ZwClose(hFile);

}



VOID
SpCustomExpressScreen(
    VOID
    )

/*++

Routine Description:

    Allow the user to choose between custom and express setup.

    The global variable CustomSetup is set according to the user's choice.

    NOTE : This feature is only available for headless installs

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG ValidKeys[] = { ASCI_CR, KEY_F3, 0 };
    ULONG MnemonicKeys[] = { MnemonicCustom, 0 };
    BOOLEAN Choosing;
    ULONG c;

    //
    // See whether this parameter is specified for unattended operation.
    //
    if(UnattendedOperation) {

        PWSTR p = SpGetSectionKeyIndex(UnattendedSifHandle,
            SIF_UNATTENDED,WINNT_U_METHOD_W,0);
        PWSTR q = SpGetSectionKeyIndex(UnattendedSifHandle,
            SIF_UNATTENDED,WINNT_U_OVERWRITEOEM_W,0);

        if( q && !_wcsicmp( q, L"no" ) ) {
            UnattendedOverwriteOem = FALSE;
        } else {
            UnattendedOverwriteOem = TRUE;
        }

        //
        // Default is custom. If user specified something
        // else then use express.
        //
        if(p && _wcsicmp(p,L"custom")) {
            CustomSetup = FALSE;
        }
        return;
    }


    //
    // Don't do this if they ran from winnt/winnt32
    // or headless terminal was not connected
    //
    if( WinntSetup || !HeadlessTerminalConnected) {
        return;
    }


    for(Choosing = TRUE; Choosing; ) {

        SpDisplayScreen(SP_SCRN_CUSTOM_EXPRESS,3,4);

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_EXPRESS,
            SP_STAT_C_EQUALS_CUSTOM,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        //
        // Wait for keypress.  Valid keys:
        //
        // ENTER = express setup
        // <MnemonicCustom> = custom setup
        //

        SpInputDrain();

        switch(c=SpWaitValidKey(ValidKeys,NULL,MnemonicKeys)) {

        case ASCI_CR:

            //
            // User wants express setup.
            //
            CustomSetup = FALSE;
            Choosing = FALSE;
            break;


        case (MnemonicCustom | KEY_MNEMONIC):
            CustomSetup = TRUE;
            Choosing = FALSE;
            break;

        case KEY_F3:
            SpDone(0, FALSE, TRUE);
            break;

        default:
            break;
        }
    }

}


PVOID
SpLoadSetupInformationFile(
    VOID
    )
{
    NTSTATUS Status;
    ULONG ErrLine;
    PVOID SifHandle;

    CLEAR_CLIENT_SCREEN();

    //
    // The image of txtsetup.sif has been passed to us
    // by setupldr.
    //
    Status = SpLoadSetupTextFile(
                NULL,
                SetupldrInfoFile,
                SetupldrInfoFileSize,
                &SifHandle,
                &ErrLine,
                TRUE,
                FALSE
                );

    //
    // We're done with the image.
    //
    SpMemFree(SetupldrInfoFile);
    SetupldrInfoFile = NULL;
    SetupldrInfoFileSize = 0;

    if(NT_SUCCESS(Status)) {
        return(SifHandle);
    }

    //
    // The file was already parsed once by setupldr.
    // If we can't do it here, there's a serious problem.
    // Assume it was a syntax error, because we didn't
    // have to load it from disk.
    //
    SpStartScreen(
        SP_SCRN_SIF_PROCESS_ERROR,
        3,
        HEADER_HEIGHT+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE,
        ErrLine
        );

    //
    // Since we haven't yet loaded the keyboard layout, we can't prompt the
    // user to press F3 to exit
    //
    SpDisplayStatusText(SP_STAT_KBD_HARD_REBOOT, DEFAULT_STATUS_ATTRIBUTE);
    SpInputGetKeypress();

    while(TRUE);    // Loop forever
}


VOID
SpIsWinntOrUnattended(
    IN PVOID        SifHandle
    )
{
    PWSTR       szZero  = L"0";
    PWSTR       szOne   = L"1";
    NTSTATUS    Status;
    ULONG       ErrorLine;
    PWSTR       p;
    WCHAR       DiskDevicePath[MAX_PATH];
    ULONG       i;
    PWSTR       Architecture;

    //
    // Attempt to load winnt.sif. If the user is in the middle of
    // a winnt setup, this file will be present.
    //
    if ( SetupldrWinntSifFile != NULL ) {
        Status = SpLoadSetupTextFile(
                    NULL,
                    SetupldrWinntSifFile,
                    SetupldrWinntSifFileSize,
                    &WinntSifHandle,
                    &ErrorLine,
                    TRUE,
                    FALSE
                    );
    } else {

        //
        // There's no winnt.sif handle, so this is probably an el-torito
        // boot.  If that's true, *and* the user chose to do an express
        // setup, then use the on-CD unattend file.
        //
        if( !CustomSetup ) {

            //
            // The only way we should ever get here is if we went to
            // the custom/express screen and the user chose express, which
            // means this is the second time through this function (we had
            // to call this fuction again to re-initialize our variables
            // using the on-CD unattend file.
            //


            //
            // Use this for testing purposes.  Check for floppy0\unattend.txt
            // before getting the file off the CDROM.
            //
            wcscpy( DiskDevicePath, L"\\device\\floppy0\\unattend.txt" );
            Status = SpLoadSetupTextFile( DiskDevicePath,
                                          NULL,
                                          0,
                                          &WinntSifHandle,
                                          &ErrorLine,
                                          TRUE,
                                          FALSE );

            if( !NT_SUCCESS(Status) ) {


                Status = STATUS_OBJECT_NAME_NOT_FOUND;
                i = 0;
                Architecture = SpGetSectionKeyIndex( SifHandle,
                                                     SIF_SETUPDATA,
                                                     L"Architecture",
                                                     0 );
    
                if( Architecture == NULL ) {
#if defined(_AMD64_)
                    Architecture = L"amd64";
#elif defined(_X86_)
                    Architecture = L"x86";
#elif defined(_IA64_)
                    Architecture = L"ia64";
#else
#error "No Target Architcture"
#endif
                }
    
                while( (i < IoGetConfigurationInformation()->CdRomCount) && (!NT_SUCCESS(Status)) ) {
    
                    swprintf( DiskDevicePath, L"\\device\\cdrom%u", i);
                    SpConcatenatePaths( DiskDevicePath, Architecture );
                    SpConcatenatePaths( DiskDevicePath, L"\\unattend.txt" );
    
                    Status = SpLoadSetupTextFile( DiskDevicePath,
                                                  NULL,
                                                  0,
                                                  &WinntSifHandle,
                                                  &ErrorLine,
                                                  TRUE,
                                                  FALSE );
                    i++;
                }

            }



            if( NT_SUCCESS(Status) ) {
                //
                // Add a bunch of defaults which *should* of been there, but
                // were not
                SpAddLineToSection(WinntSifHandle,SIF_DATA,
                    WINNT_D_MSDOS_W,&szZero,1);
                SpAddLineToSection(WinntSifHandle,SIF_DATA,
                    WINNT_D_FLOPPY_W,&szZero,1);
                SpAddLineToSection(WinntSifHandle,SIF_SETUPPARAMS,
                    WINNT_S_SKIPMISSING_W,&szOne,1);
                SpAddLineToSection(WinntSifHandle,SIF_DATA,
                    WINNT_D_AUTO_PART_W,&szOne,1);

                //
                // Tell the autopartition picker to do his job.
                //
                AutoPartitionPicker = TRUE;

            }


        } else {
            //
            // fail.
            //
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

    if(NT_SUCCESS(Status)) {

        //
        // Check for winnt setup and the case where the user left the
        // files on the CD-ROM.
        //
        p = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,WINNT_D_MSDOS_W,0);
        if(p && SpStringToLong(p,NULL,10)) {

            WinntSetup = TRUE;

            p = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,WINNT_D_LOCALSRC_CD_W,0);
            if(p && SpStringToLong(p,NULL,10)) {
                WinntFromCd = TRUE;
            }
        }

        //
        // Check for the case where the user ran "winnt32 -cmdcons"
        //
        p = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,
            WINNT_D_CMDCONS_W,0);
        if(p && SpStringToLong(p,NULL,10)) {

            ConsoleFromWinnt32 = TRUE;
        }


#if defined(_AMD64_) || defined(_X86_)
        //
        // Check for floppyless boot.
        //
        p = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,
            WINNT_D_FLOPPY_W,0);
        if(p && SpStringToLong(p,NULL,10)) {

            IsFloppylessBoot = TRUE;
        }


        //
        // Check for fake CD.
        //
        p = SpGetSectionKeyIndex (WinntSifHandle, SIF_DATA, WINNT_D_NOLS_W, 0);
        if (p && SpStringToLong (p, NULL, 10)) {

            //
            // get the original source path first
            //
            p = SpGetSectionKeyIndex (WinntSifHandle, SIF_DATA, WINNT_D_ORI_SRCPATH_W, 0);
            if (p) {
                if (p[0] && p[1] == L':') {
                    p += 2;
                }
                wcscpy (TemporaryBuffer, p);
                SpConcatenatePaths (TemporaryBuffer, (!IsNEC_98) ? L"i386" : L"nec98");
                LocalSourceDirectory = SpDupStringW (TemporaryBuffer);
                NoLs = TRUE;
            }
        }
#endif // defined(_AMD64_) || defined(_X86_)



        //
        // Check for ASR test mode.  This is intended as a way to automate
        // ASR testing.
        //
        p = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,L"AsrMode",0);
        if(p && SpStringToLong(p,NULL,10)) {

            switch (SpStringToLong(p,NULL,10)) {
            case 1:
                SpAsrSetAsrMode(ASRMODE_NORMAL);
                break;

            case 2:
                SpAsrSetAsrMode(ASRMODE_QUICKTEST_TEXT);
                break;

            case 3:
                SpAsrSetAsrMode(ASRMODE_QUICKTEST_FULL);
                break;

            default:
                SpAsrSetAsrMode(ASRMODE_NORMAL);
                break;
            }

            RepairWinnt = FALSE;    // ASR not ER
        }


        //
        // Check for auto Partition picker
        //
        p = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,WINNT_D_AUTO_PART_W,0);
        if(p && SpStringToLong(p,NULL,10)) {
            AutoPartitionPicker = TRUE;
        }

        //
        // Check for a preferred install directory
        //
        p = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,WINNT_D_INSTALLDIR_W,0);
        if (p) {
            PreferredInstallDir = SpDupStringW( p );
        }

        //
        // Check for ignore missing files.
        //
        p = SpGetSectionKeyIndex(WinntSifHandle,SIF_SETUPPARAMS,WINNT_S_SKIPMISSING_W,0);
        if(p && SpStringToLong(p,NULL,10)) {
            SkipMissingFiles = TRUE;
        }

        //
        // Check for hide windir
        //
        p = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,L"HideWinDir",0);
        if(p && SpStringToLong(p,NULL,10)) {
            HideWinDir = TRUE;
        }

        //
        // Check for accessibility options
        //
        AccessibleSetup = SpNonZeroValuesInSection(WinntSifHandle, SIF_ACCESSIBILITY, 0);

        //
        // Now check for an unattended setup.
        //
        if(SpSearchTextFileSection(WinntSifHandle,SIF_UNATTENDED)) {

            //
            // Run in unattended mode. Leave the sif open
            // and save away its handle for later use.
            //
            UnattendedSifHandle = WinntSifHandle;
            UnattendedOperation = TRUE;

        } else if(SpSearchTextFileSection(WinntSifHandle,SIF_GUI_UNATTENDED)) {

            //
            // Leave UnattendedOperation to FALSE (because it mainly uses to
            // control text mode setup.)  Store the handle of winnt.sif for later
            // reference.
            //

            UnattendedGuiOperation = TRUE;
        }

        if(UnattendedOperation) {
            PWSTR   TempStr = NULL;

            //
            //  If this is an unattended operation, find out if this is
            //  also an OEM pre-install
            //
            p = SpGetSectionKeyIndex(UnattendedSifHandle,
                                     SIF_UNATTENDED,
                                     WINNT_U_OEMPREINSTALL_W,
                                     0);

            if( p && !_wcsicmp( p, L"yes" ) ) {
                PreInstall = TRUE;
            }


            //
            // Find out if no wait has been specified or not.
            // Default is always false, in unattended case
            //
            UnattendWaitForReboot = FALSE;

            TempStr = SpGetSectionKeyIndex(UnattendedSifHandle,
                            SIF_UNATTENDED,
                            WINNT_U_WAITFORREBOOT_W,
                            0);


            if (TempStr && !_wcsicmp(TempStr, L"yes")) {
                UnattendWaitForReboot = TRUE;
            }


            //
            // See if we're upgrading.
            //
            p = SpGetSectionKeyIndex(UnattendedSifHandle,
                                     SIF_DATA,
                                     WINNT_D_NTUPGRADE_W, 
                                     0);
            if( p && !_wcsicmp( p, L"yes" ) ) {

                NTUpgrade = UpgradeFull;
            }

        }

    } else {
        // Case where there isn't an WINNT.SIF file to be found

        //
        // Create a handle to the new file
        //
        WinntSifHandle = SpNewSetupTextFile();
        //
        // Add a bunch of defaults which *should* of been there, but
        // was not
        SpAddLineToSection(WinntSifHandle,SIF_DATA,
            WINNT_D_MSDOS_W,&szZero,1);
        SpAddLineToSection(WinntSifHandle,SIF_DATA,
            WINNT_D_FLOPPY_W,&szZero,1);
        SpAddLineToSection(WinntSifHandle,SIF_SETUPPARAMS,
            WINNT_S_SKIPMISSING_W,&szZero,1);
    }
}


VOID
SpCheckSufficientMemory(
    IN PVOID SifHandle
    )

/*++

Routine Description:

    Determine whether sufficient memory exists in the system
    for installation to proceed.  The required amount is specified
    in the sif file.

Arguments:

    SifHandle - supplies handle to open setup information file.

Return Value:

    None.

--*/

{
    ULONGLONG RequiredBytes,AvailableBytes, RequiredMBytes, AvailableMBytes;
    PWSTR p;

    p = SpGetSectionKeyIndex(SifHandle,SIF_SETUPDATA,SIF_REQUIREDMEMORY,0);

    if(!p) {
        SpFatalSifError(SifHandle,SIF_SETUPDATA,SIF_REQUIREDMEMORY,0,0);
    }

    RequiredBytes = (ULONGLONG)(ULONG)SpStringToLong(p,NULL,10);

    AvailableBytes = UInt32x32To64(SystemBasicInfo.NumberOfPhysicalPages,SystemBasicInfo.PageSize);

    //
    // Now round to Mbytes for cleanliness...  Include a 4MB slack-factor.
    //
    RequiredMBytes  = ((RequiredBytes + ((4*1024*1024)-1)) >> 22) << 2;
    AvailableMBytes = ((AvailableBytes + ((4*1024*1024)-1)) >> 22) << 2;

    //
    // Allow UMA machines which may reserve 8MB for video memory.
    //
    if(AvailableMBytes < (RequiredMBytes-8)) {

        SpStartScreen(
            SP_SCRN_INSUFFICIENT_MEMORY,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            RequiredMBytes,
            0
            );

        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);

        SpInputDrain();
        while(SpInputGetKeypress() != KEY_F3) ;

        SpDone(0,FALSE,TRUE);
    }
}


PWSTR SetupSourceDevicePath = NULL;
PWSTR DirectoryOnSetupSource = NULL;
PVOID SifHandle;


ULONG
SpStartSetup(
    VOID
    )
{
    PDISK_REGION TargetRegion,SystemPartitionRegion=NULL;
    PDISK_REGION BootRegion; //NEC98
    PWSTR TargetPath=NULL,SystemPartitionDirectory=NULL,OriginalSystemPartitionDirectory=NULL;
    PWSTR DefaultTarget;
    PWSTR OldOsLoadOptions;
    PWSTR FullTargetPath;
#if defined(REMOTE_BOOT)
    PWSTR RemoteBootTarget;
#endif // defined(REMOTE_BOOT)
    BOOLEAN CdInstall = FALSE;
    BOOLEAN b, DeleteTarget=FALSE;
    NTSTATUS Status;
    PVOID NtfsConvert;
    PWSTR ThirdPartySourceDevicePath;
    HANDLE ThreadHandle = NULL;
#if defined(_AMD64_) || defined(_X86_)
    PCWSTR disableCompression;
    PCWSTR enableBackup;
    TCOMP compressionType;
#endif // defined(_AMD64_) || defined(_X86_)

    //
    // First things first, initialize the upgrade graphics global
    // variables and hook up the upgrade progress indicator
    // for graphics mode, if needed.
    //
    if (SP_IS_UPGRADE_GRAPHICS_MODE()) {
        UpgradeGraphicsInit();
        RegisterSetupProgressCallback(GraphicsModeProgressUpdate, NULL);
    }

    SendSetupProgressEvent(InitializationEvent, InitializationStartEvent, NULL);

    SpInitialize1();
    SpvidInitialize();  // initialize video first, so we can give err msg if keyboard error
    SpInputInitialize();

    if(!SpPatchBootMessages()) {
        SpBugCheck(SETUP_BUGCHECK_BOOTMSGS,0,0,0);
    }

    //
    // Initialize ARC<==>NT name translations.
    //
    SpInitializeArcNames(VirtualOemSourceDevices);

    //
    // Set up the boot device path, which we have stashed away
    // from the os loader block.
    //
    NtBootDevicePath = SpArcToNt(ArcBootDevicePath);
    if(!NtBootDevicePath) {
        SpBugCheck(SETUP_BUGCHECK_BOOTPATH,0,0,0);
    }

    //
    // Initialize dynamic update boot driver root directory path
    //
    DynUpdtBootDriverPath = SpGetDynamicUpdateBootDriverPath(NtBootDevicePath,
                                DirectoryOnBootDevice,
                                WinntSifHandle);

    //
    // For remote install, append RemoteIMirrorBootDirectoryPrefix to
    // NtBootDevicePath so that it matches what C: is linked to.
    // That way DirectoryOnBootDevice will be valid both from kernel
    // and user mode.
    //
    if (RemoteBootSetup) {
        ULONG NewBootDevicePathLen =
            (wcslen(NtBootDevicePath) + wcslen(RemoteIMirrorBootDirectoryPrefix) + 1) * sizeof(WCHAR);
        PWSTR NewBootDevicePath = SpMemAlloc(NewBootDevicePathLen);
        wcscpy(NewBootDevicePath, NtBootDevicePath);
        wcscat(NewBootDevicePath, RemoteIMirrorBootDirectoryPrefix);
        SpMemFree(NtBootDevicePath);
        NtBootDevicePath = NewBootDevicePath;
    }

    // Read SKU data, such as whether we are a product suite or
    // this is an evaluation unit. Fills in SuiteType and
    // EvaluationTime globals.
    //
    SpReadSKUStuff();

    //
    // Reinitialize video -- noop in western builds but switches into DBCS mode,
    // etc, in Far Eastern builds.
    //
    if (NT_SUCCESS(SplangInitializeFontSupport(NtBootDevicePath,
                            DirectoryOnBootDevice,
                            BootFontImage,
                            BootFontImageLength))) {
        SpvidInitialize();  // reinitialize video in alternate mode for Far East
    }

    //
    // Process the txtsetup.sif file, which the boot loader
    // will have loaded for us.
    //
    SifHandle = SpLoadSetupInformationFile();

    //
    // Determine whether this is advanced server.
    //
    SpDetermineProductType(SifHandle);

    //
    // Start the upgrade graphics
    //
    if (SP_IS_UPGRADE_GRAPHICS_MODE()) {
        if (!NT_SUCCESS(UpgradeGraphicsStart())) {
            SP_SET_UPGRADE_GRAPHICS_MODE(FALSE);
            CLEAR_ENTIRE_SCREEN();
        }
    }


    SpInputLoadLayoutDll(SifHandle,DirectoryOnBootDevice);

#ifdef PRERELEASE
    //
    // Initialize test hooks to allow testers to inject bug checks at random
    // points in text mode (internal use only)
    //

    {
        PCWSTR data;

        if (WinntSifHandle) {
            data = SpGetSectionKeyIndex (
                        WinntSifHandle,
                        L"TestHooks",
                        L"BugCheckPoint",
                        0
                        );

            if (data) {
                while (*data >= L'0' && *data <= L'9') {
                    g_TestHook = g_TestHook * 10 + (*data - L'0');
                    data++;
                }
            }
        }
    }
#endif

    //
    // Check for bad BIOS. Does not return if a bad BIOS is found.
    //
    SpCheckForBadBios();

    //
    // Check for sufficient memory. Does not return if not enough.
    //
    SpCheckSufficientMemory(SifHandle);

    //
    // Determine whether this is a winnt/winnt32 setup and/or unattended setup.
    // If unattended, the global variable UnattendedSifHandle will be filled in.
    // If winnt/winnt32, the global variable WinntSetup will be set to TRUE.
    //
    SpIsWinntOrUnattended(SifHandle);

#if defined(_X86_)
    //
    // Check if SIF has Rollback flag
    //

    if (SpGetSectionKeyIndex (
                WinntSifHandle,
                SIF_DATA,
                WINNT_D_WIN9X_ROLLBACK_W,
                0
                )) {
        Win9xRollback = TRUE;
    }

#ifdef PRERELEASE
    if (Win9xRollback) {
        g_TestHook -= 1000;     // uninstall test hooks start at 1001
    }
#endif

#endif // defined(_X86_)

    TESTHOOK(1);

    //
    // If this is a remote boot setup, get the path to the target.
    //
    // If TargetNtPartition is not specified in winnt.sif, then this is a
    // remote boot for a remote install, not a remote boot setup.
    //
    if (RemoteBootSetup) {

#if defined(REMOTE_BOOT)

         RemoteBootTarget = SpGetSectionKeyIndex(WinntSifHandle,SIF_SETUPDATA,L"TargetNtPartition",0);
        if (RemoteBootTarget == NULL) {
            RemoteInstallSetup = (BOOLEAN)(!RemoteSysPrepSetup);
        } else {
            RemoteBootTargetRegion = SpPtAllocateDiskRegionStructure(0xffffffff,0,0,TRUE,NULL,0);
            ASSERT(RemoteBootTargetRegion);
            wcscpy(RemoteBootTargetRegion->TypeName,RemoteBootTarget);
        }
#else
        RemoteInstallSetup = (BOOLEAN)(!RemoteSysPrepSetup);
#endif // defined(REMOTE_BOOT)
    }

    //
    // Display the correct header text based on the product.
    //
    if (!ForceConsole && !Win9xRollback) {
        SpDisplayHeaderText(
            SpGetHeaderTextId(),
            DEFAULT_ATTRIBUTE
            );
    }

    //
    // Check to see if we need to notify the user that we're installing a
    // demo version.  We assume that if the user is doing an unattended
    // install, they know what they're doing.
    //
    if ((!ForceConsole) && (!Win9xRollback) && (!UnattendedOperation) &&
        (EvaluationTime != 0) && (!SpDrEnabled())
        ) {
        SpNotifyEvaluationInstall();
    }

    if ((!ForceConsole) && (!Win9xRollback) && (!SpDrEnabled())) {
        //
        // Welcome the user and determine if this is for repairing.
        //
        if(!UnattendedOperation) {
            SpWelcomeScreen();
        }
    }

    //
    // The user may have chosen to do a repair during
    // the welcome screen, so we need to skip the check for
    // custom/express in this case.
    //
    if ((!ForceConsole) && (!Win9xRollback) && (!SpDrEnabled()) && (!RepairWinnt)) {

        SpCustomExpressScreen();

        if( !CustomSetup ) {
            //
            // The user wants to do an express setup.
            // reread the unattend file off the CD and use that.
            //
            // NULL-out the SetupldrWinntSifFile so we force the
            // re-read of the unattend file off the CDROM or floppy.
            //
            SetupldrWinntSifFile = NULL;
            SpIsWinntOrUnattended(SifHandle);
        }
    }

    if( (HeadlessTerminalConnected) && 
        (UnattendedOperation) &&
        (NTUpgrade != UpgradeFull) &&
        (!ForceConsole) ) {

        //
        // We're unattended and we're headless.  We really want to try and
        // not let gui-mode setup do *ANY* user-interaction.  So let's set
        // the unattend mode to fullunattended.
        //
        PWSTR   Value[1];
        WCHAR   Answer[128];

        Value[0] = Answer;

        wcscpy( Answer, WINNT_A_FULLUNATTENDED_W );
        SpAddLineToSection( WinntSifHandle, 
                            WINNT_UNATTENDED_W, 
                            WINNT_U_UNATTENDMODE_W, 
                            Value, 
                            1 );
    
    
        //
        // Is there already an Administrator Password in the unattend file?
        //
        Value[0] = SpGetSectionKeyIndex( WinntSifHandle,
                                         WINNT_GUIUNATTENDED_W, 
                                         WINNT_US_ADMINPASS_W, 
                                         0 );

        if( (NetBootAdministratorPassword == NULL) &&
            ((Value[0] == NULL) || !(_wcsicmp(Value[0], L"*"))) ) {

            //
            // We will also need to have the user provide an administrator password
            // because blank admin passwords are no longer acceptable on servers.  This
            // can be especially deadly on headless machines because it means the admin
            // can never login to change the admin password from being blank.  For that
            // reason, let's go get a password right now.
            //
            // Before we do that though, we need to accomodate OEMs that actually
            // *want* to ship their servers with a blank admin password.  They do
            // this because they want to allow the end-user to set the password
            // themselves.  To detect that, we need to look for a secondary
            // unattend key that says it's okay to allow a blank password.
            //
            Value[0] = SpGetSectionKeyIndex( WinntSifHandle,
                                             WINNT_GUIUNATTENDED_W, 
                                             L"EMSBlankPassWord",
                                             0 );
            if( (Value[0] == NULL) || 
                !(_wcsicmp(Value[0], L"0")) ||
                !(_wcsicmp(Value[0], L"no")) ) {
                //
                // It's either not there, it's '0', or it's 'no'.  Any
                // of these mean that we do need an admin password on this
                // headless server.  Go get it now.
                //
            
                if( SpGetAdministratorPassword( Answer, ARRAYSIZE(Answer)) ) {
        
                    // Write the password into the unattend file.
                    Value[0] = Answer;
                    SpAddLineToSection( WinntSifHandle, 
                                        WINNT_GUIUNATTENDED_W,
                                        WINNT_US_ADMINPASS_W,
                                        Value,
                                        1 );
                }
            }
        }
    }


    if (ForceConsole) {
        CLEAR_ENTIRE_SCREEN();
    }

    //
    // Detect/load scsi miniports.
    // WARNING WARNING WARNING
    //
    // Do NOT change the order of the actions carried out below without
    // understanding EXACTLY what you are doing.
    // There are many interdependencies...
    //
    SpConfirmScsiMiniports(SifHandle, NtBootDevicePath, DirectoryOnBootDevice);

    //
    // Load disk class drivers if necessary.
    // Do this before loading scsi class drivers, because atdisks
    // and the like 'come before' scsi disks in the load order.
    //
    SpLoadDiskDrivers(SifHandle,NtBootDevicePath,DirectoryOnBootDevice);

    //
    // Load scsi class drivers if necessary.
    //
    SpLoadScsiClassDrivers(SifHandle,NtBootDevicePath,DirectoryOnBootDevice);

    //
    // Reinitialize ARC<==>NT name translations.
    // Do this after loading disk and scsi class drivers because doing so
    // may bring additional devices on-line.
    //
    SpFreeArcNames();
    SpInitializeArcNames(VirtualOemSourceDevices);

    SendSetupProgressEvent(InitializationEvent, InitializationEndEvent, NULL);
    SendSetupProgressEvent(PartitioningEvent, PartitioningStartEvent, NULL);

    //
    // Initialize hard disk information.
    // Do this after loading disk drivers so we can talk to all attached disks.
    //
    SpDetermineHardDisks(SifHandle);

    SendSetupProgressEvent(PartitioningEvent, ScanDisksEvent, &HardDiskCount);

    //
    // Figure out where we are installing from (cd-rom or floppy).
    //      (tedm, 12/8/93) there is a minor problem here.
    //      This only works because we currently only support scsi cd-rom drives,
    //      and we have loaded the scsi class drivers above.
    //      SpDetermineInstallationSource won't allow cd-rom installation
    //      it there are no cd-rom drives on-line -- but we haven't loaded
    //      non-scsi cd-rom drivers yet.  What we really should do is
    //      allow cd-rom as a choice on all machines, and if the user selects
    //      it, not verify the presence of a drive until after we have called
    //      SpLoadCdRomDrivers().
    //
    // If winnt setup, defer this for now, because we will let the partitioning
    // engine search for the local source directory when it initializes.
    //

    TESTHOOK(2);

    if (Win9xRollback) {
        CdInstall = FALSE;
    } else {
        CdInstall = ((WinntSetup && !WinntFromCd && !RemoteBootSetup && !RemoteSysPrepSetup) ||
                        ConsoleFromWinnt32)
                  ? FALSE
                  : SpDetermineInstallationSource(
                        SifHandle,
                        &SetupSourceDevicePath,
                        &DirectoryOnSetupSource,
                        FALSE           // restart if CD-ROM is not present
                        );
    }

    //
    // Load cd-rom drivers if necessary.
    // Note that if we booted from CD (like on an ARC machine) then drivers
    // will already have been loaded by setupldr.  This call here catches the
    // case where we booted from floppy or hard disk and the user chose
    // 'install from cd' during SpDetermineInstallationSource.
    //
    // If we're in step-up mode then we load cd drivers, because the user
    // might need to insert a CD to prove that he qualifies for the step-up.
    //
    if (StepUpMode || CdInstall) {
        SpLoadCdRomDrivers(SifHandle,NtBootDevicePath,DirectoryOnBootDevice);

        //
        // Reinitialize ARC<==>NT name translations.
        //
        SpFreeArcNames();
        SpInitializeArcNames(VirtualOemSourceDevices);
    }

    //
    // At this point, any and all drivers that are to be loaded
    // are loaded -- we are done with the boot media and can switch over
    // to the setup media
    //
    // Initialize the partitioning engine.
    //
    SpPtInitialize();

    TESTHOOK(3);

    //
    // Initialize the boot variables (for ARC)
    //
    if (SpIsArc()) {
        SpInitBootVars();
    }

    //
    // If this is a winnt setup, the partition engine initialization
    // will have attempted to locate the local source partition for us.
    //
    // WARNING: Do not use the SetupSourceDevicePath or DirectoryOnSetupSource
    //      variables in the winnt case until AFTER this bit of code has executed
    //      as they are not set until we get here!
    //
    if(!ForceConsole && !Win9xRollback && WinntSetup && !WinntFromCd && !RemoteBootSetup && !RemoteSysPrepSetup) {
        SpGetWinntParams(&SetupSourceDevicePath,&DirectoryOnSetupSource);
    }

    if (!SpIsArc()) {
        //
        // Initialize the boot variables (amd64/x86)
        //
        SpInitBootVars();
    }

    //
    // invoke the command console
    //
    if (ForceConsole) {
        SpStartCommandConsole(SifHandle,SetupSourceDevicePath,DirectoryOnSetupSource);
        SpShutdownSystem();
    }

    //
    // invoke rollback
    //

#if defined(_X86_)
    if (Win9xRollback) {

        PCWSTR testPath;
        BOOLEAN defaultToBootDir = TRUE;

        TESTHOOK(1001);     // this is bugcheck point 2001 in the answer file

        //
        // Prepare the globals that tell the rest of the code which drives to use
        //

        WinUpgradeType = SpLocateWin95 (&TargetRegion, &TargetPath, &SystemPartitionRegion);

        if(!SpIsArc()) {
            //
            // system partition directory is the root of C:.
            //
            SystemPartitionDirectory = L"";
        } else {
            SystemPartitionDirectory = SpDetermineSystemPartitionDirectory(
                                            SystemPartitionRegion,
                                            OriginalSystemPartitionDirectory
                                            );
        }

        SpStringToUpper(TargetPath);

        //
        // Force the ~LS directory to be the ~BT directory if needed. We need
        // this for autochk (which is normally in ~ls during setup).
        //

        if (LocalSourceRegion) {
            SpGetWinntParams (&SetupSourceDevicePath, &DirectoryOnSetupSource);

            if (SetupSourceDevicePath && DirectoryOnSetupSource) {
                wcscpy (TemporaryBuffer, SetupSourceDevicePath);
                SpConcatenatePaths (TemporaryBuffer, DirectoryOnSetupSource);

                testPath = SpDupStringW (TemporaryBuffer);

                if (SpFileExists (testPath, TRUE)) {
                    defaultToBootDir = FALSE;
                }

                SpMemFree ((PVOID) testPath);
            }
        }

        if (defaultToBootDir) {
            SetupSourceDevicePath = SpDupStringW (NtBootDevicePath);
            DirectoryOnSetupSource = SpDupStringW (L"\\$win_nt$.~bt");
        }

        //
        // Execute autochk
        //

        AutochkRunning = TRUE;

        SpRunAutochkOnNtAndSystemPartitions (
            SifHandle,
            TargetRegion,
            SystemPartitionRegion,
            SetupSourceDevicePath,
            DirectoryOnSetupSource,
            TargetPath
            );

        AutochkRunning = FALSE;

        TESTHOOK(1002);     // this is bugcheck point 2002 in the answer file

        //
        // We finished; now it is safe to restore the machine
        //

        SpExecuteWin9xRollback (WinntSifHandle, NtBootDevicePath);
        goto CleanAndFinish;
    }
#endif // defined(_X86_)

    if(!SpDrEnabled()) {
        //
        // Display End User Licensing Agreement.  Also, in unattended case,
        // make sure the media is available.
        //

        SpDisplayEula (
                SifHandle,
                SetupSourceDevicePath,
                DirectoryOnSetupSource);
    }

    //
    //  Read the product id and setup info from setupp.ini. If we are doing ASR (specifically
    //  ER), we will wait, and only require the CD if we need it.
    //

    if (!SpDrEnabled()) {
        SpInitializePidString( SifHandle,
                               SetupSourceDevicePath,
                               DirectoryOnSetupSource );
    }

    //
    // Find out if there is any NT to upgrade and if the user wants us to
    // upgrade it.
    //
#if defined(REMOTE_BOOT)
    // If this is a remote boot setup, the target partition is
    // specified in winnt.sif.
    //
#endif // defined(REMOTE_BOOT)

    TargetRegion = NULL;

    if(SpDrEnabled()) {
        NTUpgrade = DontUpgrade;
    } else if (RemoteSysPrepSetup) {
        NTUpgrade = DontUpgrade;
    } else {
        NTUpgrade = SpFindNtToUpgrade(SifHandle,
                                  &TargetRegion,
                                  &TargetPath,
                                  &SystemPartitionRegion,
                                  &OriginalSystemPartitionDirectory);
    }

    if( PreInstall ) {
        //
        // In pre-install mode, get the information about the components
        // to pre-install
        //
        wcscpy( TemporaryBuffer, DirectoryOnSetupSource );
        SpConcatenatePaths( TemporaryBuffer, WINNT_OEM_TEXTMODE_DIR_W );
        PreinstallOemSourcePath = SpDupStringW( ( PWSTR )TemporaryBuffer );
        SpInitializePreinstallList(SifHandle,
                                   SetupSourceDevicePath ,
                                   PreinstallOemSourcePath);
    }

    //
    // Detect/confirm hardware.
    //
    SpConfirmHardware(SifHandle);
    //
    // Reinitialize the keyboard layout dll. This is a no-op for western builds
    // but in Far East builds this can cause a new keyboard layout dll to be loaded.
    //
    if(NTUpgrade != UpgradeFull) {
        extern PVOID KeyboardTable;

        SplangReinitializeKeyboard(
            UnattendedOperation,
            SifHandle,
            DirectoryOnBootDevice,
            &KeyboardTable,
            HardwareComponents
            );
    }

    TESTHOOK(4);

    //
    // Try to locate previous versions of windows, IFF we are not repairing
    //
#if defined(_X86_)
    if (!RepairWinnt && !SpDrEnabled()) {
      if(!RemoteBootSetup && !RemoteSysPrepSetup && (NTUpgrade == DontUpgrade)) {
          //
          // Take a gander on the hard drives, looking for win95 or win3.1.
          //
          WinUpgradeType = SpLocateWin95(&TargetRegion,&TargetPath,&SystemPartitionRegion);
          if(WinUpgradeType == NoWinUpgrade) {
              if(SpLocateWin31(SifHandle,&TargetRegion,&TargetPath,&SystemPartitionRegion)) {
                  WinUpgradeType = UpgradeWin31;
                  //
                  // Note that on x86, it can happen that the machine already has NT installed
                  // on top of Win31, and the user is not upgrading NT but he is upgrading win31.
                  //
                  // This is kind of a strange case but we take the extra step here to
                  // ensure that the config directory is cleaned out so the fresh install
                  // will really be fresh.
                  //
                  if(SpIsNtInDirectory(TargetRegion,TargetPath)) {
                      NTUpgrade = UpgradeInstallFresh;
                  }
              }
          } else {

              //
              // We come here only if we are in the Win9x/Win31 case
              // WE want to make sure that we have a TargetRegion at this point
              //

              
              if( !TargetRegion ){

                  //Tell the user that we could not find Win9x to upgrade
                  //This is potentially possible when Win9x was installed on 1394 or USB or some such drive that is 
                  //not supported currently for the install drive.

                  KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: We could not find the installation to upgrade (Win9x) - could be on USB or Firewire drive\n" ));

                  SpCantFindBuildToUpgrade();

              }

          }

      } else {
          //
          // Just check to see if the target region also contains WIN31, Note
          // that the MIN KB to check for is 0, since we already have done
          // the space check.
          // Note also that if the directory contains Win95, then the Win95
          // migration was already done when NT was installed, and we don't
          // care about it now.
          //
          if(!RemoteBootSetup && !RemoteSysPrepSetup && SpIsWin31Dir(TargetRegion,TargetPath,0)) {
              if(SpConfirmRemoveWin31()) {
                  WinUpgradeType = UpgradeWin31;
              }
          } else {
              WinUpgradeType = NoWinUpgrade;
          }
      }
    }

    if (IsNEC_98) { //NEC98

        if (WinUpgradeType==UpgradeWin31) {

            //
            // Remap drive letter, as hard drive start from A:
            //
            DriveAssignFromA = TRUE;
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Re-map drive letters as NEC assign.\n" ));
            SpPtRemapDriveLetters(FALSE); // Re-map as "NEC" assign.

            //
            //  ReInitialize structure;
            //
            SpPtAssignDriveLetters();

        }

    } //NEC98
#endif // defined(_X86_)

    //
    //  Special case upgrades where we want to convert to NTFS
    //
    if( ANY_TYPE_OF_UPGRADE && (( UnattendedSifHandle && (NtfsConvert = SpGetSectionKeyIndex(UnattendedSifHandle,SIF_UNATTENDED,L"Filesystem",0)) ) ||
        ( WinntSifHandle && (NtfsConvert = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,L"Filesystem",0))) ) ) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Should we convert to NTFS ?\n" ));

        if(!_wcsicmp(NtfsConvert,L"ConvertNtfs")){
            ConvertNtVolumeToNtfs = TRUE;
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Yes we should convert to NTFS\n" ));
        }
    }



    //
    // Do partitioning and ask the user for the target path.
    //
    if(!ANY_TYPE_OF_UPGRADE) {

        if(SpDrEnabled()) {
            BOOLEAN RepairedNt = FALSE;

            TargetRegion = NULL;
            SystemPartitionRegion = NULL;

            SpDrPtPrepareDisks(
                        SifHandle,
                        &TargetRegion,
                        &SystemPartitionRegion,
                        SetupSourceDevicePath,
                        DirectoryOnSetupSource,
                        &RepairedNt
                        );

            //
            // invoke the command console
            //
            if (ForceConsole) {
                CLEAR_ENTIRE_SCREEN();
                SpStartCommandConsole(SifHandle,SetupSourceDevicePath,DirectoryOnSetupSource);
                SpShutdownSystem();
            }

            if (RepairedNt) {
                //
                // retrieve information about the install we repaired
                //

                ASSERT(Gbl_HandleToSetupLog != NULL);

                SppGetRepairPathInformation(
                        Gbl_HandleToSetupLog,
                        &Gbl_SystemPartitionName,
                        &Gbl_SystemPartitionDirectory,
                        &Gbl_BootPartitionName,
                        &Gbl_BootPartitionDirectory );

                TargetPath = Gbl_BootPartitionDirectory;
                SystemPartitionDirectory = Gbl_SystemPartitionDirectory;

                ASSERT((TargetPath != NULL) && (SystemPartitionDirectory != NULL));

                RepairWinnt = TRUE;

                goto UpdateBootList;
            }
        }
        else if (RemoteSysPrepSetup) {

            PWSTR UseWholeDisk = NULL;
            BOOLEAN UseWholeDiskFlag = TRUE;

            //
            // Find IMirror.Dat file on server.  doesn't return on failure.
            //
            SpReadIMirrorFile(&RemoteIMirrorFileData, RemoteIMirrorFilePath);

            //
            // Determine what the local disk layout should be based
            // on IMirror.Dat and possible user input.  doesn't return on
            // failure. Read the .sif to see if it specifies that disks
            // should be partitioned as they originally were, or use the
            // entire size of the new disk.
            //
#if defined(REMOTE_BOOT)
            UseWholeDisk = SpGetSectionKeyIndex(WinntSifHandle,SIF_REMOTEBOOT,SIF_USEWHOLEDISK,0);
#else
            UseWholeDisk = SpGetSectionKeyIndex(WinntSifHandle,SIF_REMOTEINSTALL,SIF_USEWHOLEDISK,0);
#endif

            if ((UseWholeDisk != NULL) &&
                ((UseWholeDisk[0] == 'N') || (UseWholeDisk[0] == 'n')))
            {
                UseWholeDiskFlag = FALSE;
            }

            SpDetermineDiskLayout(RemoteIMirrorFileData, &RemoteIMirrorMemoryData);

            //
            // Make the local disks look ok.  doesn't return on failure.
            //

            SpFixupLocalDisks(SifHandle,
                              &TargetRegion,
                              &SystemPartitionRegion,
                              SetupSourceDevicePath,
                              DirectoryOnSetupSource,
                              RemoteIMirrorMemoryData,
                              UseWholeDiskFlag);
        } else {
            PWSTR RemoteBootRepartition = NULL;
            BOOLEAN PrepareForRemoteBoot = RemoteBootSetup;

            //
            // We tell SpPtPrepareDisks to repartition in a remote boot
            // case, unless there is an entry in the [RemoteBoot] section
            // saying "Repartition = No".
            //

            if (RemoteBootSetup) {
#if defined(REMOTE_BOOT)
                RemoteBootRepartition = SpGetSectionKeyIndex(WinntSifHandle,SIF_REMOTEBOOT,SIF_REPARTITION,0);
#else
                RemoteBootRepartition = SpGetSectionKeyIndex(WinntSifHandle,SIF_REMOTEINSTALL,SIF_REPARTITION,0);
#endif // defined(REMOTE_BOOT)
                if ((RemoteBootRepartition != NULL) &&
                    ((RemoteBootRepartition[0] != 'Y') && (RemoteBootRepartition[0] != 'y')))
                {
                    PrepareForRemoteBoot = FALSE;
                }
            } else {                
                BOOLEAN IsCdBoot = (!WinntSetup && !WinntFromCd);

                //
                // Honor Repartition flag only in the case of CD boot
                //
                if (UnattendedSifHandle && IsCdBoot) {
                
                    RemoteBootRepartition = SpGetSectionKeyIndex(UnattendedSifHandle,
                                                SIF_UNATTENDED,
                                                SIF_REPARTITION,
                                                0);

                    if ((RemoteBootRepartition != NULL) &&
                        ((RemoteBootRepartition[0] == 'Y') || (RemoteBootRepartition[0] == 'y')))
                    {
                        PrepareForRemoteBoot = TRUE;
                    }
                }
            }







            //
            // HACK
            // Some OEMs are shipping machines with a hidden, active partition
            // that gets marked unactive after the machine is booted once.  The
            // problem is that sometimes these machines are turned on with a win2k
            // bootable CD in them and we do all sorts of nasty stuff to their
            // hidden partition because its marked active and we think it's a
            // boot partition (which it is).
            //
            // If we detect this case, then we need to throw an error message
            // and go to the partitioning screen.
            //
            while( 1 ) {
                SpPtPrepareDisks(
                    SifHandle,
                    &TargetRegion,
                    &SystemPartitionRegion,
                    SetupSourceDevicePath,
                    DirectoryOnSetupSource,
                    PrepareForRemoteBoot
                    );

#if defined(_AMD64_) || defined(_X86_)
                if( SpIsArc() )
                    break;

                //
                // Only check this on a BIOS X86 machine
                //
                if( SpPtIsSystemPartitionRecognizable() ) {
#else
                if( 1 ) {
#endif // defined(_AMD64_) || defined(_X86_)
                    break;
                } else {
                    //
                    // Either exit or go back to the partitioning menu.
                    //
                    SpInvalidSystemPartition();
                }
            }




#if defined(REMOTE_BOOT)
            //
            // If this is a remote boot, erase any existing CSC cache, if we
            // did not repartition.
            //

            if (RemoteBootSetup && !RemoteInstallSetup && !PrepareForRemoteBoot &&
                !RemoteSysPrepSetup && (HardDiskCount != 0)) {
                SpEraseCscCache(SystemPartitionRegion);
            }
#endif // defined(REMOTE_BOOT)

        }

        //
        // Partitioning may have changed the partition ordinal of the local source
        //
        if(WinntSetup && !WinntFromCd) {
            SpMemFree(SetupSourceDevicePath);
            SpGetWinntParams(&SetupSourceDevicePath,&DirectoryOnSetupSource);
        }

        DefaultTarget = SpGetSectionKeyIndex(
                            SifHandle,
                            SIF_SETUPDATA,
                            SIF_DEFAULTPATH,
                            0
                            );

        if(!DefaultTarget) {

            SpFatalSifError(
                SifHandle,
                SIF_SETUPDATA,
                SIF_DEFAULTPATH,
                0,
                0
                );
        }

        //
        // Select the target path.
        //
        if (TargetRegion != NULL)
            DeleteTarget = SpGetTargetPath(SifHandle,TargetRegion,DefaultTarget,&TargetPath);


    }

    TESTHOOK(5);

    //
    // Form the SystemPartitionDirectory
    //
    if(!SpIsArc())
    {
        //
        // system partition directory is the root of C:.
        //
        SystemPartitionDirectory = L"";
    }
    else
    {
        SystemPartitionDirectory = SpDetermineSystemPartitionDirectory(
                                        SystemPartitionRegion,
                                        OriginalSystemPartitionDirectory
                                        );
    }

    SpStringToUpper(TargetPath);



    //
    // do any file system conversion
    //
    if(!RemoteSysPrepSetup && !SpDrEnabled()) {
        SpUpgradeToNT50FileSystems(
            SifHandle,
            SystemPartitionRegion,
            TargetRegion,
            SetupSourceDevicePath,
            DirectoryOnSetupSource
            );
    }


    //
    // Run autochk on Nt and system partitions
    //

    //
    // if it boot from hard disk, need to check the current partition.
    //

    if(IsNEC_98) {
        BootRegion = SystemPartitionRegion;

        if(!_wcsnicmp(NtBootDevicePath,DISK_DEVICE_NAME_BASE,wcslen(DISK_DEVICE_NAME_BASE))) {
            SpEnumerateDiskRegions( (PSPENUMERATEDISKREGIONS)SpDetermineBootPartitionEnumNec98,
                                    (ULONG_PTR)&BootRegion );
        }
    }

    if (!SpAsrIsQuickTest()) {

        AutochkRunning = TRUE;

        SpRunAutochkOnNtAndSystemPartitions( SifHandle,
                                             TargetRegion,
                                             (!IsNEC_98 ? SystemPartitionRegion : BootRegion),
                                             SetupSourceDevicePath,
                                             DirectoryOnSetupSource,
                                             TargetPath
                                             );

        AutochkRunning = FALSE;
    }

    if( DeleteTarget )
            SpDeleteExistingTargetDir( TargetRegion, TargetPath, TRUE, SP_SCRN_CLEARING_OLD_WINNT );

#ifdef _X86_
    if (WinUpgradeType == UpgradeWin95) {
        enableBackup = SpGetSectionKeyIndex (
                            WinntSifHandle,
                            WINNT_D_WIN9XUPG_USEROPTIONS_W,
                            WINNT_D_ENABLE_BACKUP_W,
                            0
                            );

        if (enableBackup && _wcsicmp(enableBackup, WINNT_A_YES_W) == 0) {
            disableCompression = SpGetSectionKeyIndex (
                                    WinntSifHandle,
                                    WINNT_D_WIN9XUPG_USEROPTIONS_W,
                                    WINNT_D_DISABLE_BACKUP_COMPRESSION_W,
                                    0
                                    );

            if (disableCompression && _wcsicmp(disableCompression, WINNT_A_YES_W) == 0) {
                compressionType = tcompTYPE_NONE;
            } else {
                compressionType = tcompTYPE_MSZIP;
            }

            g_Win9xBackup = SpBackUpWin9xFiles (WinntSifHandle, compressionType);
        }
    }
#endif // X86

    //
    // If we are installing into an existing tree we need to delete some
    // files and backup some files
    //
    if(NTUpgrade != DontUpgrade) {
       SpDeleteAndBackupFiles(
           SifHandle,
           TargetRegion,
           TargetPath
           );
    }

    TESTHOOK(6);

#ifdef _X86_
    //
    // If we are migrating Win95, delete some files, and move other files
    //
    switch(WinUpgradeType) {
    case UpgradeWin95:
        SpDeleteWin9xFiles(WinntSifHandle);
        SpMoveWin9xFiles(WinntSifHandle);
        break;
    case UpgradeWin31:
        SpRemoveWin31(TargetRegion,TargetPath);
        break;
    }
#endif

#if defined(REMOTE_BOOT)
    //
    // If this is a remote boot, tell the redirector that the local disk is
    // ready to be used for "local" items like the cache and pagefile.
    //

    if (RemoteBootSetup && !RemoteInstallSetup && !RemoteSysPrepSetup && (HardDiskCount != 0)) {
        IoStartCscForTextmodeSetup( (BOOLEAN)(NTUpgrade != DontUpgrade) );
    }
#endif // defined(REMOTE_BOOT)

    TESTHOOK(7);

    //
    // Create the paging file.
    //
    // The copy files and registry operations use memory mapped IO.
    // This can result in huge numbers of dirty pages and can cause
    // the filesystems to throttle if the percentage of memory that
    // is dirty becomes high.   The only way out of this is for the
    // dirty page writer thread to run and it cannot do so unless
    // there is a paging file.
    //
    SpNtNameFromRegion(
        TargetRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );
    SpConcatenatePaths(TemporaryBuffer,L"PAGEFILE.SYS");
    FullTargetPath = SpDupStringW(TemporaryBuffer);

    // Status = SpCreatePageFile(FullTargetPath,1*(1024*1024*1024),(1792*1024*1024));
    Status = SpCreatePageFile(FullTargetPath,40*(1024*1024),50*(1024*1024));
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Warning: unable to create pagefile %ws (%lx)",FullTargetPath,Status));
    }

    SpMemFree(FullTargetPath);

    //
    // On a remote boot machine, copy over the sources to the disk,
    // then change the setup path to point to them.
    //
    if (RemoteInstallSetup) {

        PWSTR TargetPartitionName;
        PWSTR CopySource;
        PWSTR LocalSourcePath;

        //
        // Initialize the diamond decompression engine.
        //
        SpdInitialize();

        wcscpy( TemporaryBuffer, SetupSourceDevicePath );
        SpConcatenatePaths( TemporaryBuffer, DirectoryOnSetupSource );
        CopySource = SpDupStringW( TemporaryBuffer );

        //
        // Copy all the source files to the disk.
        //

        SpNtNameFromRegion(
            TargetRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer),
            PartitionOrdinalCurrent
            );

        TargetPartitionName = SpDupStringW(TemporaryBuffer);

        //
        // Delete the directory if it is there.
        //

        SpConcatenatePaths(TemporaryBuffer,
                           LocalSourceDirectory);
        LocalSourcePath = SpDupStringW(TemporaryBuffer);

        if (SpFileExists(LocalSourcePath, TRUE)) {

            ENUMFILESRESULT Result;

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Deleting existing %ws directory\n", LocalSourcePath));

            SpStartScreen(SP_SCRN_WAIT_REMOVING_TEMP_FILES,0,6,TRUE,FALSE,DEFAULT_ATTRIBUTE);

            Result = SpEnumFilesRecursive(
                         LocalSourcePath,
                         SpDelEnumFile,
                         &Status,
                         NULL);
        }

        SpMemFree(LocalSourcePath);

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Copying directories from %ws to %ws%ws\n",
            CopySource, TargetPartitionName, LocalSourceDirectory));

        SpCopyDirRecursive(
            CopySource,
            TargetPartitionName,
            LocalSourceDirectory,
            COPY_NODECOMP
            );

        //
        // Now that the copy is done, the setup source path becomes the
        // previous target. We are no longer even pretending to be doing
        // a remote boot setup.
        //

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Switching to local setup source\n"));

        SetupSourceDevicePath = TargetPartitionName;
        DirectoryOnSetupSource = LocalSourceDirectory;
        if ( PreInstall ) {
            wcscpy( TemporaryBuffer, DirectoryOnSetupSource );
            SpConcatenatePaths( TemporaryBuffer, WINNT_OEM_TEXTMODE_DIR_W );
            SpMemFree( PreinstallOemSourcePath );
            PreinstallOemSourcePath = SpDupStringW( TemporaryBuffer );
        }

        RemoteBootSetup = FALSE;

        SpMemFree(CopySource);
    }

    //
    // If this isn't an automated ASR test, copy the files that make up the product.
    // Note that we cannot pass \device\floppy0 to SpCopyFiles() as a constant string,
    // because this function at some point will attempt to convert the string to lower case,
    // which will cause a bugcheck, since SpToLowerCase will overwrite the constant string.
    // So we make a duplicate of the constant string.
    //
    ThirdPartySourceDevicePath = SpDupStringW( L"\\device\\floppy0" );

    if (RemoteSysPrepSetup) {

        //
        // Initialize the diamond decompression engine.
        //
        SpdInitialize();

        SpInstallSysPrepImage(SifHandle,WinntSifHandle, RemoteIMirrorFileData, RemoteIMirrorMemoryData);

        SpFixupThirdPartyComponents( SifHandle,
                                     ( PreInstall ) ? SetupSourceDevicePath : ThirdPartySourceDevicePath,
                                     TargetRegion,
                                     TargetPath,
                                     SystemPartitionRegion,
                                     SystemPartitionDirectory );

        goto CleanAndFinish;
    }

    //
    // HACK: rename setupapi.log to setupapi.old here because this logfile can
    //       get very large on upgrades
    //
    if (NTUpgrade != DontUpgrade) {
        SpRenameSetupAPILog(TargetRegion,TargetPath);
    }

    if (!SpAsrIsQuickTest()) {
        SpCopyFiles(
            SifHandle,
            SystemPartitionRegion,
            TargetRegion,
            TargetPath,
            SystemPartitionDirectory,
            SetupSourceDevicePath,
            DirectoryOnSetupSource,
            ( PreInstall )? SetupSourceDevicePath : ThirdPartySourceDevicePath
            );
    }

    TESTHOOK(8);

    if (SpDrEnabled()) {
        SpDrCleanup();
    }

#if defined HEADLESS_ATTENDEDTEXTMODE_UNATTENDEDGUIMODE

    // Get data into inf file if we have a terminal connected and it
    // is a fresh install only
    if (HeadlessTerminalConnected && (!UnattendedOperation) &&(!ANY_TYPE_OF_UPGRADE)) {
        UnattendedGuiOperation = TRUE;
        SpGetNecessaryParameters();
        if (AdvancedServer) {
            SpGetServerDetails();
        }

    }
#endif

    SendSetupProgressEvent(SavingSettingsEvent, SavingSettingsStartEvent, NULL);


    //
    // Process Crash Recovery settings on upgrade. We call this here for another reason here. We flush the
    // $winnt$.inf file in SpInitializeRegistry. Since we write to that file doing it here makes sure that 
    // the file gets the entries we wrote
    //
    
    if( NTUpgrade == UpgradeFull ){
        SpDisableCrashRecoveryForGuiMode(TargetRegion, TargetPath);
    }

    if (ASRMODE_QUICKTEST_TEXT != SpAsrGetAsrMode()) {
        //
        // Configure the registry.
        //
        SpInitializeRegistry(
            SifHandle,
            TargetRegion,
            TargetPath,
            SetupSourceDevicePath,
            DirectoryOnSetupSource,
            wcsstr(DirectoryOnBootDevice,L"\\$WIN_NT$.~BT") ? NtBootDevicePath : NULL,
            SystemPartitionRegion
            );

        TESTHOOK(9);
    }

    SendSetupProgressEvent(SavingSettingsEvent, HiveProcessingEndEvent, NULL);

    



UpdateBootList:

    if (SpDrEnabled() && !RepairWinnt)  {    // ASR (not ER)
        SpDrCopyFiles();
    }

#ifdef _X86_
//
// NEC98
//
    if (IsNEC_98) { //NEC98
        //
        // Once clear BOOTVARS[], then rebuild it when upgrade from NT.
        //
        TargetRegion_Nec98 = TargetRegion;
        SpReInitializeBootVars_Nec98();
    } //NEC98
#endif

    //
    // If this is an upgrade we need to remove the entry which exists for
    // this system right now, because we are using new entries.  We can use
    // this opportunity to also clean out the boot ini and remove all entries
    // which point to the current nt partition and path
    //
    // Also do this in the case where we wiped out an existing directory during
    // a clean install.
    //
    OldOsLoadOptions = NULL;
    if(NTUpgrade == UpgradeFull || RepairItems[RepairNvram] || DeleteTarget
#if defined(REMOTE_BOOT)
       || RemoteBootSetup
#endif // defined(REMOTE_BOOT)
       ) {
        SpRemoveInstallationFromBootList(
            NULL,
            TargetRegion,
            TargetPath,
            NULL,
            NULL,
            PrimaryArcPath,
#if defined(REMOTE_BOOT)
            RemoteBootSetup,
#endif // defined(REMOTE_BOOT)
            &OldOsLoadOptions
            );

#if defined(_AMD64_) || defined(_X86_)
        // call again to delete the secondary Arc name
        SpRemoveInstallationFromBootList(
            NULL,
            TargetRegion,
            TargetPath,
            NULL,
            NULL,
            SecondaryArcPath,
#if defined(REMOTE_BOOT)
            RemoteBootSetup,
#endif // defined(REMOTE_BOOT)
            &OldOsLoadOptions
            );
#endif // defined(_AMD64_) || defined(_X86_)
    }


#if defined(_AMD64_) || defined(_X86_)
    //
    // Lay NT boot code on C:.  Do this before flushing boot vars
    // because it may change the 'previous os' selection.
    //
    if ((SystemPartitionRegion != NULL) && (!RepairWinnt || RepairItems[RepairBootSect])) {
        SpLayBootCode(SystemPartitionRegion);
    }
#endif // defined(_AMD64_) || defined(_X86_)

/*
At the end of text-mode setup, issue an IOCTL_STORAGE_EJECT_MEDIA to the CD-ROM
you are installing from.  On some machines this won't help at all, but on others we
can avoid the (txtsetup, reboot, boot from CD back into txtsetup) cycle that i always
get into.  This would also provide an interrupt for developers like me who don't pay
any attention to setup - we could tell when textmode setup was finished.

In GUI-mode setup if the CD can't be found in the cdrom drive issue an
IOCTL_STORAGE_LOAD_MEDIA to the cd to pull the tray back in.

If you still can't find the CD, wait for a media change notification from the
system.  When you get one (or the user hits the okay button), you continue.
Figureing out when the media has been inserted automagically would be snazzier
than just waiting there for the user to hit the OK button.
*/


#if defined(REMOTE_BOOT)
    //
    // If this is a remote boot setup, rename the loaders and initialize configuration.
    //

    if (RemoteBootSetup) {
        (VOID)SpFixupRemoteBootLoader(RemoteBootTarget);
        (VOID)SpCreateRemoteBootCfg(RemoteBootTarget, SystemPartitionRegion);
    }
#endif // defined(REMOTE_BOOT)

    if (!RepairWinnt || RepairItems[RepairNvram]) {

        //
        // Add a boot set for this installation.
        //
        SpAddInstallationToBootList(
            SifHandle,
            SystemPartitionRegion,
            SystemPartitionDirectory,
            TargetRegion,
            TargetPath,
            FALSE,
            OldOsLoadOptions
            );

        if(OldOsLoadOptions) {
            SpMemFree(OldOsLoadOptions);
        }

        SpCleanSysPartOrphan();

#if defined(REMOTE_BOOT)
        //
        // Make sure that the boot.ini in the machine directory is written.
        //
        if (RemoteBootSetup) {
            if (!SpFlushRemoteBootVars(TargetRegion)) {
                WCHAR   DriveLetterString[2];

                DriveLetterString[0] = TargetRegion->DriveLetter;
                DriveLetterString[1] = L'\0';
                SpStringToUpper(DriveLetterString);
                SpStartScreen(SP_SCRN_CANT_INIT_FLEXBOOT,
                              3,
                              HEADER_HEIGHT+1,
                              FALSE,
                              FALSE,
                              DEFAULT_ATTRIBUTE,
                              DriveLetterString,
                              DriveLetterString
                              );
                // SpDisplayScreen(SP_SCRN_CANT_INIT_FLEXBOOT,3,HEADER_HEIGHT+1);
                SpDisplayStatusText(SP_STAT_F3_EQUALS_EXIT,DEFAULT_STATUS_ATTRIBUTE);
                SpInputDrain();
                while(SpInputGetKeypress() != KEY_F3) ;
                SpDone(0,FALSE,TRUE);
            }
        }
#endif // defined(REMOTE_BOOT)

        SpCompleteBootListConfig( TargetRegion->DriveLetter );

        if (IsNEC_98) { //NEC98
            //
            // Set auto boot flag into PTE.
            //
            SpSetAutoBootFlag(TargetRegion,TRUE);
        } //NEC98
    }

    //
    //  If system was repaired, and either the System Partition
    //  or the NT Partition is an FT partition, then set the
    //  appropriate flag in the registry, so that next time the
    //  system boots, it checks and updates the partition's image.
    //
    //  (guhans) removed SpDrEnabled, ASR doesn't support FT partitions
    //
    if( RepairWinnt ) {
        UCHAR        TmpSysId;
        UCHAR        TmpNtPartitionSysId;
        BOOLEAN      SystemPartitionIsFT;
        BOOLEAN      TargetPartitionIsFT;

        TmpSysId = SpPtGetPartitionType(SystemPartitionRegion);
        ASSERT(TmpSysId != PARTITION_ENTRY_UNUSED);

        SystemPartitionIsFT = ((TmpSysId & VALID_NTFT) == VALID_NTFT) ||
                              ((TmpSysId & PARTITION_NTFT) == PARTITION_NTFT);

        TmpSysId = SpPtGetPartitionType(TargetRegion);
        ASSERT(TmpSysId != PARTITION_ENTRY_UNUSED);

        TargetPartitionIsFT = ((TmpSysId & VALID_NTFT) == VALID_NTFT) ||
                              ((TmpSysId & PARTITION_NTFT) == PARTITION_NTFT);
#if defined(_AMD64_) || defined(_X86_)
        if( ( SystemPartitionIsFT &&
              ( RepairItems[ RepairNvram ] || RepairItems[ RepairBootSect ] )
            ) ||
            ( TargetPartitionIsFT &&
              ( RepairItems[ RepairFiles ] )
            )
          ) {
            SpSetDirtyShutdownFlag( TargetRegion, TargetPath );
        }
#else
        if( ( SystemPartitionIsFT || TargetPartitionIsFT ) && RepairItems[ RepairFiles ] ) {
            SpSetDirtyShutdownFlag( TargetRegion, TargetPath );
        }
#endif // defined(_AMD64_) || defined(_X86_)
    }

CleanAndFinish:

    if ((RemoteInstallSetup || RemoteSysPrepSetup) && (NetBootSifPath != NULL)) {
        //
        // Clean out the temporary .sif file. SpDeleteFile concatenates its
        // arguments to form the final path.
        //
        Status = SpDeleteFile(L"\\Device\\LanmanRedirector", NetBootSifPath, NULL);
        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not delete temporary file %ws\n", NetBootSifPath));
        }
    }

    SendSetupProgressEvent(SavingSettingsEvent, SavingSettingsEndEvent, NULL);

#if defined(EFI_NVRAM_ENABLED)
    //
    // Deal with the driver entry for fpswa.efi
    //
    {
        PWSTR SystemPartitionDevicePath;
        SpNtNameFromRegion(SystemPartitionRegion, TemporaryBuffer, sizeof(TemporaryBuffer), PartitionOrdinalCurrent);
        SystemPartitionDevicePath = SpDupStringW(TemporaryBuffer);

        Status = SpUpdateDriverEntry(
            FPSWA_DRIVER_IMAGE_NAME,
            FPSWA_DRIVER_FRIENDLY_NAME, 
            SystemPartitionDevicePath,
            SystemPartitionDirectory,
            NULL, 
            FPSWA_DRIVER_DEST_DIR
            );

        SpMemFree(SystemPartitionDevicePath);

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((
                DPFLTR_SETUP_ID, 
                DPFLTR_ERROR_LEVEL, 
                "SETUP: Could not update driver entry for fpswa.efi, status == %08lx\n",
                Status
                ));
        }
    }
#endif

    //
    // Done with boot variables and arc names.
    //
    SpFreeBootVars();
    SpFreeArcNames();

    SpDone(0,TRUE, UnattendedOperation ? UnattendWaitForReboot : TRUE);

    //
    // We never get here because SpDone doesn't return.
    //
    SpvidTerminate();
    SpInputTerminate();
    SpTerminate();
    return((ULONG)STATUS_SUCCESS);
}

VOID
SpDetermineProductType(
    IN PVOID SifHandle
    )

/*++

Routine Description:

    Determine whether this is advanced server we are setting up,
    as dictated by the ProductType value in [SetupData] section of
    txtsetup.sif.  A non-0 value indicates that we are running
    advanced server.

    Also determine product version.

    The global variables:

    - AdvancedServer
    - MajorVersion
    - MinorVersion

    are modified

Arguments:

    SifHandle - supplies handle to loaded txtsetup.sif.

Return Value:

    None.

--*/

{
    PWSTR p;
    ULONG l;

    //
    // Assume Workstation product.
    //
    AdvancedServer = FALSE;

    //
    // Get the product type from the sif file.
    //
    p = SpGetSectionKeyIndex(SifHandle,SIF_SETUPDATA,SIF_PRODUCTTYPE,0);
    if(p) {

        //
        // Convert to numeric value.
        //
        l = SpStringToLong(p,NULL,10);
        switch (l) {
            case 1:  //SRV
            case 2:  //ADS
            case 3:  //DTC
            case 5:  //BLA
        case 6:  //SBS
                AdvancedServer = TRUE;
                break;

            case 4: //PER
            case 0: //PRO
            default:
                ;
        }
    } else {
        SpFatalSifError(SifHandle,SIF_SETUPDATA,SIF_PRODUCTTYPE,0,0);
    }

    //
    // Get the product major version
    //
    p = SpGetSectionKeyIndex(
            SifHandle,
            SIF_SETUPDATA,
            SIF_MAJORVERSION,
            0
            );

    if(!p) {
        SpFatalSifError(SifHandle,SIF_SETUPDATA,SIF_MAJORVERSION,0,0);
    }
    WinntMajorVer = (ULONG)SpStringToLong(p,NULL,10);

    //
    // Get the product minor version
    //
    p = SpGetSectionKeyIndex(
            SifHandle,
            SIF_SETUPDATA,
            SIF_MINORVERSION,
            0
            );

    if(!p) {
        SpFatalSifError(SifHandle,SIF_SETUPDATA,SIF_MINORVERSION,0,0);
    }
    WinntMinorVer = (ULONG)SpStringToLong(p,NULL,10);

    //
    //  Build the string that contains the signature that
    //  identifies setup.log
    //  Allocate a buffer of reasonable size
    //
    SIF_NEW_REPAIR_NT_VERSION = SpMemAlloc( 30*sizeof(WCHAR) );
    if( SIF_NEW_REPAIR_NT_VERSION == NULL ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to allocate memory for SIF_NEW_REPAIR_NT_VERSION \n" ));
        return;
    }
    swprintf( SIF_NEW_REPAIR_NT_VERSION,
              SIF_NEW_REPAIR_NT_VERSION_TEMPLATE,
              WinntMajorVer,WinntMinorVer );

}


BOOL
SpDetermineInstallationSource(
    IN  PVOID  SifHandle,
    OUT PWSTR *DevicePath,
    OUT PWSTR *DirectoryOnDevice,
    IN  BOOLEAN bEscape
    )
{
    PWSTR p,q;
    BOOLEAN CdInstall;

    //
    // Assume CD-ROM installation.
    //
    CdInstall = TRUE;

    //
    // See whether an override source device has been specified. This can be
    // specified in either winnt.sif or in txtsetup.sif. (Remote boot setup
    // uses winnt.sif.)
    //
    p = SpGetSectionKeyIndex(WinntSifHandle,SIF_SETUPDATA,SIF_SETUPSOURCEDEVICE,0);

    if (p == NULL) {
        p = SpGetSectionKeyIndex(SifHandle,SIF_SETUPDATA,SIF_SETUPSOURCEDEVICE,0);
    }

    if(p != NULL) {

        //
        // Determine if the specified device is a cd-rom so we can set the
        // cd-rom flag accordingly.
        //
        q = SpDupStringW(p);

        if (q) {
            SpStringToLower(q);

            if(!wcsstr(q,L"\\device\\cdrom")) {
                CdInstall = FALSE;
            }

            SpMemFree(q);
        }

        //
        // Inform the caller of the device path.
        //
        *DevicePath = p;

    } else {
        WCHAR   szDevicePath[MAX_PATH];
        PWSTR   szDefDevicePath = L"\\device\\cdrom0";
        ULONG   ulNumCDRoms = IoGetConfigurationInformation()->CdRomCount;

        // assume cdrom0 has the required installation CD
        wcscpy(szDevicePath, szDefDevicePath);

        //
        //  If there is no CD-ROM drive, put a message informing the user
        //  that setup cannot continue.
        //  In the repair case, we pretend that there is a CD-ROM drive,
        //  so that the user can at least repair the hives, boot sector,
        //  and the boot variables (boot.ini on amd64/x86 case)
        //
        if (!ulNumCDRoms) {
            if (!RepairWinnt && !SpAsrIsQuickTest()) {
                if(!bEscape) {
                    SpDisplayScreen(SP_SCRN_NO_VALID_SOURCE,3,HEADER_HEIGHT+1);
                    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
                            SP_STAT_F3_EQUALS_EXIT,0);

                    SpInputDrain();
                    while(SpInputGetKeypress() != KEY_F3) ;

                    SpDone(0,FALSE,TRUE);
                }
            } else {
                RepairNoCDROMDrive = TRUE;
            }
        } else {
            if(!RepairWinnt && !SpAsrIsQuickTest()) {
                PWSTR       szTagfile = 0, szDescription = 0, szMediaShortName;
                BOOLEAN     bRedrawNeeded = FALSE;
                BOOLEAN     bDiskInserted = FALSE;

                szMediaShortName = SpLookUpValueForFile(
                    SifHandle,
                    L"eula.txt",
                    INDEX_WHICHMEDIA,
                    TRUE
                    );

                SpGetSourceMediaInfo(SifHandle, szMediaShortName,
                                    &szDescription, &szTagfile, NULL);

                //
                // Prompt for the disk, based on the setup media type.
                // (this routine will scan all the CD-ROMs and return
                //  proper CD-ROM device path)
                //
                bDiskInserted = SpPromptForDisk(
                                    szDescription,
                                    szDevicePath,
                                    szTagfile,
                                    FALSE,          // don't ignore disk in drive
                                    bEscape,        // allow/disallow escape
                                    TRUE,           // warn about multiple prompts for same disk
                                    &bRedrawNeeded
                                    );

                if(!bDiskInserted)
                    wcscpy(szDevicePath, szDefDevicePath);
            }
        }

        *DevicePath = SpDupStringW(szDevicePath);
    }

    //
    // Fetch the directory on the source device.
    //
    if((p = SpGetSectionKeyIndex(SifHandle,SIF_SETUPDATA,SIF_SETUPSOURCEPATH,0)) == NULL) {
        SpFatalSifError(SifHandle,SIF_SETUPDATA,SIF_SETUPSOURCEPATH,0,0);
    }

    *DirectoryOnDevice = p;

    return(CdInstall);
}


VOID
SpGetWinntParams(
    OUT PWSTR *DevicePath,
    OUT PWSTR *DirectoryOnDevice
    )

/*++

Routine Description:

    Determine the local source partition and directory on the partition.

    The local source partition should have already been located for us
    by the partitioning engine when it initialized.  The directory name
    within the partition is constant.

    Note: this routine should only be called in the winnt.exe setup case!

Arguments:

    DevicePath - receives the path to the local source partition
        in the nt namespace.  The caller should not attempt to free
        this buffer.

    DirectoryOnDevice - receives the directory name of the local source.
        This is actually a fixed constant but is included here for future use.

Return Value:

    None.  If the local source was not located, setup cannot continue.

--*/

{
    ASSERT(WinntSetup && !WinntFromCd);

    if(LocalSourceRegion) {

        SpNtNameFromRegion(
            LocalSourceRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer),
            PartitionOrdinalCurrent
            );

        *DevicePath = SpDupStringW(TemporaryBuffer);

        *DirectoryOnDevice = LocalSourceDirectory;

    } else {

        //
        // Error -- can't locate local source directory
        // prepared by winnt.exe.
        //

        SpDisplayScreen(SP_SCRN_CANT_FIND_LOCAL_SOURCE,3,HEADER_HEIGHT+1);

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        SpInputDrain();
        while(SpInputGetKeypress() != KEY_F3) ;

        SpDone(0,FALSE,TRUE);
    }
}

VOID
SpInitializeDriverInf(
    IN HANDLE       MasterSifHandle,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice
    )

/*++

Routine Description:

    Open a handle to drvindex.inf
    Then open a handle to driver.cab

Arguments:

    MasterSifHandle - Handle to txtsetup.sif.

    SetupSourceDevicePath - Path to the device that contains the source media.

    DirectoryOnSourceDevice - Directory on the media where setupp.ini is located.


Return Value:

    NONE.

--*/

{
    PWSTR    MediaShortName;
    PWSTR    MediaDirectory;
    PWSTR    DriverInfPath;
    ULONG    ErrorSubId;
    ULONG    ErrorLine;
    PWSTR    TmpPid;
    NTSTATUS Status;
    PWSTR    PidExtraData;
    CHAR     ExtraDataArray[25];
    PWSTR    PrivateInfPath;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    PWSTR Tagfile,Description;
    BOOLEAN bRedraw = FALSE;

    ULONG ValidKeys[3] = { KEY_F3,ASCI_CR,0 };

    //
    //  Prepair to load drvindex.inf
    //
    MediaShortName = SpLookUpValueForFile(
                        MasterSifHandle,
                        L"drvindex.inf",
                        INDEX_WHICHMEDIA,
                        TRUE
                        );


    if (ForceConsole || ConsoleFromWinnt32){
        //
        // The user needs to reach to console so he can
        // ESCAPE is the removable media is not present
        // in the drive
        //
        SpGetSourceMediaInfo(MasterSifHandle,MediaShortName,&Description,&Tagfile,NULL);

        //
        // if setup source or directory on source is not present
        // try to fetch it
        //
        if (!SetupSourceDevicePath)
            SetupSourceDevicePath = gpCmdConsBlock->SetupSourceDevicePath;

        if (!DirectoryOnSourceDevice)
            DirectoryOnSourceDevice = gpCmdConsBlock->DirectoryOnSetupSource;

        if (!SetupSourceDevicePath || !DirectoryOnSourceDevice){
            SpDetermineInstallationSource(
                MasterSifHandle,
                &SetupSourceDevicePath,
                &DirectoryOnSourceDevice,
                TRUE    // allow to ESCAPE if CD-ROM is not found
                );

            if (SetupSourceDevicePath) {
                if (gpCmdConsBlock->SetupSourceDevicePath) {
                    SpMemFree(gpCmdConsBlock->SetupSourceDevicePath);
                    gpCmdConsBlock->SetupSourceDevicePath = SetupSourceDevicePath;
                }
            }

            if (DirectoryOnSourceDevice){
                if(gpCmdConsBlock->DirectoryOnSetupSource) {
                    SpMemFree(gpCmdConsBlock->DirectoryOnSetupSource);
                    gpCmdConsBlock->DirectoryOnSetupSource = DirectoryOnSourceDevice;
                }
            }

            if (!SetupSourceDevicePath || !DirectoryOnSourceDevice)
                return; // can't proceed
        }


        if (!SpPromptForDisk(
                Description,
                SetupSourceDevicePath,
                Tagfile,
                FALSE,          // don't ignore disk in drive
                TRUE,           // allow escape
                TRUE,           // warn about multiple prompts for same disk
                &bRedraw
                )) {
            DriverInfHandle = NULL;

            if (bRedraw) {
                // redraw the screen
                SpvidClearScreenRegion( 0, 0, 0, 0, DEFAULT_BACKGROUND );
            }

            return;
        }

        if (bRedraw) {
            // redraw the screen
            SpvidClearScreenRegion( 0, 0, 0, 0, DEFAULT_BACKGROUND );
        }
    } else {
        //
        // Prompt for the disk, based on the setup media type.
        // Note : Will not return until the media is provided
        //
        SpPromptForSetupMedia(
                    MasterSifHandle,
                    MediaShortName,
                    SetupSourceDevicePath
                    );
    }


    SpGetSourceMediaInfo(MasterSifHandle,MediaShortName,NULL,NULL,&MediaDirectory);

    wcscpy( TemporaryBuffer, SetupSourceDevicePath );
    SpConcatenatePaths( TemporaryBuffer, DirectoryOnSourceDevice );
    SpConcatenatePaths( TemporaryBuffer, MediaDirectory );
    SpConcatenatePaths( TemporaryBuffer, L"drvindex.inf" );

    DriverInfPath = SpDupStringW( TemporaryBuffer );
    if (!DriverInfPath) {
        Status = STATUS_NO_MEMORY;
    } else {
TryAgain1:
        //
        // load the inf
        //
        Status = SpLoadSetupTextFile(
                    DriverInfPath,
                    NULL,                  // No image already in memory
                    0,                     // Image size is empty
                    &DriverInfHandle,
                    &ErrorLine,
                    TRUE,
                    FALSE
                    );
    }

    if(!NT_SUCCESS(Status)) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to read drvindex.inf. Status = %lx \n", Status ));
        DriverInfHandle = NULL;

        //
        //  bail out of setup
        //
        SpStartScreen(
            SP_SCRN_DRIVERCACHE_FATAL,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE
            );

        SpDisplayStatusOptions(
                        DEFAULT_STATUS_ATTRIBUTE,
                        SP_STAT_ENTER_EQUALS_RETRY,
                        SP_STAT_F3_EQUALS_EXIT,
                        0
                        );

        SpInputDrain();
        switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {
        case ASCI_CR:
            goto TryAgain1;
            break;
        case KEY_F3:
            SpConfirmExit();
            break;
        }

        SpDone(0,FALSE,FALSE);

        ASSERT(FALSE);

    }

    if (DriverInfPath) {
        SpMemFree( DriverInfPath );
    }

    //
    // load the driver cab
    //
    // won't return if it fails
    //

    SpOpenDriverCab(
        MasterSifHandle,
        SetupSourceDevicePath,
        DirectoryOnSourceDevice,
        &MediaDirectory);


    //
    // now read delta.inf from the directory the driver cab was in
    //

    wcscpy( TemporaryBuffer, SetupSourceDevicePath );
    SpConcatenatePaths( TemporaryBuffer, DirectoryOnSourceDevice );
    SpConcatenatePaths( TemporaryBuffer, MediaDirectory );
    SpConcatenatePaths( TemporaryBuffer, L"delta.inf" );

    PrivateInfPath = SpDupStringW( TemporaryBuffer );
    if (!PrivateInfPath) {
        Status = STATUS_NO_MEMORY;
    } else {

        //
        // load the inf
        //
        Status = SpLoadSetupTextFile(
                    PrivateInfPath,
                    NULL,                  // No image already in memory
                    0,                     // Image size is empty
                    &PrivateInfHandle,
                    &ErrorLine,
                    TRUE,
                    FALSE
                    );
    }

    if(!NT_SUCCESS(Status)) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Unable to read delta.inf. Status = %lx \n", Status ));
        PrivateInfHandle = NULL;
    }

    if( PrivateInfPath ) {
        SpMemFree( PrivateInfPath );
    }

    return;
}

VOID
SpOpenDriverCab(
    IN HANDLE       MasterSifHandle,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice,
    OUT PWSTR       *Directory        OPTIONAL
    )

/*++

Routine Description:

    open driver.cab based on the current source path and directory.

Arguments:

    MasterSifHandle - Handle to txtsetup.sif.

    SetupSourceDevicePath - Path to the device that contains the source media.

    DirectoryOnSourceDevice - Directory on the media where setupp.ini is located.

    Directory - If specified, returns the directory below DirectoryOnSourceDevice
        where the cab was opened from.


Return Value:

    NONE.

--*/

{
    PWSTR CabFileSection, CabFileName;
    WCHAR   CabPath[MAX_PATH];
    PWSTR    MediaShortName;
    PWSTR    MediaDirectory;
    NTSTATUS Status;
    PWSTR    DriverCabName, DriverCabPath;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    CABDATA *MyCabData;
    DWORD   i;
    HANDLE  CabHandle;

    ULONG ValidKeys[3] = { KEY_F3,ASCI_CR,0 };

    //
    // Load up every cab that's listed in drvindex.inf
    // and fill in the CabData structure.
    //
    ASSERT( DriverInfHandle );

    if (ARGUMENT_PRESENT(Directory)) {

        //
        // --lookup the name of the cab in txtsetup.sif
        //   then get the path to the file and open it
        //
        DriverCabName = SpGetSectionKeyIndex (MasterSifHandle,
                                   L"SetupData",
                                   L"DriverCabName",
                                   0);

        if (DriverCabName) {
            MediaShortName = SpLookUpValueForFile(
                                MasterSifHandle,
                                DriverCabName,
                                INDEX_WHICHMEDIA,
                                TRUE
                                );

            SpGetSourceMediaInfo(MasterSifHandle,MediaShortName,NULL,NULL,&MediaDirectory);
            *Directory = MediaDirectory;
        } else {
            //
            //  bail out of setup
            //
            DriverInfHandle = NULL;

            SpFatalSifError(MasterSifHandle,
                L"SetupData",
                L"DriverCabName",
                0,
                0);

            return; // for prefix
        }
    }


    //
    // get the cabfiles line from the Version section
    //
    i = 0;
    CabFileSection = NULL;
    CabData = SpMemAlloc( sizeof(CABDATA) );
    RtlZeroMemory( CabData, sizeof(CABDATA) );
    MyCabData = CabData;

    //
    // SpGetSectionKeyIndex will return NULL when there are no more entries on
    // this line.
    //
    while( CabFileSection = SpGetSectionKeyIndex(DriverInfHandle,L"Version",L"CabFiles",i) ) {
        //
        // Got the section name.  Go figure out which cab we need
        // to open and load the handle.
        //
        CabFileName = SpGetSectionKeyIndex(DriverInfHandle,L"Cabs",CabFileSection,0);

        if( CabFileName ) {
            MediaShortName = SpLookUpValueForFile( MasterSifHandle,
                                                   CabFileName,
                                                   INDEX_WHICHMEDIA,
                                                   TRUE );

            SpGetSourceMediaInfo(MasterSifHandle,MediaShortName,NULL,NULL,&MediaDirectory);

            wcscpy( CabPath, SetupSourceDevicePath );
            SpConcatenatePaths( CabPath, DirectoryOnSourceDevice );
            SpConcatenatePaths( CabPath, MediaDirectory );
            SpConcatenatePaths( CabPath, CabFileName );

TryAgain2:
            INIT_OBJA(&Obja,&UnicodeString,CabPath);

            Status = ZwCreateFile( &CabHandle,
                                   FILE_GENERIC_READ,
                                   &Obja,
                                   &IoStatusBlock,
                                   NULL,
                                   FILE_ATTRIBUTE_NORMAL,
                                   FILE_SHARE_READ,
                                   FILE_OPEN,
                                   0,
                                   NULL,
                                   0 );
            if( NT_SUCCESS(Status) ) {
                //
                // load the data structure.
                //
                if( (MyCabData->CabName) && (MyCabData->CabHandle) ) {
                    //
                    // This entry is being used.  Create another.
                    //
                    MyCabData->Next = SpMemAlloc( sizeof(CABDATA) );
                    MyCabData = MyCabData->Next;
                }

                if( MyCabData ) {
                    MyCabData->Next = NULL;
                    MyCabData->CabName = SpDupStringW(CabFileName);
                    MyCabData->CabHandle = CabHandle;
                    MyCabData->CabInfHandle = DriverInfHandle;
                    MyCabData->CabSectionName = SpDupStringW(CabFileSection);
                } else {
                    //
                    // What to do...
                    //
                }



            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open cab file %ws. Status = %lx \n", CabPath, Status ));

                //
                //  bail out of setup
                //
                DriverInfHandle = NULL;

                SpStartScreen(
                    SP_SCRN_DRIVERCACHE_FATAL,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE
                    );

                SpDisplayStatusOptions(
                                DEFAULT_STATUS_ATTRIBUTE,
                                SP_STAT_ENTER_EQUALS_RETRY,
                                SP_STAT_F3_EQUALS_EXIT,
                                0
                                );
                SpInputDrain();
                switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {
                case ASCI_CR:
                    goto TryAgain2;
                    break;
                case KEY_F3:
                    SpConfirmExit();
                    break;
                }

                SpDone(0,FALSE,FALSE);

                ASSERT(FALSE);
            }
        }

        //
        // Go look in the next section.
        //
        i++;
    }

    return;
}


VOID
SpInitializePidString(
    IN HANDLE       MasterSifHandle,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice
    )

/*++

Routine Description:

    Read th Pid20 from setupp.ini on the media, and save it on the global
    variable PidString. Also read the "extradata" from setupp.ini and translate it
    into the StepUpMode global.  Note that the StepUpMode global is already set from
    reading setupreg.hiv initially, but this overrides that value

Arguments:

    MasterSifHandle - Handle to txtsetup.sif.

    SetupSourceDevicePath - Path to the device that contains the source media.

    DirectoryOnSourceDevice - Directory on the media where setupp.ini is located.


Return Value:

    NONE.

--*/

{
    PWSTR    MediaShortName;
    PWSTR    MediaDirectory;
    PWSTR    SetupIniPath;
    ULONG    ErrorSubId;
    ULONG    ErrorLine;
    PVOID    SetupIniHandle;
    PWSTR    TmpPid;
    NTSTATUS Status;
    PWSTR    PidExtraData;
    CHAR     ExtraDataArray[25];


    //
    //  Prepair to run autofmt
    //
    MediaShortName = SpLookUpValueForFile(
                        MasterSifHandle,
                        L"setupp.ini",
                        INDEX_WHICHMEDIA,
                        TRUE
                        );

    //
    // Prompt the user to insert the setup media.
    //
    SpPromptForSetupMedia(
        MasterSifHandle,
        MediaShortName,
        SetupSourceDevicePath
        );

    SpGetSourceMediaInfo(MasterSifHandle,MediaShortName,NULL,NULL,&MediaDirectory);

    wcscpy( TemporaryBuffer, SetupSourceDevicePath );
    SpConcatenatePaths( TemporaryBuffer, DirectoryOnSourceDevice );
    SpConcatenatePaths( TemporaryBuffer, MediaDirectory );
    SpConcatenatePaths( TemporaryBuffer, L"setupp.ini" );
    SetupIniPath = SpDupStringW( TemporaryBuffer );

    CLEAR_CLIENT_SCREEN();

    Status = SpLoadSetupTextFile(
                SetupIniPath,
                NULL,                  // No image already in memory
                0,                     // Image size is empty
                &SetupIniHandle,
                &ErrorLine,
                TRUE,
                FALSE
                );

    if(!NT_SUCCESS(Status)) {
        //
        //  Silently fail if unable to read setupp.ini
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Unable to read setupp.ini. Status = %lx \n", Status ));

        PidString = NULL;
        StepUpMode = TRUE;
        return;
    }

    TmpPid = SpGetSectionKeyIndex (SetupIniHandle,
                                   L"Pid",
                                   L"Pid",
                                   0);

    PidString = ( TmpPid == NULL )? NULL : SpDupStringW(TmpPid);

    TmpPid = SpGetSectionKeyIndex (SetupIniHandle,
                               L"Pid",
                               L"Pid",
                               0);

    PidString = ( TmpPid == NULL )? NULL : SpDupStringW(TmpPid);

    TmpPid = SpGetSectionKeyIndex (SetupIniHandle,
                                   L"Pid",
                                   L"ExtraData",
                                   0);

    PidExtraData = (TmpPid == NULL) ? NULL : SpDupStringW(TmpPid);
    if ( PidExtraData ) {

        if (! SpGetStepUpMode(PidExtraData,&StepUpMode)) {
            //
            // fatal error processing PidExtraData
            //  -- someone tampered with this file so bail out
            //

            SpStartScreen(
                SP_SCRN_PIDINIT_FATAL,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE
                );

            SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);
            SpInputDrain();
            while(SpInputGetKeypress() != KEY_F3);
            SpDone(0, FALSE,FALSE);

            ASSERT(FALSE);
        }

        SpMemFree( PidExtraData );

    }

    SpFreeTextFile( SetupIniHandle );
    return;
}

NTSTATUS
SpRenameSetupAPILog(
    PDISK_REGION TargetRegion,
    PCWSTR       TargetPath
    )
/*++

Routine Description:

    This routine deletes the copy of setupapi.old if present, and then
    renames setupapi.log to setupapi.old.

Arguments:

    TargetRegion -  identifies the disk containing the NT installation
    TargetPath   -  path to NT installation on disk

Return Value:

    NONE.

--*/

{
    PWSTR SetupAPIOldName;
    PWSTR SetupAPILogName;
    PWSTR p;
    NTSTATUS Status;

    SpNtNameFromRegion(
            TargetRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer),
            PartitionOrdinalCurrent
            );

    SpConcatenatePaths( TemporaryBuffer, TargetPath );

    //
    // Allocate a string buffer large enough to contain space for the string
    // in TemporaryBuffer, plus "setupapi.old", plus the path seperator that
    // SpConcatenatePaths() may insert between them.  Include room for the
    // null terminator as well.
    //

    SetupAPIOldName = SpMemAlloc(wcslen(TemporaryBuffer) * sizeof(WCHAR) +
                                 sizeof(L'\\') +
                                 sizeof(L"setupapi.old") +
                                 sizeof(L'\0'));
    if (SetupAPIOldName == NULL) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not allocate memory to rename setupapi.log.\n"));
        return STATUS_NO_MEMORY;
    }

    SetupAPILogName = SpMemAlloc(wcslen(TemporaryBuffer) * sizeof(WCHAR) +
                                 sizeof(L'\\') +
                                 sizeof(L"setupapi.log") +
                                 sizeof(L'\0'));
    if (SetupAPILogName == NULL) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not allocate memory to rename setupapi.log.\n"));
        SpMemFree(SetupAPIOldName);
        return STATUS_NO_MEMORY;
    }

    wcscpy(SetupAPIOldName, TemporaryBuffer);
    SpConcatenatePaths(SetupAPIOldName, L"setupapi.old");
    wcscpy(SetupAPILogName, TemporaryBuffer);
    SpConcatenatePaths(SetupAPILogName, L"setupapi.log");


    Status = SpDeleteFile(SetupAPIOldName, NULL, NULL);
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Could not delete %ws: %lx.\n", SetupAPIOldName, Status));
    }

    Status = SpRenameFile(SetupAPILogName, SetupAPIOldName, FALSE);
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Could not rename %ws to %ws: %lx.\n", SetupAPILogName, SetupAPIOldName, Status));
    }

    SpMemFree(SetupAPILogName);
    SpMemFree(SetupAPIOldName);

    return Status;

}



#if defined(REMOTE_BOOT)
NTSTATUS
SpFixupRemoteBootLoader(
    PWSTR RemoteBootTarget
    )

/*++

Routine Description:

    This routine deletes the setup loader that is currently NTLDR, and
    puts the os loader in its place.

Arguments:

    RemoteBootTarget -- the network path to the machine directory root
        on the server.

Return Value:

    NONE.

--*/

{
    PWSTR NtldrName;
    PWSTR OsLoaderName;
    PWSTR p;
    NTSTATUS Status;

    NtldrName = SpMemAlloc(wcslen(RemoteBootTarget) * sizeof(WCHAR) + sizeof(L"ntldr"));
    if (NtldrName == NULL) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not allocate memory to fixup remote boot loader.\n"));
        return STATUS_NO_MEMORY;
    }
    OsLoaderName = SpMemAlloc((wcslen(RemoteBootTarget) + 20) * sizeof(WCHAR));
    if (OsLoaderName == NULL) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not allocate memory to fixup remote boot loader.\n"));
        SpMemFree(NtldrName);
        return STATUS_NO_MEMORY;
    }

    wcscpy(NtldrName, RemoteBootTarget);
    p = wcsstr(NtldrName, L"BootDrive");
    ASSERT(p != NULL);
    wcscpy(p, L"ntldr");

    Status = SpDeleteFile(NtldrName, NULL, NULL);
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not delete %ws: %lx.\n", NtldrName, Status));
        goto Cleanup;
    }

    wcscpy(OsLoaderName, RemoteBootTarget);
    wcscat(OsLoaderName, L"\\winnt\\osloader.exe");

    Status = SpRenameFile(OsLoaderName, NtldrName, FALSE);
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not rename %ws to %ws: %lx.\n", OsLoaderName, NtldrName, Status));
    }

Cleanup:

    SpMemFree(NtldrName);
    SpMemFree(OsLoaderName);

    return Status;

}

NTSTATUS
SpCreateRemoteBootCfg(
    IN PWSTR RemoteBootTarget,
    IN PDISK_REGION SystemPartitionRegion
    )

/*++

Routine Description:

    This routine creates the RemoteBoot.cfg file in the system32\config directory, and
    initializes it.

Arguments:

    RemoteBootTarget -- the network path to the machine directory root
        on the server.

    SystemPartitionRegion -- The drive that is installed on the local machine.

Return Value:

    NONE.

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    PWSTR FileName;
    PWSTR p;
    NTSTATUS Status;
    HANDLE Handle;
    ULONG BootSerialNumber = 1;
    ULONG DiskSignature;
    LARGE_INTEGER ByteOffset;

    if ((SystemPartitionRegion != NULL) &&
        (!SystemPartitionRegion->PartitionedSpace ||
         (SystemPartitionRegion->Filesystem != FilesystemNtfs))) {
        KdPrintEx((Ex"SDPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, ETUP: ERROR! Invalid system partition for remoteboot!\n");
        return STATUS_UNSUCCESSFUL;
    }

    if (SystemPartitionRegion != NULL) {
        DiskSignature = U_ULONG(SystemPartitionRegion->MbrInfo->OnDiskMbr.NTFTSignature);
    } else {
        DiskSignature = 0;
    }

    FileName = SpMemAlloc(wcslen(RemoteBootTarget)  * sizeof(WCHAR) + sizeof(L"RemoteBoot.cfg"));
    if (FileName == NULL) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not allocate memory remoteboot.cfg file name.\n"));
        return STATUS_NO_MEMORY;
    }

    wcscpy(FileName, RemoteBootTarget);
    p = wcsstr(FileName, L"BootDrive");
    ASSERT(p != NULL);
    wcscpy(p, L"RemoteBoot.cfg");

    INIT_OBJA(&ObjectAttributes,&UnicodeString,FileName);

    Status = ZwCreateFile( &Handle,
                           (ACCESS_MASK)FILE_GENERIC_WRITE | FILE_GENERIC_READ,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_HIDDEN,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OVERWRITE_IF,
                           FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS,
                           NULL,
                           0
                         );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not create %ws file. Status == 0x%x\n", FileName, Status));
        goto Cleanup;
    }


    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_TRACE_LEVEL, "SETUP: Writing remoteboot.cfg file.\n"));

    //
    // Update the information
    //
    ByteOffset.LowPart = 0;
    ByteOffset.HighPart = 0;

    ZwWriteFile( Handle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 &BootSerialNumber,
                 sizeof(ULONG),
                 &ByteOffset,
                 NULL
               );

    ByteOffset.LowPart = sizeof(ULONG);

    ZwWriteFile( Handle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 &DiskSignature,
                 sizeof(ULONG),
                 &ByteOffset,
                 NULL
               );

    ByteOffset.LowPart = sizeof(ULONG) + sizeof(ULONG);

    ZwWriteFile( Handle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 NetBootHalName,
                 sizeof(NetBootHalName),
                 &ByteOffset,
                 NULL
               );

    ZwClose(Handle);

Cleanup:

    SpMemFree(FileName);
    return Status;

}

NTSTATUS
SpEraseCscCache(
    IN PDISK_REGION SystemPartitionRegion
    )

/*++

Routine Description:

    This routine erases the local CSC cache.

Arguments:

    SystemPartitionRegion - The system partition region (the local drive).

Return Value:

    NONE.

--*/

{
    NTSTATUS Status;
    ENUMFILESRESULT Result;
    PWSTR FullCscPath;

    //
    // Show a screen, the status line will show each file as it is
    // deleted.
    //

    SpDisplayScreen(SP_SCRN_CLEARING_CSC, 3, 4 );

    SpNtNameFromRegion(
        SystemPartitionRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    SpConcatenatePaths(TemporaryBuffer,
                       REMOTE_BOOT_IMIRROR_PATH_W REMOTE_BOOT_CSC_SUBDIR_W);
    FullCscPath = SpDupStringW(TemporaryBuffer);

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_TRACE_LEVEL, "SETUP: SpEraseCscCache clearing CSC cache %ws\n", FullCscPath));

    Result = SpEnumFilesRecursive(
                 FullCscPath,
                 SpDelEnumFile,
                 &Status,
                 NULL);

    SpMemFree(FullCscPath);

    return Status;

}
#endif // defined(REMOTE_BOOT)

NTSTATUS
SpProcessMigrateInfFile(
    IN  PVOID InfHandle
    )

/*++

Routine Description:

    Process the [AddReg] section of migrate.inf.
    The keys are created on the setup hive.

Arguments:

    InfHandle - Handle to migrate.inf file.

Return Value:

    Status code indicating outcome.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE  SystemHiveRoot;
    PWSTR   KeyPath = L"\\registry\\machine\\system";

    //
    //  Open a handle to HKEY_LOCAL_MACHINE\System on the setup hive
    //
    INIT_OBJA(&Obja,&UnicodeString,KeyPath);
    Obja.RootDirectory = NULL;

    Status = ZwOpenKey(&SystemHiveRoot,KEY_ALL_ACCESS,&Obja);
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ls on the setup hive. Status =  %lx \n", KeyPath, Status));
        return( Status );
    }

    Status = SpProcessAddRegSection( InfHandle,
                                     L"AddReg",
                                     SystemHiveRoot,
                                     NULL,
                                     NULL,
                                     NULL );

    ZwClose( SystemHiveRoot );
    return( Status );

}

//begin NEC98
VOID
SpSetAutoBootFlag(
    PDISK_REGION TargetRegion,
    BOOLEAN      SetBootPosision
    )
{
#if defined(NEC_98) //NEC98
    PHARD_DISK      pHardDisk;
    WCHAR DevicePath[(sizeof(DISK_DEVICE_NAME_BASE)+sizeof(L"000"))/sizeof(WCHAR)];
    ULONG i,bps;//,DiskLayoutSize;
    HANDLE Handle;
    NTSTATUS Sts;
    PREAL_DISK_PTE_NEC98 Pte;
    PUCHAR Buffer,UBuffer;
    UCHAR Position = 0;


    UBuffer = SpMemAlloc(2 * 2 * 512);
    Buffer = ALIGN(UBuffer,512);

    for(i=0; i<HardDiskCount; i++){
        swprintf(DevicePath,L"\\Device\\Harddisk%u",i);
        if(HardDisks[i].Status == DiskOffLine) {
            continue;
        }
        //
        // ignore removable disk.
        //
        if(HardDisks[i].Characteristics & FILE_REMOVABLE_MEDIA ){
            continue;
        }
        bps = HardDisks[i].Geometry.BytesPerSector;
        Sts = SpOpenPartition0(DevicePath,&Handle,TRUE);
        if(!NT_SUCCESS(Sts)) {
            continue;
        }
        RtlZeroMemory(Buffer,bps * 2);
        Sts = SpReadWriteDiskSectors(Handle,0,1,bps,Buffer,FALSE);

        if(!NT_SUCCESS(Sts)) {
            ZwClose(Handle);
            continue;
        }

        //
        //  Clear BootRecord
        //
        Buffer[bps - 5] = 0x00;
        Buffer[bps - 6] = 0x00;

        Sts = SpReadWriteDiskSectors(Handle,0,1,bps,Buffer,TRUE);

        if(!NT_SUCCESS(Sts)) {
            ZwClose(Handle);
            continue;
        }
        ZwClose(Handle);
    }

    if(SetBootPosision){

        //
        // Set RealDiskPosition.(in upgrade or repair)
        //
        if( (NTUpgrade == UpgradeFull) || (WinUpgradeType != NoWinUpgrade) ||  RepairWinnt ||
            (AutoPartitionPicker
#if defined(REMOTE_BOOT)
             && !RemoteBootSetup
#endif // defined(REMOTE_BOOT)
            ) ) {

            ASSERT(TargetRegion);
            TargetRegion->MbrInfo->OnDiskMbr.PartitionTable[TargetRegion->TablePosition].RealDiskPosition
                = (UCHAR)TargetRegion->TablePosition;
        }

        ASSERT(TargetRegion);
        RtlZeroMemory(Buffer,bps * 2);
        pHardDisk = &HardDisks[TargetRegion->DiskNumber];
        bps = HardDisks[TargetRegion->DiskNumber].Geometry.BytesPerSector;
        Sts = SpOpenPartition0(pHardDisk->DevicePath,&Handle,TRUE);
        if(!NT_SUCCESS(Sts)) {
            return;
        }
        Sts = SpReadWriteDiskSectors(Handle,0,2,bps,Buffer,FALSE);

        if(!NT_SUCCESS(Sts)) {
            ZwClose(Handle);
            SpMemFree(UBuffer);
            return;
        }

        (PUCHAR)Pte = &Buffer[bps];
        Position = TargetRegion->MbrInfo->OnDiskMbr.PartitionTable[TargetRegion->TablePosition].RealDiskPosition;

        //
        // Update BootRecord and Volume Information
        //
        Buffer[bps - 5] = Position;
        Buffer[bps - 6] = 0x80;
        Pte[Position].ActiveFlag |= 0x80;
        Pte[Position].SystemId   |= 0x80;

        //
        // If target partition was created windisk.exe on NT3.5, there is not IPL adress
        // in its volume info. So,textmode setup must write it to the volume info.
        //
        if ((Pte[Position].IPLSector != Pte[Position].StartSector)           ||
            (Pte[Position].IPLHead != Pte[Position].StartHead)               ||
            (Pte[Position].IPLCylinderLow != Pte[Position].StartCylinderLow) ||
            (Pte[Position].IPLCylinderHigh != Pte[Position].StartCylinderHigh))
        {
            //
            // Not much! Set IPL adress value same as partition start address.
            //

            Pte[Position].IPLSector = Pte[Position].StartSector;
            Pte[Position].IPLHead   = Pte[Position].StartHead;
            Pte[Position].IPLCylinderLow  = Pte[Position].StartCylinderLow;
            Pte[Position].IPLCylinderHigh = Pte[Position].StartCylinderHigh;
        }

        Sts = SpReadWriteDiskSectors(Handle,0,2,bps,Buffer,TRUE);

        if(!NT_SUCCESS(Sts)) {
            ZwClose(Handle);
            SpMemFree(UBuffer);
            return;
        }
        ZwClose(Handle);
    }
    SpMemFree(UBuffer);
#endif //NEC98
}


VOID
SpCheckHiveDriveLetters(
    VOID
    )
{
#if defined(NEC_98) //NEC98
    NTSTATUS    Status;
    PWSTR       p;
    ULONG       ErrorLine;
    PVOID       TmpWinntSifHandle = NULL;
    BOOLEAN     ForceRemapDriveLetter = FALSE;
    BOOLEAN     DriveAssign_AT = TRUE;

    if ( SetupldrWinntSifFileSize ) {

        Status = SpLoadSetupTextFile( NULL,
                                      SetupldrWinntSifFile,
                                      SetupldrWinntSifFileSize,
                                      &TmpWinntSifHandle,
                                      &ErrorLine,
                                      FALSE,
                                      TRUE
                                      );

        if (!NT_SUCCESS(Status))
            return;

        p = SpGetSectionKeyIndex(TmpWinntSifHandle,SIF_DATA,WINNT_D_DRIVEASSIGN_NEC98_W,0);
        if(p && !_wcsicmp(p,WINNT_A_YES_W)) {

            if (SetupldrMigrateInfFile) {
                p = SpGetSectionKeyIndex(TmpWinntSifHandle,SIF_DATA,WINNT_D_NTUPGRADE_W,0);
                if(p && !_wcsicmp(p,WINNT_A_YES_W)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Upgrade NEC assigned WinNT.(AT=FALSE)\n"));
                    DriveAssign_AT = FALSE;
                } else {

                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Fresh setup from NEC assigned WinNT.(AT=TRUE)\n"));
                    DriveAssign_AT = TRUE;
                }
            } else {

                p = SpGetSectionKeyIndex(TmpWinntSifHandle,SIF_DATA,WINNT_D_WIN95UPGRADE_W,0);
                if(p && !_wcsicmp(p,WINNT_A_YES_W)) {
                   KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Upgrade NEC assigned Win95.(AT=FALSE)\n"));
                   DriveAssign_AT = FALSE;
                } else {
                   KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Fresh setup from NEC assigned Win95.(AT=TRUE)\n"));
                   DriveAssign_AT = TRUE;
                }
            }
        }
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Fresh setup.(AT=TRUE)\n"));
        DriveAssign_AT = TRUE;
    }

    SpSetHiveDriveLetterNec98( DriveAssign_AT );
#endif //NEC98
}


VOID
SpSetHiveDriveLetterNec98(
    BOOLEAN DriveAssign_AT
    )
{
#if defined(NEC_98) //NEC98
    NTSTATUS    Status;
    UNICODE_STRING StartDriveLetterFrom;
    UNICODE_STRING Dummy;


    RTL_QUERY_REGISTRY_TABLE SetupTypeTable[]=
    {
        {NULL,
        RTL_QUERY_REGISTRY_DIRECT,
        L"DriveLetter",
        &StartDriveLetterFrom,
        REG_SZ,
        &Dummy,
        0
        },
        {NULL,0,NULL,NULL,REG_NONE,NULL,0}
    };

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_TRACE_LEVEL, "SETUP: SpSetHiveDriveLetter(%ld).\n", DriveAssign_AT));

    RtlInitUnicodeString(&StartDriveLetterFrom, NULL);
    RtlInitUnicodeString(&Dummy, NULL);

    Status = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE,
                                     L"\\Registry\\MACHINE\\SYSTEM\\Setup",
                                     SetupTypeTable,
                                     NULL,
                                     NULL);

    if (DriveAssign_AT) {
        //
        // Write hive "DriveLetter",
        //
        if ((StartDriveLetterFrom.Buffer[0] != L'C') &&
            (StartDriveLetterFrom.Buffer[0] != L'c')) {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Write DriveLetter=C into setup hiv.\n"));
            Status = RtlWriteRegistryValue( RTL_REGISTRY_ABSOLUTE,
                                            L"\\Registry\\Machine\\System\\Setup",
                                            L"DriveLetter",
                                            REG_SZ,
                                            L"C",
                                            sizeof(L"C")+sizeof(WCHAR));
        }
        DriveAssignFromA = FALSE;

    } else {
        //
        // Delete hive "DriveLetter",
        //
        if (NT_SUCCESS(Status)) {
            if ((StartDriveLetterFrom.Buffer[0] == L'C') ||
                (StartDriveLetterFrom.Buffer[0] == L'c')) {

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Delete DriveLetter=C from setup hiv.\n"));
                Status = RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                            L"\\Registry\\MACHINE\\SYSTEM\\Setup",
                                            L"DriveLetter");
            }
        }
        DriveAssignFromA = TRUE;
    }
#endif //NEC98
}


VOID
SpDeleteDriveLetterFromNTFTNec98(
    VOID
    )
{
#if defined(NEC_98) //NEC98
    NTSTATUS    Status;
    PWSTR       p;
    ULONG       ErrorLine;
    UNICODE_STRING StartDriveLetterFrom;
    UNICODE_STRING Dummy;
    PVOID       TmpWinntSifHandle = NULL;
    BOOLEAN     ForceRemapDriveLetter = FALSE;

    // 1st step:
    // Check whether we need to reassign drive letters.
    Status = SpLoadSetupTextFile(
                NULL,
                SetupldrWinntSifFile,
                SetupldrWinntSifFileSize,
                &TmpWinntSifHandle,
                &ErrorLine,
                FALSE,
                TRUE
                );

    if (!NT_SUCCESS(Status))
        return;

    if (SetupldrMigrateInfFile) {
        p = SpGetSectionKeyIndex(TmpWinntSifHandle,SIF_DATA,WINNT_D_NTUPGRADE_W,0);
        if(!p || !_wcsicmp(p,WINNT_A_NO_W)) {
            SpDeleteDriveLetterFromNTFTWorkerNec98();
        }
    }
#endif //NEC98
}


VOID
SpDeleteDriveLetterFromNTFTWorkerNec98(
    VOID
    )
{
#if defined(NEC_98) //NEC98

#define MOUNT_REGISTRY_KEY_W    L"\\registry\\machine\\SYSTEM\\MountedDevices"
#define DISK_REGISTRY_KEY_W     L"\\registry\\machine\\SYSTEM\\DISK"

    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE  KeyHandle;
    ULONG Disposition;

    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    ULONG                       registrySize;
    //NTSTATUS                    status;
    PDISK_CONFIG_HEADER         registry;
    PDISK_REGISTRY              diskRegistry;
    PDISK_DESCRIPTION           diskDescription;
    ULONG                       signature;
    LONGLONG                    offset;
    PDISK_PARTITION             diskPartition;
    UCHAR                       driveLetter;
    USHORT                      i, j;


    //
    // Delete \SYSTEM\\MountedDevices.
    //
    INIT_OBJA(&Obja,&UnicodeString,MOUNT_REGISTRY_KEY_W);
    Obja.RootDirectory = NULL;
    Status = ZwOpenKey(&KeyHandle,KEY_ALL_ACCESS,&Obja);

    if( NT_SUCCESS( Status ) ) {
        Status = ZwDeleteKey(KeyHandle);
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Delete %ls on the setup hive. Status =  %lx \n", MOUNT_REGISTRY_KEY_W, Status));
        ZwClose(KeyHandle);
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: No %ls on the setup hive.\n", MOUNT_REGISTRY_KEY_W));
    }


    //
    // Delete drive letter information from \SYSTEM\\DISK.
    //
    INIT_OBJA(&Obja,&UnicodeString,DISK_REGISTRY_KEY_W);
    Obja.RootDirectory = NULL;
    Status = ZwOpenKey(&KeyHandle,KEY_ALL_ACCESS,&Obja);

    if( NT_SUCCESS( Status ) ) {

        RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
        queryTable[0].QueryRoutine = SpDiskRegistryQueryRoutineNec98;
        queryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
        queryTable[0].Name = L"Information";
        queryTable[0].EntryContext = &registrySize;

        Status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE, DISK_REGISTRY_KEY_W,
                                        queryTable, &registry, NULL);

        if( NT_SUCCESS(Status) ) {

            diskRegistry = (PDISK_REGISTRY) ((PUCHAR)registry +
                                             registry->DiskInformationOffset);

            diskDescription = &diskRegistry->Disks[0];
            for (i = 0; i < diskRegistry->NumberOfDisks; i++) {
                for (j = 0; j < diskDescription->NumberOfPartitions; j++) {

                    diskPartition = &diskDescription->Partitions[j];
                    diskPartition->AssignDriveLetter = TRUE;
                    diskPartition->DriveLetter = (UCHAR)NULL;
                }

                diskDescription = (PDISK_DESCRIPTION) &diskDescription->
                                   Partitions[diskDescription->NumberOfPartitions];
            }

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Delete %ls on the setup hive. Status =  %lx \n", DISK_REGISTRY_KEY_W, Status));
            ZwDeleteKey(KeyHandle);
            ZwClose(KeyHandle);

            INIT_OBJA(&Obja,&UnicodeString,DISK_REGISTRY_KEY_W);
            Obja.RootDirectory = NULL;
            Status = ZwCreateKey(&KeyHandle,
                                 READ_CONTROL | KEY_SET_VALUE,
                                 //KEY_ALL_ACCESS,
                                 &Obja,
                                 0,
                                 NULL,
                                 REG_OPTION_NON_VOLATILE,
                                 &Disposition
                                 );

            if( NT_SUCCESS( Status ) ) {
                ZwClose(KeyHandle);
            }

            Status = RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                           DISK_REGISTRY_KEY_W,
                                           L"Information",
                                           REG_BINARY,
                                           registry,
                                           registrySize);

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Wrote Information in %ls. Status =  %lx \n", DISK_REGISTRY_KEY_W, Status));
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: No Information found in DISK registry.\n"));
            ZwDeleteKey(KeyHandle);
            ZwClose(KeyHandle);
        }
    }
#endif //NEC98
}


NTSTATUS
SpDiskRegistryQueryRoutineNec98(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )

/*++

Routine Description:

    This routine is a query routine for the disk registry entry.  It allocates
    space for the disk registry and copies it to the given context.

Arguments:

    ValueName       - Supplies the name of the registry value.

    ValueType       - Supplies the type of the registry value.

    ValueData       - Supplies the data of the registry value.

    ValueLength     - Supplies the length of the registry value.

    Context         - Returns the disk registry entry.

    EntryContext    - Returns the disk registry size.

Return Value:

    NTSTATUS

--*/

{
#if defined(NEC_98) //NEC98
    PVOID                   p;
    PDISK_CONFIG_HEADER*    reg;
    PULONG                  size;

    p = ExAllocatePool(PagedPool, ValueLength);
    if (!p) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(p, ValueData, ValueLength);

    reg = (PDISK_CONFIG_HEADER*) Context;
    *reg = (PDISK_CONFIG_HEADER) p;

    size = (PULONG) EntryContext;
    if (size) {
        *size = ValueLength;
    }

#endif //NEC98
    return STATUS_SUCCESS;
}

BOOL
SpDetermineBootPartitionEnumNec98(
    IN PPARTITIONED_DISK Disk,
    IN PDISK_REGION Region,
    IN ULONG_PTR Context
    )

/*++

Routine Description:

    Callback routine passed to SpEnumDiskRegions.

Arguments:

    Region - a pointer to a disk region returned by SpEnumDiskRegions
    Ignore - ignored parameter

Return Value:

    TRUE - to continue enumeration
    FALSE - to end enumeration

--*/

{
    WCHAR DeviceName[256];

    SpNtNameFromRegion(
        Region,
        DeviceName,
        MAX_PATH * sizeof(WCHAR),
        PartitionOrdinalOnDisk
        );

    if( !_wcsicmp(DeviceName,NtBootDevicePath)) {

        *(PDISK_REGION *)Context = Region;

        return FALSE;
    }

    return TRUE;
}
//end NEC98


NTSTATUS
SpProcessUnsupDrvInfFile(
    IN  PVOID InfHandle
    )

/*++

Routine Description:

    Process the [AddReg] section of migrate.inf.
    The keys are created on the setup hive.

Arguments:

    InfHandle - Handle to migrate.inf file.

Return Value:

    Status code indicating outcome.

--*/

{
    NTSTATUS Status;
    NTSTATUS SavedStatus = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE  SystemHiveRoot;
    PWSTR   KeyPath = L"\\registry\\machine\\system";
    ULONG   i;
    PWSTR   p, q;

    //
    // Verify arguments
    //
    if (!InfHandle) {
        KdPrintEx((DPFLTR_SETUP_ID, 
            DPFLTR_ERROR_LEVEL, 
            "SETUP: Invalid argument to SpProcessUnsupDrvInfFile(%p) \n",
            InfHandle));    
            
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Open a handle to HKEY_LOCAL_MACHINE\System on the setup hive
    //
    INIT_OBJA(&Obja,&UnicodeString,KeyPath);
    Obja.RootDirectory = NULL;

    Status = ZwOpenKey(&SystemHiveRoot,KEY_ALL_ACCESS,&Obja);
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ls on the setup hive. Status =  %lx \n", KeyPath, Status));
        return( Status );
    }


    for( i = 0;
         ((p = SpGetSectionLineIndex( InfHandle,
                                      L"Devices",
                                      i,
                                      0 )) != NULL);
         i++ ) {

        wcscpy( TemporaryBuffer, L"AddReg." );
        wcscat( TemporaryBuffer, p );
        q = SpDupStringW( ( PWSTR )TemporaryBuffer );
        Status = SpProcessAddRegSection( InfHandle,
                                         q,
                                         SystemHiveRoot,
                                         NULL,
                                         NULL,
                                         NULL );
        if( !NT_SUCCESS(Status) ) {
            if( SavedStatus == STATUS_SUCCESS ) {
                SavedStatus = Status;
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Unable to process section %ls in driver.inf. Status =  %lx \n", q, Status));
            }
        }
        SpMemFree( q );
    }

    ZwClose( SystemHiveRoot );
    return( Status );
}


NTSTATUS
SpCheckForDockableMachine(
    )

/*++

Routine Description:

    This routine attempts to determine if the machine is "dockable" (laptops),
    and set the flag DockableMachine appropriately.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE  hKey;
    PWSTR   KeyPath = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\IDConfigDB\\CurrentDockInfo";
    PWSTR   ValueName = L"DockingState";
    ULONG   ResultLength;
    DWORD   DockingState;

    Status = STATUS_SUCCESS;
    //
    //  If we have already determined if the machine is dockable, then just return
    //  This is because some machine will have the info in the registry already set prior to pnp
    //  notification, and some machines won't. So this function is always called twice.
    //
    if( !DockableMachine ) {
        //
        //  Open a the key in the setup hive that contains the docking information
        //
        INIT_OBJA(&Obja,&UnicodeString,KeyPath);
        Obja.RootDirectory = NULL;

        Status = ZwOpenKey(&hKey,KEY_READ,&Obja);
        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ls on the setup hive. Status =  %lx \n", KeyPath, Status));
            return( Status );
        }

        RtlInitUnicodeString(&UnicodeString,ValueName);
        Status = ZwQueryValueKey( hKey,
                                  &UnicodeString,
                                  KeyValuePartialInformation,
                                  TemporaryBuffer,
                                  sizeof(TemporaryBuffer),
                                  &ResultLength );

        ZwClose(hKey);

        if( !NT_SUCCESS(Status) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: ZwQueryValueKey() failed. Value name = %ls, Status = %lx \n", ValueName, Status));
            return( Status );
        }
        DockingState = *((PDWORD)(((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data));
        DockingState &= HW_PROFILE_DOCKSTATE_UNKNOWN;
        if( ( DockingState == HW_PROFILE_DOCKSTATE_UNDOCKED ) ||
            ( DockingState == HW_PROFILE_DOCKSTATE_DOCKED ) ) {
            DockableMachine = TRUE;
        } else {
            DockableMachine = FALSE;
        }
    }
    return( Status );
}


VOID
SpCheckForBadBios(
    )

/*++

Routine Description:

    Determine whether the bios of the machine supports NT, by checking the
    registry value "BadBios" on \Registry\Machine\System\CurrentControlSet\Services\Setup.
    If this value exists and it is set to 1, then we stop the installation. Otherwise, we
    assume that the bios on this machine is fine.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE  hKey;
    PWSTR   KeyPath = L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\setupdd";
    PWSTR   ValueName = L"BadBios";
    ULONG   ResultLength;
    DWORD   BadBios;

    Status = STATUS_SUCCESS;

    //
    //  Open a the setup key in the setup hive
    //
    INIT_OBJA(&Obja,&UnicodeString,KeyPath);
    Obja.RootDirectory = NULL;

    Status = ZwOpenKey(&hKey,KEY_READ,&Obja);
    if( !NT_SUCCESS( Status ) ) {
        //
        //  If we can't open the key, then assume the BIOS is fine.
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ls on the setup hive. Status =  %lx \n", KeyPath, Status));
        return;
    }

    RtlInitUnicodeString(&UnicodeString,ValueName);
    Status = ZwQueryValueKey( hKey,
                              &UnicodeString,
                              KeyValuePartialInformation,
                              TemporaryBuffer,
                              sizeof(TemporaryBuffer),
                              &ResultLength );

    ZwClose(hKey);

    if( !NT_SUCCESS(Status) ) {
        //
        //  If we can't query the value, assume that the BIOS is fine
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: ZwQueryValueKey() failed. Value name = %ls, Status = %lx \n", ValueName, Status));
        return;
    }
    BadBios = *((PDWORD)(((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data));
    if( BadBios ) {
        //
        //  If BadBios is anything other then 0, then stop the installation
        //

        SpStartScreen( SP_SCRN_BAD_BIOS,
                       3,
                       HEADER_HEIGHT+1,
                       FALSE,
                       FALSE,
                       DEFAULT_ATTRIBUTE );

        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);

        SpInputDrain();
                while(SpInputGetKeypress() != KEY_F3) ;

        SpDone(0,FALSE,TRUE);
    }
    return;
}

NTSTATUS
SpCreateDriverRegistryEntries(
    IN PHARDWARE_COMPONENT  DriverList
    )
/*++

Routine Description:

    Creates the specified registry keys & values for the
    thirdy party (OEM) drivers

Arguments:

    DriverList : List of OEM drivers loaded for which the
                 keys need to be created

Return Value:

    STATUS_SUCCESS if successful, otherwise appropriate
    error code.

--*/
{
    NTSTATUS LastError = STATUS_SUCCESS;
    PHARDWARE_COMPONENT CurrNode;
    NTSTATUS Status = DriverList ?
                STATUS_SUCCESS : STATUS_INVALID_PARAMETER;

    for (CurrNode = DriverList; CurrNode; CurrNode = CurrNode->Next) {
        if (CurrNode->ThirdPartyOptionSelected) {
            PHARDWARE_COMPONENT_FILE CurrFile;

            for (CurrFile = CurrNode->Files;
                CurrFile;
                CurrFile = CurrFile->Next) {

                if ((CurrFile->FileType == HwFileDriver) &&
                    CurrFile->ConfigName && CurrFile->RegistryValueList) {

                    WCHAR DriverKeyName[128];
                    WCHAR DriverName[32];
                    PWSTR DriverExt;
                    HANDLE hDriverKey = NULL;
                    UNICODE_STRING UniDriverKeyName;
                    OBJECT_ATTRIBUTES ObjAttrs;
                    PHARDWARE_COMPONENT_REGISTRY CurrEntry;

                    wcscpy(DriverName, CurrFile->Filename);
                    DriverExt = wcsrchr(DriverName, L'.');

                    if (DriverExt) {
                        *DriverExt = UNICODE_NULL;
                    }

                    //
                    // Note : We use driver name, instead of ConfigName for
                    // subkey name to take care of the case where ConfigName
                    // is different from DriverName
                    //

                    wcscpy(DriverKeyName,
                        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\");

                    wcscat(DriverKeyName, DriverName);

                    RtlInitUnicodeString(&UniDriverKeyName,
                        DriverKeyName);

                    InitializeObjectAttributes(&ObjAttrs,
                        &UniDriverKeyName,
                        OBJ_CASE_INSENSITIVE,
                        NULL,
                        NULL);


                    Status = ZwCreateKey(&hDriverKey,
                                KEY_ALL_ACCESS,
                                &ObjAttrs,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                NULL);

                    if (NT_SUCCESS(Status) && hDriverKey) {
                        for (CurrEntry = CurrFile->RegistryValueList;
                            CurrEntry;
                            CurrEntry = CurrEntry->Next) {

                            PWSTR   SubKey = CurrEntry->KeyName;

                            if (SubKey && !*SubKey) {
                                SubKey = NULL;
                            }

                            Status = SpOpenSetValueAndClose(
                                        hDriverKey,
                                        SubKey,
                                        CurrEntry->ValueName,
                                        CurrEntry->ValueType,
                                        CurrEntry->Buffer,
                                        CurrEntry->BufferSize);

                            if (!NT_SUCCESS(Status)) {
                                LastError = Status;

                                KdPrintEx((DPFLTR_SETUP_ID,
                                    DPFLTR_ERROR_LEVEL,
                                    "SETUP:SpCreateDriverRegistryEntries() :"
                                    " unable to set %ws (%lx)\n",
                                    CurrEntry->ValueName,
                                    Status));
                            }

                        }

                        ZwClose(hDriverKey);
                    } else {
                        LastError = Status;
                    }
                }
            }
        }
    }

    if (!NT_SUCCESS(LastError)) {
        Status = LastError;
    }

    return Status;
}

BOOL
SpRememberMigratedDrivers (
    OUT     PLIST_ENTRY List,
    IN      PDETECTED_DEVICE SetupldrList
    )
{
    PSP_MIG_DRIVER_ENTRY MigEntry;
    BOOL b = TRUE;

    while (SetupldrList) {

        if (SetupldrList->MigratedDriver) {

            MigEntry = SpMemAlloc(sizeof (*MigEntry));
            if (MigEntry) {
                MigEntry->BaseDllName = SpToUnicode(SetupldrList->BaseDllName);
                if (MigEntry->BaseDllName) {
                    InsertTailList (List, &MigEntry->ListEntry);
                } else {
                    SpMemFree (MigEntry);
                    b = FALSE;
                }
            } else {
                b = FALSE;
            }
        }

        SetupldrList = SetupldrList->Next;
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spstrings.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    spstrings.h

Abstract:

    from windows\winstate\cobra\utils\inc\strings.h

Author:

    Jay Krell (a-JayK) November 2000

Revision History:


--*/

#pragma once
#include <string.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spstrings.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    spstrings.c

Abstract:

    from windows\winstate\cobra\utils\main\strings.c

Author:

    Jay Krell (a-JayK) November 2000

Revision History:


--*/

#include "spprecmp.h"
#include "spstrings.h"
#include "spwin.h"
#include "spcab.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spsif.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spsif.c

Abstract:

    Section names and other data used for indexing into
    setup information files.

Author:

    Ted Miller (tedm) 31-August-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop

//
// [DiskDriverMap]
//
PWSTR SIF_DISKDRIVERMAP = L"DiskDriverMap";

PWSTR SIF_SETUPMEDIA = L"SourceDisksNames";
PWSTR SIF_FILESONSETUPMEDIA = L"SourceDisksFiles";

//
// [Files.KeyboardLayout]
//
PWSTR SIF_KEYBOARDLAYOUTFILES = L"Files.KeyboardLayout";
PWSTR SIF_KEYBOARDLAYOUTDESC = L"Keyboard Layout";

//
// [Files.Vga]
//
PWSTR SIF_VGAFILES = L"Files.Vga";

//
// [WinntDirectories]
//
PWSTR SIF_NTDIRECTORIES = L"WinntDirectories";

//
// [SystemPartitionFiles]
//
PWSTR SIF_SYSPARTCOPYALWAYS = L"SystemPartitionFiles";

//
// [SystemPartitionRoot]
//
PWSTR SIF_SYSPARTROOT       = L"SystemPartitionRoot";


//
// [SystemPartitionUtilities]
//
PWSTR SIF_SYSPARTUTIL       = L"SystemPartitionUtilities";

//
// [Keyboard Layout]
//
PWSTR SIF_KEYBOARDLAYOUT = L"Keyboard Layout";

#if defined(REMOTE_BOOT)
//
// [Files.RemoteBoot]
//
PWSTR SIF_REMOTEBOOTFILES = L"Files.RemoteBoot";
#endif // defined(REMOTE_BOOT)

//
// [SpecialFiles]
// Multiprocessor =
// Uniprocessor   =
// Atdisk =
// abiosdsk =
// mouseclass =
// keyboardclass =
//
PWSTR SIF_SPECIALFILES      = L"SpecialFiles";
PWSTR SIF_MPKERNEL          = L"Multiprocessor";
PWSTR SIF_UPKERNEL          = L"Uniprocessor";
PWSTR SIF_ATDISK            = L"atdisk";
PWSTR SIF_ABIOSDISK         = L"abiosdsk";
PWSTR SIF_MOUSECLASS        = L"MouseClass";
PWSTR SIF_KEYBOARDCLASS     = L"KeyboardClass";

//
// [bootvid]
//
PWSTR SIF_BOOTVID = L"bootvid";

//
// [hal]
//
PWSTR SIF_HAL = L"hal";

//
// [ntdetect]
// standard =
//
PWSTR SIF_NTDETECT = L"ntdetect";
PWSTR SIF_STANDARD = L"standard";

//
//  [BootBusExtenders]
//
PWSTR SIF_BOOTBUSEXTENDERS = L"BootBusExtenders";

//
//  [BusExtenders]
//
PWSTR SIF_BUSEXTENDERS = L"BusExtenders";

//
//  [InputDevicesSupport]
//
PWSTR SIF_INPUTDEVICESSUPPORT = L"InputDevicesSupport";


//
// Driver load lists.
//
PWSTR SIF_SCSICLASSDRIVERS = L"ScsiClass";
PWSTR SIF_DISKDRIVERS      = L"DiskDrivers";
PWSTR SIF_CDROMDRIVERS     = L"CdRomDrivers";
PWSTR SIF_FILESYSTEMS      = L"FileSystems";

//
// [SetupData]
// ProductType =
//      0 = workstation
//      1 = server
//      2 = advanced server (subset of server)
//      3 = datacenter server (subset of advanced server)
//      4 = personal (subset of workstation)
//
// FreeDiskSpace =
//      <amount of free space in KB>
// FreeSysPartDiskSpace =
//      <amount of free space on system partition in KB>
// DefaultPath =
//      <default target path, like \winnt for example>
// DefaultLayout =
//      <value that matches an entry in [Keyboard Layout]>
// LoadIdentifier =
//      <LOADIDENTIFIER boot variable: string to display in boot menu>
// BaseVideoLoadId =
//      <string to display in boot menu for VGA mode boot [amd64/x86 only]>
// OsLoadOptions =
//      <OSLOADOPTIONS for setup boot>
// OsLoadOptionsVar =
//      <optional OSLOADOPTIONS boot variable value>
// OsLoadOptionsVarAppend =
//      <optional OSLOADOPTIONS boot variable value to be appended to existing options >
// SetupSourceDevice =
//      <OPTIONAL: Nt path of source device, overrides cd-rom, etc>
// SetupSourcePath =
//      <directory on setup source where setup tree is to be found>
// DontCopy =
//      <OPTIONAL: 0,1, indicates whether to skip actual file copying>
// RequiredMemory =
//      <number of bytes of memory required for installation>
// SetupCmdlinePrepend =
//      <value to stick at front of command line, like windbg or ntsd -d>
//
PWSTR SIF_SETUPDATA             = L"SetupData";
PWSTR SIF_DISKSPACEREQUIREMENTS = L"DiskSpaceRequirements";
PWSTR SIF_PRODUCTTYPE           = L"ProductType";
PWSTR SIF_MAJORVERSION          = L"MajorVersion";
PWSTR SIF_MINORVERSION          = L"MinorVersion";
PWSTR SIF_WINDIRSPACE           = L"WindirSpace";
PWSTR SIF_FREESYSPARTDISKSPACE  = L"FreeSysPartDiskSpace";
PWSTR SIF_DEFAULTPATH           = L"DefaultPath";
PWSTR SIF_LOADIDENTIFIER        = L"LoadIdentifier";
PWSTR SIF_BASEVIDEOLOADID       = L"BaseVideoLoadId";
PWSTR SIF_OSLOADOPTIONS         = L"OsLoadOptions";
PWSTR SIF_OSLOADOPTIONSVAR      = L"OsLoadOptionsVar";
PWSTR SIF_OSLOADOPTIONSVARAPPEND = L"OsLoadOptionsVarAppend";
PWSTR SIF_SETUPSOURCEDEVICE     = L"SetupSourceDevice";
PWSTR SIF_SETUPSOURCEPATH       = L"SetupSourcePath";
PWSTR SIF_DONTCOPY              = L"DontCopy";
PWSTR SIF_REQUIREDMEMORY        = L"RequiredMemory";
PWSTR SIF_SETUPCMDPREPEND       = L"SetupCmdlinePrepend";
PWSTR SIF_PAGEFILE              = L"Pagefile";

//
// [nls]
// AnsiCodePage = <filename>,<identifier>
// OemCodePage = <filename>,<identifier>
// MacCodePage = <filename>,<identifier>
// UnicodeCasetable = <filename>
// OemHalFont = <filename>
// DefaultLayout = <identifier>
//
PWSTR SIF_NLS               = L"nls";
PWSTR SIF_ANSICODEPAGE      = L"AnsiCodepage";
PWSTR SIF_OEMCODEPAGE       = L"OemCodepage";
PWSTR SIF_MACCODEPAGE       = L"MacCodepage";
PWSTR SIF_UNICODECASETABLE  = L"UnicodeCasetable";
PWSTR SIF_OEMHALFONT        = L"OemHalFont";
PWSTR SIF_DEFAULTLAYOUT     = L"DefaultLayout";

//
// 1.0 repair disk sections.
//
PWSTR SIF_REPAIRWINNTFILES   = L"Repair.WinntFiles";
PWSTR SIF_REPAIRSYSPARTFILES = L"Repair.BootFiles";


//
// UPGRADE SIF SECTIONS
//

//
// Upgrade Registry sections
// =========================
//
//
// 1. The following section allows us to specify services to disable which may
// cause popups when net services are disabled:
//
// [NetServicesToDisable]
// ServiceName1
// ...
//
// 2. The following section allows us to remove keys which have been removed
// since the Windows NT 3.1 release:
//
// [KeysToDelete]
// RootName1( System | Software | Default | ControlSet ), RootRelativePath1
// ...
//
// 3. The following sections allow us to add/change keys / values under keys
// which have changed since the Windows NT 3.1 release:
//
// [KeysToAdd]
// RootName1, RootRelativePath1, ValueSection1 (can be "")
// ...
//
// [ValueSection1]
// name1 , type1, value1
// name2 , ...
//
// Format of the value is the following
//
// a. Type REG_SZ:          name , REG_SZ,           "value string"
// b. Type REG_EXPAND_SZ    name , REG_EXPAND_SZ,    "value string"
// c. Type REG_MULTI_SZ     name , REG_MULTI_SZ,     "value string1", "value string2", ...
// d. Type REG_BINARY       name , REG_BINARY,       byte1, byte2, ...
// e. Type REG_DWORD        name , REG_DWORD,        dword
// f. Type REG_BINARY_DWORD name , REG_BINARY_DWORD, dword1, dword2, ...
//

PWSTR SIF_NET_SERVICES_TO_DISABLE = L"NetServicesToDisable";
PWSTR SIF_KEYS_TO_DELETE          = L"KeysToDelete";
PWSTR SIF_KEYS_TO_ADD             = L"KeysToAdd";

PWSTR SIF_SYSTEM_HIVE      = L"System";
PWSTR SIF_SOFTWARE_HIVE    = L"Software";
PWSTR SIF_DEFAULT_HIVE     = L"Default";
PWSTR SIF_CONTROL_SET      = L"ControlSet";

PWSTR SIF_REG_SZ            = L"REG_SZ";
PWSTR SIF_REG_EXPAND_SZ     = L"REG_EXPAND_SZ";
PWSTR SIF_REG_MULTI_SZ      = L"REG_MULTI_SZ";
PWSTR SIF_REG_BINARY        = L"REG_BINARY";
PWSTR SIF_REG_BINARY_DWORD  = L"REG_BINARY_DWORD";
PWSTR SIF_REG_DWORD         = L"REG_DWORD";

//
// Upgrade File Sections
// =====================
//
//

//
// Files to backup, delete or move
//
PWSTR SIF_FILESDELETEONUPGRADE   = L"Files.DeleteOnUpgrade";
PWSTR SIF_FILESBACKUPONUPGRADE   = L"Files.BackupOnUpgrade";
PWSTR SIF_FILESBACKUPONOVERWRITE = L"Files.BackupOnOverwrite";

//
// Directories to delete
//

PWSTR SIF_DIRSDELETEONUPGRADE   = L"Directories.DeleteOnUpgrade";


#if defined(_AMD64_) || defined(_X86_)
PWSTR SIF_FILESMOVEBEFOREMIGRATION = L"Files.MoveBeforeMigration";
PWSTR SIF_FILESDELETEBEFOREMIGRATION = L"Files.DeleteBeforeMigration";
#endif // defined(_AMD64_) || defined(_X86_)

//
// Files to copy
//
PWSTR SIF_FILESUPGRADEWIN31    = L"Files.UpgradeWin31";
PWSTR SIF_FILESNEWHIVES        = L"Files.NewHives";


//
// New sections and keys added to setup.log
//

PWSTR SIF_NEW_REPAIR_WINNTFILES     = L"Files.WinNt";
PWSTR SIF_NEW_REPAIR_SYSPARTFILES   = L"Files.SystemPartition";
PWSTR SIF_NEW_REPAIR_SIGNATURE      = L"Signature";
PWSTR SIF_NEW_REPAIR_VERSION_KEY    = L"Version";
PWSTR SIF_NEW_REPAIR_NT_VERSION     = NULL; // Will be created during the
                                            // initialization of setupdd
                                            //
PWSTR SIF_NEW_REPAIR_NT_VERSION_TEMPLATE= L"WinNt%d.%d";
PWSTR SIF_NEW_REPAIR_PATHS                              = L"Paths";
PWSTR SIF_NEW_REPAIR_PATHS_SYSTEM_PARTITION_DEVICE      = L"SystemPartition";
PWSTR SIF_NEW_REPAIR_PATHS_SYSTEM_PARTITION_DIRECTORY   = L"SystemPartitionDirectory";
PWSTR SIF_NEW_REPAIR_PATHS_TARGET_DEVICE                = L"TargetDevice";
PWSTR SIF_NEW_REPAIR_PATHS_TARGET_DIRECTORY             = L"TargetDirectory";

PWSTR SETUP_REPAIR_DIRECTORY           = L"repair";
PWSTR SETUP_LOG_FILENAME            = L"\\setup.log";

PWSTR SIF_NEW_REPAIR_FILES_IN_REPAIR_DIR    = L"Files.InRepairDirectory";

//
// Unattended mode sections (winnt.sif)
//
PWSTR SIF_DATA                  = WINNT_DATA_W;
PWSTR SIF_UNATTENDED            = WINNT_UNATTENDED_W;
PWSTR SIF_SETUPPARAMS           = WINNT_SETUPPARAMS_W;
PWSTR SIF_CONFIRMHW             = WINNT_U_CONFIRMHW_W;
PWSTR SIF_GUI_UNATTENDED        = WINNT_GUIUNATTENDED_W;
PWSTR SIF_UNATTENDED_INF_FILE   = WINNT_GUI_FILE_W;
PWSTR SIF_UNIQUEID              = WINNT_D_UNIQUEID_W;
PWSTR SIF_ACCESSIBILITY         = WINNT_ACCESSIBILITY_W;

PWSTR SIF_EXTENDOEMPART         = L"ExtendOemPartition";

PWSTR SIF_REMOTEINSTALL         = L"RemoteInstall";
#if defined(REMOTE_BOOT)
PWSTR SIF_REMOTEBOOT            = L"RemoteBoot";
PWSTR SIF_ENABLEIPSECURITY      = L"EnableIpSecurity";
#endif // defined(REMOTE_BOOT)
PWSTR SIF_REPARTITION           = L"Repartition";
PWSTR SIF_USEWHOLEDISK          = L"UseWholeDisk";


PWSTR SIF_INCOMPATIBLE_TEXTMODE = WINNT_OVERWRITE_EXISTING_W;

//
// Alternate Source data
//
PWSTR SIF_UPDATEDSOURCES        = WINNT_SP_UPDATEDSOURCES_W;
//PWSTR SIF_ALTCOPYFILESSECTION   = WINNT_SP_ALTCOPY_W;

PWSTR
SpPlatformSpecificLookup(
    IN PVOID   SifHandle,
    IN PWSTR   Section,
    IN PWSTR   Key,
    IN ULONG   Index,
    IN BOOLEAN Fatal
    )

/*++

Routine Description:

    Look up a value in a platform-specific section and if not found,
    then in a platform-independent section. The platform-specific
    section name is the platform-independent name with .<platform>
    appended to it (where <platform is amd64, x86, ia64, etc).

Arguments:

    SifHandle - supplies a handle to the open sif in which the
        value is to be found.

    Section - supplies the base section name of the section in which
        the value is to be found.

    Key - supplies the key name of the line in the section in which
        the value is to be found.

    Index - supplies the index (0-based) of the value to be looked up
        on the line with the given Key in the given section or its
        platform-specific analogue.

    Fatal - if TRUE and the value is not found, then this is a fatal error
        and this routine will not return. if FALSE and the value is not
        found, then this routine returns NULL.

Return Value:

    Value located in the section or its platform-specific analog,
    or NULL if it cannot be found and Fatal was FALSE.

--*/

{
    PWSTR p = NULL;
    PWSTR PlatformSpecificSection;

    PlatformSpecificSection = SpMakePlatformSpecificSectionName(Section);

    if (PlatformSpecificSection) {
        p = SpGetSectionKeyIndex(SifHandle,PlatformSpecificSection,Key,Index);
        SpMemFree(PlatformSpecificSection);
    }        

    if(!p) {
        p = SpGetSectionKeyIndex(SifHandle,Section,Key,Index);
    }

    if(!p && Fatal) {
        SpFatalSifError(SifHandle,Section,Key,0,Index);
    }

    return(p);
}


PWSTR
SpLookUpTargetDirectory(
    IN PVOID SifHandle,
    IN PWSTR Symbol
    )

/*++

Routine Description:

    Retreive the target directory associated with a particular
    shortname. The symbol is looked for as a key in the platform-
    specific [WinntDirectories.xxx] section and if not found there,
    in the platform-independent [WinntDirectories] section.

Arguments:

    SifHandle - supplies a handle to the open sif in which the
        [WinntDirectories] sections are to be found.

Return Value:

--*/

{
    PWSTR p;

    p = SpPlatformSpecificLookup(
            SifHandle,
            SIF_NTDIRECTORIES,
            Symbol,
            0,
            TRUE
            );

    return(p);
}


PWSTR
SpLookUpValueForFile(
    IN PVOID   SifHandle,
    IN PWSTR   File,
    IN ULONG   Index,
    IN BOOLEAN Fatal
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PWSTR p;

    p = SpPlatformSpecificLookup(
            SifHandle,
            SIF_FILESONSETUPMEDIA,
            File,
            Index,
            Fatal
            );

    return(p);
}


BOOLEAN
IsFileFlagSet(
    IN PVOID SifHandle,
    IN PWSTR FileName,
    IN ULONG Flag
    )
{
    PWSTR file;
    PWSTR p;
    ULONG flags;
    BOOLEAN b;

    //
    // Locate file name
    //
    if(file = wcsrchr(FileName,L'\\')) {
        file++;
    } else {
        file = FileName;
    }

    if(p = SpGetSectionKeyIndex(SifHandle,L"FileFlags",file,0)) {

        flags = SpStringToLong(p,NULL,10);

        b = (flags & Flag) ? TRUE : FALSE;

    } else {
        b = FALSE;
    }

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spstring.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spstring.c

Abstract:

    This module contains functions to manipulate strings.
    These functions would ordinarily be performed by C Runtime routines
    except that we want to avoid linking this device driver with
    the kernel crt.

Author:

    Ted Miller (tedm) 15-Jan-1994

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop

VOID
SpStringToUpper(
    IN PWSTR String
    )
{
    for( ; *String; String++) {
        *String = SpToUpper(*String);
    }
}

VOID
SpStringToLower(
    IN PWSTR String
    )
{
    for( ; *String; String++) {
        *String = SpToLower(*String);
    }
}


PWCHAR
SpFindCharFromListInString(
    PWSTR String,
    PWSTR CharList
    )
{
    PWSTR wcset;

    while(*String) {
        for(wcset=CharList; *wcset; wcset++) {
            if(*wcset == *String) {
                return(String);
            }
        }
        String++;
    }
    return(NULL);
}


unsigned
SpMultiByteStringToUnsigned(
    IN  PUCHAR  String,
    OUT PUCHAR *CharThatStoppedScan OPTIONAL
    )
{
    unsigned accum = 0;

    while(*String) {

        if(isdigit(*String)) {
            accum *= 10;
            accum += *String - '0';
        }

        String++;
    }

    if(CharThatStoppedScan) {
        *CharThatStoppedScan = String;
    }

    return(accum);
}


LONG
SpStringToLong(
    IN  PWSTR     String,
    OUT PWCHAR   *EndOfValue,
    IN  unsigned  Radix
    )
{
    PWSTR p;
    BOOLEAN Negative;
    LONG Accum,v;
    WCHAR HighestDigitAllowed,HighestLetterAllowed;
    WCHAR c;

    //
    // Validate radix, 0 or 2-36.
    //
    if((Radix == 1) || (Radix > 36)) {
        if(EndOfValue) {
            *EndOfValue = String;
        }
        return(0);    
    }
    
    p = String;

    //
    // Skip whitespace.
    //
    while(SpIsSpace(*p)) {
        p++;
    }

    //
    // First char may be a plus or minus.
    //
    Negative = FALSE;
    if(*p == L'-') {
        Negative = TRUE;            
        p++;
    } else {
        if(*p == L'+') {
            p++;
        }
    }

    if(!Radix) {
        if(*p == L'0') {
            //
            // Octal number
            //
            Radix = 8;
            p++;
            if((*p == L'x') || (*p == L'X')) {
                //
                // hex number
                //
                Radix = 16;
                p++;
            }
        } else {
            Radix = 10;
        }
    }

    HighestDigitAllowed = (Radix < 10) ? L'0'+(WCHAR)(Radix-1) : L'9';
    HighestLetterAllowed = (Radix > 10) ? L'A'+(WCHAR)(Radix-11) : 0;

    Accum = 0;

    while(1) {

        c = *p;

        if((c >= L'0') && (c <= HighestDigitAllowed)) {
            v = c - L'0';
        } else {

            c = SpToUpper(c);

            if((c >= L'A') && (c <= HighestLetterAllowed)) {
                v = c - L'A' + 10;
            } else {
                break;
            }
        }

        Accum *= Radix;
        Accum += v;

        p++;
    }

    if(EndOfValue) {
        *EndOfValue = p;
    }

    return(Negative ? (0-Accum) : Accum);
}

PWCHAR
SpConvertMultiSzStrToWstr(
    IN PCHAR Source,
    IN ULONG Length
    )
{
    NTSTATUS status;
    PCHAR s, sourceEnd;
    PWCHAR dest, d;
    ANSI_STRING ansiString;
    UNICODE_STRING unicodeString;

    if (Length <= 2) {

        return NULL;
    }

#if DBG
    for (s = Source; *s != '\0'; s += strlen(s) + 1) {
    }
    ASSERT(Length == (ULONG)(s - Source) + 1);
#endif

    dest = SpMemAlloc(Length * sizeof(WCHAR));
    if (dest) {

        s = Source;
        for (sourceEnd = s + Length, d = dest; 
             s < sourceEnd && *s != '\0'; 
             s += strlen(s) + 1) {

            RtlInitAnsiString(&ansiString, s);
            status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, TRUE);
            if (!NT_SUCCESS(status)) {

                SpMemFree(dest);
                return NULL;
            }
            RtlCopyMemory(d, unicodeString.Buffer, unicodeString.Length + sizeof(UNICODE_NULL));
            d += (unicodeString.Length + sizeof(UNICODE_NULL)) / sizeof(WCHAR);
            RtlFreeUnicodeString(&unicodeString);
        }
        if (s < sourceEnd) {
            *d = UNICODE_NULL;
        }
    }

    return dest;
}

PCHAR
SpConvertMultiSzWstrToStr(
    IN PWCHAR Source,
    IN ULONG Length
    )
{
    NTSTATUS status;
    PWCHAR  s, sourceEnd;
    PCHAR   dest, d;
    ANSI_STRING ansiString;
    UNICODE_STRING unicodeString;

    if (Length <= 2) {

        return NULL;
    }

#if DBG
    for (s = Source; *s != UNICODE_NULL; s += wcslen(s) + 1) {
    }
    ASSERT(Length == (ULONG)(s - Source) + 1);
#endif
    dest = SpMemAlloc(Length * sizeof(CHAR));
    if (dest) {

        s = Source;
        for (sourceEnd = s + Length, d = dest; 
             s < sourceEnd && *s != UNICODE_NULL; 
             s += wcslen(s) + 1) {

            RtlInitUnicodeString(&unicodeString, s);
            status = RtlUnicodeStringToAnsiString(&ansiString, &unicodeString, TRUE);
            if (!NT_SUCCESS(status)) {

                SpMemFree(dest);
                return NULL;
            }
            RtlCopyMemory(d, ansiString.Buffer, ansiString.Length + 1);
            d += ansiString.Length + 1;
            RtlFreeAnsiString(&ansiString);
        }
        if (s < sourceEnd) {
            *d = '\0';
        }
    }

    return dest;
}



UCHAR _SpCharTypes[CTSIZE] = {
                                
    _SP_NONE,                   /* 00 (NUL) */
    _SP_NONE,                   /* 01 (SOH) */
    _SP_NONE,                   /* 02 (STX) */
    _SP_NONE,                   /* 03 (ETX) */
    _SP_NONE,                   /* 04 (EOT) */
    _SP_NONE,                   /* 05 (ENQ) */
    _SP_NONE,                   /* 06 (ACK) */
    _SP_NONE,                   /* 07 (BEL) */
    _SP_NONE,                   /* 08 (BS)  */
    _SP_SPACE,                  /* 09 (HT)  */
    _SP_SPACE,                  /* 0A (LF)  */
    _SP_SPACE,                  /* 0B (VT)  */
    _SP_SPACE,                  /* 0C (FF)  */
    _SP_SPACE,                  /* 0D (CR)  */
    _SP_NONE,                   /* 0E (SI)  */
    _SP_NONE,                   /* 0F (SO)  */
    _SP_NONE,                   /* 10 (DLE) */
    _SP_NONE,                   /* 11 (DC1) */
    _SP_NONE,                   /* 12 (DC2) */
    _SP_NONE,                   /* 13 (DC3) */
    _SP_NONE,                   /* 14 (DC4) */
    _SP_NONE,                   /* 15 (NAK) */
    _SP_NONE,                   /* 16 (SYN) */
    _SP_NONE,                   /* 17 (ETB) */
    _SP_NONE,                   /* 18 (CAN) */
    _SP_NONE,                   /* 19 (EM)  */
    _SP_NONE,                   /* 1A (SUB) */
    _SP_NONE,                   /* 1B (ESC) */
    _SP_NONE,                   /* 1C (FS)  */
    _SP_NONE,                   /* 1D (GS)  */
    _SP_NONE,                   /* 1E (RS)  */
    _SP_NONE,                   /* 1F (US)  */
    _SP_SPACE,                  /* 20 SPACE */
    _SP_NONE,                   /* 21 !     */
    _SP_NONE,                   /* 22 "     */
    _SP_NONE,                   /* 23 #     */
    _SP_NONE,                   /* 24 $     */
    _SP_NONE,                   /* 25 %     */
    _SP_NONE,                   /* 26 &     */
    _SP_NONE,                   /* 27 '     */
    _SP_NONE,                   /* 28 (     */
    _SP_NONE,                   /* 29 )     */
    _SP_NONE,                   /* 2A *     */
    _SP_NONE,                   /* 2B +     */
    _SP_NONE,                   /* 2C ,     */
    _SP_NONE,                   /* 2D -     */
    _SP_NONE,                   /* 2E .     */
    _SP_NONE,                   /* 2F /     */
    _SP_DIGIT + _SP_XDIGIT,     /* 30 0     */
    _SP_DIGIT + _SP_XDIGIT,     /* 31 1     */
    _SP_DIGIT + _SP_XDIGIT,     /* 32 2     */
    _SP_DIGIT + _SP_XDIGIT,     /* 33 3     */
    _SP_DIGIT + _SP_XDIGIT,     /* 34 4     */
    _SP_DIGIT + _SP_XDIGIT,     /* 35 5     */
    _SP_DIGIT + _SP_XDIGIT,     /* 36 6     */
    _SP_DIGIT + _SP_XDIGIT,     /* 37 7     */
    _SP_DIGIT + _SP_XDIGIT,     /* 38 8     */
    _SP_DIGIT + _SP_XDIGIT,     /* 39 9     */
    _SP_NONE,                   /* 3A :     */
    _SP_NONE,                   /* 3B ;     */
    _SP_NONE,                   /* 3C <     */
    _SP_NONE,                   /* 3D =     */
    _SP_NONE,                   /* 3E >     */
    _SP_NONE,                   /* 3F ?     */
    _SP_NONE,                   /* 40 @     */
    _SP_UPPER + _SP_XDIGIT,     /* 41 A     */
    _SP_UPPER + _SP_XDIGIT,     /* 42 B     */
    _SP_UPPER + _SP_XDIGIT,     /* 43 C     */
    _SP_UPPER + _SP_XDIGIT,     /* 44 D     */
    _SP_UPPER + _SP_XDIGIT,     /* 45 E     */
    _SP_UPPER + _SP_XDIGIT,     /* 46 F     */
    _SP_UPPER,                  /* 47 G     */
    _SP_UPPER,                  /* 48 H     */
    _SP_UPPER,                  /* 49 I     */
    _SP_UPPER,                  /* 4A J     */
    _SP_UPPER,                  /* 4B K     */
    _SP_UPPER,                  /* 4C L     */
    _SP_UPPER,                  /* 4D M     */
    _SP_UPPER,                  /* 4E N     */
    _SP_UPPER,                  /* 4F O     */
    _SP_UPPER,                  /* 50 P     */
    _SP_UPPER,                  /* 51 Q     */
    _SP_UPPER,                  /* 52 R     */
    _SP_UPPER,                  /* 53 S     */
    _SP_UPPER,                  /* 54 T     */
    _SP_UPPER,                  /* 55 U     */
    _SP_UPPER,                  /* 56 V     */
    _SP_UPPER,                  /* 57 W     */
    _SP_UPPER,                  /* 58 X     */
    _SP_UPPER,                  /* 59 Y     */
    _SP_UPPER,                  /* 5A Z     */
    _SP_NONE,                   /* 5B [     */
    _SP_NONE,                   /* 5C \     */
    _SP_NONE,                   /* 5D ]     */
    _SP_NONE,                   /* 5E ^     */
    _SP_NONE,                   /* 5F _     */
    _SP_NONE,                   /* 60 `     */
    _SP_LOWER + _SP_XDIGIT,     /* 61 a     */
    _SP_LOWER + _SP_XDIGIT,     /* 62 b     */
    _SP_LOWER + _SP_XDIGIT,     /* 63 c     */
    _SP_LOWER + _SP_XDIGIT,     /* 64 d     */
    _SP_LOWER + _SP_XDIGIT,     /* 65 e     */
    _SP_LOWER + _SP_XDIGIT,     /* 66 f     */
    _SP_LOWER,                  /* 67 g     */
    _SP_LOWER,                  /* 68 h     */
    _SP_LOWER,                  /* 69 i     */
    _SP_LOWER,                  /* 6A j     */
    _SP_LOWER,                  /* 6B k     */
    _SP_LOWER,                  /* 6C l     */
    _SP_LOWER,                  /* 6D m     */
    _SP_LOWER,                  /* 6E n     */
    _SP_LOWER,                  /* 6F o     */
    _SP_LOWER,                  /* 70 p     */
    _SP_LOWER,                  /* 71 q     */
    _SP_LOWER,                  /* 72 r     */
    _SP_LOWER,                  /* 73 s     */
    _SP_LOWER,                  /* 74 t     */
    _SP_LOWER,                  /* 75 u     */
    _SP_LOWER,                  /* 76 v     */
    _SP_LOWER,                  /* 77 w     */
    _SP_LOWER,                  /* 78 x     */
    _SP_LOWER,                  /* 79 y     */
    _SP_LOWER                   /* 7A z     */
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spsif.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spsif.h

Abstract:

    Header file for section names and other data used for indexing into
    setup information files.

Author:

    Ted Miller (tedm) 31-August-1993

Revision History:

--*/


#ifndef _SPSIF_
#define _SPSIF_



//
// Field indices for hardware-related sections in txtsetup.sif
//

// in [Map.<Component>] sections
#define INDEX_MAP_FWID          0

// in [<Component>] sections
#define INDEX_DESCRIPTION       0
#define INDEX_FILESECTION       1
#define INDEX_INFKEYNAME        2
#define INDEX_FIRSTAUXFIELD     3


//
// Macro to determine whether a string is present in a SIF.
//
#define SIF_SPECIFIED(string)   ((string) && *(string))

extern PWSTR SIF_DISKDRIVERMAP;

//
// Media description and file placement
//
extern PWSTR SIF_SETUPMEDIA;
extern PWSTR SIF_FILESONSETUPMEDIA;

//
// defines to index into SIF_FILESONSETUPMEDIA section
//
#define INDEX_WHICHMEDIA        0
#define INDEX_WHICHBOOTMEDIA    6
#define INDEX_DESTINATION       7
#define INDEX_UPGRADE           8
#define INDEX_WINNTFILE         9
#define INDEX_TARGETNAME        10

//
// This is the index for file attributes, currently only being used for
// system partition utilities in IA64.
//
#define INDEX_FILE_ATTRIB       13

//
// File copy lists
//
extern PWSTR SIF_SYSPARTCOPYALWAYS;
extern PWSTR SIF_SYSPARTROOT;
extern PWSTR SIF_SYSPARTUTIL;                             
extern PWSTR SIF_SPECIALFILES;
extern PWSTR SIF_MPKERNEL;
extern PWSTR SIF_UPKERNEL;
extern PWSTR SIF_ATDISK;
extern PWSTR SIF_ABIOSDISK;
extern PWSTR SIF_MOUSECLASS;
extern PWSTR SIF_KEYBOARDCLASS;

extern PWSTR SIF_HAL;
extern PWSTR SIF_BOOTVID;

extern PWSTR SIF_BOOTBUSEXTENDERS;
extern PWSTR SIF_BUSEXTENDERS;
extern PWSTR SIF_INPUTDEVICESSUPPORT;

extern PWSTR SIF_NTDETECT;
extern PWSTR SIF_STANDARD;

extern PWSTR SIF_KEYBOARDLAYOUTFILES;
extern PWSTR SIF_KEYBOARDLAYOUTDESC;
extern PWSTR SIF_VGAFILES;

extern PWSTR SIF_NTDIRECTORIES;

extern PWSTR SIF_SCSICLASSDRIVERS;
extern PWSTR SIF_DISKDRIVERS;
extern PWSTR SIF_CDROMDRIVERS;
extern PWSTR SIF_FILESYSTEMS;

extern PWSTR SIF_KEYBOARDLAYOUT;

#if defined(REMOTE_BOOT)
extern PWSTR SIF_REMOTEBOOTFILES;
#endif // defined(REMOTE_BOOT)

extern PWSTR SIF_SETUPDATA;
extern PWSTR SIF_DISKSPACEREQUIREMENTS;
extern PWSTR SIF_PRODUCTTYPE;
extern PWSTR SIF_MAJORVERSION;
extern PWSTR SIF_MINORVERSION;
extern PWSTR SIF_WINDIRSPACE;
extern PWSTR SIF_FREESYSPARTDISKSPACE;
extern PWSTR SIF_DEFAULTPATH;
extern PWSTR SIF_LOADIDENTIFIER;
extern PWSTR SIF_BASEVIDEOLOADID;
extern PWSTR SIF_OSLOADOPTIONS;
extern PWSTR SIF_OSLOADOPTIONSVAR;
extern PWSTR SIF_OSLOADOPTIONSVARAPPEND;
extern PWSTR SIF_SETUPSOURCEDEVICE;
extern PWSTR SIF_SETUPSOURCEPATH;
extern PWSTR SIF_DONTCOPY;
extern PWSTR SIF_REQUIREDMEMORY;
extern PWSTR SIF_SETUPCMDPREPEND;
extern PWSTR SIF_PAGEFILE;

extern PWSTR SIF_NLS;
extern PWSTR SIF_ANSICODEPAGE;
extern PWSTR SIF_OEMCODEPAGE;
extern PWSTR SIF_MACCODEPAGE;
extern PWSTR SIF_UNICODECASETABLE;
extern PWSTR SIF_OEMHALFONT;
extern PWSTR SIF_DEFAULTLAYOUT;

extern PWSTR SIF_REPAIRWINNTFILES;
extern PWSTR SIF_REPAIRSYSPARTFILES;


//
// Upgrade sections, values
//

extern PWSTR SIF_NET_SERVICES_TO_DISABLE;
extern PWSTR SIF_KEYS_TO_DELETE;
extern PWSTR SIF_KEYS_TO_ADD;

extern PWSTR SIF_SYSTEM_HIVE;
extern PWSTR SIF_SOFTWARE_HIVE;
extern PWSTR SIF_DEFAULT_HIVE;
extern PWSTR SIF_CONTROL_SET;

extern PWSTR SIF_REG_SZ;
extern PWSTR SIF_REG_DWORD;
extern PWSTR SIF_REG_EXPAND_SZ;
extern PWSTR SIF_REG_MULTI_SZ;
extern PWSTR SIF_REG_BINARY;
extern PWSTR SIF_REG_BINARY_DWORD;

extern PWSTR SIF_FILESDELETEONUPGRADE;
extern PWSTR SIF_FILESBACKUPONUPGRADE;
extern PWSTR SIF_FILESBACKUPONOVERWRITE;

extern PWSTR SIF_DIRSDELETEONUPGRADE;

#ifdef _X86_
extern PWSTR SIF_FILESMOVEBEFOREMIGRATION;
extern PWSTR SIF_FILESDELETEBEFOREMIGRATION;
#endif

extern PWSTR SIF_FILESUPGRADEWIN31;
extern PWSTR SIF_FILESNEWHIVES;

//
// New sections and keys added to setup.log
//

extern PWSTR SIF_NEW_REPAIR_WINNTFILES;
extern PWSTR SIF_NEW_REPAIR_SYSPARTFILES;
extern PWSTR SIF_NEW_REPAIR_SIGNATURE;
extern PWSTR SIF_NEW_REPAIR_VERSION_KEY;
extern PWSTR SIF_NEW_REPAIR_NT_VERSION_TEMPLATE;
extern PWSTR SIF_NEW_REPAIR_NT_VERSION;
extern PWSTR SIF_NEW_REPAIR_PATHS;
extern PWSTR SIF_NEW_REPAIR_PATHS_SYSTEM_PARTITION_DEVICE;
extern PWSTR SIF_NEW_REPAIR_PATHS_SYSTEM_PARTITION_DIRECTORY;
extern PWSTR SIF_NEW_REPAIR_PATHS_TARGET_DEVICE;
extern PWSTR SIF_NEW_REPAIR_PATHS_TARGET_DIRECTORY;

extern PWSTR SETUP_REPAIR_DIRECTORY;
extern PWSTR SETUP_LOG_FILENAME;

extern PWSTR SIF_NEW_REPAIR_FILES_IN_REPAIR_DIR;

extern PWSTR SIF_DATA;
extern PWSTR SIF_UNATTENDED;
extern PWSTR SIF_SETUPPARAMS;
extern PWSTR SIF_CONFIRMHW;
extern PWSTR SIF_GUI_UNATTENDED;
extern PWSTR SIF_UNATTENDED_INF_FILE;
extern PWSTR SIF_UNIQUEID;
extern PWSTR SIF_EXTENDOEMPART;
extern PWSTR SIF_ACCESSIBILITY;

extern PWSTR SIF_REMOTEINSTALL;
#if defined(REMOTE_BOOT)
extern PWSTR SIF_REMOTEBOOT;
extern PWSTR SIF_ENABLEIPSECURITY;
#endif // defined(REMOTE_BOOT)
extern PWSTR SIF_REPARTITION;
extern PWSTR SIF_USEWHOLEDISK;

//
// Alternate Source data
//
extern PWSTR SIF_UPDATEDSOURCES;
//extern PWSTR SIF_ALTCOPYFILESSECTION;

extern PWSTR SIF_INCOMPATIBLE_TEXTMODE;


PWSTR
SpPlatformSpecificLookup(
    IN PVOID   SifHandle,
    IN PWSTR   Section,
    IN PWSTR   Key,
    IN ULONG   Index,
    IN BOOLEAN Fatal
    );

PWSTR
SpLookUpTargetDirectory(
    IN PVOID SifHandle,
    IN PWSTR Symbol
    );

PWSTR
SpLookUpValueForFile(
    IN PVOID   SifHandle,
    IN PWSTR   File,
    IN ULONG   Index,
    IN BOOLEAN Fatal
    );

BOOLEAN
IsFileFlagSet(
    IN PVOID SifHandle,
    IN PWSTR FileName,
    IN ULONG Flag
    );

#endif // ndef _SPSIF_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spswitch.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    spswitch.h

Abstract:

    Macros & Functions to switch between old and 
    new partitioning engine in textmode.

    NEW_PARTITION_ENGINE forces new partition engine
    code to be used for both MBR and GPT disks.

    GPT_PARTITION_ENGINE forces new partition engine
    code to be used for GPT disks and old partition
    engine code for MBR disks.

    OLD_PARTITION_ENGINE forces the old partition
    engine to used for MBR disks. This option cannot
    handle GPT disks.

    Note : 
    If none of the NEW_PARTITION_ENGINE, 
    OLD_PARTITION_ENGINE or GPT_PARTITION_ENGINE macro
    is defined, then by default NEW_PARTITION_ENGINE is
    used.

Author:

    Vijay Jayaseelan    (vijayj)    18 March 2000

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop


#ifdef NEW_PARTITION_ENGINE

//
// Switching stubs for NEW_PARTITION_ENGINE
//

NTSTATUS
SpPtPrepareDisks(
    IN  PVOID         SifHandle,
    OUT PDISK_REGION *InstallRegion,
    OUT PDISK_REGION *SystemPartitionRegion,
    IN  PWSTR         SetupSourceDevicePath,
    IN  PWSTR         DirectoryOnSetupSource,
    IN  BOOLEAN       RemoteBootRepartition
    )
{
    return SpPtnPrepareDisks(SifHandle,
                    InstallRegion,
                    SystemPartitionRegion,
                    SetupSourceDevicePath,
                    DirectoryOnSetupSource,
                    RemoteBootRepartition);
}

NTSTATUS
SpPtInitialize(
    VOID
    )
{
    return SpPtnInitializeDiskDrives();
}


PDISK_REGION
SpPtValidSystemPartition(
    VOID
    )
{
    return SpPtnValidSystemPartition();
}


PDISK_REGION
SpPtValidSystemPartitionArc(
    IN PVOID SifHandle,
    IN PWSTR SetupSourceDevicePath,
    IN PWSTR DirectoryOnSetupSource
    )
{
    return SpPtnValidSystemPartitionArc(SifHandle,
                    SetupSourceDevicePath,
                    DirectoryOnSetupSource,
                    TRUE);
}


BOOLEAN
SpPtDoCreate(
    IN  PDISK_REGION  pRegion,
    OUT PDISK_REGION *pActualRegion, OPTIONAL
    IN  BOOLEAN       ForNT,
    IN  ULONGLONG     DesiredMB OPTIONAL,
    IN  PPARTITION_INFORMATION_EX PartInfo OPTIONAL,
    IN  BOOLEAN       ConfirmIt
    )
{
    return SpPtnDoCreate(pRegion,
                        pActualRegion,
                        ForNT,
                        DesiredMB,
                        PartInfo,
                        ConfirmIt);
}


VOID
SpPtDoDelete(
    IN PDISK_REGION pRegion,
    IN PWSTR        RegionDescription,
    IN BOOLEAN      ConfirmIt
    )
{
    SpPtnDoDelete(pRegion,
                RegionDescription,
                ConfirmIt);
}


ULONG
SpPtGetOrdinal(
    IN PDISK_REGION         Region,
    IN PartitionOrdinalType OrdinalType
    )
{
    return SpPtnGetOrdinal(Region, OrdinalType);
}


VOID
SpPtGetSectorLayoutInformation(
    IN  PDISK_REGION Region,
    OUT PULONGLONG   HiddenSectors,
    OUT PULONGLONG   VolumeSectorCount
    )
{
    SpPtnGetSectorLayoutInformation(Region,
                            HiddenSectors,
                            VolumeSectorCount);
}


BOOLEAN
SpPtCreate(
    IN  ULONG         DiskNumber,
    IN  ULONGLONG     StartSector,
    IN  ULONGLONG     SizeMB,
    IN  BOOLEAN       InExtended,
    IN  PPARTITION_INFORMATION_EX PartInfo,
    OUT PDISK_REGION *ActualDiskRegion OPTIONAL
    )
{
    return SpPtnCreate(DiskNumber, 
                    StartSector,
                    0,              // SizeInSectors: Used only in ASR
                    SizeMB,
                    InExtended,
                    TRUE,          // AlignToCylinder
                    PartInfo,
                    ActualDiskRegion);
}

BOOLEAN
SpPtDelete(
    IN ULONG   DiskNumber,
    IN ULONGLONG  StartSector
    )
{
    return SpPtnDelete(DiskNumber, StartSector);
}

BOOL
SpPtIsSystemPartitionRecognizable(
    VOID
    )
{
    return SpPtnIsSystemPartitionRecognizable();
}


VOID
SpPtMakeRegionActive(
    IN PDISK_REGION Region
    )
{
    SpPtnMakeRegionActive(Region);
}


NTSTATUS
SpPtCommitChanges(
    IN  ULONG    DiskNumber,
    OUT PBOOLEAN AnyChanges
    )
{
    return SpPtnCommitChanges(DiskNumber, AnyChanges);
}

VOID
SpPtDeletePartitionsForRemoteBoot(
    PPARTITIONED_DISK PartDisk,
    PDISK_REGION StartRegion,
    PDISK_REGION EndRegion,
    BOOLEAN Extended
    )
{
    SpPtnDeletePartitionsForRemoteBoot(PartDisk,
                StartRegion,
                EndRegion,
                Extended);
}

VOID
SpPtLocateSystemPartitions(
    VOID
    )
{
    SpPtnLocateSystemPartitions();
}

#else

#ifdef GPT_PARTITION_ENGINE

//
// Switching stubs for GPT_PARTITION_ENGINE
//

NTSTATUS
SpPtPrepareDisks(
    IN  PVOID         SifHandle,
    OUT PDISK_REGION *InstallRegion,
    OUT PDISK_REGION *SystemPartitionRegion,
    IN  PWSTR         SetupSourceDevicePath,
    IN  PWSTR         DirectoryOnSetupSource,
    IN  BOOLEAN       RemoteBootRepartition
    )
{
    return SpPtnPrepareDisks(SifHandle,
                    InstallRegion,
                    SystemPartitionRegion,
                    SetupSourceDevicePath,
                    DirectoryOnSetupSource,
                    RemoteBootRepartition);
}

VOID
SpPtMakeRegionActive(
    IN PDISK_REGION Region
    )
{
    SpPtnMakeRegionActive(Region);
}

PDISK_REGION
SpPtValidSystemPartitionArc(
    IN PVOID SifHandle,
    IN PWSTR SetupSourceDevicePath,
    IN PWSTR DirectoryOnSetupSource
    )
{
    return SpPtnValidSystemPartitionArc(SifHandle,
                        SetupSourceDevicePath,
                        DirectoryOnSetupSource,
                        TRUE);
}

BOOL
SpPtIsSystemPartitionRecognizable(
    VOID
    )
{
    return SpPtnIsSystemPartitionRecognizable();
}

VOID
SpPtLocateSystemPartitions(
    VOID
    )
{
    SpPtnLocateSystemPartitions();
}

#endif

#endif // NEW_PARTITION_ENGINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spstring.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spstring.h

Abstract:

    Header file for functions to manipulate strings.
    These functions would ordinarily be performed by C Runtime routines
    except that we want to avoid linking this device driver with
    the kernel crt.

Author:

    Ted Miller (tedm) 15-Jan-1994

Revision History:

--*/


//
// Character types.
//
#define _SP_NONE      0x00
#define _SP_SPACE     0x01
#define _SP_DIGIT     0x02
#define _SP_XDIGIT    0x04
#define _SP_UPPER     0x08
#define _SP_LOWER     0x10

//
// Optimize the size of the types array by noting that no characters
// above 'z' have any attributes we care about.
//
#define CTSIZE ('z'+1)
extern UCHAR _SpCharTypes[CTSIZE];

//
// Be careful using these as they evaluate their arguments more than once.
//
#define SpIsSpace(c)    (((c) < CTSIZE) ? (_SpCharTypes[(c)] & _SP_SPACE)  : FALSE)
#define SpIsDigit(c)    (((c) < CTSIZE) ? (_SpCharTypes[(c)] & _SP_DIGIT)  : FALSE)
#define SpIsXDigit(c)   (((c) < CTSIZE) ? (_SpCharTypes[(c)] & _SP_XDIGIT) : FALSE)
#define SpIsUpper(c)    (((c) < CTSIZE) ? (_SpCharTypes[(c)] & _SP_UPPER)  : FALSE)
#define SpIsLower(c)    (((c) < CTSIZE) ? (_SpCharTypes[(c)] & _SP_LOWER)  : FALSE)
#define SpIsAlpha(c)    (SpIsUpper(c) || SpIsLower(c))
#define SpToUpper(c)    ((WCHAR)(SpIsLower(c) ? ((c)-(L'a'-L'A')) : (c)))
#define SpToLower(c)    ((WCHAR)(SpIsUpper(c) ? ((c)+(L'a'-L'A')) : (c)))

VOID
SpStringToUpper(
    IN PWSTR String
    );

VOID
SpStringToLower(
    IN PWSTR String
    );

PWCHAR
SpFindCharFromListInString(
    PWSTR String,
    PWSTR CharList
    );

unsigned
SpMultiByteStringToUnsigned(
    IN  PUCHAR  String,
    OUT PUCHAR *CharThatStoppedScan OPTIONAL
    );

LONG
SpStringToLong(
    IN  PWSTR     String,
    OUT PWCHAR   *EndOfValue,
    IN  unsigned  Radix
    );

PCHAR
SpConvertMultiSzWstrToStr(
    IN PWCHAR Source,
    IN ULONG Length
    );

PWCHAR
SpConvertMultiSzStrToWstr(
    IN PCHAR Source,
    IN ULONG Length
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spterm.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spterm.h

Abstract:

    Text setup support for terminals

Author:

    Sean Selitrennikoff (v-seans) 25-May-1999

Revision History:

--*/


extern BOOLEAN HeadlessTerminalConnected;
extern BOOLEAN SpTermDoUtf8;

//
// <CSI>K is the vt100 code to clear from cursor to end of line
//
#define HEADLESS_CLEAR_TO_EOL_STRING L"\033[K"

VOID 
SpTermInitialize(
    VOID
    );

VOID 
SpTermTerminate(
    VOID
    );

VOID 
SpTermDisplayStringOnTerminal(
    IN PWSTR String,
    IN UCHAR Attribute,
    IN ULONG X,                 // 0-based coordinates (character units)
    IN ULONG Y
    );

PWSTR
SpTermAttributeToTerminalEscapeString(
    IN UCHAR Attribute
    );
    
VOID
SpTermSendStringToTerminal(
    IN PWSTR String,
    IN BOOLEAN Raw
    );

ULONG
SpTermGetKeypress(
    VOID
    );

BOOLEAN
SpTermIsKeyWaiting(
    VOID
    );
    
VOID
SpTermDrain(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spsysprp.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spsysprp.h

Abstract:

    Public header file for setup of sys prep images

Author:

    Sean Selitrennikoff (v-seasel) 16-Jun-1998

Revision History:

--*/


#ifndef _SPSYSPREP_DEFN_
#define _SPSYSPREP_DEFN_

#include <remboot.h>
#include <oscpkt.h>

extern NET_CARD_INFO RemoteSysPrepNetCardInfo;

typedef struct _MIRROR_VOLUME_INFO_MEMORY {
    WCHAR   DriveLetter;
    UCHAR   PartitionType;
    BOOLEAN PartitionActive;
    BOOLEAN IsBootDisk;
    BOOLEAN CompressedVolume;
    ULONG   DiskNumber;
    ULONG   PartitionNumber;
    ULONG   DiskSignature;
    ULONG   BlockSize;
    ULONG   LastUSNMirrored;
    ULONG   FileSystemFlags;
    WCHAR   FileSystemName[16];
    PWCHAR  VolumeLabel;
    PWCHAR  OriginalArcName;
    LARGE_INTEGER DiskSpaceUsed;
    LARGE_INTEGER StartingOffset;
    LARGE_INTEGER PartitionSize;
    PDISK_REGION CreatedRegion;
} MIRROR_VOLUME_INFO_MEMORY, *PMIRROR_VOLUME_INFO_MEMORY;

typedef struct _MIRROR_CFG_INFO_MEMORY {
    ULONG   NumberVolumes;
    MIRROR_VOLUME_INFO_MEMORY Volumes[1];
} MIRROR_CFG_INFO_MEMORY, *PMIRROR_CFG_INFO_MEMORY;

extern PUCHAR RemoteIMirrorFilePath;

VOID
SpInstallSysPrepImage(
    IN HANDLE SetupSifHandle,
    IN HANDLE WinntSifHandle,
    IN PMIRROR_CFG_INFO_FILE pFileData,
    IN PMIRROR_CFG_INFO_MEMORY pMemoryData
    );

NTSTATUS
SpFixupThirdPartyComponents(
    IN PVOID        SifHandle,
    IN PWSTR        ThirdPartySourceDevicePath,
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR        Sysroot,
    IN PDISK_REGION SystemPartitionRegion,
    IN PWSTR        SystemPartitionDirectory
    );

BOOLEAN
SpReadIMirrorFile(
    OUT PMIRROR_CFG_INFO_FILE *ppFileData,
    IN PCHAR pszIMirrorFilePath
    );

BOOLEAN
SpFindMirrorDataFile(
    IN  PCWSTR SrcPath,
    IN  PFILE_BOTH_DIR_INFORMATION  FileInfo,
    OUT PULONG ReturnData,
    IN  PVOID *ppFileData
    );

BOOLEAN
SpDetermineDiskLayout(
    IN PMIRROR_CFG_INFO_FILE pFileData,
    OUT PMIRROR_CFG_INFO_MEMORY *pMemoryData
    );

BOOLEAN
SpFixupLocalDisks(
    IN HANDLE SifHandle,
    OUT PDISK_REGION *InstallRegion,
    OUT PDISK_REGION *SystemPartitionRegion,
    IN PWSTR SetupSourceDevicePath,
    IN PWSTR DirectoryOnSetupSource,
    IN PMIRROR_CFG_INFO_MEMORY pMemoryData,
    IN BOOLEAN UseWholeDisk
    );

BOOLEAN
SpCopyMirrorDisk(
    PMIRROR_CFG_INFO_FILE pFileData,
    ULONG cDisk
    );

NTSTATUS
SpPatchSysPrepImage(
    IN HANDLE SetupSifHandle,
    IN HANDLE WinntSifHandle,
    IN PMIRROR_CFG_INFO_FILE pFileData,
    IN PMIRROR_CFG_INFO_MEMORY pMemoryData
    );

NTSTATUS
SpPatchBootIni(
    IN PWCHAR BootIniPath,
    IN PMIRROR_CFG_INFO_MEMORY pMemoryData
    );

NTSTATUS
SpCopyNicFiles(
    IN PWCHAR SetupPath,
    IN PWCHAR DestPath
    );

NTSTATUS
SpSysPrepNicRcvFunc(
    PVOID DataBuffer,
    ULONG DataBufferLength
    );

VOID
SpSysPrepFailure(
    ULONG ReasonNumber,
    PVOID Parameter1,
    PVOID Parameter2
    );

NTSTATUS
SpSysPrepSetExtendedInfo (
    PWCHAR Source,
    PWCHAR Dest,
    BOOLEAN Directory,
    BOOLEAN RootDir
    );

NTSTATUS
SpCopyEAsAndStreams (
    PWCHAR SourceFile,
    HANDLE SourceHandle,
    PWCHAR TargetFile,
    HANDLE TargetHandle,
    BOOLEAN Directory
    );

#endif // ndef _SPSYSPREP_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\sptarget.c ===
#include "spprecmp.h"
#pragma hdrstop

#define MAX_NT_DIR_LEN 50



/*++
Revision History:

--*/

VOID
SpCheckDirectoryForNt(
    IN  PDISK_REGION Region,
    IN  PWSTR        Directory,
    OUT PBOOLEAN     ReselectDirectory,
    OUT PBOOLEAN     NtInDirectory
    );

VOID
pSpDrawGetNtPathScreen(
    OUT PULONG EditFieldY
    );

ValidationValue
SpGetPathKeyCallback(
    IN ULONG Key
    );

BOOLEAN
SpIsValid8Dot3(
    IN PWSTR Path
    );

BOOLEAN
pSpConsecutiveBackslashes(
    IN PWSTR Path
    );

VOID
SpNtfsNameFilter(
    IN OUT PWSTR Path
    );

BOOLEAN
SpGetUnattendedPath(
    IN  PDISK_REGION Region,
    IN  PWSTR        DefaultPath,
    OUT PWSTR        TargetPath
    );

BOOLEAN
SpGenerateNTPathName(
    IN  PDISK_REGION Region,
    IN  PWSTR        DefaultPath,
    OUT PWSTR        TargetPath
    );

//
// From spcopy.c.
//

BOOLEAN
SpDelEnumFileAndDirectory(
    IN  PCWSTR                     DirName,
    IN  PFILE_BOTH_DIR_INFORMATION FileInfo,
    OUT PULONG                     ret,
    IN  PVOID                      Pointer
    );

extern PVOID FileDeleteGauge;

BOOLEAN
SpGetTargetPath(
    IN  PVOID            SifHandle,
    IN  PDISK_REGION     Region,
    IN  PWSTR            DefaultPath,
    OUT PWSTR           *TargetPath
    )
//
//  Return value - True  - indicates that the path has to be wiped out
//                 False - the path doesn't already exist
//
{
    ULONG EditFieldY;
    WCHAR NtDir[MAX_NT_DIR_LEN+2];
    BOOLEAN BadDirectory = FALSE;
    BOOLEAN NtAlreadyPresent;
    BOOLEAN GotUnattendedPath = FALSE;
    BOOLEAN WipeDir = FALSE;

    NtDir[0] = 0;

    //
    // If this is an ASR recovery session, just get the target path from
    // the dr_state.sif file and return.
    //

    if( SpDrEnabled() && ! RepairWinnt ) {
        PWSTR TargetPathFromDrState;

        TargetPathFromDrState = SpDrGetNtDirectory();
        *TargetPath = SpDupStringW(TargetPathFromDrState);
        ASSERT(*TargetPath);

        NTUpgrade = DontUpgrade;
        return(FALSE);
    }

    //
    // If this is unattended operation, fetch the path from the
    // unattended script.  The path we get there might have
    // indicate that we should generate a pathname.  This allows
    // installation into a path that is guaranteed to be unique.
    // (in case the user already has nt on the machine, etc).
    //

    if(UnattendedOperation) {
        GotUnattendedPath = SpGetUnattendedPath(Region,DefaultPath,NtDir);
    } else {
        if (PreferredInstallDir) {
            GotUnattendedPath = TRUE;
            wcscpy( NtDir, PreferredInstallDir );
        } else {
            GotUnattendedPath = TRUE;
            wcscpy( NtDir, DefaultPath );
        }
    }

    if (!GotUnattendedPath) {
        BadDirectory = TRUE;
    }

    do {
        if (BadDirectory) {
            //
            // we do not have a good path so ask the user
            //
            ASSERT(wcslen(DefaultPath) < MAX_NT_DIR_LEN);
            ASSERT(*DefaultPath == L'\\');

            wcsncpy(NtDir,DefaultPath,MAX_NT_DIR_LEN);

            NtDir[MAX_NT_DIR_LEN] = 0;

            pSpDrawGetNtPathScreen(&EditFieldY);

            SpGetInput(
                SpGetPathKeyCallback,
                6,                        // left edge of the edit field
                EditFieldY,
                MAX_NT_DIR_LEN,
                NtDir,
                FALSE,                  // escape clears edit field
                0                       // don't cover up the typed input
                );
        }

        //
        // If the user didn't start with a backslash, put one in there
        // for him.
        //
        if(NtDir[0] != L'\\') {
            RtlMoveMemory(NtDir+1,NtDir,MAX_NT_DIR_LEN+1);
            NtDir[0] = L'\\';
        }

        //
        // Assume the directory is OK and not already present.
        //
        BadDirectory = FALSE;
        NtAlreadyPresent = FALSE;

        //
        // Force 8.3 because otherwise WOW won't run.
        // This checks also nabs "" and "\" and disallows them.
        //
        if(!SpIsValid8Dot3(NtDir)) {
            BadDirectory = TRUE;
        } else {

            //
            // Perform a filtering operation that coalesces
            // consecutive dots, etc.
            //
            SpNtfsNameFilter(NtDir);

            //
            // If the name has consecutive backslashes, disallow it.
            //
            if(pSpConsecutiveBackslashes(NtDir)) {
                BadDirectory = TRUE;
            }
        }

        //
        // If we have a bad directory, tell the user.
        //
        if(BadDirectory) {

            SpDisplayScreen(SP_SCRN_INVALID_NTPATH,3,HEADER_HEIGHT+1);

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_ENTER_EQUALS_CONTINUE,
                0
                );

            SpInputDrain();
            while(SpInputGetKeypress() != ASCI_CR) ;
        } else {
            //
            // The directory is good.  Check to see if Windows NT is
            // already in there.  If it is, then the user will have
            // the option of reselecting a path or overwriting the
            // existing installation.  This is brute force.  Next
            // time look for an opportunity to be more elegant.
            //
            if(!SpDrEnabled()) {
                SpCheckDirectoryForNt(Region,NtDir,&BadDirectory,&NtAlreadyPresent);
            } else {
                BadDirectory = FALSE;
            }


            //
            // If the directory is OK and we didn't find Windows NT in it,
            // then see if the directory is the Windows directory and whether
            // the user wants to install into this.  If we found Windows NT
            // in this directory, no user input is needed.  We just need to
            // find out if this also contains a Windows installation.
            //
            if(!BadDirectory && NtAlreadyPresent)
                WipeDir = TRUE;


        }

    } while(BadDirectory);

    //
    // Remove trailing backslash.  Only have to worry about one
    // because if there were two, pSpConsecutiveBackslashes() would
    // have caught this earlier and we'd never have gotten here.
    //

    if(NtDir[wcslen(NtDir)-1] == L'\\') {
        NtDir[wcslen(NtDir)-1] = 0;
    }

    //
    // Make a duplicate of the directory name.
    //

    *TargetPath = SpDupStringW(NtDir);

    ASSERT(*TargetPath);

    return( WipeDir );
}



BOOLEAN
SpGenerateNTPathName(
    IN  PDISK_REGION Region,
    IN  PWSTR        DefaultPath,
    OUT PWSTR        TargetPath
    )

/*++

Routine Description:

    Using the default path as a starting point,
    this routine generates a unique path name
    to install nt into.

Arguments:

    Region - supplies region to which nt is being installed.

    DefaultPath - supplies the default path for the installation.
        The path to install to will be based on this name.

    TargetPath - receives the path to install to if the return value is TRUE.
        This buffer must be large enough to hold MAX_NT_DIR_LEN+2 wchars.

Return Value:

    TRUE if the path we return is valid and should be used as
    the target path.  FALSE otherwise.

--*/

{
    PWCHAR p;
    unsigned i;
    WCHAR num[5];


    //
    // Init TargetPath and remember where he ends.
    //
    wcscpy( TargetPath, DefaultPath );
    num[0] = L'.';

    p = TargetPath + wcslen( TargetPath );

    //
    // Form the region's nt pathname.
    //
    SpNtNameFromRegion(
        Region,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    //
    // Using extensions with numerical values 0-999, attempt to locate
    // a nonexistent directory name.
    //
    for(i=0; i<999; i++) {

        //
        // See whether a directory or file exists.  If not, we found our path.
        //
        if( (!SpNFilesExist(TemporaryBuffer,&TargetPath,1,TRUE )) &&
            (!SpNFilesExist(TemporaryBuffer,&TargetPath,1,FALSE)) ) {
            return(TRUE);
        }

        swprintf(&num[1],L"%u",i);
        wcscpy(p,num);
    }

    //
    // Couldn't find a pathname that doesn't exist.
    //
    return FALSE;
}


BOOLEAN
SpGetUnattendedPath(
    IN  PDISK_REGION Region,
    IN  PWSTR        DefaultPath,
    OUT PWSTR        TargetPath
    )

/*++

Routine Description:

    In an unattended installation, look in the unattended script
    to determine the target path.  The target path can either be fully
    specified or can be * which will cause is to generate
    a unique pathname.  This is useful to ensure that nt gets installed
    into a unique directory when other installations may be present
    on the same machine.

    Call this routine only if this is unattended mode setup.

Arguments:

    Region - supplies region to which nt is being installed.

    DefaultPath - supplies the default path for the installation.
        The path to install to will be based on this name.

    TargetPath - receives the path to install to if the return value is TRUE.
        This buffer must be large enough to hold MAX_NT_DIR_LEN+2 wchars.

Return Value:

    TRUE if the path we return is valid and should be used as
    the target path.  FALSE otherwise.

--*/

{
    PWSTR PathSpec;


    ASSERT(UnattendedOperation);
    if(!UnattendedOperation) {
        return(FALSE);
    }

    PathSpec = SpGetSectionKeyIndex(UnattendedSifHandle,SIF_UNATTENDED,L"TargetPath",0);
    if(!PathSpec) {
         //
        // Default to *.
        //
        PathSpec = L"*";
    }

    //
    // if it's not "*" then it's an absolute path -- just return it.
    //
    if(wcscmp(PathSpec,L"*")) {
        wcsncpy(TargetPath,PathSpec,MAX_NT_DIR_LEN);
        TargetPath[MAX_NT_DIR_LEN] = 0;
        return(TRUE);
    }

    return SpGenerateNTPathName( Region, DefaultPath, TargetPath );
}


VOID
SpCheckDirectoryForNt(
    IN  PDISK_REGION Region,
    IN  PWSTR        Directory,
    OUT PBOOLEAN     ReselectDirectory,
    OUT PBOOLEAN     NtInDirectory
    )

/*++

Routine Description:

    Check a directory for the presence of Windows NT.  If Windows NT
    is in there, then inform the user that if he continues, his existing
    configuration will be overwritten.

Arguments:

    Region - supplies region descriptor for partition to check for nt.

    Directory - supplies name of directory on the partition ro check for nt.

    ReselectDirectory - receives boolean value indicating whether the caller
        should ask the user to select a different directory.

    NtInDirectory - receives a boolean value indicating whether we found
        windows nt in the given directory.

Return Value:

    None.

--*/

{
    ULONG ValidKeys[3] = { KEY_F3,ASCI_ESC,0 };
    ULONG Mnemonics[2] = { MnemonicDeletePartition2, 0 };

    //
    // Assume the directory is ok as-is and so the user does not have to
    // select a different one.
    //
    *ReselectDirectory = FALSE;
    *NtInDirectory = FALSE;

    //
    // Check for Windows NT in the directory.
    // If it's in there, then ask the user whether he wants to
    // overwrite it.
    //

    SpNtNameFromRegion(
        Region,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    if( (!SpNFilesExist(TemporaryBuffer,&Directory,1,TRUE )) &&
            (!SpNFilesExist(TemporaryBuffer,&Directory,1,FALSE)) ) {
        return;
    }
    else{


        *NtInDirectory = TRUE;

        while(1) {
            SpStartScreen( SP_SCRN_NTPATH_EXISTS,
                           3,
                           HEADER_HEIGHT+1,
                           FALSE,
                           FALSE,
                           DEFAULT_ATTRIBUTE,
                           Directory );

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_L_EQUALS_DELETE,
                SP_STAT_ESC_EQUALS_NEW_PATH,
                SP_STAT_F3_EQUALS_EXIT,
                0
                );

            switch(SpWaitValidKey(ValidKeys,NULL,Mnemonics)) {

            case KEY_F3:
                SpConfirmExit();
                break;

            case ASCI_ESC:
                //
                // Reselect path.
                //
                *ReselectDirectory = TRUE;
                // fall through
            default:
                //
                // Path is ok, just return.
                //
                return;
            }
        }
    }
}

ValidationValue
SpGetPathKeyCallback(
    IN ULONG Key
    )
{
    ULONG u;

    switch(Key) {

    case KEY_F3:
        SpConfirmExit();
        pSpDrawGetNtPathScreen(&u);
        return(ValidateRepaint);

    default:

        //
        // Ignore special keys and illegal characters.
        // Use the set of illegal FAT characters.
        // Disallow 127 because there is no ANSI equivalent
        // and so the name can't be displayed by Windows.
        // Disallow space because DOS can't handle it.
        // Disallow oem characters because we have problems
        // booting if they are used.
        //
        if((Key & KEY_NON_CHARACTER)
        || wcschr(L" \"*+,/:;<=>?[]|!#$&@^'`{}()%~",(WCHAR)Key)
        || (Key >= 127) || (Key < 32))
        {
            return(ValidateReject);
        }
        break;
    }

    return(ValidateAccept);
}

VOID
pSpDrawGetNtPathScreen(
    OUT PULONG EditFieldY
    )
{
    SpDisplayScreen(SP_SCRN_GETPATH_1,3,HEADER_HEIGHT+1);
    *EditFieldY = NextMessageTopLine + 1;
    SpContinueScreen(SP_SCRN_GETPATH_2,3,4,FALSE,DEFAULT_ATTRIBUTE);

    SpDisplayStatusOptions(
        DEFAULT_STATUS_ATTRIBUTE,
        SP_STAT_ENTER_EQUALS_CONTINUE,
        SP_STAT_F3_EQUALS_EXIT,
        0
        );
}


BOOLEAN
SpIsValid8Dot3(
    IN PWSTR Path
    )

/*++

Routine Description:

    Check whether a path is valid 8.3.  The path may or may not start with
    a backslash.  Only backslashes are recognized as path separators.
    Individual characters are not checked for validity (ie, * would not
    invalidate the path).  The path may or may not terminate with a backslash.
    A component may have a dot without characters in the extension
    (ie, a\b.\c is valid).

    \ and "" are explicitly disallowed even though they fit the rules.

Arguments:

    Path - pointer to path to check.

Return Value:

    TRUE if valid 8.3, FALSE otherwise.

--*/

{
    unsigned Count;
    BOOLEAN DotSeen,FirstChar;

    if((*Path == 0) || ((Path[0] == L'\\') && (Path[1] == 0))) {
        return(FALSE);
    }

    DotSeen = FALSE;
    FirstChar = TRUE;
    Count = 0;

    while(*Path) {

        //
        // Path points to start of current component (1 past the slash)
        //

        switch(*Path) {

        case L'.':
            if(FirstChar) {
                return(FALSE);
            }
            if(DotSeen) {
                return(FALSE);
            }

            Count = 0;
            DotSeen = TRUE;
            break;

        case L'\\':

            DotSeen = FALSE;
            FirstChar = TRUE;
            Count = 0;

            if(*(++Path) == '\\') {

                // 2 slashes in a row
                return(FALSE);
            }

            continue;

        default:

            Count++;
            FirstChar = FALSE;

            if((Count == 4) && DotSeen) {
                return(FALSE);
            }

            if(Count == 9) {
                return(FALSE);
            }

            //
            // This routine is called also in case of attended install as 
            // no harm in validating twice. 
            //
            if (ValidateAccept != SpGetPathKeyCallback(*Path)){
            	return(FALSE);	    
            }
         }
        Path++;
    }

    return(TRUE);
}


BOOLEAN
pSpConsecutiveBackslashes(
    IN PWSTR Path
    )
{
    int x = wcslen(Path);
    int i;

    for(i=0; i<x-1; i++) {

        if((Path[i] == L'\\') && (Path[i+1] == L'\\')) {

            return(TRUE);
        }
    }

    return(FALSE);
}

VOID
SpNtfsNameFilter(
    IN OUT PWSTR Path
    )

/*++

Routine Description:

    Strip trailing .' within a path component.  This also strips tailing
    .'s from the entire path itself.  Also condense other consecutive .'s
    into a single ..

    Example: \...\..a...b.  ==> \\.a.b

Arguments:

    Path - On input, supplies the path to be filtered.  On output, contains
        the filtered pathname.

Return Value:

    None.

--*/

{
    PWSTR TempPath = SpDupStringW(Path);
    PWSTR p,q;
    BOOLEAN Dot;

    if (TempPath) {
        //
        // Coalesce adjacent dots and strip trailing dots within a component.
        // xfers Path ==> TempPath
        //

        for(Dot=FALSE,p=Path,q=TempPath; *p; p++) {

            if(*p == L'.') {

                Dot = TRUE;

            } else  {

                if(Dot && (*p != L'\\')) {
                    *q++ = L'.';
                }
                Dot = FALSE;
                *q++ = *p;
            }
        }
        *q = 0;

        wcscpy(Path,TempPath);
    }        
}

ULONG
SpGetMaxNtDirLen( VOID )
{
        return( MAX_NT_DIR_LEN );
}

VOID
SpDeleteExistingTargetDir(
    IN  PDISK_REGION     Region,
    IN  PWSTR            NtDir,
    IN  BOOLEAN          GaugeNeeded,
    IN  DWORD            MsgId
    )
/*

    Parameters :
    
        Region  - Pointer to Region structure associated with the partition that contains the OS
        NtDir   - The directory to recursively delete
        GaugeNeeded - Should we display a gauge while deleting the dir ?
        MsgId   - Use this if you want to display a title message

*/

{
    ENUMFILESRESULT Result;
    PWSTR FullNtPath;
    NTSTATUS Status, Stat;
    PULONG RecursiveOperation;

    if( MsgId )
        SpDisplayScreen(MsgId, 3, 4 );

    SpNtNameFromRegion(
        Region,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    SpConcatenatePaths( TemporaryBuffer, NtDir );

    FullNtPath = SpDupStringW(TemporaryBuffer);


    // First try and delete the install directory
    // This is to see if itself is a reparse point. Also if it is just an empty dir
    // then we save time.

    Stat = SpDeleteFileEx( FullNtPath,
                        NULL,
                        NULL,
                        FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT );


    if(NT_SUCCESS(Stat)){
        SpMemFree( FullNtPath);
        return;  // We are done
    }



    RecursiveOperation = SpMemAlloc(sizeof(ULONG));
    ASSERT( RecursiveOperation );

    //
    // Do the counting phase for the clean-up
    //

    *RecursiveOperation = SP_COUNT_FILESTODELETE;

    SpDisplayStatusText(SP_STAT_SETUP_IS_EXAMINING_DIRS,DEFAULT_STATUS_ATTRIBUTE);

    Result = SpEnumFilesRecursiveDel(
        FullNtPath,
        SpDelEnumFileAndDirectory,
        &Status,
        RecursiveOperation);

    //
    // Now do the cleanup (actual deleting)
    //

    FileDeleteGauge = NULL;
    if( GaugeNeeded ){
        SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_TEXT_SETUP_IS_DELETING);
        FileDeleteGauge = SpCreateAndDisplayGauge(*RecursiveOperation,0,15,TemporaryBuffer,NULL,GF_PERCENTAGE,0);
        ASSERT(FileDeleteGauge);
    }

    *RecursiveOperation = SP_DELETE_FILESTODELETE;

    Result = SpEnumFilesRecursiveDel(
        FullNtPath,
        SpDelEnumFileAndDirectory,
        &Status,
        RecursiveOperation);

    //Delete the main parent as the recursive call only cleans out everythin below it

    Stat = SpDeleteFileEx( FullNtPath,
                        NULL,
                        NULL,
                        FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT );

    if(!NT_SUCCESS(Stat) && (Stat != STATUS_OBJECT_NAME_NOT_FOUND)) {
         KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Dir Not Deleted - Status - %ws (%lx)\n", (PWSTR)FullNtPath, Stat));
    }

    if (GaugeNeeded) {
        SpDestroyGauge(FileDeleteGauge);
        FileDeleteGauge = NULL;
    }
    

    SpMemFree( FullNtPath );
    SpMemFree( RecursiveOperation );

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spsysprp.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spsetup.c

Abstract:

    Module for supporing installation of SysPrep images from a remote share

Author:

    Sean Selitrennikoff (v-seasel) 6-10-1998

--*/

#include "spprecmp.h"
#pragma hdrstop
#include "spcmdcon.h"
#include <remboot.h>
#include <oscpkt.h>
#include <regstr.h>

NET_CARD_INFO RemoteSysPrepNetCardInfo;
PVOID pGlobalResponsePacket = NULL;
ULONG GlobalResponsePacketLength = 0;

#define SYSPREP_PARTITION_SLOP 10       // in percent

VOID
SpInstallSysPrepImage(
    IN HANDLE SetupSifHandle,
    IN HANDLE WinntSifHandle,
    IN PMIRROR_CFG_INFO_FILE pFileData,
    IN PMIRROR_CFG_INFO_MEMORY pMemoryData
    )

/*++

Routine Description:

    Main routine for installing a SysPrep images from a remote share.

Arguments:

    WinntSifHandle - Handle to the SIF file.

    pFileData - The IMirror.dat data, as saved in the file.

    pMemoryData - The IMirror.dat data, as modified to match this computer.

Return Value:

    None.  Doesn't return on fatal failure.

--*/

{
    DWORD cDisk;
    NTSTATUS Status;

    //
    // Right here we should check to see if any patching is going to be needed
    // by opening the hive files on the server and checking with the passed in
    // PCI ids.  If patching is necessary, and the SIF file contains a pointer
    // to a CD image that matches the SysPrep image, then we call off to BINL
    // to find the appropriate drivers.  If BINL does not return an error, then
    // we assume that later we will be able to do the patch (after the file copy
    // below).
    //
    // If it looks like the patch will fail, either because there is no pointer
    // to a CD image, or BINL returned an error, then we present the user with
    // a screen telling them that any hardware differences between their machine
    // and the SysPrep image may result in an unbootable system.  They may choose
    // to continue the setup, or quit.
    //
    // NOTE: seanse - Put all of the above here.

    //
    // For each disk, copy all the files to the local store.
    //
    for (cDisk = 0; cDisk < pFileData->NumberVolumes; cDisk++) {
        if (!SpCopyMirrorDisk(pFileData, cDisk)) {
            goto CleanUp;
        }
    }

    //
    // Patch up the SysPrep image.
    //
    Status = SpPatchSysPrepImage(   SetupSifHandle,
                                    WinntSifHandle,
                                    pFileData,
                                    pMemoryData);

    if (!NT_SUCCESS(Status)) {

        ULONG ValidKeys[2] = { KEY_F3, 0 };
        ULONG Mnemonics[2] = { MnemonicContinueSetup,0 };

        while (1) {

            if (Status == STATUS_INVALID_PARAMETER) {

                SpStartScreen(
                    SP_SCRN_SYSPREP_PATCH_MISSING_OS,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE
                    );

            } else {

                SpStartScreen(
                    SP_SCRN_SYSPREP_PATCH_FAILURE,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE
                    );
            }

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_C_EQUALS_CONTINUE_SETUP,
                SP_STAT_F3_EQUALS_EXIT,
                0
                );

            switch(SpWaitValidKey(ValidKeys,NULL,Mnemonics)) {
            case KEY_F3:
                SpConfirmExit();
                break;
            default:
                //
                // must be c=continue
                //
                goto CleanUp;
            }

        }

    }

CleanUp:

    return;

}

NTSTATUS
SpFixupThirdPartyComponents(
    IN PVOID        SifHandle,
    IN PWSTR        ThirdPartySourceDevicePath,
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR        Sysroot,
    IN PDISK_REGION SystemPartitionRegion,
    IN PWSTR        SystemPartitionDirectory
    )

/*++

Routine Description:

    This routine will take care of installing any 3rd party drivers detected during setupldr.
    We have to take care of this here because the normal code path for textmode setup has
    been bypassed in lieu of installing a sysprep'd image.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    ThirdPartySourceDevicePath - path to 3rd party install files.

    NtPartitionRegion - region where installation is located.

    Sysroot - string containing %windir% (with no drive).

    SystemPartitionRegion - region where system partition is located.

    SystemPartitionDirectory - directory on the system partition where
                               system-specific files are located (should
                               be NULL for non-ARC machines)

Return Value:

    NTSTATUS which will indicate success or failure.

--*/

{
NTSTATUS        Status = STATUS_SUCCESS;
PWSTR           NtPartition = NULL,
                SystemPartition = NULL;
PDISK_FILE_LIST DiskFileLists;
ULONG           DiskCount;
HANDLE          hKeyControlSetServices;
UNICODE_STRING  UnicodeString1;
UNICODE_STRING  UnicodeString2;
UNICODE_STRING  UnicodeString;
WCHAR           Path[MAX_PATH];
HANDLE          DstHandle = NULL;
DWORD           Size, Number;
PVOID           Buffer = NULL;
OBJECT_ATTRIBUTES Obj;
OBJECT_ATTRIBUTES DstObj;

    //
    // See if there's anything for us to do.
    //
    if( PreinstallScsiHardware == NULL ) {
        return STATUS_SUCCESS;
    }


    //
    // =================
    // Install the files.
    // =================
    //

    //
    // Get the device path of the nt partition.
    //
    SpNtNameFromRegion( NtPartitionRegion,
                        TemporaryBuffer,
                        sizeof(TemporaryBuffer),
                        PartitionOrdinalCurrent );
    NtPartition = SpDupStringW(TemporaryBuffer);

    //
    // Get the device path of the system partition.
    //
    if (SystemPartitionRegion != NULL) {
        SpNtNameFromRegion( SystemPartitionRegion,
                            TemporaryBuffer,
                            sizeof(TemporaryBuffer),
                            PartitionOrdinalCurrent );
        SystemPartition = SpDupStringW(TemporaryBuffer);
    } else {
        SystemPartition = NULL;
    }

    //
    // Generate media descriptors for the source media.
    //
    SpInitializeFileLists( SifHandle,
                           &DiskFileLists,
                           &DiskCount );

    SpCopyThirdPartyDrivers( ThirdPartySourceDevicePath,
                             NtPartition, 
                             Sysroot,
                             SystemPartition,
                             SystemPartitionDirectory,
                             DiskFileLists,
                             DiskCount );


    //
    // =================
    // Set the registry.
    // =================
    //

    //
    // We need to open the hive of the target install, not
    // our own.  Get a path to the system hive.
    //
    wcscpy(Path, NtPartition);
    SpConcatenatePaths(Path, Sysroot);
    SpConcatenatePaths(Path, L"system32\\config\\system");

    //
    // Load him up.
    //
    INIT_OBJA(&Obj, &UnicodeString2, Path);
    INIT_OBJA(&DstObj, &UnicodeString1, L"\\Registry\\SysPrepReg");

    Status = ZwLoadKey(&DstObj, &Obj);

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpFixupThirdPartyComponents: ZwLoadKey to SysPrepReg failed %lx\n", Status));
        goto CleanUp0;
    }


    //
    // Now get path to services key in the SysPrep image
    //
    wcscpy(Path, L"\\Registry\\SysPrepReg");
    INIT_OBJA(&Obj, &UnicodeString2, Path);
    Status = ZwOpenKey(&DstHandle, KEY_READ, &Obj);

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpFixupThirdPartyComponents: ZwOpenKey of root SysPrepReg failed %lx\n", Status));
        goto CleanUp1;
    }

    //
    // Allocate a temporary buffer, then figure out which is the current control set.
    //
    Buffer = SpMemAlloc(1024 * 4);
    if( Buffer == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto CleanUp1;
    }

    Status = SpGetValueKey( DstHandle,
                            L"Select",
                            L"Current",
                            1024 * 4,
                            Buffer,
                            &Size );

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpFixupThirdPartyComponents: SpGetValueKey of Select\\Current failed %lx\n", Status));
        goto CleanUp1;
    }

    if ( (ULONG)(((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Type) != REG_DWORD ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpFixupThirdPartyComponents: SpGetValueKey of Select\\Current didn't return a REG_DWORD.\n"));
        goto CleanUp1;
    }

    Number = *((DWORD *)(((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data));

    ZwClose(DstHandle);
    DstHandle = NULL;



    //
    // We're ready to actually open CCS\Services key.
    //
    swprintf(Path,
             L"\\Registry\\SysPrepReg\\ControlSet%03d\\Services",
             Number
            );
    INIT_OBJA(&Obj, &UnicodeString, Path);
    Status = ZwOpenKey(&DstHandle, KEY_ALL_ACCESS, &Obj);

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpFixupThirdPartyComponents: ZwOpenKey of SysPrepReg services failed %lx for %ws\n", Status,Path));
        goto CleanUp1;
    }

    //
    // Do it.
    //
    Status = SpThirdPartyRegistry(DstHandle);

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpFixupThirdPartyComponents: SpThirdPartyRegistry failed %lx\n", Status));
        goto CleanUp1;
    }


CleanUp1:
    ZwUnloadKey(&DstObj);

    if( Buffer ) {
        SpMemFree( Buffer );
    }

    if( DstHandle ) {
        ZwClose(DstHandle);
    }

CleanUp0:
    if( NtPartition ) {
        SpMemFree( NtPartition );
    }

    if( SystemPartition ) {
        SpMemFree( SystemPartition );
    }




    return Status;

}

BOOLEAN
SpReadIMirrorFile(
    OUT PMIRROR_CFG_INFO_FILE *ppFileData,
    IN PCHAR IMirrorFilePath
    )

/*++

Routine Description:

    This routine opens the file in IMirrorFilePath, allocates a buffer, copies the data
    into the buffer and returns the buffer.  This buffer needs to be freed later.

Arguments:

    ppFileData - If TRUE is returned, a pointer to an in-memory copy of the file.

    IMirrorFilePath - The UNC to the root directory containing all the IMirrorX directories.

Return Value:

    TRUE if successful, else it generates a fatal error.

--*/

{
    WCHAR wszRootDir[MAX_PATH];
    ULONG ulReturnData;

    mbstowcs(wszRootDir, IMirrorFilePath, strlen(IMirrorFilePath) + 1);

    *ppFileData = NULL;

    //
    // Enumerate thru all the files in the base directory looking for the IMirror data file.
    // If it is found, the callback function fills in pFileData.
    //
    if ((SpEnumFiles(wszRootDir, SpFindMirrorDataFile, &ulReturnData, (PVOID)ppFileData) == EnumFileError) ||
        (*ppFileData == NULL)) {

        SpSysPrepFailure( SP_SYSPREP_NO_MIRROR_FILE, wszRootDir, NULL );

        // shouldn't get here.
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
SpFindMirrorDataFile(
    IN  PCWSTR SrcPath,
    IN  PFILE_BOTH_DIR_INFORMATION  FileInfo,
    OUT PULONG ReturnData,
    IN  PVOID *ppFileData
    )

/*++

Routine Description:

    This routine is called by the file enumerator as a callback for
    each file or subdirectory found in the source directory.
    If FileInfo represents a file, then we skip it.
    If FileInfo represents a directory, then we search it for the IMirror data file.

Arguments:

    SrcPath - Absolute path to the source directory. This path should contain
              the path to the source device.

    FileInfo - supplies find data for a file in the source dir.

    ReturnData - receives an error code if an error occurs.

    ppFileData - If successful in finding the IMirror data file, this is a buffer which is
    a copy of the file.

Return Value:

    FALSE if we find the IMirror data file, else TRUE. (return value is used to continue
    the enumeration or not)

--*/

{
    PWSTR Temp1;
    PWSTR Temp2;
    ULONG ulLen;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;

    if(!(FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
        return TRUE;
    }

    Handle = NULL;

    //
    // Build the path name to the IMirror data file
    //
    Temp1 = TemporaryBuffer + (sizeof(TemporaryBuffer) / sizeof(WCHAR) / 2);
    ulLen = FileInfo->FileNameLength/sizeof(WCHAR);

    wcsncpy(Temp1,FileInfo->FileName, ulLen);
    Temp1[ulLen] = 0;

    wcscpy(TemporaryBuffer, SrcPath);
    SpConcatenatePaths(TemporaryBuffer, Temp1);
    SpConcatenatePaths(TemporaryBuffer, IMIRROR_DAT_FILE_NAME);
    Temp2 = SpDupStringW(TemporaryBuffer);

    INIT_OBJA(&Obja, &UnicodeString, Temp2);

    Status = ZwCreateFile(&Handle,
                          FILE_GENERIC_READ,
                          &Obja,
                          &IoStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ,
                          FILE_OPEN,
                          FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0
                         );

    SpMemFree(Temp2);

    if(!NT_SUCCESS(Status)) {
        return TRUE;
    }

    Status = SpGetFileSize(Handle, &ulLen);

    if(!NT_SUCCESS(Status)) {
        ZwClose(Handle);
        return TRUE;
    }

    //
    // Now allocate memory and read in the file.
    //
    *ppFileData = SpMemAlloc(ulLen);

    Status = ZwReadFile(Handle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        *ppFileData,
                        ulLen,
                        0,
                        NULL
                        );

    if(!NT_SUCCESS(Status)) {
        SpMemFree(*ppFileData);
        *ppFileData = NULL;
        ZwClose(Handle);
        return TRUE;
    }

    ZwClose(Handle);
    return FALSE;
}

BOOLEAN
SpDetermineDiskLayout(
    IN PMIRROR_CFG_INFO_FILE pFileData,
    OUT PMIRROR_CFG_INFO_MEMORY *pMemoryData
    )
/*++

Routine Description:

    This routine takes the passed-in IMirror.dat file and produces a
    resulting memory structure indicating how the local disks should
    be partitioned.

Arguments:

    pFileData - A pointer to an in-memory copy of IMirror.Dat.

    pMemoryData - Returnes an allocated pointed to how the disks should
        be partitioned.

Return Value:

    TRUE if successful, else it generates a fatal error.

--*/
{
    PMIRROR_CFG_INFO_MEMORY memData;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    NTSTATUS Status;
    ULONG ResultLength;
    PKEY_BASIC_INFORMATION KeyInfo;
    PWSTR CurrentHalName, OriginalHalName;
    ULONG CurrentHalNameLength;
    ULONG i, j;
    ULONG diskNumber;
    PPARTITIONED_DISK pDisk;

    if (pFileData->MirrorVersion != IMIRROR_CURRENT_VERSION) {

        SpSysPrepFailure( SP_SYSPREP_INVALID_VERSION, NULL, NULL );
        return FALSE;
    }

    //
    // Check if the current HAL that textmode installed for this
    // system is different from the one that is running on this system
    // (note that this works because for remote install boots, setupldr
    // loads the real HAL, not the one from the short list of HALs
    // included on the boot floppy).
    //

    INIT_OBJA(&Obja, &UnicodeString, L"\\Registry\\Machine\\Hardware\\RESOURCEMAP\\Hardware Abstraction Layer");
    Status = ZwOpenKey(&Handle, KEY_READ, &Obja);
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpDetermineDiskLayout: ZwOpenKey of HAL key failed %lx\n", Status));
        SpSysPrepFailure( SP_SYSPREP_WRONG_HAL, NULL, NULL );
        return FALSE;
    }

    KeyInfo = (PKEY_BASIC_INFORMATION)TemporaryBuffer;
    Status = ZwEnumerateKey(Handle, 0, KeyBasicInformation, KeyInfo, sizeof(TemporaryBuffer), &ResultLength);

    ZwClose(Handle);

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpDetermineDiskLayout: ZwEnumerateKey of HAL key failed %lx\n", Status));
        SpSysPrepFailure( SP_SYSPREP_WRONG_HAL, NULL, NULL );
        return FALSE;
    }

    KeyInfo->Name[KeyInfo->NameLength / sizeof(WCHAR)] = L'\0';
    CurrentHalName = SpDupStringW(KeyInfo->Name);
    CurrentHalNameLength = KeyInfo->NameLength;

    OriginalHalName = (PWCHAR)(((PUCHAR)pFileData) + pFileData->HalNameOffset);

    if (!CurrentHalName || 
            (memcmp(OriginalHalName, CurrentHalName, CurrentHalNameLength) != 0)) {
            
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, 
                 "SpDetermineDiskLayout: HAL strings different, old <%ws> new <%ws>\n",
                 OriginalHalName,
                 CurrentHalName));
                 
        SpSysPrepFailure(
            SP_SYSPREP_WRONG_HAL,
            OriginalHalName,
            CurrentHalName);
            
        return FALSE;
    }

    //
    // For the moment, don't worry about the number of processors being
    // different. The HAL check will probably catch it, and if not it should
    // still work as long as the build is internally consistent, since we
    // don't replace any components right now. There are two error screens
    // defined for this case, SP_SYSPREP_WRONG_PROCESSOR_COUNT_UNI and
    // SP_SYSPREP_WRONG_PROCESSOR_COUNT_MULTI.
    //

    memData = SpMemAlloc(FIELD_OFFSET(MIRROR_CFG_INFO_MEMORY, Volumes[0]) +
                         (pFileData->NumberVolumes * sizeof(MIRROR_VOLUME_INFO_MEMORY)));

    memData->NumberVolumes = pFileData->NumberVolumes;
    for (i = 0; i < pFileData->NumberVolumes; i++) {

        memData->Volumes[i].DriveLetter = pFileData->Volumes[i].DriveLetter;
        memData->Volumes[i].PartitionType = pFileData->Volumes[i].PartitionType;
        memData->Volumes[i].PartitionActive = pFileData->Volumes[i].PartitionActive;
        memData->Volumes[i].IsBootDisk = pFileData->Volumes[i].IsBootDisk;
        memData->Volumes[i].CompressedVolume = pFileData->Volumes[i].CompressedVolume;
        diskNumber = pFileData->Volumes[i].DiskNumber;
        memData->Volumes[i].DiskNumber = diskNumber;
        memData->Volumes[i].PartitionNumber = pFileData->Volumes[i].PartitionNumber;
        memData->Volumes[i].DiskSignature = pFileData->Volumes[i].DiskSignature;
        memData->Volumes[i].BlockSize = pFileData->Volumes[i].BlockSize;
        memData->Volumes[i].LastUSNMirrored = pFileData->Volumes[i].LastUSNMirrored;
        memData->Volumes[i].FileSystemFlags = pFileData->Volumes[i].FileSystemFlags;

        wcscpy(memData->Volumes[i].FileSystemName, pFileData->Volumes[i].FileSystemName);
        memData->Volumes[i].VolumeLabel = SpDupStringW((PWCHAR)(((PUCHAR)pFileData) + pFileData->Volumes[i].VolumeLabelOffset));
        memData->Volumes[i].OriginalArcName = SpDupStringW((PWCHAR)(((PUCHAR)pFileData) + pFileData->Volumes[i].ArcNameOffset));

        memData->Volumes[i].DiskSpaceUsed = pFileData->Volumes[i].DiskSpaceUsed;
        memData->Volumes[i].StartingOffset = pFileData->Volumes[i].StartingOffset;
        memData->Volumes[i].PartitionSize = pFileData->Volumes[i].PartitionSize;

        //
        // Ensure that the required disk number actually exists, and that the
        // disk is online.
        //

        pDisk = &PartitionedDisks[diskNumber];
        if ((diskNumber >= HardDiskCount) ||
            (pDisk->HardDisk == NULL) ||
            (pDisk->HardDisk->Status == DiskOffLine) ) {
            SpSysPrepFailure( SP_SYSPREP_INVALID_PARTITION, NULL, NULL );
        }
    }

    *pMemoryData = memData;

    SpMemFree(CurrentHalName);

    return TRUE;
}

NTSTATUS
SpGetBaseDeviceName(
    IN PWSTR SymbolicName,
    OUT PWSTR Buffer,
    IN ULONG Size
    )

/*++

Routine Description:

    This routine drills down thru symbolic links until it finds the base device name.

Arguments:

    SymbolicName - The name to start with.

    Buffer - The output buffer.

    Size - Length, in bytes of Buffer

Return Value:

    STATUS_SUCCESS if it completes adding all the to do items properly.

--*/

{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    NTSTATUS Status;

    //
    // Start at the first name
    //
    INIT_OBJA(&Obja,&UnicodeString,SymbolicName);

    Status = ZwOpenSymbolicLinkObject(&Handle,
                                      (ACCESS_MASK)SYMBOLIC_LINK_QUERY,
                                      &Obja
                                     );

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    while (TRUE) {

        //
        // Take this open and get the next name
        //
        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = (USHORT)Size;
        UnicodeString.Buffer = (PWCHAR)Buffer;
        Status = ZwQuerySymbolicLinkObject(Handle,
                                           &UnicodeString,
                                           NULL
                                          );

        ZwClose(Handle);

        Buffer[(UnicodeString.Length / sizeof(WCHAR))] = UNICODE_NULL;

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        //
        // See if the next name is also a symbolic name
        //

        INIT_OBJA(&Obja,&UnicodeString,MOUNTMGR_DEVICE_NAME);

        Status = ZwOpenSymbolicLinkObject(&Handle,
                                          (ACCESS_MASK)SYMBOLIC_LINK_QUERY,
                                          &Obja
                                         );

        if (!NT_SUCCESS(Status)) {
            return STATUS_SUCCESS;
        }

    }
}

BOOLEAN
SpVerifyDriveLetter(
    IN PWSTR RegionName,
    IN WCHAR DriveLetter
    )

/*++

Routine Description:

    This routine makes sure that the specified region has been assigned
    the correct drive letter by the mount manager, if not it changes it.

Arguments:

    RegionName - The region name, \Device\HardiskX\PartitionY.

    DriveLetter - The desired drive letter.

Return Value:

    TRUE if successful, else FALSE.

--*/

{
    WCHAR currentLetter;
    ULONG i;
    PMOUNTMGR_MOUNT_POINT mountPoint = NULL;
    PMOUNTMGR_CREATE_POINT_INPUT createMountPoint;
    WCHAR NewSymbolicLink[16];
    PWSTR regionBaseName;
    ULONG mountPointSize;
    ULONG createMountPointSize;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;
    PMOUNTMGR_MOUNT_POINTS mountPointsReturned;
    LARGE_INTEGER DelayTime;

    //
    // See what drive letter the region has. Since the mount manager
    // assigns drive letters asynchronously, we wait a little while
    // if we don't get one back.
    //

    for (i = 0; ; i++) {

        currentLetter = SpGetDriveLetter(RegionName, &mountPoint);

        if (currentLetter == DriveLetter) {
            if (mountPoint) {
                SpMemFree(mountPoint);
            }
            
            return TRUE;
        } else if (currentLetter != L'\0') {
            break;
        } else if (i == 5) {
            break;
        }

        //
        // Wait 2 sec and try again.
        //
        DelayTime.HighPart = -1;
        DelayTime.LowPart = (ULONG)(-20000000);
        KeDelayExecutionThread(KernelMode,FALSE,&DelayTime);
    }

    //
    // At this point, we either have no drive letter assigned, or a
    // wrong one.
    //

    if (currentLetter != L'\0') {

        //
        // There is an existing drive letter, so delete it.
        //

        INIT_OBJA(&Obja,&UnicodeString,MOUNTMGR_DEVICE_NAME);

        Status = ZwOpenFile(
                    &Handle,
                    // (ACCESS_MASK)(FILE_GENERIC_READ | FILE_GENERIC_WRITE),
                    (ACCESS_MASK)(FILE_GENERIC_READ),
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE ,
                    FILE_NON_DIRECTORY_FILE
                  );

        if( !NT_SUCCESS( Status ) ) {
            SpMemFree(mountPoint);
            FALSE;
        }

        mountPointsReturned = SpMemAlloc( 4096 );

        mountPointSize = sizeof(MOUNTMGR_MOUNT_POINT) +
                         mountPoint->SymbolicLinkNameLength +
                         mountPoint->UniqueIdLength +
                         mountPoint->DeviceNameLength;

        Status = ZwDeviceIoControlFile(
                        Handle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        IOCTL_MOUNTMGR_DELETE_POINTS,
                        mountPoint,
                        mountPointSize,
                        mountPointsReturned,
                        4096
                        );


        if (!NT_SUCCESS( Status )) {
            SpMemFree(mountPointsReturned);
            SpMemFree(mountPoint);
            ZwClose(Handle);
            return FALSE;
        }

        SpMemFree(mountPointsReturned);
        SpMemFree(mountPoint);   // don't need this anymore
    }

    //
    // Now add the one we want.
    //

    //
    // We need to get the real base name (\Device\HardDiskX\PartitionY
    // is a symbolic link).
    //

    SpGetBaseDeviceName(RegionName, TemporaryBuffer, sizeof(TemporaryBuffer));
    regionBaseName = SpDupStringW(TemporaryBuffer);

    swprintf(NewSymbolicLink, L"\\DosDevices\\%c:", DriveLetter);
    createMountPointSize = sizeof(MOUNTMGR_CREATE_POINT_INPUT) +
                           (wcslen(regionBaseName) * sizeof(WCHAR)) +
                           (wcslen(NewSymbolicLink) * sizeof(WCHAR));
    createMountPoint = SpMemAlloc(createMountPointSize);
    createMountPoint->SymbolicLinkNameLength = wcslen(NewSymbolicLink) * sizeof(WCHAR);
    createMountPoint->SymbolicLinkNameOffset = sizeof(MOUNTMGR_CREATE_POINT_INPUT);
    memcpy((PCHAR)createMountPoint + createMountPoint->SymbolicLinkNameOffset,
           NewSymbolicLink,
           createMountPoint->SymbolicLinkNameLength);

    createMountPoint->DeviceNameLength = wcslen(regionBaseName) * sizeof(WCHAR);
    createMountPoint->DeviceNameOffset = createMountPoint->SymbolicLinkNameOffset +
                                         createMountPoint->SymbolicLinkNameLength;
    memcpy((PCHAR)createMountPoint + createMountPoint->DeviceNameOffset,
           regionBaseName,
           createMountPoint->DeviceNameLength);

    Status = ZwDeviceIoControlFile(
                    Handle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    IOCTL_MOUNTMGR_CREATE_POINT,
                    createMountPoint,
                    createMountPointSize,
                    NULL,
                    0
                    );

    SpMemFree(createMountPoint);
    SpMemFree(regionBaseName);
    ZwClose(Handle);

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
SpSetVolumeLabel(
    IN PWSTR RegionName,
    IN PWSTR VolumeLabel
    )

/*++

Routine Description:

    This routine sets the volume label on the specified region.

Arguments:

    RegionName - The region name, \Device\HardiskX\PartitionY.

    DriveLetter - The desired volume label.

Return Value:

    TRUE if successful, else FALSE.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;
    struct LABEL_BUFFER {
        FILE_FS_LABEL_INFORMATION VolumeInfo;
        WCHAR Label[64];
        } LabelBuffer;

    INIT_OBJA(&Obja,&UnicodeString,RegionName);

    Status = ZwOpenFile(
                &Handle,
                (ACCESS_MASK)(FILE_GENERIC_READ | FILE_GENERIC_WRITE),
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE ,
                FILE_NON_DIRECTORY_FILE
              );

    if( !NT_SUCCESS( Status ) ) {
        return FALSE;
    }

    LabelBuffer.VolumeInfo.VolumeLabelLength = wcslen(VolumeLabel) * sizeof(WCHAR);
    wcscpy(LabelBuffer.VolumeInfo.VolumeLabel, VolumeLabel);

    Status = ZwSetVolumeInformationFile(
                 Handle,
                 &IoStatusBlock,
                 &LabelBuffer,
                 FIELD_OFFSET(FILE_FS_LABEL_INFORMATION, VolumeLabel[0]) + LabelBuffer.VolumeInfo.VolumeLabelLength,
                 FileFsLabelInformation);

    ZwClose(Handle);

    if( !NT_SUCCESS( Status ) ) {
        return FALSE;
    }

    return TRUE;

}

BOOLEAN
SpFixupLocalDisks(
    IN HANDLE SifHandle,
    OUT PDISK_REGION *InstallRegion,
    OUT PDISK_REGION *SystemPartitionRegion,
    IN PWSTR SetupSourceDevicePath,
    IN PWSTR DirectoryOnSetupSource,
    IN PMIRROR_CFG_INFO_MEMORY pMemoryData,
    IN BOOLEAN UseWholeDisk
    )

/*++

Routine Description:

    This routine parses the IMirror.dat file given and makes the local disk(s) look as
    closely as possible to the configuration in the file.

Arguments:

    SifHandle - Controlling sif file.

    InstallRegion - Returns the install region to use.

    SystemPartitionRegion - Returns the system partition to use.

    SetupSourceDevicePath - Path to the setup device.

    DirectoryOnSetupSource - Subdirectory of the setup files.

    pMemoryData - A pointer to an in-memory copy of the file.

    UseWholeDisk - TRUE if disks should be partitioned as their current
        physical size; FALSE if they should be partitioned to match
        the size that the original source machine had.

Return Value:

    TRUE if successful, else it generates a fatal error.

--*/

{
    PDISK_REGION pRegion=NULL;
    PDISK_REGION p;
    PWSTR RegionDescr;
    PWSTR RegionNtName;
    NTSTATUS Status;
    BOOLEAN DiskCleaned[8] = { FALSE };  // track if a disk has been cleaned up.
    ULONG volume, disk;
    PMIRROR_VOLUME_INFO_MEMORY volumeInfo;
    LARGE_INTEGER SizeInMB;
    PPARTITIONED_DISK pDisk;
    BOOLEAN ExpandToEnd;
    ULONG j;
    PARTITION_INFORMATION_EX    PartInfo;
    ULONGLONG   SysPartStartSector = 0;
    ULONG       SysPartDisk = 0;

    LARGE_INTEGER SizeAvailable;
    LARGE_INTEGER SlopSize;
    LARGE_INTEGER SlopSizeTimes100;
    LARGE_INTEGER SizeRequiredMax;
    LARGE_INTEGER SizeRequiredMin;

    PULONGLONG     StartSectors = NULL;

    if (pMemoryData->NumberVolumes) {
        StartSectors = (PULONGLONG)(SpMemAlloc(sizeof(ULONGLONG) * pMemoryData->NumberVolumes));

        if (!StartSectors) {
            *InstallRegion = NULL;
            *SystemPartitionRegion = NULL;

            return FALSE;   // ran out of memory
        }
    }       

    RtlZeroMemory(StartSectors, (sizeof(ULONGLONG) * pMemoryData->NumberVolumes));

    //
    // NOTE: imirror.dat
    // doesn't have information about which partitions were in the extended
    // partition. We could read the boot sector from the server, or just
    // try to guess at when we need an extended partition. For the moment,
    // we will just let the partition creation code create extended
    // partitions whent it wants to (all regions after the first primary
    // become logical disks in an extended partition).
    //

    for (volume = 0; volume < pMemoryData->NumberVolumes; volume++) {

        volumeInfo = &pMemoryData->Volumes[volume];

        //
        // If this disk has not been cleaned up, then do so.
        //

        disk = volumeInfo->DiskNumber;

        if (!DiskCleaned[disk]) {

            //
            // Clean out the different partitions on disk.
            //

            SpPtPartitionDiskForRemoteBoot(
                disk,
                &pRegion);

            //
            // That function may leave one big partitioned region, if so delete
            // it so we can start from scratch.
            //

            if (pRegion && pRegion->PartitionedSpace) {
                SpPtDelete(pRegion->DiskNumber,pRegion->StartSector);
            }

            DiskCleaned[disk] = TRUE;

        } else {

            //
            // We have already cleaned out this disk, so pRegion points
            // to the last partition we created. However, we have these 2 dirty looking validation checks on pRegion
            // to make PREFIX happy. pRegion is never NULL but if it is we think that something is wrong and move on.
            //
            
            if( pRegion == NULL )
                continue;

            pRegion = pRegion->Next;

            if( pRegion == NULL )
                continue;
        }

        //
        // Create a region of the specified size.
        // NOTE: Worry about volumeInfo->PartitionType/CompressedVolume?
        // NOTE: What if the rounding to the nearest MB loses something?
        //
        //  We allow for some slop.
        //  a) If the new disk is <= x% smaller, and the image will still fit, then we'll do it.
        //  b) If the new disk is <= x% bigger, then we'll make one partition out of the whole disk.
        //  c) If the new disk is >x% bigger, then we'll make one partition equal to the original one and leave the rest of the disk raw.
        //  d) If the new disk is >x% smaller, then we'll fail.

        pDisk = &PartitionedDisks[pRegion->DiskNumber];
//        SizeAvailable = RtlEnlargedUnsignedMultiply( pRegion->SectorCount, pDisk->HardDisk->Geometry.BytesPerSector );
        SizeAvailable.QuadPart = pRegion->SectorCount * pDisk->HardDisk->Geometry.BytesPerSector;

        // SYSPREP_PARTITION_SLOP is specified as a percentage

        SlopSizeTimes100 = RtlExtendedIntegerMultiply(SizeAvailable, SYSPREP_PARTITION_SLOP);
        SlopSize = RtlExtendedLargeIntegerDivide( SlopSizeTimes100, 100, NULL );

        SizeRequiredMin = RtlLargeIntegerSubtract( volumeInfo->PartitionSize, SlopSize );

        if ( SizeRequiredMin.QuadPart < volumeInfo->DiskSpaceUsed.QuadPart ) {

            SizeRequiredMin = volumeInfo->DiskSpaceUsed;
        }

        SizeRequiredMax = RtlLargeIntegerAdd( volumeInfo->PartitionSize, SlopSize );

        ExpandToEnd = FALSE;
        if (UseWholeDisk) {
            ExpandToEnd = TRUE;

            //
            // If this is the last partition on the disk, then use the rest of it.
            //
            for (j = 0; j < pMemoryData->NumberVolumes; j++) {
                if ((j != volume) &&
                    (pMemoryData->Volumes[j].DiskNumber == pMemoryData->Volumes[volume].DiskNumber) &&
                    (pMemoryData->Volumes[j].StartingOffset.QuadPart > pMemoryData->Volumes[volume].StartingOffset.QuadPart)) {
                    ExpandToEnd = FALSE;
                    break;
                }
            }
        }

        SizeInMB = RtlExtendedLargeIntegerDivide(volumeInfo->PartitionSize, 1024 * 1024, NULL);

        if (!ExpandToEnd && (SizeAvailable.QuadPart > SizeRequiredMax.QuadPart)) {

            // use volumeInfo->PartitionSize

        } else if (SizeAvailable.QuadPart >= SizeRequiredMin.QuadPart ) {

            SizeInMB.QuadPart = 0; // use all available space

        } else {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Sysprep partition of %d Mb is too big\n", SizeInMB.LowPart));

            SpSysPrepFailure( SP_SYSPREP_NOT_ENOUGH_DISK_SPACE, NULL, NULL );
            return(FALSE);
        }

        //
        // TBD : fix the partition type 
        // if(!SpPtDoCreate(pRegion,&p,TRUE,SizeInMB.LowPart,volumeInfo->PartitionType,TRUE)) {
        //
        RtlZeroMemory(&PartInfo, sizeof(PARTITION_INFORMATION_EX));
        PartInfo.Mbr.PartitionType = volumeInfo->PartitionType;
        
        if(!SpPtDoCreate(pRegion, &p, TRUE, SizeInMB.LowPart, &PartInfo, TRUE)) {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not create sys prep partition %d Mb\n", SizeInMB.LowPart));

            SpSysPrepFailure( SP_SYSPREP_NOT_ENOUGH_DISK_SPACE, NULL, NULL );
            return(FALSE);
        }

        //
        // If we just created an extended partition and a logical drive,
        // we'll need to switch regions -- Region points to the extended partition
        // region, but we want to point to the logical drive region.
        //
        ASSERT(p);
        pRegion = p;

#if defined(_AMD64_) || defined(_X86_)
        if (volumeInfo->PartitionActive) {

            if (volumeInfo->IsBootDisk) {

                //
                // On an amd64/x86 machine, make sure that we have a valid primary partition
                // on drive 0 (C:), for booting.
                //
                PDISK_REGION SysPart = SpPtValidSystemPartition();

                ASSERT(pRegion == SysPart);

                SPPT_MARK_REGION_AS_SYSTEMPARTITION(pRegion, TRUE);
                SPPT_SET_REGION_DIRTY(pRegion, TRUE);
                
                SysPartDisk = disk;
                SysPartStartSector = pRegion->StartSector;
            }

            //
            // Make sure the system partition is active and all others are inactive.
            //
            SpPtMakeRegionActive(pRegion);            
        }
#endif // defined(_AMD64_) || defined(_X86_)

        volumeInfo->CreatedRegion = NULL;
        StartSectors[disk] = pRegion->StartSector;
    }

    if (SysPartStartSector == 0) {
        *InstallRegion = *SystemPartitionRegion = NULL;
        SpMemFree(StartSectors);

        return FALSE;   // We need the system partition and install region
    }
    
    //
    // At this point, everything is fine, so commit any
    // partition changes the user may have made.
    // This won't return if an error occurs while updating the disk.
    //
    SpPtDoCommitChanges();

    //
    // Now format all the partitions and make sure the drive letter
    // is correct.
    //

    for (volume = 0; volume < pMemoryData->NumberVolumes; volume++) {
        ULONG FilesystemType;
        ULONG DiskNumber = volumeInfo->DiskNumber;

        volumeInfo = &pMemoryData->Volumes[volume];        
        
        if (StartSectors[DiskNumber]) {
            volumeInfo->CreatedRegion = SpPtLookupRegionByStart(
                                            SPPT_GET_PARTITIONED_DISK(DiskNumber),
                                            TRUE,
                                            StartSectors[DiskNumber]);
        } else {
            ASSERT(FALSE);

            continue;
        }            
        
        pRegion = volumeInfo->CreatedRegion;

        SpPtRegionDescription(
            &PartitionedDisks[pRegion->DiskNumber],
            pRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer)
            );

        RegionDescr = SpDupStringW(TemporaryBuffer);

        if (wcscmp(volumeInfo->FileSystemName, L"FAT") == 0) {
            FilesystemType = FilesystemFat;
        } else if (wcscmp(volumeInfo->FileSystemName, L"FAT32") == 0) {
            FilesystemType = FilesystemFat32;
        } else {
            FilesystemType = FilesystemNtfs;
        }

        Status = SpDoFormat(
                    RegionDescr,
                    pRegion,
                    FilesystemType,
                    FALSE,
                    FALSE,      // don't need to worry about fat size
                    TRUE,
                    SifHandle,
                    0,          // default cluster size
                    SetupSourceDevicePath,
                    DirectoryOnSetupSource
                    );

        SpMemFree(RegionDescr);

        //
        // This checks that the drive letter is correct.
        //

        SpNtNameFromRegion(
            pRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer),
            PartitionOrdinalCurrent);

        RegionNtName = SpDupStringW(TemporaryBuffer);

        SpVerifyDriveLetter(
            RegionNtName,
            volumeInfo->DriveLetter
            );

        SpSetVolumeLabel(
            RegionNtName,
            volumeInfo->VolumeLabel
            );

        pRegion->DriveLetter = volumeInfo->DriveLetter;
        wcsncpy(pRegion->VolumeLabel,
                volumeInfo->VolumeLabel,
                (sizeof(pRegion->VolumeLabel) / sizeof(WCHAR)) - 1
               );

        pRegion->VolumeLabel[ (sizeof(pRegion->VolumeLabel) / sizeof(WCHAR)) - 1] = UNICODE_NULL;

        SpMemFree(RegionNtName);

    }

    //
    // Locate the system and install region
    //
    *SystemPartitionRegion = SpPtLookupRegionByStart(SPPT_GET_PARTITIONED_DISK(SysPartDisk),
                                            TRUE,
                                            SysPartStartSector);

    *InstallRegion = *SystemPartitionRegion;

    SpMemFree(StartSectors);
    

    return (*InstallRegion != NULL);
}

BOOLEAN
SpCopyMirrorDisk(
    IN PMIRROR_CFG_INFO_FILE pFileData,
    IN ULONG cDisk
    )

/*++

Routine Description:

    This routine uses the IMirror.dat file given and a disk number to copy the contents
    on the mirror share down to the local machine.

Arguments:

    pFileData - A pointer to an in-memory copy of the file.

    cDisk - The disk number to copy.

Return Value:

    TRUE if successful, else FALSE.

--*/
{
    PMIRROR_VOLUME_INFO_FILE pVolume;
    PDISK_REGION pRegion;
    WCHAR Buffer[MAX_PATH];
    NTSTATUS Status;
    PWSTR pNtName;

    if (pFileData->NumberVolumes <= cDisk) {
        SpSysPrepFailure( SP_SYSPREP_INVALID_PARTITION, NULL, NULL );
        return FALSE;
    }

    //
    // Find the correct region.
    // NOTE: the drive with this
    // letter might not be on the same disk, we should scan all disks
    // for this drive letter.
    //
    pVolume = &(pFileData->Volumes[cDisk]);
    pRegion = PartitionedDisks[pVolume->DiskNumber].PrimaryDiskRegions;

    while (pRegion != NULL) {
        if (pRegion->DriveLetter == pVolume->DriveLetter) {
            break;
        }
        pRegion = pRegion->Next;
    }

    if (pRegion ==  NULL) {

        pRegion = PartitionedDisks[pVolume->DiskNumber].ExtendedDiskRegions;

        while (pRegion != NULL) {
            if (pRegion->DriveLetter == pVolume->DriveLetter) {
                break;
            }
            pRegion = pRegion->Next;
        }

        if (pRegion == NULL) {
            SpSysPrepFailure( SP_SYSPREP_NOT_ENOUGH_PARTITIONS, NULL, NULL );
            return FALSE;
        }
    }

    SpPtRegionDescription(
        &PartitionedDisks[pRegion->DiskNumber],
        pRegion,
        Buffer,
        sizeof(Buffer)
        );

    //
    // Now copy all files over
    //
    SpNtNameFromRegion(
        pRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    pNtName = SpDupStringW(TemporaryBuffer);

    mbstowcs(Buffer, RemoteIMirrorFilePath, strlen(RemoteIMirrorFilePath) + 1);
    wcscat(Buffer, (PWSTR)(((PUCHAR)pFileData) + pVolume->MirrorUncPathOffset));

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Copying directories from %ws to %ws%ws\n",
        Buffer, pNtName, L"\\"));

    //
    //  setup the global that says whether we look at compression bit or ACL.
    //

    if ((wcscmp(pVolume->FileSystemName, L"FAT") == 0) ||
        (wcscmp(pVolume->FileSystemName, L"FAT32") == 0)) {

        RemoteSysPrepVolumeIsNtfs = FALSE;

    } else {

        RemoteSysPrepVolumeIsNtfs = TRUE;
    }

    //
    //  copy the acl onto the root.
    //

    Status = SpSysPrepSetExtendedInfo( Buffer, pNtName, TRUE, TRUE );

    if (!NT_SUCCESS(Status)) {

        SpSysPrepFailure( SP_SYSPREP_ACL_FAILURE, pNtName, NULL );
        SpMemFree( pNtName );
        return FALSE;
    }

    SpCopyDirRecursive(
        Buffer,
        pNtName,
        L"\\",
        0
        );

    //
    //  create the \sysprep\sysprep.inf file as a dup of our sif file for gui
    //  mode setup answer file.
    //

    if (pVolume->IsBootDisk) {

        //
        //  first we create the sysprep directory, then we create the inf
        //  file in it.
        //

        SpCreateDirectory( pNtName,
                           NULL,
                           L"sysprep",
                           0,
                           0 );

        Status = SpWriteSetupTextFile(WinntSifHandle,pNtName,L"sysprep",L"sysprep.inf");
    }

    SpMemFree( pNtName );
    return TRUE;
}

VOID
SpDeleteStorageVolumes (
    IN HANDLE SysPrepRegHandle,
    IN DWORD ControlSetNumber
    )
/*++

Routine Description:

    This routine deletes those subkeys of the CCS\Enum\STORAGE\Volume key that
    represent volumes that were never fully installed. This eliminates stale
    information about volumes that may not exist on this computer.

    The motivation for this is this scenario and others like it:

    On the initial install of the OS, the disk has one large partition. The user
    chooses to delete this partition and create a smaller one to hold the OS.
    The result of this is that textmode setup transfers volume information about
    both partitions into the system hive for the running OS. GUI mode setup then
    completely installs the smaller volume, but the larger volume is left partially
    installed and marked with CONFIGFLAG_REINSTALL.

    Next RIPREP is run to copy the OS image to a RIS server. When the image is
    brought back down, say to the same machine or to a machine with the same
    hard disk size, and the automatic UseWholeDisk partitioning is done, there
    will be one large partition of the same size as the original large partition.
    The Volume instance name will match the partially installed one, so when
    mini-GUI mode setup starts, it will get a bugcheck 7B because the partially
    installed volume cannot be used as the system disk.

    To combat this problem, this routine deletes all partially installed volumes
    from the CCS\Enum\STORAGE\Volume key.

Arguments:

    SysPrepRegHandle - Handle to the system hive of the build we are patching.

    ControlSetNumber - Current control set number in the hive.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING unicodeString;
    HANDLE volumeKeyHandle;
    DWORD enumIndex;
    DWORD resultLength;
    PKEY_BASIC_INFORMATION keyInfo;
    PKEY_VALUE_FULL_INFORMATION valueInfo;
    PWCH instanceName;
    HANDLE instanceKeyHandle;
    DWORD configFlags;

    //
    // Open the Enum\STORAGE\Volume key in the current control set.
    //

    swprintf(
        TemporaryBuffer,
        L"ControlSet%03d\\Enum\\STORAGE\\Volume",
        ControlSetNumber
        );

    INIT_OBJA( &obja, &unicodeString, TemporaryBuffer );
    obja.RootDirectory = SysPrepRegHandle;

    status = ZwOpenKey( &volumeKeyHandle, KEY_ALL_ACCESS, &obja );
    if( !NT_SUCCESS(status) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SpDeleteStorageVolumes: Unable to open %ws.  status = %lx\n", TemporaryBuffer, status ));
        return;
    }

    //
    // Enumerate all of the instance keys.
    //

    enumIndex = 0;

    while ( TRUE ) {

        status = ZwEnumerateKey(
                    volumeKeyHandle,
                    enumIndex,
                    KeyBasicInformation,
                    TemporaryBuffer,
                    sizeof(TemporaryBuffer),
                    &resultLength
                    );

        if ( !NT_SUCCESS(status) ) {

            if ( status == STATUS_NO_MORE_ENTRIES ) {

                //
                // Enumeration completed successfully.
                //

                status = STATUS_SUCCESS;

            } else {

                //
                // Some kind of error occurred. Print a message and bail.
                //

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SpDeleteStorageVolumes: Unable to enumerate existing storage volumes (%lx)\n", status ));
            }

            break;
        }

        //
        // Zero-terminate the subkey name just in case. Copy it out of the
        // temporary buffer into "local" storage.
        //

        keyInfo = (PKEY_BASIC_INFORMATION)TemporaryBuffer;
        keyInfo->Name[keyInfo->NameLength/sizeof(WCHAR)] = UNICODE_NULL;
        instanceName = SpDupStringW( keyInfo->Name );

        //
        // Open the key for the volume instance.
        //

        INIT_OBJA( &obja, &unicodeString, instanceName );
        obja.RootDirectory = volumeKeyHandle;

        status = ZwOpenKey( &instanceKeyHandle, KEY_ALL_ACCESS, &obja );

        if( !NT_SUCCESS(status) ) {

            //
            // Unable to open the instance key. Print a message and move
            // on to the next one.
            //

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SpDeleteStorageVolumes: Unable to open %ws.  status = %lx\n", instanceName, status ));
            SpMemFree( instanceName );
            enumIndex++;
            continue;
        }

        //
        // Query the ConfigFlags value.
        //

        RtlInitUnicodeString( &unicodeString, L"ConfigFlags");
        status = ZwQueryValueKey(
                    instanceKeyHandle,
                    &unicodeString,
                    KeyValueFullInformation,
                    TemporaryBuffer,
                    sizeof(TemporaryBuffer),
                    &resultLength
                    );
        valueInfo = (PKEY_VALUE_FULL_INFORMATION)TemporaryBuffer;

        if ( NT_SUCCESS(status) &&
             (valueInfo->Type == REG_DWORD) ) {

            //
            // Got the value. If the volume isn't fully installed, delete the
            // whole instance key.
            //

            configFlags = *(PULONG)((PUCHAR)valueInfo + valueInfo->DataOffset);

            if ( (configFlags & 
                   (CONFIGFLAG_REINSTALL | CONFIGFLAG_FINISH_INSTALL)) != 0 ) {

                //KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SpDeleteStorageVolumes: instance %ws has ConfigFlags %x; DELETING\n", instanceName, configFlags ));
                ZwClose( instanceKeyHandle );
                status = SppDeleteKeyRecursive(
                            volumeKeyHandle,
                            instanceName,
                            TRUE // ThisKeyToo
                            );
                SpMemFree( instanceName );
                // Don't increment enumIndex, because we just deleted a key.
                continue;

            } else {

                //
                // This volume is fully installed. Leave it alone.
                //

                //KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SpDeleteStorageVolumes: instance %ws has ConfigFlags %x; not deleting\n", instanceName, configFlags ));
            }

        } else {

            //
            // ConfigFlags value not present or not a DWORD. Print a
            // message and move on.
            //

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SpDeleteStorageVolumes: instance %ws has invalid ConfigFlags\n", instanceName ));
        }

        //
        // Clean up and move on to the next volume instance.
        //

        ZwClose( instanceKeyHandle );
        SpMemFree( instanceName );
        enumIndex++;
    }

    //
    // All done. Close the Volume key.
    //

    ZwClose( volumeKeyHandle );

    return;
}


NTSTATUS
SpPatchSysPrepImage(
    IN HANDLE SetupSifHandle,
    IN HANDLE WinntSifHandle,
    IN PMIRROR_CFG_INFO_FILE pFileData,
    IN PMIRROR_CFG_INFO_MEMORY pMemoryData
    )

/*++

Routine Description:

    This routine uses the IMirror.dat file given and the given SIF file to make the
    following modifications to a locally copied SysPrep image.
        - Replace the disk controller driver in the image with one that supports the current hardware.
        - Replace the NIC driver in the image with one that supports the current hardware.
        - Replace the HAL, kernel and other mp/up dependent drivers if necessary.
        - Migrate the mounted device settings.
        - Modify boot.ini ARC names if necessary.

Arguments:

    WinntSifHandle - Handle to the open SIF file.

    pFileData - A pointer to an in-memory copy of IMirror.Dat

    pMemoryData - A pointer to an in-memory copy of IMirror.Dat, modified to
        match the specs of this computer (disk sizes etc).

Return Value:

    The NTSTATUS of the operation.
--*/
{
    PWCHAR SysPrepDriversDevice;
    PWCHAR Tmp;
    ULONG Index;
    DWORD Size;
    DWORD Number;
    WCHAR Path[MAX_PATH];
    WCHAR Path2[MAX_PATH];
    WCHAR ImageName[MAX_PATH];
    WCHAR SrvPath[MAX_PATH];
    HANDLE SrcHandle = NULL;
    HANDLE DstHandle = NULL;
    HANDLE TmpHandle = NULL;
    HANDLE TmpHandle2 = NULL;
    HANDLE FileHandle = NULL;
    HANDLE FileHandle2 = NULL;
    PVOID Buffer = NULL;
    BOOLEAN NeedToUnload = FALSE;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obj;
    OBJECT_ATTRIBUTES DstObj;
    UNICODE_STRING UnicodeString1;
    UNICODE_STRING UnicodeString2;
    IO_STATUS_BLOCK IoStatusBlock;
    PKEY_BASIC_INFORMATION pKeyNode;
    ULONG volume;
    PMIRROR_VOLUME_INFO_MEMORY volumeInfo;
    PDISK_FILE_LIST DiskFileLists;
    ULONG   DiskCount;
    BOOLEAN HaveCopyList = FALSE;
    BOOLEAN CopyListEmpty = TRUE;
    PMIRROR_VOLUME_INFO_FILE pVolume = NULL;
    PWSTR pVolumePath = NULL;

    //
    // Find the volume descriptor for the boot disk.
    //
    DiskCount = 0;
    while (DiskCount < pFileData->NumberVolumes) {

        pVolume = &(pFileData->Volumes[DiskCount]);
        if (pVolume->IsBootDisk) {
            break;
        }
        pVolume = NULL;
        DiskCount++;
    }
    if (pVolume == NULL) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage:  Couldn't find boot drive record\n"));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // First check if the SIF file has a value for SysPrepDriversDevice so that we can
    // get new drivers, etc, if necessary.
    //
    SysPrepDriversDevice = SpGetSectionKeyIndex(WinntSifHandle,
                                                L"SetupData",
                                                L"SysPrepDriversDevice",
                                                0
                                               );

    if ((SysPrepDriversDevice == NULL) || (wcslen(SysPrepDriversDevice) == 0)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage:  SIF has no SysPrepDriversDevice value\n"));
        return STATUS_INVALID_PARAMETER;
    }

    Tmp = SysPrepDriversDevice;
    while(*Tmp != UNICODE_NULL) {
        if (*Tmp == L'%') {
            return STATUS_INVALID_PARAMETER;
        }
        Tmp++;
    }

    //
    // Generate media descriptors for the source media.
    //
    SpInitializeFileLists(
        SetupSifHandle,
        &DiskFileLists,
        &DiskCount
        );

    HaveCopyList = TRUE;

    //
    // Allocate a temporary buffer
    //
    Buffer = SpMemAlloc(1024 * 4);

    //
    // Make a string that contains the path to the volume (\??\X:).
    //
    wcscpy(TemporaryBuffer, L"\\??\\X:");
    TemporaryBuffer[4] = pVolume->DriveLetter;
    pVolumePath = SpDupStringW(TemporaryBuffer);

    //
    // Now load the local version of the SysPrep hives, using IMirror.Dat to find them
    // NOTE: DstObj is assumed by CleanUp to still be the key.
    //
    Tmp = (PWCHAR)(((PUCHAR)pFileData) + pFileData->SystemPathOffset);
    wcscpy(Path, L"\\??\\");
    wcscat(Path, Tmp);
    wcscat(Path, L"\\System32\\Config\\System");

    INIT_OBJA(&DstObj, &UnicodeString1, L"\\Registry\\SysPrepReg");
    INIT_OBJA(&Obj, &UnicodeString2, Path);

    Status = ZwLoadKey(&DstObj, &Obj);

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: ZwLoadKey to SysPrepReg failed %lx\n", Status));
        goto CleanUp;
    }

    NeedToUnload = TRUE;

    //
    // Compare the local SysPrep NIC to the NIC that is currently running
    //

    //
    // If different, then replace the NIC
    //

    //
    // Put all critical devices in the currently running hives into the SysPrep hive.
    //
    wcscpy(Path, L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Control\\CriticalDeviceDatabase");

    INIT_OBJA(&Obj, &UnicodeString2, Path);

    Status = ZwOpenKey(&SrcHandle, KEY_READ, &Obj);

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: ZwOpenKey of local CriticalDeviceDatabase failed %lx\n", Status));
        goto CleanUp;
    }

    wcscpy(Path, L"\\Registry\\SysPrepReg");

    INIT_OBJA(&Obj, &UnicodeString2, Path);

    Status = ZwOpenKey(&DstHandle, KEY_READ, &Obj);

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: ZwOpenKey of root SysPrepReg failed %lx\n", Status));
        goto CleanUp;
    }

    Status = SpGetValueKey(
                 DstHandle,
                 L"Select",
                 L"Current",
                 1024 * 4,
                 Buffer,
                 &Size
                 );

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: SpGetValueKey of Select\\Current failed %lx\n", Status));
        goto CleanUp;
    }

    Number = *((DWORD *)(((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data));

    ZwClose(DstHandle);
    DstHandle = NULL;

    //
    // Print the current control set number to find the current control set
    //
    swprintf(Path,
             L"\\Registry\\SysPrepReg\\ControlSet%03d\\Control\\CriticalDeviceDatabase",
             Number
            );

    //
    // Open the critical device database in the SysPrep image
    //
    INIT_OBJA(&Obj, &UnicodeString2, Path);

    Status = ZwOpenKey(&DstHandle, KEY_READ | KEY_WRITE, &Obj);

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: ZwOpenKey of SysPrepReg CriticalDeviceDatabase failed %lx\n", Status));
        goto CleanUp;
    }

    //
    // Start looping and copying the data from the currently running critical device database
    // into the SysPrep's database.
    //
    pKeyNode = (PKEY_BASIC_INFORMATION)Buffer;

    for (Index = 0; ; Index++) {

        if (TmpHandle) {
            ZwClose(TmpHandle);
            TmpHandle = NULL;
        }
        if (TmpHandle2) {
            ZwClose(TmpHandle2);
            TmpHandle2 = NULL;
        }

        Status = ZwEnumerateKey(SrcHandle,
                                Index,
                                KeyBasicInformation,
                                pKeyNode,
                                1024 * 4,
                                &Size
                                );

        if (!NT_SUCCESS(Status)) {
            Status = STATUS_SUCCESS;
            break;
        }

        RtlCopyMemory((PUCHAR)Path2, (PUCHAR)(pKeyNode->Name), pKeyNode->NameLength);
        Path2[pKeyNode->NameLength/sizeof(WCHAR)] = UNICODE_NULL;



        //
        // We need to quit migrating everything from the current critical device database.
        // In order to do that, we'll only migrate the following types:
        //

        //
        // Make sure this is the type of device we really want to migrate.  We will
        // accept any of the following classes:
        // {4D36E965-E325-11CE-BFC1-08002BE10318}    CDROM
        // {4D36E967-E325-11CE-BFC1-08002BE10318}    DiskDrive
        // {4D36E96A-E325-11CE-BFC1-08002BE10318}    hdc
        // {4D36E96B-E325-11CE-BFC1-08002BE10318}    Keyboard
        // {4D36E96F-E325-11CE-BFC1-08002BE10318}    Mouse
        // {4D36E97B-E325-11CE-BFC1-08002BE10318}    SCSIAdapter
        // {4D36E97D-E325-11CE-BFC1-08002BE10318}    System
        //
        Status = SpGetValueKey( SrcHandle,
                                Path2,
                                L"ClassGUID",
                                1024 * 4,
                                Buffer,
                                &Size );
        if( NT_SUCCESS(Status) ) {

            if( ( _wcsnicmp(L"{4D36E965-E325-11CE-BFC1-08002BE10318}", (PWSTR)((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data, (((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->DataLength/sizeof(WCHAR))) ) &&
                ( _wcsnicmp(L"{4D36E967-E325-11CE-BFC1-08002BE10318}", (PWSTR)((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data, (((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->DataLength/sizeof(WCHAR))) ) &&
                ( _wcsnicmp(L"{4D36E96A-E325-11CE-BFC1-08002BE10318}", (PWSTR)((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data, (((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->DataLength/sizeof(WCHAR))) ) &&
                ( _wcsnicmp(L"{4D36E96B-E325-11CE-BFC1-08002BE10318}", (PWSTR)((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data, (((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->DataLength/sizeof(WCHAR))) ) &&
                ( _wcsnicmp(L"{4D36E96F-E325-11CE-BFC1-08002BE10318}", (PWSTR)((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data, (((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->DataLength/sizeof(WCHAR))) ) &&
                ( _wcsnicmp(L"{4D36E97B-E325-11CE-BFC1-08002BE10318}", (PWSTR)((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data, (((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->DataLength/sizeof(WCHAR))) ) &&
                ( _wcsnicmp(L"{4D36E97D-E325-11CE-BFC1-08002BE10318}", (PWSTR)((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data, (((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->DataLength/sizeof(WCHAR))) ) ) {

                // he's not something we want to migrate.
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SpPatchSysPrepImage: We're skipping migration of %ws because his type is %ws\n", Path2, ((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data));
                continue;
            } else {

                // looks good.
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SpPatchSysPrepImage: We're going to migration %ws because his ClassGUID is %ws\n", Path2, ((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data));
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SpPatchSysPrepImage: SpGetValueKey failed to open %ws\\ClassGUID, but we're going to migrate this key anyway. (%lx)\n", Path2, Status));    
        }


        INIT_OBJA(&Obj, &UnicodeString, Path2);

        Obj.RootDirectory = DstHandle;

        Status = ZwOpenKey(&TmpHandle, KEY_ALL_ACCESS, &Obj);

        if(NT_SUCCESS(Status)) {

            //
            // Delete the current item to rid of stale data
            //
            ZwDeleteKey(TmpHandle);
            ZwClose(TmpHandle);
        }

        TmpHandle = NULL;

        Status = SppCopyKeyRecursive(SrcHandle,
                                     DstHandle,
                                     Path2,
                                     Path2,
                                     TRUE,               // CopyAlways
                                     FALSE               // ApplyACLsAlways
                                    );

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: SppCopyKeyRecursive of %ws failed %lx\n", Path2, Status));
            continue;
        }

        //
        // Now open the services key in both registries
        //
        Status = SpGetValueKey(
                    DstHandle,
                    Path2,
                    L"Service",
                    sizeof(TemporaryBuffer),
                    (PVOID)TemporaryBuffer,
                    &Size
                    );

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage:  Couldn't get target service for %ws, 0x%x\n", Path2,Status));
            continue;
        }


        RtlCopyMemory(Path,
                      ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data,
                      ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->DataLength
                     );

        Path[((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->DataLength/sizeof(WCHAR)] = UNICODE_NULL;

        INIT_OBJA(&Obj,
                  &UnicodeString,
                  L"\\Registry\\Machine\\System\\CurrentControlSet\\Services"
                 );

        Status = ZwOpenKey(&TmpHandle, KEY_ALL_ACCESS, &Obj);

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: ZwOpenKey of Services failed %lx for %ws\n", Status, Path2));
            continue;
        }

        //
        // Get the image path -- remember, since we are in Textmode Setup, the path
        // does *not* contain system32\drivers
        //
        Status = SpGetValueKey(TmpHandle,
                               Path,
                               L"ImagePath",
                               sizeof(TemporaryBuffer),
                               (PVOID)TemporaryBuffer,
                               &Size
                              );

        if (!NT_SUCCESS(Status)) {
            //
            //  if ImagePath isn't there, we default to using the service name.
            //

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: GetValue for ImagePath failed %lx for %ws, we'll default it.\n", Status, Path));
            wcscpy( ImageName, Path );
            wcscat( ImageName, L".sys" );

        } else {

            RtlCopyMemory(ImageName,
                          ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data,
                          ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->DataLength
                         );

            ImageName[((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->DataLength/sizeof(WCHAR)] = UNICODE_NULL;
        }

        //
        // Now delete the old services entry first
        //
        swprintf(TemporaryBuffer,
                 L"\\Registry\\SysPrepReg\\ControlSet%03d\\Services\\%ws",
                 Number,
                 Path
                );

        INIT_OBJA(&Obj, &UnicodeString, TemporaryBuffer);

        Status = ZwOpenKey(&TmpHandle2, KEY_ALL_ACCESS, &Obj);

        if (NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage:  Deleting target service %ws so that we can recreate it cleanly.\n", Path));
            ZwDeleteKey(TmpHandle2);
            ZwClose(TmpHandle2);
            TmpHandle2 = NULL;
        }

        //
        // Now get path to services key in the SysPrep image
        //
        swprintf(TemporaryBuffer,
                 L"\\Registry\\SysPrepReg\\ControlSet%03d\\Services",
                 Number
                );

        INIT_OBJA(&Obj, &UnicodeString, TemporaryBuffer);

        Status = ZwOpenKey(&TmpHandle2, KEY_ALL_ACCESS, &Obj);

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: ZwOpenKey of SysPrepReg services failed %lx for %ws\n", Status,Path2));
            continue;
        }

        //
        // Build the path to the server source.
        //
        wcscpy(SrvPath, SysPrepDriversDevice);
        SpConcatenatePaths(SrvPath, ImageName);

        //
        // Build the path in the SysPrep image for where to store it
        //
        Tmp = (PWCHAR)(((PUCHAR)pFileData) + pFileData->SystemPathOffset);
        wcscpy(TemporaryBuffer, L"\\??\\");
        SpConcatenatePaths(TemporaryBuffer, Tmp);
        SpConcatenatePaths(TemporaryBuffer, L"\\System32\\Drivers\\");
        SpConcatenatePaths(TemporaryBuffer, ImageName);

        wcsncpy(Path2, 
                TemporaryBuffer, 
                MAX_COPY_SIZE(Path2));
        Path2[MAX_COPY_SIZE(Path2)] = L'\0';
        //
        // Copy the driver from the server
        //
        Status = SpCopyFileUsingNames(SrvPath,
                                      Path2,
                                      0,
                                      COPY_ONLY_IF_NOT_PRESENT | COPY_DECOMPRESS_SYSPREP
                                     );

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: SpCopyFilesUsingNames for %ws failed %lx\n", Path2, Status));
            continue;
        }

        wcscpy( ImageName, L"Files." );
        wcscat( ImageName, Path );

        CopyListEmpty = FALSE;

        //  copy the rest of the files for this service by looking up the
        //  appropriate section in txtsetup.inf

        SpAddSectionFilesToCopyList(
            SetupSifHandle,
            DiskFileLists,
            DiskCount,
            ImageName,              // this is now L"Files.Path"
            pVolumePath,            // L"\\Device\\Harddisk0\\Partition1"
            NULL,                   // it should look up the target directory
            COPY_ONLY_IF_NOT_PRESENT,
            TRUE,                    // force nocompression, we don't know what type of driver it is.
            FALSE);                      

        //
        // Now duplicate the services key
        //
        Status = SppCopyKeyRecursive(TmpHandle,
                                     TmpHandle2,
                                     Path,
                                     Path,
                                     TRUE,               // CopyAlways
                                     FALSE               // ApplyACLsAlways
                                    );

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: SppCopyKeyRecursive for %ws failed %lx\n", Path, Status));
            continue;
        }

        //
        // Set the start type to 0
        //
        Size = 0;
        Status = SpOpenSetValueAndClose(TmpHandle2,
                                        Path,
                                        L"Start",
                                        REG_DWORD,
                                        &Size,
                                        sizeof(ULONG)
                                       );

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: SpOpenSetValueAndClose for %ws Start failed %lx\n", Path, Status));
            continue;
        }

        //
        // Set the image path to one with system32\drivers on the front.  We do this by
        // moving backwards thru the target path we have already built to the 3rd backslash
        // from the end.
        //
        Tmp = &(Path2[wcslen(Path2)]);
        for (Size = 0; Size < 3; Size++) {
            while (*Tmp != L'\\') {
                Tmp--;
            }
            Tmp--;
        }

        Tmp += 2;

        Status = SpOpenSetValueAndClose(TmpHandle2,
                                        Path,
                                        L"ImagePath",
                                        REG_EXPAND_SZ,
                                        Tmp,
                                        (wcslen(Tmp) + 1) * sizeof(WCHAR)
                                       );

        ZwClose(TmpHandle);
        ZwClose(TmpHandle2);
        TmpHandle = NULL;
        TmpHandle2 = NULL;

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: SpOpenSetValueAndClose for %ws ImagePath failed %lx\n", Path, Status));
            continue;
        }
    }

    //
    // Copy over the NIC files, including the INF file.
    //
    Tmp = (PWCHAR)(((PUCHAR)pFileData) + pFileData->SystemPathOffset);
    wcscpy(Path, L"\\??\\");
    SpConcatenatePaths(Path, Tmp);
    Status = SpCopyNicFiles(SysPrepDriversDevice, Path);

    //
    // Get the HAL and just always copy it over.
    //

    //
    // Now test for mp/up and then replace dependent drivers as necessary.
    //

    //
    // Migrate the MountedDevices and DISK registry information.
    //

    ZwClose(SrcHandle);
    SrcHandle = NULL;
    ZwClose(DstHandle);
    DstHandle = NULL;

    //
    // Open the system hive of the current build.
    //
    INIT_OBJA(&Obj, &UnicodeString2, L"\\Registry\\Machine\\SYSTEM");
    Status = ZwOpenKey(&SrcHandle, KEY_READ, &Obj);
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: ZwOpenKey for local SYSTEM failed %lx\n", Status));
        goto CleanUp;
    }

    //
    // Open the system hive of the build we are patching.
    //
    INIT_OBJA(&Obj, &UnicodeString2, L"\\Registry\\SysPrepReg");
    Status = ZwOpenKey(&DstHandle, KEY_READ | KEY_WRITE, &Obj);
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: ZwOpenKey for SysPrepReg SYSTEM failed %lx\n", Status));
        goto CleanUp;
    }

    //
    // Delete the existing subkeys of the MountedDevices key.
    //

    Status = SppDeleteKeyRecursive(DstHandle,
                                   L"MountedDevices",
                                   TRUE);  // ThisKeyToo
    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
        Status = STATUS_SUCCESS;
    }
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: SppDeleteKeyRecursive of MountedDevices failed %lx\n", Status));
        goto CleanUp;
    }

    //
    // Copy the MountedDevices key over.
    //

    Status = SppCopyKeyRecursive(SrcHandle,
                                 DstHandle,
                                 L"MountedDevices",
                                 L"MountedDevices",
                                 TRUE,      // CopyAlways
                                 TRUE);     // ApplyACLsAlways
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: SppCopyKeyRecursive of MountedDevices failed %lx\n", Status));
        goto CleanUp;
    }

    //
    // Delete the existing subkeys of the DISK key. This routine returns
    // STATUS_OBJECT_NAME_NOT_FOUND if the key does not exist, which is
    // not an error in this case.
    //

    Status = SppDeleteKeyRecursive(DstHandle,
                                   L"DISK",
                                   TRUE);  // ThisKeyToo

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
        Status = STATUS_SUCCESS;
    }
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: SppDeleteKeyRecursive of DISK failed %lx\n", Status));
        goto CleanUp;
    }

    //
    // Copy the DISK key over.
    //

    Status = SppCopyKeyRecursive(SrcHandle,
                                 DstHandle,
                                 L"DISK",
                                 L"DISK",
                                 TRUE,      // CopyAlways
                                 TRUE);     // ApplyACLsAlways

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
        Status = STATUS_SUCCESS;
    }
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: SppCopyKeyRecursive of DISK failed %lx\n", Status));
        Status = STATUS_SUCCESS;
        goto CleanUp;
    }

    //
    // Delete those subkeys of the CCS\Enum\STORAGE\Volume key that
    // represent volumes that were never fully installed. This eliminates
    // stale information about volumes that may not exist on this computer.
    //

    SpDeleteStorageVolumes( DstHandle, Number );

CleanUp:

    if (!CopyListEmpty) {
        //
        // Copy files in the copy list.
        //

        WCHAR emptyString = L'\0';
        PWCHAR lastComponent;

        Tmp = (PWCHAR)(((PUCHAR)pFileData) + pFileData->SystemPathOffset);

        if (*Tmp != L'\0' && *(Tmp+1) == L':') {
            Tmp += 2;           // have it skip L"C:" at front of path
            wcscpy(Path2, Tmp);
        } else {
            wcscpy(Path2, L"\\??\\");
            SpConcatenatePaths(Path2, Tmp);
        }

        //
        //  first we need to remove the L"\i386" off the end of the source
        //  path since SpCopyFilesInCopyList or decendent will tack it on.
        //
        //  divide up the source path into two parts so that SpConcatenatePaths
        //  does the right thing when it puts it back together.
        //

        wcscpy( SrvPath, SysPrepDriversDevice );

        lastComponent = SrvPath + wcslen( SrvPath ) - 1;

        while (lastComponent > SrvPath && *lastComponent != L'\\') {
            lastComponent--;
        }

        if (lastComponent > SrvPath) {

            *lastComponent = L'\0';     // this removes the architecture off the end

            // now move backwards until we find the start of the last component
            while (lastComponent > SrvPath && *lastComponent != L'\\') {
                lastComponent--;
            }

            if (lastComponent > SrvPath) {
                *lastComponent = L'\0';
                lastComponent++;
            } else {
                lastComponent = &emptyString;
            }
        } else {
            lastComponent = &emptyString;
        }

        SpCopyFilesInCopyList(
            SetupSifHandle,
            DiskFileLists,
            DiskCount,
            SrvPath,                        // L"\\device\\harddisk0\\partition1"
            lastComponent,                  // L"\\$win_nt$.~ls"
            Path2,                          // L"\\WINNT"
            NULL
            );
    }

    if (HaveCopyList) {
        SpFreeCopyLists(&DiskFileLists,DiskCount);
    }

    if (SrcHandle != NULL) {
        ZwClose(SrcHandle);
    }

    if (DstHandle != NULL) {
        ZwClose(DstHandle);
    }

    if (TmpHandle != NULL) {
        ZwClose(TmpHandle);
    }

    if (TmpHandle2 != NULL) {
        ZwClose(TmpHandle2);
    }

    if (NeedToUnload) {
        ZwUnloadKey(&DstObj);
        NeedToUnload = FALSE;
    }

    if (pVolumePath != NULL) {
        SpMemFree( pVolumePath );
    }

    //
    //  update the NT source path in the software section of the registry
    //  since we have a valid SysPrepDriversDevice
    //

    if (SysPrepDriversDevice && *SysPrepDriversDevice != L'\0') {

        //
        // Now load the local version of the SysPrep hives, using IMirror.Dat to find them
        // NOTE: DstObj is assumed by CleanUp to still be the key.
        //
        Tmp = (PWCHAR)(((PUCHAR)pFileData) + pFileData->SystemPathOffset);
        wcscpy(Path, L"\\??\\");
        wcscat(Path, Tmp);
        wcscat(Path, L"\\System32\\Config\\Software");

        INIT_OBJA(&DstObj, &UnicodeString1, L"\\Registry\\SysPrepReg");
        INIT_OBJA(&Obj, &UnicodeString2, Path);

        Status = ZwLoadKey(&DstObj, &Obj);

        if (NT_SUCCESS(Status)) {

            NeedToUnload = TRUE;

            //
            // Open the system hive of the build we are patching.
            //
            INIT_OBJA(&Obj, &UnicodeString2, L"\\Registry\\SysPrepReg\\Microsoft\\Windows\\CurrentVersion\\Setup");
            Status = ZwOpenKey(&DstHandle, KEY_READ | KEY_WRITE, &Obj);
            if (NT_SUCCESS(Status)) {

                BOOLEAN haveDecentString = FALSE;

                //
                // the path is of the form
                //    \device\lanmanredirector\server\share\..\flat\i386
                // when we want it of the form \\server\share\..\flat
                //

                Tmp = SysPrepDriversDevice + 1;

                while (*Tmp != L'\0' && *Tmp != L'\\') {
                    Tmp++;
                }
                if (*Tmp == L'\\') {

                    Tmp++;
                    while (*Tmp != L'\0' && *Tmp != L'\\') {
                        Tmp++;
                    }
                    if (*Tmp == L'\\') {    // back up one before the \server\share
                                            // so we can put another \ on it
                        Tmp--;
                        wcscpy( Path, Tmp );
                        Tmp = Path;
                        *Tmp = L'\\';       // we now have \\server\share\..\flat\i386

                        Tmp = Path + wcslen(Path);

                        while (Tmp > Path && *Tmp != L'\\') {
                            Tmp--;
                        }
                        if (Tmp > Path) {
                            *Tmp = L'\0';       // remove the \i386
                            haveDecentString = TRUE;
                        }
                    }
                }

                if (haveDecentString) {
                    INIT_OBJA(&Obj, &UnicodeString2, L"SourcePath");
                    Status = ZwSetValueKey (DstHandle,
                                            &UnicodeString2,
                                            0,
                                            REG_SZ,
                                            Path,
                                            (wcslen(Path) + 1 ) * sizeof(WCHAR));
                    if (!NT_SUCCESS(Status)) {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: Setting SourcePath to %ws failed with 0x%x\n", Path, Status));
                    }
                } else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: Couldn't set SourcePath to %ws\n", SysPrepDriversDevice));
                    Status = STATUS_OBJECT_PATH_INVALID;
                }
                ZwClose(DstHandle);
                DstHandle = NULL;

            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: ZwOpenKey for SysPrepReg SOFTWARE failed %lx\n", Status));
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: ZwLoadKey to SysPrepReg failed %lx\n", Status));
        }
    }

    //
    //  patch boot.ini regardless of the status of the patching of everything
    //  else.  if we don't patch boot.ini, the whole image has no hope of
    //  booting.
    //

#if defined(_AMD64_) || defined(_X86_)
    //
    // Patch boot.ini if the ARC names have changed. Boot.ini will
    // be on the active partition of disk 0.
    //

    for (volume = 0; volume < pMemoryData->NumberVolumes; volume++) {
        volumeInfo = &pMemoryData->Volumes[volume];
        if ((volumeInfo->DiskNumber == 0) &&
            (volumeInfo->PartitionActive)) {

            ULONG tmpLen;
            wcscpy(Path, L"\\??\\");
            tmpLen = wcslen(Path);
            Path[tmpLen] = volumeInfo->DriveLetter;
            Path[tmpLen+1] = L'\0';
            wcscat(Path, L":\\boot.ini");

            SpPatchBootIni(Path, pMemoryData);
            break;
        }
    }
#endif // defined(_AMD64_) || defined(_X86_)

    if (NeedToUnload) {
        ZwUnloadKey(&DstObj);
    }

    if (Buffer != NULL) {
        SpMemFree(Buffer);
    }

    return Status;
}

VOID
SpReplaceArcName(
    IN PUCHAR CurrentArcName,
    IN PMIRROR_CFG_INFO_MEMORY pMemoryData,
    OUT PBOOLEAN Replaced
    )
/*++

Routine Description:

    This routine looks in pMemoryData to see if there is a partition
    whose OriginalArcName is equal to CurrentArcName, and if so it
    replaces CurrentArcName, adjusting the rest of the string that
    follows CurrentArcName if needed.

Arguments:

    CurrentArcName - The ARC name to check.

    pMemoryData - A pointer to an in-memory copy of IMirror.Dat, modified to
        match the specs of this computer (disk sizes etc).

    Replaced - Returns TRUE if the name is replaced.

Return Value:

    The NTSTATUS of the operation.
--*/
{
    ULONG volume;
    PMIRROR_VOLUME_INFO_MEMORY volumeInfo;
    ULONG originalArcNameLength, newArcNameLength;
    CHAR TmpArcName[128];

    //
    // Scan pMemoryData to see if any ARC names match.
    //

    *Replaced = FALSE;

    for (volume = 0; volume < pMemoryData->NumberVolumes; volume++) {
        volumeInfo = &pMemoryData->Volumes[volume];

        originalArcNameLength = wcslen(volumeInfo->OriginalArcName);
        wcstombs(TmpArcName, volumeInfo->OriginalArcName, originalArcNameLength+1);

        if (RtlCompareMemory(TmpArcName, CurrentArcName, originalArcNameLength) == originalArcNameLength) {

            //
            // This is the partition that CurrentArcName refers to,
            // see what the ARC name is now.
            //

            SpArcNameFromRegion(
                volumeInfo->CreatedRegion,
                TemporaryBuffer,
                sizeof(TemporaryBuffer),
                PartitionOrdinalOnDisk,
                PrimaryArcPath);

            //
            // If we got an ARC name and it is different from what it was on
            // the old machine, we need to replace.
            //

            if (*TemporaryBuffer &&
                (wcscmp(volumeInfo->OriginalArcName, TemporaryBuffer) != 0)) {

                //
                // See if we need to adjust the buffer because the length
                // of the ARC names is different.
                //

                newArcNameLength = wcslen(TemporaryBuffer);
                if (newArcNameLength != originalArcNameLength) {
                    memmove(
                        CurrentArcName+newArcNameLength,
                        CurrentArcName+originalArcNameLength,
                        strlen(CurrentArcName+originalArcNameLength) + 1);
                }

                //
                // Copy over the new ARC name.
                //

                wcstombs(TmpArcName, TemporaryBuffer, newArcNameLength);
                memcpy(CurrentArcName, TmpArcName, newArcNameLength);

                *Replaced = TRUE;
                break;    // no need to look at any other volumeInfo's.

            }
        }
    }
}

NTSTATUS
SpPatchBootIni(
    IN PWCHAR BootIniPath,
    IN PMIRROR_CFG_INFO_MEMORY pMemoryData
    )

/*++

Routine Description:

    This routine modifies boot.ini to modify any ARC names that have
    changed.

Arguments:

    BootIniPath - The path to the local boot.ini.

    pMemoryData - A pointer to an in-memory copy of IMirror.Dat, modified to
        match the specs of this computer (disk sizes etc).

Return Value:

    The NTSTATUS of the operation.
--*/
{
    ULONG ulLen;
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;
    PCHAR pFileData = NULL, pNewFileData = NULL;
    PCHAR curLoc, endOfLine;
    BOOLEAN changedFile = FALSE;
    PWCHAR TmpBootIni = NULL;

    //
    // Read in the current boot.ini.
    //

    INIT_OBJA(&Obja, &UnicodeString, BootIniPath);

    Status = ZwCreateFile(&Handle,
                          FILE_GENERIC_READ,
                          &Obja,
                          &IoStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ,
                          FILE_OPEN,
                          FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0
                         );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPatchBootIni could not open %ws: %lx\n", BootIniPath, Status));
        goto Cleanup;
    }

    Status = SpGetFileSize(Handle, &ulLen);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPatchBootIni could not SpGetFileSize: %lx\n", Status));
        ZwClose(Handle);
        goto Cleanup;
    }

    //
    // Allocate memory and read in the file.
    //
    pFileData = SpMemAlloc(ulLen);

    Status = ZwReadFile(Handle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        pFileData,
                        ulLen,
                        0,
                        NULL
                        );

    ZwClose(Handle);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPatchBootIni could not ZwReadFile: %lx\n", Status));
        goto Cleanup;
    }


    //
    // Allocate memory for the new copy of the file (we use twice the
    // current size as a worst-case scenario).
    //

    pNewFileData = SpMemAlloc(ulLen * 2);
    memcpy(pNewFileData, pFileData, ulLen);
    pNewFileData[ulLen] = '\0';   // NULL-terminate to make replace easier.

    //
    // Run through each line of the file, looking for ARC names to
    // replace. ARC names are either after the "default=" text or
    // else they start a line.
    //

    curLoc = pNewFileData;

    while (TRUE) {

        BOOLEAN replaced = FALSE;
        LONG adjustment;

        //
        // Replace if this is a "default=" line, or a line that does not
        // start with "timeout=" or a '['.
        //

        if (RtlCompareMemory(curLoc, "default=", strlen("default=")) == strlen("default=")) {
            SpReplaceArcName(curLoc + strlen("default="), pMemoryData, &replaced);
        } else if ((*curLoc != '[') &&
                   (RtlCompareMemory(curLoc, "timeout=", strlen("timeout=")) != strlen("timeout="))) {
            SpReplaceArcName(curLoc, pMemoryData, &replaced);
        }

        if (replaced) {
            changedFile = TRUE;
        }

        //
        // Look for a '\n' in the file.
        //

        endOfLine = strchr(curLoc, '\n');
        if (endOfLine == NULL) {
            break;
        }

        curLoc = endOfLine + 1;

        if (*curLoc == L'\0') {
            break;
        }
    }

    //
    // If we changed the file, write out the new one.
    //

    if (changedFile) {

        //
        // Replace the old boot.ini with the new one.
        //

        TmpBootIni = SpDupStringW(BootIniPath);

        if (!TmpBootIni) {
            goto Cleanup;
        }

        TmpBootIni[wcslen(TmpBootIni)-1] = L'$';   // make it boot.in$

        INIT_OBJA(&Obja, &UnicodeString, TmpBootIni);

        Status = ZwCreateFile(&Handle,
                              FILE_GENERIC_WRITE,
                              &Obja,
                              &IoStatusBlock,
                              NULL,
                              FILE_ATTRIBUTE_NORMAL,
                              0,    // no sharing
                              FILE_OVERWRITE_IF,
                              FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_WRITE_THROUGH,
                              NULL,
                              0
                             );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPatchBootIni could not create %ws: %lx\n", TmpBootIni, Status));
            goto Cleanup;
        }

        Status = ZwWriteFile(Handle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            pNewFileData,
                            strlen(pNewFileData),
                            NULL,
                            NULL
                            );

        ZwClose(Handle);

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPatchBootIni could not ZwWriteFile: %lx\n", Status));
            goto Cleanup;
        }


        //
        // Now that we have written the tmp file, do the swap.
        //

        Status = SpDeleteFile(BootIniPath, NULL, NULL);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPatchBootIni could not SpDeleteFile(%ws): %lx\n", BootIniPath, Status));
            goto Cleanup;
        }

        Status = SpRenameFile(TmpBootIni, BootIniPath, FALSE);

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPatchBootIni could not SpRenameFile(%ws,%ws): %lx\n", TmpBootIni, BootIniPath, Status));
            goto Cleanup;
        }

    }

Cleanup:

    if (pFileData != NULL) {
        SpMemFree(pFileData);
    }

    if (pNewFileData != NULL) {
        SpMemFree(pNewFileData);
    }

    if (TmpBootIni != NULL) {
        SpMemFree(TmpBootIni);
    }

    return Status;

}

NTSTATUS
SpCopyNicFiles(
    IN PWCHAR SetupPath,
    IN PWCHAR DestPath
    )

/*++

Routine Description:

    This routine packages up information and sends it to the BINL server, getting back
    a list of files to copy to support the given NIC. It then copies those files.

Arguments:

    SetupPath - Setup path that supports the SysPrep image.

    DestPath - Path to the winnt directory.

Return Value:

    The NTSTATUS of the operation.

--*/
{
    PSPUDP_PACKET pUdpPacket = NULL;
    WCHAR UNALIGNED * pPacketEnd;
    PSP_NETCARD_INFO_REQ pReqPacket;
    PSP_NETCARD_INFO_RSP pRspPacket;
    ULONG PacketSize;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG i,j;
    PWCHAR pSrc, pDst, pTmp;
    WCHAR SrcFqn[MAX_PATH];
    WCHAR DstFqn[MAX_PATH];

    //
    // BINL expects the path to be a UNC w/o the architecture type, so take the current
    // setup path, in the form of "\device\lanmanredirector\server\share\...\i386" and
    // make it "\\server\share\..."
    //
    // First remove the architecture type, and the the leading stuff.
    //
    wcscpy(SrcFqn, SetupPath);

    pTmp = &(SrcFqn[wcslen(SrcFqn)]);

    while ((*pTmp != L'\\') && (pTmp != SrcFqn)) {
        pTmp--;
    }

    if (*pTmp == L'\\') {
        *pTmp = UNICODE_NULL;
    }

    pTmp = SrcFqn;
    pTmp++;
    while ((*pTmp != UNICODE_NULL) && (*pTmp != L'\\')) {
        pTmp++;
    }
    if (*pTmp == L'\\') {
        pTmp++;
    }
    while ((*pTmp != UNICODE_NULL) && (*pTmp != L'\\')) {
        pTmp++;
    }
    if (*pTmp == L'\\') {
        pTmp--;
        *pTmp = L'\\';
    }

    //
    // Allocate the packet
    //
    PacketSize = FIELD_OFFSET(SPUDP_PACKET, Data[0]) +
                 FIELD_OFFSET(SP_NETCARD_INFO_REQ, SetupPath[0]) +
                 (wcslen(pTmp) + 1) * sizeof(WCHAR);

    pUdpPacket = (PSPUDP_PACKET)SpMemAllocNonPagedPool(PacketSize);

    //
    // Fill in the packet
    //
    RtlCopyMemory(&(pUdpPacket->Signature[0]), SetupRequestSignature, 4);
    pUdpPacket->Length = PacketSize - FIELD_OFFSET(SPUDP_PACKET, RequestType);
    pUdpPacket->RequestType = 0;
    pUdpPacket->Status = STATUS_SUCCESS;
    pUdpPacket->SequenceNumber = 1;
    pUdpPacket->FragmentNumber = 1;
    pUdpPacket->FragmentTotal = 1;

    pReqPacket = (PSP_NETCARD_INFO_REQ)(&(pUdpPacket->Data[0]));
    pReqPacket->Version = OSCPKT_NETCARD_REQUEST_VERSION;
    RtlCopyMemory(&(pReqPacket->CardInfo), &RemoteSysPrepNetCardInfo, sizeof(NET_CARD_INFO));
    wcscpy(&(pReqPacket->SetupPath[0]), pTmp);

#if defined(_AMD64_)
    pReqPacket->Architecture = PROCESSOR_ARCHITECTURE_AMD64;
#elif defined(_IA64_)
    pReqPacket->Architecture = PROCESSOR_ARCHITECTURE_IA64;
#elif defined(_X86_)
    pReqPacket->Architecture = PROCESSOR_ARCHITECTURE_INTEL;
#else
#error "No Target Architecture"
#endif


    //
    // Open the Udp stack
    //
    Status = SpUdpConnect();

    if (!NT_SUCCESS(Status)) {
        goto CleanUp;
    }


    //
    // Send the request
    //
    Status = SpUdpSendAndReceiveDatagram(pUdpPacket,
                                         PacketSize,
                                         RemoteServerIpAddress,
                                         BINL_DEFAULT_PORT,
                                         SpSysPrepNicRcvFunc
                                        );

    SpUdpDisconnect();

    if (!NT_SUCCESS(Status)) {
        goto CleanUp;
    }

    //
    // Get the received packet
    //
    SpMemFree(pUdpPacket);
    pUdpPacket = (PSPUDP_PACKET)pGlobalResponsePacket;

    Status = pUdpPacket->Status;

    if (!NT_SUCCESS(Status)) {
        goto CleanUp;
    }

    if (GlobalResponsePacketLength <
        (ULONG)(FIELD_OFFSET(SPUDP_PACKET, Data[0]) + FIELD_OFFSET(SP_NETCARD_INFO_RSP, MultiSzFiles[0]))) {
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }

    pRspPacket = (PSP_NETCARD_INFO_RSP)(&(pUdpPacket->Data[0]));
    pPacketEnd = (WCHAR UNALIGNED *)(((PUCHAR)pGlobalResponsePacket) + GlobalResponsePacketLength);

    //
    // Now copy each file
    //
    pTmp = &(pRspPacket->MultiSzFiles[0]);
    for (i = 0; i < pRspPacket->cFiles;) {

        i++;

        if (pTmp >= pPacketEnd) {
            Status = STATUS_INVALID_PARAMETER;
            goto CleanUp;
        }

        
        //
        // Be careful about reading this data, since it's come in over the
        // network.  ie., make sure that the string length is reasonable
        // before proceeding with processing the string.
        //
        pSrc = pTmp;

        try {            
            j = wcslen(pSrc);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            j = sizeof(SrcFqn)/sizeof(WCHAR) + 1;
        }

        
        if (j + wcslen(SetupPath) + 1 > sizeof(SrcFqn)/sizeof(WCHAR)) {
            Status = STATUS_INVALID_PARAMETER;
            goto CleanUp;
        }

        pDst = pTmp = pSrc + j + 1;
        if (pTmp >= pPacketEnd) {
            Status = STATUS_INVALID_PARAMETER;
            goto CleanUp;
        }
        wcscpy(SrcFqn, SetupPath);
        SpConcatenatePaths(SrcFqn, pSrc);

        wcscpy(DstFqn, DestPath);

        if (i == pRspPacket->cFiles) {  // the last file in the list is the INF
            SpConcatenatePaths(DstFqn, L"inf");
        } else {                        // all the others go in system32\drivers
            SpConcatenatePaths(DstFqn, L"system32\\drivers");
        }

        if (*pDst != UNICODE_NULL) {
            try {            
                j = wcslen(pDst);
            } except(EXCEPTION_EXECUTE_HANDLER) {
                j = sizeof(DstFqn)/sizeof(WCHAR) + 1;
            }

            if (j+wcslen(DstFqn)+1 > sizeof(DstFqn)/sizeof(WCHAR)) {
                Status = STATUS_INVALID_PARAMETER;
                goto CleanUp;
            }

            pTmp = pDst + j + 1;
            if (pTmp >= pPacketEnd) {
                Status = STATUS_INVALID_PARAMETER;
                goto CleanUp;
            }

            SpConcatenatePaths(DstFqn, pDst);
        } else {
            SpConcatenatePaths(DstFqn, pSrc);
            pTmp = pDst + 1;
        }

        Status = SpCopyFileUsingNames(SrcFqn, DstFqn, 0, COPY_DECOMPRESS_SYSPREP );

        if (!NT_SUCCESS(Status)) {
            goto CleanUp;
        }

    }


CleanUp:

    if (pUdpPacket != NULL) {
        SpMemFree(pUdpPacket);
    }

    return Status;
}

NTSTATUS
SpSysPrepNicRcvFunc(
    PVOID DataBuffer,
    ULONG DataBufferLength
    )

/*++

Routine Description:

    This routine receives datagrams from the server into the global variable
    pGlobalResponsePacket, iff it is NULL, otherwise it is presumed to hold data
    and the incoming packet is assumed to be a duplicate response packet.

    NOTE: spudp.c guarantees singly-threaded callbacks, so we don't have to spin lock
    here.

Arguments:

    DataBuffer - The incoming data.

    DataBufferLength - Length of the data in bytes.

Return Value:

    The NTSTATUS of the operation.

--*/

{
    PSPUDP_PACKET pUdpPacket;
    WCHAR UNALIGNED * pPacketEnd;

    if ((pGlobalResponsePacket != NULL) || (DataBufferLength == 0)) {
        return STATUS_UNSUCCESSFUL;
    }

    pUdpPacket = (PSPUDP_PACKET)DataBuffer;

    if (RtlCompareMemory(&(pUdpPacket->Signature[0]), SetupResponseSignature, 4) != 4) {
        return STATUS_UNSUCCESSFUL;
    }

    pGlobalResponsePacket = SpMemAlloc(DataBufferLength + sizeof(WCHAR));

    RtlCopyMemory(pGlobalResponsePacket, DataBuffer, DataBufferLength);
    pPacketEnd = (WCHAR UNALIGNED *)(((PUCHAR)pGlobalResponsePacket) + DataBufferLength);
    *pPacketEnd = L'\0';  // NULL-terminate it
    GlobalResponsePacketLength = DataBufferLength;

    return STATUS_SUCCESS;
}

VOID
SpSysPrepFailure(
    ULONG ReasonNumber,
    PVOID Parameter1,
    PVOID Parameter2
    )

/*++

Routine Description:

    Inform the user that we were unable to bring down the sysprep image
    correctly.

    This is a fatal condition.

Arguments:

    None.

Return Value:

    Does not return.

--*/

{
    ULONG ValidKeys[2] = { KEY_F3, 0 };
    PWCHAR MessageText = NULL;
    WCHAR blankMessage[1];

    if (ReasonNumber > 0) {

        // Get the message text.
        //

        if (Parameter1 == NULL) {

            MessageText = SpRetreiveMessageText(NULL,ReasonNumber,NULL,0);

        } else {

            SpFormatMessage(  TemporaryBuffer,
                              sizeof(TemporaryBuffer),
                              ReasonNumber,
                              Parameter1,
                              Parameter2
                              );

            MessageText = SpDupStringW(TemporaryBuffer);
        }
        if (MessageText == NULL) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpSysPrepFailure: SpRetreiveMessageText %u returned NULL\n",ReasonNumber));
        }
    }

    if (MessageText == NULL) {

        blankMessage[0] = L'\0';
        MessageText = &blankMessage[0];
    }

    CLEAR_CLIENT_SCREEN();

    SpStartScreen(  SP_SCRN_SYSPREP_FATAL_FAILURE,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE,
                    MessageText
                    );

    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);

    SpWaitValidKey(ValidKeys,NULL,NULL);

    SpDone(0,FALSE,FALSE);
}


NTSTATUS
SpSysPrepSetShortFileName (
    PWCHAR Source,
    PWCHAR Dest
    )

/*++

Routine Description:

    Try to set the short filename out of the sysprep image.
    
    This should be considered non-fatal if it fails since not all
    files will have this information set for them.   

Arguments:

    Source :

Return Value:

    The status code from setting the info.  May not return if we hit a failure
    and the user specifies to abort the setup.

--*/


{
    ULONG stringLength = 0;
    ULONG FileNameInformationLength = 0;
    PWCHAR fullName = NULL;
    PWCHAR SFNBuffer = NULL;
    
    HANDLE sourceHandle = NULL;
    HANDLE streamHandle = NULL;
    HANDLE destHandle = NULL;

    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    MIRROR_SFN_STREAM mirrorHeader;
    
    LARGE_INTEGER byteOffset;
    ULONG bytesRead;
    

    BOOLEAN haveSFN = FALSE;
    BOOLEAN haveStream = FALSE;
    BOOLEAN haveSourceAttributes = FALSE;

    PFILE_NAME_INFORMATION FileNameInformation;

    if ((Source == NULL) || (Dest == NULL)) {

        return STATUS_SUCCESS;
    }

    // alloc a buffer to hold the full file of the source including stream

    while (*(Source+stringLength) != L'\0') {
        stringLength++;
    }
    stringLength += sizeof( IMIRROR_SFN_STREAM_NAME ) + 1;      // + 1 for size of null
    stringLength *= sizeof(WCHAR);

    fullName = SpMemAlloc( stringLength );
    if (!fullName) {
        Status = STATUS_SUCCESS;
        goto exit;
    }

    wcscpy( fullName, Source );
    wcscat( fullName, IMIRROR_SFN_STREAM_NAME );

    //
    // Open the source stream.
    //

    INIT_OBJA(&Obja,&UnicodeString,fullName);

    Status = ZwCreateFile(
                &streamHandle,
                GENERIC_READ | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                NULL,
                0,
                FILE_SHARE_READ,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_SEQUENTIAL_ONLY,
                NULL,
                0
                );

    if ( ! NT_SUCCESS(Status) ) {

        //
        //  for now, if a directory or file doesn't have our stream, it's ok.
        //  we'll just skip it.
        //

        Status = STATUS_SUCCESS;
        goto exit;
    }

    byteOffset.QuadPart = 0;

    Status = ZwReadFile(streamHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        (PCHAR) &mirrorHeader,
                        sizeof( mirrorHeader ),
                        &byteOffset,
                        NULL
                        );

    if (!NT_SUCCESS(Status) ||
        (IoStatusBlock.Information < sizeof( mirrorHeader ))) {

        //
        // we can't read the header correctly.  just skip setting SFN.
        //
        Status = STATUS_SUCCESS;
        goto exit;

    }
    if (mirrorHeader.StreamVersion != IMIRROR_SFN_STREAM_VERSION) {

        //
        //  we can't read the header correctly.  just skip setting SFN.
        //
        Status = STATUS_SUCCESS;
        goto exit;
    }

    haveStream = TRUE;

    //
    //  allocate a buffer to hold the SFN.  The size is embedded in the header.
    //  take off room for the structure and tack on two for a UNICODE_NULL at 
    //  the end, just in case the stream doesn't have one.
    //

    if (mirrorHeader.StreamLength) {

        SFNBuffer = SpMemAlloc( mirrorHeader.StreamLength - sizeof(MIRROR_SFN_STREAM) + 2 );
        if (!SFNBuffer) {
            Status = STATUS_SUCCESS;
            goto exit;
        }

        byteOffset.QuadPart += sizeof( mirrorHeader );

        //
        //  now we read the SFN  since we know how long it is.
        //

        Status = ZwReadFile(streamHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            SFNBuffer,
                            mirrorHeader.StreamLength - sizeof(MIRROR_SFN_STREAM),
                            &byteOffset,
                            NULL
                            );

        if (!NT_SUCCESS(Status) ||
            (IoStatusBlock.Information < (mirrorHeader.StreamLength - sizeof(MIRROR_SFN_STREAM)))) {

            //
            //  oh joy, we can't read the SFN correctly
            //
            Status = STATUS_SUCCESS;
            goto exit;
        }

        haveSFN = TRUE;
        //
        // tack on a unicode NULL just in case.
        //
        SFNBuffer[(mirrorHeader.StreamLength - sizeof(MIRROR_SFN_STREAM))/sizeof(WCHAR)] = UNICODE_NULL;

    } else {
        ASSERT(FALSE);
        Status = STATUS_SUCCESS;
        goto exit;
    }

    INIT_OBJA(&Obja,&UnicodeString,Dest);
    
    Status = ZwCreateFile(
                &destHandle,
                FILE_READ_ATTRIBUTES |
                FILE_WRITE_ATTRIBUTES |
                FILE_READ_DATA |
                FILE_WRITE_DATA |
                DELETE,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_DIRECTORY,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT,
                NULL,
                0
                );

    if (!NT_SUCCESS(Status)) {
        
        //
        // Maybe it's not a directory...  Try for a file.
        //
        
        Status = ZwCreateFile(
                    &destHandle,
                    FILE_READ_ATTRIBUTES |
                    FILE_WRITE_ATTRIBUTES |
                    FILE_READ_DATA |
                    FILE_WRITE_DATA |
                    DELETE,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN,
                    FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT,
                    NULL,
                    0
                    );

              
        if( !NT_SUCCESS(Status) ) {
            Status = STATUS_SUCCESS;
            goto exit;
        }
    }


    FileNameInformationLength = FIELD_OFFSET(FILE_NAME_INFORMATION, FileName) + ((wcslen(SFNBuffer)+1)*sizeof(WCHAR));
    FileNameInformation = SpMemAlloc( FileNameInformationLength );

    if (FileNameInformation) {
        
        FileNameInformation->FileNameLength = wcslen(SFNBuffer) * sizeof(WCHAR);
        wcscpy( FileNameInformation->FileName, SFNBuffer );
        

        Status = ZwSetInformationFile(  destHandle,
                                        &IoStatusBlock,
                                        FileNameInformation,
                                        FileNameInformationLength,
                                        FileShortNameInformation
                                        );
        
        SpMemFree( FileNameInformation );
        
        // Keep quiet.
        Status = STATUS_SUCCESS;
    }
   
exit:
    if (fullName) {
        SpMemFree( fullName );
    }
    if (SFNBuffer) {
        SpMemFree( SFNBuffer );
    }
    if (streamHandle) {
        ZwClose( streamHandle );
    }
    if (sourceHandle) {
        ZwClose( sourceHandle );
    }
    if (destHandle) {
        ZwClose( destHandle );
    }

    return(Status);
}


NTSTATUS
SpSysPrepSetExtendedInfo (
    PWCHAR Source,
    PWCHAR Dest,
    BOOLEAN Directory,
    BOOLEAN RootDir
    )

/*++

Routine Description:

    Try to set the extended information out of the sysprep image.  This
    includes the acl and the compression info.  If we encounter an error,
    we may not only fail the operation but also reboot if the user chooses
    to abandon the setup.

Arguments:

    Source :

Return Value:

    The status code from setting the info.  May not return if we hit a failure
    and the user specifies to abort the setup.

--*/


{
    ULONG stringLength = 0;
    PWCHAR fullName = NULL;
    PWCHAR rootWithSlash = NULL;
    HANDLE sourceHandle = NULL;
    HANDLE streamHandle = NULL;
    HANDLE destHandle = NULL;
    PCHAR sdBuffer = NULL;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    MIRROR_ACL_STREAM mirrorHeader;
    LARGE_INTEGER byteOffset;
    ULONG bytesRead;
    ULONG ValidKeys[4] = { ASCI_ESC, KEY_F3, 0 };
    ULONG WarnKeys[2] = { KEY_F3, 0 };
    ULONG MnemonicKeys[] = { MnemonicContinueSetup, 0 };
    BOOLEAN haveSecurityDescriptor = FALSE;
    BOOLEAN haveStream = FALSE;
    BOOLEAN haveSourceAttributes = FALSE;
    FILE_BASIC_INFORMATION BasicFileInfo;
    USHORT CompressionState;

    if ((Source == NULL) || (Dest == NULL)) {

        return STATUS_SUCCESS;
    }

    if (!RootDir) {        
        SpSysPrepSetShortFileName(Source, Dest);
    }

    mirrorHeader.ExtendedAttributes = 0;

    // alloc a buffer to hold the full file of the source including stream

    while (*(Source+stringLength) != L'\0') {
        stringLength++;
    }
    stringLength += sizeof( IMIRROR_ACL_STREAM_NAME ) + 1;      // + 1 for size of null
    stringLength *= sizeof(WCHAR);

    fullName = SpMemAlloc( stringLength );

    wcscpy( fullName, Source );
    wcscat( fullName, IMIRROR_ACL_STREAM_NAME );

    //
    // Open the source stream.
    //

    INIT_OBJA(&Obja,&UnicodeString,fullName);

    Status = ZwCreateFile(
                &streamHandle,
                GENERIC_READ | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                NULL,
                0,
                FILE_SHARE_READ,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_SEQUENTIAL_ONLY,
                NULL,
                0
                );

    if ( ! NT_SUCCESS(Status) ) {

        //
        //  for now, if a directory or file doesn't have our stream, it's ok.
        //  we'll just copy the attributes from the source.
        //

        Status = STATUS_SUCCESS;
        goto setFileAttributes;
    }

    byteOffset.QuadPart = 0;

    Status = ZwReadFile(streamHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        (PCHAR) &mirrorHeader,
                        sizeof( mirrorHeader ),
                        &byteOffset,
                        NULL
                        );

    if (!NT_SUCCESS(Status) ||
        (IoStatusBlock.Information < sizeof( mirrorHeader ))) {

        //
        //  oh joy, we can't read the header correctly.  Let's ask the user
        //  if he wants to continue or abort.
        //

failSetInfo:
        SpStartScreen(
            SP_SCRN_SYSPREP_SETACL_FAILED,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            Dest
            );

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ESC_EQUALS_SKIP_FILE,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {

        case ASCI_ESC:      // skip file

            break;

        case KEY_F3:        // exit setup

            SpConfirmExit();
            goto failSetInfo;
        }

        CLEAR_CLIENT_SCREEN();

        //
        //  we're skipping the file, delete it if it's not a directory since
        //  it isn't correctly formed.
        //

        if (destHandle) {
            ZwClose( destHandle );
            destHandle = NULL;
        }

        if ( ! Directory ) {
            SpDeleteFile(Dest,NULL,NULL);
        } else {
            if (!RootDir) {
                SpDeleteFileEx( Dest, NULL, NULL,
                                FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                                FILE_OPEN_FOR_BACKUP_INTENT );
            }
        }

        return Status;
    }
    if (mirrorHeader.StreamVersion != IMIRROR_ACL_STREAM_VERSION) {

        //
        //  oh joy, we've hit a file we don't support.
        //
        goto failSetInfo;
    }

    haveStream = TRUE;

    //
    //  allocate a buffer to hold the security descriptor.
    //

    if (mirrorHeader.SecurityDescriptorLength) {

        sdBuffer = SpMemAlloc( mirrorHeader.SecurityDescriptorLength );

        byteOffset.QuadPart += sizeof( mirrorHeader );

        //
        //  now we read the security descriptor since we know how long it is.
        //

        Status = ZwReadFile(streamHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            sdBuffer,
                            mirrorHeader.SecurityDescriptorLength,
                            &byteOffset,
                            NULL
                            );

        if (!NT_SUCCESS(Status) ||
            (IoStatusBlock.Information < mirrorHeader.SecurityDescriptorLength)) {

            //
            //  oh joy, we can't read the SD correctly
            //
            goto failSetInfo;
        }

        haveSecurityDescriptor = TRUE;
    }
setFileAttributes:

    //
    //  we first open the source to get the file attributes and times that we're
    //  going to copy over to the dest.
    //

    INIT_OBJA(&Obja,&UnicodeString,Source);

    Status = ZwCreateFile(
                &sourceHandle,
                FILE_READ_ATTRIBUTES,
                &Obja,
                &IoStatusBlock,
                NULL,
                0,
                FILE_SHARE_READ,
                FILE_OPEN,
                Directory ? ( FILE_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT ) : FILE_NON_DIRECTORY_FILE,
                NULL,
                0
                );

    if ( NT_SUCCESS(Status) ) {

        Status = ZwQueryInformationFile(    sourceHandle,
                                            &IoStatusBlock,
                                            &BasicFileInfo,
                                            sizeof(BasicFileInfo),
                                            FileBasicInformation
                                            );
        if (NT_SUCCESS(Status)) {

            haveSourceAttributes = TRUE;
        }
    }

    //
    //  Now we open the target to write out the security descriptor and
    //  attributes.
    //

    if (RootDir) {

        //
        //  append a \ to the end of the dest path
        //

        stringLength = 0;
        while (*(Dest+stringLength) != L'\0') {
            stringLength++;
        }
        stringLength += 2;      // one for null, one for backslash
        stringLength *= sizeof(WCHAR);

        rootWithSlash = SpMemAlloc( stringLength );

        wcscpy( rootWithSlash, Dest );
        wcscat( rootWithSlash, L"\\" );

        INIT_OBJA(&Obja,&UnicodeString,rootWithSlash);

    } else {

        INIT_OBJA(&Obja,&UnicodeString,Dest);
    }

    Status = ZwCreateFile(
                &destHandle,
                WRITE_OWNER |
                    WRITE_DAC |
                    ACCESS_SYSTEM_SECURITY |
                    FILE_READ_ATTRIBUTES |
                    FILE_WRITE_ATTRIBUTES |
                    FILE_READ_DATA |
                    FILE_WRITE_DATA,
                &Obja,
                &IoStatusBlock,
                NULL,
                0,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0
                );

    if (!NT_SUCCESS(Status)) {

        //
        //  oh joy, we can't open the target correctly.
        //
        goto failSetInfo;
    }

    // NOTE: figure out what to do about reparse points and encrypted files

//  if (mirrorHeader.ExtendedAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
//  }
//  if (mirrorHeader.ExtendedAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
//  }

    if (mirrorHeader.ExtendedAttributes & FILE_ATTRIBUTE_COMPRESSED) {

        CompressionState = COMPRESSION_FORMAT_DEFAULT;

    } else {

        CompressionState = COMPRESSION_FORMAT_NONE;
    }

    try {
        Status = ZwFsControlFile(   destHandle,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_SET_COMPRESSION,
                                    &CompressionState,
                                    sizeof(CompressionState),
                                    NULL,
                                    0
                                    );
        if (Status == STATUS_INVALID_DEVICE_REQUEST) {

            //
            //  if this file system doesn't support compression for this
            //  object, we'll just ignore the error.
            //

            Status = STATUS_SUCCESS;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_IN_PAGE_ERROR;
    }

    if ( NT_SUCCESS(Status) && ! haveSourceAttributes ) {

        //
        //  if we don't have the source attributes, just grab them from the
        //  destination so that we have some attributes to manipulate.
        //

        Status = ZwQueryInformationFile(    destHandle,
                                            &IoStatusBlock,
                                            &BasicFileInfo,
                                            sizeof(BasicFileInfo),
                                            FileBasicInformation
                                            );
    }

    if (haveStream) {

        //
        //  If this file has our stream, use the stream fields as the overriding
        //  values.  They even override the source file's attributes on the server.
        //

        BasicFileInfo.FileAttributes = mirrorHeader.ExtendedAttributes;
        BasicFileInfo.ChangeTime.QuadPart = mirrorHeader.ChangeTime.QuadPart;
    }
    if ( NT_SUCCESS(Status) ) {

        if (Directory) {

            BasicFileInfo.FileAttributes |= FILE_ATTRIBUTE_DIRECTORY;

        } else if (BasicFileInfo.FileAttributes == 0) {

            BasicFileInfo.FileAttributes = FILE_ATTRIBUTE_NORMAL;
        }

        Status = ZwSetInformationFile(  destHandle,
                                        &IoStatusBlock,
                                        &BasicFileInfo,
                                        sizeof(BasicFileInfo),
                                        FileBasicInformation
                                        );
        if (Status == STATUS_INVALID_PARAMETER && RootDir) {

            //
            //  if this file system doesn't support setting attributes on the
            //  root of the volume, we'll ignore the error.
            //

            Status = STATUS_SUCCESS;
        }
    }

    if (!NT_SUCCESS(Status)) {

        //
        //  post a warning that we couldn't set it.  shouldn't be fatal.
        //

        SpStartScreen(
            SP_SCRN_SYSPREP_COPY_FAILURE,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            Status,
            Dest
            );

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_C_EQUALS_CONTINUE_SETUP,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        switch(SpWaitValidKey(WarnKeys,NULL,MnemonicKeys)) {

        case KEY_F3:        // exit setup

            SpConfirmExit();
            break;

        default:
            break;
        }
    }

    if (haveSecurityDescriptor) {
        try {

            // the state of the security descriptor is unknown, let's protect
            // ourselves

            Status = ZwSetSecurityObject( destHandle,
                                          OWNER_SECURITY_INFORMATION |
                                            GROUP_SECURITY_INFORMATION |
                                            DACL_SECURITY_INFORMATION |
                                            SACL_SECURITY_INFORMATION,
                                          (PSECURITY_DESCRIPTOR) sdBuffer
                                          );
        } except(EXCEPTION_EXECUTE_HANDLER) {
            Status = STATUS_IN_PAGE_ERROR;
        }

        if (!NT_SUCCESS(Status)) {

            //
            //  oh joy, we can't write the SD correctly.
            //
            goto failSetInfo;
        }
    }

// endSetExtended:
    if (rootWithSlash) {
        SpMemFree( rootWithSlash );
    }
    if (fullName) {
        SpMemFree( fullName );
    }
    if (sdBuffer) {
        SpMemFree( sdBuffer );
    }
    if (streamHandle) {
        ZwClose( streamHandle );
    }
    if (sourceHandle) {
        ZwClose( sourceHandle );
    }
    if (destHandle) {
        ZwClose( destHandle );
    }
    return STATUS_SUCCESS;
}

NTSTATUS
SpCopyEAsAndStreams (
    PWCHAR SourceFile,
    HANDLE SourceHandle OPTIONAL,
    PWCHAR TargetFile,
    HANDLE TargetHandle OPTIONAL,
    BOOLEAN Directory
    )
//
//  This copies the EAs and streams from the source to the target.  The
//  source and dest handles are specified for files and optional for
//  directories.
//
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG ValidKeys[4] = { ASCI_CR, ASCI_ESC, KEY_F3, 0 };
    FILE_EA_INFORMATION eaInfo;
    HANDLE tempSourceHandle = SourceHandle;
    HANDLE tempTargetHandle = TargetHandle;
    HANDLE StreamHandle;
    HANDLE newStreamHandle;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    ULONG StreamInfoSize = 4096-8; // alloc a whole page. spmemalloc reserves 8 bytes
    PFILE_STREAM_INFORMATION StreamInfoBase = NULL;
    PFILE_STREAM_INFORMATION StreamInfo;
    PUCHAR StreamBuffer = NULL;
    UNICODE_STRING StreamName;

retryCopyEAs:

    if (tempSourceHandle == NULL) {

        INIT_OBJA(&Obja,&UnicodeString,SourceFile);

        Status = ZwCreateFile(
                    &tempSourceHandle,
                    FILE_LIST_DIRECTORY | SYNCHRONIZE,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_DIRECTORY,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN_IF,
                    FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_ALERT | FILE_OPEN_FOR_BACKUP_INTENT,
                    NULL,
                    0
                    );

        if (!NT_SUCCESS(Status)) {
            goto EndCopyEAs;
        }
    }

    if (tempTargetHandle == NULL) {

        INIT_OBJA(&Obja,&UnicodeString,TargetFile);

        Status = ZwCreateFile(
                    &tempTargetHandle,
                    FILE_LIST_DIRECTORY | SYNCHRONIZE,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_DIRECTORY,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN_IF,
                    FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_ALERT | FILE_OPEN_FOR_BACKUP_INTENT,
                    NULL,
                    0
                    );

        if(!NT_SUCCESS(Status)) {
            goto EndCopyEAs;
        }
    }

    //
    //  EAs can be on either FAT or NTFS.
    //

    Status = ZwQueryInformationFile(    tempSourceHandle,
                                        &IoStatusBlock,
                                        &eaInfo,
                                        sizeof( eaInfo ),
                                        FileEaInformation
                                        );

    if (Status == STATUS_SUCCESS && eaInfo.EaSize > 0) {

        //
        // FileEaInformation, oddly enough, doesn't tell you how big a
        // buffer you need to retrieve the EAs. Instead, it tells you
        // how much room the EAs take up on the disk (in OS/2 format)!
        // So we use the OS/2 size as a rough approximation of how large
        // a buffer we need.
        //

        ULONG actualEaSize = eaInfo.EaSize;
        PCHAR eaBuffer;

        do {
            actualEaSize *= 2;
            eaBuffer = SpMemAlloc( actualEaSize );

            Status = ZwQueryEaFile( tempSourceHandle,
                                    &IoStatusBlock,
                                    eaBuffer,
                                    actualEaSize,
                                    FALSE,
                                    NULL,
                                    0,
                                    NULL,
                                    TRUE );

            if ( !NT_SUCCESS(Status) ) {
                SpMemFree( eaBuffer );
                IoStatusBlock.Information = 0;
            }

        } while ( (Status == STATUS_BUFFER_OVERFLOW) ||
                  (Status == STATUS_BUFFER_TOO_SMALL) );

        actualEaSize = (ULONG)IoStatusBlock.Information;

        if (NT_SUCCESS( Status )) {

            Status = ZwSetEaFile(   tempTargetHandle,
                                    &IoStatusBlock,
                                    eaBuffer,
                                    actualEaSize
                                    );
        }
        SpMemFree( eaBuffer );

        if (! NT_SUCCESS( Status )) {
            goto EndCopyEAs;
        }
    }

    //
    //  Streams are only on NTFS and they're also only on files, not directories.
    //

    if (( RemoteSysPrepVolumeIsNtfs != TRUE ) || Directory ) {

        goto EndCopyEAs;
    }

    do {
        if (StreamInfoBase == NULL) {
            StreamInfoBase = SpMemAlloc( StreamInfoSize );
        }
        Status = ZwQueryInformationFile(
                    tempSourceHandle,
                    &IoStatusBlock,
                    (PVOID) StreamInfoBase,
                    StreamInfoSize,
                    FileStreamInformation
                    );
        if ( !NT_SUCCESS(Status) ) {
            SpMemFree( StreamInfoBase );
            StreamInfoBase = NULL;
            StreamInfoSize *= 2;
        }
    } while ( Status == STATUS_BUFFER_OVERFLOW ||
              Status == STATUS_BUFFER_TOO_SMALL );

    if ( NT_SUCCESS(Status) && IoStatusBlock.Information ) {

        StreamInfo = StreamInfoBase;

        for (;;) {

            PWCHAR streamPtr;
            USHORT remainingLength;
            PWCHAR streamName;

            //
            // Build a string descriptor for the name of the stream.
            //

            StreamName.Buffer = &StreamInfo->StreamName[0];
            StreamName.Length = (USHORT) StreamInfo->StreamNameLength;
            StreamName.MaximumLength = StreamName.Length;

            streamPtr = StreamName.Buffer;

            if ((StreamName.Length > 0) && *streamPtr == L':') {

                streamPtr++;    // skip leading ":"
                streamName = streamPtr;     // remember start of stream name
                remainingLength = StreamName.Length - sizeof(WCHAR);

                while (remainingLength > 0 && *streamPtr != L':') {
                    streamPtr++;
                    remainingLength -= sizeof(WCHAR);
                }

                if (remainingLength > 0) {

                    if ((remainingLength == (sizeof(L":$DATA")-sizeof(WCHAR))) &&
                        (RtlCompareMemory( streamPtr, L":$DATA", remainingLength )
                            == remainingLength)) {

                        //
                        //  the attribute type on this is of type data so we
                        //  have a data stream here.  Now check that it is not
                        //  the unnamed primary data stream and our own acl stream
                        //  or the short file name stream.
                        //
                        if ((*streamName != L':') &&
                            ((RtlCompareMemory(StreamName.Buffer,
                                              IMIRROR_ACL_STREAM_NAME,
                                              (sizeof(IMIRROR_ACL_STREAM_NAME)-sizeof(WCHAR)))
                                             != (sizeof(IMIRROR_ACL_STREAM_NAME)-sizeof(WCHAR))) &&
                             (RtlCompareMemory(StreamName.Buffer,
                                              IMIRROR_SFN_STREAM_NAME,
                                              (sizeof(IMIRROR_SFN_STREAM_NAME)-sizeof(WCHAR)))
                                             != (sizeof(IMIRROR_SFN_STREAM_NAME)-sizeof(WCHAR))))) {
                            //
                            //  allocate a buffer to hold the stream data.
                            //  Can't use TemporaryBuffer as it's used by
                            //  SpCopyDirRecursiveCallback et al.
                            //

                            if (StreamBuffer == NULL) {
                                StreamBuffer = SpMemAlloc( StreamInfoSize );
                            }

                            //
                            //  we chop off the ":DATA" suffix from the stream name
                            //

                            StreamName.Length -= remainingLength;

                            //
                            // Open the source stream.
                            //

                            InitializeObjectAttributes(
                                &Obja,
                                &StreamName,
                                0,
                                tempSourceHandle,
                                NULL
                                );
                            Status = ZwCreateFile(
                                        &StreamHandle,
                                        GENERIC_READ | SYNCHRONIZE,
                                        &Obja,
                                        &IoStatusBlock,
                                        NULL,
                                        0,
                                        FILE_SHARE_READ,
                                        FILE_OPEN,
                                        FILE_SYNCHRONOUS_IO_NONALERT,
                                        NULL,
                                        0
                                        );
                            if ( ! NT_SUCCESS(Status) ) {
                                break;
                            }

                            //
                            // Open the source stream.
                            //

                            InitializeObjectAttributes(
                                &Obja,
                                &StreamName,
                                0,
                                tempTargetHandle,
                                NULL
                                );
                            Status = ZwCreateFile(
                                        &newStreamHandle,
                                        GENERIC_WRITE,
                                        &Obja,
                                        &IoStatusBlock,
                                        NULL,
                                        0,
                                        FILE_SHARE_READ,
                                        FILE_CREATE,
                                        FILE_SYNCHRONOUS_IO_NONALERT,
                                        NULL,
                                        0
                                        );
                            if ( NT_SUCCESS(Status) ) {

                                LARGE_INTEGER byteOffset;
                                ULONG bytesRead;

                                byteOffset.QuadPart = 0;

                                while (NT_SUCCESS(Status)) {

                                    Status = ZwReadFile(StreamHandle,
                                                        NULL,
                                                        NULL,
                                                        NULL,
                                                        &IoStatusBlock,
                                                        StreamBuffer,
                                                        StreamInfoSize,
                                                        &byteOffset,
                                                        NULL
                                                        );

                                    if ( ! NT_SUCCESS(Status) ) {

                                        if (Status == STATUS_END_OF_FILE) {
                                            Status = STATUS_SUCCESS;
                                        }
                                        break;
                                    }
                                    bytesRead = (ULONG)IoStatusBlock.Information;
                                    try {
                                        Status = ZwWriteFile(newStreamHandle,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             &IoStatusBlock,
                                                             StreamBuffer,
                                                             bytesRead,
                                                             &byteOffset,
                                                             NULL
                                                             );
                                    } except(EXCEPTION_EXECUTE_HANDLER) {
                                        Status = STATUS_IN_PAGE_ERROR;
                                    }
                                    byteOffset.QuadPart += bytesRead;
                                }
                                ZwClose(newStreamHandle);
                            }
                            ZwClose(StreamHandle);
                        }
                    }
                }
            }

            if ( NT_SUCCESS(Status) && StreamInfo->NextEntryOffset ) {
                StreamInfo = (PFILE_STREAM_INFORMATION)((PCHAR) StreamInfo + StreamInfo->NextEntryOffset);
            } else {
                break;
            }
        }
    }
EndCopyEAs:

    if (tempSourceHandle != NULL && SourceHandle == NULL) {
        ZwClose( tempSourceHandle );
    }
    if (tempTargetHandle != NULL && TargetHandle == NULL) {
        ZwClose( tempTargetHandle );
    }
    if (!NT_SUCCESS(Status)) {

        //
        //  this failed.  let's ask the user if he wants to retry, skip, or
        //  abort.
        //
repaint:
        SpStartScreen(
            SP_SCRN_COPY_FAILED,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            TargetFile
            );

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_RETRY,
            SP_STAT_ESC_EQUALS_SKIP_FILE,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {

        case ASCI_CR:       // retry

            SpCopyFilesScreenRepaint(SourceFile,TargetFile,TRUE);
            goto retryCopyEAs;

        case ASCI_ESC:      // skip file

            break;

        case KEY_F3:        // exit setup

            SpConfirmExit();
            goto repaint;
        }

        //
        //  we're skipping the file, delete it if it's not a directory since
        //  it isn't correctly formed.
        //

        if ( ! Directory ) {
            SpDeleteFile(TargetFile,NULL,NULL);
        }

        //
        // Need to completely repaint gauge, etc.
        //
        SpCopyFilesScreenRepaint(SourceFile,TargetFile,TRUE);
    }
    if (StreamInfoBase != NULL) {
       SpMemFree(StreamInfoBase);
    }
    if (StreamBuffer != NULL) {
        SpMemFree(StreamBuffer);
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spterm.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spterm.c

Abstract:

    Text setup support for terminals

Author:

    Sean Selitrennikoff (v-seans) 25-May-1999

Revision History:

--*/



#include "spprecmp.h"
#include "ntddser.h"
#pragma hdrstop
#include <hdlsblk.h>
#include <hdlsterm.h>

#define MS_DSRCTSCD 0xB0            // Status bits for DSR, CTS and CD



BOOLEAN HeadlessTerminalConnected = FALSE;
UCHAR Utf8ConversionBuffer[80*3+1];
PUCHAR TerminalBuffer = Utf8ConversionBuffer;
WCHAR UnicodeScratchBuffer[80+1];

//
// Use these variables to decode incoming UTF8
// data streams.
//
WCHAR IncomingUnicodeValue;
UCHAR IncomingUtf8ConversionBuffer[3];


//
// Determine if we will do UTF8 encoding before we send the string off
// to the headless terminal.
//
BOOLEAN SpTermDoUtf8 = FALSE;


//
// Reverse lookup table for the odd-ball unicode line drawing
// characters they use for JPN builds.  If we detect one of these
// we need to convert it into real unicode before we UTF8
// encode it.
//

typedef struct _UNICODE_CROSS_REFERENCE {

            //
            // Whacky far east unicode value.  For example, we
            // might get 0x0006 for a double-horizontal line, which
            // is just nonsense.
            //
    WCHAR   FECode;

            //
            // The corresponding real unicode value.
            //
    WCHAR   Unicode;
} UNICODE_CROSS_REFERENCE;

UNICODE_CROSS_REFERENCE FEUnicodeToRealUnicodeValue[LineCharMax]  = {

    0x0001, 0x2554,     // DoubleUpperLeft
    0x0002, 0x2557,     // DoubleUpperRight
    0x0003, 0x255a,     // DoubleLowerLeft
    0x0004, 0x255d,     // DoubleLowerRight
    0x0006, 0x2550,     // DoubleHorizontal
    0x0005, 0x2551,     // DoubleVertical
    0x0001, 0x250c,     // SingleUpperLeft
    0x0002, 0x2510,     // SingleUpperRight
    0x0003, 0x2514,     // SingleLowerLeft
    0x0004, 0x2518,     // SingleLowerRight
    0x0006, 0x2500,     // SingleHorizontal
    0x0005, 0x2502,     // SingleVertical
    0x0019, 0x255f,     // DoubleVerticalToSingleHorizontalRight,
    0x0017, 0x2562      // DoubleVerticalToSingleHorizontalLeft
};

BOOLEAN
SpTranslateUnicodeToUtf8(
    PCWSTR SourceBuffer,
    UCHAR  *DestinationBuffer
    )
/*++

Routine Description:

    translates a unicode buffer into a UTF8 version.

Arguments:

    SourceBuffer - unicode buffer to be translated.
    DestinationBuffer - receives UTF8 version of same buffer.

Return Value:

    TRUE - We successfully translated the Unicode value into its
           corresponding UTF8 encoding.

    FALSE - The translation failed.

--*/

{
    ULONG   Count = 0;
    ULONG   i = 0;
    WCHAR   CurrentChar = 0;
    //
    // convert into UTF8 for actual transmission
    //
    // UTF-8 encodes 2-byte Unicode characters as follows:
    // If the first nine bits are zero (00000000 0xxxxxxx), encode it as one byte 0xxxxxxx
    // If the first five bits are zero (00000yyy yyxxxxxx), encode it as two bytes 110yyyyy 10xxxxxx
    // Otherwise (zzzzyyyy yyxxxxxx), encode it as three bytes 1110zzzz 10yyyyyy 10xxxxxx
    //
    DestinationBuffer[Count] = (UCHAR)'\0';
    while (*SourceBuffer) {

        CurrentChar = *SourceBuffer;

        if( CurrentChar < 0x0020 ) {
            //
            // See if we need to convert this FarEast whacky unicode value into a real
            // unicode encoding.
            //
            for (i = 0; i < LineCharMax; i++) {
                if( FEUnicodeToRealUnicodeValue[i].FECode == CurrentChar ) {
                    CurrentChar = FEUnicodeToRealUnicodeValue[i].Unicode;
                    break;
                }
            }
        }



        if( (CurrentChar & 0xFF80) == 0 ) {
            //
            // if the top 9 bits are zero, then just
            // encode as 1 byte.  (ASCII passes through unchanged).
            //
            DestinationBuffer[Count++] = (UCHAR)(CurrentChar & 0x7F);
        } else if( (CurrentChar & 0xF800) == 0 ) {
            //
            // if the top 5 bits are zero, then encode as 2 bytes
            //
            DestinationBuffer[Count++] = (UCHAR)((CurrentChar >> 6) & 0x1F) | 0xC0;
            DestinationBuffer[Count++] = (UCHAR)(CurrentChar & 0xBF) | 0x80;
        } else {
            //
            // encode as 3 bytes
            //
            DestinationBuffer[Count++] = (UCHAR)((CurrentChar >> 12) & 0xF) | 0xE0;
            DestinationBuffer[Count++] = (UCHAR)((CurrentChar >> 6) & 0x3F) | 0x80;
            DestinationBuffer[Count++] = (UCHAR)(CurrentChar & 0xBF) | 0x80;
        }
        SourceBuffer += 1;
    }

    DestinationBuffer[Count] = (UCHAR)'\0';

    return(TRUE);

}




BOOLEAN
SpTranslateUtf8ToUnicode(
    UCHAR  IncomingByte,
    UCHAR  *ExistingUtf8Buffer,
    WCHAR  *DestinationUnicodeVal
    )
/*++

Routine Description:

    Takes IncomingByte and concatenates it onto ExistingUtf8Buffer.
    Then attempts to decode the new contents of ExistingUtf8Buffer.

Arguments:

    IncomingByte -          New character to be appended onto
                            ExistingUtf8Buffer.


    ExistingUtf8Buffer -    running buffer containing incomplete UTF8
                            encoded unicode value.  When it gets full,
                            we'll decode the value and return the
                            corresponding Unicode value.

                            Note that if we *do* detect a completed UTF8
                            buffer and actually do a decode and return a
                            Unicode value, then we will zero-fill the
                            contents of ExistingUtf8Buffer.


    DestinationUnicodeVal - receives Unicode version of the UTF8 buffer.

                            Note that if we do *not* detect a completed
                            UTF8 buffer and thus can not return any data
                            in DestinationUnicodeValue, then we will
                            zero-fill the contents of DestinationUnicodeVal.


Return Value:

    TRUE - We received a terminating character for our UTF8 buffer and will
           return a decoded Unicode value in DestinationUnicode.

    FALSE - We haven't yet received a terminating character for our UTF8
            buffer.

--*/

{
//    ULONG Count = 0;
    ULONG i = 0;
    BOOLEAN ReturnValue = FALSE;



    //
    // Insert our byte into ExistingUtf8Buffer.
    //
    i = 0;
    do {
        if( ExistingUtf8Buffer[i] == 0 ) {
            ExistingUtf8Buffer[i] = IncomingByte;
            break;
        }

        i++;
    } while( i < 3 );

    //
    // If we didn't get to actually insert our IncomingByte,
    // then someone sent us a fully-qualified UTF8 buffer.
    // This means we're about to drop IncomingByte.
    //
    // Drop the zero-th byte, shift everything over by one
    // and insert our new character.
    //
    // This implies that we should *never* need to zero out
    // the contents of ExistingUtf8Buffer unless we detect
    // a completed UTF8 packet.  Otherwise, assume one of
    // these cases:
    // 1. We started listening mid-stream, so we caught the
    //    last half of a UTF8 packet.  In this case, we'll
    //    end up shifting the contents of ExistingUtf8Buffer
    //    until we detect a proper UTF8 start byte in the zero-th
    //    position.
    // 2. We got some garbage character, which would invalidate
    //    a UTF8 packet.  By using the logic below, we would
    //    end up disregarding that packet and waiting for
    //    the next UTF8 packet to come in.
    if( i >= 3 ) {
        ExistingUtf8Buffer[0] = ExistingUtf8Buffer[1];
        ExistingUtf8Buffer[1] = ExistingUtf8Buffer[2];
        ExistingUtf8Buffer[2] = IncomingByte;
    }





    //
    // Attempt to convert the UTF8 buffer
    //
    // UTF8 decodes to Unicode in the following fashion:
    // If the high-order bit is 0 in the first byte:
    //      0xxxxxxx yyyyyyyy zzzzzzzz decodes to a Unicode value of 00000000 0xxxxxxx
    //
    // If the high-order 3 bits in the first byte == 6:
    //      110xxxxx 10yyyyyy zzzzzzzz decodes to a Unicode value of 00000xxx xxyyyyyy
    //
    // If the high-order 3 bits in the first byte == 7:
    //      1110xxxx 10yyyyyy 10zzzzzz decodes to a Unicode value of xxxxyyyy yyzzzzzz
    //
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpTranslateUtf8ToUnicode - About to decode the UTF8 buffer.\n" ));
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "                                  UTF8[0]: 0x%02lx UTF8[1]: 0x%02lx UTF8[2]: 0x%02lx\n",
                                                   ExistingUtf8Buffer[0],
                                                   ExistingUtf8Buffer[1],
                                                   ExistingUtf8Buffer[2] ));

    if( (ExistingUtf8Buffer[0] & 0x80) == 0 ) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpTranslateUtf8ToUnicode - Case1\n" ));

        //
        // First case described above.  Just return the first byte
        // of our UTF8 buffer.
        //
        *DestinationUnicodeVal = (WCHAR)(ExistingUtf8Buffer[0]);


        //
        // We used 1 byte.  Discard that byte and shift everything
        // in our buffer over by 1.
        //
        ExistingUtf8Buffer[0] = ExistingUtf8Buffer[1];
        ExistingUtf8Buffer[1] = ExistingUtf8Buffer[2];
        ExistingUtf8Buffer[2] = 0;

        ReturnValue = TRUE;

    } else if( (ExistingUtf8Buffer[0] & 0xE0) == 0xC0 ) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpTranslateUtf8ToUnicode - 1st byte of UTF8 buffer says Case2\n" ));

        //
        // Second case described above.  Decode the first 2 bytes of
        // of our UTF8 buffer.
        //
        if( (ExistingUtf8Buffer[1] & 0xC0) == 0x80 ) {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpTranslateUtf8ToUnicode - 2nd byte of UTF8 buffer says Case2.\n" ));

            // upper byte: 00000xxx
            *DestinationUnicodeVal = ((ExistingUtf8Buffer[0] >> 2) & 0x07);
            *DestinationUnicodeVal = *DestinationUnicodeVal << 8;

            // high bits of lower byte: xx000000
            *DestinationUnicodeVal |= ((ExistingUtf8Buffer[0] & 0x03) << 6);

            // low bits of lower byte: 00yyyyyy
            *DestinationUnicodeVal |= (ExistingUtf8Buffer[1] & 0x3F);


            //
            // We used 2 bytes.  Discard those bytes and shift everything
            // in our buffer over by 2.
            //
            ExistingUtf8Buffer[0] = ExistingUtf8Buffer[2];
            ExistingUtf8Buffer[1] = 0;
            ExistingUtf8Buffer[2] = 0;

            ReturnValue = TRUE;

        }
    } else if( (ExistingUtf8Buffer[0] & 0xF0) == 0xE0 ) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpTranslateUtf8ToUnicode - 1st byte of UTF8 buffer says Case3\n" ));

        //
        // Third case described above.  Decode the all 3 bytes of
        // of our UTF8 buffer.
        //

        if( (ExistingUtf8Buffer[1] & 0xC0) == 0x80 ) {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpTranslateUtf8ToUnicode - 2nd byte of UTF8 buffer says Case3\n" ));

            if( (ExistingUtf8Buffer[2] & 0xC0) == 0x80 ) {

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpTranslateUtf8ToUnicode - 3rd byte of UTF8 buffer says Case3\n" ));

                // upper byte: xxxx0000
                *DestinationUnicodeVal = ((ExistingUtf8Buffer[0] << 4) & 0xF0);

                // upper byte: 0000yyyy
                *DestinationUnicodeVal |= ((ExistingUtf8Buffer[1] >> 2) & 0x0F);

                *DestinationUnicodeVal = *DestinationUnicodeVal << 8;

                // lower byte: yy000000
                *DestinationUnicodeVal |= ((ExistingUtf8Buffer[1] << 6) & 0xC0);

                // lower byte: 00zzzzzz
                *DestinationUnicodeVal |= (ExistingUtf8Buffer[2] & 0x3F);

                //
                // We used all 3 bytes.  Zero out the buffer.
                //
                ExistingUtf8Buffer[0] = 0;
                ExistingUtf8Buffer[1] = 0;
                ExistingUtf8Buffer[2] = 0;

                ReturnValue = TRUE;

            }
        }
    }

    return ReturnValue;
}




VOID
SpTermInitialize(
    VOID
    )

/*++

Routine Description:

    Attempts to connect to a VT100 attached to COM1

Arguments:

    None.

Return Value:

    None.

--*/

{
    HEADLESS_CMD_ENABLE_TERMINAL Command;
    NTSTATUS Status;

    Command.Enable = TRUE;
    Status = HeadlessDispatch(HeadlessCmdEnableTerminal,
                              &Command,
                              sizeof(HEADLESS_CMD_ENABLE_TERMINAL),
                              NULL,
                              NULL
                             );

    HeadlessTerminalConnected = NT_SUCCESS(Status);
}

VOID
SpTermDisplayStringOnTerminal(
    IN PWSTR  String,
    IN UCHAR Attribute,
    IN ULONG X,                 // 0-based coordinates (character units)
    IN ULONG Y
    )

/*++

Routine Description:

    Write a string of characters to the terminal.

Arguments:

    Character - supplies a string to be displayed at the given position.

    Attribute - supplies the attributes for the characters in the string.

    X,Y - specify the character-based (0-based) position of the output.

Return Value:

    None.

--*/

{
    PWSTR EscapeString;

    //
    // send <CSI>x;yH to move the cursor to the specified location
    //
    swprintf(UnicodeScratchBuffer, L"\033[%d;%dH", Y + 1, X + 1);
    SpTermSendStringToTerminal(UnicodeScratchBuffer, TRUE);

    //
    // convert any attributes to an escape string.  EscapeString uses
    // the TerminalBuffer global scratch buffer
    //
    EscapeString = SpTermAttributeToTerminalEscapeString(Attribute);

    //
    // transmit the escape string if we received one
    //
    if (EscapeString != NULL) {
        SpTermSendStringToTerminal(EscapeString, TRUE);
    }

    //
    // finally send the actual string contents to the terminal
    //
    SpTermSendStringToTerminal(String, FALSE);
}

PWSTR
SpTermAttributeToTerminalEscapeString(
    IN UCHAR Attribute
    )

/*++

Routine Description:

    Convert a vga attribute byte to an escape sequence to send to the terminal.

Arguments:

    Attribute - supplies the attribute.

Return Value:

    A pointer to the escape sequence, or NULL if it could not be converted.

--*/

{
    ULONG BgColor;
    ULONG FgColor;
    BOOLEAN Inverse;

    BgColor = (Attribute & 0x70) >> 4;
    FgColor = Attribute & 0x07;

    Inverse = !((BgColor == 0) || (BgColor == DEFAULT_BACKGROUND));

    //
    // Convert the colors.
    //
    switch (BgColor) {
    case ATT_BLUE:
        BgColor = 44;
        break;
    case ATT_GREEN:
        BgColor = 42;
        break;
    case ATT_CYAN:
        BgColor = 46;
        break;
    case ATT_RED:
        BgColor = 41;
        break;
    case ATT_MAGENTA:
        BgColor = 45;
        break;
    case ATT_YELLOW:
        BgColor = 43;
        break;
    case ATT_BLACK:
        BgColor = 40;
        break;
    case ATT_WHITE:
        BgColor = 47;
        break;
    }
    switch (FgColor) {
    case ATT_BLUE:
        FgColor = 34;
        break;
    case ATT_GREEN:
        FgColor = 32;
        break;
    case ATT_CYAN:
        FgColor = 36;
        break;
    case ATT_RED:
        FgColor = 31;
        break;
    case ATT_MAGENTA:
        FgColor = 35;
        break;
    case ATT_YELLOW:
        FgColor = 33;
        break;
    case ATT_BLACK:
        FgColor = 30;
        break;
    case ATT_WHITE:
        FgColor = 37;
        break;
    }

    //
    // <CSI>%1;%2;%3m is the escape to set a color
    // where 1 = video mode
    //       2 = foreground color
    //       3 = background color
    //
    swprintf(UnicodeScratchBuffer,
            L"\033[%u;%u;%um",
            (Inverse ? 7 : 0),
            FgColor,
            BgColor
           );

    return UnicodeScratchBuffer;
}

VOID
SpTermSendStringToTerminal(
    IN PWSTR String,
    IN BOOLEAN Raw
    )

/*++

Routine Description:

    Write a character string to the terminal, translating some codes if desired.

Arguments:

    String - NULL terminated string to write.

    Raw - Send the string raw or not.

Return Value:

    None.

--*/


{
    ULONG i = 0;
    PWSTR LocalBuffer = UnicodeScratchBuffer;


    ASSERT(FIELD_OFFSET(HEADLESS_CMD_PUT_STRING, String) == 0);  // ASSERT if anyone changes this structure.

    //
    // Don't do anything if we aren't running headless.
    //
    if( !HeadlessTerminalConnected ) {
        return;
    }

    if (Raw) {

        if (SpTermDoUtf8) {
            SpTranslateUnicodeToUtf8( String, Utf8ConversionBuffer );

            HeadlessDispatch( HeadlessCmdPutData,
                     Utf8ConversionBuffer,
                     strlen(Utf8ConversionBuffer),
                     NULL,
                     NULL
                    );
        } else {
            //
            // Convert unicode string to oem, guarding against overflow.
            //
            RtlUnicodeToOemN(
                Utf8ConversionBuffer,
                sizeof(Utf8ConversionBuffer)-1,     // guarantee room for nul
                NULL,
                String,
                (wcslen(String)+1)*sizeof(WCHAR)
                );

            Utf8ConversionBuffer[sizeof(Utf8ConversionBuffer)-1] = '\0';

            HeadlessDispatch( HeadlessCmdPutString,
                     Utf8ConversionBuffer,
                     strlen(Utf8ConversionBuffer) + sizeof(UCHAR),
                     NULL,
                     NULL
                    );
        }




        return;
    }

    while (*String != L'\0') {

        LocalBuffer[i++] = *String;

        if (*String == L'\n') {

            //
            // Every \n becomes a \n\r sequence.
            //
            LocalBuffer[i++] = L'\r';

        } else if (*String == 0x00DC) {

            //
            // The cursor becomes a space and then a backspace, this is to
            // delete the old character and position the terminal cursor properly.
            //
            LocalBuffer[i-1] = 0x0020;
            LocalBuffer[i++] = 0x0008;

        }

        //
        // we've got an entire line of text -- we need to transmit it now or
        // we can end up scrolling the text and everything will look funny from
        // this point forward.
        //
        if (i >= 70) {

            LocalBuffer[i] = L'\0';
            if (SpTermDoUtf8) {
                SpTranslateUnicodeToUtf8( LocalBuffer, Utf8ConversionBuffer );

                HeadlessDispatch(HeadlessCmdPutData,
                                 Utf8ConversionBuffer,
                                 strlen(Utf8ConversionBuffer),
                                 NULL,
                                 NULL
                                );


            } else {
                //
                // Convert unicode string to oem, guarding against overflow.
                //
                RtlUnicodeToOemN(
                    Utf8ConversionBuffer,
                    sizeof(Utf8ConversionBuffer)-1,     // guarantee room for nul
                    NULL,
                    LocalBuffer,
                    (wcslen(LocalBuffer)+1)*sizeof(WCHAR)
                    );


                Utf8ConversionBuffer[sizeof(Utf8ConversionBuffer)-1] = '\0';

                HeadlessDispatch(HeadlessCmdPutString,
                                 Utf8ConversionBuffer,
                                 strlen(Utf8ConversionBuffer) + sizeof(UCHAR),
                                 NULL,
                                 NULL
                                );

            }

            i = 0;
        }

        String++;
    }

    LocalBuffer[i] = L'\0';
    if (SpTermDoUtf8) {
        SpTranslateUnicodeToUtf8( LocalBuffer, Utf8ConversionBuffer );

        HeadlessDispatch(HeadlessCmdPutData,
                     Utf8ConversionBuffer,
                     strlen(Utf8ConversionBuffer),
                     NULL,
                     NULL
                    );

    } else {
        //
        // Convert unicode string to oem, guarding against overflow.
        //
        RtlUnicodeToOemN(
            Utf8ConversionBuffer,
            sizeof(Utf8ConversionBuffer)-1,     // guarantee room for nul
            NULL,
            LocalBuffer,
            (wcslen(LocalBuffer)+1)*sizeof(WCHAR)
            );

        Utf8ConversionBuffer[sizeof(Utf8ConversionBuffer)-1] = '\0';

        HeadlessDispatch(HeadlessCmdPutString,
                     Utf8ConversionBuffer,
                     strlen(Utf8ConversionBuffer) + sizeof(UCHAR),
                     NULL,
                     NULL
                    );

    }

}

VOID
SpTermTerminate(
    VOID
    )

/*++

Routine Description:

    Close down connection to the dumb terminal

Arguments:

    None.

Return Value:

    None.

--*/

{
    HEADLESS_CMD_ENABLE_TERMINAL Command;

    //
    // Don't do anything if we aren't running headless.
    //
    if( !HeadlessTerminalConnected ) {
        return;
    }



    Command.Enable = FALSE;
    HeadlessDispatch(HeadlessCmdEnableTerminal,
                     &Command,
                     sizeof(HEADLESS_CMD_ENABLE_TERMINAL),
                     NULL,
                     NULL
                    );

    HeadlessTerminalConnected = FALSE;
}

BOOLEAN
SpTermIsKeyWaiting(
    VOID
    )

/*++

Routine Description:

    Probe for a read.

Arguments:

    None.

Return Value:

    TRUE if there is a character waiting for input, else FALSE.

--*/

{
    HEADLESS_RSP_POLL Response;
    NTSTATUS Status;
    SIZE_T Length;


    //
    // Don't do anything if we aren't running headless.
    //
    if( !HeadlessTerminalConnected ) {
        return FALSE;
    }


    Length = sizeof(HEADLESS_RSP_POLL);

    Response.QueuedInput = FALSE;

    Status = HeadlessDispatch(HeadlessCmdTerminalPoll,
                              NULL,
                              0,
                              &Response,
                              &Length
                             );

    return (NT_SUCCESS(Status) && Response.QueuedInput);
}

ULONG
SpTermGetKeypress(
    VOID
    )

/*++

Routine Description:

    Read in a (possible) sequence of keystrokes and return a Key value.

Arguments:

    None.

Return Value:

    0 if no key is waiting, else a ULONG key value.

--*/

{
    UCHAR Byte;
    BOOLEAN Success;
    TIME_FIELDS StartTime;
    TIME_FIELDS EndTime;
    HEADLESS_RSP_GET_BYTE Response;
    SIZE_T Length;
    NTSTATUS Status;


    //
    // Don't do anything if we aren't running headless.
    //
    if( !HeadlessTerminalConnected ) {
        return 0;
    }


    //
    // Read first character
    //
    Length = sizeof(HEADLESS_RSP_GET_BYTE);

    Status = HeadlessDispatch(HeadlessCmdGetByte,
                              NULL,
                              0,
                              &Response,
                              &Length
                             );

    if (NT_SUCCESS(Status)) {
        Byte = Response.Value;
    } else {
        Byte = 0;
    }



    //
    // Handle all the special escape codes.
    //
    if (Byte == 0x8) {   // backspace (^h)
        return ASCI_BS;
    }
    if (Byte == 0x7F) {  // delete
        return KEY_DELETE;
    }
    if ((Byte == '\r') || (Byte == '\n')) {  // return
        return ASCI_CR;
    }

    if (Byte == 0x1b) {    // Escape key

        do {

            Success = HalQueryRealTimeClock(&StartTime);
            ASSERT(Success);

            //
            // Adjust StartTime to be our ending time.
            //
            StartTime.Second += 2;
            if (StartTime.Second > 59) {
                StartTime.Second -= 60;
            }

            while (!SpTermIsKeyWaiting()) {

                //
                // Give the user 1 second to type in a follow up key.
                //
                Success = HalQueryRealTimeClock(&EndTime);
                ASSERT(Success);

                if (StartTime.Second == EndTime.Second) {
                    break;
                }
            }

            if (!SpTermIsKeyWaiting()) {
                return ASCI_ESC;
            }

            //
            // Read the next keystroke
            //
            Length = sizeof(HEADLESS_RSP_GET_BYTE);

            Status = HeadlessDispatch(HeadlessCmdGetByte,
                                      NULL,
                                      0,
                                      &Response,
                                      &Length
                                     );

            if (NT_SUCCESS(Status)) {
                Byte = Response.Value;
            } else {
                Byte = 0;
            }


            //
            // Some terminals send ESC, or ESC-[ to mean
            // they're about to send a control sequence.  We've already
            // gotten an ESC key, so ignore an '[' if it comes in.
            //
        } while ( Byte == '[' );


        switch (Byte) {
            case '@':
                return KEY_F12;
            case '!':
                return KEY_F11;
            case '0':
                return KEY_F10;
            case '9':
                return KEY_F9;
            case '8':
                return KEY_F8;
            case '7':
                return KEY_F7;
            case '6':
                return KEY_F6;
            case '5':
                return KEY_F5;
            case '4':
                return KEY_F4;
            case '3':
                return KEY_F3;
            case '2':
                return KEY_F2;
            case '1':
                return KEY_F1;
            case '+':
                return KEY_INSERT;
            case '-':
                return KEY_DELETE;
            case 'H':
                return KEY_HOME;
            case 'K':
                return KEY_END;
            case '?':
                return KEY_PAGEUP;
            case '/':
                return KEY_PAGEDOWN;
            case 'A':
                return KEY_UP;
            case 'B':
                return KEY_DOWN;
            case 'C':
                return KEY_RIGHT;
            case 'D':
                return KEY_LEFT;

        }

        //
        // We didn't get anything we recognized after the
        // ESC key.  Just return the ESC key.
        //
        return ASCI_ESC;

    } // Escape key



    //
    // The incoming byte isn't an escape code.
    //
    // Decode it as if it's a UTF8 stream.
    //
    if( SpTranslateUtf8ToUnicode( Byte,
                                  IncomingUtf8ConversionBuffer,
                                  &IncomingUnicodeValue ) ) {

        //
        // He returned TRUE, so we must have recieved a complete
        // UTF8-encoded character.
        //
        return IncomingUnicodeValue;
    } else {
        //
        // The UTF8 stream isn't complete yet, so we don't have
        // a decoded character to return yet.
        //
        return 0;
    }

}

VOID
SpTermDrain(
    VOID
    )

/*++

Routine Description:

    Read in and throw out all characters in input stream

Arguments:

    None.

Return Value:

    None.

--*/

{
    while (SpTermIsKeyWaiting()) {
        SpTermGetKeypress();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spswitch.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    spswitch.h

Abstract:

    Macros & Functions to switch between old and 
    new partitioning engine in textmode.

    NEW_PARTITION_ENGINE forces new partition engine
    code to be used for both MBR and GPT disks.

    GPT_PARTITION_ENGINE forces new partition engine
    code to be used for GPT disks and old partition
    engine code for MBR disks.

    OLD_PARTITION_ENGINE forces the old partition
    engine to used for MBR disks. This option cannot
    handle GPT disks correctly.

    Note : 
    If none of the NEW_PARTITION_ENGINE, 
    OLD_PARTITION_ENGINE or GPT_PARTITION_ENGINE are
    defined, then by default NEW_PARTITION_ENGINE is
    used.

Author:

    Vijay Jayaseelan    (vijayj)    18 March 2000

Revision History:

--*/


#ifndef _SPSWITCH_H_
#define _SPSWITCH_H_

#ifdef NEW_PARTITION_ENGINE

#undef OLD_PARTITION_ENGINE
#undef GPT_PARTITION_ENGINE

#else

#ifdef OLD_PARTITION_ENGINE

#undef NEW_PARTITION_ENGINE
#undef GPT_PARTITION_ENGINE

#else

#ifndef GPT_PARTITION_ENGINE

#pragma message( "!!! Defaulting to NEW_PARTITION_ENGINE !!!" )

#define NEW_PARTITION_ENGINE    1

#endif // !GPT_PARTITION_ENGINE

#endif // OLD_PARTITION_ENGINE

#endif // NEW_PARTITION_ENGINE

#if defined(NEW_PARTITION_ENGINE) || defined(GPT_PARTITION_ENGINE)
#include "sppart3.h"
#endif

#endif // for _SPSWITCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\sptxtfil.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    sptxtfil.c

Abstract:

    Routines to load and extract information from
    setup text files.

Author:

    Ted Miller (tedm) 4-Aug-1993

Revision History:

--*/



#include "spprecmp.h"
#pragma hdrstop
#include <setupapi.h>

BOOLEAN HandleLineContinueChars = TRUE;

//
// We often need an empty string while processing the inf files.  Rather
// than incur the overhead of allocating memory for an empty string, we'll
// just point to this empty string for all cases.
//
PWSTR  CommonStrings[11] =
    { (PWSTR)(L"0"),
      (PWSTR)(L"1"),
      (PWSTR)(L"2"),
      (PWSTR)(L"3"),
      (PWSTR)(L"4"),
      (PWSTR)(L"5"),
      (PWSTR)(L"6"),
      (PWSTR)(L"7"),
      (PWSTR)(L"8"),
      (PWSTR)(L"9"),
      (PWSTR)(L"")
    };

PVOID
ParseInfBuffer(
    PWCHAR  Buffer,
    ULONG   Size,
    PULONG  ErrorLine
    );

NTSTATUS
SppWriteTextToFile(
    IN PVOID Handle,
    IN PWSTR String
    );

BOOLEAN
pSpAdjustRootAndSubkeySpec(
    IN  PVOID    SifHandle,
    IN  LPCWSTR  RootKeySpec,
    IN  LPCWSTR  SubkeySpec,
    IN  HANDLE   HKLM_SYSTEM,
    IN  HANDLE   HKLM_SOFTWARE,
    IN  HANDLE   HKCU,
    IN  HANDLE   HKR,
    OUT HANDLE  *RootKey,
    OUT LPWSTR   Subkey
    );



NTSTATUS
SpLoadSetupTextFile(
    IN  PWCHAR  Filename,   OPTIONAL
    IN  PVOID   Image,      OPTIONAL
    IN  ULONG   ImageSize,  OPTIONAL
    OUT PVOID  *Handle,
    OUT PULONG  ErrorLine,
    IN  BOOLEAN ClearScreen,
    IN  BOOLEAN ScreenNotReady
    )

/*++

Routine Description:

    Load a setup text file into memory.

Arguments:

    Filename - If specified, supplies full filename (in NT namespace)
        of the file to be loaded. Oneof Image or Filename must be specified.

    Image - If specified, supplies a pointer to an image of the file
        already in memory. One of Image or Filename must be specified.

    ImageSize - if Image is specified, then this parameter supplies the
        size of the buffer pointed to by Image.  Ignored otherwise.

    Handle - receives handle to loaded file, which can be
        used in subsequent calls to other text file services.

    ErrorLine - receives line number of syntax error, if parsing fails.

    ClearScreen - supplies boolean value indicating whether to clear the
        screen.

    ScreenNotReady - Indicates that this function was invoked during the initialization
                     of setupdd.sys, and that the screen is not ready yet for output.
                     If this flag is set, then this function will not clear the screen or update
                     the status line.


Return Value:

    STATUS_SUCCESS - file was read and parsed successfully.
        In this case, Handle is filled in.

    STATUS_UNSUCCESSFUL - syntax error in file.  In this case, ErrorLine
        is filled in.

    STATUS_NO_MEMORY - unable to allocate memory while parsing.

    STATUS_IN_PAGE_ERROR - i/o error while reading the file.

--*/

{
    HANDLE hFile;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING FilenameU;
    OBJECT_ATTRIBUTES oa;
    PWCHAR pText;
    ULONG cbText;
    HANDLE hSection;
    PVOID UnmapAddress;
    PWCHAR UniText = NULL;
    BOOLEAN LoadFromFile;

    // Set Errorline to zero to take care of default failure case

    if(ErrorLine)
        *ErrorLine=0;

    //
    // Argument validation -- one of Filename or Image must be specified,
    // but not both.
    //
    ASSERT(!(Filename && Image));
    ASSERT(Filename || Image);

    LoadFromFile = (BOOLEAN)(Filename != NULL);
    if(ScreenNotReady) {
        ClearScreen = FALSE;
    }
    if(ClearScreen) {
        CLEAR_CLIENT_SCREEN();
    }

    if(LoadFromFile) {

        if(!ScreenNotReady) {
            SpDisplayStatusText(
                SP_STAT_LOADING_SIF,
                DEFAULT_STATUS_ATTRIBUTE,
                wcsrchr(Filename,L'\\')+1
                );
        }

        //
        // Open the file.
        //
        RtlInitUnicodeString(&FilenameU,Filename);
        InitializeObjectAttributes(&oa,&FilenameU,OBJ_CASE_INSENSITIVE,NULL,NULL);
        Status = ZwCreateFile(
                    &hFile,
                    FILE_GENERIC_READ,
                    &oa,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ,
                    FILE_OPEN,
                    0,
                    NULL,
                    0
                    );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpLoadSetupTextFile: unable to open file %ws (%lx)\n",Filename,Status));
            goto ltf0;
        }

        //
        // Get the file size.
        //
        Status = SpGetFileSize(hFile,&cbText);
        if(!NT_SUCCESS(Status)) {
            goto ltf1;
        }

        //
        // Map the file.
        //
        Status = SpMapEntireFile(hFile,&hSection,&pText,FALSE);
        if(!NT_SUCCESS(Status)) {
            goto ltf1;
        }

        UnmapAddress = pText;

    } else {

        if(!ScreenNotReady) {
            SpDisplayStatusText(SP_STAT_PROCESSING_SIF,DEFAULT_STATUS_ATTRIBUTE);
        }

        pText = Image;
        cbText = ImageSize;

        Status = STATUS_SUCCESS;  // We are now ready to go to the next block.
    }


    //
    // See if we think the file is Unicode.  We think it's Unicode
    // if it's even length and starts with the Unicode text marker.
    //
    try {

        if((*pText == 0xfeff) && !(cbText & 1)) {

            //
            // Assume it's already unicode.
            //
            pText++;
            cbText -= sizeof(WCHAR);

        } else {

            //
            // It's not Unicode. Convert it from OEM to Unicode.
            //
            // Allocate a buffer large enough to hold the maximum
            // unicode text.  This max size occurs when
            // every character is single-byte, and this size is
            // equal to exactly double the size of the single-byte text.
            //
            if(UniText = SpMemAllocEx(cbText*sizeof(WCHAR),'1teS', PagedPool)) {

                Status = RtlOemToUnicodeN(
                            UniText,                // output: newly allocatd buffer
                            cbText * sizeof(WCHAR), // max size of output
                            &cbText,                // receives # bytes in unicode text
                            (PUCHAR)pText,          // input: oem text (mapped file)
                            cbText                  // size of input
                            );

                if(NT_SUCCESS(Status)) {
                    pText = UniText;                // Use newly converted Unicode text
                }

            } else {
                Status = STATUS_NO_MEMORY;
            }
        }
    } except(IN_PAGE_ERROR) {
        Status = STATUS_IN_PAGE_ERROR;
    }

    //
    // Process the file.
    //
    if(NT_SUCCESS(Status)) {

        try {
            if((*Handle = ParseInfBuffer(pText,cbText,ErrorLine)) == (PVOID)NULL) {
                Status = STATUS_UNSUCCESSFUL;
            } else {
                Status = STATUS_SUCCESS;
            }
        } except(IN_PAGE_ERROR) {
            Status = STATUS_IN_PAGE_ERROR;
        }
    }

    //
    // Free the unicode text buffer if we allocated it.
    //
    if(UniText) {
        SpMemFree(UniText);
    }

    //
    // Unmap the file.
    //
  //ltf2:

    if(LoadFromFile) {
        SpUnmapFile(hSection,UnmapAddress);
    }

  ltf1:
    //
    // Close the file.
    //
    if(LoadFromFile) {
        ZwClose(hFile);
    }

  ltf0:

    return(Status);
}

//
// [Strings] section types.
//
typedef enum {
    StringsSectionNone,
    StringsSectionPlain,
    StringsSectionLoosePrimaryMatch,
    StringsSectionExactPrimaryMatch,
    StringsSectionExactMatch
} StringsSectionType;


typedef struct _TEXTFILE_VALUE {
    struct _TEXTFILE_VALUE *pNext;
    PWCHAR                  pName;
} TEXTFILE_VALUE, *PTEXTFILE_VALUE;

typedef struct _TEXTFILE_LINE {
    struct _TEXTFILE_LINE *pNext;
    PWCHAR                  pName;
    PTEXTFILE_VALUE         pValue;
} TEXTFILE_LINE, *PTEXTFILE_LINE;

typedef struct _TEXTFILE_SECTION {
    struct _TEXTFILE_SECTION *pNext;
    PWCHAR                    pName;
    PTEXTFILE_LINE            pLine;
    PTEXTFILE_LINE            PreviouslyFoundLine;
} TEXTFILE_SECTION, *PTEXTFILE_SECTION;

typedef struct _TEXTFILE {
    PTEXTFILE_SECTION pSection;
    PTEXTFILE_SECTION PreviouslyFoundSection;
    PTEXTFILE_SECTION StringsSection;
    StringsSectionType StringsSectionType;
} TEXTFILE, *PTEXTFILE;

//
// DEFINES USED FOR THE PARSER INTERNALLY
//
//
// typedefs used
//

typedef enum _tokentype {
    TOK_EOF,      // 0
    TOK_EOL,      // 1
    TOK_LBRACE,   // 2
    TOK_RBRACE,   // 3
    TOK_STRING,   // 4
    TOK_EQUAL,    // 5
    TOK_COMMA,    // 6
    TOK_ERRPARSE, // 7
    TOK_ERRNOMEM  // 8
} TOKENTYPE, *PTOKENTTYPE;


typedef struct _token {
    TOKENTYPE Type;
    PWCHAR    pValue;
} TOKEN, *PTOKEN;


//
// Routine defines
//

NTSTATUS
SpAppendSection(
    IN PWCHAR pSectionName
    );

NTSTATUS
SpAppendLine(
    IN PWCHAR pLineKey
    );

NTSTATUS
SpAppendValue(
    IN PWCHAR pValueString
    );

TOKEN
SpGetToken(
    IN OUT PWCHAR *Stream,
    IN PWCHAR     MaxStream,
    IN OUT PULONG LineNumber
    );

// what follows was alinf.c

//
// Internal Routine Declarations for freeing inf structure members
//

VOID
FreeSectionList (
   IN PTEXTFILE_SECTION pSection
   );

VOID
FreeLineList (
   IN PTEXTFILE_LINE pLine
   );

VOID
FreeValueList (
   IN PTEXTFILE_VALUE pValue
   );


//
// Internal Routine declarations for searching in the INF structures
//


PTEXTFILE_VALUE
SearchValueInLine(
   IN PTEXTFILE_LINE pLine,
   IN ULONG ValueIndex
   );

PTEXTFILE_LINE
SearchLineInSectionByKey(
   IN PTEXTFILE_SECTION pSection,
   IN PWCHAR    Key
   );

PTEXTFILE_LINE
SearchLineInSectionByIndex(
   IN PTEXTFILE_SECTION pSection,
   IN ULONG    LineIndex
   );

PTEXTFILE_SECTION
SearchSectionByName(
   IN PTEXTFILE pINF,
   IN LPCWSTR    SectionName
   );

PWCHAR
SpProcessForSimpleStringSub(
    IN PTEXTFILE pInf,
    IN PWCHAR    String
    );


PVOID
SpNewSetupTextFile(
    VOID
    )
{
    PTEXTFILE pFile;

    pFile = SpMemAllocEx(sizeof(TEXTFILE),'2teS', PagedPool);

    RtlZeroMemory(pFile,sizeof(TEXTFILE));
    return(pFile);
}


VOID
SpAddLineToSection(
    IN PVOID Handle,
    IN PWSTR SectionName,
    IN PWSTR KeyName,       OPTIONAL
    IN PWSTR Values[],
    IN ULONG ValueCount
    )
{
    PTEXTFILE_SECTION pSection;
    PTEXTFILE_LINE pLine;
    PTEXTFILE_VALUE pValue,PrevVal;
    PTEXTFILE pFile;
    ULONG v;
    ULONG nameLength;

    pFile = (PTEXTFILE)Handle;

    //
    // If the section doesn't exist, create it.
    //
    pSection = SearchSectionByName(pFile,SectionName);
    if(!pSection) {
        nameLength = (wcslen(SectionName) + 1) * sizeof(WCHAR);
        pSection = SpMemAllocEx(sizeof(TEXTFILE_SECTION) + nameLength,'3teS', PagedPool);
        RtlZeroMemory(pSection,sizeof(TEXTFILE_SECTION));

        pSection->pNext = pFile->pSection;
        pFile->pSection = pSection;

        pSection->pName = (PWCHAR)(pSection + 1);
        RtlCopyMemory( pSection->pName, SectionName, nameLength );
    }

    //
    // if the line already exists, then overwrite it
    //
    if (KeyName && (pLine = SearchLineInSectionByKey(pSection,KeyName))) {
        FreeValueList(pLine->pValue);   
    } else {
    
        //
        // Create a structure for the line in the section.
        //
        if (KeyName) {
            nameLength = (wcslen(KeyName) + 1) * sizeof(WCHAR);
        } else {
            nameLength = 0;
        }
    
        pLine = SpMemAllocEx(sizeof(TEXTFILE_LINE) + nameLength,'4teS', PagedPool);
        RtlZeroMemory(pLine,sizeof(TEXTFILE_LINE));
    
        pLine->pNext = pSection->pLine;
        pSection->pLine = pLine;
    
        if(KeyName) {
            pLine->pName = (PWCHAR)(pLine + 1);
            RtlCopyMemory( pLine->pName, KeyName, nameLength );
        }

    }

    //
    // Create value entries for each specified value.
    // These must be kept in the order they were specified.
    //
    for(v=0; v<ValueCount; v++) {

        nameLength = (wcslen(Values[v]) + 1) * sizeof(WCHAR);

        pValue = SpMemAllocEx(sizeof(TEXTFILE_VALUE) + nameLength,'5teS', PagedPool);
        RtlZeroMemory(pValue,sizeof(TEXTFILE_VALUE));

        pValue->pName = (PWCHAR)(pValue + 1);
        RtlCopyMemory( pValue->pName, Values[v], nameLength );

        if(v == 0) {
            pLine->pValue = pValue;
        } else {
            PrevVal->pNext = pValue;
        }
        PrevVal = pValue;
    }    
}


NTSTATUS
SpWriteSetupTextFile(
    IN PVOID Handle,
    IN PWSTR FilenamePart1,
    IN PWSTR FilenamePart2, OPTIONAL
    IN PWSTR FilenamePart3  OPTIONAL
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    HANDLE hFile;
    PWSTR p;
    PTEXTFILE pFile;
    PTEXTFILE_SECTION pSection;
    PTEXTFILE_LINE pLine;
    PTEXTFILE_VALUE pValue;

    //
    // Do this because it takes care of read-only attributes, etc.
    // Do it before starting to use TemporaryBuffer.
    //
    SpDeleteFile(FilenamePart1,FilenamePart2,FilenamePart3);

    p = TemporaryBuffer;

    wcscpy(p,FilenamePart1);
    if(FilenamePart2) {
        SpConcatenatePaths(p,FilenamePart2);
    }
    if(FilenamePart3) {
        SpConcatenatePaths(p,FilenamePart3);
    }

    INIT_OBJA(&Obja,&UnicodeString, p);

    Status = ZwCreateFile(
                &hFile,
                FILE_ALL_ACCESS,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                0,                          // no sharing
                FILE_OVERWRITE_IF,
                FILE_SYNCHRONOUS_IO_ALERT | FILE_NON_DIRECTORY_FILE,
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open .sif file %ws (%lx)\n",p, Status ));
        return(Status);
    }

    //
    // Write out the file contents.
    //
    pFile = (PTEXTFILE)Handle;

    for(pSection=pFile->pSection; pSection; pSection=pSection->pNext) {

        swprintf(p,L"[%s]\r\n",pSection->pName);
        Status = SppWriteTextToFile( hFile, p );
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SppWriteTextToFile() failed. Status = %lx \n", Status));
            goto wtf1;
        }

        for(pLine=pSection->pLine; pLine; pLine=pLine->pNext) {

            wcscpy( p, L"" );
            //
            // Write the keyname if there is one.
            //
            if(pLine->pName) {
                BOOLEAN AddDoubleQuotes;

                AddDoubleQuotes = (wcschr(pLine->pName, (WCHAR)' ') == NULL)? FALSE : TRUE;
                if( AddDoubleQuotes ) {
                    wcscat(p,L"\"");
                }
                wcscat(p,pLine->pName);
                if( AddDoubleQuotes ) {
                    wcscat(p,L"\"");
                }
                wcscat(p,L" = ");
            }

            for(pValue=pLine->pValue; pValue; pValue=pValue->pNext) {

                if(pValue != pLine->pValue) {
                    wcscat(p,L",");
                }

                wcscat(p,L"\"");
                wcscat(p,pValue->pName);
                wcscat(p,L"\"");
            }

            if(!pLine->pValue) {
                wcscat(p,L"\"\"");
            }
            wcscat(p,L"\r\n");
            Status = SppWriteTextToFile( hFile, p );
            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SppWriteTextToFile() failed. Status = %lx \n", Status));
                goto wtf1;
            }
        }
    }

wtf1:
    ZwClose(hFile);

    return(Status);
}


BOOLEAN
SpFreeTextFile(
   IN PVOID Handle
   )

/*++

Routine Description:

    Frees a text file.

Arguments:


Return Value:

    TRUE.

--*/

{
   PTEXTFILE pINF;

   ASSERT(Handle);

   //
   // cast the buffer into an INF structure
   //

   pINF = (PTEXTFILE)Handle;

   FreeSectionList(pINF->pSection);

   //
   // free the inf structure too
   //

   SpMemFree(pINF);

   return(TRUE);
}


VOID
FreeSectionList (
   IN PTEXTFILE_SECTION pSection
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PTEXTFILE_SECTION Next;

    while(pSection) {
        Next = pSection->pNext;
        FreeLineList(pSection->pLine);
        if ((pSection->pName != (PWCHAR)(pSection + 1)) && (pSection->pName != NULL)) {
            SpMemFree(pSection->pName);
        }
        SpMemFree(pSection);
        pSection = Next;
    }
}


VOID
FreeLineList (
   IN PTEXTFILE_LINE pLine
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PTEXTFILE_LINE Next;

    while(pLine) {
        Next = pLine->pNext;
        FreeValueList(pLine->pValue);
        if ((pLine->pName != (PWCHAR)(pLine + 1)) && (pLine->pName != NULL)) {
            SpMemFree(pLine->pName);
        }
        SpMemFree(pLine);
        pLine = Next;
    }
}

VOID
FreeValueList (
   IN PTEXTFILE_VALUE pValue
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PTEXTFILE_VALUE Next;

    while(pValue) {
        Next = pValue->pNext;
        if ((pValue->pName != (PWCHAR)(pValue + 1)) && (pValue->pName != NULL)) {
            SpMemFree(pValue->pName);
        }
        SpMemFree(pValue);
        pValue = Next;
    }
}


BOOLEAN
SpSearchTextFileSection (
    IN PVOID  Handle,
    IN PWCHAR SectionName
    )

/*++

Routine Description:

    Searches for the existance of a particular section.

Arguments:


Return Value:


--*/

{
    return((BOOLEAN)(SearchSectionByName((PTEXTFILE)Handle,SectionName) != NULL));
}




PWCHAR
SpGetSectionLineIndex(
    IN PVOID   Handle,
    IN LPCWSTR SectionName,
    IN ULONG   LineIndex,
    IN ULONG   ValueIndex
    )

/*++

Routine Description:

    Given section name, line number and index return the value.

Arguments:


Return Value:


--*/

{
    PTEXTFILE_SECTION pSection;
    PTEXTFILE_LINE    pLine;
    PTEXTFILE_VALUE   pValue;

    if((pSection = SearchSectionByName((PTEXTFILE)Handle,SectionName)) == NULL) {
        return(NULL);
    }

    if((pLine = SearchLineInSectionByIndex(pSection,LineIndex)) == NULL) {
        return(NULL);
    }

    if((pValue = SearchValueInLine(pLine,ValueIndex)) == NULL) {
        return(NULL);
    }

    return(SpProcessForSimpleStringSub(Handle,pValue->pName));
}


BOOLEAN
SpGetSectionKeyExists (
   IN PVOID  Handle,
   IN PWCHAR SectionName,
   IN PWCHAR Key
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PTEXTFILE_SECTION pSection;

    if((pSection = SearchSectionByName((PTEXTFILE)Handle,SectionName)) == NULL) {
        return(FALSE);
    }

    if(SearchLineInSectionByKey(pSection,Key) == NULL) {
        return(FALSE);
    }

    return(TRUE);
}


PWCHAR
SpGetKeyName(
    IN PVOID   Handle,
    IN LPCWSTR SectionName,
    IN ULONG   LineIndex
    )
{
    PTEXTFILE_SECTION pSection;
    PTEXTFILE_LINE    pLine;

    pSection = SearchSectionByName((PTEXTFILE)Handle,SectionName);
    if(pSection == NULL) {
        return(NULL);
    }

    pLine = SearchLineInSectionByIndex(pSection,LineIndex);
    if(pLine == NULL) {
        return(NULL);
    }

    return(pLine->pName);
}



PWCHAR
SpGetSectionKeyIndex (
   IN PVOID  Handle,
   IN PWCHAR SectionName,
   IN PWCHAR Key,
   IN ULONG  ValueIndex
   )

/*++

Routine Description:

    Given section name, key and index return the value

Arguments:


Return Value:


--*/

{
    PTEXTFILE_SECTION pSection;
    PTEXTFILE_LINE    pLine;
    PTEXTFILE_VALUE   pValue;

    if((pSection = SearchSectionByName((PTEXTFILE)Handle,SectionName)) == NULL) {
        return(NULL);
    }

    if((pLine = SearchLineInSectionByKey(pSection,Key)) == NULL) {
        return(NULL);
    }

    if((pValue = SearchValueInLine(pLine,ValueIndex)) == NULL) {
       return(NULL);
    }

    return(SpProcessForSimpleStringSub(Handle,pValue->pName));
}

ULONG
SpGetKeyIndex(
  IN PVOID Handle,
  IN PWCHAR SectionName,
  IN PWCHAR KeyName
  )
{
  ULONG Result = -1;

  if (SectionName && KeyName) {
    ULONG MaxLines = SpCountLinesInSection(Handle, SectionName);
    ULONG Index;
    PWSTR CurrKey = 0;

    for (Index=0; Index < MaxLines; Index++) {
      CurrKey = SpGetKeyName(Handle, SectionName, Index);

      if (CurrKey && !wcscmp(CurrKey, KeyName)) {
        Result = Index;

        break;
      }
    }
  }

  return Result;
}

ULONG
SpCountLinesInSection(
    IN PVOID Handle,
    IN PWCHAR SectionName
    )
{
    PTEXTFILE_SECTION pSection;
    PTEXTFILE_LINE    pLine;
    ULONG    Count;

    if((pSection = SearchSectionByName((PTEXTFILE)Handle,SectionName)) == NULL) {
        return(0);
    }

    for(pLine = pSection->pLine, Count = 0;
        pLine;
        pLine = pLine->pNext, Count++
       );

    return(Count);
}


PTEXTFILE_VALUE
SearchValueInLine(
    IN PTEXTFILE_LINE pLine,
    IN ULONG          ValueIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PTEXTFILE_VALUE pValue;
    ULONG  i;

    if(pLine == NULL) {
       return(NULL);
    }

    pValue = pLine->pValue;
    for(i=0; (i<ValueIndex) && (pValue=pValue->pNext); i++) {
        ;
    }

    return pValue;
}


PTEXTFILE_LINE
SearchLineInSectionByKey(
    IN PTEXTFILE_SECTION pSection,
    IN PWCHAR            Key
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PTEXTFILE_LINE pLine,pFirstSearchedLine;

    //
    // Start at the line where we left off in the last search.
    //
    pLine = pFirstSearchedLine = pSection->PreviouslyFoundLine;

    while(pLine && ((pLine->pName == NULL) || _wcsicmp(pLine->pName,Key))) {
        pLine = pLine->pNext;
    }

    //
    // If we haven't found it yet, wrap around to the beginning of the section.
    //
    if(!pLine) {

        pLine = pSection->pLine;

        while(pLine && (pLine != pFirstSearchedLine)) {

            if(pLine->pName && !_wcsicmp(pLine->pName,Key)) {
                break;
            }

            pLine = pLine->pNext;
        }

        //
        // If we wrapped around to the first line we searched,
        // then we didn't find the line we're looking for.
        //
        if(pLine == pFirstSearchedLine) {
            pLine = NULL;
        }
    }

    //
    // If we found the line, save it away so we can resume the
    // search from that point the next time we are called.
    //
    if(pLine) {
        pSection->PreviouslyFoundLine = pLine;
    }

    return pLine;
}


PTEXTFILE_LINE
SearchLineInSectionByIndex(
    IN PTEXTFILE_SECTION pSection,
    IN ULONG             LineIndex
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PTEXTFILE_LINE pLine;
    ULONG  i;

    //
    // Validate the parameters passed in
    //

    if(pSection == NULL) {
        return(NULL);
    }

    //
    // find the start of the line list in the section passed in
    //

    pLine = pSection->pLine;

    //
    // traverse down the current line list to the LineIndex th line
    //

    for(i=0; (i<LineIndex) && (pLine = pLine->pNext); i++) {
       ;
    }

    //
    // return the Line found
    //

    return pLine;
}


PTEXTFILE_SECTION
SearchSectionByName(
    IN PTEXTFILE pINF,
    IN LPCWSTR   SectionName
    )
{
    PTEXTFILE_SECTION pSection,pFirstSearchedSection;

    //
    // find the section list
    //
    pSection = pFirstSearchedSection = pINF->PreviouslyFoundSection;

    //
    // traverse down the section list searching each section for the section
    // name mentioned
    //

    while(pSection && _wcsicmp(pSection->pName,SectionName)) {
        pSection = pSection->pNext;
    }

    //
    // If we didn't find it so far, search the beginning of the file.
    //
    if(!pSection) {

        pSection = pINF->pSection;

        while(pSection && (pSection != pFirstSearchedSection)) {

            if(pSection->pName && !_wcsicmp(pSection->pName,SectionName)) {
                break;
            }

            pSection = pSection->pNext;
        }

        //
        // If we wrapped around to the first section we searched,
        // then we didn't find the section we're looking for.
        //
        if(pSection == pFirstSearchedSection) {
            pSection = NULL;
        }
    }

    if(pSection) {
        pINF->PreviouslyFoundSection = pSection;
    }

    //
    // return the section at which we stopped (either NULL or the section
    // which was found).
    //

    return pSection;
}


PWCHAR
SpProcessForSimpleStringSub(
    IN PTEXTFILE pInf,
    IN PWCHAR    String
    )
{
    UINT Len;
    PWCHAR ReturnString;
    PTEXTFILE_SECTION pSection;
    PTEXTFILE_LINE pLine;

    //
    // Assume no substitution necessary.
    //
    ReturnString = String;

    //
    // If it starts and end with % then look it up in the
    // strings section. Note the initial check before doing a
    // wcslen, to preserve performance in the 99% case where
    // there is no substitution.
    //
    if((String[0] == L'%') && ((Len = wcslen(String)) > 2) && (String[Len-1] == L'%')
    && (pSection = pInf->StringsSection)) {

        for(pLine = pSection->pLine; pLine; pLine=pLine->pNext) {
            if(pLine->pName
            && !_wcsnicmp(pLine->pName,String+1,Len-2)
            && (pLine->pName[Len-2] == 0)) {
                break;
            }
        }

        if(pLine && pLine->pValue && pLine->pValue->pName) {
            ReturnString = pLine->pValue->pName;
        }
    }

    return(ReturnString);
}


VOID
SpProcessForStringSubs(
    IN  PVOID   SifHandle,
    IN  LPCWSTR StringIn,
    OUT LPWSTR  StringOut,
    IN  ULONG   BufferSizeChars
    )
{
    LPCWSTR In,q;
    LPWSTR Out,p;
    WCHAR Str[511];
    ULONG Len,i;
    WCHAR *End;

    In = StringIn;
    Out = StringOut;
    End = Out + BufferSizeChars;

    while(*In) {
        if(*In == L'%') {
            //
            // Double % in input ==> single % in output
            //
            if(*(++In) == L'%') {
                if(Out < End) {
                    *Out++ = L'%';
                }
                In++;
            } else {
                //
                // Look for terminating %.
                //
                if(p = wcschr(In,L'%')) {
                    //
                    // Get value to substitute. If we can't find the value,
                    // put the whole string like %abc% in there.
                    //
                    Len = (ULONG)(p - In);
                    if(Len > ((sizeof(Str)/sizeof(WCHAR))-1)) {
                        //
                        // We can't handle substitutions for tokens this long.
                        // We'll just bail in this case, and copy over the token as-is.
                        //
                        q = NULL;
                    } else {
                        RtlCopyMemory(Str,In-1,(Len+2)*sizeof(WCHAR));
                        Str[Len+2] = 0;

                        q = SpProcessForSimpleStringSub(SifHandle,Str);
                        if(q == Str) {
                            q = NULL;
                        }
                    }
                    if(q) {
                        Len = wcslen(q);
                        for(i=0; i<Len; i++) {
                            if(Out < End) {
                                *Out++ = q[i];
                            }
                        }
                        In = p+1;
                    } else {
                        //
                        // Len is the length of the internal part (the abc in %abc%).
                        //
                        if(Out < End) {
                            *Out++ = L'%';
                        }
                        for(i=0; i<=Len; i++, In++) {
                            if(Out < End) {
                                *Out++ = *In;
                            }
                        }
                    }
                } else {
                    //
                    // No terminating %. So we have something like %abc.
                    // Want to put %abc in the output. Put the % in here
                    // manually and then just let subsequent passes
                    // through the loop copy the rest of the chars.
                    //
                    if(Out < End) {
                        *Out++ = L'%';
                    }
                }
            }
        } else {
            //
            // Plain char.
            //
            if(Out < End) {
                *Out++ = *In;
            }
            In++;
        }
    }

    *Out = 0;
}


//
//  Globals used to make building the lists easier
//

PTEXTFILE         pINF;
PTEXTFILE_SECTION pSectionRecord;
PTEXTFILE_LINE    pLineRecord;
PTEXTFILE_VALUE   pValueRecord;


//
// Globals used by the token parser
//

// string terminators are the whitespace characters (isspace: space, tab,
// linefeed, formfeed, vertical tab, carriage return) or the chars given below

WCHAR  StringTerminators[] = L"[]=,\t \"\n\f\v\r";

PWCHAR QStringTerminators = StringTerminators+6;


//
// Main parser routine
//

PVOID
ParseInfBuffer(
    PWCHAR Buffer,
    ULONG  Size,
    PULONG ErrorLine
    )

/*++

Routine Description:

   Given a character buffer containing the INF file, this routine parses
   the INF into an internal form with Section records, Line records and
   Value records.

Arguments:

   Buffer - contains to ptr to a buffer containing the INF file

   Size - contains the size of the buffer in bytes.

   ErrorLine - if a parse error occurs, this variable receives the line
        number of the line containing the error.


Return Value:

   PVOID - INF handle ptr to be used in subsequent INF calls.

--*/

{
    PWCHAR     Stream, MaxStream, pchSectionName = NULL, pchValue = NULL;
    ULONG      State, InfLine;
    TOKEN      Token;
    BOOLEAN    Done;
    BOOLEAN    Error;
    NTSTATUS   ErrorCode;

    //
    // Initialise the globals
    //
    pINF            = NULL;
    pSectionRecord  = NULL;
    pLineRecord     = NULL;
    pValueRecord    = NULL;

    //
    // Get INF record
    //
    if((pINF = SpMemAllocEx(sizeof(TEXTFILE),'6teS', PagedPool)) == NULL) {
        return NULL;
    }

    RtlZeroMemory(pINF,sizeof(TEXTFILE));

    //
    // Set initial state
    //
    State     = 1;
    InfLine   = 1;
    Stream    = Buffer;
    MaxStream = Buffer + (Size/sizeof(WCHAR));
    Done      = FALSE;
    Error     = FALSE;

    //
    // Enter token processing loop
    //

    while (!Done)       {

       Token = SpGetToken(&Stream, MaxStream, &InfLine);

       switch (State) {
       //
       // STATE1: Start of file, this state remains till first
       //         section is found
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_LBRACE, TOK_STRING
       //               TOK_STRING occurs when reading dblspace.ini
       //
       case 1:
           switch (Token.Type) {
              case TOK_EOL:
                  break;
              case TOK_EOF:
                  Done = TRUE;
                  break;
              case TOK_LBRACE:
                  State = 2;
                  break;
              case TOK_STRING:
                  pchSectionName = SpMemAllocEx( ( wcslen( DBLSPACE_SECTION ) + 1 )*sizeof( WCHAR ),'7teS', PagedPool );
                  if( pchSectionName == NULL ) {
                        Error = Done = TRUE;
                        ErrorCode = STATUS_NO_MEMORY;
                  }
                  wcscpy( pchSectionName, DBLSPACE_SECTION );
                  pchValue = Token.pValue;
                  if ((ErrorCode = SpAppendSection(pchSectionName)) != STATUS_SUCCESS) {
                    Error = Done = TRUE;
                    ErrorCode = STATUS_UNSUCCESSFUL;
                  } else {
                    pchSectionName = NULL;
                    State = 6;
                  }
                  break;
              default:
                  Error = Done = TRUE;
                  ErrorCode = STATUS_UNSUCCESSFUL;
                  break;
           }
           break;

       //
       // STATE 2: Section LBRACE has been received, expecting STRING or RBRACE
       //
       // Valid Tokens: TOK_STRING, TOK_RBRACE
       //
       case 2:
           switch (Token.Type) {
              case TOK_STRING:
                  State = 3;
                  pchSectionName = Token.pValue;
                  break;

              case TOK_RBRACE:
                  State = 4;
                  pchSectionName = CommonStrings[10];
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = STATUS_UNSUCCESSFUL;
                  break;

           }
           break;

       //
       // STATE 3: Section Name received, expecting RBRACE
       //
       // Valid Tokens: TOK_RBRACE
       //
       case 3:
       switch (Token.Type) {
              case TOK_RBRACE:
                State = 4;
                break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = STATUS_UNSUCCESSFUL;
                  break;
           }
           break;
       //
       // STATE 4: Section Definition Complete, expecting EOL
       //
       // Valid Tokens: TOK_EOL, TOK_EOF
       //
       case 4:
           switch (Token.Type) {
              case TOK_EOL:
                  if ((ErrorCode = SpAppendSection(pchSectionName)) != STATUS_SUCCESS)
                    Error = Done = TRUE;
                  else {
                    pchSectionName = NULL;
                    State = 5;
                  }
                  break;

              case TOK_EOF:
                  if ((ErrorCode = SpAppendSection(pchSectionName)) != STATUS_SUCCESS)
                    Error = Done = TRUE;
                  else {
                    pchSectionName = NULL;
                    Done = TRUE;
                  }
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = STATUS_UNSUCCESSFUL;
                  break;
           }
           break;

       //
       // STATE 5: Expecting Section Lines
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_STRING, TOK_LBRACE
       //
       case 5:
           switch (Token.Type) {
              case TOK_EOL:
                  break;
              case TOK_EOF:
                  Done = TRUE;
                  break;
              case TOK_STRING:
                  pchValue = Token.pValue;
                  State = 6;
                  break;
              case TOK_LBRACE:
                  State = 2;
                  break;
              default:
                  Error = Done = TRUE;
                  ErrorCode = STATUS_UNSUCCESSFUL;
                  break;
           }
           break;

       //
       // STATE 6: String returned, not sure whether it is key or value
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA, TOK_EQUAL
       //
       case 6:
           switch (Token.Type) {
              case TOK_EOL:
                  if ( (ErrorCode = SpAppendLine(NULL)) != STATUS_SUCCESS ||
                       (ErrorCode = SpAppendValue(pchValue)) !=STATUS_SUCCESS )
                      Error = Done = TRUE;
                  else {
                      pchValue = NULL;
                      State = 5;
                  }
                  break;

              case TOK_EOF:
                  if ( (ErrorCode = SpAppendLine(NULL)) != STATUS_SUCCESS ||
                       (ErrorCode = SpAppendValue(pchValue)) !=STATUS_SUCCESS )
                      Error = Done = TRUE;
                  else {
                      pchValue = NULL;
                      Done = TRUE;
                  }
                  break;

              case TOK_COMMA:
                  if ( (ErrorCode = SpAppendLine(NULL)) != STATUS_SUCCESS ||
                       (ErrorCode = SpAppendValue(pchValue)) !=STATUS_SUCCESS )
                      Error = Done = TRUE;
                  else {
                      pchValue = NULL;
                      State = 7;
                  }
                  break;

              case TOK_EQUAL:
                  if ( (ErrorCode = SpAppendLine(pchValue)) != STATUS_SUCCESS)
                      Error = Done = TRUE;
                  else {
                      pchValue = NULL;
                      State = 8;
                  }
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = STATUS_UNSUCCESSFUL;
                  break;
           }
           break;

       //
       // STATE 7: Comma received, Expecting another string
       //       Also allow a comma to indicate an empty value ie x = 1,,2
       //
       // Valid Tokens: TOK_STRING TOK_COMMA
       //
       case 7:
           switch (Token.Type) {
              case TOK_COMMA:
                  Token.pValue = CommonStrings[10];
                  if ((ErrorCode = SpAppendValue(Token.pValue)) != STATUS_SUCCESS)
                      Error = Done = TRUE;

                  //
                  // State stays at 7 because we are expecting a string
                  //
                  break;

              case TOK_STRING:
                  if ((ErrorCode = SpAppendValue(Token.pValue)) != STATUS_SUCCESS)
                      Error = Done = TRUE;
                  else
                     State = 9;

                  break;
              default:
                  Error = Done = TRUE;
                  ErrorCode = STATUS_UNSUCCESSFUL;
                  break;
           }
           break;
       //
       // STATE 8: Equal received, Expecting another string
       //          If none, assume there is a single empty string on the RHS
       //
       // Valid Tokens: TOK_STRING, TOK_EOL, TOK_EOF
       //
       case 8:
           switch (Token.Type) {
              case TOK_EOF:
                  Token.pValue = CommonStrings[10];
                  if((ErrorCode = SpAppendValue(Token.pValue)) != STATUS_SUCCESS) {
                      Error = TRUE;
                  }
                  Done = TRUE;
                  break;

              case TOK_EOL:
                  Token.pValue = CommonStrings[10];
                  if((ErrorCode = SpAppendValue(Token.pValue)) != STATUS_SUCCESS) {
                      Error = TRUE;
                      Done = TRUE;
                  } else {
                      State = 5;
                  }
                  break;

              case TOK_STRING:
                  if ((ErrorCode = SpAppendValue(Token.pValue)) != STATUS_SUCCESS)
                      Error = Done = TRUE;
                  else
                      State = 9;

                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = STATUS_UNSUCCESSFUL;
                  break;
           }
           break;
       //
       // STATE 9: String received after equal, value string
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
       //
       case 9:
           switch (Token.Type) {
              case TOK_EOL:
                  State = 5;
                  break;

              case TOK_EOF:
                  Done = TRUE;
                  break;

              case TOK_COMMA:
                  State = 7;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = STATUS_UNSUCCESSFUL;
                  break;
           }
           break;
       //
       // STATE 10: Value string definitely received
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
       //
       case 10:
           switch (Token.Type) {
              case TOK_EOL:
                  State =5;
                  break;

              case TOK_EOF:
                  Done = TRUE;
                  break;

              case TOK_COMMA:
                  State = 7;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = STATUS_UNSUCCESSFUL;
                  break;
           }
           break;

       default:
           Error = Done = TRUE;
           ErrorCode = STATUS_UNSUCCESSFUL;
           break;

       } // end switch(State)


       if (Error) {

           switch (ErrorCode) {
               case STATUS_UNSUCCESSFUL:
                  *ErrorLine = InfLine;
                  break;
               case STATUS_NO_MEMORY:
                  //SpxOutOfMemory();
                  break;
               default:
                  break;
           }

           SpFreeTextFile(pINF);
           if(pchSectionName) {
               SpMemFree(pchSectionName);
           }

           if(pchValue) {
               SpMemFree(pchValue);
           }

           pINF = NULL;
       }
       else {

          //
          // Keep track of line numbers so that we can display Errors
          //

          if(Token.Type == TOK_EOL) {
              InfLine++;
          }
       }

    } // End while

    if(pINF) {

        PTEXTFILE_SECTION p;

        pINF->PreviouslyFoundSection = pINF->pSection;

        for(p=pINF->pSection; p; p=p->pNext) {
            p->PreviouslyFoundLine = p->pLine;
        }
    }

    return(pINF);
}



NTSTATUS
SpAppendSection(
    IN PWCHAR pSectionName
    )

/*++

Routine Description:

    This appends a new section to the section list in the current INF.
    All further lines and values pertain to this new section, so it resets
    the line list and value lists too.

Arguments:

    pSectionName - Name of the new section. ( [SectionName] )

Return Value:

    STATUS_SUCCESS      if successful.
    STATUS_NO_MEMORY    if memory allocation failed.
    STATUS_UNSUCCESSFUL if invalid parameters passed in or the INF buffer not
                           initialised

--*/

{
    PTEXTFILE_SECTION pNewSection;
    StringsSectionType type;
    WCHAR *p;
    USHORT Id;
    USHORT ThreadLang;

    //
    // Check to see if INF initialised and the parameter passed in is valid
    //

    ASSERT(pINF);
    ASSERT(pSectionName);
    if((pINF == NULL) || (pSectionName == NULL)) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // See if we already have a section by this name. If so we want
    // to merge sections.
    //
    for(pNewSection=pINF->pSection; pNewSection; pNewSection=pNewSection->pNext) {
        if(pNewSection->pName && !_wcsicmp(pNewSection->pName,pSectionName)) {
            break;
        }
    }
    if(pNewSection) {
        //
        // Set pLineRecord to point to the list line currently in the section.
        //
        for(pLineRecord = pNewSection->pLine;
            pLineRecord && pLineRecord->pNext;
            pLineRecord = pLineRecord->pNext)
            ;

    } else {
        //
        // Allocate memory for the new section and initialize the structure.
        //
        if((pNewSection = SpMemAllocEx(sizeof(TEXTFILE_SECTION),'8teS', PagedPool)) == NULL) {
            return STATUS_NO_MEMORY;
        }
        RtlZeroMemory(pNewSection,sizeof(TEXTFILE_SECTION));
        pNewSection->pName = pSectionName;

        //
        // Link it in. Also track the [strings] sections in order of desirability:
        //
        // 1) Strings.xxxx where xxxx is the language id part of the current thread locale.
        // 2) Strings.xxxx where xxxx is the primary language id part of the thread locale.
        // 3) Stirngs.xxxx where the primary language id part of xxxx matches the
        //    primary language id part of the thread locale.
        // 4) Plain old [Strings].
        //
        pNewSection->pNext = pINF->pSection;
        pINF->pSection = pNewSection;

        if(!_wcsnicmp(pSectionName,L"Strings",7)) {

            type = StringsSectionNone;

            if(pSectionName[7] == L'.') {
                //
                // The langid part must be in the form of 4 hex digits.
                //
                Id = (USHORT)SpStringToLong(pSectionName+8,&p,16);
                if((p == pSectionName+8+5) && (*p == 0)) {

                    ThreadLang = LANGIDFROMLCID(NtCurrentTeb()->CurrentLocale);

                    if(ThreadLang == Id) {
                        type = StringsSectionExactMatch;
                    } else {
                        if(Id == PRIMARYLANGID(ThreadLang)) {
                            type = StringsSectionExactPrimaryMatch;
                        } else {
                            if(PRIMARYLANGID(Id) == PRIMARYLANGID(ThreadLang)) {
                                type = StringsSectionLoosePrimaryMatch;
                            }
                        }
                    }
                }
            } else {
                if(!pSectionName[7]) {
                    type = StringsSectionPlain;
                }
            }

            if(type > pINF->StringsSectionType) {
                pINF->StringsSection = pNewSection;
            }
        }

        //
        // reset the current line record
        //
        pLineRecord = NULL;
    }

    pSectionRecord = pNewSection;
    pValueRecord   = NULL;

    return STATUS_SUCCESS;
}


NTSTATUS
SpAppendLine(
    IN PWCHAR pLineKey
    )

/*++

Routine Description:

    This appends a new line to the line list in the current section.
    All further values pertain to this new line, so it resets
    the value list too.

Arguments:

    pLineKey - Key to be used for the current line, this could be NULL.

Return Value:

    STATUS_SUCCESS      if successful.
    STATUS_NO_MEMORY    if memory allocation failed.
    STATUS_UNSUCCESSFUL if invalid parameters passed in or current section not
                        initialised


--*/


{
    PTEXTFILE_LINE pNewLine;

    //
    // Check to see if current section initialised
    //

    ASSERT(pSectionRecord);
    if(pSectionRecord == NULL) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Allocate memory for the new Line
    //

    if((pNewLine = SpMemAllocEx(sizeof(TEXTFILE_LINE),'9teS', PagedPool)) == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // Link it in
    //
    pNewLine->pNext  = NULL;
    pNewLine->pValue = NULL;
    pNewLine->pName  = pLineKey;

    if (pLineRecord == NULL) {
        pSectionRecord->pLine = pNewLine;
    } else {
        pLineRecord->pNext = pNewLine;
    }

    pLineRecord  = pNewLine;

    //
    // Reset the current value record
    //

    pValueRecord = NULL;

    return STATUS_SUCCESS;
}



NTSTATUS
SpAppendValue(
    IN PWCHAR pValueString
    )

/*++

Routine Description:

    This appends a new value to the value list in the current line.

Arguments:

    pValueString - The value string to be added.

Return Value:

    STATUS_SUCCESS      if successful.
    STATUS_NO_MEMORY    if memory allocation failed.
    STATUS_UNSUCCESSFUL if invalid parameters passed in or current line not
                        initialised.

--*/

{
    PTEXTFILE_VALUE pNewValue;

    //
    // Check to see if current line record has been initialised and
    // the parameter passed in is valid
    //

    ASSERT(pLineRecord);
    ASSERT(pValueString);
    if((pLineRecord == NULL) || (pValueString == NULL)) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Allocate memory for the new value record
    //

    if((pNewValue = SpMemAllocEx(sizeof(TEXTFILE_VALUE),'ateS', PagedPool)) == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // Link it in.
    //

    pNewValue->pNext  = NULL;
    pNewValue->pName  = pValueString;

    if (pValueRecord == NULL) {
        pLineRecord->pValue = pNewValue;
    } else {
        pValueRecord->pNext = pNewValue;
    }

    pValueRecord = pNewValue;
    return STATUS_SUCCESS;
}

TOKEN
SpGetToken(
    IN OUT PWCHAR *Stream,
    IN PWCHAR      MaxStream,
    IN OUT PULONG LineNumber
    )

/*++

Routine Description:

    This function returns the Next token from the configuration stream.

Arguments:

    Stream - Supplies the address of the configuration stream.  Returns
        the address of where to start looking for tokens within the
        stream.

    MaxStream - Supplies the address of the last character in the stream.


Return Value:

    TOKEN - Returns the next token

--*/

{

    PWCHAR pch, pchStart, pchNew;
    ULONG  Length;
    TOKEN  Token;
    ULONG QuotedQuotes;

    //
    //  Skip whitespace (except for eol)
    //
    pch = *Stream;
    restart:
    while((pch < MaxStream) && (*pch != '\n') && SpIsSpace(*pch)) {
        pch++;
    }


    //
    // Check for comments and remove them
    //

    if((pch < MaxStream) && ((*pch == L';') || (*pch == L'#'))) {
        while((pch < MaxStream) && (*pch != L'\n')) {
            pch++;
        }
    }

    //
    // Check to see if EOF has been reached, set the token to the right
    // value
    //

    if((pch >= MaxStream) || (*pch == 26)) {
        *Stream = pch;
        Token.Type  = TOK_EOF;
        Token.pValue = NULL;
        return Token;
    }


    switch (*pch) {

    case L'[' :
        pch++;
        Token.Type  = TOK_LBRACE;
        Token.pValue = NULL;
        break;

    case L']' :
        pch++;
        Token.Type  = TOK_RBRACE;
        Token.pValue = NULL;
        break;

    case L'=' :
        pch++;
        Token.Type  = TOK_EQUAL;
        Token.pValue = NULL;
        break;

    case L',' :
        pch++;
        Token.Type  = TOK_COMMA;
        Token.pValue = NULL;
        break;

    case L'\n' :
        pch++;
        Token.Type  = TOK_EOL;
        Token.pValue = NULL;
        break;

    case L'\"':
        pch++;
        //
        // Determine quoted string. Within a quoted string, two double-quotes
        // in a row are replaced by a single double-quote. In the normal case
        // the number of characters in the string equals the number of
        // characters in the input field (minus 2 for the quotes) so we
        // preserve performance for that case. In the case where we have
        // quoted quotes, we have to filter the string from the input file
        // into our internal buffer to get rid of some quote chars.
        //
        // Note that in the txtsetup.sif case, setupldr has replaced all
        // terminating quote chars with nul chars in the image we're parsing,
        // so we have to deal with that here.
        //
        pchStart = pch;
        QuotedQuotes = 0;
        morequotedstring:
        while((pch < MaxStream) && *pch && !wcschr(QStringTerminators,*pch)) {
            pch++;
        }
        if(((pch+1) < MaxStream) && (*pch == L'\"') && (*(pch+1) == L'\"')) {
            QuotedQuotes++;
            pch += 2;
            goto morequotedstring;
        }

        if((pch >= MaxStream) || ((*pch != L'\"') && *pch)) {
            Token.Type   = TOK_ERRPARSE;
            Token.pValue = NULL;
        } else {
            Length = (ULONG)(((PUCHAR)pch - (PUCHAR)pchStart)/sizeof(WCHAR));
            if ((pchNew = SpMemAllocEx(((Length + 1) - QuotedQuotes) * sizeof(WCHAR),'bteS', PagedPool)) == NULL) {
                Token.Type = TOK_ERRNOMEM;
                Token.pValue = NULL;
            } else {
                if(Length) {    // Null quoted strings are allowed
                    if(QuotedQuotes) {
                        for(Length=0; pchStart<pch; pchStart++) {
                            if((pchNew[Length++] = *pchStart) == L'\"') {
                                //
                                // The only way this could happen is if there's
                                // another double-quote char after this one, since
                                // otherwise this would have terminated the string.
                                //
                                pchStart++;
                            }
                        }
                    } else {
                        wcsncpy(pchNew,pchStart,Length);
                    }
                }
                pchNew[Length] = 0;
                Token.Type = TOK_STRING;
                Token.pValue = pchNew;
            }
            pch++;   // advance past the quote
        }
        break;

    default:
        //
        // Check to see if we have a line continuation,
        // which is \ followed by only whitespace on the line
        //
        pchStart = pch;
        if((*pch == L'\\') && (HandleLineContinueChars)) {
            pch++;
            //
            // Keep skipping until we hit the end of the file,
            // or the newline, or a non-space character.
            //
            while((pch < MaxStream) && (*pch != L'\n') && SpIsSpace(*pch)) {
                pch++;
            }
            if(pch < MaxStream) {
                if(*pch == L'\n') {
                    //
                    // No non-space chars between the \ and the end of the line.
                    // Ignore the newline.
                    //
                    pch++;
                    *LineNumber = *LineNumber + 1;
                    goto restart;
                } else {
                  
                        //
                        // Not line continuation.
                        // Reset the input to the start of the field.
                        //
                        pch = pchStart;
                   }
            }
        }

        //
        // determine regular string
        //
        pchStart = pch;
        while((pch < MaxStream) && (wcschr(StringTerminators,*pch) == NULL)) {
            pch++;
        }

        if (pch == pchStart) {
            pch++;
            Token.Type  = TOK_ERRPARSE;
            Token.pValue = NULL;
        }
        else {
            ULONG i;
            Length = (ULONG)(((PUCHAR)pch - (PUCHAR)pchStart)/sizeof(WCHAR));
            //
            // Check for a common string...
            //
            for( i = 0; i < sizeof(CommonStrings)/sizeof(PWSTR); i++ ) {
                if( !_wcsnicmp( pchStart, CommonStrings[i], Length ) ) {
                    break;
                }
            }
            if( i < sizeof(CommonStrings)/sizeof(PWSTR) ) {
                //
                // Hit...
                //
                Token.Type = TOK_STRING;
                Token.pValue = CommonStrings[i];
            } else if((pchNew = SpMemAllocEx((Length + 1) * sizeof(WCHAR),'cteS', PagedPool)) == NULL) {
                Token.Type = TOK_ERRNOMEM;
                Token.pValue = NULL;
            }
            else {
                wcsncpy(pchNew, pchStart, Length);
                pchNew[Length] = 0;
                Token.Type = TOK_STRING;
                Token.pValue = pchNew;
            }
        }
        break;
    }

    *Stream = pch;
    return (Token);
}



#if DBG
VOID
pSpDumpTextFileInternals(
    IN PVOID Handle
    )
{
    PTEXTFILE pInf = Handle;
    PTEXTFILE_SECTION pSection;
    PTEXTFILE_LINE pLine;
    PTEXTFILE_VALUE pValue;

    for(pSection = pInf->pSection; pSection; pSection = pSection->pNext) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "Section: [%ws]\r\n",pSection->pName));

        for(pLine = pSection->pLine; pLine; pLine = pLine->pNext) {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "   [%ws] = ",pLine->pName ? pLine->pName : L"(none)"));

            for(pValue = pLine->pValue; pValue; pValue = pValue->pNext) {

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "[%ws] ",pValue->pName));
            }
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "\n"));
        }
    }
}
#endif


PWSTR
SpGetKeyNameByValue(
    IN PVOID Inf,
    IN PWSTR SectionName,
    IN PWSTR Value
    )

/*++

Routine Description:

    Determines the key name of a given value in a given section.

Arguments:

    Inf - Handle to an inf file (txtsetup.sif or winnt.sif).

    SectionName - Supplies the name of the section

    Value - Supplies the string to be matched (eg. "Digital DECpc AXP 150")

Return Value:

    NULL - No match was found.

    PWSTR - Pointer to the canonical shortname of the component.

--*/

{
    ULONG i;
    PWSTR SearchName;

    //
    // If this is not an OEM component, then enumerate the entries in the
    // section in txtsetup.sif
    //
    for (i=0;;i++) {
        SearchName = SpGetSectionLineIndex(Inf,
                                           SectionName,
                                           i,
                                           0);
        if (SearchName==NULL) {
            //
            // we have enumerated the entire section without finding a
            // match, return failure.
            //
            return(NULL);
        }

        if (_wcsicmp(Value, SearchName) == 0) {
            //
            // we have a match
            //
            break;
        }
    }
    //
    // i is the index into the section of the short machine name
    //
    return(SpGetKeyName(Inf,
                        SectionName,
                        i));
}


ULONG
SpCountSectionsInFile(
    IN PVOID Handle
    )
{
    PTEXTFILE_SECTION pSection;
    PTEXTFILE         pFile;
    ULONG             Count;

    pFile = (PTEXTFILE)Handle;
    for(pSection=pFile->pSection, Count = 0;
        pSection;
        pSection = pSection->pNext, Count++
       );

    return(Count);
}

PWSTR
SpGetSectionName(
    IN PVOID Handle,
    IN ULONG Index
    )
{
    PTEXTFILE_SECTION pSection;
    PTEXTFILE         pFile;
    ULONG             Count;
    PWSTR             SectionName;

    pFile = (PTEXTFILE)Handle;
    for(pSection=pFile->pSection, Count = 0;
        pSection && (Count < Index);
        pSection = pSection->pNext, Count++
       );
    return( (pSection != NULL)? pSection->pName : NULL );
}



NTSTATUS
SppWriteTextToFile(
    IN PVOID Handle,
    IN PWSTR String
    )
{
    NTSTATUS        Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PCHAR           OemText;

    OemText = SpToOem( String );

    Status = ZwWriteFile( Handle,
                          NULL,
                          NULL,
                          NULL,
                          &IoStatusBlock,
                          OemText,
                          strlen( OemText ),
                          NULL,
                          NULL );
    SpMemFree( OemText );

    return( Status );
}


NTSTATUS
SpProcessAddRegSection(
    IN PVOID   SifHandle,
    IN LPCWSTR SectionName,
    IN HANDLE  HKLM_SYSTEM,
    IN HANDLE  HKLM_SOFTWARE,
    IN HANDLE  HKCU,
    IN HANDLE  HKR
    )
{
    LPCWSTR p;
    WCHAR *q;
    ULONG Flags;
    HKEY RootKey;
    PTEXTFILE_SECTION pSection;
    PTEXTFILE_LINE pLine;
    PTEXTFILE_VALUE pValue;
    LPWSTR buffer;
    ULONG DataType;
    LPCWSTR ValueName;
    PVOID Data;
    ULONG DataSize;
    ULONG len;
    HANDLE hkey;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;
    KEY_VALUE_BASIC_INFORMATION BasicInfo;
    BOOLEAN b;
    WCHAR c;

    //
    // Find the section.
    //
    pSection = SearchSectionByName(SifHandle,SectionName);
    if(!pSection) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: addreg section %ws missing\n",SectionName));
        return(STATUS_UNSUCCESSFUL);
    }

    for(pLine=pSection->pLine; pLine; pLine=pLine->pNext) {

        buffer = TemporaryBuffer;

        //
        // 0th field is HKCU, HKLM, HKCR, or HKR.
        // 1st field is subkey name, which may be empty.
        //
        if(pValue = pLine->pValue) {

            b = pSpAdjustRootAndSubkeySpec(
                    SifHandle,
                    pValue->pName,
                    pValue->pNext ? pValue->pNext->pName : L"",
                    HKLM_SYSTEM,
                    HKLM_SOFTWARE,
                    HKCU,
                    HKR,
                    &RootKey,
                    buffer
                    );

            if(!b) {
                return(STATUS_UNSUCCESSFUL);
            }

        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: missing root key spec in section %ws\n",SectionName));
            return(STATUS_UNSUCCESSFUL);
        }

        //
        // Advance past key path to free area in buffer
        //
        buffer += wcslen(buffer) + 1;

        //
        // 2nd field is value name, which may be empty.
        //
        if(pValue = pValue->pNext) {
            pValue = pValue->pNext;
        }
        if(pValue) {
            p = pValue->pName;
            pValue = pValue->pNext;
        } else {
            p = L"";
        }

        SpProcessForStringSubs(SifHandle,p,buffer,sizeof(TemporaryBuffer));
        ValueName = buffer;

        //
        // Advance past value name to free area in buffer -
        // align on DWORD boundary.
        //
        buffer += wcslen(buffer) + 1;
        buffer = ALIGN_UP_POINTER(buffer,DWORD);

        //
        // 3rd field is flags.
        //
        if(pValue) {
            SpProcessForStringSubs(SifHandle,pValue->pName,buffer,sizeof(TemporaryBuffer));
            Flags = (ULONG)SpStringToLong(buffer,NULL,0);
            pValue = pValue->pNext;
        } else {
            Flags = 0;
        }

        //
        // 4th field and beyond is data, whose interpretation depends on
        // the flags.
        //
        switch(Flags & FLG_ADDREG_TYPE_MASK) {

        case FLG_ADDREG_TYPE_SZ:
            DataType = REG_SZ;
            break;

        case FLG_ADDREG_TYPE_MULTI_SZ:
            DataType = REG_MULTI_SZ;
            break;

        case FLG_ADDREG_TYPE_EXPAND_SZ:
            DataType = REG_EXPAND_SZ;
            break;

        case FLG_ADDREG_TYPE_BINARY:
            DataType = REG_BINARY;
            break;

        case FLG_ADDREG_TYPE_DWORD:
            DataType = REG_DWORD;
            break;

        case FLG_ADDREG_TYPE_NONE:
            DataType = REG_NONE;
            break;

        default:
            //
            // If the FLG_ADDREG_BINVALUETYPE is set, then the highword
            // can contain just about any random reg data type ordinal value.
            //
            if(Flags & FLG_ADDREG_BINVALUETYPE) {
                //
                // Disallow the following reg data types:
                //
                //    REG_NONE, REG_SZ, REG_EXPAND_SZ, REG_MULTI_SZ
                //
                DataType = (ULONG)HIWORD(Flags);

                if((DataType < REG_BINARY) || (DataType == REG_MULTI_SZ)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: bogus flags value 0x%lx in addreg section %ws\n",Flags,SectionName));
                    return(STATUS_UNSUCCESSFUL);
                }
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: bogus flags value 0x%lx in addreg section %ws\n",Flags,SectionName));
                return(STATUS_UNSUCCESSFUL);
            }
        }
        //
        // Don't support append flag for now.
        //
        if(Flags & FLG_ADDREG_APPEND) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: FLG_ADDREG_APPEND not supported\n"));
            return(STATUS_UNSUCCESSFUL);
        }

        Data = buffer;
        DataSize = 0;

        switch(DataType) {

        case REG_MULTI_SZ:
            //
            // Each remaining field is a member of the multi_sz
            //
            while(pValue) {
                SpProcessForStringSubs(SifHandle,pValue->pName,buffer,sizeof(TemporaryBuffer));
                len = wcslen(buffer);
                buffer = buffer + len + 1;
                DataSize += (len+1)*sizeof(WCHAR);
                pValue = pValue->pNext;
            }
            *buffer = 0;
            DataSize += sizeof(WCHAR);
            break;

        case REG_DWORD:
            //
            // Support specification as 4 bytes of binary data or as a dword.
            //

            *(PULONG)buffer = 0;

            if(pValue) {

                if(pValue->pNext
                && pValue->pNext->pNext
                && pValue->pNext->pNext->pNext
                && !pValue->pNext->pNext->pNext->pNext) {

                    goto binarytype;
                }

                SpProcessForStringSubs(
                    SifHandle,
                    pValue->pName,
                    buffer,
                    sizeof(TemporaryBuffer)
                    );

                *(PULONG)buffer = (ULONG)SpStringToLong(buffer,NULL,0);
            }

            buffer += sizeof(ULONG) / sizeof(WCHAR);
            DataSize = sizeof(ULONG);
            break;

        case REG_SZ:
        case REG_EXPAND_SZ:

            p = pValue ? pValue->pName : L"";

            SpProcessForStringSubs(SifHandle,p,buffer,sizeof(TemporaryBuffer));
            len = wcslen(buffer);

            DataSize = (len+1)*sizeof(WCHAR);
            buffer = buffer + len + 1;
            break;

        case REG_BINARY:
        default:
        binarytype:
            //
            // All other types are specified in binary format.
            //
            while(pValue)  {

                // Advance past value name to free area in buffer -
                // align on DWORD boundary.
                //
                q = buffer + 1 + sizeof(DWORD);
                q = (LPWSTR) ((DWORD_PTR)q & (~((DWORD_PTR) sizeof(DWORD) - 1)));

                SpProcessForStringSubs(SifHandle,pValue->pName,q,sizeof(TemporaryBuffer));

                *(PUCHAR)buffer = (UCHAR)SpStringToLong(q,NULL,16);
                pValue = pValue->pNext;
                DataSize++;
                buffer = (PWSTR) ((PUCHAR)buffer + 1);
            }
            break;
        }

        //
        // Open/create the key if it's a subkey, otherwise just use
        // the root key itself.
        //
        if(*TemporaryBuffer) {

            InitializeObjectAttributes(
                &ObjectAttributes,
                &UnicodeString,
                OBJ_CASE_INSENSITIVE,
                RootKey,
                NULL
                );

            //
            // Multilevel key create, one component at a time.
            //
            q = TemporaryBuffer;
            if(*q == L'\\') {
                q++;
            }
            do {
                if(q = wcschr(q,L'\\')) {
                    c = *q;
                    *q = 0;
                } else {
                    c = 0;
                }

                RtlInitUnicodeString(&UnicodeString,TemporaryBuffer);

                Status = ZwCreateKey(
                            &hkey,
                            READ_CONTROL | KEY_SET_VALUE,
                            &ObjectAttributes,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            &len
                            );

                if(!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: addreg: ZwCreateKey(%ws) failed %lx\n",TemporaryBuffer,Status));
                    return(Status);
                }

                if(c) {
                    *q = c;
                    q++;
                    //
                    // The call to ZwClose is in here so that we retain a handle
                    // to the final full key. We close it later, below.
                    //
                    ZwClose(hkey);
                }
            } while(c);

            RtlInitUnicodeString(&UnicodeString,ValueName);

            //
            // If the key already existed and the noclobber flag is set,
            // then leave the default value alone.
            //
            if(len == REG_OPENED_EXISTING_KEY) {
                if((Flags & FLG_ADDREG_NOCLOBBER) && (*ValueName == 0)) {
                    //
                    // Nothing to do.
                    //
                    ZwClose(hkey);
                    continue;
                } else if (Flags & FLG_ADDREG_DELVAL) {
                    //
                    // If this flag is set, ignore value data and delete the value.
                    //
                    ZwDeleteValueKey(hkey,&UnicodeString);
                }
            }

        } else {
            hkey = RootKey;
            RtlInitUnicodeString(&UnicodeString,ValueName);
        }

        if(!(Flags & FLG_ADDREG_KEYONLY)) {
            //
            // If the noclobber flag is set, see if the value exists
            // and if so leave it alone. To see if the value exists,
            // we attempt to get basic information on the key and pass in
            // a buffer that's large enough only for the fixed part of the
            // basic info structure. If this is successful or reports buffer overflow,
            // then the key exists. Otherwise it doesn't exist.
            //
            if(Flags & FLG_ADDREG_NOCLOBBER) {

                Status = ZwQueryValueKey(
                            hkey,
                            &UnicodeString,
                            KeyValueBasicInformation,
                            &BasicInfo,
                            sizeof(BasicInfo),
                            &len
                            );

                if(NT_SUCCESS(Status) || (Status == STATUS_BUFFER_OVERFLOW)) {
                    Status = STATUS_SUCCESS;
                } else {
                    Status = ZwSetValueKey(hkey,&UnicodeString,0,DataType,Data,DataSize);
                }
            } else {
                Status = ZwSetValueKey(hkey,&UnicodeString,0,DataType,Data,DataSize);
            }
        }

        if(hkey != RootKey) {
            ZwClose(hkey);
        }

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: addreg: status %lx adding value %ws to %ws\n",Status,ValueName,TemporaryBuffer));
            return(Status);
        }
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
SpProcessDelRegSection(
    IN PVOID   SifHandle,
    IN LPCWSTR SectionName,
    IN HANDLE  HKLM_SYSTEM,
    IN HANDLE  HKLM_SOFTWARE,
    IN HANDLE  HKCU,
    IN HANDLE  HKR
    )
{
    LPWSTR KeyPath;
    LPWSTR ValueName;
    PTEXTFILE_SECTION pSection;
    PTEXTFILE_LINE pLine;
    PTEXTFILE_VALUE pValue;
    HKEY RootKey;
    NTSTATUS Status;
    HANDLE hkey;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    BOOLEAN b;

    //
    // Allocate a temporary buffer. The registry delnode routine
    // uses TemporaryBuffer so we can't use that.
    //
    KeyPath = SpMemAllocEx(1000,'dteS', PagedPool);
    ValueName = SpMemAllocEx(1000,'eteS', PagedPool);

    //
    // Find the section.
    //
    pSection = SearchSectionByName(SifHandle,SectionName);
    if(!pSection) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: delreg section %ws missing\n",SectionName));
        SpMemFree(KeyPath);
        SpMemFree(ValueName);
        return(STATUS_UNSUCCESSFUL);
    }

    for(pLine=pSection->pLine; pLine; pLine=pLine->pNext) {

        //
        // 0th field is HKCU, HKLM, HKCR, or HKR.
        // 1st field is subkey name.
        // Both must be present.
        //
        if((pValue = pLine->pValue) && (pValue->pNext)) {

            b = pSpAdjustRootAndSubkeySpec(
                    SifHandle,
                    pValue->pName,
                    pValue->pNext->pName,
                    HKLM_SYSTEM,
                    HKLM_SOFTWARE,
                    HKCU,
                    HKR,
                    &RootKey,
                    KeyPath
                    );

            if(!b) {
                SpMemFree(KeyPath);
                SpMemFree(ValueName);
                return(STATUS_UNSUCCESSFUL);
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: delreg: missing root key spec in section %ws\n",SectionName));
            SpMemFree(KeyPath);
            SpMemFree(ValueName);
            return(STATUS_UNSUCCESSFUL);
        }

        //
        // 2nd field is value name, which may be missing or empty.
        // If it's missing, we want to delete the whole tree rooted at
        // the given subkey. If it's present then we want to delete only
        // one value (which may be the unnamed value).
        //
        if(pValue = pValue->pNext->pNext) {

            SpProcessForStringSubs(SifHandle,pValue->pName,ValueName,1000);

            if(*KeyPath) {

                RtlInitUnicodeString(&UnicodeString,KeyPath);

                InitializeObjectAttributes(
                    &ObjectAttributes,
                    &UnicodeString,
                    OBJ_CASE_INSENSITIVE,
                    RootKey,
                    NULL
                    );

                Status = ZwOpenKey(
                            &hkey,
                            READ_CONTROL | KEY_SET_VALUE,
                            &ObjectAttributes
                            );

                if(!NT_SUCCESS(Status)) {
                    if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: delreg: warning: key %ws not present for delete (%lx)\n",KeyPath,Status));
                    }
                    hkey = NULL;
                }
            } else {
                Status = STATUS_SUCCESS;
                hkey = RootKey;
            }

            if(NT_SUCCESS(Status)) {
                RtlInitUnicodeString(&UnicodeString,ValueName);
                Status = ZwDeleteValueKey(hkey,&UnicodeString);
                if(!NT_SUCCESS(Status) && (Status != STATUS_OBJECT_NAME_NOT_FOUND)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: delreg: warning: delete value %ws from key %ws returned %lx\n",ValueName,KeyPath,Status));
                }
            }

            if(hkey && (hkey != RootKey)) {
                ZwClose(hkey);
            }

        } else {
            //
            // If we're trying to delete the key from the root of the hive,
            // ignore it.
            //
            if(*KeyPath) {
                SppDeleteKeyRecursive(RootKey,KeyPath,TRUE);
            }
        }
    }

    SpMemFree(ValueName);
    SpMemFree(KeyPath);
    return(STATUS_SUCCESS);
}


BOOLEAN
pSpAdjustRootAndSubkeySpec(
    IN  PVOID    SifHandle,
    IN  LPCWSTR  RootKeySpec,
    IN  LPCWSTR  SubkeySpec,
    IN  HANDLE   HKLM_SYSTEM,
    IN  HANDLE   HKLM_SOFTWARE,
    IN  HANDLE   HKCU,
    IN  HANDLE   HKR,
    OUT HANDLE  *RootKey,
    OUT LPWSTR   Subkey
    )
{
    ULONG len;

    if(*SubkeySpec == L'\\') {
        SubkeySpec++;
    }

    if(!_wcsicmp(RootKeySpec,L"HKCR")) {
        //
        // HKEY_CLASSES_ROOT. The ultimate root is HKLM\Software\Classes.
        // We take care not to produce a subkey spec that ends with \.
        //
        *RootKey = HKLM_SOFTWARE;
        wcscpy(Subkey,L"Classes");
        if(*SubkeySpec) {
            if(*SubkeySpec == L'\\') {
                SubkeySpec++;
            }
            Subkey[7] = L'\\';
            SpProcessForStringSubs(SifHandle,SubkeySpec,Subkey+8,sizeof(TemporaryBuffer));
        }
    } else {
        if(!_wcsicmp(RootKeySpec,L"HKLM")) {
            //
            // The first component of the subkey must be SYSTEM or SOFTWARE.
            //
            len = wcslen(SubkeySpec);

            if((len >= 8)
            && ((SubkeySpec[8] == L'\\') || !SubkeySpec[8])
            && !_wcsnicmp(SubkeySpec,L"software",8)) {

                *RootKey = HKLM_SOFTWARE;
                SubkeySpec += 8;

            } else {
                if((len >= 6)
                && ((SubkeySpec[6] == L'\\') || !SubkeySpec[6])
                && !_wcsnicmp(SubkeySpec,L"system",6)) {

                    *RootKey = HKLM_SYSTEM;
                    SubkeySpec += 6;

                } else {

                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unknown root/subkey spec %ws %ws\n",RootKeySpec,SubkeySpec));
                    return(FALSE);
                }
            }

            if(*SubkeySpec == L'\\') {
                SubkeySpec++;
            }

            SpProcessForStringSubs(SifHandle,SubkeySpec,Subkey,sizeof(TemporaryBuffer));

        } else {
            if(!_wcsicmp(RootKeySpec,L"HKCU")) {
                *RootKey = HKCU;
                SpProcessForStringSubs(SifHandle,SubkeySpec,Subkey,sizeof(TemporaryBuffer));
            } else {
                if(!_wcsicmp(RootKeySpec,L"HKR")) {
                    *RootKey = HKR;
                    SpProcessForStringSubs(SifHandle,SubkeySpec,Subkey,sizeof(TemporaryBuffer));
                } else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unknown root key spec %ws\n",RootKeySpec));
                    return(FALSE);
                }
            }
        }
    }

    return(TRUE);
}



BOOLEAN
pSpIsFileInPrivateInf(
    IN PCWSTR FileName
    )

/*++

Routine Description:

    Tell the caller if the file specified is in the inf that
    lists the privates being tested (as specifed by using
    the /M flag in winnt32.exe).

Arguments:

    FileName - supplies name of the file we're looking for.

Return Value:

    TRUE/FALSE indicating the presence of the file in the inf.

--*/
{
    PWSTR  SectionName = L"Privates";
    PWSTR  InfFileName;
    UINT   FileCount,i;

    if (!PrivateInfHandle) {
        return(FALSE);
    }

    FileCount = SpCountLinesInSection(PrivateInfHandle, SectionName);

    for (i=0; i< FileCount; i++) {
        InfFileName = SpGetSectionLineIndex( PrivateInfHandle, SectionName, i, 0);
        if (InfFileName) {
            if (wcscmp(InfFileName, FileName) == 0) {
                return(TRUE);
            }
        }
    }

    return(FALSE);
}

BOOLEAN
SpNonZeroValuesInSection(
    PVOID Handle,
    PCWSTR SectionName,
    ULONG ValueIndex
    )
{
    PTEXTFILE_SECTION pSection;
    PTEXTFILE_LINE pLine;
    PTEXTFILE_VALUE pVal;
    ULONG i;

    pSection = SearchSectionByName((PTEXTFILE) Handle, SectionName);

    for(i = 0; (pLine = SearchLineInSectionByIndex(pSection, i)) != NULL; ++i) {
        pVal = SearchValueInLine(pLine, ValueIndex);

        if(pVal != NULL && pVal->pName != NULL && SpStringToLong(pVal->pName, NULL, 0) != 0) {
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\sptxtfil.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    sptxtfil.h

Abstract:

    Public header file for text file functions in text setup.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:

--*/


#ifndef _SPTXTFIL_DEFN_
#define _SPTXTFIL_DEFN_

#define DBLSPACE_SECTION    L"DBLSPACE_SECTION"


NTSTATUS
SpLoadSetupTextFile(
    IN  PWCHAR  Filename,
    IN  PVOID   Image,      OPTIONAL
    IN  ULONG   ImageSize,  OPTIONAL
    OUT PVOID  *Handle,
    OUT PULONG  ErrorLine,
    IN  BOOLEAN ClearScreen,
    IN  BOOLEAN ScreenNotReady
    );

BOOLEAN
SpFreeTextFile(
    IN PVOID Handle
    );

BOOLEAN
SpSearchTextFileSection(        // searches for the existance of a section
    IN PVOID  Handle,
    IN PWCHAR SectionName
    );

ULONG
SpCountLinesInSection(      // count # lines in section; 0 if no such section
    IN PVOID  Handle,
    IN PWCHAR SectionName
    );

ULONG
SpGetKeyIndex(
  IN PVOID Handle,
  IN PWCHAR SectionName,
  IN PWCHAR KeyName
  );

PWCHAR
SpGetSectionLineIndex(     // given section name, line number and index return the value.
    IN PVOID   Handle,
    IN LPCWSTR SectionName,
    IN ULONG   LineIndex,
    IN ULONG   ValueIndex
    );

BOOLEAN
SpGetSectionKeyExists(     // given section name, key searches existance
    IN PVOID  Handle,
    IN PWCHAR SectionName,
    IN PWCHAR Key
    );

PWCHAR
SpGetSectionKeyIndex(      // given section name, key and index return the value
    IN PVOID  Handle,
    IN PWCHAR Section,
    IN PWCHAR Key,
    IN ULONG  ValueIndex
    );

PWCHAR
SpGetKeyName(               // given section name and line index, return key
    IN PVOID   Handle,
    IN LPCWSTR SectionName,
    IN ULONG   LineIndex
    );

PWSTR
SpGetKeyNameByValue(        // given section name and value, return key
    IN PVOID Inf,
    IN PWSTR SectionName,
    IN PWSTR Value
    );

ULONG
SpCountSectionsInFile(      // count # sections in file;
    IN PVOID Handle
    );

PWSTR
SpGetSectionName(           // given section index, return section name
    IN PVOID Handle,
    IN ULONG Index
    );

VOID
SpProcessForStringSubs(
    IN  PVOID   SifHandle,
    IN  LPCWSTR StringIn,
    OUT LPWSTR  StringOut,
    IN  ULONG   BufferSizeChars
    );

PVOID
SpNewSetupTextFile(
    VOID
    );

VOID
SpAddLineToSection(
    IN PVOID Handle,
    IN PWSTR SectionName,
    IN PWSTR KeyName,       OPTIONAL
    IN PWSTR Values[],
    IN ULONG ValueCount
    );

NTSTATUS
SpWriteSetupTextFile(
    IN PVOID Handle,
    IN PWSTR FilenamePart1,
    IN PWSTR FilenamePart2, OPTIONAL
    IN PWSTR FilenamePart3  OPTIONAL
    );

NTSTATUS
SpProcessAddRegSection(
    IN PVOID   SifHandle,
    IN LPCWSTR SectionName,
    IN HANDLE  HKLM_SYSTEM,
    IN HANDLE  HKLM_SOFTWARE,
    IN HANDLE  HKCU,
    IN HANDLE  HKR
    );

NTSTATUS
SpProcessDelRegSection(
    IN PVOID   SifHandle,
    IN LPCWSTR SectionName,
    IN HANDLE  HKLM_SYSTEM,
    IN HANDLE  HKLM_SOFTWARE,
    IN HANDLE  HKCU,
    IN HANDLE  HKR
    );

BOOLEAN
pSpIsFileInPrivateInf(    
    IN PCWSTR FileName
    );

BOOLEAN
SpNonZeroValuesInSection(
    PVOID Handle,
    PCWSTR SectionName,
    ULONG ValueIndex
    );


#endif // ndef _SPTXTFIL_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spudp.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spudp.h

Abstract:

    Public header file for supporting UDP conversations during setup

Author:

    Sean Selitrennikoff (v-seasel) 16-Jun-1998

Revision History:

--*/


#ifndef _SPUDP_DEFN_
#define _SPUDP_DEFN_

#define BINL_DEFAULT_PORT 4011

extern ULONG RemoteServerIpAddress;
extern ULONG SpUdpSendSequenceNumber;
extern KSPIN_LOCK SpUdpLock;
extern KIRQL SpUdpOldIrql;

typedef NTSTATUS (CALLBACK * SPUDP_RECEIVE_FN)(PVOID DataBuffer, ULONG DataBufferLength);

NTSTATUS
SpUdpConnect(
    VOID
    );


NTSTATUS
SpUdpDisconnect(
    VOID
    );

NTSTATUS
SpUdpSendAndReceiveDatagram(
    IN PVOID                 SendBuffer,
    IN ULONG                 SendBufferLength,
    IN ULONG                 RemoteHostAddress,
    IN USHORT                RemoteHostPort,
    IN SPUDP_RECEIVE_FN      SpUdpReceiveFunc
    );

#endif // _SPUDP_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spupgcfg.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Spupgcfg.c

Abstract:

    Configuration routines for the upgrade case

Author:

    Sunil Pai (sunilp) 18-Nov-1993

Revision History:

--*/

#include "spprecmp.h"
#include <initguid.h>
#include <devguid.h>
#pragma hdrstop

NTSTATUS
SppResetLastKnownGood(
    IN  HANDLE  hKeySystem
    );

BOOLEAN
SppEnsureHardwareProfileIsPresent(
    IN HANDLE   hKeyCCSet
    );

VOID
SppSetGuimodeUpgradePath(
    IN HANDLE hKeySoftwareHive,
    IN HANDLE hKeyControlSet
    );

NTSTATUS
SppMigratePrinterKeys(
    IN HANDLE hControlSet,
    IN HANDLE hDestSoftwareHive
    );

VOID
SppClearMigratedInstanceValues(
    IN HANDLE hKeyCCSet
    );

VOID
SppClearMigratedInstanceValuesCallback(
    IN     HANDLE  SetupInstanceKeyHandle,
    IN     HANDLE  UpgradeInstanceKeyHandle  OPTIONAL,
    IN     BOOLEAN RootEnumerated,
    IN OUT PVOID   Context
    );


//
// Callback routine for SppMigrateDeviceParentId
//
typedef BOOL (*PSPP_DEVICE_MIGRATION_CALLBACK_ROUTINE) (
    IN     HANDLE  InstanceKeyHandle,
    IN     HANDLE  DriverKeyHandle
    );

VOID
SppMigrateDeviceParentId(
    IN HANDLE hKeyCCSet,
    IN PWSTR  DeviceId,
    IN PSPP_DEVICE_MIGRATION_CALLBACK_ROUTINE DeviceMigrationCallbackRoutine
    );

VOID
SppMigrateDeviceParentIdCallback(
    IN     HANDLE  SetupInstanceKeyHandle,
    IN     HANDLE  UpgradeInstanceKeyHandle OPTIONAL,
    IN     BOOLEAN RootEnumerated,
    IN OUT PVOID   Context
    );

BOOL
SppParallelClassCallback(
    IN     HANDLE  InstanceKeyHandle,
    IN     HANDLE  DriverKeyHandle
    );

typedef struct _GENERIC_BUFFER_CONTEXT {
    PUCHAR Buffer;
    ULONG  BufferSize;
} GENERIC_BUFFER_CONTEXT, *PGENERIC_BUFFER_CONTEXT;

typedef struct _DEVICE_MIGRATION_CONTEXT {
    PUCHAR Buffer;
    ULONG  BufferSize;
    ULONG  UniqueParentID;
    PWSTR  ParentIdPrefix;
    HANDLE hKeyCCSet;
    PSPP_DEVICE_MIGRATION_CALLBACK_ROUTINE DeviceMigrationCallbackRoutine;
} DEVICE_MIGRATION_CONTEXT, *PDEVICE_MIGRATION_CONTEXT;


//
// Device classe(s) for root device(s) that need to be deleted on upgrade
//
RootDevnodeSectionNamesType UpgRootDeviceClassesToDelete[] =
{
    { L"RootDeviceClassesToDelete",     RootDevnodeSectionNamesType_ALL,   0x0000, 0xffff },
    { L"RootDeviceClassesToDelete.NT4", RootDevnodeSectionNamesType_NTUPG, 0x0000, 0x04ff },
    { NULL, 0, 0, 0 }
};



NTSTATUS
SpUpgradeNTRegistry(
    IN PVOID    SifHandle,
    IN HANDLE  *HiveRootKeys,
    IN LPCWSTR  SetupSourceDevicePath,
    IN LPCWSTR  DirectoryOnSourceDevice,
    IN HANDLE   hKeyCCSet
    )

/*++

Routine Description:

    This routine does all the NT registry modifications needed on an upgrade.
    This includes the following:

    - Disabling network services
    - Running the addreg/delreg sections specified in txtsetup.sif
    - Deleting various root-enumerated devnode keys specified in txtsetup.sif

Arguments:

    SifHandle - supplies handle to txtsetup.sif.

    HiveRootKeys - supplies array of handles of root keys in the hives
            of the system being upgraded.

    hKeyCCSet: Handle to the root of the control set in the system
        being upgraded.

Return Value:

    Status is returned.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    BOOLEAN b;

    //
    // Disable the network stuff
    //
    Status = SpDisableNetwork(SifHandle,HiveRootKeys[SetupHiveSoftware],hKeyCCSet);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: warning: SpDisableNetworkFailed (%lx)\n",Status));
    }

    //
    // Migrate the parallel class device parent id value to all parallel
    // devices.
    //
    SppMigrateDeviceParentId(hKeyCCSet,
                             L"Root\\PARALLELCLASS\\0000",
                             SppParallelClassCallback);

    //
    // Delete legacy root-enumerated devnode keys out of Enum tree.
    //
    SpDeleteRootDevnodeKeys(SifHandle,
            hKeyCCSet,
            L"RootDevicesToDelete",
            UpgRootDeviceClassesToDelete);

    //
    // Clean the "Migrated" values from device instance keys in the setup
    // and upgrade registries, as appropriate.
    //
    SppClearMigratedInstanceValues(hKeyCCSet);

    //
    // If the user doesn't have any hardware profiles defined (i.e., we're upgrading
    // from a pre-NT4 system), then create them one.
    //
    b = SppEnsureHardwareProfileIsPresent(hKeyCCSet);

    if(!b) {
        return STATUS_UNSUCCESSFUL;
    }

    Status = SppMigratePrinterKeys( hKeyCCSet,
                                    HiveRootKeys[SetupHiveSoftware] );
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: warning: SppMigratePrinterKeys() failed. Status = %lx \n",Status));
    }


    //
    // Perform the general and wide-ranging hive upgrade.
    //
    b = SpHivesFromInfs(
            SifHandle,
            L"HiveInfs.Upgrade",
            SetupSourceDevicePath,
            DirectoryOnSourceDevice,
            HiveRootKeys[SetupHiveSystem],
            HiveRootKeys[SetupHiveSoftware],
            HiveRootKeys[SetupHiveDefault],
            HiveRootKeys[SetupHiveUserdiff]
            );

    if(!b) {
        return(STATUS_UNSUCCESSFUL);
    }


    SppSetGuimodeUpgradePath(HiveRootKeys[SetupHiveSystem],hKeyCCSet);

    //
    // Set 'LastKnownGood' the same as 'Current'
    // Ignore the error in case of failure, since this will
    // not affect the installation process
    //
    Status = SppResetLastKnownGood(HiveRootKeys[SetupHiveSystem]);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: warning: SppResetLastKnownGood() failed. Status = (%lx)\n",Status));
        return(Status);
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
SppDeleteKeyRecursive(
    HANDLE  hKeyRoot,
    PWSTR   Key,
    BOOLEAN ThisKeyToo
    )
/*++

Routine Description:

    Routine to recursively delete all subkeys under the given
    key, including the key given.

Arguments:

    hKeyRoot:    Handle to root relative to which the key to be deleted is
                 specified.

    Key:         Root relative path of the key which is to be recursively deleted.

    ThisKeyToo:  Whether after deletion of all subkeys, this key itself is to
                 be deleted.

Return Value:

    Status is returned.

--*/
{
    ULONG ResultLength;
    PKEY_BASIC_INFORMATION KeyInfo;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    PWSTR SubkeyName;
    HANDLE hKey;

    //
    // Initialize
    //

    KeyInfo = (PKEY_BASIC_INFORMATION)TemporaryBuffer;

    //
    // Open the key
    //

    INIT_OBJA(&Obja,&UnicodeString,Key);
    Obja.RootDirectory = hKeyRoot;
    Status = ZwOpenKey(&hKey,KEY_ALL_ACCESS,&Obja);
    if( !NT_SUCCESS(Status) ) {
        return(Status);
    }

    //
    // Enumerate all subkeys of the current key. if any exist they should
    // be deleted first.  since deleting the subkey affects the subkey
    // index, we always enumerate on subkeyindex 0
    //
    while(1) {
        Status = ZwEnumerateKey(
                    hKey,
                    0,
                    KeyBasicInformation,
                    TemporaryBuffer,
                    sizeof(TemporaryBuffer),
                    &ResultLength
                    );
        if(!NT_SUCCESS(Status)) {
            break;
        }

        //
        // Zero-terminate the subkey name just in case.
        //
        KeyInfo->Name[KeyInfo->NameLength/sizeof(WCHAR)] = 0;

        //
        // Make a duplicate of the subkey name because the name is
        // in TemporaryBuffer, which might get clobbered by recursive
        // calls to this routine.
        //
        SubkeyName = SpDupStringW(KeyInfo->Name);
        Status = SppDeleteKeyRecursive( hKey, SubkeyName, TRUE);
        SpMemFree(SubkeyName);
        if(!NT_SUCCESS(Status)) {
            break;
        }
    }

    ZwClose(hKey);

    //
    // Check the status, if the status is anything other than
    // STATUS_NO_MORE_ENTRIES we failed in deleting some subkey,
    // so we cannot delete this key too
    //

    if( Status == STATUS_NO_MORE_ENTRIES) {
        Status = STATUS_SUCCESS;
    }

    if(!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // else delete the current key if asked to do so
    //

    if( ThisKeyToo ) {
        Status = SpDeleteKey(hKeyRoot, Key);
    }

    return(Status);
}


NTSTATUS
SppCopyKeyRecursive(
    HANDLE  hKeyRootSrc,
    HANDLE  hKeyRootDst,
    PWSTR   SrcKeyPath,   OPTIONAL
    PWSTR   DstKeyPath,   OPTIONAL
    BOOLEAN CopyAlways,
    BOOLEAN ApplyACLsAlways
    )
/*++

Routine Description:

    This routine recursively copies a src key to a destination key.  Any new
    keys that are created will receive the same security that is present on
    the source key.

Arguments:

    hKeyRootSrc: Handle to root src key

    hKeyRootDst: Handle to root dst key

    SrcKeyPath:  src root key relative path to the subkey which needs to be
                 recursively copied. if this is null hKeyRootSrc is the key
                 from which the recursive copy is to be done.

    DstKeyPath:  dst root key relative path to the subkey which needs to be
                 recursively copied.  if this is null hKeyRootDst is the key
                 from which the recursive copy is to be done.

    CopyAlways:  If FALSE, this routine doesn't copy values which are already
                 there on the target tree.

Return Value:

    Status is returned.

--*/

{
    NTSTATUS             Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES    ObjaSrc, ObjaDst;
    UNICODE_STRING       UnicodeStringSrc, UnicodeStringDst, UnicodeStringValue;
    HANDLE               hKeySrc=NULL,hKeyDst=NULL;
    ULONG                ResultLength, Index;
    PWSTR                SubkeyName,ValueName;
    PSECURITY_DESCRIPTOR Security = NULL;

    PKEY_BASIC_INFORMATION      KeyInfo;
    PKEY_VALUE_FULL_INFORMATION ValueInfo;

    //
    // Get a handle to the source key
    //

    if(SrcKeyPath == NULL) {
        hKeySrc = hKeyRootSrc;
    }
    else {
        //
        // Open the Src key
        //

        INIT_OBJA(&ObjaSrc,&UnicodeStringSrc,SrcKeyPath);
        ObjaSrc.RootDirectory = hKeyRootSrc;
        Status = ZwOpenKey(&hKeySrc,KEY_READ,&ObjaSrc);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to open key %ws in the source hive (%lx)\n",SrcKeyPath,Status));
            return(Status);
        }
    }

    //
    // Get a handle to the destination key
    //

    if(DstKeyPath == NULL) {
        hKeyDst = hKeyRootDst;
    } else {
        //
        // First, get the security descriptor from the source key so we can create
        // the destination key with the correct ACL.
        //
        Status = ZwQuerySecurityObject(hKeySrc,
                                       DACL_SECURITY_INFORMATION,
                                       NULL,
                                       0,
                                       &ResultLength
                                      );
        if(Status==STATUS_BUFFER_TOO_SMALL) {
            Security=SpMemAlloc(ResultLength);
            Status = ZwQuerySecurityObject(hKeySrc,
                                           DACL_SECURITY_INFORMATION,
                                           Security,
                                           ResultLength,
                                           &ResultLength);
            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to query security for key %ws in the source hive (%lx)\n",
                         SrcKeyPath,
                         Status)
                       );
                SpMemFree(Security);
                Security=NULL;
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to query security size for key %ws in the source hive (%lx)\n",
                     SrcKeyPath,
                     Status)
                   );
            Security=NULL;
        }
        //
        // Attempt to open (not create) the destination key first.  If we can't
        // open the key because it doesn't exist, then we'll create it and apply
        // the security present on the source key.
        //
        INIT_OBJA(&ObjaDst,&UnicodeStringDst,DstKeyPath);
        ObjaDst.RootDirectory = hKeyRootDst;
        Status = ZwOpenKey(&hKeyDst,KEY_ALL_ACCESS,&ObjaDst);
        if(!NT_SUCCESS(Status)) {
            //
            // Assume that failure was because the key didn't exist.  Now try creating
            // the key.

            ObjaDst.SecurityDescriptor = Security;

            Status = ZwCreateKey(
                        &hKeyDst,
                        KEY_ALL_ACCESS,
                        &ObjaDst,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        NULL
                        );

            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to create key %ws(%lx)\n",DstKeyPath, Status));
                if(SrcKeyPath != NULL) {
                    ZwClose(hKeySrc);
                }
                if(Security) {
                    SpMemFree(Security);
                }
                return(Status);
            }
        } else if (ApplyACLsAlways) {
            Status = ZwSetSecurityObject(
                        hKeyDst,
                        DACL_SECURITY_INFORMATION,
                        Security );

            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to copy ACL to existing key %ws(%lx)\n",DstKeyPath, Status));
            }
        }

        //
        // Free security descriptor buffer before checking return status from ZwCreateKey.
        //
        if(Security) {
            SpMemFree(Security);
        }

    }

    //
    // Enumerate all keys in the source key and recursively create
    // all the subkeys
    //

    KeyInfo = (PKEY_BASIC_INFORMATION)TemporaryBuffer;
    for( Index=0;;Index++ ) {

        Status = ZwEnumerateKey(
                    hKeySrc,
                    Index,
                    KeyBasicInformation,
                    TemporaryBuffer,
                    sizeof(TemporaryBuffer),
                    &ResultLength
                    );

        if(!NT_SUCCESS(Status)) {
            if(Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }
            else {
                if(SrcKeyPath!=NULL) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to enumerate subkeys in key %ws(%lx)\n",SrcKeyPath, Status));
                }
                else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to enumerate subkeys in root key(%lx)\n", Status));
                }
            }
            break;
        }

        //
        // Zero-terminate the subkey name just in case.
        //
        KeyInfo->Name[KeyInfo->NameLength/sizeof(WCHAR)] = 0;

        //
        // Make a duplicate of the subkey name because the name is
        // in TemporaryBuffer, which might get clobbered by recursive
        // calls to this routine.
        //
        SubkeyName = SpDupStringW(KeyInfo->Name);
        Status = SppCopyKeyRecursive(
                     hKeySrc,
                     hKeyDst,
                     SubkeyName,
                     SubkeyName,
                     CopyAlways,
                     ApplyACLsAlways
                     );

        SpMemFree(SubkeyName);

    }

    //
    // Process any errors if found
    //

    if(!NT_SUCCESS(Status)) {

        if(SrcKeyPath != NULL) {
            ZwClose(hKeySrc);
        }
        if(DstKeyPath != NULL) {
            ZwClose(hKeyDst);
        }

        return(Status);
    }

    //
    // Enumerate all values in the source key and create all the values
    // in the destination key
    //
    ValueInfo = (PKEY_VALUE_FULL_INFORMATION)TemporaryBuffer;
    for( Index=0;;Index++ ) {

        Status = ZwEnumerateValueKey(
                    hKeySrc,
                    Index,
                    KeyValueFullInformation,
                    TemporaryBuffer,
                    sizeof(TemporaryBuffer),
                    &ResultLength
                    );

        if(!NT_SUCCESS(Status)) {
            if(Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }
            else {
                if(SrcKeyPath!=NULL) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to enumerate values in key %ws(%lx)\n",SrcKeyPath, Status));
                }
                else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to enumerate values in root key(%lx)\n", Status));
                }
            }
            break;
        }

        //
        // Process the value found and create the value in the destination
        // key
        //
        ValueName = (PWSTR)SpMemAlloc(ValueInfo->NameLength + sizeof(WCHAR));
        ASSERT(ValueName);
        wcsncpy(ValueName, ValueInfo->Name, (ValueInfo->NameLength)/sizeof(WCHAR));
        ValueName[(ValueInfo->NameLength)/sizeof(WCHAR)] = 0;
        RtlInitUnicodeString(&UnicodeStringValue,ValueName);

        //
        // If it is a conditional copy, we need to check if the value already
        // exists in the destination, in which case we shouldn't set the value
        //
        if( !CopyAlways ) {
            ULONG Length;
            PKEY_VALUE_BASIC_INFORMATION DestValueBasicInfo;

            Length = sizeof(KEY_VALUE_BASIC_INFORMATION) + ValueInfo->NameLength + sizeof(WCHAR) + MAX_PATH;
            DestValueBasicInfo = (PKEY_VALUE_BASIC_INFORMATION)SpMemAlloc(Length);
            ASSERT(DestValueBasicInfo);
            Status = ZwQueryValueKey(
                         hKeyDst,
                         &UnicodeStringValue,
                         KeyValueBasicInformation,
                         DestValueBasicInfo,
                         Length,
                         &ResultLength
                         );
            SpMemFree((PVOID)DestValueBasicInfo);

            if(NT_SUCCESS(Status)) {
                //
                // Value exists, we shouldn't change the value
                //
                SpMemFree(ValueName);
                continue;
            }


            if( Status!=STATUS_OBJECT_NAME_NOT_FOUND && Status!=STATUS_OBJECT_PATH_NOT_FOUND) {
                if(DstKeyPath) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to query value %ws in key %ws(%lx)\n",ValueName,DstKeyPath, Status));
                }
                else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to query value %ws in root key(%lx)\n",ValueName, Status));
                }
                SpMemFree(ValueName);
                break;
            }

        }

        Status = ZwSetValueKey(
                    hKeyDst,
                    &UnicodeStringValue,
                    ValueInfo->TitleIndex,
                    ValueInfo->Type,
                    (PBYTE)ValueInfo + ValueInfo->DataOffset,
                    ValueInfo->DataLength
                    );

        if(!NT_SUCCESS(Status)) {
            if(DstKeyPath) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to set value %ws in key %ws(%lx)\n",ValueName,DstKeyPath, Status));
            }
            else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to set value %ws(%lx)\n",ValueName, Status));
            }
            SpMemFree(ValueName);
            break;
        }
        SpMemFree(ValueName);
    }

    //
    // cleanup
    //
    if(SrcKeyPath != NULL) {
        ZwClose(hKeySrc);
    }
    if(DstKeyPath != NULL) {
        ZwClose(hKeyDst);
    }

    return(Status);
}

NTSTATUS
SppResetLastKnownGood(
    IN  HANDLE  hKeySystem
    )
{
    NTSTATUS                        Status;
    ULONG                           ResultLength;
    DWORD                           Value;

    //
    //  Make the appropriate change
    //

    Status = SpGetValueKey(
                 hKeySystem,
                 L"Select",
                 L"Current",
                 sizeof(TemporaryBuffer),
                 (PCHAR)TemporaryBuffer,
                 &ResultLength
                 );

    //
    //  TemporaryBuffer is 32kb long, and it should be big enough
    //  for the data.
    //
    ASSERT( Status != STATUS_BUFFER_OVERFLOW );
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to read value from registry. KeyName = Select, ValueName = Current, Status = (%lx)\n",Status));
        return( Status );
    }

    Value = *(DWORD *)(((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data);
    Status = SpOpenSetValueAndClose( hKeySystem,
                                     L"Select",
                                     L"LastKnownGood",
                                     REG_DWORD,
                                     &Value,
                                     sizeof( ULONG ) );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to write value to registry. KeyName = Select, ValueName = LastKnownGood, Status = (%lx)\n",Status));
    }
    //
    //  We need also to reset the value 'Failed'. Otherwise, the Service Control
    //  Manager will display a popup indicating the LastKnownGood CCSet was
    //  used.
    //
    Value = 0;
    Status = SpOpenSetValueAndClose( hKeySystem,
                                     L"Select",
                                     L"Failed",
                                     REG_DWORD,
                                     &Value,
                                     sizeof( ULONG ) );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to write value to registry. KeyName = Select, ValueName = Failed, Status = (%lx)\n",Status));
    }
    return( Status );
}

VOID
SpDeleteRootDevnodeKeys(
    IN PVOID  SifHandle,
    IN HANDLE hKeyCCSet,
    IN PWSTR DevicesToDelete,
    IN RootDevnodeSectionNamesType *DeviceClassesToDelete
    )

/*++

Routine Description:

    This routine deletes some root-enumerated devnode registry keys
    based on criteria specified in txtsetup.sif.  The following sections
    are processed:

    [RootDevicesToDelete] - this section lists device IDs under
                            HKLM\System\CurrentControlSet\Enum\Root that
                            should be deleted (including their subkeys).

    [RootDeviceClassesToDelete] - this section lists device class GUIDs
                                  whose root-enumerated members are to be
                                  deleted.

    For each device instance key to be deleted, we also delete the corresponding
    Driver key under HKLM\System\CurrentControlSet\Control\Class, if specified.

    We also do two additional operations to clean-up in certain cases where we
    may encounter junk deposited in the registry from NT4:

        1.  Delete any root-enumerated devnode keys that have a nonzero (or
            ill-formed) "Phantom" value, indicating that they're a "private
            phantom".
        2.  Delete any Control subkeys we may find--since these are supposed to
            always be volatile, we _should_ never see these, but we've seen
            cases where OEM preinstalls 'seed' the hives with device instance
            keys including this subkey, and the results are disastrous (i.e.,
            we bugcheck when we encounter a PDO address we'd squirreled away in
            the key on a previous boot thinking it was nonvolatile, hence would
            disappear upon reboot).

Arguments:

    SifHandle: Supplies handle to txtsetup.sif.

    hKeyCCSet: Handle to the root of the control set in the system
        being upgraded.

    DevicesToDelete: Section name containing the root device names that need
        to be deleted.

    DeviceClassesToDelete: Specifies the classes of root devices that need to
        be deleted.

Return Value:

    none.

--*/
{
    HANDLE hRootKey, hDeviceKey, hInstanceKey, hClassKey;
    HANDLE hSetupRootKey, hSetupDeviceKey, hSetupInstanceKey, hSetupClassKey;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString, guidString;
    ULONG LineIndex, DeviceKeyIndex, ResultLength, InstanceKeyIndex;
    PKEY_BASIC_INFORMATION DeviceKeyInfo, InstanceKeyInfo;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    PUCHAR p, q;
    BOOLEAN InstanceKeysEnumerated;
    PWSTR DeviceId, ClassGuidToDelete;
    PUCHAR MyScratchBuffer;
    ULONG MyScratchBufferSize, drvInst;
    BOOLEAN DeleteInstanceKey;
    int SectionIndex;
    DWORD OsFlags = 0;
    DWORD OsVersion = 0;
    DWORD MangledVersion;
    PWSTR Value;

    //
    // Determine OSFlags & OSVersion for going through various sections
    //
    Value = SpGetSectionKeyIndex(WinntSifHandle,
                                SIF_DATA, WINNT_D_NTUPGRADE_W, 0);

    if(Value && _wcsicmp(Value, WINNT_A_YES_W)==0) {
        //
        // It's an NT upgrade
        //
        OsFlags |= RootDevnodeSectionNamesType_NTUPG;
    }
    if(!OsFlags) {
        Value = SpGetSectionKeyIndex(WinntSifHandle,
                                    SIF_DATA, WINNT_D_WIN95UPGRADE_W, 0);

        if (Value && _wcsicmp(Value, WINNT_A_YES_W)==0) {
            //
            // It's a Win9x upgrade
            //
            OsFlags |= RootDevnodeSectionNamesType_W9xUPG;
        }
        if(!OsFlags) {
            //
            // in all other cases assume clean
            //
            OsFlags = RootDevnodeSectionNamesType_CLEAN;
        }
    }

    Value = SpGetSectionKeyIndex(WinntSifHandle,
                                SIF_DATA, WINNT_D_WIN32_VER_W, 0);

    if(Value) {
        //
        // version is bbbbllhh - build/low/high
        // we want this as hhll
        //
        MangledVersion = (DWORD)SpStringToLong( Value, NULL, 16 );

        OsVersion = RtlUshortByteSwap((USHORT)MangledVersion) & 0xffff;
    } else {
        OsVersion = 0;
    }

    //
    // open CCS\Enum\Root in the registry being upgraded.
    //
    INIT_OBJA(&Obja, &UnicodeString, L"Enum\\Root");
    Obja.RootDirectory = hKeyCCSet;

    Status = ZwOpenKey(&hRootKey, KEY_ALL_ACCESS, &Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                   "SETUP: Unable to open upgrade Enum\\Root for devnode deletion.  Status = %lx \n",
                   Status));
        return;
    }

    //
    // Open CCS\Enum\Root in the current setup registry.
    //
    INIT_OBJA(&Obja, &UnicodeString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Enum\\Root");
    Obja.RootDirectory = NULL;

    Status = ZwOpenKey(&hSetupRootKey, KEY_ALL_ACCESS, &Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                   "SETUP: Unable to open setup Enum\\Root for devnode deletion.  Status = %lx \n",
                   Status));
        ZwClose(hRootKey);
        return;
    }

    //
    // Next, open CCS\Control\Class in the registry being upgraded.
    //
    INIT_OBJA(&Obja, &UnicodeString, L"Control\\Class");
    Obja.RootDirectory = hKeyCCSet;

    Status = ZwOpenKey(&hClassKey, KEY_ALL_ACCESS, &Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                   "SETUP: Unable to open upgrade Control\\Class for devnode deletion.  Status = %lx \n",
                   Status));
        ZwClose(hSetupRootKey);
        ZwClose(hRootKey);
        return;
    }

    //
    // Open CCS\Control\Class in the current setup registry.
    //
    INIT_OBJA(&Obja, &UnicodeString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Class");
    Obja.RootDirectory = NULL;

    Status = ZwOpenKey(&hSetupClassKey, KEY_ALL_ACCESS, &Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                   "SETUP: Unable to open setup Control\\Class for devnode deletion.  Status = %lx \n",
                   Status));
        ZwClose(hClassKey);
        ZwClose(hSetupRootKey);
        ZwClose(hRootKey);
        return;
    }

    //
    // Allocate some scratch space to work with.  The most we'll need is enough for 2
    // KEY_BASIC_INFORMATION structures, plus the maximum length of a device instance ID,
    // plus a KEY_VALUE_PARTIAL_INFORMATION structure, plus the length of a driver instance
    // key path [stringified GUID + '\' + 4 digit ordinal + term NULL], plus 2 large integer
    // structures for alignment.
    //
    MyScratchBufferSize = (2*sizeof(KEY_BASIC_INFORMATION)) + (200*sizeof(WCHAR)) +
                          sizeof(KEY_VALUE_PARTIAL_INFORMATION) + ((GUID_STRING_LEN+5)*sizeof(WCHAR) +
                          2*sizeof(LARGE_INTEGER));

    MyScratchBuffer = SpMemAlloc(MyScratchBufferSize);
    if(!MyScratchBuffer) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                   "SETUP: Can't allocate memory for deletion of classes of root-enumerated devnodes!\n"));
        ZwClose(hSetupClassKey);
        ZwClose(hClassKey);
        ZwClose(hSetupRootKey);
        ZwClose(hRootKey);
        return;
    }

    //
    // PART 1: Process [RootDevicesToDelete]
    //

    //
    // Now, traverse the entries under the [RootDevicesToDelete] section, and
    // delete each one.
    //
    for(LineIndex = 0;
        DeviceId = SpGetSectionLineIndex(SifHandle, DevicesToDelete, LineIndex, 0);
        LineIndex++) {

        //
        // Open up the device key so we can enumerate the instances.
        //
        INIT_OBJA(&Obja, &UnicodeString, DeviceId);
        Obja.RootDirectory = hRootKey;

        Status = ZwOpenKey(&hDeviceKey, KEY_ALL_ACCESS, &Obja);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                       "SETUP: Unable to open Enum\\Root\\%ws during devnode deletion.  Status = %lx \n",
                       DeviceId,
                       Status));
            //
            // Skip this key and continue.
            //
            continue;
        }

        //
        // Attempt to open the device key in the setup registry.
        //
        Obja.RootDirectory = hSetupRootKey;

        Status = ZwOpenKey(&hSetupDeviceKey, KEY_ALL_ACCESS, &Obja);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                       "SETUP: Unable to open Enum\\Root\\%ws during devnode deletion.  Status = %lx \n",
                       DeviceId,
                       Status));
            //
            // It's ok if we don't have this device key in the setup registry.
            //
            hSetupDeviceKey = NULL;
        }

        //
        // Now enumerate the instance subkeys under this device key.
        //

        p = ALIGN_UP_POINTER(((PUCHAR)MyScratchBuffer), sizeof(LARGE_INTEGER));

        InstanceKeyInfo = (PKEY_BASIC_INFORMATION)p;
        InstanceKeyIndex = 0;

        while(TRUE) {

            Status = ZwEnumerateKey(hDeviceKey,
                                    InstanceKeyIndex,
                                    KeyBasicInformation,
                                    p,
                                    (ULONG)MyScratchBufferSize,
                                    &ResultLength
                                    );
            if(!NT_SUCCESS(Status)) {
                break;
            }

            //
            // Zero-terminate the instance key name, just in case.
            //
            InstanceKeyInfo->Name[InstanceKeyInfo->NameLength/sizeof(WCHAR)] = 0;

            //
            // Now, open up the instance key so we can check its Driver value.
            //
            INIT_OBJA(&Obja, &UnicodeString, InstanceKeyInfo->Name);
            Obja.RootDirectory = hDeviceKey;

            Status = ZwOpenKey(&hInstanceKey, KEY_ALL_ACCESS, &Obja);
            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                           "SETUP: Unable to open Enum\\Root\\%ws\\%ws for potential devnode deletion.  Status = %lx \n",
                           DeviceId,
                           InstanceKeyInfo->Name,
                           Status));
                //
                // Skip this key and continue.
                //
                InstanceKeyIndex++;
                continue;
            }

            //
            // Attempt to open the same instance key in the setup registry.
            //
            hSetupInstanceKey = NULL;
            if (hSetupDeviceKey) {
                Obja.RootDirectory = hSetupDeviceKey;
                Status = ZwOpenKey(&hSetupInstanceKey, KEY_ALL_ACCESS, &Obja);
                if(!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                               "SETUP: Unable to open setup Enum\\Root\\%ws\\%ws for potential devnode deletion.  Status = %lx \n",
                               DeviceId,
                               InstanceKeyInfo->Name,
                               Status));
                }
            }

            //
            // Now look for some value entries under this instance key.  Don't
            // overwrite the instance key name already in MyScratchBuffer,
            // since we'll need it later.
            //
            q = ALIGN_UP_POINTER(((PUCHAR)p + ResultLength), sizeof(LARGE_INTEGER));

            if (hSetupInstanceKey) {
                //
                // Check if the Migrated value still exists on this registry
                // key.  If so, it was migrated, but wasn't ever used by
                // textmode setup and is now specified to be deleted.
                //
                KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
                RtlInitUnicodeString(&UnicodeString, L"Migrated");
                Status = ZwQueryValueKey(hSetupInstanceKey,
                                         &UnicodeString,
                                         KeyValuePartialInformation,
                                         q,
                                         (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                         &ResultLength);
                if (NT_SUCCESS(Status) &&
                    (KeyValueInfo->Type == REG_DWORD) &&
                    (*(PULONG)(KeyValueInfo->Data) == 1)) {
                    DeleteInstanceKey = TRUE;
                } else {
                    DeleteInstanceKey = FALSE;
                }
            }
            //
            // First check for the presence of old style "Driver" value.
            //
            KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
            RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_DRIVER);
            Status = ZwQueryValueKey(hInstanceKey,
                                     &UnicodeString,
                                     KeyValuePartialInformation,
                                     q,
                                     (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                     &ResultLength
                                     );
            if (NT_SUCCESS(Status) && KeyValueInfo->Type == REG_SZ) {
                //
                // Delete the Driver key.
                //
                SppDeleteKeyRecursive(hClassKey, (PWCHAR)KeyValueInfo->Data, TRUE);

                //
                // Also attempt to delete the driver key from the setup
                // registry.  Note that we don't need to check that it has the
                // same Driver value, since we explicitly migrated it to be the
                // same value at the start of textmode setup.
                //
                if (hSetupInstanceKey && DeleteInstanceKey) {
                    SppDeleteKeyRecursive(hSetupClassKey, (PWCHAR)KeyValueInfo->Data, TRUE);
                }
            } else {
                //
                // Construct the driver instance as "ClassGuid\nnnn"
                //
                KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
                RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_GUID);
                Status = ZwQueryValueKey(hInstanceKey,
                                         &UnicodeString,
                                         KeyValuePartialInformation,
                                         q,
                                         (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                         &ResultLength
                                         );
                if (NT_SUCCESS(Status) && KeyValueInfo->Type == REG_BINARY) {

                    Status = RtlStringFromGUID((REFGUID)KeyValueInfo->Data, &guidString);
                    ASSERT(NT_SUCCESS(Status));
                    if (NT_SUCCESS(Status)) {

                        KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
                        RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_DRVINST);
                        Status = ZwQueryValueKey(hInstanceKey,
                                                 &UnicodeString,
                                                 KeyValuePartialInformation,
                                                 q,
                                                 (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                                 &ResultLength
                                                 );
                        if (NT_SUCCESS(Status) && KeyValueInfo->Type == REG_DWORD) {

                            drvInst = *(PULONG)KeyValueInfo->Data;
                            swprintf((PWCHAR)&KeyValueInfo->Data[0], TEXT("%wZ\\%04u"), &guidString, drvInst);
                            //
                            // Delete the Driver key.
                            //
                            SppDeleteKeyRecursive(hClassKey, (PWCHAR)KeyValueInfo->Data, TRUE);

                            //
                            // Also attempt to delete the driver key from the setup
                            // registry.  Note that we don't need to check that it has the
                            // same Driver value, since we explicitly migrated it to be the
                            // same value at the start of textmode setup.
                            //
                            if (hSetupInstanceKey && DeleteInstanceKey) {
                                SppDeleteKeyRecursive(hSetupClassKey, (PWCHAR)KeyValueInfo->Data, TRUE);
                            }
                        }
                        RtlFreeUnicodeString(&guidString);
                    }
                }
            }
            //
            // Delete the instance key from the setup registry, if we should do so.
            //
            if (hSetupInstanceKey && DeleteInstanceKey) {
                ZwClose(hSetupInstanceKey);
                SppDeleteKeyRecursive(hSetupDeviceKey, InstanceKeyInfo->Name, TRUE);
            }

            //
            // Now close the handle, and move on to the next one.
            //
            ZwClose(hInstanceKey);
            InstanceKeyIndex++;
        }

        //
        // Delete the device key, and all instance subkeys.
        //
        ZwClose(hDeviceKey);
        SppDeleteKeyRecursive(hRootKey, DeviceId, TRUE);

        //
        // If the device has no remaining instances in the setup registry,
        // delete the device key.
        //
        if (hSetupDeviceKey) {
            KEY_FULL_INFORMATION keyFullInfo;
            Status = ZwQueryKey(hSetupDeviceKey,
                                KeyFullInformation,
                                (PVOID)&keyFullInfo,
                                sizeof(KEY_FULL_INFORMATION),
                                &ResultLength);
            ZwClose(hSetupDeviceKey);
            hSetupDeviceKey = NULL;
            if ((NT_SUCCESS(Status) || (Status == STATUS_BUFFER_TOO_SMALL)) &&
                (keyFullInfo.SubKeys == 0)) {
                SppDeleteKeyRecursive(hSetupRootKey, DeviceId, TRUE);
            }
        }
    }


    //
    // PART 2: Process [RootDeviceClassesToDelete]
    //

    //
    // Now, enumerate all remaining device instances under Enum\Root, looking for
    // devices whose class is one of our classes to delete.
    //
    DeviceKeyInfo = (PKEY_BASIC_INFORMATION)MyScratchBuffer;
    DeviceKeyIndex = 0;
    while(TRUE && DeviceClassesToDelete) {

        Status = ZwEnumerateKey(hRootKey,
                                DeviceKeyIndex,
                                KeyBasicInformation,
                                MyScratchBuffer,
                                MyScratchBufferSize,
                                &ResultLength
                               );
        if(!NT_SUCCESS(Status)) {
            break;
        }

        //
        // Reset our flag that indicates whether or not we enumerated the instance
        // subkeys under this key.  We use this later in determining whether the
        // device key itself should be deleted.
        //
        InstanceKeysEnumerated = FALSE;

        //
        // Zero-terminate the subkey name just in case.
        //
        DeviceKeyInfo->Name[DeviceKeyInfo->NameLength/sizeof(WCHAR)] = 0;
        //
        // Go ahead and bump the used-buffer length by sizeof(WCHAR), to
        // accomodate the potential growth caused by adding a terminating NULL.
        //
        ResultLength += sizeof(WCHAR);

        //
        // Now, open up the device key so we can enumerate the instances.
        //
        INIT_OBJA(&Obja, &UnicodeString, DeviceKeyInfo->Name);
        Obja.RootDirectory = hRootKey;

        Status = ZwOpenKey(&hDeviceKey, KEY_ALL_ACCESS, &Obja);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                       "SETUP: Unable to open Enum\\Root\\%ws for potential devnode deletion.  Status = %lx \n",
                       DeviceKeyInfo->Name,
                       Status));
            //
            // Skip this key and continue.
            //
            DeviceKeyIndex++;
            continue;
        }

        //
        // Attempt to open the device key in the setup registry.
        //
        Obja.RootDirectory = hSetupRootKey;

        Status = ZwOpenKey(&hSetupDeviceKey, KEY_ALL_ACCESS, &Obja);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                       "SETUP: Unable to open setup Enum\\Root\\%ws during devnode deletion.  Status = %lx \n",
                       DeviceKeyInfo->Name,
                       Status));
            //
            // It's ok if we don't have this device key in the setup registry.
            //
            hSetupDeviceKey = NULL;
        }

        //
        // Now enumerate the instance subkeys under this device key.  Don't overwrite
        // the device ID key name already in MyScratchBuffer, since we'll probably
        // be needing it again in the case where all subkeys get deleted.
        //

        p = ALIGN_UP_POINTER(((PUCHAR)MyScratchBuffer + ResultLength), sizeof(LARGE_INTEGER));

        InstanceKeyInfo = (PKEY_BASIC_INFORMATION)p;
        InstanceKeyIndex = 0;
        InstanceKeysEnumerated = TRUE;
        while(TRUE) {

            Status = ZwEnumerateKey(hDeviceKey,
                                    InstanceKeyIndex,
                                    KeyBasicInformation,
                                    p,
                                    (ULONG)((MyScratchBuffer + MyScratchBufferSize) - p),
                                    &ResultLength
                                   );
            if(!NT_SUCCESS(Status)) {
                break;
            }

            //
            // Zero-terminate the instance key name, just in case.
            //
            InstanceKeyInfo->Name[InstanceKeyInfo->NameLength/sizeof(WCHAR)] = 0;

            //
            // Go ahead and bump the used-buffer length by sizeof(WCHAR), to
            // accomodate the potential growth caused by adding a terminating NULL.
            //
            ResultLength += sizeof(WCHAR);

            //
            // Now, open up the instance key so we can check its class.
            //
            INIT_OBJA(&Obja, &UnicodeString, InstanceKeyInfo->Name);
            Obja.RootDirectory = hDeviceKey;

            Status = ZwOpenKey(&hInstanceKey, KEY_ALL_ACCESS, &Obja);
            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                           "SETUP: Unable to open Enum\\Root\\%ws\\%ws for potential devnode deletion.  Status = %lx \n",
                           DeviceKeyInfo->Name,
                           InstanceKeyInfo->Name,
                           Status));
                //
                // Skip this key and continue.
                //
                InstanceKeyIndex++;
                continue;
            }

            //
            // Attempt to open the same instance key in the setup registry.
            //
            hSetupInstanceKey = NULL;
            if (hSetupDeviceKey) {
                Obja.RootDirectory = hSetupDeviceKey;
                Status = ZwOpenKey(&hSetupInstanceKey, KEY_ALL_ACCESS, &Obja);
                if(!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                               "SETUP: Unable to open setup Enum\\Root\\%ws\\%ws for potential devnode deletion.  Status = %lx \n",
                               DeviceId,
                               InstanceKeyInfo->Name,
                               Status));
                }
            }

            DeleteInstanceKey = FALSE;

            //
            // Now look for some value entries under this instance key.  Don't
            // overwrite the instance key name already in MyScratchBuffer,
            // since we'll need it if we discover that the instance should be
            // deleted.
            //
            q = ALIGN_UP_POINTER(((PUCHAR)p + ResultLength), sizeof(LARGE_INTEGER));

            //
            // If we find a nonzero Phantom value entry, then the devnode
            // should be removed.
            //
            KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
            RtlInitUnicodeString(&UnicodeString, L"Phantom");
            Status = ZwQueryValueKey(hInstanceKey,
                                     &UnicodeString,
                                     KeyValuePartialInformation,
                                     q,
                                     (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                     &ResultLength
                                    );

            if(NT_SUCCESS(Status) &&
               ((KeyValueInfo->Type != REG_DWORD) ||
                *(PULONG)(KeyValueInfo->Data))) {

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                           "SETUP: SpDeleteRootDevnodeKeys: Encountered a left-over phantom in Enum\\Root\\%ws\\%ws. Deleting key. \n",
                           DeviceKeyInfo->Name,
                           InstanceKeyInfo->Name));

                DeleteInstanceKey = TRUE;
            }

            if(!DeleteInstanceKey) {
                //
                // Unless it is a phantom, if we find a nonzero
                // FirmwareIdentified value entry, then the devnode should not
                // be removed, no matter what class it is.
                //
                KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
                RtlInitUnicodeString(&UnicodeString, L"FirmwareIdentified");
                Status = ZwQueryValueKey(hInstanceKey,
                                         &UnicodeString,
                                         KeyValuePartialInformation,
                                         q,
                                         (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                         &ResultLength
                                         );

                if(NT_SUCCESS(Status) &&
                   ((KeyValueInfo->Type != REG_DWORD) ||
                    *(PULONG)(KeyValueInfo->Data))) {
                    //
                    // Skip this key and continue;
                    //
                    goto CloseInstanceKeyAndContinue;
                }
            }

            if(!DeleteInstanceKey) {
                //
                // Retrieve the ClassGUID value entry.
                //
                // First check for the old value.
                //
                KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
                RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_CLASSGUID);
                Status = ZwQueryValueKey(hInstanceKey,
                                         &UnicodeString,
                                         KeyValuePartialInformation,
                                         q,
                                         (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                         &ResultLength
                                        );
                if(!NT_SUCCESS(Status)) {
                    //
                    // Check the new value.
                    //
                    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
                    RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_GUID);
                    Status = ZwQueryValueKey(hInstanceKey,
                                             &UnicodeString,
                                             KeyValuePartialInformation,
                                             q,
                                             (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                             &ResultLength
                                            );
                    if(NT_SUCCESS(Status) && KeyValueInfo->Type == REG_BINARY) {
                        GUID    guid;
                        UNICODE_STRING guidString;

                        guid = *(GUID *)KeyValueInfo->Data;
                        Status = RtlStringFromGUID(&guid, &guidString);
                        ASSERT(NT_SUCCESS(Status));
                        if (NT_SUCCESS(Status)) {

                            KeyValueInfo->Type = REG_SZ;
                            KeyValueInfo->DataLength = guidString.MaximumLength;
                            RtlCopyMemory(KeyValueInfo->Data, guidString.Buffer, KeyValueInfo->DataLength);
                            RtlFreeUnicodeString(&guidString);
                        } else {

                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                                       "SETUP: SpDeleteRootDevnodeKeys: Failed to convert GUID to string! \n",
                                       DeviceKeyInfo->Name,
                                       InstanceKeyInfo->Name));
                            //
                            // Skip this key and continue;
                            //
                            goto CloseInstanceKeyAndContinue;
                        }
                    } else {

                        DeleteInstanceKey = TRUE;
                    }
                }
            }

            if(DeleteInstanceKey) {
                //
                // The instance key will be deleted.  Check if the instance
                // specifies a corresponding Driver key that should also be
                // deleted.
                //
                // First read the old style "Driver" value.
                //
                KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
                RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_DRIVER);
                Status = ZwQueryValueKey(hInstanceKey,
                                         &UnicodeString,
                                         KeyValuePartialInformation,
                                         q,
                                         (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                         &ResultLength
                                         );
                if (NT_SUCCESS(Status) && KeyValueInfo->Type == REG_SZ) {
                    //
                    // Delete the Driver key.
                    //
                    SppDeleteKeyRecursive(hClassKey, (PWCHAR)KeyValueInfo->Data, TRUE);
                    //
                    // Also attempt to delete the driver key from the setup
                    // registry.  Note that we don't need to check that it has the
                    // same Driver value, since we explicitly migrated it to be the
                    // same value at the start of textmode setup.
                    //
                    if (hSetupInstanceKey) {
                        SppDeleteKeyRecursive(hSetupClassKey, (PWCHAR)KeyValueInfo->Data, TRUE);
                    }
                } else {
                    //
                    // Create the driver instance.
                    //
                    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
                    RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_GUID);
                    Status = ZwQueryValueKey(hInstanceKey,
                                             &UnicodeString,
                                             KeyValuePartialInformation,
                                             q,
                                             (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                             &ResultLength
                                             );
                    if (NT_SUCCESS(Status) && KeyValueInfo->Type == REG_BINARY) {

                        Status = RtlStringFromGUID((REFGUID)KeyValueInfo->Data, &guidString);
                        ASSERT(NT_SUCCESS(Status));
                        if (NT_SUCCESS(Status)) {

                            KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
                            RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_DRVINST);
                            Status = ZwQueryValueKey(hInstanceKey,
                                                     &UnicodeString,
                                                     KeyValuePartialInformation,
                                                     q,
                                                     (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                                     &ResultLength
                                                     );
                            if (NT_SUCCESS(Status) && KeyValueInfo->Type == REG_DWORD) {

                                drvInst = *(PULONG)KeyValueInfo->Data;
                                swprintf((PWCHAR)&KeyValueInfo->Data[0], TEXT("%wZ\\%04u"), &guidString, drvInst);
                                //
                                // Delete the Driver key.
                                //
                                SppDeleteKeyRecursive(hClassKey, (PWCHAR)KeyValueInfo->Data, TRUE);

                                //
                                // Also attempt to delete the driver key from the setup
                                // registry.  Note that we don't need to check that it has the
                                // same Driver value, since we explicitly migrated it to be the
                                // same value at the start of textmode setup.
                                //
                                if (hSetupInstanceKey) {
                                    SppDeleteKeyRecursive(hSetupClassKey, (PWCHAR)KeyValueInfo->Data, TRUE);
                                }
                            }
                            RtlFreeUnicodeString(&guidString);
                        }
                    }
                }
                //
                // Delete the instance key.
                //
                ZwClose(hInstanceKey);
                SppDeleteKeyRecursive(hDeviceKey, InstanceKeyInfo->Name, TRUE);

                //
                // Delete the instance key from the setup registry.
                //
                if (hSetupInstanceKey) {
                    ZwClose(hSetupInstanceKey);
                    SppDeleteKeyRecursive(hSetupDeviceKey, InstanceKeyInfo->Name, TRUE);
                }

                //
                // We deleted the instance key, so set the instance enumeration
                // index back to zero and continue.
                //
                InstanceKeyIndex = 0;
                continue;
            }

            //
            // This value should be exactly the length of a stringified GUID + terminating NULL.
            //
            if(KeyValueInfo->DataLength != (GUID_STRING_LEN * sizeof(WCHAR))) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                           "SETUP: SpDeleteRootDevnodeKeys: Enum\\Root\\%ws\\%ws has corrupted ClassGUID! \n",
                           DeviceKeyInfo->Name,
                           InstanceKeyInfo->Name));
                //
                // Skip this key and continue;
                //
                goto CloseInstanceKeyAndContinue;
            }

            //
            // Now loop through the [RootDeviceClassesToDelete] section to see if this class is one
            // of the ones whose devices we're supposed to delete.
            //
            for(SectionIndex = 0; DeviceClassesToDelete[SectionIndex].SectionName; SectionIndex++) {
                if((!(DeviceClassesToDelete[SectionIndex].SectionFlags & OsFlags))
                   || (OsVersion < DeviceClassesToDelete[SectionIndex].VerLow)
                   || (OsVersion > DeviceClassesToDelete[SectionIndex].VerHigh)) {
                    //
                    // not interesting
                    //
                    continue;
                }
                for(LineIndex = 0;
                    ClassGuidToDelete = SpGetSectionLineIndex(SifHandle,
                                            DeviceClassesToDelete[SectionIndex].SectionName,
                                            LineIndex,
                                            0);
                    LineIndex++) {
                    //
                    // Compare the two GUID strings.
                    //
                    if(!_wcsicmp(ClassGuidToDelete, (PWCHAR)(KeyValueInfo->Data))) {
                        //
                        // We have a match.  Check if the instance specifies a
                        // corresponding Driver key that should also be deleted.
                        //
                        // First check the old style "Driver" value.
                        //
                        KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
                        RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_DRIVER);
                        Status = ZwQueryValueKey(hInstanceKey,
                                                 &UnicodeString,
                                                 KeyValuePartialInformation,
                                                 q,
                                                 (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                                 &ResultLength
                                                 );
                        if (NT_SUCCESS(Status) && KeyValueInfo->Type == REG_SZ) {

                            SppDeleteKeyRecursive(hClassKey, (PWCHAR)KeyValueInfo->Data, TRUE);

                        } else {

                            KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
                            RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_GUID);
                            Status = ZwQueryValueKey(hInstanceKey,
                                                     &UnicodeString,
                                                     KeyValuePartialInformation,
                                                     q,
                                                     (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                                     &ResultLength
                                                     );
                            if (NT_SUCCESS(Status) && KeyValueInfo->Type == REG_BINARY) {

                                Status = RtlStringFromGUID((REFGUID)KeyValueInfo->Data, &guidString);
                                ASSERT(NT_SUCCESS(Status));
                                if (NT_SUCCESS(Status)) {

                                    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
                                    RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_DRVINST);
                                    Status = ZwQueryValueKey(hInstanceKey,
                                                             &UnicodeString,
                                                             KeyValuePartialInformation,
                                                             q,
                                                             (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                                             &ResultLength
                                                             );
                                    if (NT_SUCCESS(Status) && KeyValueInfo->Type == REG_DWORD) {

                                        drvInst = *(PULONG)KeyValueInfo->Data;
                                        swprintf((PWCHAR)&KeyValueInfo->Data[0], TEXT("%wZ\\%04u"), &guidString, drvInst);
                                        //
                                        // Delete the Driver key.
                                        //
                                        SppDeleteKeyRecursive(hClassKey, (PWCHAR)KeyValueInfo->Data, TRUE);
                                    }
                                    RtlFreeUnicodeString(&guidString);
                                }
                            }
                        }

                        //
                        // Nuke this key and break out of the GUID comparison loop.
                        //
                        ZwClose(hInstanceKey);
                        SppDeleteKeyRecursive(hDeviceKey, InstanceKeyInfo->Name, TRUE);
                        goto DeletedKeyRecursive;
                    }
                }
            }
DeletedKeyRecursive:

            if(ClassGuidToDelete) {
                //
                // We deleted the instance key, so set the instance enumeration index back to zero
                // and continue.
                //
                InstanceKeyIndex = 0;
                continue;
            }

CloseInstanceKeyAndContinue:
            //
            // If we get to here, then we've decided that this instance key
            // should not be deleted. Delete the Control key (if there happens
            // to be one) to avoid a painful death at next boot.
            //
            SppDeleteKeyRecursive(hInstanceKey, L"Control", TRUE);

            //
            // Now close the handle, and move on to the next one.
            //
            ZwClose(hInstanceKey);
            if (hSetupInstanceKey) {
                ZwClose(hSetupInstanceKey);
            }
            InstanceKeyIndex++;
        }

        ZwClose(hDeviceKey);

        //
        // If we dropped out of the loop on instance subkeys, and the index is non-zero,
        // then there remains at least one subkey that we didn't delete, so we can't nuke
        // the parent.  Otherwise, delete the device key.
        //
        if(InstanceKeysEnumerated && !InstanceKeyIndex) {
            SppDeleteKeyRecursive(hRootKey, DeviceKeyInfo->Name, TRUE);
            //
            // Since we deleted a key, we must reset our enumeration index.
            //
            DeviceKeyIndex = 0;
        } else {
            //
            // We didn't delete this key--move on to the next one.
            //
            DeviceKeyIndex++;
        }

        //
        // If the device has no remaining instances in the setup registry,
        // delete the device key.
        //
        if (hSetupDeviceKey) {
            KEY_FULL_INFORMATION keyFullInfo;
            Status = ZwQueryKey(hSetupDeviceKey,
                                KeyFullInformation,
                                (PVOID)&keyFullInfo,
                                sizeof(KEY_FULL_INFORMATION),
                                &ResultLength);
            ZwClose(hSetupDeviceKey);
            if ((NT_SUCCESS(Status) || (Status == STATUS_BUFFER_TOO_SMALL)) &&
                (keyFullInfo.SubKeys == 0)) {
                SppDeleteKeyRecursive(hSetupRootKey, DeviceKeyInfo->Name, TRUE);
            }
        }
    }

    ZwClose(hSetupClassKey);
    ZwClose(hClassKey);
    ZwClose(hSetupRootKey);
    ZwClose(hRootKey);

    SpMemFree(MyScratchBuffer);

    return;
}


VOID
SppClearMigratedInstanceValues(
    IN HANDLE hKeyCCSet
    )

/*++

Routine Description:

    This routine removes "Migrated" values from device instance keys in the
    setup registry that were migrated at the start of textmode setup (from
    winnt.sif, via SpMigrateDeviceInstanceData).

Arguments:

    hKeyCCSet: Handle to the root of the control set in the system
               being upgraded.

Return Value:

    None.

Notes:

    This routine is not called when performing an ASR setup (not an upgrade).

    For upgrade setup, it is safe to remove "Migrated" values from all
    device instance keys because these keys were migrated from the system
    registry in the winnt.sif during the winnt32 portion of setup, so all the
    information will be present when we boot into GUI setup after this.

    Note that during ASR setup, these values are not removed during textmode
    setp because the registry these instances were migrated from is not restored
    until late in GUI setup.

--*/
{
    GENERIC_BUFFER_CONTEXT Context;

    //
    // Allocate some scratch space for the callback routine to work with.  The
    // most it will need is enough for a KEY_VALUE_PARTIAL_INFORMATION
    // structure, plus a stringified GUID, plus a large integer structure for
    // alignment.
    //
    Context.BufferSize = sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
                         sizeof(DWORD) + sizeof(LARGE_INTEGER);
    Context.Buffer = SpMemAlloc(Context.BufferSize);
    if(!Context.Buffer) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                   "SETUP: Can't allocate context for SppClearMigratedInstanceValuesCallback, exiting!\n"));
        return;
    }

    //
    // Apply the devnode migration processing callback to all device instance
    // keys.
    //
    SpApplyFunctionToDeviceInstanceKeys(hKeyCCSet,
        SppClearMigratedInstanceValuesCallback,
        &Context);

    //
    // Free the allocated context buffer,
    //
    SpMemFree(Context.Buffer);

    return;
}


VOID
SppMigrateDeviceParentId(
    IN HANDLE hKeyCCSet,
    IN PWSTR  DeviceId,
    IN PSPP_DEVICE_MIGRATION_CALLBACK_ROUTINE DeviceMigrationCallbackRoutine
    )

/*++

Routine Description:

    This routine migrates the ParentIdPrefix or UniqueParentID value from the
    specified device instance in the registry being upgraded to any device
    instances in the current registry, as dictated by the specified
    InstanceKeyCallbackRoutine.

Arguments:

    hKeyCCSet: Handle to the root of the control set in the system
               being upgraded.

    DeviceId:  Device instance Id of the device in the system being upgraded
               whose ParentIdPrefix (or UniqueParentID) value is to be migrated
               to device instance keys in the current system registry.

    InstanceKeyCallbackRoutine: Callback routine for each device instance key in
               the existsing registry that should decide if the values should be
               replaced.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE hEnumKey, hInstanceKey;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    PUCHAR p;
    ULONG ResultLength;
    DEVICE_MIGRATION_CONTEXT DeviceMigrationContext;


    //
    // Allocate some scratch space to work with here, and in our callback
    // routine.  The most we'll need is enough for a
    // KEY_VALUE_PARTIAL_INFORMATION structure, the length of a stringified GUID
    // + '\' + 4 digit ordinal + terminating NULL, plus a large integer
    // structure for alignment.
    //
    DeviceMigrationContext.BufferSize = sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
                                        ((GUID_STRING_LEN + 5)*sizeof(WCHAR)) +
                                        sizeof(LARGE_INTEGER);

    DeviceMigrationContext.Buffer = SpMemAlloc(DeviceMigrationContext.BufferSize);
    if(!DeviceMigrationContext.Buffer) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                   "SETUP: Can't allocate memory for device migration processing!\n"));
        return;
    }

    //
    // Open the Enum key in the registry being upgraded.
    //
    INIT_OBJA(&Obja, &UnicodeString, L"Enum");
    Obja.RootDirectory = hKeyCCSet;

    Status = ZwOpenKey(&hEnumKey, KEY_ALL_ACCESS, &Obja);
    if (!NT_SUCCESS(Status)) {
        SpMemFree(DeviceMigrationContext.Buffer);
        return;
    }

    //
    // Open the specified device instance key in the registry being upgraded.
    //
    INIT_OBJA(&Obja, &UnicodeString, DeviceId);
    Obja.RootDirectory = hEnumKey;

    Status = ZwOpenKey(&hInstanceKey, KEY_ALL_ACCESS, &Obja);

    ZwClose(hEnumKey);

    if (!NT_SUCCESS(Status)) {
        //
        // Couldn't find the key to migrate, so we're done.
        //
        SpMemFree(DeviceMigrationContext.Buffer);
        return;
    }

    //
    // Retrieve the UniqueParentID, if one exists.
    //
    DeviceMigrationContext.ParentIdPrefix = NULL;
    p = ALIGN_UP_POINTER(((PUCHAR)DeviceMigrationContext.Buffer), sizeof(LARGE_INTEGER));
    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)p;
    RtlInitUnicodeString(&UnicodeString, L"UniqueParentID");
    Status = ZwQueryValueKey(hInstanceKey,
                             &UnicodeString,
                             KeyValuePartialInformation,
                             KeyValueInfo,
                             (ULONG)((DeviceMigrationContext.Buffer +
                                      DeviceMigrationContext.BufferSize) - p),
                             &ResultLength);
    if (NT_SUCCESS(Status)) {
        ASSERT(KeyValueInfo->Type == REG_DWORD);
        DeviceMigrationContext.UniqueParentID = *(PULONG)(KeyValueInfo->Data);
    } else {
        //
        // No UniqueParentID, so look for the ParentIdPrefix.
        //
        RtlInitUnicodeString(&UnicodeString, L"ParentIdPrefix");
        Status = ZwQueryValueKey(hInstanceKey,
                                 &UnicodeString,
                                 KeyValuePartialInformation,
                                 KeyValueInfo,
                                 (ULONG)((DeviceMigrationContext.Buffer +
                                          DeviceMigrationContext.BufferSize) - p),
                                 &ResultLength);
        if (NT_SUCCESS(Status)) {
            ASSERT(KeyValueInfo->Type == REG_SZ);
            DeviceMigrationContext.ParentIdPrefix = SpDupStringW((PWSTR)KeyValueInfo->Data);
            ASSERT(DeviceMigrationContext.ParentIdPrefix);
        }
    }

    ZwClose(hInstanceKey);

    if (!NT_SUCCESS(Status)) {
        //
        // If we couldn't find either value, there's nothing more we can do.
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                   "SETUP: No Parent Id values were found for %ws for migration.  Status = %lx \n",
                   DeviceId,
                   Status));
        SpMemFree(DeviceMigrationContext.Buffer);
        return;
    }

    //
    // Supply the hKeyCCSet for the system being upgraded.
    //
    DeviceMigrationContext.hKeyCCSet = hKeyCCSet;

    //
    // Supply the caller specified device migration callback routine.
    //
    DeviceMigrationContext.DeviceMigrationCallbackRoutine = DeviceMigrationCallbackRoutine;

    //
    // Apply the parent id migration callback for all device instance keys.
    // This will in turn, call the specified device instance callback routine to
    // determine whether parent id migration should be done.
    //
    SpApplyFunctionToDeviceInstanceKeys(hKeyCCSet,
        SppMigrateDeviceParentIdCallback,
        &DeviceMigrationContext);

    if (DeviceMigrationContext.ParentIdPrefix) {
        SpMemFree(DeviceMigrationContext.ParentIdPrefix);
    }
    SpMemFree(DeviceMigrationContext.Buffer);

    return;
}


VOID
SppMigrateDeviceParentIdCallback(
    IN     HANDLE  SetupInstanceKeyHandle,
    IN     HANDLE  UpgradeInstanceKeyHandle OPTIONAL,
    IN     BOOLEAN RootEnumerated,
    IN OUT PVOID   Context
    )

/*++

Routine Description:

    This routine is a callback routine for SpApplyFunctionToDeviceInstanceKeys.

Arguments:

    SetupInstanceKeyHandle: Handle to the device instance key in the current
        registry.

    UpgradeInstanceKeyHandle: Handle to the corresponding device instance key in
        the system being upgraded, if it exists.

    Context: User supplied context.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString, guidString;
    PDEVICE_MIGRATION_CONTEXT DeviceMigrationContext;
    PUCHAR p;
    ULONG ResultLength, drvInst;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    HANDLE hClassKey, hDriverKey;
    BOOL CallbackResult;

    UNREFERENCED_PARAMETER(SetupInstanceKeyHandle);
    UNREFERENCED_PARAMETER(RootEnumerated);

    //
    // We only care about keys that exist in the system being upgraded.
    //
    if (!UpgradeInstanceKeyHandle) {
        return;
    }

    //
    // Retrieve the "Driver" value from the instance key.
    //
    DeviceMigrationContext = (PDEVICE_MIGRATION_CONTEXT)Context;
    p = ALIGN_UP_POINTER(((PUCHAR)DeviceMigrationContext->Buffer), sizeof(LARGE_INTEGER));

    //
    // First check the old style "Driver" value.
    //
    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)p;
    RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_DRIVER);
    Status = ZwQueryValueKey(UpgradeInstanceKeyHandle,
                             &UnicodeString,
                             KeyValuePartialInformation,
                             p,
                             (ULONG)((DeviceMigrationContext->Buffer +
                                      DeviceMigrationContext->BufferSize) - p),
                             &ResultLength
                             );
    if (!NT_SUCCESS(Status) || KeyValueInfo->Type != REG_SZ) {

        //
        // Try the new style "GUID" and "DrvInst" values.
        //
        KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)p;
        RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_GUID);
        Status = ZwQueryValueKey(UpgradeInstanceKeyHandle,
                                 &UnicodeString,
                                 KeyValuePartialInformation,
                                 p,
                                 (ULONG)((DeviceMigrationContext->Buffer +
                                          DeviceMigrationContext->BufferSize) - p),
                                 &ResultLength
                                 );
        if (!NT_SUCCESS(Status) || KeyValueInfo->Type != REG_BINARY) {

            return;
        }

        Status = RtlStringFromGUID((REFGUID)KeyValueInfo->Data, &guidString);
        ASSERT(NT_SUCCESS(Status));
        if (!NT_SUCCESS(Status)) {

            return;
        }

        KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)p;
        RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_DRVINST);
        Status = ZwQueryValueKey(UpgradeInstanceKeyHandle,
                                 &UnicodeString,
                                 KeyValuePartialInformation,
                                 p,
                                 (ULONG)((DeviceMigrationContext->Buffer +
                                          DeviceMigrationContext->BufferSize) - p),
                                 &ResultLength
                                 );
        if (!NT_SUCCESS(Status) || KeyValueInfo->Type != REG_DWORD) {

            return;
        }
        drvInst = *(PULONG)KeyValueInfo->Data;
        swprintf((PWCHAR)&KeyValueInfo->Data[0], TEXT("%wZ\\%04u"), &guidString, drvInst);
        RtlFreeUnicodeString(&guidString);
    }

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
               "SETUP: SppMigrateDeviceParentIdCallback: Driver = %ws\n",
               (PWSTR)KeyValueInfo->Data));

    //
    // Open the Control\Class key in the system being upgraded.
    //
    INIT_OBJA(&Obja, &UnicodeString, L"Control\\Class");
    Obja.RootDirectory = DeviceMigrationContext->hKeyCCSet;

    Status = ZwOpenKey(&hClassKey, KEY_ALL_ACCESS, &Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                   "SETUP: Unable to open Class key for device migration processing.  Status = %lx \n",
                   Status));
        return;
    }

    //
    // Open the device's "Driver" key.
    //
    INIT_OBJA(&Obja, &UnicodeString, (PWSTR)KeyValueInfo->Data);
    Obja.RootDirectory = hClassKey;

    Status = ZwOpenKey(&hDriverKey, KEY_ALL_ACCESS, &Obja);

    ZwClose(hClassKey);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                   "SETUP: Unable to open Class\\%ws key for device migration processing.  Status = %lx \n",
                   (PWSTR)KeyValueInfo->Data,
                   Status));
        return;
    }

    //
    // Call the specified device migration callback routine.
    //
    CallbackResult = (DeviceMigrationContext->DeviceMigrationCallbackRoutine)(
                          UpgradeInstanceKeyHandle,
                          hDriverKey);

    ZwClose(hDriverKey);

    if (!CallbackResult) {
        return;
    }

    //
    // Replace the UniqueParentID or ParentIdPrefix values for this device
    // instance.  First, remove any UniqueParentId or ParentIdPrefix values that
    // already exist for this instance key.
    //
    RtlInitUnicodeString(&UnicodeString, L"ParentIdPrefix");
    ZwDeleteValueKey(UpgradeInstanceKeyHandle, &UnicodeString);

    RtlInitUnicodeString(&UnicodeString, L"UniqueParentID");
    ZwDeleteValueKey(UpgradeInstanceKeyHandle, &UnicodeString);

    //
    // Replace the instance key's UniqueParentID or ParentIdPrefix with that
    // from the device migration context.
    //
    if (!DeviceMigrationContext->ParentIdPrefix) {

        //
        // We're using the old UniqueParentID mechanism.
        //
        RtlInitUnicodeString(&UnicodeString, L"UniqueParentID");
        Status = ZwSetValueKey(UpgradeInstanceKeyHandle,
                               &UnicodeString,
                               0,
                               REG_DWORD,
                               &DeviceMigrationContext->UniqueParentID,
                               sizeof(DeviceMigrationContext->UniqueParentID));
        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                       "SETUP: Unable to set %ws during device migration processing.  Status = %lx \n",
                       UnicodeString.Buffer,
                       Status));
        }
    } else {

        //
        // We're using the ParentIdPrefix mechanism.
        //
        RtlInitUnicodeString(&UnicodeString, L"ParentIdPrefix");
        Status = ZwSetValueKey(UpgradeInstanceKeyHandle,
                               &UnicodeString,
                               0,
                               REG_SZ,
                               DeviceMigrationContext->ParentIdPrefix,
                               (wcslen(DeviceMigrationContext->ParentIdPrefix)+1)*sizeof(WCHAR));
        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                       "SETUP: Unable to set %ws during device migration processing.  Status = %lx \n",
                       UnicodeString.Buffer,
                       Status));
        }
    }

    return;
}


BOOL
SppParallelClassCallback(
    IN     HANDLE  InstanceKeyHandle,
    IN     HANDLE  DriverKeyHandle
    )

/*++

Routine Description:

    This routine is a callback routine for SpApplyFunctionToDeviceInstanceKeys.

Arguments:

    InstanceKeyHandle: Handle to the device instance key in the system being
        upgraded.

    DriverKeyHandle: Handle to the driver key for device instance in
        the system being upgraded.

Return Value:

    Returns TRUE/FALSE.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    PUCHAR MyScratchBuffer;
    ULONG MyScratchBufferSize;
    PUCHAR p;
    ULONG ResultLength;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    HANDLE hClassKey, hDriverKey;
    UNICODE_STRING UnicodeString;
    GUID guid;

    //
    // Allocate some scratch space to work with.  The most we'll need is enough
    // for a KEY_VALUE_PARTIAL_INFORMATION structure, plus a stringified GUID,
    // plus a large integer structure for alignment.
    //
    MyScratchBufferSize = sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
                          (GUID_STRING_LEN * sizeof(WCHAR)) +
                          sizeof(LARGE_INTEGER);
    MyScratchBuffer = SpMemAlloc(MyScratchBufferSize);
    if(!MyScratchBuffer) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                   "SETUP: Can't allocate memory for parallel migration processing!\n"));
        return FALSE;
    }

    //
    // Check the class of the enumerated device instance, and see if it is a
    // member of the "Ports" class.
    //
    p = ALIGN_UP_POINTER(((PUCHAR)MyScratchBuffer), sizeof(LARGE_INTEGER));

    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)p;
    RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_CLASSGUID);
    Status = ZwQueryValueKey(InstanceKeyHandle,
                             &UnicodeString,
                             KeyValuePartialInformation,
                             p,
                             (ULONG)((MyScratchBuffer + MyScratchBufferSize) - p),
                             &ResultLength);
    if (NT_SUCCESS(Status)) {

        if (KeyValueInfo->Type == REG_SZ) {

            RtlInitUnicodeString(&UnicodeString, (PWSTR)KeyValueInfo->Data);
            Status = RtlGUIDFromString(&UnicodeString, &guid);

        } else {

            Status = STATUS_UNSUCCESSFUL;
        }
    } else {

        KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)p;
        RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_GUID);
        Status = ZwQueryValueKey(InstanceKeyHandle,
                                 &UnicodeString,
                                 KeyValuePartialInformation,
                                 p,
                                 (ULONG)((MyScratchBuffer + MyScratchBufferSize) - p),
                                 &ResultLength);
        if (NT_SUCCESS(Status)) {

            if (KeyValueInfo->Type == REG_BINARY) {

                guid = *(GUID *)KeyValueInfo->Data;
            } else {

                Status = STATUS_UNSUCCESSFUL;
            }
        }
    }
    if (NT_SUCCESS(Status)) {

        if (!IsEqualGUID(&GUID_DEVCLASS_PORTS, &guid)) {
            //
            // Not a match.
            //
            Status = STATUS_UNSUCCESSFUL;
        }
    }

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    //
    // Check the "PortSubClass" value from the device's driver key.
    //
    RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_PORTSUBCLASS);
    Status = ZwQueryValueKey(DriverKeyHandle,
                             &UnicodeString,
                             KeyValuePartialInformation,
                             p,
                             (ULONG)((MyScratchBuffer + MyScratchBufferSize) - p),
                             &ResultLength);

    if (!NT_SUCCESS(Status) ||
        (KeyValueInfo->Type != REG_BINARY) ||
        (KeyValueInfo->DataLength != sizeof(BYTE)) ||
        (*(PBYTE)(KeyValueInfo->Data) != 0x0)) {
        return FALSE;
    }

    //
    // This device instance is a parallel port device.
    //
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
               "SETUP: \tSppParallelClassCallback: Found a parallel port!\n"));

    return TRUE;
}


VOID
SppClearMigratedInstanceValuesCallback(
    IN     HANDLE  SetupInstanceKeyHandle,
    IN     HANDLE  UpgradeInstanceKeyHandle  OPTIONAL,
    IN     BOOLEAN RootEnumerated,
    IN OUT PVOID   Context
    )

/*++

Routine Description:

    This routine is a callback routine for SpApplyFunctionToDeviceInstanceKeys.

Arguments:

    SetupInstanceKeyHandle: Handle to the device instance key in the current
        registry.

    UpgradeInstanceKeyHandle: Handle to the corresponding device instance key in
        the system being upgraded, if it exists.

    Context: User supplied context.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    PUCHAR p;
    ULONG ResultLength;
    PGENERIC_BUFFER_CONTEXT BufferContext;

    //
    // To save us the effort of allocating a buffer on every iteration of the
    // callback, SppClearMigratedInstanceValues has already allocated a buffer
    // for us to use, and supplied to us as our context.
    //
    BufferContext = (PGENERIC_BUFFER_CONTEXT)Context;

    ASSERT(BufferContext->Buffer);
    ASSERT(BufferContext->BufferSize > 0);

    //
    // Check if the Migrated value still exists on this registry key.  If so, it
    // was migrated, but wasn't seen by textmode setup.
    //
    p = ALIGN_UP_POINTER(((PUCHAR)BufferContext->Buffer), sizeof(LARGE_INTEGER));
    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)p;
    RtlInitUnicodeString(&UnicodeString, L"Migrated");
    Status = ZwQueryValueKey(SetupInstanceKeyHandle,
                             &UnicodeString,
                             KeyValuePartialInformation,
                             p,
                             (ULONG)(BufferContext->BufferSize),
                             &ResultLength);
    if (NT_SUCCESS(Status)) {
        //
        // If there is a Migrated value, it should be well-formed, but we still
        // want to delete it no matter what it is.
        //
        ASSERT(KeyValueInfo->Type == REG_DWORD);
        ASSERT(*(PULONG)(KeyValueInfo->Data) == 1);

        if (UpgradeInstanceKeyHandle) {
            //
            // This instance key exists in the upgraded registry, so we'll
            // remove the Migrated value from it in the setup registry.
            //
            Status = ZwDeleteValueKey(SetupInstanceKeyHandle, &UnicodeString);
            ASSERT(NT_SUCCESS(Status));

            //
            // Remove the migrated value from the key in the upgraded registry
            // only if it is root-enumerated, because those devices should
            // always be enumerated, no matter what.
            //
            // (If the instance key is not root-enumerated, the value should
            // really stay as it is - so that migrated values on ASR machines
            // are preserved on upgrades.)
            //
            if (RootEnumerated) {
                ZwDeleteValueKey(UpgradeInstanceKeyHandle, &UnicodeString);
            }
        }
    }

    return;
}


VOID
SpApplyFunctionToDeviceInstanceKeys(
    IN HANDLE hKeyCCSet,
    IN PSPP_INSTANCEKEY_CALLBACK_ROUTINE InstanceKeyCallbackRoutine,
    IN OUT PVOID Context
    )

/*++

Routine Description:

    This routine enumerates device instance keys in the setup registry, and
    calls the specified callback routine for each such device instance key.

Arguments:

    hKeyCCSet: Handle to the root of the control set in the system
               being upgraded.

    InstanceKeyCallbackRoutine - Supplies a pointer to a function that will be
        called for each device instance key in the setup registry.
        The prototype of the function is as follows:

          typedef VOID (*PSPP_INSTANCEKEY_CALLBACK_ROUTINE) (
              IN     HANDLE  SetupInstanceKeyHandle,
              IN     HANDLE  UpgradeInstanceKeyHandle  OPTIONAL,
              IN     BOOLEAN RootEnumerated,
              IN OUT PVOID   Context
              );

        where SetupInstanceKeyHandle is the handle to an enumerated device
        instance key in the setup registry, UpgradeInstanceKeyHandle is the
        handle to the corresponding device instance key in the registry being
        upgraded (if exists), and Context is a pointer to user-defined data.

Return Value:

    None.

Note:

    Note that a device instance key in the system being upgraded is opened only
    after the corresponding device instance key was enumerated in the setup
    registry.

--*/
{
    NTSTATUS Status;
    HANDLE hEnumKey, hEnumeratorKey, hDeviceKey, hInstanceKey;
    HANDLE hUpgradeEnumKey, hUpgradeEnumeratorKey, hUpgradeDeviceKey, hUpgradeInstanceKey;
    BOOLEAN RootEnumerated;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    PUCHAR MyScratchBuffer;
    ULONG MyScratchBufferSize;
    ULONG EnumeratorKeyIndex, DeviceKeyIndex, InstanceKeyIndex, ResultLength;
    PKEY_BASIC_INFORMATION EnumeratorKeyInfo, DeviceKeyInfo, InstanceKeyInfo;
    PUCHAR p, q, r;

    //
    // First, open CCS\Enum in the setup registry.
    //
    INIT_OBJA(&Obja, &UnicodeString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Enum");
    Obja.RootDirectory = NULL;

    Status = ZwOpenKey(&hEnumKey, KEY_ALL_ACCESS, &Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                   "SETUP: Unable to open setup Enum for device migration processing.  Status = %lx \n",
                   Status));
        return;
    }

    //
    // Next, open CCS\Enum in the registry being upgraded.
    //
    INIT_OBJA(&Obja, &UnicodeString, L"Enum");
    Obja.RootDirectory = hKeyCCSet;

    Status = ZwOpenKey(&hUpgradeEnumKey, KEY_ALL_ACCESS, &Obja);
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                   "SETUP: Unable to open upgrade Enum for device migration processing.  Status = %lx \n",
                   Status));
        //
        // This is really odd, but not fatal.
        //
        hUpgradeEnumKey = NULL;
    }

    //
    // Allocate some scratch space to work with.  The most we'll need is enough
    // for 3 KEY_BASIC_INFORMATION structures, plus the maximum length of a
    // device instance ID, plus 3 large integer structures for alignment.
    //
    MyScratchBufferSize = (3*sizeof(KEY_BASIC_INFORMATION)) +
                          (200*sizeof(WCHAR)) +
                          (3*sizeof(LARGE_INTEGER));

    MyScratchBuffer = SpMemAlloc(MyScratchBufferSize);
    if(!MyScratchBuffer) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                   "SETUP: Can't allocate memory for device migration processing!\n"));
        ZwClose(hEnumKey);
        return;
    }

    //
    // First, enumerate the enumerator subkeys under the Enum key.
    //
    EnumeratorKeyInfo = (PKEY_BASIC_INFORMATION)MyScratchBuffer;
    EnumeratorKeyIndex = 0;
    while(TRUE) {

        Status = ZwEnumerateKey(hEnumKey,
                                EnumeratorKeyIndex,
                                KeyBasicInformation,
                                MyScratchBuffer,
                                MyScratchBufferSize,
                                &ResultLength);
        if(!NT_SUCCESS(Status)) {
            break;
        }

        //
        // Zero-terminate the subkey name just in case.
        //
        EnumeratorKeyInfo->Name[EnumeratorKeyInfo->NameLength/sizeof(WCHAR)] = 0;

        //
        // Go ahead and bump the used-buffer length by sizeof(WCHAR), to
        // accomodate the potential growth caused by adding a terminating NULL.
        //
        ResultLength += sizeof(WCHAR);

        //
        // Determine if the subkey devices are root-enumerated.
        //
        RootEnumerated = (_wcsnicmp(EnumeratorKeyInfo->Name,
                                    REGSTR_KEY_ROOTENUM, 4) == 0);

        //
        // Now, open up the enumerator key so we can enumerate the devices.
        //
        INIT_OBJA(&Obja, &UnicodeString, EnumeratorKeyInfo->Name);
        Obja.RootDirectory = hEnumKey;

        Status = ZwOpenKey(&hEnumeratorKey, KEY_ALL_ACCESS, &Obja);
        if(!NT_SUCCESS(Status)) {
            //
            // Skip this key and continue.
            //
            EnumeratorKeyIndex++;
            continue;
        }

        //
        // Open the enumerator key in the registry being upgraded.
        //
        hUpgradeEnumeratorKey = NULL;
        if (hUpgradeEnumKey) {
            Obja.RootDirectory = hUpgradeEnumKey;

            Status = ZwOpenKey(&hUpgradeEnumeratorKey, KEY_ALL_ACCESS, &Obja);
            if(!NT_SUCCESS(Status)) {
                //
                // Again, this is odd, but not fatal.
                //
                hUpgradeEnumeratorKey = NULL;
            }
        }

        //
        // Now enumerate the device subkeys under this enumerator key.  Don't
        // overwrite the enumerator key name already in MyScratchBuffer.
        //
        p = ALIGN_UP_POINTER(((PUCHAR)MyScratchBuffer + ResultLength), sizeof(LARGE_INTEGER));

        //
        // Now, enumerate all devices under the enumerator.
        //
        DeviceKeyInfo = (PKEY_BASIC_INFORMATION)p;
        DeviceKeyIndex = 0;
        while(TRUE) {

            Status = ZwEnumerateKey(hEnumeratorKey,
                                    DeviceKeyIndex,
                                    KeyBasicInformation,
                                    p,
                                    (ULONG)((MyScratchBuffer + MyScratchBufferSize) - p),
                                    &ResultLength);
            if(!NT_SUCCESS(Status)) {
                break;
            }

            //
            // Zero-terminate the subkey name just in case.
            //
            DeviceKeyInfo->Name[DeviceKeyInfo->NameLength/sizeof(WCHAR)] = 0;

            //
            // Go ahead and bump the used-buffer length by sizeof(WCHAR), to
            // accomodate the potential growth caused by adding a terminating NULL.
            //
            ResultLength += sizeof(WCHAR);

            //
            // Now, open up the device key so we can enumerate the instances.
            //
            INIT_OBJA(&Obja, &UnicodeString, DeviceKeyInfo->Name);
            Obja.RootDirectory = hEnumeratorKey;

            Status = ZwOpenKey(&hDeviceKey, KEY_ALL_ACCESS, &Obja);
            if(!NT_SUCCESS(Status)) {
                //
                // Skip this key and continue.
                //
                DeviceKeyIndex++;
                continue;
            }

            //
            // Open the device key in the registry being upgraded.
            //
            hUpgradeDeviceKey = NULL;
            if (hUpgradeEnumeratorKey) {
                Obja.RootDirectory = hUpgradeEnumeratorKey;

                Status = ZwOpenKey(&hUpgradeDeviceKey, KEY_ALL_ACCESS, &Obja);
                if(!NT_SUCCESS(Status)) {
                    //
                    // Again, this is odd, but not fatal.
                    //
                    hUpgradeDeviceKey = NULL;
                }
            }

            //
            // Now enumerate the device subkeys under this enumerator key.  Don't
            // overwrite the enumerator key name already in MyScratchBuffer.
            //
            q = ALIGN_UP_POINTER(((PUCHAR)p + ResultLength), sizeof(LARGE_INTEGER));

            //
            // Now, enumerate all instances under the device.
            //
            InstanceKeyInfo = (PKEY_BASIC_INFORMATION)q;
            InstanceKeyIndex = 0;
            while(TRUE) {

                Status = ZwEnumerateKey(hDeviceKey,
                                        InstanceKeyIndex,
                                        KeyBasicInformation,
                                        q,
                                        (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                        &ResultLength);
                if(!NT_SUCCESS(Status)) {
                    break;
                }

                //
                // Zero-terminate the subkey name just in case.
                //
                InstanceKeyInfo->Name[InstanceKeyInfo->NameLength/sizeof(WCHAR)] = 0;

                //
                // Go ahead and bump the used-buffer length by sizeof(WCHAR), to
                // accomodate the potential growth caused by adding a terminating NULL.
                //
                ResultLength += sizeof(WCHAR);

                //
                // Now, open up the instance key.
                //
                INIT_OBJA(&Obja, &UnicodeString, InstanceKeyInfo->Name);
                Obja.RootDirectory = hDeviceKey;

                Status = ZwOpenKey(&hInstanceKey, KEY_ALL_ACCESS, &Obja);
                if(!NT_SUCCESS(Status)) {
                    //
                    // Skip this key and continue.
                    //
                    InstanceKeyIndex++;
                    continue;
                }

                //
                // Open the instance key in the registry being upgraded.
                //
                hUpgradeInstanceKey = NULL;
                if (hUpgradeDeviceKey) {
                    Obja.RootDirectory = hUpgradeDeviceKey;

                    Status = ZwOpenKey(&hUpgradeInstanceKey, KEY_ALL_ACCESS, &Obja);
                    if(!NT_SUCCESS(Status)) {
                        //
                        // Again, this is odd, but not fatal.
                        //
                        hUpgradeInstanceKey = NULL;
                    }
                }

                //
                // Call the specified callback routine for this device instance key.
                //
                InstanceKeyCallbackRoutine(hInstanceKey,
                                           hUpgradeInstanceKey,
                                           RootEnumerated,
                                           Context);

                InstanceKeyIndex++;
                ZwClose(hInstanceKey);
                if (hUpgradeInstanceKey) {
                    ZwClose(hUpgradeInstanceKey);
                }
            }
            DeviceKeyIndex++;
            ZwClose(hDeviceKey);
            if (hUpgradeDeviceKey) {
                ZwClose(hUpgradeDeviceKey);
            }
        }
        EnumeratorKeyIndex++;
        ZwClose(hEnumeratorKey);
        if (hUpgradeEnumeratorKey) {
            ZwClose(hUpgradeEnumeratorKey);
        }
    }

    ZwClose(hEnumKey);
    if (hUpgradeEnumKey) {
        ZwClose(hUpgradeEnumKey);
    }
    SpMemFree(MyScratchBuffer);

    return;
}


BOOLEAN
SppEnsureHardwareProfileIsPresent(
    IN HANDLE   hKeyCCSet
    )

/*++

Routine Description:

    This routine checks for the presence of the presence of the following keys:

    HKLM\System\CurrentControlSet\Control\IDConfigDB\Hardware Profiles
    HKLM\System\CurrentControlSet\Hardware Profiles

    If these keys exist, it checks the profile information subkeys under
    IDConfigDB for a "Pristine Profile".

    If the Pristine Profile is not in the proper NT5 format, that is
    under the \0000 subkey, with a PreferenceOrder == -1 and Pristine == 1,
    then it is deleted, and we rely on a valid pristine profile with
    these settings to be migrated from the SETUPREG.HIV.  We then re-order
    the PreferenceOrder values for the remaining hardware profiles, and
    make sure sure each has a HwProfileGuid.

    If a valid Pristine profile is found, it is not removed, and will
    not be replaced during migration.

    If one of either the CCS\Control\IDConfigDB\Hardware Profiles key, or
    the CCS\Hardware Profiles keys is missing, then the set of hardware
    profiles is invalid, and both keys will be removed and migrated from
    the SETUPREG.HIV.


Arguments:

    hKeyCCSet - Handle to the root of the control set in the system
        being upgraded.

Return Value:

    If successful, the return value is TRUE, otherwise it is FALSE.

--*/
{
    OBJECT_ATTRIBUTES ObjaID, ObjaHw;
    UNICODE_STRING UnicodeString, TempString, UnicodeValueName;
    UNICODE_STRING UnicodeKeyName, GuidString, UnicodeLabel;
    NTSTATUS Status;
    HANDLE IDConfigProfiles=NULL, IDConfigEntry=NULL;
    HANDLE HwProfiles=NULL, HwProfileEntry=NULL;
    ULONG profileNumber;
    ULONG len;
    PWSTR  SubkeyName;
    ULONG  ValueBufferSize;
    BOOLEAN b = TRUE;
    BOOLEAN ReOrder = FALSE, bKeyNameIs0000 = FALSE;
    ULONG   pristinePreferenceOrder, preferenceOrder;
    ULONG   enumIndex, resultLength;
    ULONG   nameIndex, dockState;
    UUID    uuid;
    PKEY_BASIC_INFORMATION pKeyInfo;
    PKEY_VALUE_FULL_INFORMATION pValueInfo;


    //
    // Initialize Object Attributes for Hardware profile specific keys
    //
    INIT_OBJA(&ObjaID, &UnicodeString, L"Control\\IDConfigDB\\Hardware Profiles");
    ObjaID.RootDirectory = hKeyCCSet;

    INIT_OBJA(&ObjaHw, &TempString, L"Hardware Profiles");
    ObjaHw.RootDirectory = hKeyCCSet;

    //
    // Attempt to open "CCS\Control\IDConfigDB\Hardware Profiles"
    // and "CCS\Hardware Profiles" keys.
    // If either key is missing, this is an inconsistent state;
    // make sure neither key is present and rely on the migration of these
    // keys from SETUPREG.HIV to provide the basic state (pristine only).
    //
    if ((ZwOpenKey(&IDConfigProfiles,
                   KEY_READ | KEY_WRITE,
                   &ObjaID) != STATUS_SUCCESS) ||
        (ZwOpenKey(&HwProfiles,
                   KEY_READ | KEY_WRITE,
                   &ObjaHw) != STATUS_SUCCESS)) {

        SppDeleteKeyRecursive(hKeyCCSet, UnicodeString.Buffer, TRUE);
        SppDeleteKeyRecursive(hKeyCCSet, TempString.Buffer, TRUE);

        goto Clean;
    }

    //
    // Look for the pristine profile.
    //
    enumIndex = 0;
    while(TRUE) {

        //
        //Enumerate through each Profile Key
        //
        Status = ZwEnumerateKey(IDConfigProfiles,
                                enumIndex,
                                KeyBasicInformation,
                                TemporaryBuffer,
                                sizeof(TemporaryBuffer),
                                &resultLength);

        if(!NT_SUCCESS(Status)) {
            //
            // couldn't enumerate subkeys
            //
            if(Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }
            else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ** Unable to enumerate existing Hardware Profiles (%lx)\n", Status));
                b = FALSE;
            }
            break;
        }

        //
        // Zero-terminate the subkey name just in case.
        //
        pKeyInfo = (PKEY_BASIC_INFORMATION)TemporaryBuffer;
        pKeyInfo->Name[pKeyInfo->NameLength/sizeof(WCHAR)] = UNICODE_NULL;
        SubkeyName = SpDupStringW(pKeyInfo->Name);
        RtlInitUnicodeString(&UnicodeKeyName, SubkeyName);

        //
        // See if this Profile is occupying the space the Pristine Profile should
        // occupy.  We'll check to see if it is really the Pristine Profile later.
        //
        Status = RtlUnicodeStringToInteger( &UnicodeKeyName, 10, &profileNumber );
        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not get integer profile number for key %ws (%lx)\n",
                     UnicodeKeyName.Buffer,Status));
            bKeyNameIs0000 = FALSE;
        } else {
            bKeyNameIs0000 = (profileNumber==0);
        }

        //
        // Open the subkey
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Checking Profile Key %ws (%lx)\n",UnicodeKeyName.Buffer,Status));
        InitializeObjectAttributes (&ObjaID,
                                    &UnicodeKeyName,
                                    OBJ_CASE_INSENSITIVE,
                                    IDConfigProfiles,
                                    NULL);
        Status = ZwOpenKey(&IDConfigEntry,
                           KEY_ALL_ACCESS,
                           &ObjaID);
        if (!NT_SUCCESS(Status)) {
            //
            // Couldn't open this particular profile key, just log
            // it and check the others, shouldn't stop Setup here.
            //
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ** Unable to open enumerated Hardware Profile key %ws (%lx)\n",
                     UnicodeKeyName.Buffer, Status));
            SpMemFree(SubkeyName);
            enumIndex++;
            continue;
        }

        //
        // Look for the Pristine Entry
        //
        RtlInitUnicodeString(&UnicodeValueName, L"Pristine");
        Status = ZwQueryValueKey(IDConfigEntry,
                                 &UnicodeValueName,
                                 KeyValueFullInformation,
                                 TemporaryBuffer,
                                 sizeof(TemporaryBuffer),
                                 &resultLength);
        pValueInfo = (PKEY_VALUE_FULL_INFORMATION)TemporaryBuffer;

        if (NT_SUCCESS(Status) && (pValueInfo->Type == REG_DWORD) &&
            (* (PULONG) ((PUCHAR)pValueInfo + pValueInfo->DataOffset))) {
            //
            // Found the Pristine Entry, now find its PreferenceOrder
            //
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Found what appears to be a Pristine profile (%lx)\n",Status));
            RtlInitUnicodeString(&UnicodeValueName, REGSTR_VAL_PREFERENCEORDER);
            Status = ZwQueryValueKey(IDConfigEntry,
                                     &UnicodeValueName,
                                     KeyValueFullInformation,
                                     TemporaryBuffer,
                                     sizeof(TemporaryBuffer),
                                     &resultLength);

            if(NT_SUCCESS(Status) && (pValueInfo->Type == REG_DWORD)) {
                //
                // Found the PreferenceOrder of the Pristine;
                // save it so we can fill in the gap left after we delete it.
                //
                pristinePreferenceOrder = (* (PULONG) ((PUCHAR)pValueInfo + pValueInfo->DataOffset));

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: PreferenceOrder of this Pristine ==  %u\n",
                         pristinePreferenceOrder));

                //
                // At most one Pristine Profile should ever be found and reordered,
                // or else the reordering of profiles will not work properly.
                //
                ASSERT(!ReOrder);

                if (bKeyNameIs0000 && (pristinePreferenceOrder == -1)) {
                    //
                    // This is a valid 0000 Pristine Profile Key, don't touch it.
                    //
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Key %ws is a valid pristine profile\n",
                             UnicodeKeyName.Buffer));
                    enumIndex++;
                } else {
                    //
                    // This is an old-style Pristine Profile, delete it and the corresponding
                    // key under "CCS\Hardware Profiles", and rely on the Pristine Profile
                    // keys migrated from setupreg.hiv (as specified in txtsetup.sif)
                    //
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Key %ws is an invalid pristine profile, deleteing this key.\n",
                             UnicodeKeyName.Buffer));
                    ReOrder = TRUE;
                    ZwDeleteKey(IDConfigEntry);
                    SppDeleteKeyRecursive(HwProfiles,
                                          UnicodeKeyName.Buffer,
                                          TRUE);
                }

            } else {
                //
                // An invalid Pristine config has no PreferenceOrder,
                // Just delete it, and nobody should miss it.
                //
                ZwDeleteKey(IDConfigEntry);
                SppDeleteKeyRecursive(HwProfiles,
                                      UnicodeKeyName.Buffer,
                                      TRUE);
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Invalid PreferenceOrder value for key %ws, deleting this key. (%lx)\n",
                         UnicodeKeyName.Buffer,Status));
            }

        } else {
            //
            // Not a Pristine Profile
            //

            if (bKeyNameIs0000) {
                //
                // We need to wipe out any non-Pristine Profiles currently occupying key \0000
                // to make room for the new Pristine Profile that we'll migrate over later.
                // (sorry, but nobody has any business being here in the first place.)
                //
                ZwDeleteKey(IDConfigEntry);
                SppDeleteKeyRecursive(HwProfiles,
                                      UnicodeKeyName.Buffer,
                                      TRUE);
            } else {

                //
                // Check that it has a PreferenceOrder
                //
                RtlInitUnicodeString(&UnicodeValueName, REGSTR_VAL_PREFERENCEORDER);
                Status = ZwQueryValueKey(IDConfigEntry,
                                         &UnicodeValueName,
                                         KeyValueFullInformation,
                                         TemporaryBuffer,
                                         sizeof(TemporaryBuffer),
                                         &resultLength);

                if(!NT_SUCCESS(Status) || (pValueInfo->Type != REG_DWORD)) {
                    //
                    // Invalid or missing PreferenceOrder for this profile;
                    // Since this profile was most likely inaccessible anyways,
                    // just delete it and the corresponding entry under CCS\\Hardware Profiles.
                    //
                    ZwDeleteKey(IDConfigEntry);
                    SppDeleteKeyRecursive(HwProfiles,
                                          UnicodeKeyName.Buffer,
                                          TRUE);
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Invalid PreferenceOrder value for key %ws, deleting this key. (%lx)\n",
                             UnicodeKeyName.Buffer,Status));
                }  else {

                    //
                    // Make sure all profiles have a HwProfileGuid value.
                    //
                    RtlInitUnicodeString(&UnicodeValueName, L"HwProfileGuid");
                    Status = ZwQueryValueKey(IDConfigEntry,
                                             &UnicodeValueName,
                                             KeyValueFullInformation,
                                             TemporaryBuffer,
                                             sizeof(TemporaryBuffer),
                                             &resultLength);
                    pValueInfo = (PKEY_VALUE_FULL_INFORMATION)TemporaryBuffer;

                    if (!NT_SUCCESS(Status) || (pValueInfo->Type != REG_SZ)) {
                        //
                        // Profile doesn't have a HwProfileGuid; make one up.
                        //
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Missing or invalid HwProfileGuid for Profile %ws, creating one (%lx)\n",
                                 UnicodeKeyName.Buffer, Status));
                        Status = ExUuidCreate(&uuid);
                        if (NT_SUCCESS(Status)) {
                            Status = RtlStringFromGUID(&uuid, &GuidString);
                            ASSERT(NT_SUCCESS(Status));
                            if (NT_SUCCESS(Status)) {
                                Status = ZwSetValueKey(IDConfigEntry,
                                                       &UnicodeValueName,
                                                       0,
                                                       REG_SZ,
                                                       GuidString.Buffer,
                                                       GuidString.Length + sizeof(UNICODE_NULL));
                                RtlFreeUnicodeString(&GuidString);
                                if(!NT_SUCCESS(Status)) {
                                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ** Unable to set HwProfileGuid value for key %ws, Status = (%lx)\n",
                                             UnicodeKeyName.Buffer,Status));
                                }
                            } else {
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ** Unable to create string from GUID (Status = %lx)\n",
                                         Status));
                            }
                        } else {
                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ** Could not create a GUID for this profile (Status = %lx)\n",
                                     Status));
                        }
                    }

                    //
                    // only raise enumIndex when we don't delete a key.
                    //
                    enumIndex++;
                }
            }
        }
        SpMemFree(SubkeyName);
        ZwClose(IDConfigEntry);
        IDConfigEntry = NULL;
    }

    //
    // If we don't need to reorder any PreferenceOrder values, we're done.
    //
    if (!ReOrder) {
        goto Clean;
    }


    //
    // ReOrder PreferenceOrder values after deleting one
    // to make up for the gap.
    //

    enumIndex = 0;
    while(TRUE) {

        //
        //Enumerate through each Profile Key again
        //
        Status = ZwEnumerateKey(IDConfigProfiles,
                                enumIndex,
                                KeyBasicInformation,
                                TemporaryBuffer,
                                sizeof(TemporaryBuffer),
                                &resultLength);
        if(!NT_SUCCESS(Status)) {
            if(Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }
            else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ** Unable to reorder remaining Hardware Profiles (%lx)\n", Status));
                b = FALSE;
            }
            break;
        }

        //
        // Zero-terminate the subkey name just in case.
        //
        pKeyInfo = (PKEY_BASIC_INFORMATION)TemporaryBuffer;
        pKeyInfo->Name[pKeyInfo->NameLength/sizeof(WCHAR)] = UNICODE_NULL;
        SubkeyName = SpDupStringW(pKeyInfo->Name);
        RtlInitUnicodeString(&UnicodeKeyName, SubkeyName);

        InitializeObjectAttributes (&ObjaID,
                                    &UnicodeKeyName,
                                    OBJ_CASE_INSENSITIVE,
                                    IDConfigProfiles,
                                    NULL);
        Status = ZwOpenKey (&IDConfigEntry,
                            KEY_ALL_ACCESS,
                            &ObjaID);
        if (!NT_SUCCESS(Status)) {
            //
            // Couldn't open this particular profile key, just log
            // it and check the others, shouldn't stop Setup here.
            //
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ** Unable to open enumerated Hardware Profile key %ws (%lx)\n",
                     UnicodeKeyName.Buffer, Status));
            SpMemFree(SubkeyName);
            enumIndex++;
            continue;
        }

        pValueInfo = (PKEY_VALUE_FULL_INFORMATION)(TemporaryBuffer + (sizeof(TemporaryBuffer) / sizeof(WCHAR) / 2));
        ValueBufferSize = sizeof(TemporaryBuffer) / 2;

        //
        // Get the PreferenceOrder for this profile
        //
        RtlInitUnicodeString(&UnicodeValueName, REGSTR_VAL_PREFERENCEORDER);
        Status = ZwQueryValueKey(IDConfigEntry,
                                 &UnicodeValueName,
                                 KeyValueFullInformation,
                                 pValueInfo,
                                 ValueBufferSize,
                                 &len);

        if(NT_SUCCESS(Status) && (pValueInfo->Type == REG_DWORD)) {
            //
            // Got the Preference Order
            //
            ASSERT((* (PULONG) ((PUCHAR)pValueInfo + pValueInfo->DataOffset)) != pristinePreferenceOrder);
            if (((* (PULONG) ((PUCHAR)pValueInfo + pValueInfo->DataOffset))  > pristinePreferenceOrder) &&
                ((* (PULONG) ((PUCHAR)pValueInfo + pValueInfo->DataOffset)) != -1)) {
                //
                // Re-order PreferenceOrders for profiles other than a valid pristine,
                // beyond deleted pristine up one.
                //
                preferenceOrder = (* (PULONG) ((PUCHAR)pValueInfo + pValueInfo->DataOffset)) - 1;
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: ReOrdering Profile %ws to PreferenceOrder %u\n",
                         UnicodeKeyName.Buffer,preferenceOrder));
                Status = ZwSetValueKey(IDConfigEntry,
                                       &UnicodeValueName,
                                       0,
                                       REG_DWORD,
                                       &preferenceOrder,
                                       sizeof(preferenceOrder));
                if(!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to change PreferenceOrder for Profile %ws, Status = (%lx)\n",
                             UnicodeKeyName.Buffer,Status));
                    b = FALSE;
                }
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: *** Couldn't determine PreferenceOrder of profile %ws (%lx)\n",
                     UnicodeKeyName.Buffer,Status));
        }

        enumIndex++;
        SpMemFree(SubkeyName);
        ZwClose(IDConfigEntry);
        IDConfigEntry = NULL;
    }

Clean:

    if (NULL != IDConfigProfiles) {
        ZwClose (IDConfigProfiles);
    }
    if (NULL != IDConfigEntry) {
        ZwClose (IDConfigEntry);
    }
    if (NULL != HwProfiles) {
        ZwClose (HwProfiles);
    }
    if (NULL != HwProfileEntry) {
        ZwClose (HwProfileEntry);
    }
    return b;
}

VOID
SppSetGuimodeUpgradePath(
    IN HANDLE hKeySoftwareHive,
    IN HANDLE hKeyControlSet
    )
{


    PWSTR Default_Path[3] = { L"%SystemRoot%\\system32",
                             L"%SystemRoot%",
                             L"%SystemRoot%\\system32\\WBEM"};
    UNICODE_STRING StringRegPath;
    UNICODE_STRING StringRegOldPath, UnicodeString;
    PKEY_VALUE_PARTIAL_INFORMATION pValueInfo;
    ULONG len;
    PWSTR CurrentPath = NULL;
    PWSTR p,q,final;
    OBJECT_ATTRIBUTES Obja;
    HKEY hKeyEnv;
    DWORD err;
    BOOL Found;
    int i;

    INIT_OBJA( &Obja, &UnicodeString, L"Control\\Session Manager\\Environment" );
    Obja.RootDirectory = hKeyControlSet;

    err = ZwOpenKey( &hKeyEnv, KEY_ALL_ACCESS, &Obja );
    if( NT_SUCCESS( err )){
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP:SppSetGuimodeUpgradePath - Opened the Environment key\n" ));

        RtlInitUnicodeString(&StringRegPath, L"Path");
        err = ZwQueryValueKey(
                  hKeyEnv,
                  &StringRegPath,
                  KeyValuePartialInformation,
                  TemporaryBuffer,
                  sizeof(TemporaryBuffer),
                  &len);

        if( NT_SUCCESS(err)) {
            pValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer;
            if( pValueInfo->Type == REG_EXPAND_SZ || pValueInfo->Type == REG_SZ) {

                CurrentPath = SpDupStringW( (PWSTR)pValueInfo->Data );


                // Now we try to extract from the existing path all elements that are not part of the default
                // path that we maintain during GUI Setup. We then append that to the default path. That way
                // we don't end up duplicating path elements over successive upgrades. We store this in the
                // 'OldPath' value and restore it at the end of GUI mode.
                //

                TemporaryBuffer[0]=L'\0';
                for(i=0; i<ELEMENT_COUNT(Default_Path); i++){
                    wcscat( TemporaryBuffer, Default_Path[i] );
                    wcscat( TemporaryBuffer, L";");
                }
                TemporaryBuffer[wcslen(TemporaryBuffer)-1]=L'\0';

                //Set the default path in the registry

                err = ZwSetValueKey(
                          hKeyEnv,
                          &StringRegPath,
                          0,
                          REG_EXPAND_SZ,
                          TemporaryBuffer,
                          ((wcslen(TemporaryBuffer)+1)*sizeof(WCHAR)));


                if( !NT_SUCCESS( err ) )
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "\nSETUP: Error %x in saving path. Ignoring and not resetting PATH for GUI Setup\n", err));


                for( p=q=CurrentPath; p && *p; ){

                    //Jump to the ';' delimiter

                    if( q = wcsstr(p, L";") )
                        *q=0;


                    //  Compare with elements of our default path

                    Found=FALSE;
                    for(i=0; i<ELEMENT_COUNT(Default_Path); i++){
                        if (!_wcsicmp(p,Default_Path[i])) {
                            Found=TRUE;
                            break;

                        }
                    }
                    if(!Found){
                        wcscat( TemporaryBuffer, L";");
                        wcscat( TemporaryBuffer, p);
                    }

                    if(q)
                        p=q+1;
                    else
                        break;
                }


                RtlInitUnicodeString(&StringRegOldPath, L"OldPath");


                //
                // Set the Oldpath always, if it exists or not
                //
                err = ZwSetValueKey(
                          hKeyEnv,
                          &StringRegOldPath,
                          0,
                          REG_EXPAND_SZ,
                          TemporaryBuffer,
                          ((wcslen(TemporaryBuffer)+1)*sizeof(WCHAR)));

                if( !NT_SUCCESS( err ) )
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "\nSETUP: Error %x in saving old PATH. \n", err));


            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "\nSETUP:PATH type in registry not REG_EXPAND_SZ nor REG_SZ. Resetting PATH to default\n"));

                TemporaryBuffer[0]=L'\0';
                for(i=0; i<ELEMENT_COUNT(Default_Path); i++){
                    wcscat( TemporaryBuffer, Default_Path[i] );
                    wcscat( TemporaryBuffer, L";");
                }
                TemporaryBuffer[wcslen(TemporaryBuffer)-1]=L'\0';

                //Set the default path in the registry

                err = ZwSetValueKey(
                          hKeyEnv,
                          &StringRegPath,
                          0,
                          REG_EXPAND_SZ,
                          TemporaryBuffer,
                          ((wcslen(TemporaryBuffer)+1)*sizeof(WCHAR)));

                if( !NT_SUCCESS( err ) )
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "\nSETUP: Error %x in saving path. Ignoring and not resetting PATH for GUI Setup\n", err));
            }

        }else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "\nSETUP:Query for PATH value failed with error %x. Ignoring and not resetting PATH for GUI Setup\n",err));
        }
        ZwClose( hKeyEnv );

    }else
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "\nSETUP:Error %x while opening Environment key. Ignoring and not resetting PATH for GUI Setup\n",err));

    if( CurrentPath )
        SpMemFree( CurrentPath );

    return;
}


NTSTATUS
SppMigratePrinterKeys(
    IN HANDLE hControlSet,
    IN HANDLE hDestSoftwareHive
    )

/*++

Routine Description:

    This routine migrates HKLM\SYSTEM\CurrentControlSet\Control\Print\Printers to
    HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers.

Arguments:

    hControlSet - Handle to CurrentControlSet key in the system hive of the system being upgraded

    hDestSoftwareHive - Handle to the root of the software hive on the system
                        being upgraded.


Return Value:

    Status value indicating outcome of operation.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;


    PWSTR   SrcPrinterKeyPath = L"Control\\Print\\Printers";
    PWSTR   DstPrinterKeyName = L"Printers";
    PWSTR   DstPrinterKeyPath = SpDupStringW(L"Microsoft\\Windows NT\\CurrentVersion\\Print\\Printers");
    HANDLE  SrcKey;
    HANDLE  DstKey;

    //
    //  Find out if the destination key exists
    //
    INIT_OBJA(&Obja,&UnicodeString,DstPrinterKeyPath);
    Obja.RootDirectory = hDestSoftwareHive;
    Status = ZwOpenKey(&DstKey,KEY_ALL_ACCESS,&Obja);
    if( NT_SUCCESS( Status ) ) {
        //
        //  If the key exists, then there is no need to do any migration.
        //  The migration has occurred on previous upgrades.
        //
        ZwClose( DstKey );
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: HKLM\\SYSTEM\\CurrentControlSet\\%ls doesn't need to be migrated. \n", DstPrinterKeyPath));
        SpMemFree( DstPrinterKeyPath );
        return( Status );
    } else if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
        //
        //  The key doesn't exist, so we need to do migration.
        //  First create the parent key.
        //

        PWSTR   p;

        p = wcsrchr ( DstPrinterKeyPath, L'\\' );

        if (p) {
            *p = L'\0';
        }

        INIT_OBJA(&Obja,&UnicodeString,DstPrinterKeyPath);
        Obja.RootDirectory = hDestSoftwareHive;
        Status = ZwCreateKey(&DstKey,
                             KEY_ALL_ACCESS,
                             &Obja,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             NULL );

        if( !NT_SUCCESS( Status ) ) {
            //
            //  If unable to create the parent key, then don't do migration
            //
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to create HKLM\\SOFTWARE\\%ls. Status =  %lx \n", DstPrinterKeyPath, Status));
            SpMemFree( DstPrinterKeyPath );
            return( Status );
        }
    } else {
        //
        //  We can't really determine whether or not the migration has occurred in the past, because the key is
        //  unaccessible. So son't attempt to do migration.
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open HKLM\\SOFTWARE\\%ls. Status = %lx \n", DstPrinterKeyPath, Status));
        SpMemFree( DstPrinterKeyPath );
        return( Status );
    }

    //
    //  At this point we now that the migration needs to be done.
    //  First, open the source key. Note that DstPrinterKeyPath is no longer needed.
    //
    SpMemFree( DstPrinterKeyPath );
    INIT_OBJA(&Obja,&UnicodeString,SrcPrinterKeyPath);
    Obja.RootDirectory = hControlSet;

    Status = ZwOpenKey(&SrcKey,KEY_ALL_ACCESS,&Obja);
    if( !NT_SUCCESS( Status ) ) {
        //
        //  If unable to open the source key, then fail.
        //
        ZwClose( DstKey );
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open HKLM\\SYSTEM\\CurrentControlSet\\%ls. Status = %lx \n", SrcPrinterKeyPath, Status));
        return( Status );
    }
    Status = SppCopyKeyRecursive( SrcKey,
                                  DstKey,
                                  NULL,
                                  DstPrinterKeyName,
                                  FALSE,
                                  TRUE
                                );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to migrate %ls. Status = %lx\n", SrcPrinterKeyPath, Status));
    }
    ZwClose( SrcKey );
    ZwClose( DstKey );
    //
    //  If the key was migrated successfully, then attempt to delete the source key.
    //  if we are unable to delete the key, then silently fail.
    //
    if( NT_SUCCESS( Status ) ) {
        NTSTATUS    Status1;
        PWSTR       q, r;

        //
        //  q will point to "Control\Print"
        //  r will point to "Printers"
        //
        q = SpDupStringW( SrcPrinterKeyPath );
        r = wcsrchr ( q, L'\\' );
        *r = L'\0';
        r++;

        INIT_OBJA(&Obja,&UnicodeString,q);
        Obja.RootDirectory = hControlSet;

        Status1 = ZwOpenKey(&SrcKey,KEY_ALL_ACCESS,&Obja);
        if( NT_SUCCESS( Status1 ) ) {
            Status1 = SppDeleteKeyRecursive(SrcKey,
                                            r,
                                            TRUE);

            if( !NT_SUCCESS( Status1 ) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to delete %ls\\%ls. Status = %lx\n", q, r, Status1));
            }
            ZwClose( SrcKey );
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to delete %ls. ZwOpenKey() failed. Status = %lx\n", SrcPrinterKeyPath, Status1));
        }
        SpMemFree(q);
    }
    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spupgcfg.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Spupgcfg.h

Abstract:

    Configuration routines for the upgrade case

Author:

    Sunil Pai (sunilp) 18-Nov-1993

Revision History:

--*/

#pragma once

//
// data types
//
typedef struct {
    PWSTR SectionName;
    DWORD SectionFlags;
    DWORD VerLow;
    DWORD VerHigh;
} RootDevnodeSectionNamesType;

#define RootDevnodeSectionNamesType_NTUPG  (0x0001)
#define RootDevnodeSectionNamesType_W9xUPG (0x0002)
#define RootDevnodeSectionNamesType_CLEAN  (0x0004)
#define RootDevnodeSectionNamesType_ALL    (0x0007)


//
// Public routines
//
NTSTATUS
SpUpgradeNTRegistry(
    IN PVOID    SifHandle,
    IN HANDLE  *HiveRootKeys,
    IN LPCWSTR  SetupSourceDevicePath,
    IN LPCWSTR  DirectoryOnSourceDevice,
    IN HANDLE   hKeyCCSet
    );

BOOLEAN
SpHivesFromInfs(
    IN PVOID   SifHandle,
    IN LPCWSTR SectionName,
    IN LPCWSTR SourcePath1,
    IN LPCWSTR SourcePath2,     OPTIONAL
    IN HANDLE  SystemHiveRoot,
    IN HANDLE  SoftwareHiveRoot,
    IN HANDLE  DefaultUserHiveRoot,
    IN HANDLE  HKR
    );

VOID
SpDeleteRootDevnodeKeys(
    IN PVOID  SifHandle,
    IN HANDLE hKeyCCSet,
    IN PWSTR DevicesToDelete,
    IN RootDevnodeSectionNamesType *DeviceClassesToDelete
    );

//
// Private routines
//
NTSTATUS
SppDeleteKeyRecursive(
    HANDLE  hKeyRoot,
    PWSTR   Key,
    BOOLEAN ThisKeyToo
    );

NTSTATUS
SppCopyKeyRecursive(
    HANDLE  hKeyRootSrc,
    HANDLE  hKeyRootDst,
    PWSTR   SrcKeyPath,
    PWSTR   DstKeyPath,
    BOOLEAN CopyAlways,
    BOOLEAN ApplyACLsAlways
    );


//
// Callback routine for SpApplyFunctionToDeviceInstanceKeys
//
typedef VOID (*PSPP_INSTANCEKEY_CALLBACK_ROUTINE) (
    IN     HANDLE  SetupInstanceKeyHandle,
    IN     HANDLE  UpgradeInstanceKeyHandle,
    IN     BOOLEAN RootEnumerated,
    IN OUT PVOID   Context
    );

VOID
SpApplyFunctionToDeviceInstanceKeys(
    IN HANDLE hKeyCCSet,
    IN PSPP_INSTANCEKEY_CALLBACK_ROUTINE InstanceKeyCallbackRoutine,
    IN OUT PVOID Context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spudp.c ===
/*++

Copyright (c) 1998  Micros  oft Corporation

Module Name:

    spudp.c

Abstract:

    Routines for handling sending and receiving datagram packets to a BINL server.

Author:

    Sean Selitrennikoff (v-seasel) 22-Jun-1998

Revision History:

Notes:

--*/

#include "spprecmp.h"
#pragma hdrstop
#include "spcmdcon.h"
#include <tdi.h>
#include <tdikrnl.h>
#include <remboot.h>
#include <oscpkt.h>

//
// Useful definitions
//
#define NULL_IP_ADDR    0
#define htons( a ) ((((a) & 0xFF00) >> 8) |\
                    (((a) & 0x00FF) << 8))

//
// Type definitions
//
typedef struct _SPUDP_FSCONTEXT {
        LIST_ENTRY     Linkage;
        PFILE_OBJECT   FileObject;
        LONG           ReferenceCount;
        UCHAR          CancelIrps;
        UCHAR          Pad[3];
} SPUDP_FSCONTEXT, *PSPUDP_FSCONTEXT;

typedef enum {
    SpUdpNetworkDisconnected,
    SpUdpNetworkDisconnecting,
    SpUdpNetworkConnecting,
    SpUdpNetworkConnected
} SPUDP_NETWORK_STATE;

typedef struct _SPUDP_RECEIVE_ENTRY {
    LIST_ENTRY ListEntry;
    ULONG DataBufferLength;
    PVOID DataBuffer;
} SPUDP_RECEIVE_ENTRY, *PSPUDP_RECEIVE_ENTRY;


//
// Globals
//
SPUDP_NETWORK_STATE SpUdpNetworkState = SpUdpNetworkDisconnected;
ULONG SpUdpActiveRefCount = 0;
HANDLE SpUdpDatagramHandle;
PFILE_OBJECT SpUdpDatagramFileObject;
PDEVICE_OBJECT SpUdpDatagramDeviceObject;
KSPIN_LOCK SpUdpLock;
KIRQL SpUdpOldIrql;
LIST_ENTRY SpUdpReceiveList;
ULONG SpUdpNumReceivePackets = 0;
ULONG SpUdpSendSequenceNumber = 1;

//
// Function definitions
//

NTSTATUS
SpUdpTdiErrorHandler(
    IN PVOID     TdiEventContext,
    IN NTSTATUS  Status
    );

NTSTATUS
SpUdpTdiSetEventHandler(
    IN PFILE_OBJECT    FileObject,
    IN PDEVICE_OBJECT  DeviceObject,
    IN ULONG           EventType,
    IN PVOID           EventHandler,
    IN PVOID           EventContext
    );


NTSTATUS
SpUdpIssueDeviceControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN ULONG            IoctlCode,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    OUT PVOID           OutputBuffer,
    IN ULONG            OutputBufferLength
    );


NTSTATUS
SpUdpTdiReceiveDatagramHandler(
    IN  PVOID    TdiEventContext,
    IN  LONG     SourceAddressLength,
    IN  PVOID    SourceAddress,
    IN  LONG     OptionsLength,
    IN  PVOID    Options,
    IN  ULONG    ReceiveDatagramFlags,
    IN  ULONG    BytesIndicated,
    IN  ULONG    BytesAvailable,
    OUT PULONG   BytesTaken,
    IN  PVOID    Tsdu,
    OUT PIRP *   Irp
    );

NTSTATUS
SpUdpReceivePacketHandler(
    IN  ULONG          TdiReceiveDatagramFlags,
    IN  ULONG          BytesIndicated,
    IN  ULONG          BytesAvailable,
    OUT PULONG         BytesTaken,
    IN  PVOID          Tsdu,
    OUT PIRP *         Irp
    );

NTSTATUS
SpUdpCompleteReceivePacket(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    );

VOID
SpUdpProcessReceivePacket(
    IN  ULONG          TsduSize,
    IN  PVOID          Tsdu
    );

NTSTATUS
SpUdpSendDatagram(
    IN PVOID                 SendBuffer,
    IN ULONG                 SendBufferLength,
    IN ULONG                 RemoteHostAddress,
    IN USHORT                RemoteHostPort
    );

NTSTATUS
SpUdpCompleteSendDatagram(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );





VOID
SpUdpDereferenceFsContext(
    PSPUDP_FSCONTEXT   FsContext
    )
{
    LONG  newValue = InterlockedDecrement(&(FsContext->ReferenceCount));


    ASSERT(newValue >= 0);

    if (newValue != 0) {
        return;
    }

    return;
}  // SpUdpDereferenceFsContext


NTSTATUS
SpUdpMarkRequestPending(
    PIRP                Irp,
    PIO_STACK_LOCATION  IrpSp,
    PDRIVER_CANCEL      CancelRoutine
    )
/*++

Notes:

    Called with IoCancelSpinLock held.

--*/
{
    PSPUDP_FSCONTEXT   fsContext = (PSPUDP_FSCONTEXT) IrpSp->FileObject->FsContext;
    KIRQL              oldIrql;

    //
    // Set up for cancellation
    //
    ASSERT(Irp->CancelRoutine == NULL);

    if (!Irp->Cancel) {

        IoMarkIrpPending(Irp);
        IoSetCancelRoutine(Irp, CancelRoutine);

        InterlockedIncrement(&(fsContext->ReferenceCount));

        return(STATUS_SUCCESS);
    }

    //
    // The IRP has already been cancelled.
    //
    return(STATUS_CANCELLED);

}  // SpUdpMarkRequestPending



VOID
SpUdpCompletePendingRequest(
    IN PIRP      Irp,
    IN NTSTATUS  Status,
    IN ULONG     BytesReturned
    )
/*++

Routine Description:

    Completes a pending request.

Arguments:

    Irp           - A pointer to the IRP for this request.
    Status        - The final status of the request.
    BytesReturned - Bytes sent/received information.

Return Value:

    None.

Notes:

    Called with IoCancelSpinLock held. Lock Irql is stored in Irp->CancelIrql.
    Releases IoCancelSpinLock before returning.

--*/

{
    PIO_STACK_LOCATION  irpSp;
    PSPUDP_FSCONTEXT       fsContext;


    irpSp = IoGetCurrentIrpStackLocation(Irp);
    fsContext = (PSPUDP_FSCONTEXT) irpSp->FileObject->FsContext;

    IoSetCancelRoutine(Irp, NULL);

    SpUdpDereferenceFsContext(fsContext);

    if (Irp->Cancel || fsContext->CancelIrps) {
        Status = (unsigned int) STATUS_CANCELLED;
        BytesReturned = 0;
    }

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    Irp->IoStatus.Status = (NTSTATUS) Status;
    Irp->IoStatus.Information = BytesReturned;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    return;

}  // SpUdpCompletePendingRequest



PFILE_OBJECT
SpUdpBeginCancelRoutine(
    IN  PIRP     Irp
    )

/*++

Routine Description:

    Performs common bookkeeping for irp cancellation.

Arguments:

    Irp          - Pointer to I/O request packet

Return Value:

    A pointer to the file object on which the irp was submitted.
    This value must be passed to SpUdpEndCancelRequest().

Notes:

    Called with cancel spinlock held.

--*/

{
    PIO_STACK_LOCATION  irpSp;
    PSPUDP_FSCONTEXT    fsContext;
    NTSTATUS            status = STATUS_SUCCESS;
    PFILE_OBJECT        fileObject;


    ASSERT(Irp->Cancel);

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    fileObject = irpSp->FileObject;
    fsContext = (PSPUDP_FSCONTEXT) fileObject->FsContext;

    IoSetCancelRoutine(Irp, NULL);

    //
    // Add a reference so the object can't be closed while the cancel routine
    // is executing.
    //
    InterlockedIncrement(&(fsContext->ReferenceCount));

    return(fileObject);

}  // SpUdpBeginCancelRoutine



VOID
SpUdpEndCancelRoutine(
    PFILE_OBJECT    FileObject
    )
/*++

Routine Description:

    Performs common bookkeeping for irp cancellation.

Arguments:


Return Value:


Notes:

    Called with cancel spinlock held.

--*/
{

    PSPUDP_FSCONTEXT   fsContext = (PSPUDP_FSCONTEXT) FileObject->FsContext;

    //
    // Remove the reference placed on the endpoint by the cancel routine.
    //
    SpUdpDereferenceFsContext(fsContext);
    return;

} // SpUdpEndCancelRoutine





NTSTATUS
SpUdpConnect(
    VOID
)
{

    NTSTATUS                               status;
    OBJECT_ATTRIBUTES                      objectAttributes;
    IO_STATUS_BLOCK                        iosb;
    PFILE_FULL_EA_INFORMATION              ea = NULL;
    ULONG                                  eaBufferLength;
    HANDLE                                 addressHandle = NULL;
    PFILE_OBJECT                           addressFileObject = NULL;
    PDEVICE_OBJECT                         addressDeviceObject = NULL;
    BOOLEAN                                attached = FALSE;
    UNICODE_STRING                         unicodeString;
    TDI_REQUEST_KERNEL_QUERY_INFORMATION   queryInfo;
    PTDI_ADDRESS_INFO                      addressInfo;
    TDI_PROVIDER_INFO                      providerInfo;
    PWCHAR                                 TdiProviderName;
    ULONG                                  TdiProviderNameLength;
    PTRANSPORT_ADDRESS                     TransportAddress;
    PTDI_ADDRESS_IP                        TdiAddressIp;

    TdiProviderName = L"\\Device\\Udp";
    TdiProviderNameLength = (wcslen(TdiProviderName) + 1) * sizeof(WCHAR);

    InitializeListHead(&SpUdpReceiveList);

    //
    // Allocate memory to hold the EA buffer we'll use to specify the
    // transport address to NtCreateFile.
    //
    eaBufferLength = FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                     TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                     sizeof(TA_IP_ADDRESS);

    ea = SpMemAlloc(eaBufferLength);

    if (ea == NULL) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: memory allocation of %u bytes failed.\n", eaBufferLength));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Initialize the EA using the network's transport information.
    //
    ea->NextEntryOffset = 0;
    ea->Flags = 0;
    ea->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    ea->EaValueLength = (USHORT)sizeof(TA_IP_ADDRESS);

    RtlMoveMemory(
        ea->EaName,
        TdiTransportAddress,
        ea->EaNameLength + 1
        );

    TransportAddress = (PTRANSPORT_ADDRESS)(&(ea->EaName[ea->EaNameLength + 1]));
    TransportAddress->TAAddressCount = 1;
    TransportAddress->Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
    TransportAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    TdiAddressIp = (PTDI_ADDRESS_IP)(&(TransportAddress->Address[0].Address[0]));
    TdiAddressIp->sin_port= 0; // Means that you want a port assigned
    TdiAddressIp->in_addr= NULL_IP_ADDR;
    RtlZeroMemory(TdiAddressIp->sin_zero, sizeof(TdiAddressIp->sin_zero));

    RtlInitUnicodeString(&unicodeString, TdiProviderName);

    KeAcquireSpinLock(&SpUdpLock, &SpUdpOldIrql);

    if (SpUdpNetworkState != SpUdpNetworkDisconnected) {
        KeReleaseSpinLock(&SpUdpLock, SpUdpOldIrql);
        SpMemFree(ea);
        return((SpUdpNetworkState == SpUdpNetworkConnected) ? STATUS_SUCCESS : STATUS_PENDING);
    }

    ASSERT(SpUdpDatagramHandle == NULL);
    ASSERT(SpUdpDatagramFileObject == NULL);
    ASSERT(SpUdpDatagramDeviceObject == NULL);
    ASSERT(SpUdpActiveRefCount == 0);

    //
    // Set the initial active refcount to 2. One reference will be removed
    // when the network is successfully brought online. The other will be
    // removed when the network is to be taken offline. Also increment the
    // base refcount to account for the active refcount. Change to
    // the online pending state.
    //
    SpUdpActiveRefCount = 2;
    SpUdpNetworkState = SpUdpNetworkConnecting;

    KeReleaseSpinLock(&SpUdpLock, SpUdpOldIrql);

    //
    // Prepare for opening the address object.
    //
    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,         // attributes
        NULL,
        NULL
        );

    //
    // Perform the actual open of the address object.
    //
    status = ZwCreateFile(
                 &addressHandle,
                 GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                 &objectAttributes,
                 &iosb,                          // returned status information.
                 0,                              // block size (unused).
                 0,                              // file attributes.
                 0,                              // not shareable
                 FILE_CREATE,                    // create disposition.
                 0,                              // create options.
                 ea,
                 eaBufferLength
                 );

    SpMemFree(ea);
    ea = NULL;

    if (status != STATUS_SUCCESS) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to open address for UDP, status %lx.\n", status));
        goto error_exit;
    }

    //
    // Get a pointer to the file object of the address.
    //
    status = ObReferenceObjectByHandle(
                 addressHandle,
                 0L,                         // DesiredAccess
                 NULL,
                 KernelMode,
                 &addressFileObject,
                 NULL
                 );

    if (status != STATUS_SUCCESS) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to reference address handle, status %lx.\n", status));
        goto error_exit;
    }

    //
    // Remember the device object to which we need to give requests for
    // this address object.  We can't just use the fileObject->DeviceObject
    // pointer because there may be a device attached to the transport
    // protocol.
    //
    addressDeviceObject = IoGetRelatedDeviceObject(addressFileObject);

    //
    // Get the transport provider info
    //
    queryInfo.QueryType = TDI_QUERY_PROVIDER_INFO;
    queryInfo.RequestConnectionInformation = NULL;

    status = SpUdpIssueDeviceControl(
                 addressDeviceObject,
                 TDI_QUERY_INFORMATION,
                 &queryInfo,
                 sizeof(queryInfo),
                 &providerInfo,
                 sizeof(providerInfo)
                 );

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to get provider info, status %lx\n", status));
        goto error_exit;
    }

    if (!(providerInfo.ServiceFlags & TDI_SERVICE_CONNECTIONLESS_MODE)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Provider doesn't support datagrams!\n"));
        status = STATUS_UNSUCCESSFUL;
        goto error_exit;
    }

    //
    // Set up indication handlers on the address object. We are eligible
    // to receive indications as soon as we do this.
    //
    status = SpUdpTdiSetEventHandler(
                 addressFileObject,
                 addressDeviceObject,
                 TDI_EVENT_ERROR,
                 SpUdpTdiErrorHandler,
                 NULL
                 );

    if ( !NT_SUCCESS(status) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Setting TDI_EVENT_ERROR failed: %lx\n", status));
        goto error_exit;
    }

    status = SpUdpTdiSetEventHandler(
                 addressFileObject,
                 addressDeviceObject,
                 TDI_EVENT_RECEIVE_DATAGRAM,
                 SpUdpTdiReceiveDatagramHandler,
                 NULL
                 );

    if ( !NT_SUCCESS(status) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Setting TDI_EVENT_RECEIVE_DATAGRAM failed: %lx\n", status));
        goto error_exit;
    }

    //
    // Finish transition to online state. Note that an offline request
    // could have been issued in the meantime.
    //
    KeAcquireSpinLock(&SpUdpLock, &SpUdpOldIrql);

    SpUdpDatagramHandle = addressHandle;
    addressHandle = NULL;
    SpUdpDatagramFileObject = addressFileObject;
    addressFileObject = NULL;
    SpUdpDatagramDeviceObject = addressDeviceObject;
    addressDeviceObject = NULL;

    ASSERT(SpUdpActiveRefCount == 2);
    SpUdpActiveRefCount--;
    SpUdpNetworkState = SpUdpNetworkConnected;

    KeReleaseSpinLock(&SpUdpLock, SpUdpOldIrql);

    return(STATUS_SUCCESS);


error_exit:

    if (addressFileObject != NULL) {
        ObDereferenceObject(addressFileObject);
    }

    if (addressHandle != NULL) {
        ZwClose(addressHandle);
    }

    SpUdpDisconnect();

    return(status);

}  // SpUdpConnect


NTSTATUS
SpUdpDisconnect(
    VOID
    )
{
    PLIST_ENTRY ListEntry;
    PSPUDP_RECEIVE_ENTRY ReceiveEntry;

    KeAcquireSpinLock(&SpUdpLock, &SpUdpOldIrql);

    if (SpUdpNetworkState == SpUdpNetworkDisconnected) {
        KeReleaseSpinLock(&SpUdpLock, SpUdpOldIrql);
        return(STATUS_SUCCESS);
    }

    SpUdpNetworkState = SpUdpNetworkDisconnecting;

    if (SpUdpActiveRefCount != 1) {
        KeReleaseSpinLock(&SpUdpLock, SpUdpOldIrql);
        return(STATUS_PENDING);
    }

    KeReleaseSpinLock(&SpUdpLock, SpUdpOldIrql);

    if (SpUdpDatagramFileObject != NULL) {
        ObDereferenceObject(SpUdpDatagramFileObject);
    }

    if (SpUdpDatagramHandle != NULL) {
        ZwClose(SpUdpDatagramHandle);
    }

    KeAcquireSpinLock(&SpUdpLock, &SpUdpOldIrql);

    SpUdpDatagramFileObject = NULL;
    SpUdpDatagramHandle = NULL;
    SpUdpDatagramDeviceObject = NULL;
    SpUdpActiveRefCount = 0;
    SpUdpNetworkState = SpUdpNetworkDisconnected;

    while (!IsListEmpty(&SpUdpReceiveList)) {
        ListEntry = RemoveHeadList(&SpUdpReceiveList);
        ReceiveEntry = CONTAINING_RECORD(ListEntry,
                                         SPUDP_RECEIVE_ENTRY,
                                         ListEntry
                                        );

        SpMemFree(ReceiveEntry->DataBuffer);
        SpMemFree(ReceiveEntry);
    }

    SpUdpNumReceivePackets = 0;

    KeReleaseSpinLock(&SpUdpLock, SpUdpOldIrql);

    return(STATUS_SUCCESS);

}  // SpUdpDisconnect


NTSTATUS
SpUdpIssueDeviceControl(
    IN PDEVICE_OBJECT Device,
    IN ULONG IoctlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    )
/*++

Description:

    Builds and send an IOCTL to a device and return the results

Arguments:

    Device - a device on the device stack to receive the IOCTL - the
             irp is always sent to the top of the stack

    IoctlCode - the IOCTL to run

    InputBuffer - arguments to the IOCTL

    InputBufferLength - length in bytes of the InputBuffer

    OutputBuffer - data returned by the IOCTL

    OnputBufferLength - the size in bytes of the OutputBuffer

Return Value:

    Status

--*/
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatus;
    KEVENT event;
    PIRP irp;

    PAGED_CODE();

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    //
    // Get Io to build the IRP for us
    //

    irp = IoBuildDeviceIoControlRequest(IoctlCode,
                                        Device,
                                        InputBuffer,
                                        InputBufferLength,
                                        OutputBuffer,
                                        OutputBufferLength,
                                        FALSE, // InternalDeviceIoControl
                                        &event,
                                        &ioStatus
                                        );


    if (!irp) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    //
    // Send the IRP and wait for it to complete
    //

    status = IoCallDriver(Device, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

exit:

    return status;

}


NTSTATUS
SpUdpTdiSetEventHandler(
    IN PFILE_OBJECT    FileObject,
    IN PDEVICE_OBJECT  DeviceObject,
    IN ULONG           EventType,
    IN PVOID           EventHandler,
    IN PVOID           EventContext
    )
/*++

Routine Description:

    Sets up a TDI indication handler on the address object.  This is done synchronously, which
    shouldn't usually be an issue since TDI providers can usually complete
    indication handler setups immediately.

Arguments:

    FileObject - a pointer to the file object for an open connection or
        address object.

    DeviceObject - a pointer to the device object associated with the
        file object.

    EventType - the event for which the indication handler should be
        called.

    EventHandler - the routine to call when tghe specified event occurs.

    EventContext - context which is passed to the indication routine.

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    TDI_REQUEST_KERNEL_SET_EVENT  parameters;
    NTSTATUS                      status;

    parameters.EventType = EventType;
    parameters.EventHandler = EventHandler;
    parameters.EventContext = EventContext;


    status = SpUdpIssueDeviceControl(
                 DeviceObject,
                 TDI_SET_EVENT_HANDLER,
                 &parameters,
                 sizeof(parameters),
                 NULL,
                 0
                 );
    
    return(status);

}  // SpUdpTdiSetEventHandler



NTSTATUS
SpUdpTdiErrorHandler(
    IN PVOID     TdiEventContext,
    IN NTSTATUS  Status
    )
{

    return(STATUS_SUCCESS);

}  // SpUdpTdiErrorHandler



NTSTATUS
SpUdpTdiReceiveDatagramHandler(
    IN  PVOID    TdiEventContext,
    IN  LONG     SourceAddressLength,
    IN  PVOID    SourceAddress,
    IN  LONG     OptionsLength,
    IN  PVOID    Options,
    IN  ULONG    ReceiveDatagramFlags,
    IN  ULONG    BytesIndicated,
    IN  ULONG    BytesAvailable,
    OUT PULONG   BytesTaken,
    IN  PVOID    Tsdu,
    OUT PIRP *   Irp
    )
{
    NTSTATUS                        status;
    SPUDP_PACKET UNALIGNED *        pHeader = Tsdu;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    if (SpUdpNetworkState != SpUdpNetworkConnected) {
        return(STATUS_SUCCESS);
    }

    //
    // Validate the CNP header.
    //
    if (BytesIndicated > sizeof(SPUDP_PACKET)) {

        //
        // Deliver the packet to the appropriate upper layer protocol.
        //
        status = SpUdpReceivePacketHandler(
                     ReceiveDatagramFlags,
                     BytesIndicated,
                     BytesAvailable,
                     BytesTaken,
                     Tsdu,
                     Irp
                     );

        return(status);
    }

    //
    // Something went wrong. Drop the packet by
    // indicating that we consumed it.
    //

    *BytesTaken = BytesAvailable;
    *Irp = NULL;

    return(STATUS_SUCCESS);

}  // SpUdpTdiReceiveDatagramHandler


NTSTATUS
SpUdpReceivePacketHandler(
    IN  ULONG          TdiReceiveDatagramFlags,
    IN  ULONG          BytesIndicated,
    IN  ULONG          BytesAvailable,
    OUT PULONG         BytesTaken,
    IN  PVOID          Tsdu,
    OUT PIRP *         Irp
    )
{
    NTSTATUS                 status;
    PVOID                    DataBuffer;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    if (BytesAvailable == 0) {

        *Irp = NULL;
        return(STATUS_SUCCESS);
    }

    //
    // We need to fetch the rest of the packet before we
    // can process it.
    //
    //
    // Allocate a buffer to hold the data.
    //
    DataBuffer = SpMemAllocNonPagedPool(BytesAvailable);

    if (DataBuffer != NULL) {
        *Irp = IoAllocateIrp(SpUdpDatagramDeviceObject->StackSize, FALSE);

        if (*Irp != NULL) {

            PMDL  mdl = IoAllocateMdl(
                            DataBuffer,
                            BytesAvailable,
                            FALSE,
                            FALSE,
                            NULL
                            );

            if (mdl != NULL) {

                MmBuildMdlForNonPagedPool(mdl);

                //
                // Build the irp.
                //
                (*Irp)->Flags = 0;
                (*Irp)->RequestorMode = KernelMode;
                (*Irp)->PendingReturned = FALSE;
                (*Irp)->UserIosb = NULL;
                (*Irp)->UserEvent = NULL;
                (*Irp)->Overlay.AsynchronousParameters.UserApcRoutine = NULL;
                (*Irp)->AssociatedIrp.SystemBuffer = NULL;
                (*Irp)->UserBuffer = NULL;
                (*Irp)->Tail.Overlay.Thread = 0;
                (*Irp)->Tail.Overlay.OriginalFileObject = SpUdpDatagramFileObject;
                (*Irp)->Tail.Overlay.AuxiliaryBuffer = NULL;

                TdiBuildReceiveDatagram(
                    (*Irp),
                    SpUdpDatagramDeviceObject,
                    SpUdpDatagramFileObject,
                    SpUdpCompleteReceivePacket,
                    DataBuffer,
                    mdl,
                    BytesAvailable,
                    NULL,
                    NULL,
                    0
                    );

                //
                // Make the next stack location current.
                // Normally IoCallDriver would do this, but
                // since we're bypassing that, we do it directly.
                //
                IoSetNextIrpStackLocation( *Irp );
                return(STATUS_MORE_PROCESSING_REQUIRED);
            }

            IoFreeIrp(*Irp);
            *Irp = NULL;
        }

        SpMemFree(DataBuffer);
        DataBuffer = NULL;
    }


    //
    // Something went wrong. Drop the packet.
    //
    *BytesTaken += BytesAvailable;
    return(STATUS_SUCCESS);

}  // SpUdpReceivePacketHandler


NTSTATUS
SpUdpCompleteReceivePacket(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    )
{
    if (Irp->IoStatus.Status == STATUS_SUCCESS) {

        SpUdpProcessReceivePacket(
            (ULONG)Irp->IoStatus.Information,
            Context
            );

        IoFreeMdl(Irp->MdlAddress);
        IoFreeIrp(Irp);
    }

    return(STATUS_MORE_PROCESSING_REQUIRED);

} // SpUdpCompleteReceivePacket


VOID
SpUdpProcessReceivePacket(
    IN  ULONG          TsduSize,
    IN  PVOID          Tsdu
    )
{
    SPUDP_PACKET UNALIGNED * header = Tsdu;
    PSPUDP_RECEIVE_ENTRY ReceiveEntry;

    ASSERT(TsduSize >= sizeof(SPUDP_PACKET));

    if ((RtlCompareMemory(header->Signature, SetupResponseSignature, sizeof(SetupResponseSignature)) ==
         sizeof(SetupResponseSignature)) &&
        (SpUdpNumReceivePackets < 100)) {

        //
        // Put this packet on the receive list
        //
        ReceiveEntry = SpMemAllocNonPagedPool(sizeof(SPUDP_RECEIVE_ENTRY));

        if (ReceiveEntry == NULL) {
            SpMemFree(Tsdu);
            return;
        }

        ReceiveEntry->DataBufferLength = TsduSize;
        ReceiveEntry->DataBuffer = Tsdu;

        KeAcquireSpinLock(&SpUdpLock, &SpUdpOldIrql);
        InsertTailList(&SpUdpReceiveList, &(ReceiveEntry->ListEntry));
        SpUdpNumReceivePackets++;
        KeReleaseSpinLock(&SpUdpLock, SpUdpOldIrql);

    } else {

        SpMemFree(Tsdu);

    }

    return;

} // SpUdpProcessReceivePacket


NTSTATUS
SpUdpSendDatagram(
    IN PVOID                 SendBuffer,
    IN ULONG                 SendBufferLength,
    IN ULONG                 RemoteHostAddress,
    IN USHORT                RemoteHostPort
    )
{
    NTSTATUS         status = STATUS_SUCCESS;
    PLIST_ENTRY      entry;
    PIRP             irp;
    PMDL             dataMdl;
    PTDI_CONNECTION_INFORMATION   TdiSendDatagramInfo = NULL;
    PTRANSPORT_ADDRESS TaAddress;
    PTDI_ADDRESS_IP  TdiAddressIp;

    TdiSendDatagramInfo = SpMemAllocNonPagedPool(sizeof(TDI_CONNECTION_INFORMATION) +
                                                 sizeof(TA_IP_ADDRESS)
                                                );

    if (TdiSendDatagramInfo == NULL) {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlZeroMemory(TdiSendDatagramInfo,
                  sizeof(TDI_CONNECTION_INFORMATION) +
                      sizeof(TA_IP_ADDRESS)
                 );

    dataMdl = IoAllocateMdl(
                 SendBuffer,
                 SendBufferLength,
                 FALSE,
                 FALSE,
                 NULL
                 );

    if (dataMdl == NULL) {
        SpMemFree(TdiSendDatagramInfo);
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    MmBuildMdlForNonPagedPool(dataMdl);

    //
    // Ok, we can send the packet.
    //
    irp = IoAllocateIrp(SpUdpDatagramDeviceObject->StackSize, FALSE);

    if (irp != NULL) {

        //
        // Reference the network so it can't disconnect while we are using it.
        //
        KeAcquireSpinLock(&SpUdpLock, &SpUdpOldIrql);

        if (SpUdpNetworkState != SpUdpNetworkConnected) {
            KeReleaseSpinLock(&SpUdpLock, SpUdpOldIrql);
            return STATUS_SUCCESS;
        }
        SpUdpActiveRefCount++;

        KeReleaseSpinLock(&SpUdpLock, SpUdpOldIrql);

        //
        // Set the addressing info
        //
        TdiSendDatagramInfo->RemoteAddressLength = sizeof(TA_IP_ADDRESS);
        TdiSendDatagramInfo->RemoteAddress = (PVOID)(TdiSendDatagramInfo + 1);
        TaAddress = (PTRANSPORT_ADDRESS)(TdiSendDatagramInfo->RemoteAddress);
        TaAddress->TAAddressCount = 1;
        TaAddress->Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
        TaAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
        TdiAddressIp = (PTDI_ADDRESS_IP)(&(TaAddress->Address[0].Address[0]));
        TdiAddressIp->in_addr = RemoteHostAddress;
        TdiAddressIp->sin_port= htons(RemoteHostPort);
        RtlZeroMemory(TdiAddressIp->sin_zero, sizeof(TdiAddressIp->sin_zero));

        //
        // Build the irp.
        //
        irp->Flags = 0;
        irp->RequestorMode = KernelMode;
        irp->PendingReturned = FALSE;

        irp->UserIosb = NULL;
        irp->UserEvent = NULL;

        irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;

        irp->AssociatedIrp.SystemBuffer = NULL;
        irp->UserBuffer = NULL;

        irp->Tail.Overlay.Thread = PsGetCurrentThread();
        irp->Tail.Overlay.OriginalFileObject = SpUdpDatagramFileObject;
        irp->Tail.Overlay.AuxiliaryBuffer = NULL;

        TdiBuildSendDatagram(
            irp,
            SpUdpDatagramDeviceObject,
            SpUdpDatagramFileObject,
            SpUdpCompleteSendDatagram,
            TdiSendDatagramInfo,
            dataMdl,
            SendBufferLength,
            TdiSendDatagramInfo
            );

        //
        // Now send the packet.
        //
        IoCallDriver(
            SpUdpDatagramDeviceObject,
            irp
            );

        return(STATUS_PENDING);
    }

    IoFreeMdl(dataMdl);
    SpMemFree(TdiSendDatagramInfo);

    return(STATUS_INSUFFICIENT_RESOURCES);

}  // SpUdpSendDatagram


NTSTATUS
SpUdpCompleteSendDatagram(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
{
    PMDL               dataMdl;

    dataMdl = Irp->MdlAddress;
    Irp->MdlAddress = NULL;

    //
    // Remove the active reference we put on.
    //
    KeAcquireSpinLock(&SpUdpLock, &SpUdpOldIrql);

    SpUdpActiveRefCount--;

    if (SpUdpNetworkState == SpUdpNetworkDisconnecting) {
        SpUdpDisconnect();
    }

    KeReleaseSpinLock(&SpUdpLock, SpUdpOldIrql);

    //
    // Free the TDI address buffer
    //
    SpMemFree(Context);

    //
    // Free the Irp
    //
    IoFreeIrp(Irp);

    //
    // Free the MDL chain
    //
    IoFreeMdl(dataMdl);

    return(STATUS_MORE_PROCESSING_REQUIRED);

}  // SpUdpCompleteSendPacket

NTSTATUS
SpUdpSendAndReceiveDatagram(
    IN PVOID                 SendBuffer,
    IN ULONG                 SendBufferLength,
    IN ULONG                 RemoteHostAddress,
    IN USHORT                RemoteHostPort,
    IN SPUDP_RECEIVE_FN      SpUdpReceiveFunc
    )
{
    LARGE_INTEGER DelayTime;
    ULONG SendTries;
    ULONG RcvTries;
    PLIST_ENTRY ListEntry;
    PSPUDP_RECEIVE_ENTRY ReceiveEntry;
    NTSTATUS Status;

    DelayTime.QuadPart = -10*1000*1; // 10 millisecond (wake up at next tick)

    for (SendTries=0; SendTries < 15; SendTries++) {

        SpUdpSendDatagram(SendBuffer,
                          SendBufferLength,
                          RemoteHostAddress,
                          RemoteHostPort
                          );

        //
        // Wait for 1 second for a response
        //
        for (RcvTries=0; RcvTries < 400; ) {

            KeAcquireSpinLock(&SpUdpLock, &SpUdpOldIrql);
            if (!IsListEmpty(&SpUdpReceiveList)) {

                SpUdpNumReceivePackets--;
                ListEntry = RemoveHeadList(&SpUdpReceiveList);
                KeReleaseSpinLock(&SpUdpLock, SpUdpOldIrql);

                ReceiveEntry = CONTAINING_RECORD(ListEntry,
                                                 SPUDP_RECEIVE_ENTRY,
                                                 ListEntry
                                                );

                Status = (*SpUdpReceiveFunc)(ReceiveEntry->DataBuffer, ReceiveEntry->DataBufferLength);

                SpMemFree(ReceiveEntry->DataBuffer);
                SpMemFree(ReceiveEntry);

                if (NT_SUCCESS(Status)) {
                    return Status;
                }

            } else {

                KeReleaseSpinLock(&SpUdpLock, SpUdpOldIrql);

                RcvTries++;

                KeDelayExecutionThread(KernelMode, FALSE, &DelayTime);

            }

        }

    }

    return STATUS_UNSUCCESSFUL;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spvideo.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spvideo.c

Abstract:

    Text setup display support.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:


--*/



#include "spprecmp.h"
#include <hdlsblk.h>
#include <hdlsterm.h>
#pragma hdrstop

extern BOOLEAN ForceConsole;

//
// Video function vectors.
//
PVIDEO_FUNCTION_VECTOR VideoFunctionVector;

//
// Other display paramters
//
SP_VIDEO_VARS VideoVars;

BOOLEAN VideoInitialized = FALSE;

POEM_FONT_FILE_HEADER FontHeader;
ULONG                 FontBytesPerRow;
ULONG                 FontCharacterHeight;
ULONG                 FontCharacterWidth;

//
// bootfont.bin file image
//
PVOID   BootFontImage = NULL;
ULONG   BootFontImageLength = 0;

//
// The following structures and constants are used in font files.
//

//
// Define OS/2 executable resource information structure.
//

#define FONT_DIRECTORY 0x8007
#define FONT_RESOURCE 0x8008

typedef struct _RESOURCE_TYPE_INFORMATION {
    USHORT Ident;
    USHORT Number;
    LONG   Proc;
} RESOURCE_TYPE_INFORMATION, *PRESOURCE_TYPE_INFORMATION;

//
// Define OS/2 executable resource name information structure.
//

typedef struct _RESOURCE_NAME_INFORMATION {
    USHORT Offset;
    USHORT Length;
    USHORT Flags;
    USHORT Ident;
    USHORT Handle;
    USHORT Usage;
} RESOURCE_NAME_INFORMATION, *PRESOURCE_NAME_INFORMATION;

//
// These values are passed to us by setupldr and represent monitor config
// data from the monitor peripheral for the display we are supposed to use
// during setup.  They are used only for non-vga displays.
//
PMONITOR_CONFIGURATION_DATA MonitorConfigData;
PCHAR MonitorFirmwareIdString;

//
// Function prototypes.
//
BOOLEAN
pSpvidInitPalette(
    VOID
    );

VOID
SpvidInitialize0(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    Perform phase-0 display initialization.  This routine is used to
    perform initialization that can be performed only at driver load time.

    Actions:

        - initialize the font.  We retreive the hal oem font image
          from the loader block and copy it into locally allocated memory.
          This must be done here because the loader block is gone
          when setup is actually started.

Arguments:

    LoaderBlock - supplies pointer to loader parameter block.

Return Value:

    None.  Does not return if error.

--*/

{
    POEM_FONT_FILE_HEADER fontHeader;
    PSETUP_LOADER_BLOCK SetupBlock;
    BOOLEAN bValidOemFont;

    //
    // Check if the file has a font file header. Use SEH so that we don't bugcheck if
    // we got passed something screwy.
    //
    try {

        fontHeader = (POEM_FONT_FILE_HEADER)LoaderBlock->OemFontFile;

        if ((fontHeader->Version != OEM_FONT_VERSION) ||
            (fontHeader->Type != OEM_FONT_TYPE) ||
            (fontHeader->Italic != OEM_FONT_ITALIC) ||
            (fontHeader->Underline != OEM_FONT_UNDERLINE) ||
            (fontHeader->StrikeOut != OEM_FONT_STRIKEOUT) ||
            (fontHeader->CharacterSet != OEM_FONT_CHARACTER_SET) ||
            (fontHeader->Family != OEM_FONT_FAMILY) ||
            (fontHeader->PixelWidth > 32))
        {
            bValidOemFont = FALSE;
        } else {
            bValidOemFont = TRUE;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

        bValidOemFont = FALSE;
    }

    if(!bValidOemFont) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: oem hal font image is not a .fnt file.\n"));
        SpBugCheck(SETUP_BUGCHECK_BAD_OEM_FONT,0,0,0);
    }

    FontHeader = SpMemAlloc(fontHeader->FileSize);
    RtlMoveMemory(FontHeader,fontHeader,fontHeader->FileSize);

    FontBytesPerRow     = (FontHeader->PixelWidth + 7) / 8;
    FontCharacterHeight = FontHeader->PixelHeight;
    FontCharacterWidth  = FontHeader->PixelWidth;

    //
    // Get pointer to the setup loader block.
    //
    SetupBlock = LoaderBlock->SetupLoaderBlock;

    //
    // Save away monitor data.
    //

    if(SetupBlock->Monitor) {

        RtlMoveMemory(
            MonitorConfigData = SpMemAlloc(sizeof(MONITOR_CONFIGURATION_DATA)),
            SetupBlock->Monitor,
            sizeof(MONITOR_CONFIGURATION_DATA)
            );
    }

    if(SetupBlock->MonitorId) {

        MonitorFirmwareIdString = SpDupString(SetupBlock->MonitorId);
    }

    //
    // save off bootfont.bin file image, if any
    //
    if (SetupBlock->BootFontFile && SetupBlock->BootFontFileLength) {
        BootFontImage = SpMemAlloc(SetupBlock->BootFontFileLength);

        if (BootFontImage) {
            BootFontImageLength = SetupBlock->BootFontFileLength;

            RtlMoveMemory(BootFontImage, 
                SetupBlock->BootFontFile, 
                BootFontImageLength);
        }
    }

    //
    // Initialize the global video state
    //
    RtlZeroMemory(&VideoVars, sizeof(SP_VIDEO_VARS));
}


VOID
SpvidInitialize(
    VOID
    )
{
    NTSTATUS                Status;
    OBJECT_ATTRIBUTES       Attributes;
    IO_STATUS_BLOCK         IoStatusBlock;
    UNICODE_STRING          UnicodeString;
    VIDEO_NUM_MODES         NumModes;
    PVIDEO_MODE_INFORMATION VideoModes;
    PVIDEO_MODE_INFORMATION pVideoMode;
    ULONG                   VideoModesSize;
    ULONG                   mode;
    BOOLEAN                 IsVga;
    PVIDEO_FUNCTION_VECTOR  NewVector;
    PVIDEO_MODE_INFORMATION GraphicsVideoMode = NULL;


    //
    // If video is already initialized, we are performing a reinit.
    //
    if(VideoInitialized) {
        //
        // Request video function vector from the locale/lang-specific module.
        //
        NewVector = SplangGetVideoFunctionVector(
                        (VideoFunctionVector == &VgaVideoVector) ? SpVideoVga : SpVideoFrameBuffer,
                        &VideoVars
                        );

        //
        // If there is no alternate video then we're done. Else go into action.
        //
        if(NewVector) {
            SpvidTerminate();
        } else {
            return;
        }
    } else {
        NewVector = NULL;
    }

    
    //
    // Initialize the headless terminal.  Once we decide
    // to start UTF8 encoding (i.e. we're on a FE build),
    // then never stop.
    //
    SpTermDoUtf8 = (SpTermDoUtf8 || (NewVector != NULL));
    SpTermInitialize();
    //
    // Open \Device\Video0.
    //
    RtlInitUnicodeString(&UnicodeString,L"\\Device\\Video0");

    InitializeObjectAttributes(
        &Attributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = ZwCreateFile(
                &VideoVars.hDisplay,
                GENERIC_READ | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                &Attributes,
                &IoStatusBlock,
                NULL,                   // allocation size
                FILE_ATTRIBUTE_NORMAL,
                0,                      // no sharing
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,                   // no EAs
                0
                );

    if(!NT_SUCCESS(Status)) {
        //
        // if we're in headless mode, try to operate without the video card 
        // present...otherwise we're done
        //
        if (HeadlessTerminalConnected) {
            //
            // if there's no video card, then we default into VGA mode,
            // which will do nothing if there is no video card
            //
            VideoFunctionVector = &VgaVideoVector;
            VideoVars.ScreenWidth  = 80;
            VideoVars.ScreenHeight = HEADLESS_SCREEN_HEIGHT;
            //
            // Allocate a buffer for use translating unicode to oem.
            // Assuming each unicode char translates to a dbcs char,
            // we need a buffer twice the width of the screen to hold
            // (the width of the screen being the longest string
            // we'll display in one shot).
            //
            VideoVars.SpvCharTranslationBufferSize = (VideoVars.ScreenWidth+1)*2;
            VideoVars.SpvCharTranslationBuffer = SpMemAlloc(VideoVars.SpvCharTranslationBufferSize);

            VideoInitialized = TRUE;

            return;
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: NtOpenFile of \\device\\video0 returns %lx\n",Status));
            SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_OPEN, Status);
            while(TRUE);    // loop forever
        }
    }

    //
    // Request a list of video modes.
    //
    Status = ZwDeviceIoControlFile(
                VideoVars.hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
                NULL,
                0,
                &NumModes,
                sizeof(NumModes)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to query video mode count (status = %lx)\n",Status));
        ZwClose(VideoVars.hDisplay);
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_GETNUMMODES, Status);
        while(TRUE);    // loop forever
    }

    VideoModesSize = NumModes.NumModes * NumModes.ModeInformationLength;
    VideoModes = SpMemAlloc(VideoModesSize);

    Status = ZwDeviceIoControlFile(
                VideoVars.hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_QUERY_AVAIL_MODES,
                NULL,
                0,
                VideoModes,
                VideoModesSize
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to get list of video modes (status = %lx)\n",Status));
        SpMemFree(VideoModes);
        ZwClose(VideoVars.hDisplay);
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_GETMODES, Status);
        while(TRUE);    // loop forever
    }

    //
    // If we have a 720 x 400 text mode, it's vga.
    // Otherwise it's a frame buffer.
    //
    IsVga = FALSE;

    pVideoMode = &VideoModes[0];

    for(mode=0; mode<NumModes.NumModes; mode++) {

        if(!IsVga && !(pVideoMode->AttributeFlags & VIDEO_MODE_GRAPHICS)
        && (pVideoMode->VisScreenWidth == 720)
        && (pVideoMode->VisScreenHeight == 400))
        {
            IsVga = TRUE;
        }

        if ((pVideoMode->AttributeFlags & VIDEO_MODE_GRAPHICS) &&
             (pVideoMode->VisScreenWidth == 640) &&
             (pVideoMode->VisScreenHeight == 480) && 
             (pVideoMode->NumberOfPlanes == 4) && 
             (pVideoMode->BitsPerPlane == 1)) {
             GraphicsVideoMode = pVideoMode;
        }             

        pVideoMode = (PVIDEO_MODE_INFORMATION) (((PUCHAR) pVideoMode) + NumModes.ModeInformationLength);
    }

    VideoFunctionVector = NewVector ? NewVector : (IsVga ? &VgaVideoVector : &FrameBufferVideoVector);

    if (GraphicsVideoMode) {
        VideoVars.GraphicsModeInfo = *GraphicsVideoMode;
    } else {
        //
        // disable graphics mode
        //
        SP_SET_UPGRADE_GRAPHICS_MODE(FALSE);
    }                

    spvidSpecificInitialize(VideoModes,NumModes.NumModes,NumModes.ModeInformationLength);

    // Set the terminal Height to the correct value
    if (HeadlessTerminalConnected) {
        VideoVars.ScreenHeight = HEADLESS_SCREEN_HEIGHT;
    }
    
    //
    // Allocate a buffer for use translating unicode to oem.
    // Assuming each unicode char translates to a dbcs char,
    // we need a buffer twice the width of the screen to hold
    // (the width of the screen being the longest string
    // we'll display in one shot).
    //
    VideoVars.SpvCharTranslationBufferSize = (VideoVars.ScreenWidth+1)*2;
    VideoVars.SpvCharTranslationBuffer = SpMemAlloc(VideoVars.SpvCharTranslationBufferSize);

    pSpvidInitPalette();

    CLEAR_ENTIRE_SCREEN();
    
    VideoInitialized = TRUE;

    SpMemFree(VideoModes);

}



VOID
SpvidTerminate(
    VOID
    )
{
    NTSTATUS Status;

    if(VideoInitialized) {

        spvidSpecificTerminate();

        SpTermTerminate();

        if (VideoVars.hDisplay) {
            Status = ZwClose(VideoVars.hDisplay);
    
            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to close \\device\\video0 (status = %lx)\n",Status));
            }
        }

        SpMemFree(VideoVars.SpvCharTranslationBuffer);
        VideoVars.SpvCharTranslationBuffer = NULL;

        VideoInitialized = FALSE;
    }
}


UCHAR
GetDefaultAttr(
    void
    )
{
    return (UCHAR)(ForceConsole ? (ATT_FG_WHITE | ATT_BG_BLACK) : (ATT_FG_WHITE | ATT_BG_BLUE));
}


UCHAR
GetDefaultBackground(
    void
    )
{
    return (UCHAR)(ForceConsole ? ATT_BLACK : ATT_BLUE);
}


UCHAR
GetDefaultStatusAttr(
    void
    )
{
    return (UCHAR)(ForceConsole ? (ATT_FG_WHITE | ATT_BG_BLACK) : (ATT_FG_BLACK | ATT_BG_WHITE));
}


UCHAR
GetDefaultStatusBackground(
    void
    )
{
    return (UCHAR)(ForceConsole ? ATT_BLACK : ATT_WHITE);
}


BOOLEAN
SpvidGetModeParams(
    OUT PULONG XResolution,
    OUT PULONG YResolution,
    OUT PULONG BitsPerPixel,
    OUT PULONG VerticalRefresh,
    OUT PULONG InterlacedFlag
    )
{
    if(VideoVars.VideoModeInfo.AttributeFlags & VIDEO_MODE_GRAPHICS) {

        *XResolution = VideoVars.VideoModeInfo.VisScreenWidth;
        *YResolution = VideoVars.VideoModeInfo.VisScreenHeight;
        *BitsPerPixel = VideoVars.VideoModeInfo.BitsPerPlane;
        *VerticalRefresh = VideoVars.VideoModeInfo.Frequency;
        *InterlacedFlag = (VideoVars.VideoModeInfo.AttributeFlags & VIDEO_MODE_INTERLACED) ? 1 : 0;

        return(TRUE);

    } else {

        //
        // VGA/text mode. Params are not interesting.
        //
        return(FALSE);
    }
}



BOOLEAN
pSpvidInitPalette(
    VOID
    )

/*++

Routine Description:

    Set the display up so we can use the standard 16 cga attributes.

    If the video mode is direct color, then we construct a table of
    attribute to color mappings based on the number of bits for
    red, green, and blue.

    If the video mode is palette driven, then we actually construct
    a 16-color palette and pass it to the driver.

Arguments:

    VOID

Return Value:

    TRUE if display set up successfully, false if not.

--*/


{
    ULONG i;
    ULONG MaxVal[3];
    ULONG MidVal[3];

    #define C_RED 0
    #define C_GRE 1
    #define C_BLU 2

    if(VideoVars.VideoModeInfo.AttributeFlags & VIDEO_MODE_PALETTE_DRIVEN) {

        UCHAR Buffer[sizeof(VIDEO_CLUT)+(sizeof(VIDEO_CLUTDATA)*15)];   // size is close enough
        PVIDEO_CLUT clut = (PVIDEO_CLUT)Buffer;
        NTSTATUS Status;
        IO_STATUS_BLOCK IoStatusBlock;

        //
        // Palette driven.  Set up the attribute to color table
        // as a one-to-one mapping so we can use attribute values
        // directly in the frame buffer and get the expected result.
        //
        MaxVal[C_RED] = ((1 << VideoVars.VideoModeInfo.NumberRedBits  ) - 1);
        MaxVal[C_GRE] = ((1 << VideoVars.VideoModeInfo.NumberGreenBits) - 1);
        MaxVal[C_BLU] = ((1 << VideoVars.VideoModeInfo.NumberBlueBits ) - 1);

        MidVal[C_RED] = 2 * MaxVal[C_RED] / 3;
        MidVal[C_GRE] = 2 * MaxVal[C_GRE] / 3;
        MidVal[C_BLU] = 2 * MaxVal[C_BLU] / 3;

        clut->NumEntries = 16;
        clut->FirstEntry = 0;

        for(i=0; i<16; i++) {

            VideoVars.AttributeToColorValue[i] = i;

            clut->LookupTable[i].RgbArray.Red   = (UCHAR)((i & ATT_RED  )
                                                ? ((i & ATT_INTENSE) ? MaxVal[C_RED] : MidVal[C_RED])
                                                : 0);

            clut->LookupTable[i].RgbArray.Green = (UCHAR)((i & ATT_GREEN)
                                                ? ((i & ATT_INTENSE) ? MaxVal[C_GRE] : MidVal[C_GRE])
                                                : 0);

            clut->LookupTable[i].RgbArray.Blue  = (UCHAR)((i & ATT_BLUE )
                                                ? ((i & ATT_INTENSE) ? MaxVal[C_BLU] : MidVal[C_BLU])
                                                : 0);

            clut->LookupTable[i].RgbArray.Unused = 0;
        }

        Status = ZwDeviceIoControlFile(
                    VideoVars.hDisplay,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    IOCTL_VIDEO_SET_COLOR_REGISTERS,
                    clut,
                    sizeof(Buffer),
                    NULL,
                    0
                    );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set palette (status = %lx)\n",Status));
            return(FALSE);
        }

    } else {

        //
        // Direct color. Construct an attribute to color value table.
        //
        ULONG mask[3];
        ULONG bitcnt[3];
        ULONG bits;
        ULONG shift[3];
        unsigned color;

        //
        // Determine the ranges for each of red, green, and blue.
        //
        mask[C_RED] = VideoVars.VideoModeInfo.RedMask;
        mask[C_GRE] = VideoVars.VideoModeInfo.GreenMask;
        mask[C_BLU] = VideoVars.VideoModeInfo.BlueMask;

        bitcnt[C_RED] = VideoVars.VideoModeInfo.NumberRedBits;
        bitcnt[C_GRE] = VideoVars.VideoModeInfo.NumberGreenBits;
        bitcnt[C_BLU] = VideoVars.VideoModeInfo.NumberBlueBits;

        shift[C_RED] = 32;
        shift[C_GRE] = 32;
        shift[C_BLU] = 32;

        for(color=0; color<3; color++) {

            bits = 0;

            //
            // Count the number of 1 bits and determine the shift value
            // to shift in that color component.
            //
            for(i=0; i<32; i++) {

                if(mask[color] & (1 << i)) {

                    bits++;

                    //
                    // Remember the position of the least significant bit
                    // in this mask.
                    //
                    if(shift[color] == 32) {
                        shift[color] = i;
                    }
                }
            }

            //
            // Calculate the maximum color value for this color component.
            //
            MaxVal[color] = (1 << bits) - 1;

            //
            // Make sure we haven't overflowed the actual number of bits
            // available for this color component.
            //
            if(bitcnt[color] && (MaxVal[color] > ((ULONG)(1 << bitcnt[color]) - 1))) {
                MaxVal[color] = (ULONG)(1 << bitcnt[color]) - 1;
            }
        }

        MidVal[C_RED] = 2 * MaxVal[C_RED] / 3;
        MidVal[C_GRE] = 2 * MaxVal[C_GRE] / 3;
        MidVal[C_BLU] = 2 * MaxVal[C_BLU] / 3;

        //
        // Now go through and construct the color table.
        //
        for(i=0; i<16; i++) {

            VideoVars.AttributeToColorValue[i] =

                (((i & ATT_RED)
               ? ((i & ATT_INTENSE) ? MaxVal[C_RED] : MidVal[C_RED])
               : 0)
                << shift[C_RED])

             |  (((i & ATT_GREEN)
               ? ((i & ATT_INTENSE) ? MaxVal[C_GRE] : MidVal[C_GRE])
               : 0)
                << shift[C_GRE])

             |  (((i & ATT_BLUE)
               ? ((i & ATT_INTENSE) ? MaxVal[C_BLU] : MidVal[C_BLU])
               : 0)
                << shift[C_BLU]);
        }
    }

    //
    // Perform any display-specific palette setup.
    //
    return(spvidSpecificInitPalette());
}



VOID
pSpvidMapVideoMemory(
    IN BOOLEAN Map
    )

/*++

Routine Description:

    Map or unmap video memory.  Fills in or uses the VideoMemoryInfo global.

Arguments:

    Map - if TRUE, map video memory.
          if FALSE, unmap video memory.


Return Value:

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    VIDEO_MEMORY VideoMemory;

    VideoMemory.RequestedVirtualAddress = Map ? NULL : VideoVars.VideoMemoryInfo.VideoRamBase;

    Status = ZwDeviceIoControlFile(
                VideoVars.hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                Map ? IOCTL_VIDEO_MAP_VIDEO_MEMORY : IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
                &VideoMemory,
                sizeof(VideoMemory),
                Map ? &VideoVars.VideoMemoryInfo : NULL,
                Map ? sizeof(VideoVars.VideoMemoryInfo) : 0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to %smap video memory (status = %lx)\n",Map ? "" : "un",Status));
        if(Map) {
            SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_MAP, Status);
            while(TRUE);    // loop forever
        }
    }
}


VOID
SpvidDisplayString(
    IN PWSTR String,
    IN UCHAR Attribute,
    IN ULONG X,
    IN ULONG Y
    )
{
    //
    // Convert unicode string to oem, guarding against overflow.
    //
    RtlUnicodeToOemN(
        VideoVars.SpvCharTranslationBuffer,
        VideoVars.SpvCharTranslationBufferSize-1,     // guarantee room for nul
        NULL,
        String,
        (wcslen(String)+1)*sizeof(WCHAR)
        );

    VideoVars.SpvCharTranslationBuffer[VideoVars.SpvCharTranslationBufferSize-1] = 0;

    spvidSpecificDisplayString(VideoVars.SpvCharTranslationBuffer,Attribute,X,Y);
       
    SpTermDisplayStringOnTerminal( String, Attribute, X, Y);

}


VOID
SpvidDisplayOemString(
    IN PSTR  String,
    IN UCHAR Attribute,
    IN ULONG X,
    IN ULONG Y
    )
{
    spvidSpecificDisplayString(String,Attribute,X,Y);

    RtlOemToUnicodeN(
        (PWSTR)VideoVars.SpvCharTranslationBuffer,
        VideoVars.SpvCharTranslationBufferSize-1,     // guarantee room for nul
        NULL,
        String,
        (strlen(String)+1)*sizeof(CHAR));

    //
    // make it a unicode NULL at the end
    //
    VideoVars.SpvCharTranslationBuffer[VideoVars.SpvCharTranslationBufferSize-1] = '\0';
    VideoVars.SpvCharTranslationBuffer[VideoVars.SpvCharTranslationBufferSize-2] = '\0';

    SpTermDisplayStringOnTerminal((PWSTR)VideoVars.SpvCharTranslationBuffer, Attribute, X, Y);

}


VOID
SpvidClearScreenRegion(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG W,
    IN ULONG H,
    IN UCHAR Attribute
    )

/*++

Routine Description:

    Clear out a screen region to a specific attribute.

Arguments:

    X,Y,W,H - specify rectangle in 0-based character coordinates.
        If W or H are 0, clear the entire screen.

    Attribute - Low nibble specifies attribute to be filled in the rectangle
        (ie, the background color to be cleared to).

Return Value:

    None.

--*/

{
    ULONG   i;
    UCHAR   FillAttribute;
    WCHAR   TerminalLine[80];
    BOOLEAN ToEOL;

    if(!W || !H) {
        X = Y = 0;
        W = VideoVars.ScreenWidth;
        H = VideoVars.ScreenHeight;

    } else {
        ASSERT(X+W <= VideoVars.ScreenWidth);
        ASSERT(X <= VideoVars.ScreenWidth);
        ASSERT(W <= VideoVars.ScreenWidth);
        ASSERT(Y+H <= VideoVars.ScreenHeight);
        ASSERT(Y <= VideoVars.ScreenHeight);
        ASSERT(H <= VideoVars.ScreenHeight);

        if (W > VideoVars.ScreenWidth)
                W = VideoVars.ScreenWidth;

        if (X > VideoVars.ScreenWidth)
            X = VideoVars.ScreenWidth;
        
        if(X+W > VideoVars.ScreenWidth) {
            W = VideoVars.ScreenWidth-X;
        }

        if(Y > VideoVars.ScreenHeight) {
            Y = VideoVars.ScreenHeight;
        }

        if(H > VideoVars.ScreenHeight) {
            H = VideoVars.ScreenHeight;
        }

        if(Y+H > VideoVars.ScreenHeight) {
            H = VideoVars.ScreenHeight-Y;
        }
    }

    spvidSpecificClearRegion(X,Y,W,H,Attribute);
    
    FillAttribute = (Attribute << 4) | Attribute;    

    ToEOL = FALSE;
    if (X + W < 80) {
        for (i = 0; i<W;i++) {
            TerminalLine[i] = L' ';
        }
        TerminalLine[W] = L'\0';
    } else {
        for (i = 0; i<(79-X); i++) {
            TerminalLine[i] = L' ';
        }
        TerminalLine[79 - X] = L'\0';    
        if ((X == 0) && (Attribute == DEFAULT_BACKGROUND)) {
            ToEOL = TRUE;
        }
    }
    for(i=0; i<H; i++) {

        if (ToEOL) {
            SpTermDisplayStringOnTerminal(HEADLESS_CLEAR_TO_EOL_STRING, 
                                          FillAttribute, 
                                          X, 
                                          Y + i
                                         );
        } else {
            SpTermDisplayStringOnTerminal(TerminalLine, FillAttribute, X, Y + i);
        }
    }


}


BOOLEAN
SpvidScrollUp(
    IN ULONG TopLine,
    IN ULONG BottomLine,
    IN ULONG LineCount,
    IN UCHAR FillAttribute
    )
{
    BOOLEAN vidSpecificRet;
    ULONG i; 
    ULONG line;
    WCHAR TerminalLine[80];
    
    vidSpecificRet = spvidSpecificScrollUp(TopLine,BottomLine,LineCount,FillAttribute);
    if (!HeadlessTerminalConnected) {
        return(vidSpecificRet);
    }

    if ((TopLine == 0) && (BottomLine==VideoVars.ScreenHeight-1)) {        
        //
        // Efficient scrolling for *whole screen* by
        // issuing the <CSI>x;80H escape, which moves the cursor to
        // the bottom right corner of the VT100.  Each time we
        // move the cursor to this position, it makes the VT100 scroll
        // one line.
        //
        swprintf(TerminalLine, L"\033[%d;80H\n", BottomLine+1);
        for (i=0;i<LineCount; i++){
            SpTermSendStringToTerminal(TerminalLine,
                                       TRUE
                                       );
        }
        return vidSpecificRet;
    }

    //
    // We have to scroll it the hard way because we're not doing the
    // entire screen
    //

    //
    // Select the top and bottom line numbers via <CSI>x;yr escape
    // this will be some portion of the active display
    //
    swprintf(TerminalLine,L"\033[%d;%dr", TopLine+1, BottomLine+1);
    SpTermSendStringToTerminal(TerminalLine,
                               TRUE
                               );

    //
    // move the cursor to the bottom right corner of the selected area 
    // via <CSI>x;80H escape.  Each time we write to this area, it makes
    // the selected area scroll one line
    //
    swprintf(TerminalLine, L"\033[%d;80H\n", BottomLine+1);
    for(i = 0; i< LineCount; i++){
        SpTermSendStringToTerminal(TerminalLine,
                                   TRUE
                                   );
    }

    //
    // get a line of whitespace to clear out the bottom lines that may
    // have garbage in them now.
    //
    for (i=0;i<79;i++) {
        TerminalLine[i] = L' ';
    }
    TerminalLine[79] = '\0';

    
    line = BottomLine - LineCount + 1;
    for(i=0;i<LineCount;i++){
        SpTermDisplayStringOnTerminal(TerminalLine,
                                      FillAttribute,
                                      0,
                                      line + i
                                      );
    }

    //
    // send <CSI>r escape, which resets the selected line numbers
    // so that the entire display is active again.
    //
    swprintf(TerminalLine, L"\033[r");
    SpTermSendStringToTerminal(TerminalLine,
                               TRUE
                               );
    return vidSpecificRet;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\sputil.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    sputil.c

Abstract:

    Miscellaneous functions for text setup.

Author:

    Ted Miller (tedm) 17-Sep-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop
#include "bootvar.h"
#include "bootstatus.h"

#if !defined(SETUP_CAB_TEST_USERMODE)


//
// On the x86 and amd64, we want to clear the previous OS entry in boot.ini
// if we reformat C:
//

#if defined(_AMD64_) || defined(_X86_)
UCHAR    OldSystemLine[MAX_PATH];
BOOLEAN  DiscardOldSystemLine = FALSE;
#endif // defined(_AMD64_) || defined(_X86_)

BOOLEAN Nec98RestoreBootFiles = TRUE; //NEC98
extern PDISK_REGION TargetRegion_Nec98;

#define REGKEY_SERVICES L"\\Registry\\Machine\\System\\CurrentControlSet\\Services"

LIST_ENTRY SpServiceList;

typedef struct _SERVICE_ENTRY {
    LIST_ENTRY Next;
    PWCHAR ServiceName;
} SERVICE_ENTRY, *PSERVICE_ENTRY;

//
// Setup progress callback data
//
#define MAX_SETUP_PROGRESS_SUBSCRIBERS  8

ULONG ProgressSubscribersCount = 0;
TM_PROGRESS_SUBSCRIBER  ProgressSubscribers[MAX_SETUP_PROGRESS_SUBSCRIBERS] = {0};


//
// NEC98
//
NTSTATUS
SpDeleteAndBackupBootFiles(
    IN BOOLEAN  RestoreBackupFiles,
    IN BOOLEAN  DeleteBackupFiles,
    IN BOOLEAN  DeleteRootFiles,
    IN BOOLEAN  RestorePreviousOs,
    IN BOOLEAN  ClearBootFlag
    );

//
// NEC98
//
VOID
SpSetAutoBootFlag(
    IN PDISK_REGION TargetRegion,
    IN BOOLEAN      SetBootPosision
    );

//
// NEC98
//
NTSTATUS
SppRestoreBootCode(
    VOID
    );

//
// These symbols are the Chkdsk return codes given by autochk
// when invoked with the '/s' switch.  They were duplicated from
// utils\ifsutil\inc\supera.hxx, and should be kept in sync with
// the codes listed there.
//

#define CHKDSK_EXIT_SUCCESS         0
#define CHKDSK_EXIT_ERRS_FIXED      1
#define CHKDSK_EXIT_MINOR_ERRS      2       // whether or not "/f"
#define CHKDSK_EXIT_COULD_NOT_CHK   3
#define CHKDSK_EXIT_ERRS_NOT_FIXED  3
#define CHKDSK_EXIT_COULD_NOT_FIX   3

#define AUTOFMT_EXIT_SUCCESS          0
#define AUTOFMT_EXIT_COULD_NOT_FORMAT 1

//
//  Gauge used to display progress of autochk and autofmt
//
PVOID   UserModeGauge = NULL;

//
//  This variable is used when displaying the progress bar
//  during autochk and autofmt. It indicates the disk that
//  is being autochecked or formatted.
//
ULONG   CurrentDiskIndex = 0;


//
// Seed used for generating random number for disk signature
// and pseudo GUIDs
//
ULONG RandomSeed = 17;


BOOLEAN
SppPromptOptionalAutochk(
    IN PVOID SifHandle,
    IN PWSTR MediaShortname,
    IN PWSTR DiskDevicePath
    );


extern BOOLEAN
SpGenerateNTPathName(
    IN  PDISK_REGION Region,
    IN  PWSTR        DefaultPath,
    OUT PWSTR        TargetPath
    );

VOID
SpDone(
    IN DWORD   MsgId,
    IN BOOLEAN Successful,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    Display a message indicating that we are done with setup,
    and text setup completed successfully, or that windows nt
    is not installed.  Then reboot the machine.

Arguments:

    Successful - if TRUE, then tell the user that pressing enter will
        restart the machine and continue setup.  Otherwise, tell the user
        that Windows NT is not installed.

    Wait - if FALSE, do not display a screen, just reboot immediately.
        Otherwise, wait for the user to press enter before rebooting.

Return Value:

    DOES NOT RETURN

--*/

{
    #define SECS_FOR_REBOOT 15
    ULONG MessageId;
    PWSTR p;
    LARGE_INTEGER DelayInterval;
    ULONG InputChar;
    ULONG Seconds;
    PVOID DelayGauge;


    if(Wait) {

        if (MsgId) {
            MessageId = MsgId;
        } else if(RepairWinnt) {
            MessageId = Successful ? SP_SCRN_REPAIR_SUCCESS : SP_SCRN_REPAIR_FAILURE;
        } else {
            MessageId = Successful ? SP_SCRN_TEXTSETUP_SUCCESS : SP_SCRN_TEXTSETUP_FAILURE;
        }

        SpStartScreen(MessageId,3,4,FALSE,FALSE,DEFAULT_ATTRIBUTE);

#if defined(_AMD64_) || defined(_X86_)
        SpContinueScreen(SP_SCRN_REMOVE_FLOPPY,3,1,FALSE,DEFAULT_ATTRIBUTE);
        //
        // For machines with El-Torito boot we need to tell the user
        // to remove the CD-ROM also. There are a whole bunch of different
        // possibilities: user booted from floppy but is using the CD, etc.
        // We'll only tell the user to remove the CD if he actually booted
        // from it, since otherwise we assume the machine is set up to *not*
        // boot from CD-ROM and the presence of the CD is irrelevent.
        //
        // tedm: the above logic is nice but there are plenty of machines
        // out there with broken eltorito. Thus well always tell people to
        // remove the CD if they have a CD-ROM drive.
        //
#if 0
        SpStringToLower(ArcBootDevicePath);
        if(wcsstr(ArcBootDevicePath,L")cdrom(")) {
            SpContinueScreen(SP_SCRN_ALSO_REMOVE_CD,3,0,FALSE,DEFAULT_ATTRIBUTE);
        }
// #else
        if(IoGetConfigurationInformation()->CdRomCount) {
            SpContinueScreen(SP_SCRN_ALSO_REMOVE_CD,3,0,FALSE,DEFAULT_ATTRIBUTE);
        }
#endif

#endif // defined(_AMD64_) || defined(_X86_)

        SpContinueScreen(SP_SCRN_ENTER_TO_RESTART,3,1,FALSE,DEFAULT_ATTRIBUTE);
        if(!RepairWinnt && Successful) {
            SpContinueScreen(SP_SCRN_RESTART_EXPLAIN,3,0,FALSE,DEFAULT_ATTRIBUTE);
        }

        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_ENTER_EQUALS_RESTART,0);

        DelayInterval.LowPart = -10000000;
        DelayInterval.HighPart = -1;
        Seconds = 0;

        SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_TEXT_SETUP_REBOOT);
        DelayGauge = SpCreateAndDisplayGauge(
            SECS_FOR_REBOOT,
            0,
            15,
            L"",
            TemporaryBuffer,
            GF_ITEMS_REMAINING,
            ATT_BG_RED | ATT_BG_INTENSE
            );
        ASSERT( DelayGauge );

        SpInputDrain();
        while (Seconds < SECS_FOR_REBOOT) {
            KeDelayExecutionThread( ExGetPreviousMode(), FALSE, &DelayInterval );
            if (SpInputIsKeyWaiting()) {
                InputChar = SpInputGetKeypress();
                if (InputChar == ASCI_CR) {
                    break;
                } else {
                    SpInputDrain();
                    break;
                }
            }
            SpTickGauge( DelayGauge );
            Seconds += 1;
        }

        SpDestroyGauge( DelayGauge );
    }


#ifdef _X86_
    //
    // restore backed up boot files for other OS on NEC98.
    //
    if (IsNEC_98) { //NEC98
        if(Nec98RestoreBootFiles && (IsFloppylessBoot || UnattendedOperation)) {

            WCHAR DevicePath[MAX_PATH];
            WCHAR PartitionPath[MAX_PATH];
            BOOLEAN RestoreBackupFiles, DeleteBackupFiles, DeleteRootDirFiles, RestorePreviousOs, ClearBootFlag;

            if(TargetRegion_Nec98) {
                wcscpy(DevicePath,
                       PartitionedDisks[TargetRegion_Nec98->DiskNumber].HardDisk->DevicePath
                       );
                swprintf(PartitionPath,
                         L"partition%lu",
                         SpPtGetOrdinal(TargetRegion_Nec98,PartitionOrdinalCurrent)
                         );
                SpConcatenatePaths(DevicePath,PartitionPath);
            }

            if(Successful){
                if(!_wcsicmp(NtBootDevicePath, DevicePath)) {
                    //
                    // case normal exit and same bootpath and targetpath.
                    //
                    RestoreBackupFiles  = FALSE;
                    DeleteBackupFiles   = TRUE;
                    DeleteRootDirFiles  = FALSE;
                    RestorePreviousOs   = FALSE;
                    ClearBootFlag       = FALSE;
                    //SpDeleteAndBackupBootFiles(FALSE,TRUE,FALSE,FALSE,FALSE);
                } else {
                    //
                    // case normal exit and different bootpath and targetpath.
                    //
                    RestoreBackupFiles  = TRUE;
                    DeleteBackupFiles   = TRUE;
                    DeleteRootDirFiles  = TRUE;
                    RestorePreviousOs   = TRUE;
                    ClearBootFlag       = FALSE;
                    //SpDeleteAndBackupBootFiles(TRUE,TRUE,TRUE,TRUE,FALSE);

                }
            } else {
                //
                // case abnormal exit
                //
                if(TargetRegion_Nec98) {
                    //
                    // after selecting target partition
                    //
                    if(!_wcsicmp(NtBootDevicePath, DevicePath)) {
                        RestoreBackupFiles  = FALSE;
                        DeleteBackupFiles   = TRUE;
                        DeleteRootDirFiles  = TRUE;
                        RestorePreviousOs   = FALSE;
                        ClearBootFlag       = TRUE;
                        //SpDeleteAndBackupBootFiles(FALSE,TRUE,TRUE,FALSE,TRUE);
                    }else{
                        RestoreBackupFiles  = TRUE;
                        DeleteBackupFiles   = TRUE;
                        DeleteRootDirFiles  = TRUE;
                        RestorePreviousOs   = TRUE;
                        ClearBootFlag       = TRUE;
                        //SpDeleteAndBackupBootFiles(TRUE,TRUE,TRUE,TRUE,TRUE);
                    }
                } else {
                    RestoreBackupFiles  = TRUE;
                    DeleteBackupFiles   = TRUE;
                    DeleteRootDirFiles  = TRUE;
                    RestorePreviousOs   = TRUE;
                    ClearBootFlag       = FALSE;
                    //SpDeleteAndBackupBootFiles(TRUE,TRUE,TRUE,TRUE,FALSE);
                }

                //
                // In the case of, winnt32 from Win95 that have separated
                // system partition or winnt from DOS, Auto boot flag will
                // set system partition not booted partition..
                //
                if(IsFloppylessBoot){
                    ClearBootFlag = TRUE;
                }
            }

            SpDeleteAndBackupBootFiles(RestoreBackupFiles,
                                       DeleteBackupFiles,
                                       DeleteRootDirFiles,
                                       RestorePreviousOs,
                                       ClearBootFlag);
        }
    } //NEC98
#endif

    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_SHUTTING_DOWN,DEFAULT_STATUS_ATTRIBUTE);

    SpShutdownSystem();

    //
    // Shouldn't get here.
    //
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: shutdown returned!\n"));

    HalReturnToFirmware(HalRebootRoutine);
}



VOID
SpFatalSifError(
    IN PVOID SifHandle,
    IN PWSTR Section,
    IN PWSTR Key,           OPTIONAL
    IN ULONG Line,
    IN ULONG ValueNumber
    )

/*++

Routine Description:

    Inform the user that a required value is missing or corrupt in
    a sif file.  Display the section, line number or key, and value
    number.

    Then reboot the machine.

Arguments:

    SifHandle - specifies the information file which is corrupt.

    Section - supplies the name of the section that is corrupt.

    Key - if specified, specifies the line in the section that is
        missing or corrupt.

    Line - if Key is not specified, then this is the line number
        within the section that is corrupt.

    ValueNumber - supplies the value number on the line that is
        missing or corrupt.

Return Value:

    DOES NOT RETURN

--*/

{
    ULONG ValidKeys[2] = { KEY_F3,0 };

    //
    // Display a message indicating that there is a fatal
    // error in the sif file.
    //
    if(Key) {

        SpStartScreen(
            SP_SCRN_FATAL_SIF_ERROR_KEY,
            3,
            HEADER_HEIGHT+3,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            ValueNumber,
            Section,
            Key
            );

    } else {

        SpStartScreen(
            SP_SCRN_FATAL_SIF_ERROR_LINE,
            3,
            HEADER_HEIGHT+3,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            ValueNumber,
            Line,
            Section
            );
    }

    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);
    SpWaitValidKey(ValidKeys,NULL,NULL);

    SpDone(0,FALSE,TRUE);
}


VOID
SpNonFatalSifError(
    IN PVOID SifHandle,
    IN PWSTR Section,
    IN PWSTR Key,           OPTIONAL
    IN ULONG Line,
    IN ULONG ValueNumber,
    IN PWSTR FileName
    )

/*++

Routine Description:

    Inform the user that a required value is missing or corrupt in
    a sif file.  Display the section, line number or key, and value
    number, along with the file name that cannot be copied.

    Then ask the user if they want to skip the file or exit Setup.

Arguments:

    SifHandle - specifies the information file which is corrupt.

    Section - supplies the name of the section that is corrupt.

    Key - if specified, specifies the line in the section that is
        missing or corrupt.

    Line - if Key is not specified, then this is the line number
        within the section that is corrupt.

    ValueNumber - supplies the value number on the line that is
        missing or corrupt.

    FileName - supplies the name of the file that cannot be copied.

Return Value:

    none (may not return if user chooses to exit Setup)

--*/

{
    ULONG ValidKeys[3] = { ASCI_ESC, KEY_F3, 0 };

    //
    // Display a message indicating that there is a fatal
    // error in the sif file.
    //
    if(Key) {

        SpStartScreen(
            SP_SCRN_NONFATAL_SIF_ERROR_KEY,
            3,
            HEADER_HEIGHT+3,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            ValueNumber,
            Section,
            Key,
            FileName
            );

    } else {

        SpStartScreen(
            SP_SCRN_NONFATAL_SIF_ERROR_LINE,
            3,
            HEADER_HEIGHT+3,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            ValueNumber,
            Line,
            Section,
            FileName
            );
    }

    SpDisplayStatusOptions(
        DEFAULT_STATUS_ATTRIBUTE,
        SP_STAT_ESC_EQUALS_SKIP_FILE,
        SP_STAT_F3_EQUALS_EXIT,
        0
        );

    switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {

        case ASCI_ESC:      // skip file

            break;

        case KEY_F3:        // exit setup

            SpConfirmExit();
    }
}


VOID
SpConfirmExit(
    VOID
    )

/*++

Routine Description:

    Confirm with the user that he really wants to exit.
    If he does, then exit, otherwise return.

    When this routine returns, the caller must repaint the entire
    client area and status area of the screen.

Arguments:

    None.

Return Value:

    MAY NOT RETURN

--*/

{
    ULONG ValidKeys[3] = { ASCI_CR, KEY_F3, 0 };
    WCHAR *p = (WCHAR *)TemporaryBuffer;
    BOOLEAN FirstLine,FirstCharOnLine;


    //
    // Don't erase the screen.
    //
    // We have to do something very funky here because the resources
    // are originally in ANSI, which doesn't have the line-draw chars.
    //
    vSpFormatMessage(
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        SP_SCRN_EXIT_CONFIRMATION,
        NULL,
        NULL
        );

    for(FirstCharOnLine=TRUE,FirstLine=TRUE; *p; p++) {

        switch(*p) {

        case L'+':
            if(FirstCharOnLine) {

                *p = SplangGetLineDrawChar(
                        FirstLine ? LineCharDoubleUpperLeft : LineCharDoubleLowerLeft
                        );

                FirstCharOnLine = FALSE;
            } else {

                *p = SplangGetLineDrawChar(
                        FirstLine ? LineCharDoubleUpperRight : LineCharDoubleLowerRight
                        );
            }
            break;

        case L'=':
            FirstCharOnLine = FALSE;
            *p = SplangGetLineDrawChar(LineCharDoubleHorizontal);
            break;

        case L'-':
            FirstCharOnLine = FALSE;
            *p = SplangGetLineDrawChar(LineCharSingleHorizontal);
            break;

        case L'|':
            FirstCharOnLine = FALSE;
            *p = SplangGetLineDrawChar(LineCharDoubleVertical);
            break;

        case L'*':
            *p = SplangGetLineDrawChar(
                      FirstCharOnLine
                    ? LineCharDoubleVerticalToSingleHorizontalRight
                    : LineCharDoubleVerticalToSingleHorizontalLeft
                    );

            FirstCharOnLine = FALSE;
            break;

        case L'\n':
            FirstCharOnLine = TRUE;
            FirstLine = FALSE;
            break;

        default:
            FirstCharOnLine = FALSE;
            break;
        }
    }

    SpDisplayText(
        TemporaryBuffer,
        wcslen(TemporaryBuffer)+1,
        TRUE,
        TRUE,
        ATT_FG_RED | ATT_BG_WHITE,
        0,
        0
        );

    SpvidClearScreenRegion(
        0,
        VideoVars.ScreenHeight-STATUS_HEIGHT,
        VideoVars.ScreenWidth,
        STATUS_HEIGHT,
        DEFAULT_STATUS_BACKGROUND
        );

    if(SpWaitValidKey(ValidKeys,NULL,NULL) == KEY_F3) {
        SpDone(0,FALSE,TRUE);
    }

    //
    // User backed out of bailing, just return to caller.
    //
}


#endif

PWSTR
SpDupStringW(
    IN PCWSTR String
    )
{
    PWSTR p;

    p = SpMemAlloc((wcslen(String)+1) * sizeof(WCHAR));
    ASSERT(p);

    wcscpy(p,String);
    return(p);
}


PSTR
SpDupString(
    IN PCSTR String
    )
{
    PUCHAR p;

    p = SpMemAlloc(strlen(String)+1);
    ASSERT(p);

    strcpy(p,String);
    return(p);
}

PWSTR
SpToUnicode(
    IN PUCHAR OemString
    )
{
    ULONG OemStringSize;
    ULONG MaxUnicodeStringSize;
    ULONG ActualUnicodeStringSize;
    PWSTR UnicodeString;

    //
    // Determine the maximum number of bytes in the oem string
    // and allocate a buffer to hold a string of that size.
    // The maximum length of the equivalent unicode string
    // is twice that number (this occurs when all oem chars
    // in the string are single-byte).
    //
    OemStringSize = strlen(OemString) + 1;

    MaxUnicodeStringSize = OemStringSize * sizeof(WCHAR);

    UnicodeString = SpMemAlloc(MaxUnicodeStringSize);
    ASSERT(UnicodeString);

    //
    // Call the conversion routine.
    //
    RtlOemToUnicodeN(
        UnicodeString,
        MaxUnicodeStringSize,
        &ActualUnicodeStringSize,
        OemString,
        OemStringSize
        );

    //
    // Reallocate the unicode string to its real size,
    // which depends on the number of doublebyte characters
    // OemString contained.
    //
    if(ActualUnicodeStringSize != MaxUnicodeStringSize) {

        UnicodeString = SpMemRealloc(UnicodeString,ActualUnicodeStringSize);
        ASSERT(UnicodeString);
    }

    return(UnicodeString);
}

PUCHAR
SpToOem(
    IN PWSTR UnicodeString
    )
{
    ULONG UnicodeStringSize;
    ULONG MaxOemStringSize;
    ULONG ActualOemStringSize;
    PUCHAR OemString;

    //
    // Allocate a buffer of maximum size to hold the oem string.
    // The maximum size would occur if all characters in the
    // unicode string being converted have doublebyte OEM equivalents.
    //
    UnicodeStringSize = (wcslen(UnicodeString)+1) * sizeof(WCHAR);

    MaxOemStringSize = UnicodeStringSize;

    OemString = SpMemAlloc(MaxOemStringSize);
    ASSERT(OemString);

    //
    // Call the conversion routine.
    //
    RtlUnicodeToOemN(
        OemString,
        MaxOemStringSize,
        &ActualOemStringSize,
        UnicodeString,
        UnicodeStringSize
        );

    //
    // Reallocate the oem string to reflect its true size,
    // which depends on the number of doublebyte characters it contains.
    //
    if(ActualOemStringSize != MaxOemStringSize) {
        OemString = SpMemRealloc(OemString,ActualOemStringSize);
        ASSERT(OemString);
    }

    return(OemString);
}


VOID
SpConcatenatePaths(
    IN OUT PWSTR  Path1,        OPTIONAL
    IN     PCWSTR Path2         OPTIONAL
    )
{
    UNICODE_STRING Path1_Ustr;
    UNICODE_STRING Path2_Ustr;

    if (!Path1) {
        return;
    }

    RtlInitUnicodeString(&Path1_Ustr, Path1);
    Path1_Ustr.MaximumLength = 10000; // arbitrarily large
    RtlInitUnicodeString(&Path2_Ustr, Path2);

    SpConcatenatePaths_Ustr(&Path1_Ustr, &Path2_Ustr);

    RTL_STRING_NUL_TERMINATE(&Path1_Ustr);
}

NTSTATUS
SpConcatenatePaths_Ustr(
    IN OUT PUNICODE_STRING Path1_Ustr,
    IN     PCUNICODE_STRING Path2_Ustr
    )
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;
    UNICODE_STRING Path2_Ustr_mutable;
    const static UNICODE_STRING EmptyString = RTL_CONSTANT_STRING(L"");
    BOOLEAN AppendPath2 = FALSE;
    SIZE_T NewLength = 0;

    if (Path1_Ustr == NULL) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }
    if (Path1_Ustr->Buffer == NULL) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    //
    // remove one trailing backslash from path1, remove one leading backslash from path2,
    // append one trailing backlash to path1, and append path2 to path1.
    //
    if (Path1_Ustr->Length != 0 && RTL_STRING_GET_LAST_CHAR(Path1_Ustr) == L'\\') {
        Path1_Ustr->Length -= sizeof(Path1_Ustr->Buffer[0]);
        Path1_Ustr->MaximumLength -= sizeof(Path1_Ustr->Buffer[0]);
    }

    if (Path2_Ustr != NULL && Path2_Ustr->Buffer != NULL && Path2_Ustr->Length != 0) {
        Path2_Ustr_mutable = *Path2_Ustr;
        if (Path2_Ustr_mutable.Buffer[0] == L'\\') {
            Path2_Ustr_mutable.Buffer += 1;
            Path2_Ustr_mutable.Length -= sizeof(Path2_Ustr_mutable.Buffer[0]);
            Path2_Ustr_mutable.MaximumLength -= sizeof(Path2_Ustr_mutable.Buffer[0]);
        }
        AppendPath2 = TRUE;
    } else {
        AppendPath2 = FALSE;
    }

    //
    // Append a backslash, then Path2 if it was specified
    //
    NewLength = Path1_Ustr->Length + sizeof(WCHAR);
    if (NewLength > Path1_Ustr->MaximumLength) {
        Status = STATUS_NAME_TOO_LONG;
        goto Exit;
    }
    Path1_Ustr->Buffer[RTL_STRING_GET_LENGTH_CHARS(Path1_Ustr)] = L'\\';
    Path1_Ustr->Length = (RTL_STRING_LENGTH_TYPE)NewLength;

    if (AppendPath2) {
        NewLength = (Path1_Ustr->Length + Path2_Ustr_mutable.Length);
        if (NewLength > Path1_Ustr->MaximumLength) {
            Status = STATUS_NAME_TOO_LONG;
            goto Exit;
        }
        RtlMoveMemory(
            Path1_Ustr->Buffer + RTL_STRING_GET_LENGTH_CHARS(Path1_Ustr),
            Path2_Ustr_mutable.Buffer,
            Path2_Ustr_mutable.Length
            );
        Path1_Ustr->Length = (RTL_STRING_LENGTH_TYPE)NewLength;
    }
    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

#if !defined(SETUP_CAB_TEST_USERMODE)

VOID
SpFetchDiskSpaceRequirements(
    IN  PVOID  SifHandle,
    IN  ULONG  BytesPerCluster,
    OUT PULONG FreeKBRequired,          OPTIONAL
    OUT PULONG FreeKBRequiredSysPart    OPTIONAL
    )
{
    PWSTR p;


    if(FreeKBRequired) {
    WCHAR   ClusterSizeString[64];

        if( BytesPerCluster <= 512 ) {
            //
            // We got some miniscule cluster size.  Assume 512 byte.
            //
            wcscpy( ClusterSizeString, L"WinDirSpace512" );
        } else if( BytesPerCluster > (256 * 1024) ) {
            //
            // We got some huge cluster size.  Must be garbage, assume 32K byte.
            //
            wcscpy( ClusterSizeString, L"WinDirSpace32K" );
        } else {
            swprintf( ClusterSizeString, L"WinDirSpace%uK", BytesPerCluster/1024 );
        }

        p = SpGetSectionKeyIndex( SifHandle,
                                  SIF_DISKSPACEREQUIREMENTS,
                                  ClusterSizeString,
                                  0 );

        if(!p) {
            SpFatalSifError( SifHandle,
                             SIF_DISKSPACEREQUIREMENTS,
                             ClusterSizeString,
                             0,
                             0 );
        }

        *FreeKBRequired = (ULONG)SpStringToLong(p,NULL,10);
    }

    if(FreeKBRequiredSysPart) {

        p = SpGetSectionKeyIndex( SifHandle,
                                  SIF_DISKSPACEREQUIREMENTS,
                                  SIF_FREESYSPARTDISKSPACE,
                                  0 );

        if(!p) {
            SpFatalSifError( SifHandle,
                             SIF_DISKSPACEREQUIREMENTS,
                             SIF_FREESYSPARTDISKSPACE,
                             0,
                             0 );
        }

        *FreeKBRequiredSysPart = (ULONG)SpStringToLong(p,NULL,10);
    }
}

VOID
SpFetchTempDiskSpaceRequirements(
    IN  PVOID  SifHandle,
    IN  ULONG  BytesPerCluster,
    OUT PULONG LocalSourceKBRequired,   OPTIONAL
    OUT PULONG BootKBRequired           OPTIONAL
    )
{
    PWSTR p;
    WCHAR   ClusterSizeString[64];

    if( BytesPerCluster <= 512 ) {
        //
        // We got some miniscule cluster size.  Assume 512 byte.
        //
        wcscpy( ClusterSizeString, L"TempDirSpace512" );
    } else if( BytesPerCluster > (256 * 1024) ) {
        //
        // We got some huge cluster size.  Must be garbage, assume 32K byte.
        //
        wcscpy( ClusterSizeString, L"TempDirSpace32K" );
    } else {
        swprintf( ClusterSizeString, L"TempDirSpace%uK", BytesPerCluster/1024 );
    }

    if(LocalSourceKBRequired) {
        p = SpGetSectionKeyIndex( SifHandle,
                                  SIF_DISKSPACEREQUIREMENTS,
                                  ClusterSizeString,
                                  0 );

        if(!p) {
            SpFatalSifError( SifHandle,
                             SIF_DISKSPACEREQUIREMENTS,
                             ClusterSizeString,
                             0,
                             0 );
        }

        *LocalSourceKBRequired = ((ULONG)SpStringToLong(p,NULL,10) + 1023) / 1024;  // round up
    }

    if(BootKBRequired) {

        p = SpGetSectionKeyIndex( SifHandle,
                                  SIF_DISKSPACEREQUIREMENTS,
                                  ClusterSizeString,
                                  1 );

        if(!p) {
            SpFatalSifError( SifHandle,
                             SIF_DISKSPACEREQUIREMENTS,
                             ClusterSizeString,
                             0,
                             1 );
        }

        *BootKBRequired = ((ULONG)SpStringToLong(p,NULL,10) + 1023) / 1024;  // round up
    }
}

PDISK_REGION
SpRegionFromArcName(
    IN PWSTR                ArcName,
    IN PartitionOrdinalType OrdinalType,
    IN PDISK_REGION         PreviousMatch
    )
/*++

Routine Description:

    Given an ARC name find the region descriptor which describes the drive
    this ARC name is on.

Arguments:

    ArcName - supplies the arc name.

    OrdinalType - primary (multi) or secondary (scsi) type.

    PreviousMatch - specifies where we should begin looking.

Return Value:

    Region descriptor if one found, otherwise NULL.

--*/
{
    PDISK_REGION Region = NULL;
    PWSTR   NormalizedArcPath = NULL;
    ULONG   disk;
    PWSTR   ArcPath1,ArcPath2;
    BOOLEAN StartLooking = FALSE;
    #define BufferSize 2048

    ArcPath1 = SpMemAlloc(BufferSize);
    ArcPath2 = SpMemAlloc(BufferSize);

    if( ArcName && *ArcName ) {
        NormalizedArcPath = SpNormalizeArcPath( ArcName );
        if( NormalizedArcPath ) {

            if(!PreviousMatch) {    // then we start from the beginning
                StartLooking = TRUE;
            }

            for( disk=0; disk<HardDiskCount; disk++ ) {
                Region = PartitionedDisks[disk].PrimaryDiskRegions;
                while( Region ) {
                    if((!StartLooking) && (Region == PreviousMatch)) {
                        StartLooking = TRUE;
                    } else if(Region->PartitionedSpace && StartLooking) {
                        SpArcNameFromRegion(Region,ArcPath1,BufferSize,OrdinalType,PrimaryArcPath);
                        SpArcNameFromRegion(Region,ArcPath2,BufferSize,OrdinalType,SecondaryArcPath);
                        if(!_wcsicmp(ArcPath1, NormalizedArcPath)
                        || !_wcsicmp(ArcPath2, NormalizedArcPath)) {
                            break;
                        }
                    }
                    Region = Region->Next;
                }
                if ( Region ) {
                    break;
                }

                Region = PartitionedDisks[disk].ExtendedDiskRegions;
                while( Region ) {
                    if((!StartLooking) && (Region == PreviousMatch)) {
                        StartLooking = TRUE;
                    } else if(Region->PartitionedSpace && StartLooking) {
                        SpArcNameFromRegion(Region,ArcPath1,BufferSize,OrdinalType,PrimaryArcPath);
                        SpArcNameFromRegion(Region,ArcPath2,BufferSize,OrdinalType,SecondaryArcPath);
                        if(!_wcsicmp(ArcPath1, NormalizedArcPath)
                        || !_wcsicmp(ArcPath2, NormalizedArcPath)) {
                            break;
                        }
                    }
                    Region = Region->Next;
                }
                if ( Region ) {
                    break;
                }

            }

#if defined(REMOTE_BOOT)
            if ( (Region == NULL) && RemoteBootSetup && !RemoteInstallSetup &&
                 (PreviousMatch == NULL) ) {
                if (_wcsicmp(L"net(0)", NormalizedArcPath) == 0) {
                    Region = RemoteBootTargetRegion;
                }
            }
#endif // defined(REMOTE_BOOT)

        }
        if( NormalizedArcPath ) {
            SpMemFree( NormalizedArcPath );
        }
    }

    SpMemFree(ArcPath1);
    SpMemFree(ArcPath2);

    return( Region );
}

PDISK_REGION
SpRegionFromNtName(
    IN PWSTR                NtName,
    IN PartitionOrdinalType OrdinalType
    )
/*++

Routine Description:

    Given an Nt name find the region descriptor which describes the drive
    this NT name is on.

Arguments:

    NtName - supplies the Nt name of the desired region.

    PartitionOrdinalType - Specifies the ordinal type of the partition.

Return Value:

    Region descriptor if one found, otherwise NULL.

--*/
{
    PDISK_REGION Region = NULL;
    PWSTR p;

    //
    // Convert to arc path.
    //

    if (p = SpNtToArc(NtName, PrimaryArcPath)) {
        Region = SpRegionFromArcName(p, PartitionOrdinalCurrent, NULL);
        SpMemFree(p);
    }
    return(Region);
}

PDISK_REGION
SpRegionFromDosName(
    IN PCWSTR DosName
    )
/*++

Routine Description:

    Given a DOS name find the region descriptor which describes the drive
    this ARC name is on.

Arguments:

    ArcName - supplies the arc name.

Return Value:

    Region descriptor if one found, otherwise NULL.

--*/

{
    PDISK_REGION Region = NULL;
    ULONG        disk;
    WCHAR        DriveLetter;

    if( DosName && *DosName && *(DosName + 1) == L':' ) {
        DriveLetter = SpToUpper(*DosName);

#if defined(REMOTE_BOOT)
        if ( RemoteBootSetup && !RemoteInstallSetup && (DriveLetter == L'C') ) {
            return RemoteBootTargetRegion;
        }
#endif // defined(REMOTE_BOOT)

        for( disk=0; disk<HardDiskCount; disk++ ) {
            Region = PartitionedDisks[disk].PrimaryDiskRegions;
            while( Region ) {
                if(Region->PartitionedSpace && (Region->DriveLetter == DriveLetter)) {
                    break;
                }
                Region = Region->Next;
            }
            if ( Region ) {
                break;
            }

            Region = PartitionedDisks[disk].ExtendedDiskRegions;
            while( Region ) {
                if(Region->PartitionedSpace && (Region->DriveLetter == DriveLetter)) {
                    break;
                }
                Region = Region->Next;
            }
            if ( Region ) {
                break;
            }
        }
    }
    return( Region );
}


PDISK_REGION
SpRegionFromArcOrDosName(
    IN PWSTR                Name,
    IN PartitionOrdinalType OrdinalType,
    IN PDISK_REGION         PreviousMatch
    )
{
    PDISK_REGION Region;

    //
    // Determine if Name represents an ARC name or a DOS name and use
    // the appropriate routine to extract the region for this name.  Check
    // for the ":" character at position 2 to see if it is a DOS name.
    // If not a DOS name then assume it is an ARC name.
    //
    if(Name) {
        if(Name[0] && (Name[1] == ':')) {
            if(PreviousMatch) {
                Region = NULL;
            } else {
                Region = SpRegionFromDosName(Name);
            }
        } else {
            Region = SpRegionFromArcName(Name, OrdinalType, PreviousMatch);
        }
    } else {
        Region = NULL;
    }

    return(Region);
}


VOID
SpNtNameFromRegion(
    IN  PDISK_REGION          Region,
    OUT PWSTR                 NtPath,
    IN  ULONG                 BufferSizeBytes,
    IN  PartitionOrdinalType  OrdinalType
    )

/*++

Routine Description:

    Generate a name in the NT name space for a region.  This name can be
    in one of three forms.  For partitions, the name is always of the form

        \device\harddisk<n>\partition<m>.

    If the region is actually a DoubleSpace drive, then the name is of the form

    \device\harddisk<n>\partition<m>.<xxx> where <xxx> is the filename of
    the CVF (ie, something like dblspace.001).

    If the region is on a redirected drive, the name is of the form

        \device\lanmanredirector\<server>\<share>

Arguments:

    Region - supplies a pointer to the region descriptor for the region
        whose path is desired.

    NtPath - receives the path.

    BufferSizeBytes - specifies the size of the buffer pointed to by NtPath.
        The name will be truncated to fit in the buffer if necessary.

    OrdinalType - indicates which partition ordinal (original, on disk,
        current) to use when generating the name.

Return Value:

    None.

--*/

{
    ULONG MaxNameChars;
    ULONG NeededChars;
    WCHAR PartitionComponent[50];
    INT   iResult = 0;

#if defined(REMOTE_BOOT)
    //
    //  Handle remote boot case where target is over the network.
    //

    if (Region->DiskNumber == 0xffffffff) {
        wcscpy(NtPath,Region->TypeName);
        return;
    }
#endif // defined(REMOTE_BOOT)

    //
    // Calculate the maximum size of the name if unicode characters.
    // Leave room for a terminating nul.
    //
    MaxNameChars = (BufferSizeBytes / sizeof(WCHAR)) - 1;

    //
    // Generate the partition component of the name.
    // Note that the first letter of PartitionComponent must be upper case.
    //
    if(_snwprintf(PartitionComponent, 
                  (sizeof(PartitionComponent)/sizeof(WCHAR)) - 1, 
                  L"\\Partition%u", 
                  SpPtGetOrdinal(Region,OrdinalType)) < 0){
        ASSERT(FALSE);
        PartitionComponent[(sizeof(PartitionComponent)/sizeof(WCHAR)) - 1] = '\0';
    }

    //
    // Calculate the amount of buffer space needed for the path.
    //
    NeededChars = wcslen(HardDisks[Region->DiskNumber].DevicePath)
                + wcslen(PartitionComponent);

    if(Region->Filesystem == FilesystemDoubleSpace) {
        //
        // Add the size taken up by the double space cvf name.
        // This is the length of the name, plus one character
        // for the dot.
        //
        NeededChars += 8+1+3+1;  // Maximum size of a CVF file name
    }

    //
    // Even though we do something reasonable in this case,
    // really it should never happen.  If the name is truncated,
    // it won't be of any use anyway.
    //
    ASSERT(NeededChars <= MaxNameChars);

    //
    // Generate the name.
    //
    if(Region->Filesystem == FilesystemDoubleSpace) {
        iResult = _snwprintf(NtPath, 
                             MaxNameChars, 
                             L"%ws%ws.%ws.%03d", 
                             HardDisks[Region->DiskNumber].DevicePath, 
                             PartitionComponent, 
                             L"DBLSPACE", 
                             Region->SeqNumber);
    }
    else{
        iResult = _snwprintf(NtPath, 
                             MaxNameChars, 
                             L"%ws%ws", 
                             HardDisks[Region->DiskNumber].DevicePath, 
                             PartitionComponent);
    }

    if(iResult < 0){
        ASSERT(FALSE);
        NtPath[MaxNameChars] = '\0';
    }
}


VOID
SpArcNameFromRegion(
    IN  PDISK_REGION         Region,
    OUT PWSTR                ArcPath,
    IN  ULONG                BufferSizeBytes,
    IN  PartitionOrdinalType OrdinalType,
    IN  ENUMARCPATHTYPE      ArcPathType
    )

/*++

Routine Description:

    Generate a name in the ARC name space for a region.

Arguments:

    Region - supplies a pointer to the region descriptor for the region
        whose path is desired.

    ArcPath - receives the path.

    BufferSizeBytes - specifies the size of the buffer pointed to by ArcPath.
        The name will be truncated to fit in the buffer if necessary.

    OrdinalType - indicates which partition ordinal (original, on disk,
        current) to use when generating the name.

    ArcPathType - Look for the primary or secondary arc path depending on this value.
                  This is meaningful for disks on amd64/x86 that are scsi but visible
                  through the bios.  The multi() style name is the 'primary' arc
                  path; the scsi() style name is the 'secondary' one.

Return Value:

    None.

--*/

{
    PWSTR p;

    //
    // Get the nt name.
    //
    SpNtNameFromRegion(Region,ArcPath,BufferSizeBytes,OrdinalType);

    //
    // Convert to arc path.
    //
    if(p = SpNtToArc(ArcPath,ArcPathType)) {
        wcsncpy(ArcPath,p,(BufferSizeBytes/sizeof(WCHAR))-1);
        SpMemFree(p);
        ArcPath[(BufferSizeBytes/sizeof(WCHAR))-1] = 0;
    } else {
        *ArcPath = 0;
    }
}


BOOLEAN
SpNtNameFromDosPath (
    IN      PCWSTR DosPath,
    OUT     PWSTR NtPath,
    IN      UINT NtPathSizeInBytes,
    IN      PartitionOrdinalType OrdinalType
    )

/*++

Routine Description:

  SpNtNameFromDosPath converts a DOS path (in x:\foo\bar format) into an NT
  name (such as \devices\harddisk0\parition1\foo\bar).

Arguments:

  DosPath - Specifies the DOS path to convert

  NtPath - Receives the NT object

  NtPathSizeInBytes - Specifies the size of NtPath

  OrdinalType - indicates which partition ordinal (original, on disk, current)
                to use when generating the name.

Return Value:

  TRUE if the path was converted, FALSE otherwise.

--*/

{
    PDISK_REGION region;

    //
    // Get region on disk for the DOS path
    //

    region = SpRegionFromDosName (DosPath);

    if (!region) {
        KdPrintEx ((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: SpNtPathFromDosPath failed to get region for %ws\n",
            DosPath
            ));

        return FALSE;
    }

    //
    // Convert region struct into an NT path.
    //

    SpNtNameFromRegion(
        region,
        NtPath,
        NtPathSizeInBytes - (wcslen (&DosPath[2]) * sizeof (WCHAR)),
        OrdinalType
        );

    SpConcatenatePaths (NtPath, &DosPath[2]);
    return TRUE;
}



BOOLEAN
SpPromptForDisk(
    IN      PWSTR    DiskDescription,
    IN OUT  PWSTR    DiskDevicePath,
    IN      PWSTR    DiskTagFile,
    IN      BOOLEAN  IgnoreDiskInDrive,
    IN      BOOLEAN  AllowEscape,
    IN      BOOLEAN  WarnMultiplePrompts,
    OUT     PBOOLEAN pRedrawFlag
    )

/*++

Routine Description:

    Prompt the user to insert a floppy disk or CD-ROM.

Arguments:

    DiskDescription - supplies a descriptive name for the disk.

    DiskDevicePath - supplies the device path for the device on
        which we want the user to insert the disk.  This should
        be a real nt device object, as opposed to a symbolic link
        (ie, use \device\floppy0, not \dosdevices\a:).

        NOTE: This path will be modified only in case of prompting
        for a CD-ROM 0 and the required disk existed on another
        CD-ROM like CD-ROM 2.


    DiskTagFile - supplies the full path (relative to the root)
        of a file whose presence on the disk indicates the presence
        of the disk we are prompting for.

    IgnoreDiskInDrive - if TRUE, the Setup will always issue at least
        one prompt.  If FALSE, Setup checks the disk in the drive
        and thus may issue 0 prompts.

    AllowEscape - if TRUE, the user can press escape to indicate
        that he wishes to cancel the operation. (This is meaningful
        only to the caller).

    WarnMultiplePrompts - if TRUE and DiskDevicePath desribes a
        floppy disk drive, then put up a little note when displaying the
        disk prompt, that we may prompt for some disks more than once.
        Users get confused when we ask them to insert disks that they
        already inserted once before.

    pRedrawFlag - if non-NULL, receives a flag indicating whether the
        screen was messed up with a disk prompt, requiring a redraw.

Return Value:

    TRUE if the requested disk is in the drive.  FALSE otherwise.
    FALSE can only be returned if AllowEscape is TRUE.

--*/

{
    WCHAR               OpenPath[MAX_PATH];
    NTSTATUS            Status;
    UNICODE_STRING      UnicodeString;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    HANDLE              Handle;
    BOOLEAN             Done = FALSE;
    BOOLEAN             rc;
    WCHAR               DriveLetter;
    ULONG               PromptId;
    ULONG               ValidKeys[4] = { KEY_F3, ASCI_CR, 0, 0 };
    BOOLEAN             TryOpen;

    //
    // Initially, assume no redraw required
    //
    if(pRedrawFlag) {
        *pRedrawFlag = FALSE;
    }

    //
    // Need to get device characteristics to see whether
    // the device is a cd, fixed disk or removable disk/floppy.
    //
    SpStringToLower(DiskDevicePath);

    if( !_wcsnicmp(DiskDevicePath,L"\\device\\cdrom",13)) {
        PromptId = SP_SCRN_CDROM_PROMPT;
        WarnMultiplePrompts = FALSE;
    } else if( !_wcsnicmp(DiskDevicePath,L"\\device\\floppy",14)) {
        PromptId = SP_SCRN_FLOPPY_PROMPT;
        DriveLetter = (WCHAR)SpStringToLong(wcsstr(DiskDevicePath,L"floppy")+6,NULL,10) + L'A';
    } else {
        //
        // Assume hard disk
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpPromptforDisk assuming %ws is hard disk, returning TRUE\n",DiskDevicePath));

        return(TRUE);
    }

    //
    // Form the complete NT pathname of the tagfile.
    //
    wcscpy(OpenPath,DiskDevicePath);
    SpConcatenatePaths(OpenPath,DiskTagFile);

    //
    // Initialize object attributes.
    //
    INIT_OBJA(&ObjectAttributes,&UnicodeString,OpenPath);


    //
    // If we're looking for a cdrom0, and there are multiple CDROM
    // drives in the machine, skip prompting the user the first time
    // and look for our tag on all the CD drives first.
    //
    if( (PromptId == SP_SCRN_CDROM_PROMPT) &&
        (IoGetConfigurationInformation()->CdRomCount > 1) &&
        (wcsstr( OpenPath, L"cdrom0" ))) {
        IgnoreDiskInDrive = FALSE;
    }

    do {
        //
        // Put up the prompt.
        //
        TryOpen = TRUE;

        if(IgnoreDiskInDrive) {
            //
            // We going to put up a prompt screen, so a redraw will be required
            //
            if(pRedrawFlag) {
                *pRedrawFlag = TRUE;
            }

            SpStartScreen(PromptId,0,0,TRUE,TRUE,DEFAULT_ATTRIBUTE,DiskDescription,DriveLetter);

            //
            // Display status options: exit, enter, and escape if specified.
            //
            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_F3_EQUALS_EXIT,
                SP_STAT_ENTER_EQUALS_CONTINUE,
                AllowEscape ? SP_STAT_ESC_EQUALS_CANCEL : 0,
                0
                );

            if(AllowEscape) {
                ValidKeys[2] = ASCI_ESC;
            }

            switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {
            case ASCI_ESC:
                rc = FALSE;
                Done = TRUE;
                TryOpen = FALSE;
                break;
            case KEY_F3:
                TryOpen = FALSE;
                SpConfirmExit();
                break;
            case ASCI_CR:
                break;
            }
        }

        //
        // Attempt to open the tagfile.
        //
        if(TryOpen) {
            //
            //  If this function was called during repair, do not clear the scree.
            //  This condition is necessary so that the screen will not
            //  blink when setup is repairing multiple files without asking the
            //  user to confirm each file.
            //
            if( !RepairWinnt ) {
                CLEAR_CLIENT_SCREEN();
            }

            SpDisplayStatusText(SP_STAT_PLEASE_WAIT,DEFAULT_STATUS_ATTRIBUTE);

            //
            // If we're looking for a cdrom0, and there are multiple CDROM
            // drives in the machine, check all of them.
            //
            if( (PromptId == SP_SCRN_CDROM_PROMPT) &&
                (IoGetConfigurationInformation()->CdRomCount > 1) &&
                (wcsstr( OpenPath, L"cdrom0" ))) {

                WCHAR  CdRomDevicePath[MAX_PATH];
                ULONG  i;

                //
                // We're looking for a CD.  We've assumed we're looking for
                // Cdrom0, but there are more than one on the system.
                //
                for( i = 0; i < IoGetConfigurationInformation()->CdRomCount; i++ ) {
                    //
                    // Modify our path, taking into account our new device.  Let's
                    // leave OpenPath alone.  Just in case we fail, we won't have to
                    // re-initialize him.
                    //
                    swprintf(CdRomDevicePath, L"\\device\\cdrom%u", i);

                    if(DiskTagFile)
                        SpConcatenatePaths(CdRomDevicePath, DiskTagFile);

                    //
                    // Initialize object attributes.
                    //
                    INIT_OBJA(&ObjectAttributes,&UnicodeString,CdRomDevicePath);

                    Status = ZwCreateFile(
                                &Handle,
                                FILE_GENERIC_READ,
                                &ObjectAttributes,
                                &IoStatusBlock,
                                NULL,
                                FILE_ATTRIBUTE_NORMAL,
                                FILE_SHARE_READ,
                                FILE_OPEN,
                                0,
                                NULL,
                                0
                                );

                    if(NT_SUCCESS(Status)) {
                        if( i > 0 ) {
                            //
                            // We found the tagfile on a different device than
                            // than where we were supposed to look.  Modify the
                            // DiskDevicePath.
                            //
                            swprintf(DiskDevicePath, L"\\device\\cdrom%u", i);

                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:SpPromptForDisk: %ws has the requested %ws file.\n",
                                        DiskDevicePath, DiskTagFile));
                        }

                        ZwClose(Handle);

                        return( TRUE );
                    }
                }

                //
                // If we missed, we can fall through without any harm and use
                // the prompt/error code below.  But first, cover our tracks.
                //
                INIT_OBJA(&ObjectAttributes, &UnicodeString, OpenPath);
            }


            Status = ZwCreateFile(
                        &Handle,
                        FILE_GENERIC_READ,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        NULL,
                        FILE_ATTRIBUTE_NORMAL,
                        FILE_SHARE_READ,
                        FILE_OPEN,
                        0,
                        NULL,
                        0
                        );

            //
            // If we got back success, then we're done.
            //
            if(NT_SUCCESS(Status)) {

                ZwClose(Handle);
                Done = TRUE;
                rc = TRUE;

            } else {

                //
                // Handle CD-ROM error code indicating that there is no media
                // in the drive.
                //
                if((Status == STATUS_DEVICE_NOT_READY) && (PromptId == SP_SCRN_CDROM_PROMPT)) {
                    Status = STATUS_NO_MEDIA_IN_DEVICE;
                }

                //
                // If we got back something other than file not found, path not found,
                // or no media in drive, tell the user that the disk may be damaged.
                //
                if((Status != STATUS_NO_MEDIA_IN_DEVICE)
                && (Status != STATUS_OBJECT_NAME_NOT_FOUND)
                && (Status != STATUS_OBJECT_PATH_NOT_FOUND)
                && (Status != STATUS_NO_SUCH_FILE))
                {
                    SpDisplayScreen(SP_SCRN_DISK_DAMAGED,3,HEADER_HEIGHT+1);
                    SpDisplayStatusText(SP_STAT_ENTER_EQUALS_CONTINUE,DEFAULT_STATUS_ATTRIBUTE);
                    SpInputDrain();
                    while(SpInputGetKeypress() != ASCI_CR) ;
                }
            }
        }

        //
        // Set this value to true to force us to put up the prompt.
        //
        IgnoreDiskInDrive = TRUE;

    } while(!Done);

    return(rc);
}


VOID
SpGetSourceMediaInfo(
    IN  PVOID  SifHandle,
    IN  PWSTR  MediaShortName,
    OUT PWSTR *Description,     OPTIONAL
    OUT PWSTR *Tagfile,         OPTIONAL
    OUT PWSTR *Directory        OPTIONAL
    )
{
    PWSTR description,tagfile,directory;
    PWSTR SectionName;

    //
    // Look in the platform-specific section first.
    //
    SectionName = SpMakePlatformSpecificSectionName(SIF_SETUPMEDIA);

    if(SectionName && !SpGetSectionKeyExists(SifHandle,SectionName,MediaShortName)) {
        SpMemFree(SectionName);
        SectionName = SIF_SETUPMEDIA;
    }

    if(Description) {
        description = SpGetSectionKeyIndex(
                            SifHandle,
                            SectionName,
                            MediaShortName,
                            0
                            );

        if(description) {
            *Description = description;
        } else {
            SpFatalSifError(SifHandle,SectionName,MediaShortName,0,0);
        }
    }

    if(Tagfile) {
        tagfile = SpGetSectionKeyIndex(
                        SifHandle,
                        SectionName,
                        MediaShortName,
                        1
                        );

        if(tagfile) {
            *Tagfile = tagfile;
        } else {
            SpFatalSifError(SifHandle,SectionName,MediaShortName,0,1);
        }
    }

    if(Directory) {


        if (NoLs && !_wcsicmp (MediaShortName, L"1")) {

            directory = L"";

        }
        else {

            directory = SpGetSectionKeyIndex(
                            SifHandle,
                            SectionName,
                            MediaShortName,
                            3
                            );

        }

        if(directory) {
            *Directory = directory;
        } else {
            SpFatalSifError(SifHandle,SectionName,MediaShortName,0,3);
        }
    }

    if(SectionName != SIF_SETUPMEDIA) {
        SpMemFree(SectionName);
    }
}


BOOLEAN
SpPromptForSetupMedia(
    IN  PVOID  SifHandle,
    IN  PWSTR  MediaShortname,
    IN  PWSTR  DiskDevicePath
    )
{
    PWSTR Tagfile,Description;
    BOOLEAN RedrawNeeded;

    SpGetSourceMediaInfo(SifHandle,MediaShortname,&Description,&Tagfile,NULL);

    //
    // Prompt for the disk, based on the setup media type.
    //
    SpPromptForDisk(
        Description,
        DiskDevicePath,
        Tagfile,
        FALSE,          // don't ignore disk in drive
        FALSE,          // don't allow escape
        TRUE,           // warn about multiple prompts for same disk
        &RedrawNeeded
        );

    return(RedrawNeeded);
}



ULONG
SpFindStringInTable(
    IN PWSTR *StringTable,
    IN PWSTR  StringToFind
    )
{
    ULONG i;

    for(i=0; StringTable[i]; i++) {
        if(!_wcsicmp(StringTable[i],StringToFind)) {
            break;
        }
    }
    return(i);
}


PWSTR
SpGenerateCompressedName(
    IN PWSTR Filename
    )

/*++

Routine Description:

    Given a filename, generate the compressed form of the name.
    The compressed form is generated as follows:

    Look backwards for a dot.  If there is no dot, append "._" to the name.
    If there is a dot followed by 0, 1, or 2 charcaters, append "_".
    Otherwise assume there is a 3-character extension and replace the
    third character after the dot with "_".

Arguments:

    Filename - supplies filename whose compressed form is desired.

Return Value:

    Pointer to buffer containing nul-terminated compressed-form filename.
    The caller must free this buffer via SpFree().

--*/

{
   PWSTR CompressedName,p,q;

   //
   // The maximum length of the compressed filename is the length of the
   // original name plus 2 (for ._).
   //
   CompressedName = SpMemAlloc((wcslen(Filename)+3)*sizeof(WCHAR));
   wcscpy(CompressedName,Filename);

   p = wcsrchr(CompressedName,L'.');
   q = wcsrchr(CompressedName,L'\\');
   if(q < p) {

        //
        // If there are 0, 1, or 2 characters after the dot, just append
        // the underscore.  p points to the dot so include that in the length.
        //
        if(wcslen(p) < 4) {
            wcscat(CompressedName,L"_");
        } else {

            //
            // Assume there are 3 characters in the extension.  So replace
            // the final one with an underscore.
            //

            p[3] = L'_';
        }

    } else {

        //
        // No dot, just add ._.
        //

        wcscat(CompressedName,L"._");
    }

    return(CompressedName);
}

BOOLEAN
SpNonCriticalError(
    IN PVOID SifHandle,
    IN ULONG MsgId,
    IN PWSTR p1, OPTIONAL
    IN PWSTR p2  OPTIONAL
    )
/*++

Routine Description:

    This routine lets Setup display a non critical error to the user
    and ask the user whether he wants to retry the operation, skip the
    operation or exit Setup.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    MsgId     - message to display

    p1 - optional replacement string

    p2 - optional replacement string

Return Value:

    TRUE if user wants to retry the operation, FALSE otherwise.  Exit
    Setup won't return from this routine

--*/

{
    ULONG ValidKeys[4] = { ASCI_CR, ASCI_ESC, KEY_F3, 0 };

    CLEAR_CLIENT_SCREEN();
    while(1) {
        if(p1!=NULL && p2!=NULL ) {
            SpStartScreen(
                MsgId,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                p1,
                p2
                );

        }
        else if (p1!=NULL) {
            SpStartScreen(
                MsgId,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                p1
                );

        }
        else{
            SpStartScreen(
                MsgId,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE
                );

        }

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_RETRY,
            SP_STAT_ESC_EQUALS_SKIP_OPERATION,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {

        case ASCI_CR:       // retry

            return(TRUE);

        case ASCI_ESC:      // skip operation

            return(FALSE);

        case KEY_F3:        // exit setup

            SpConfirmExit();
            break;
        }
    }
}



BOOLEAN
SpNonCriticalErrorWithContinue (
    IN ULONG MsgId,
    IN PWSTR p1, OPTIONAL
    IN PWSTR p2  OPTIONAL
    )
/*++

Routine Description:

    This routine lets Setup display a non critical error to the user and ask
    the user whether he wants to ignore the failure, skip the operation or
    exit Setup.

Arguments:

    MsgId     - message to display

    p1 - optional replacement string

    p2 - optional replacement string

Return Value:

    TRUE if user wants to ignore the failure, FALSE otherwise.  Exit
    Setup won't return from this routine

--*/

{
    ULONG ValidKeys[4] = { ASCI_CR, ASCI_ESC, KEY_F3, 0 };

    CLEAR_CLIENT_SCREEN();
    while(1) {
        if(p1!=NULL && p2!=NULL ) {
            SpStartScreen(
                MsgId,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                p1,
                p2
                );

        }
        else if (p1!=NULL) {
            SpStartScreen(
                MsgId,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                p1
                );

        }
        else{
            SpStartScreen(
                MsgId,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE
                );

        }

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            SP_STAT_ESC_EQUALS_SKIP_OPERATION,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {

        case ASCI_CR:       // ignore failure

            return(TRUE);

        case ASCI_ESC:      // skip operation

            return(FALSE);

        case KEY_F3:        // exit setup

            SpConfirmExit();
            break;
        }
    }
}



VOID
SpNonCriticalErrorNoRetry (
    IN ULONG MsgId,
    IN PWSTR p1, OPTIONAL
    IN PWSTR p2  OPTIONAL
    )
/*++

Routine Description:

    This routine lets Setup display a non critical error to the user and ask
    the user whether he wants to continue exit Setup.

Arguments:

    MsgId     - message to display

    p1 - optional replacement string

    p2 - optional replacement string

Return Value:

    None.

--*/

{
    ULONG ValidKeys[3] = { ASCI_CR, KEY_F3, 0 };

    CLEAR_CLIENT_SCREEN();
    while(1) {
        if(p1!=NULL && p2!=NULL ) {
            SpStartScreen(
                MsgId,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                p1,
                p2
                );

        }
        else if (p1!=NULL) {
            SpStartScreen(
                MsgId,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                p1
                );

        }
        else{
            SpStartScreen(
                MsgId,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE
                );

        }

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {

        case ASCI_CR:       // continue

            return;

        case KEY_F3:        // exit setup

            SpConfirmExit();
            break;
        }
    }
}



PWSTR
SpDetermineSystemPartitionDirectory(
    IN PDISK_REGION SystemPartitionRegion,
    IN PWSTR        OriginalSystemPartitionDirectory OPTIONAL
    )

/*++

Routine Description:

    This routine figures out what directory to use for the hal and
    osloader on the system partition.  In the past we just used \os\nt
    but consider the case where there is a Windows NT 3.1 installation
    and a Windows NT 3.5 system sharing a system partition.  The 3.5
    installation overwrites the 3.1 hal with a 3.5 one, which  won't work
    with 3.1, and the 3.1 system is now hosed.

    For now, we will use the existing directory (in the case of an upgrade),
    or \os\winnt50.n (where 'n' is a unique digit from 0 to 999) for a
    fresh install.

Arguments:

    SystemPartitionRegion - supplies the disk region for the system partition
        to be used for the windows nt we are installing.

    OriginalSystemPartitionDirectory - if we are upgrading nt, then this
        will be the directory on the system partition that is used by
        the system we are upgrading.

Return Value:

    Directory to be used on the system partition.

--*/

{
WCHAR   ReturnPath[512];

#if defined(EFI_NVRAM_ENABLED)
    #define OS_DIRECTORY_PREFIX         L"\\EFI\\Microsoft\\WINNT50"
#else
    #define OS_DIRECTORY_PREFIX         L"\\OS\\WINNT50"
#endif


    if(ARGUMENT_PRESENT(OriginalSystemPartitionDirectory)) {

        //
        // Note that we're about to break an install under
        // certain conditions.  For example, say the user has
        // two NT4 installs, both sharing the same \os\winnt40
        // directory.  Now the user has decided to upgrade one
        // of those.  We're about to upgrade the hal, osloader, ...
        // in that winnt40 directory, which will break the
        // users secondary install that's sharing this directory.
        // This should be a rare case though, and this is
        // exactly how we behaved in NT40 and NT3.51.
        //
        wcscpy( ReturnPath, OriginalSystemPartitionDirectory );
    } else {

        //
        // We want to return os\winnt50, but we also want
        // to make sure that whatever directory we select, it's
        // unique (since this is a clean install).  Note that
        // this allows the user to have multiple NT installs,
        // with no shared files (which fixes the upgrade problem
        // described above.
        //
        if( !SpGenerateNTPathName( SystemPartitionRegion,
#if DBG
                                   OS_DIRECTORY_PREFIX L"C",    // C - for Checked
#else
                                   OS_DIRECTORY_PREFIX,
#endif
                                   ReturnPath ) ) {
            //
            // Odd...  Just default to using
            // the base directory name.
            //
            wcscpy( ReturnPath,
#if DBG
                    OS_DIRECTORY_PREFIX L"C"    // C - for Checked
#else
                    OS_DIRECTORY_PREFIX
#endif
                  );
        }
    }

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SpDetermineSystemPartitionDirectory - Generated directory name: %ws\n", ReturnPath ));
    return SpDupStringW( ReturnPath );
}


VOID
SpFindSizeOfFilesInOsWinnt(
    IN PVOID        MasterSifHandle,
    IN PDISK_REGION SystemPartition,
    IN PULONG       TotalSize
    )

/*++

Routine Description:

    This routine computes the size of of the files present on os\winnt.
    Currently these files are osloader.exe and hal.dll.
    The size computed by this function can be used to adjust the total
    required free space on the system partition.

Arguments:

    Region - supplies the disk region for the system partition.

    TotalSize - Variable that will contain the total size of the files
                in os\winnt, in number of bytes.

Return Value:

    None.

--*/

{
    ULONG               FileSize;
    ULONG               i, Count;
    PWSTR               FileName;
    NTSTATUS            Status;
    PWSTR               SystemPartitionDirectory;
    PWSTR               SystemPartitionDevice;

    *TotalSize = 0;
    SystemPartitionDirectory = SpDetermineSystemPartitionDirectory( SystemPartition,
                                                                    NULL );
    if( SystemPartitionDirectory == NULL ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to determine system partition directory \n"));
        return;
    }

    //
    // Get the device path of the system partition.
    //
    SpNtNameFromRegion(
        SystemPartition,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    SystemPartitionDevice = SpDupStringW(TemporaryBuffer);

    //
    //  Compute the size of the files that are always copied to the system
    //  partition directory. These files are listed on SIF_SYSPARTCOPYALWAYS
    //
    Count = SpCountLinesInSection(MasterSifHandle, SIF_SYSPARTCOPYALWAYS);
    for (i = 0; i < Count; i++) {
        FileName = SpGetSectionLineIndex(MasterSifHandle,SIF_SYSPARTCOPYALWAYS,i,0);
        if( FileName == NULL ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SETUP: Unable to get file name from txtsetup.sif, Section = %ls \n", SIF_SYSPARTCOPYALWAYS ));
            continue;
        }

        Status = SpGetFileSizeByName( SystemPartitionDevice,
                                      SystemPartitionDirectory,
                                      FileName,
                                      &FileSize );
        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpGetFileSizeByName() failed. File = %ls, Status = %x\n",FileName, Status ) );
            continue;
        }

        *TotalSize += FileSize;
    }
    //
    // Now compute the size of hal.dll
    //
    FileName = L"hal.dll";
    Status = SpGetFileSizeByName( SystemPartitionDevice,
                                  SystemPartitionDirectory,
                                  FileName,
                                  &FileSize );
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpGetFileSizeByName() failed. File = %ls, Status = %x\n",FileName, Status ) );
        return;
    }
    *TotalSize += FileSize;
}


ENUMFILESRESULT
SpEnumFiles(
    IN  PCWSTR        DirName,
    IN  ENUMFILESPROC EnumFilesProc,
    OUT PULONG        ReturnData,
    IN  PVOID         p1    OPTIONAL
    )
/*++

Routine Description:

    This routine processes every file (and subdirectory) in the directory
    specified by 'DirName'. Each entry is sent to the callback function
    'EnumFilesProc' for processing.  If the callback returns TRUE, processing
    continues, otherwise processing terminates.

Arguments:

    DirName       - Supplies the directory name containing the files/subdirectories
                    to be processed.

    EnumFilesProc - Callback function to be called for each file/subdirectory.
                    The function must have the following prototype:

                    BOOLEAN EnumFilesProc(
                        IN  PWSTR,
                        IN  PFILE_BOTH_DIR_INFORMATION,
                        OUT PULONG
                        );

    ReturnData    - Pointer to the returned data.  The contents stored here
                    depend on the reason for termination (See below).

    p1 - Optional pointer, to be passed to the callback function.

Return Value:

    This function can return one of three values.  The data stored in
    'ReturnData' depends upon which value is returned:

        NormalReturn   - if the whole process completes uninterrupted
                         (ReturnData is not used)
        EnumFileError  - if an error occurs while enumerating files
                         (ReturnData contains the error code)
        CallbackReturn - if the callback returns FALSE, causing termination
                         (ReturnData contains data defined by the callback)

--*/
{
    HANDLE                     hFindFile;
    NTSTATUS                   Status;
    UNICODE_STRING             PathName;
    OBJECT_ATTRIBUTES          Obja;
    IO_STATUS_BLOCK            IoStatusBlock;
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo;
    BOOLEAN                    bStartScan;
    ENUMFILESRESULT            ret;

    //
    // Prepare to open the directory
    //
    INIT_OBJA(&Obja, &PathName, DirName);

    //
    // Open the specified directory for list access
    //
    Status = ZwOpenFile(
        &hFindFile,
        FILE_LIST_DIRECTORY | SYNCHRONIZE,
        &Obja,
        &IoStatusBlock,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
        );

    if(!NT_SUCCESS(Status)) {
        if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open directory %ws for list (%lx)\n", DirName, Status));
        }
        *ReturnData = Status;
        return EnumFileError;
    }

    DirectoryInfo = SpMemAlloc(ACTUAL_MAX_PATH * sizeof(WCHAR) + sizeof(FILE_BOTH_DIR_INFORMATION));
    if(!DirectoryInfo) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Unable to allocate memory for SpEnumFiles()\n"));
        *ReturnData = STATUS_NO_MEMORY;
        return EnumFileError;
    }

    bStartScan = TRUE;
    while(TRUE) {
        Status = ZwQueryDirectoryFile(
            hFindFile,
            NULL,
            NULL,
            NULL,
            &IoStatusBlock,
            DirectoryInfo,
            (ACTUAL_MAX_PATH * sizeof(WCHAR) + sizeof(FILE_BOTH_DIR_INFORMATION)),
            FileBothDirectoryInformation,
            TRUE,
            NULL,
            bStartScan
            );

        if(Status == STATUS_NO_MORE_FILES) {

            ret = NormalReturn;
            break;

        } else if(!NT_SUCCESS(Status)) {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Unable to query directory %ws (%lx)\n", DirName, Status));
            *ReturnData = Status;
            ret = EnumFileError;
            break;
        }


        if(bStartScan) {
            bStartScan = FALSE;
        }

        //
        // Now pass this entry off to our callback function for processing
        //
        if(!EnumFilesProc(DirName, DirectoryInfo, ReturnData, p1)) {

            ret = CallbackReturn;
            break;
        }
    }

    SpMemFree(DirectoryInfo);
    ZwClose(hFindFile);
    return ret;
}


/*typedef struct {
    PVOID           OptionalPtr;
    ENUMFILESPROC   EnumProc;
} RECURSION_DATA, *PRECURSION_DATA;

BOOLEAN
SppRecursiveEnumProc (
    IN  PCWSTR                     DirName,
    IN  PFILE_BOTH_DIR_INFORMATION FileInfo,
    OUT PULONG                     ret,
    IN  PVOID                      Param
    )
{
    PWSTR           FullPath;
    PWSTR           temp;
    ULONG           Len;
    NTSTATUS        Status;
    ULONG           ReturnData;
    ENUMFILESRESULT EnumResult;
    BOOLEAN         b = FALSE;
    PRECURSION_DATA RecursionData;

    RecursionData = (PRECURSION_DATA) Param;

    //
    // Build the full file or dir path
    //

    temp = TemporaryBuffer + (sizeof(TemporaryBuffer) / sizeof(WCHAR) / 2);
    Len = FileInfo->FileNameLength/sizeof(WCHAR);

    wcsncpy(temp,FileInfo->FileName,Len);
    temp[Len] = 0;

    wcscpy(TemporaryBuffer,DirName);
    SpConcatenatePaths(TemporaryBuffer,temp);
    FullPath = SpDupStringW(TemporaryBuffer);


    //
    // For directories, recurse
    //

    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        if( (wcscmp( temp, L"." ) == 0) ||
            (wcscmp( temp, L".." ) == 0) ) {
            //
            // Skip past . and .. directories
            //
            b = TRUE;
        } else {
            //
            // Recurse through subdirectory
            //

            EnumResult = SpEnumFilesRecursive (
                                FullPath,
                                RecursionData->EnumProc,
                                &ReturnData,
                                RecursionData->OptionalPtr
                                );

            if (EnumResult != NormalReturn) {
                *ret = EnumResult;
                return FALSE;
            }
        }
    }

    //
    // Call normal enum proc for file or dir (except . or .. dirs)
    //

    if (!b) {
        b = RecursionData->EnumProc (
                                DirName,
                                FileInfo,
                                ret,
                                RecursionData->OptionalPtr
                                );
    }

    SpMemFree (FullPath);

    return b;
}*/



/*BOOLEAN
SppRecursiveEnumProcDel (
    IN  PCWSTR                     DirName,
    IN  PFILE_BOTH_DIR_INFORMATION FileInfo,
    OUT PULONG                     ret,
    IN  PVOID                      Param
    )
{*/
/*
    This function is the same as above except that it checks for reparse points. The reason
    we have 2 seperate functions rather than one function and an extra parameter is so that
    we don't have the Reparse point check overhead for other recursive processing like copying
    file. Given the no. of files this could be overhead. Also this way we don't hack the
    recursive directory search algo as well as reduce stack overhead in a recursive operation.

*/
/*

    HANDLE                     hFixed;
    NTSTATUS                   Status;
    UNICODE_STRING             PathName;
    OBJECT_ATTRIBUTES          Obja;
    IO_STATUS_BLOCK            IoStatusBlock;
    FILE_FS_DEVICE_INFORMATION DeviceInfo;

    PWSTR           FullPath;
    PWSTR           temp;
    ULONG           Len;
    ULONG           ReturnData;
    ENUMFILESRESULT EnumResult;
    BOOLEAN         b = FALSE;
    BOOLEAN         IsLink = FALSE;
    PRECURSION_DATA RecursionData;

    RecursionData = (PRECURSION_DATA) Param;

    //
    // Build the full file or dir path
    //

    temp = TemporaryBuffer + (sizeof(TemporaryBuffer) / sizeof(WCHAR) / 2);
    Len = FileInfo->FileNameLength/sizeof(WCHAR);

    wcsncpy(temp,FileInfo->FileName,Len);
    temp[Len] = 0;

    wcscpy(TemporaryBuffer,DirName);
    SpConcatenatePaths(TemporaryBuffer,temp);
    FullPath = SpDupStringW(TemporaryBuffer);


    //
    // For directories, recurse
    //

    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        if( (wcscmp( temp, L"." ) == 0) ||
            (wcscmp( temp, L".." ) == 0) ) {
            //
            // Skip past . and .. directories
            //
            b = TRUE;
        } else {
            //
            // Recurse through subdirectory
            //


            //
            //   Look for mount point and delete right away to avoid cycle complications
            //

            if( FileInfo->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT )
                IsLink = TRUE;



            if( !IsLink ){

                EnumResult = SpEnumFilesRecursiveDel (
                                    FullPath,
                                    RecursionData->EnumProc,
                                    &ReturnData,
                                    RecursionData->OptionalPtr
                                    );

                if (EnumResult != NormalReturn) {
                    *ret = EnumResult;
                    return FALSE;
                }
            }
        }
    }

    //
    // Call normal enum proc for file or dir (except . or .. dirs)
    //

    if (!b) {
        b = RecursionData->EnumProc (
                                DirName,
                                FileInfo,
                                ret,
                                RecursionData->OptionalPtr
                                );
    }

    SpMemFree (FullPath);

    return b;
}*/

#define LONGEST_NT_PATH_LENGTH      512 // RtlGetLongestNtPathLength always return just 277(MAX_PATH+UNC_PREFIX_LENGTH)
                                        // longest NT path is 32000 character.
#define MAX_DEPTH      -1

typedef struct
{
    HANDLE hHandle;
    int    Index;
    PFILE_BOTH_DIR_INFORMATION FileInfo;
}ENUM_LEVEL, *PENUM_LEVEL;

BOOLEAN 
SpEnumFilesInline(
    IN  PCWSTR pPath, 
    IN  ENUMFILESPROC EnumFilesProc, 
    OUT PULONG ReturnData, 
    IN  PVOID   p1                      OPTIONAL, 
    IN  BOOLEAN bExcludeRepasePointDirs OPTIONAL, 
    IN  LONG    DirectoriesMaxDepth, 
    IN  BOOLEAN bEnumerateDirFirst      OPTIONAL
    )
{
    PENUM_LEVEL         level = NULL;
    int                 MaxLevelNumber = 0;
    UNICODE_STRING      UnicodeString;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    PFILE_BOTH_DIR_INFORMATION FileInfo = NULL;
    int                 SizeOfFileInfo;
    NTSTATUS            Status;
    PWSTR               Path = NULL;
    PWSTR               SubDir = NULL;
    int                 index;
    int                 i;
    BOOLEAN             FirstQuery;
    ENUMFILESRESULT     enumResult = NormalReturn;


    if(!pPath || wcslen(pPath) >= LONGEST_NT_PATH_LENGTH){
        return EnumFileError;
    }

    __try{
        Path = (PWSTR)SpMemAlloc(LONGEST_NT_PATH_LENGTH * sizeof(WCHAR));
        if(!Path){
            if(ReturnData){
                *ReturnData = STATUS_NO_MEMORY;
            }
            enumResult = EnumFileError;
            __leave;
        }

        SubDir = (PWSTR)SpMemAlloc(LONGEST_NT_PATH_LENGTH * sizeof(WCHAR));
        if(!SubDir){
            if(ReturnData){
                *ReturnData = STATUS_NO_MEMORY;
            }
            enumResult = EnumFileError;
            __leave;
        }
        
        SizeOfFileInfo = LONGEST_NT_PATH_LENGTH * sizeof(WCHAR) + sizeof(FILE_BOTH_DIR_INFORMATION);
        FileInfo = (PFILE_BOTH_DIR_INFORMATION)SpMemAlloc(SizeOfFileInfo);
        if(!FileInfo){
            if(ReturnData){
                *ReturnData = STATUS_NO_MEMORY;
            }
            enumResult = EnumFileError;
            __leave;
        }
    
        MaxLevelNumber = LONGEST_NT_PATH_LENGTH / 2;
        level = (PENUM_LEVEL)SpMemAlloc(sizeof(level[0]) * MaxLevelNumber);
        if(!level){
            if(ReturnData){
                *ReturnData = STATUS_NO_MEMORY;
            }
            enumResult = EnumFileError;
            __leave;
        }
        memset(level, 0, sizeof(level[0]) * MaxLevelNumber);
        
        wcscpy(Path, pPath);

        index = wcslen(Path) - 1;
        if('\\' != Path[index] && '//' != Path[index]){
            Path[index + 1] = '\\';
            Path[index + 2] = '\0';
        }
    
        for(index = 0; index >= 0;){
            INIT_OBJA(&ObjectAttributes, &UnicodeString, Path);
            level[index].Index = wcslen(Path);
            if(!bEnumerateDirFirst){
                level[index].FileInfo = (PFILE_BOTH_DIR_INFORMATION)SpMemAlloc(SizeOfFileInfo);
                if(!level[index].FileInfo){
                    if(ReturnData){
                        *ReturnData = STATUS_NO_MEMORY;
                    }
                    enumResult = EnumFileError;
                    __leave;
                }
            }
            
            Status = ZwOpenFile(&level[index].hHandle,
                                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                                &ObjectAttributes,
                                &IoStatusBlock,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                FILE_DIRECTORY_FILE |
                                    FILE_SYNCHRONOUS_IO_NONALERT |
                                    FILE_OPEN_FOR_BACKUP_INTENT
                                );
            if(!NT_SUCCESS(Status)){
                level[index].hHandle = NULL;
                if(ReturnData){
                    *ReturnData = Status;
                }
                enumResult = EnumFileError;
                if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {
                    KdPrintEx((
                        DPFLTR_SETUP_ID, 
                        DPFLTR_ERROR_LEVEL, 
                        "SETUP:SpEnumFilesInline, Failed to open %ws folder for list access - status 0x%08X.\n", 
                        Path, 
                        Status));
                }
                __leave;//index--;
            }
            else{
                FirstQuery = TRUE;
            }

            for(;;)
            {
                for(; index >= 0; index--){
                    Status = ZwQueryDirectoryFile(level[index].hHandle, 
                                                  NULL,                           // no event to signal
                                                  NULL,                           // no apc routine
                                                  NULL,                           // no apc context
                                                  &IoStatusBlock, 
                                                  FileInfo, 
                                                  SizeOfFileInfo - sizeof(WCHAR), // leave room for terminating nul
                                                  FileBothDirectoryInformation, 
                                                  TRUE,                           // want single entry
                                                  NULL,                           // get 'em all
                                                  FirstQuery);
                    FirstQuery = FALSE;
                    if(NT_SUCCESS(Status)){
                        break;
                    }
                    else{
                        if(STATUS_NO_MORE_FILES != Status){
                            if(ReturnData){
                                *ReturnData = Status;
                            }
                            KdPrintEx((
                                DPFLTR_SETUP_ID, 
                                DPFLTR_ERROR_LEVEL, 
                                "SETUP:SpEnumFilesInline, Failed to query %d level - status 0x%08X.\n", 
                                index, 
                                Status));
                            enumResult = EnumFileError;
                            __leave;
                        }
                        else{
                            if(!bEnumerateDirFirst){
                                if(index > 0){
                                    wcsncpy(SubDir, Path, level[index - 1].Index);
                                    SubDir[level[index - 1].Index] = '\0';
                                
                                    if(!EnumFilesProc(SubDir, level[index - 1].FileInfo, ReturnData, p1)){
                                        enumResult = CallbackReturn;
                                        KdPrintEx((
                                            DPFLTR_SETUP_ID, 
                                            DPFLTR_ERROR_LEVEL, 
                                            "SETUP:SpEnumFilesInline, Callback returned FALSE on %ws\\%ws\n", 
                                            SubDir, 
                                            level[index - 1].FileInfo->FileName));
                                        __leave;
                                    }
                                }
                            }
                        }
                    }
                
                    ZwClose(level[index].hHandle);
                    level[index].hHandle = NULL;
                }

                if(index < 0){
                    break;
                }

                FileInfo->FileName[FileInfo->FileNameLength / sizeof(WCHAR)] = '\0';

                wcscpy(&Path[level[index].Index], FileInfo->FileName);
                
                wcsncpy(SubDir, Path, level[index].Index);
                SubDir[level[index].Index] = '\0';

                if(!(FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY)){
                    if(!EnumFilesProc(SubDir, FileInfo, ReturnData, p1)){
                        enumResult = CallbackReturn;
                        KdPrintEx((
                            DPFLTR_SETUP_ID, 
                            DPFLTR_ERROR_LEVEL, 
                            "SETUP:SpEnumFilesInline, Callback returned FALSE on %ws\\%ws\n", 
                            SubDir, 
                            FileInfo->FileName));
                        __leave;
                    }
                }
                else{
                    if(wcscmp(FileInfo->FileName, L".") && 
                       wcscmp(FileInfo->FileName, L"..")){
                        wcscat(Path, L"\\");
                        if(bEnumerateDirFirst){
                            if(!EnumFilesProc(SubDir, FileInfo, ReturnData, p1)){
                                enumResult = CallbackReturn;
                                KdPrintEx((
                                    DPFLTR_SETUP_ID, 
                                    DPFLTR_ERROR_LEVEL, 
                                    "SETUP:SpEnumFilesInline, Callback returned FALSE on %ws\\%ws\n", 
                                    SubDir, 
                                    FileInfo->FileName));
                                __leave;
                            }
                        }
                        else{
                            ASSERT(level[index].FileInfo);
                            memcpy(level[index].FileInfo, FileInfo, SizeOfFileInfo);
                        }
                        
                        if(DirectoriesMaxDepth >= 0 && index >= DirectoriesMaxDepth){
                            continue;
                        }
                        if(bExcludeRepasePointDirs && FileInfo->FileAttributes&FILE_ATTRIBUTE_REPARSE_POINT){
                            continue;
                        }

                        index++;
                        break;
                    }
                }
            }
        }
        
        enumResult = NormalReturn;
    }
    __finally{
        if(level){
            for(i = 0; i < MaxLevelNumber; i++){
                if(level[i].hHandle){
                    ZwClose(level[i].hHandle);
                }
                if(level[i].FileInfo){
                    SpMemFree(level[i].FileInfo);
                }
            }
            SpMemFree(level);
        }
        if(SubDir){
            SpMemFree(SubDir);
        }
        if(Path){
            SpMemFree(Path);
        }
        if(FileInfo){
            SpMemFree(FileInfo);
        }
    }

    return enumResult;
}

ENUMFILESRESULT
SpEnumFilesRecursive (
    IN  PWSTR         DirName,
    IN  ENUMFILESPROC EnumFilesProc,
    OUT PULONG        ReturnData,
    IN  PVOID         p1    OPTIONAL
    )
{
    return SpEnumFilesInline(DirName, 
                             EnumFilesProc, 
                             ReturnData, 
                             p1, 
                             FALSE, 
                             MAX_DEPTH, 
                             FALSE);
/*
    RECURSION_DATA RecursionData;
    
    RecursionData.OptionalPtr = p1;
    RecursionData.EnumProc    = EnumFilesProc;

    return SpEnumFiles (
                DirName,
                SppRecursiveEnumProc,
                ReturnData,
                &RecursionData
                );
                */
}

/*typedef struct {
    ULONG           MaxDepth;
    ULONG           CurrentDepth;
    PVOID           OptionalPtr;
    ENUMFILESPROC   EnumProc;
} RECURSION_LIMITED_DATA, *PRECURSION_LIMITED_DATA;

BOOLEAN
SppRecursiveLimitedEnumProc (
    IN  PCWSTR                     DirName,
    IN  PFILE_BOTH_DIR_INFORMATION FileInfo,
    OUT PULONG                     ret,
    IN  PVOID                      Param
    )*/
/*++

Routine Description:

    This routine is the same as SppRecursiveEnumProc with the added feature
    that it supports recursion depth limiting.  The recursion context is passed
    in via the Param argument and is of type RECURSION_LIMITED_DATA.

Arguments:

    DirName     - Supplies the directory name containing the current directory of the 
                  File/Dir currently being enumerated.

    FileInfo    - File/Dir info about the current file being enumerated

    ret         - Pointer to the returned data.  The contents stored here
                    depend on the reason for termination:
                
                        NormalReturn   - if the whole process completes uninterrupted
                                         (ReturnData is not used)
                        EnumFileError  - if an error occurs while enumerating files
                                         (ReturnData contains the error code)
                        CallbackReturn - if the callback returns FALSE, causing termination
                                         (ReturnData contains data defined by the callback)

    Param       - Recursion context

Return Value:

    TRUE    - continue processing 
    
    otherwise, FALSE

--*/
/*{
    PWSTR           FullPath;
    PWSTR           temp;
    ULONG           Len;
    NTSTATUS        Status;
    ULONG           ReturnData;
    ENUMFILESRESULT EnumResult;
    BOOLEAN         b = FALSE;
    PRECURSION_LIMITED_DATA RecursionData;

    RecursionData = (PRECURSION_LIMITED_DATA) Param;

    //
    // If we are at our max recursion depth, bail out
    //
    // Note: using >= allows us to look at files at the MaxDepth,
    //       but not recurse into directories beyond MaxDepth.
    //
    if (RecursionData->CurrentDepth >= RecursionData->MaxDepth) {
        *ret = NormalReturn;
        return TRUE;
    }

    //
    // Build the full file or dir path
    //

    temp = TemporaryBuffer + (sizeof(TemporaryBuffer) / sizeof(WCHAR) / 2);
    Len = FileInfo->FileNameLength/sizeof(WCHAR);

    wcsncpy(temp,FileInfo->FileName,Len);
    temp[Len] = 0;

    wcscpy(TemporaryBuffer,DirName);
    SpConcatenatePaths(TemporaryBuffer,temp);
    FullPath = SpDupStringW(TemporaryBuffer);

    //
    // if the length of FullPath >= MAX_PATH, then we might
    // have encountered a corrupt region of the file system.
    // Hence, ensure that the length of FullPath is < MAX_PATH-1.
    // (allow for null termination when comparing to MAX_PATH)
    //
    if (wcslen(FullPath) >= MAX_PATH) {
        
        SpMemFree(FullPath);
        
        //
        // skip this entry and continue scanning
        //
        // (Since this routine is used by Bootcfg in the recover console,
        //  this behavior is helpful because it allows us to continue scanning
        //  and perhaps find a valid Windows install - which would then allow
        //  us to possibly do more recovery work...)
        //
        *ret = NormalReturn;
        return TRUE;
    
    }

    //
    // For directories, recurse
    //

    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        if( (wcscmp( temp, L"." ) == 0) ||
            (wcscmp( temp, L".." ) == 0) ) {
            //
            // Skip past . and .. directories
            //
            b = TRUE;
        } else {
            //
            // Recurse through subdirectory
            //
            
            RecursionData->CurrentDepth++;

            EnumResult = SpEnumFilesRecursiveLimited (
                                FullPath,
                                RecursionData->EnumProc,
                                RecursionData->MaxDepth,
                                RecursionData->CurrentDepth,
                                &ReturnData,
                                RecursionData->OptionalPtr
                                );
            
            RecursionData->CurrentDepth--;

            if (EnumResult != NormalReturn) {
                *ret = EnumResult;
                return FALSE;
            }
        }
    }

    //
    // Call normal enum proc for file or dir (except . or .. dirs)
    //

    if (!b) {
        b = RecursionData->EnumProc (
                                DirName,
                                FileInfo,
                                ret,
                                RecursionData->OptionalPtr
                                );
    }

    SpMemFree (FullPath);

    return b;
}*/

ENUMFILESRESULT
SpEnumFilesRecursiveLimited (
    IN  PWSTR         DirName,
    IN  ENUMFILESPROC EnumFilesProc,
    IN  ULONG         MaxDepth,
    IN  ULONG         CurrentDepth,
    OUT PULONG        ReturnData,
    IN  PVOID         p1    OPTIONAL
    )
/*++

Routine Description:

    This routine processes every file (and subdirectory) in the directory
    specified by 'DirName'. Each entry is sent to the callback function
    'EnumFilesProc' for processing.  If the callback returns TRUE, processing
    continues, otherwise processing terminates.

    This routine employs recursion depth limiting.

Arguments:

    DirName       - Supplies the directory name containing the files/subdirectories
                    to be processed.

    EnumFilesProc - Callback function to be called for each file/subdirectory.
                    The function must have the following prototype:

                    BOOLEAN EnumFilesProc(
                        IN  PWSTR,
                        IN  PFILE_BOTH_DIR_INFORMATION,
                        OUT PULONG
                        );

    MaxDepth      - The maximum depth the recursion will be allowed to go.
                    
                    Note: During the recursion process, the directories will be
                          recursed until CurrentDepth == MaxDepth.  Files at 
                          MaxDepth + 1 will be processed via EnumProc, but any
                          directories below MaxDepth will not be visited.
                                                            
                                                      
    CurrentDepth  - The depth the recursion is currently at.
                
                    Note: When first calling this routine, CurrentDepth should be 0.
                          This argument exists because this routine is the core of the
                          recursion and is called by SppRecursiveLimitedEnumProc.  Each
                          time SppRecursiveLimitedEnumProc calls this function, it passes
                          the current recursion depth.

    ReturnData    - Pointer to the returned data.  The contents stored here
                    depend on the reason for termination (See below).

    p1 - Optional pointer, to be passed to the callback function.

Return Value:

    This function can return one of three values.  The data stored in
    'ReturnData' depends upon which value is returned:

        NormalReturn   - if the whole process completes uninterrupted
                         (ReturnData is not used)
        EnumFileError  - if an error occurs while enumerating files
                         (ReturnData contains the error code)
        CallbackReturn - if the callback returns FALSE, causing termination
                         (ReturnData contains data defined by the callback)

--*/
{
/*    RECURSION_LIMITED_DATA RecursionData;

    RecursionData.OptionalPtr   = p1;
    RecursionData.EnumProc      = EnumFilesProc;
    RecursionData.MaxDepth      = MaxDepth;
    RecursionData.CurrentDepth  = CurrentDepth;

    return SpEnumFiles (
                DirName,
                SppRecursiveLimitedEnumProc,
                ReturnData,
                &RecursionData
                );*/

    return SpEnumFilesInline(DirName, 
                             EnumFilesProc, 
                             ReturnData, 
                             p1, 
                             FALSE, 
                             MaxDepth, 
                             FALSE);
}

ENUMFILESRESULT
SpEnumFilesRecursiveDel (
    IN  PWSTR         DirName,
    IN  ENUMFILESPROC EnumFilesProc,
    OUT PULONG        ReturnData,
    IN  PVOID         p1    OPTIONAL
    )
//
// This function is the same as SpEnumFilesRecursive except that
// it handles reparse points too and avoids name cycles and calls
// SppRecursiveEnumProcDel instead
//

{
    return SpEnumFilesInline(DirName, 
                             EnumFilesProc, 
                             ReturnData, 
                             p1, 
                             TRUE, 
                             MAX_DEPTH, 
                             FALSE);

/*    RECURSION_DATA RecursionData;

    RecursionData.OptionalPtr = p1;
    RecursionData.EnumProc    = EnumFilesProc;

    return SpEnumFiles (
                DirName,
                SppRecursiveEnumProcDel,
                ReturnData,
                &RecursionData
                );*/
}


VOID
SpFatalKbdError(
    IN ULONG MessageId,
    ...
    )

/*++

Routine Description:

    Inform the user that a keyboard problem (specified by MessageId)
    prevents setup from continuing.  Since we can't prompt the user
    to press a key to reboot, we just go into an infinite loop until
    they power-cycle the computer.
    In the headless case, we will restart after a key is pressed
    remotely.

Arguments:

    MessageId - Message ID for keyboard error message to display

    ...       - Supply arguments for insertion/substitution into the message text.

Return Value:

    DOES NOT RETURN

--*/

{
    va_list arglist;

    //
    // Display a message indicating that a keyboard
    // error prevents Setup from continuing.
    //
    CLEAR_CLIENT_SCREEN();

    va_start(arglist, MessageId);

    vSpDisplayFormattedMessage(
            MessageId,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            3,
            HEADER_HEIGHT+3,
            arglist
            );

    va_end(arglist);

    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, SP_STAT_KBD_HARD_REBOOT, 0);

    //
    // attempt to read from terminal.
    // if terminal is not connected, 
    // loop forever
    //
    SpTermDrain();
    while(!SpTermGetKeypress());
    SpDone( 0, FALSE, FALSE );
}

VOID
SpFatalError(
    IN ULONG MessageId,
    ...
    )

/*++

Routine Description:

    Inform the user of a blocking problem. Then reboot.

Arguments:

    MessageId - Message ID for keyboard error message to display

    ...       - Supply arguments for insertion/substitution into the message text.

Return Value:

    DOES NOT RETURN

--*/

{
    va_list arglist;

    CLEAR_CLIENT_SCREEN();

    va_start(arglist, MessageId);

    vSpDisplayFormattedMessage(
            MessageId,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            3,
            HEADER_HEIGHT+3,
            arglist
            );

    va_end(arglist);

    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, SP_STAT_F3_EQUALS_REBOOT, 0);

    SpInputDrain();
    while( SpInputGetKeypress() != KEY_F3 );
    SpDone( 0, FALSE, TRUE );
}

VOID
SpRunAutochkOnNtAndSystemPartitions(
    IN HANDLE       MasterSifHandle,
    IN PDISK_REGION WinntPartitionRegion,
    IN PDISK_REGION SystemPartitionRegion,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice,
    IN PWSTR        TargetPath
    )

/*++

Routine Description:

    Run autochk on the NT and System partitions.

    We always invoke autochk.exe for both the winnt and system
    partitions.  However under some conditions we pass flags that
    cause it to run only if the dirty bit is set.  Running only when
    the dirty bit is set is referred to below as a "light check" wheras
    running regardless of the state of the dirty bit is the "heavy check."

    If this is repair, run the heavy check in all cases on both partitions.

    If this is express setup or unattended operation, run light check on
    ntfs partitions and heavy check on fat ones.

    Otherwise (attended custom setup), ask the user.

Arguments:

    MasterSifHandle         - Handle to txtsetup.sif.

    WinntPartitionRegion    - Pointer to the structure that describes the
                              NT partition.

    SystemPartitionRegion   - Pointer to the structure that describes the
                              system partition.

    SetupSourceDevicePath   - NT device path where autochk.exe is located

    DirectoryOnSourceDevice - Directory on that device where autochk.exe is located


Return Value:

    None.

--*/

{
    PWSTR           MediaShortName;
    PWSTR           MediaDirectory;
    PWSTR           AutochkPath;
    ULONG           AutochkStatus;
    WCHAR           DriveLetterString[3] = L"?:";
    NTSTATUS        Status;
    ULONG ValidKeys[3] = { ASCI_CR, ASCI_ESC, 0 };
    PWSTR           WinntPartition, SystemPartition;
    ULONG           WinntPartIndex, SystemPartIndex, i;
    PWSTR           AutochkPartition[2];
    PWSTR           AutochkType[2];
    LARGE_INTEGER   DelayTime;
    PWSTR           HeavyCheck = L"-t -p";  // -t causes autochk to send messages (like % complete)
    PWSTR           LightCheck = L"-t";     // to the setup driver
    BOOLEAN         RunAutochkForRepair;
    BOOLEAN         MultiplePartitions = TRUE, RebootRequired = FALSE;
    ULONG           InputChar;

    //
    // We first need to determine if either the system partition
    // or winnt partition also contains the directory from which
    // autochk is being run. If so, then we want to run autochk on that
    // partition last.  This is done so that no further access to
    // that partition will be necessary should a reboot be required.
    //
    // First, get the device path of the nt partition and system partition.
    //
#if defined(REMOTE_BOOT)
    // Note that during a remote boot setup, there will be no winnt partition,
    // and if the machine is diskless there will be no system partition.
    //
#endif // defined(REMOTE_BOOT)
    if (WinntPartitionRegion != NULL) {
        SpNtNameFromRegion(
            WinntPartitionRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer),
            PartitionOrdinalCurrent
            );
        WinntPartition = SpDupStringW(TemporaryBuffer);
    } else {
        WinntPartition = NULL;
    }

    if (SystemPartitionRegion != NULL) {
        SpNtNameFromRegion(
            SystemPartitionRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer),
            PartitionOrdinalCurrent
            );
        SystemPartition = SpDupStringW(TemporaryBuffer);
    } else {
        SystemPartition = NULL;
    }

    //
    // Skip autocheck if not partitions names could
    // be formed
    //
    if (!WinntPartition && !SystemPartition) {
        return;
    }

#if defined(REMOTE_BOOT)
    if (!RemoteBootSetup) {
#endif // defined(REMOTE_BOOT)
        if (WinntPartition) {
        if (SystemPartition && !_wcsicmp(WinntPartition, SystemPartition)) {
                SystemPartIndex = WinntPartIndex = 0;
                MultiplePartitions = FALSE;
            } else if(!_wcsicmp(WinntPartition, SetupSourceDevicePath)) {
                WinntPartIndex = 1;
                SystemPartIndex = 0;
            } else {
                WinntPartIndex = 0;
                SystemPartIndex = 1;
            }
        } else {
            WinntPartIndex = 1;
            SystemPartIndex = 0;
        }

        AutochkPartition[WinntPartIndex] = WinntPartition;

        if(MultiplePartitions) {
            AutochkPartition[SystemPartIndex] = SystemPartition;
        }

#if defined(REMOTE_BOOT)
    } else {

        //
        // Remote boot system - only check the system partition.
        //

        SystemPartIndex = WinntPartIndex = 0;
        AutochkPartition[SystemPartIndex] = SystemPartition;
        MultiplePartitions = FALSE;
    }
#endif // defined(REMOTE_BOOT)

    //
    // For repair or Disaster Recovery, we run the heavy check in all cases.    // @@ mtp
    //
    if( RepairWinnt || SpDrEnabled() ) {

        AutochkType[WinntPartIndex] = HeavyCheck;
        if(MultiplePartitions) {
            AutochkType[SystemPartIndex] = HeavyCheck;
        }

    } else {


#if defined(REMOTE_BOOT)
        //
        // On a diskless remote boot system, there will be no system partition.
        //

        if (SystemPartitionRegion != NULL)
#endif // defined(REMOTE_BOOT)
        {
            AutochkType[SystemPartIndex] = (SystemPartitionRegion->Filesystem == FilesystemNtfs) ? LightCheck : HeavyCheck;
        }

        //
        // If MultiplePartitions is FALSE, then the WinntPartition is the same
        // as the SystemPartition, so we are not going to autochk the WinntPartition.
        //
#if defined(REMOTE_BOOT)
        // MultiplePartitions will also be FALSE if this is a remote boot system,
        // in which case the WinntPartition is remote. Again, we are not going
        // to autochk the WinntPartition.
        //
#endif // defined(REMOTE_BOOT)

        if (MultiplePartitions) {
            ASSERT(WinntPartitionRegion != NULL);
            ASSERT(WinntPartition != NULL);
            AutochkType[WinntPartIndex] = (WinntPartitionRegion->Filesystem == FilesystemNtfs) ? LightCheck : HeavyCheck;
        }
    }

    CLEAR_CLIENT_SCREEN();

    //
    //  Prepare to run autochk
    //
    MediaShortName = SpLookUpValueForFile(
                        MasterSifHandle,
                        L"autochk.exe",
                        INDEX_WHICHMEDIA,
                        TRUE
                        );

    //
    // Prompt the user to insert the setup media.  If we're repairing,
    // then we don't want to force the user to have the setup media
    // (there's certain things they can do without it), so we give them
    // a slightly different prompt, that allows them to press ESC and
    // not run autochk.
    //
    if (!Win9xRollback) {
        if(RepairWinnt) {
            RunAutochkForRepair = SppPromptOptionalAutochk(
                                        MasterSifHandle,
                                        MediaShortName,
                                        SetupSourceDevicePath
                                        );

            if(!RunAutochkForRepair) {
                SpMemFree( WinntPartition );
                SpMemFree( SystemPartition );
                CLEAR_CLIENT_SCREEN();
                return;
            }
        } else {
            SpPromptForSetupMedia(
                MasterSifHandle,
                MediaShortName,
                SetupSourceDevicePath
                );
        }

        SpGetSourceMediaInfo(MasterSifHandle,MediaShortName,NULL,NULL,&MediaDirectory);

        wcscpy( TemporaryBuffer, SetupSourceDevicePath );
        SpConcatenatePaths( TemporaryBuffer, DirectoryOnSourceDevice );
        SpConcatenatePaths( TemporaryBuffer, MediaDirectory );
        SpConcatenatePaths( TemporaryBuffer, L"autochk.exe" );
        AutochkPath = SpDupStringW( TemporaryBuffer );
    } else {
        //
        // Win9x rollback -- autochk.exe is in $win_nt$.~bt\i386
        //

        wcscpy (TemporaryBuffer, NtBootDevicePath);
        SpConcatenatePaths (TemporaryBuffer, DirectoryOnBootDevice);
        SpConcatenatePaths (TemporaryBuffer, L"i386\\autochk.exe");
        AutochkPath = SpDupStringW (TemporaryBuffer);
    }

    //
    // Run autochk on the partition(s)
    //
    CLEAR_CLIENT_SCREEN();
    SpDisplayScreen( SP_SCRN_RUNNING_AUTOCHK, 3, 4 );

    //
    //  Create the gauge.
    //  Since we want only one progress bar displayed to the user
    //  while autochk is running, we initialize the range of the
    //  gauge based on the number of partitions to be examined.
    //  If the system and NT partitions are the same, the we set
    //  the range as 100. Otherwise, we set the range at 200.
    //  Note that on the multiple partitions case, 50% of the gauge
    //  will be used to display the progress for each disk.
    //  The IOCTL that calls SpFillGauge(), will have to adjust the
    //  amount of the gauge to be filled, based on the partition that
    //  is currently being examined.
    //
    UserModeGauge = SpCreateAndDisplayGauge( (MultiplePartitions)? 200 : 100,
                                             0,
                                             15,
                                             L"",
                                             NULL,
                                             GF_PERCENTAGE,
                                             0
                                           );       //          Setup is checking disk(s)...
                                                    //

    for(i = 0; i < (ULONG)(MultiplePartitions ? 2 : 1); i++) {
        //
        //  Display message informing that autocheck is being run
        //
        if (AutochkPartition[i] != NULL) {
            DriveLetterString[0] = (i == WinntPartIndex) ?
                                   WinntPartitionRegion->DriveLetter :
                                   SystemPartitionRegion->DriveLetter;

            SpDisplayStatusText( SP_STAT_CHECKING_DRIVE,
                                 DEFAULT_STATUS_ATTRIBUTE,
                                 DriveLetterString );

            if(!i) {
                //
                // Cheesy kludge below to wait 4 seconds before invoking autochk.exe
                // the first time. This was necessary because the cache manager delays
                // in closing the handle to system.log (opened by NT registry APIs when
                // we find NT's to upgrade)
                //
                DelayTime.HighPart = -1;
                DelayTime.LowPart  = (ULONG)-40000000;
                KeDelayExecutionThread (KernelMode, FALSE, &DelayTime);
            }

            //
            //  Tell the IOCTL which disk is being examined.
            //
            CurrentDiskIndex = i;

            AutochkStatus = 0;
            Status = SpExecuteImage( AutochkPath,
                                     &AutochkStatus,
                                     2,
                                     AutochkType[i],
                                     AutochkPartition[i]
                                     );


            if( NT_SUCCESS( Status ) ) {

                switch(AutochkStatus) {

                    case CHKDSK_EXIT_COULD_NOT_FIX :
                        //
                        //  Inform that the partition has an unrecoverable error
                        //
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: autochk.exe failed on %ls. ReturnCode = %x \n", AutochkPartition[i], AutochkStatus ));
                        SpStartScreen( SP_SCRN_FATAL_ERROR_AUTOCHK_FAILED,
                                       3,
                                       HEADER_HEIGHT+1,
                                       FALSE,
                                       FALSE,
                                       DEFAULT_ATTRIBUTE,
                                       DriveLetterString );

                        SpDisplayStatusOptions( DEFAULT_STATUS_ATTRIBUTE,
                                                SP_STAT_F3_EQUALS_EXIT,
                                                0 );
                        SpInputDrain();
                        while( SpInputGetKeypress() != KEY_F3 );

                        //
                        // The third arg of SpDone is TRUE to provide 15
                        // seconds before reboot. We don't want this during
                        // an uninstall.
                        //

                        SpDone( 0, FALSE, !Win9xRollback );

                    case CHKDSK_EXIT_ERRS_FIXED :
                        //
                        // Autochk was able to repair the partition, but will require a reboot.
                        //
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: autochk requires a reboot for %ls.\n", AutochkPartition[i]));
                        RebootRequired = TRUE;

                    default :
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Ran autochk.exe on %ls. \n", AutochkPartition[i] ));
                }

            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to run autochk.exe on %ls. Status = %x \n", AutochkPartition[i], Status ));
                SpStartScreen( Win9xRollback ? SP_SCRN_CANT_RUN_AUTOCHK_UNINSTALL : SP_SCRN_CANT_RUN_AUTOCHK,
                               3,
                               HEADER_HEIGHT+1,
                               FALSE,
                               FALSE,
                               DEFAULT_ATTRIBUTE,
                               DriveLetterString );

                SpDisplayStatusOptions( DEFAULT_STATUS_ATTRIBUTE,
                                        SP_STAT_ENTER_EQUALS_CONTINUE,
                                        0 );
                SpInputDrain();

                do {
                    InputChar = SpInputGetKeypress();
                } while (InputChar != ASCI_CR && (!Win9xRollback || InputChar != KEY_F3));

                if (InputChar == KEY_F3) {
                    SpDone (0, FALSE, FALSE);
                }

                //
                //  Put the screen back the way it was
                //
                CLEAR_CLIENT_SCREEN();
                SpDisplayScreen( SP_SCRN_RUNNING_AUTOCHK, 3, 4 );
                if( UserModeGauge != NULL ) {
                    SpDrawGauge( UserModeGauge );
                }
            }
        }
    }

    //
    //  The gauge is no longer needed.
    //
    SpDestroyGauge( UserModeGauge );
    UserModeGauge = NULL;

    if (WinntPartition != NULL) {
        SpMemFree( WinntPartition );
    }
    if (SystemPartition != NULL) {
        SpMemFree( SystemPartition );
    }
    SpMemFree( AutochkPath );

    CLEAR_CLIENT_SCREEN();

    if (RebootRequired) {
#ifdef _X86_
        //
        // If we are trying to cancel a setup that is in-progress, make sure
        // that the textmode option is removed from boot.ini, but the textmode
        // option that has /rollback is left in-place.
        //

        if (Win9xRollback) {
            SpRemoveExtraBootIniEntry();
            SpAddRollbackBootOption (TRUE);
            SpFlushBootVars();
        }
#endif

        if (TargetPath && TargetPath[0] && NTUpgrade == UpgradeFull) {
          SpSetUpgradeStatus(
           WinntPartitionRegion,
           TargetPath,
           UpgradeNotInProgress
           );
        }

        //
        // If this is not an unattended case let the user see the
        // error message and confirm it.
        //
        if (!UnattendedOperation) {
          SpStartScreen( SP_SCRN_AUTOCHK_REQUIRES_REBOOT,
                         3,
                         HEADER_HEIGHT+1,
                         TRUE,
                         TRUE,
                         DEFAULT_ATTRIBUTE );

          SpDisplayStatusOptions( DEFAULT_STATUS_ATTRIBUTE,
                                  SP_STAT_F3_EQUALS_REBOOT,
                                  0 );
          SpInputDrain();
          while( SpInputGetKeypress() != KEY_F3 );
        }

        if (IsNEC_98) { //NEC98
            Nec98RestoreBootFiles = FALSE;
        } //NEC98

        SpDone(SP_SCRN_AUTOCHK_REQUIRES_REBOOT, FALSE, TRUE );
    }
}


BOOLEAN
SppPromptOptionalAutochk(
    IN PVOID SifHandle,
    IN PWSTR MediaShortname,
    IN PWSTR DiskDevicePath
    )
{
    PWSTR             Tagfile,Description,Directory;
    NTSTATUS          Status;
    UNICODE_STRING    UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK   IoStatusBlock;
    HANDLE            Handle;
    ULONG ValidKeys[4] = { KEY_F3, ASCI_CR, ASCI_ESC, 0 };
    BOOLEAN           AutochkChosen;


    SpGetSourceMediaInfo(SifHandle,MediaShortname,&Description,&Tagfile,&Directory);

    //
    // We initially see if the media is in the drive, and if not, we give
    // the user a message with the option of skipping autochk.  We
    // do this now, so that the user doesn't simply get a disk prompt with
    // a Cancel option (Cancel what?  Autochk?  The whole repair process?)
    //
    wcscpy(TemporaryBuffer, DiskDevicePath);
    SpConcatenatePaths(TemporaryBuffer, Tagfile);
    INIT_OBJA(&ObjectAttributes, &UnicodeString, TemporaryBuffer);
    Status = ZwCreateFile(
                &Handle,
                FILE_GENERIC_READ,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ,
                FILE_OPEN,
                0,
                NULL,
                0
                );

    //
    // If we got back success, then we're done.
    //
    if(NT_SUCCESS(Status)) {
        ZwClose(Handle);
        return TRUE;
    }

    //
    // The media isn't currently in the drive, so give the
    // user the option of whether to run autochk or not.
    //
    AutochkChosen = FALSE;
    do {
        SpDisplayScreen(SP_SCRN_AUTOCHK_OPTION, 3, HEADER_HEIGHT+1);

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_F3_EQUALS_EXIT,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            SP_STAT_ESC_EQUALS_CANCEL,
            0
            );

        switch(SpWaitValidKey(ValidKeys, NULL, NULL)) {
        case ASCI_ESC:
            return FALSE;
        case KEY_F3:
            SpConfirmExit();
            break;
        case ASCI_CR:
            AutochkChosen = TRUE;
        }
    } while(!AutochkChosen);

    //
    // Prompt for the disk, based on the setup media type.
    //
    return(SpPromptForDisk(Description, DiskDevicePath, Tagfile, FALSE, TRUE, TRUE, NULL));
}


PWSTR
SpMakePlatformSpecificSectionName(
    IN PWSTR SectionName
    )
{
    PWSTR p;

    p = SpMemAlloc((wcslen(SectionName) + wcslen(PlatformExtension) + 1) * sizeof(WCHAR));

    wcscpy(p,SectionName);
    wcscat(p,PlatformExtension);

    return(p);
}

NTSTATUS
SpRunAutoFormat(
    IN HANDLE       MasterSifHandle,
    IN PWSTR        RegionDescription,
    IN PDISK_REGION PartitionRegion,
    IN ULONG        FilesystemType,
    IN BOOLEAN      QuickFormat,
    IN DWORD        ClusterSize,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice
    )

/*++

Routine Description:

    Run autofmt to format a partition.

Arguments:

    MasterSifHandle         - Handle to txtsetup.sif.

    RegionDescription       - The region description, as displayed to the
                              user, in the screen with the various partitions
                              for the user to choose.

    PartitionRegion         - Pointer to the structure that describes the
                              partition to be formatted.

    FilesystemType          - Indicates the file system to use.

    ClusterSize             - File system cluster-size to use. (0=>Use default)

    SetupSourceDevicePath   - NT device path where autochk.exe is located

    DirectoryOnSourceDevice - Directory on that device where autochk.exe is located

Return Value:

    None.

--*/

{
    PWSTR           MediaShortName;
    PWSTR           MediaDirectory;
    PWSTR           AutofmtPath;
    ULONG           AutofmtStatus;
    NTSTATUS        Status;
    WCHAR           AutofmtArgument[32];
    PWSTR           PartitionPath;
    LARGE_INTEGER   DelayTime;
    ULONG           PartitionOrdinal;


    ASSERT( ( FilesystemType == FilesystemNtfs ) ||
            ( FilesystemType == FilesystemFat32) ||
            ( FilesystemType == FilesystemFat  ) );

    //
    // Make SURE it's not partition0!  The results of formatting partition0
    // are so disasterous that this warrants a special check.
    //
    PartitionOrdinal = SpPtGetOrdinal(PartitionRegion,PartitionOrdinalCurrent);

    if(!PartitionOrdinal) {
        SpBugCheck(
            SETUP_BUGCHECK_PARTITION,
            PARTITIONBUG_B,
            PartitionRegion->DiskNumber,
            0
            );
    }

    //
    // Get the device path of the partition to format
    //
    SpNtNameFromRegion(
        PartitionRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );
    PartitionPath = SpDupStringW(TemporaryBuffer);

    CLEAR_CLIENT_SCREEN();

    //
    //  Prepair to run autofmt
    //
    MediaShortName = SpLookUpValueForFile(
                        MasterSifHandle,
                        L"autofmt.exe",
                        INDEX_WHICHMEDIA,
                        TRUE
                        );

    //
    // Prompt the user to insert the setup media.
    //
    SpPromptForSetupMedia(
        MasterSifHandle,
        MediaShortName,
        SetupSourceDevicePath
        );

    SpGetSourceMediaInfo(MasterSifHandle,MediaShortName,NULL,NULL,&MediaDirectory);

    wcscpy( TemporaryBuffer, SetupSourceDevicePath );
    SpConcatenatePaths( TemporaryBuffer, DirectoryOnSourceDevice );
    SpConcatenatePaths( TemporaryBuffer, MediaDirectory );
    SpConcatenatePaths( TemporaryBuffer, L"autofmt.exe" );
    AutofmtPath = SpDupStringW( TemporaryBuffer );

    //
    // Run autofmt on the partition
    //

    CLEAR_CLIENT_SCREEN();
    //
    // Put up a screen indicating what we are doing.
    //
    SpStartScreen(
        SP_SCRN_SETUP_IS_FORMATTING,
        0,
        HEADER_HEIGHT + 3,
        TRUE,
        FALSE,
        DEFAULT_ATTRIBUTE,
        RegionDescription,
        HardDisks[PartitionRegion->DiskNumber].Description
        );

    SpvidClearScreenRegion(
        0,
        VideoVars.ScreenHeight-STATUS_HEIGHT,
        VideoVars.ScreenWidth,
        STATUS_HEIGHT,
        DEFAULT_STATUS_BACKGROUND
        );

    //
    //  Create and display the (global) gauge.
    //
    SpFormatMessage(
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        SP_TEXT_SETUP_IS_FORMATTING
        );

    UserModeGauge = SpCreateAndDisplayGauge( 100,
                                             0,
                                             VideoVars.ScreenHeight - STATUS_HEIGHT - (3*GAUGE_HEIGHT/2),
                                             TemporaryBuffer,
                                             NULL,
                                             GF_PERCENTAGE,
                                             0
                                             );


    //
    // Cheesy kludge below to wait 4 seconds before invoking autochk.exe
    // the first time. This was necessary because the cache manager delays
    // in closing the handle to system.log (opened by NT registry APIs when
    // we find NT's to upgrade)
    //
    DelayTime.HighPart = -1;
    DelayTime.LowPart  = (ULONG)-40000000;
    KeDelayExecutionThread (KernelMode, FALSE, &DelayTime);

    AutofmtStatus = AUTOFMT_EXIT_SUCCESS;

    if (ClusterSize > 0) {
        swprintf(AutofmtArgument, L"/a:%lu /t ", ClusterSize);
    }
    else {
        wcscpy(AutofmtArgument, L"/t ");
    }

    if (QuickFormat) {
        wcscat(AutofmtArgument, L"/Q ");
    }

    switch(FilesystemType) {
    case FilesystemNtfs:
        wcscat(AutofmtArgument, L"/fs:ntfs");
        break;
    case FilesystemFat32:
        wcscat(AutofmtArgument, L"/fs:fat32");
        break;
    case FilesystemFat:
    default:
        wcscat(AutofmtArgument, L"/fs:fat");
        break;
    }



    //
    //  Tell the IOCTL which disk is being examined.
    //
    CurrentDiskIndex = 0;

    //
    // For quick format, emulate as though progress is
    // being made
    //
    if (UserModeGauge && QuickFormat) {
        SpFillGauge(UserModeGauge, 20);
    }

    //
    //  Note that autofmt requires that the partition path comes
    //  before the autofmt switches
    //
    Status = SpExecuteImage( AutofmtPath,
                             &AutofmtStatus,
                             2,
                             PartitionPath,
                             AutofmtArgument
                           );

    //
    // For quick format, emulate as though progress is
    // being made
    //
    if (UserModeGauge && QuickFormat) {
        SpFillGauge(UserModeGauge, 100);

        //
        // wait for a second so that user can
        // see it filled
        //
        DelayTime.HighPart = -1;
        DelayTime.LowPart  = (ULONG)-10000000;
        KeDelayExecutionThread (KernelMode, FALSE, &DelayTime);
    }

    //
    //  Destroy the gauge
    //
    SpDestroyGauge( UserModeGauge );
    UserModeGauge = NULL;

    if( NT_SUCCESS( Status ) ) {
        //
        //  autofmt.exe was run.
        //  Find out if the partition was formatted.
        //
        KdPrint(("SETUP:AutoFormat Status : %lx\n", AutofmtStatus));

        switch(AutofmtStatus) {
            case AUTOFMT_EXIT_SUCCESS:
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Ran autofmt.exe on %ls. \n", PartitionPath ));
#if defined(_AMD64_) || defined(_X86_)
                if (!IsNEC_98) { //NEC98
                    //
                    // If we formatted C:, then clear the previous OS entry
                    // in boot.ini.
                    //
                    if(PartitionRegion == SpPtValidSystemPartition()) {
                        *OldSystemLine = '\0';
                    }
                } //NEC98
#endif // defined(_AMD64_) || defined(_X86_)
                break;

            // case AUTOFMT_EXIT_COULD_NOT_FORMAT :
            default:
                //
                //  autofmt was unable to format the partition
                //
                Status =  STATUS_UNSUCCESSFUL;
                break;

        }

    } else {
        //
        //  autofmt.exe didn't get executed.
        //  Display a fatal error message.
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to run autofmt.exe on %ls. Status = %x \n", PartitionPath, Status ));
        SpStartScreen( SP_SCRN_CANT_RUN_AUTOFMT,
                       3,
                       HEADER_HEIGHT+1,
                       FALSE,
                       FALSE,
                       DEFAULT_ATTRIBUTE );

        SpDisplayStatusOptions( DEFAULT_STATUS_ATTRIBUTE,
                                SP_STAT_F3_EQUALS_EXIT,
                                0 );
        SpInputDrain();
        while( SpInputGetKeypress() != KEY_F3 );
        SpDone( 0, FALSE, TRUE );
    }

    //
    //  Do the cleanup and return
    //
    SpMemFree( PartitionPath );
    SpMemFree( AutofmtPath );

    CLEAR_CLIENT_SCREEN();
    return( Status );
}

//
// NEC98
//

//
// On floppyless setup if user have canceled setup or setup be stoped by error
// occured,previous OS cann't boot to be written boot code and boot loader.
//

NTSTATUS
SpDeleteAndBackupBootFiles(
    BOOLEAN    RestoreBackupFiles,
    BOOLEAN    DeleteBackupFiles,
    BOOLEAN    DeleteRootDirFiles,
    BOOLEAN    RestorePreviousOs,
    BOOLEAN    ClearBootFlag
    )
{

    #define WINNT_BAK  L"$WIN_NT$.~BU"
    #define FILE_ATTRIBUTES_RHS (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_ARCHIVE)

    PWSTR DeleteRootFiles[] = {L"ntdetect.com",L"$ldr$",L"boot.ini",L"txtsetup.sif",L"ntldr",L"bootfont.bin",L"bootsect.dos"};
    PWSTR RestoreFiles[] = {L"boot.ini",L"ntdetect.com",L"ntldr"};
    WCHAR DevicePath[256],SourceFileName[256],TargetFileName[256],TmpFileName[256];
    UCHAR i;
    NTSTATUS status=0;
    PWSTR SetupSourceDevicePath,DirectoryOnSetupSource;

    SpdInitialize();

#if defined(_AMD64_) || defined(_X86_)

    if(RestorePreviousOs){

        //
        // IF bootsect.dos exist in boot path, setup restore previous OS bootcode.
        //
        // NOTE:When you modefied boot.ini for multi boot function if it is same NT boot partition
        //      and partition where is exiting bootsect.dos , setup restore DOS bootcode.
        //      Therefore NT on this partition is not boot forever.
        //
        SppRestoreBootCode();
    }

#endif // defined(_AMD64_) || defined(_X86_)

    if(DeleteRootDirFiles){

        //
        // Delete floppy less boot files in root.
        //

        for(i=0 ; i < ELEMENT_COUNT(DeleteRootFiles); i++) {

            wcscpy(TargetFileName,NtBootDevicePath);
            SpDeleteFile(TargetFileName, DeleteRootFiles[i], NULL);

        }


#if defined(_X86_)
        //
        // If we're on an x86, but it's *NOT* an ARC machine,
        // then there's no need for the arc loaders to be
        // present.
        //
        if( !SpIsArc() ) {
            wcscpy(TargetFileName,NtBootDevicePath);
            SpDeleteFile(TargetFileName, L"arcsetup.exe", NULL);
            wcscpy(TargetFileName,NtBootDevicePath);
            SpDeleteFile(TargetFileName, L"arcldr.exe", NULL);
        }
#endif // defined(_X86_)

    }

    //
    // If \BOOTSECT.NEC exists, restore it to \BOOTSECT.DOS.
    // BTY, winnt32 makes \BOOTSECT.DOS even if boot sector is for NT.(NEC98 only)
    //
    wcscpy(SourceFileName,NtBootDevicePath);
    SpConcatenatePaths(SourceFileName,L"\\");
    SpConcatenatePaths(SourceFileName,L"bootsect.nec");
    wcscpy(TargetFileName,NtBootDevicePath);
    SpConcatenatePaths(TargetFileName,L"\\");
    SpConcatenatePaths(TargetFileName,L"bootsect.dos");

    if(SpFileExists(SourceFileName,FALSE)) {

        if(SpFileExists(TargetFileName,FALSE)) {
            SpDeleteFile( TargetFileName, NULL, NULL);
        }
        SpRenameFile( SourceFileName, TargetFileName, FALSE );
    }

    if(RestoreBackupFiles){

        //
        // Restore previous NT files to root form $WIN_NT$.~BU.
        //
        for(i=0 ; i < ELEMENT_COUNT(RestoreFiles) ;i++) {

            wcscpy(SourceFileName,NtBootDevicePath);
            SpConcatenatePaths(SourceFileName,WINNT_BAK);
            SpConcatenatePaths(SourceFileName,RestoreFiles[i]);
            wcscpy(TargetFileName,NtBootDevicePath);
            SpConcatenatePaths(TargetFileName,L"\\");
            SpConcatenatePaths(TargetFileName,RestoreFiles[i]);

            if( SpFileExists( SourceFileName, FALSE ) ) {
                SpCopyFileUsingNames(SourceFileName,TargetFileName,FILE_ATTRIBUTES_RHS,0L);
            }

        }

        //
        // Force uncompressd to "\ntldr".
        //
        wcscpy(TargetFileName,NtBootDevicePath);
        SpConcatenatePaths(TargetFileName,L"\\");
        SpConcatenatePaths(TargetFileName,L"ntldr");

        if( SpFileExists( TargetFileName, FALSE ) ) {
            SpVerifyNoCompression(TargetFileName);
        }

    }

    if(DeleteBackupFiles){

        //
        // Delete files in $WIN_NT$.~BU.
        //
        for(i=0 ; i < ELEMENT_COUNT(RestoreFiles); i++) {

            wcscpy(TargetFileName,NtBootDevicePath);
            SpConcatenatePaths(TargetFileName,WINNT_BAK);
            SpDeleteFile(TargetFileName, RestoreFiles[i], NULL);


        }

        //
        // Delete $WIN_NT$.~BU
        //
        wcscpy(TargetFileName,NtBootDevicePath);
        SpConcatenatePaths(TargetFileName,WINNT_BAK);
        if( SpFileExists( TargetFileName, FALSE ) ) {
            SpDeleteFile(TargetFileName, NULL, NULL);
        }

#if NEC_TEST //0
        //
        // It's not available to delete $WIN_NT.~BT, but we will try
        // to delete $WIN_NT$.~LS, Because Nec98 will boot back after F.3
        //
        if (WinntSetup && !WinntFromCd && !RemoteBootSetup && LocalSourceRegion) {
            SpGetWinntParams(&SetupSourceDevicePath,&DirectoryOnSetupSource);
            wcscpy(TargetFileName,SetupSourceDevicePath);
            SpConcatenatePaths(TargetFileName,DirectoryOnSetupSource);
            if( SpFileExists( TargetFileName, FALSE ) ) {
                SpDeleteFile(TargetFileName, NULL, NULL);
            }
        }
#endif //NEC_TEST
    }

    //if(ClearBootFlag && TmpTargetRegion){
    if(ClearBootFlag){

        SpSetAutoBootFlag(NULL,FALSE);
    }

    SpdTerminate();
    return(status);
}


BOOLEAN
SpFindServiceInList(
    IN PWSTR ServiceName
    )
{
    LIST_ENTRY *Next;
    PSERVICE_ENTRY ServiceEntry;


    Next = SpServiceList.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&SpServiceList) {
        ServiceEntry = CONTAINING_RECORD( Next, SERVICE_ENTRY, Next );
        Next = ServiceEntry->Next.Flink;
        if (_wcsicmp( ServiceEntry->ServiceName, ServiceName ) == 0) {
            return TRUE;
        }
    }

    return FALSE;
}


BOOLEAN
AddServiceToList(
    IN PWSTR ServiceName
    )
{
    PSERVICE_ENTRY ServiceEntry;


    if (SpFindServiceInList(ServiceName)) {
        return TRUE;
    }

    ServiceEntry = (PSERVICE_ENTRY) SpMemAlloc( sizeof(SERVICE_ENTRY) );
    if (ServiceEntry == NULL) {
        return FALSE;
    }

    ServiceEntry->ServiceName = SpDupStringW( ServiceName );
    InsertTailList( &SpServiceList, &ServiceEntry->Next );

    return TRUE;
}


BOOLEAN
SpFindServiceDependencies(
    IN HANDLE ServicesHandle,
    IN PWSTR ServiceName,
    IN PWSTR ServiceDependName
    )
{
    NTSTATUS Status;
    HANDLE KeyHandle;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    PKEY_VALUE_PARTIAL_INFORMATION ValInfo;
    ULONG ResultLength;
    PWSTR SubkeyName;
    PWSTR s;
    BOOLEAN rVal = FALSE;


    INIT_OBJA( &Obja, &UnicodeString, ServiceName );
    Obja.RootDirectory = ServicesHandle;
    Status = ZwOpenKey( &KeyHandle, KEY_READ, &Obja );
    if (!NT_SUCCESS(Status)) {
        return rVal;
    }

    ValInfo = (PKEY_VALUE_PARTIAL_INFORMATION) TemporaryBuffer;
    RtlInitUnicodeString( &UnicodeString, L"DependOnService");

    Status = ZwQueryValueKey(
        KeyHandle,
        &UnicodeString,
        KeyValuePartialInformation,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        &ResultLength
        );
    if (!NT_SUCCESS(Status)) {
        ZwClose( KeyHandle );
        return rVal;
    }

    if (ValInfo->Type == REG_MULTI_SZ) {
        s = (PWSTR)ValInfo->Data;
        while (s && *s) {
            SubkeyName = SpDupStringW( s );

            if (SubkeyName) {
                if (_wcsicmp( ServiceDependName, SubkeyName ) == 0) {
                    if (AddServiceToList( ServiceName )) {
                        rVal = TRUE;
                    }
                } else if (SpFindServiceDependencies( ServicesHandle, SubkeyName, ServiceDependName )) {
                    if (AddServiceToList( ServiceName )) {
                        rVal = TRUE;
                    }
                }
                SpMemFree( SubkeyName );
            }

            s = s + ((wcslen(s)+1)*sizeof(WCHAR));
        }
    } else if (ValInfo->Type == REG_SZ) {
        SubkeyName = SpDupStringW( (PWSTR)ValInfo->Data );
        if (_wcsicmp( ServiceDependName, SubkeyName ) == 0) {
            if (AddServiceToList( ServiceName )) {
                rVal = TRUE;
            }
        } else if (SpFindServiceDependencies( ServicesHandle, SubkeyName, ServiceDependName )) {
            if (AddServiceToList( ServiceName )) {
                rVal = TRUE;
            }
        }
        SpMemFree( SubkeyName );
    }

    ZwClose( KeyHandle );
    return rVal;
}



NTSTATUS
SpGetServiceTree(
    IN PWSTR ServiceName
    )
{
    NTSTATUS Status;
    HANDLE KeyHandle = NULL;
    HANDLE ServicesHandle = NULL;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    ULONG ResultLength;
    ULONG SubKeyIndex;
    PKEY_BASIC_INFORMATION KeyInfo;
    PWSTR SubkeyName;


    InitializeListHead( &SpServiceList );

    RtlInitUnicodeString( &UnicodeString, REGKEY_SERVICES );
    InitializeObjectAttributes( &Obja, &UnicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL );

    Status = ZwOpenKey( &ServicesHandle, KEY_READ, &Obja );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    for (SubKeyIndex=0,KeyInfo=(PKEY_BASIC_INFORMATION)TemporaryBuffer;
         NT_SUCCESS( ZwEnumerateKey( ServicesHandle,
                        SubKeyIndex,
                        KeyBasicInformation,
                        TemporaryBuffer,
                        sizeof(TemporaryBuffer), &ResultLength ) );
         SubKeyIndex++
         )
    {
        KeyInfo->Name[KeyInfo->NameLength/sizeof(WCHAR)] = 0;
        SubkeyName = SpDupStringW(KeyInfo->Name);

        if (SubkeyName) {
            SpFindServiceDependencies( ServicesHandle,
                SubkeyName,
                ServiceName );

            SpMemFree( SubkeyName );
        }
    }

    ZwClose( ServicesHandle );

    return Status;
}


VOID
SpCreateNewGuid(
    IN GUID *Guid
    )
/*++

Routine Description:

    Creates a new pseudo GUID

Arguments:

    Guid    -   Place holder for the new pseudo

Return Value:

    None.

--*/
{
    if (Guid) {
        LARGE_INTEGER   Time;
        ULONG Random1 = RtlRandom(&RandomSeed);
        ULONG Random2 = RtlRandom(&RandomSeed);

        //
        // Get system time
        //
        KeQuerySystemTime(&Time);

        RtlZeroMemory(Guid, sizeof(GUID));

        //
        // First 8 bytes is system time
        //
        RtlCopyMemory(Guid, &(Time.QuadPart), sizeof(Time.QuadPart));

        //
        // Next 8 bytes are two random numbers
        //
        RtlCopyMemory(Guid->Data4, &Random1, sizeof(ULONG));

        RtlCopyMemory(((PCHAR)Guid->Data4) + sizeof(ULONG),
            &Random2, sizeof(ULONG));

#if 0
        {
            WCHAR   GuidStr[256];

            KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                "SETUP: SpCreateNewGuid : %ws\n",
                SpPtGuidToString(Guid, GuidStr)));
        }
#endif
    }
}


NTSTATUS
RegisterSetupProgressCallback(
    IN TM_SETUP_PROGRESS_CALLBACK Callback,
    IN PVOID Context
    )

/*++

Routine Description:

    Registers the given callback function to
    post setup progress events

Arguments:

    Callback - The callback function

    Context  - Caller specified, context for the callback function
               that needs to sent with each event

Return Value:

    STATUS_SUCCESS if successful, otherwise appropriate
    error code.

--*/
{
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;

    if (Callback) {
        if (ProgressSubscribersCount < MAX_SETUP_PROGRESS_SUBSCRIBERS) {
            ProgressSubscribers[ProgressSubscribersCount].Callback = Callback;
            ProgressSubscribers[ProgressSubscribersCount].Context = Context;
            ProgressSubscribersCount++;
            Callback(CallbackEvent, CallbackInitialize, Context, NULL);
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_NO_MEMORY;
        }
    }

    return Status;
}

NTSTATUS
DeregisterSetupProgressCallback(
    IN TM_SETUP_PROGRESS_CALLBACK Callback,
    IN PVOID Context
    )
/*++

Routine Description:

    Deregisters the given callback function to
    quit posting setup progress events

Arguments:

    Callback - The callback function

    Context  - Caller specified, context for the callback function
               that needs to sent with each event

Return Value:

    STATUS_SUCCESS if successful, otherwise appropriate
    error code.

--*/
{
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;

    if (Callback) {
        ULONG Index;

        for (Index = 0; Index < MAX_SETUP_PROGRESS_SUBSCRIBERS; Index++) {
            if (ProgressSubscribers[Index].Callback == Callback) {
                ProgressSubscribers[Index].Callback = NULL;
                ProgressSubscribers[Index].Context = NULL;
                ProgressSubscribersCount--;
                Index++;

                //
                // Compact the array
                //
                while ((Index < MAX_SETUP_PROGRESS_SUBSCRIBERS) &&
                       (ProgressSubscribers[Index].Callback)) {
                    ProgressSubscribers[Index - 1] = ProgressSubscribers[Index];
                    Index++;
                }

                //
                // Indicate the callback is going away
                //
                Callback(CallbackEvent, CallbackDeInitialize, Context, NULL);

                Status = STATUS_SUCCESS;

                break;
            }
        }
    }

    return Status;
}

VOID
SendSetupProgressEvent(
    IN TM_SETUP_MAJOR_EVENT MajorEvent,
    IN TM_SETUP_MINOR_EVENT MinorEvent,
    IN PVOID EventData
    )
/*++

Routine Description:

    Post the specified events and the associated data to
    all the registered parties interested in setup progress
    events.

Arguments:

    MajorEvent - Setup progress major event

    MinorEvent - Setup progress minor event, w.r.t to the
                 major event type

    EventData  - The associated event data with the specified
                 Major and Minor event pair

Return Value:

    None.

--*/

{
    ULONG Index;

    for (Index = 0; Index < ProgressSubscribersCount; Index++) {
        ASSERT(ProgressSubscribers[Index].Callback != NULL);

        ProgressSubscribers[Index].Callback(MajorEvent,
                MinorEvent,
                ProgressSubscribers[Index].Context,
                EventData);
    }
}

ULONG
SpGetHeaderTextId(
    VOID
    )
/*++

Routine Description:

    Retreives the appropriate product type title id based on the system.

Arguments:

    None.

Return Value:

    Text ID for the product.  This ID may be found in usetup.exe

--*/
{
    ULONG HeaderTextId;

    if (AdvancedServer) {
        HeaderTextId = SP_HEAD_SRV_SETUP;

        if (SpIsProductSuite(VER_SUITE_BLADE)) {
            HeaderTextId = SP_HEAD_BLA_SETUP;
        }
		
        if (SpIsProductSuite(VER_SUITE_SMALLBUSINESS_RESTRICTED)) {
            HeaderTextId = SP_HEAD_SBS_SETUP;
        }
 
	if (SpIsProductSuite(VER_SUITE_ENTERPRISE)) {
            HeaderTextId = SP_HEAD_ADS_SETUP;
        }

        if (SpIsProductSuite(VER_SUITE_DATACENTER)) {
            HeaderTextId = SP_HEAD_DTC_SETUP;
        }
    } else {
        HeaderTextId = SP_HEAD_PRO_SETUP;

        if (SpIsProductSuite(VER_SUITE_PERSONAL)) {
            HeaderTextId = SP_HEAD_PER_SETUP;
        }
    }

    return(HeaderTextId);

}

NTSTATUS
SpGetVersionFromStr(
    IN  PWSTR   VersionStr,
    OUT PDWORD  Version,        // major * 100 + minor
    OUT PDWORD  BuildNumber
    )
/*++

Routine Description:

    Converts the given version string major.minor.build#.sp#
    (e.g. 5.0.2195.1) to the two dwords

Arguments:

    VersionStr  : The version string
    Version     : Place holder for receiving major & minor version
                  (major * 100 + minor)
    BuildNumber : Place holder for receiving build number

Return Value:

    STATUS_SUCCESS if successful otherwise appropriate error code

--*/
{
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;

    if (VersionStr && (Version || BuildNumber)) {
        DWORD MajorVer = 0, MinorVer = 0, BuildNum = 0;
        WCHAR *EndPtr = NULL;
        WCHAR *EndChar = NULL;
        WCHAR TempBuff[64] = {0};

        EndPtr = wcschr(VersionStr, TEXT('.'));

        if (EndPtr) {
            wcsncpy(TempBuff, VersionStr, (EndPtr - VersionStr));
            MajorVer = SpStringToLong(TempBuff, &EndChar, 10);

            VersionStr = EndPtr + 1;

            if (VersionStr) {
                EndPtr = wcschr(VersionStr, TEXT('.'));

                if (EndPtr) {
                    memset(TempBuff, 0, sizeof(TempBuff));
                    wcsncpy(TempBuff, VersionStr, (EndPtr - VersionStr));
                    MinorVer = SpStringToLong(TempBuff, &EndChar, 10);

                    VersionStr = EndPtr + 1;

                    if (VersionStr) {
                        EndPtr = wcschr(VersionStr, TEXT('.'));

                        if (EndPtr) {
                            memset(TempBuff, 0, sizeof(TempBuff));
                            wcsncpy(TempBuff, VersionStr, (EndPtr - VersionStr));
                            Build