;
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str,  "\\511.tmp" ), strcat( Str2,  "\\511.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str,  "\\512.tmp" ), strcat( Str2,  "\\512.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str,  "\\513.tmp" ), strcat( Str2,  "\\513.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\1023.tmp" ), strcat( Str2, "\\1023.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\1024.tmp" ), strcat( Str2, "\\1024.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\1025.tmp" ), strcat( Str2, "\\1025.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\4095.tmp" ), strcat( Str2, "\\4095.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\4096.tmp" ), strcat( Str2, "\\4096.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\4097.tmp" ), strcat( Str2, "\\4097.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\8191.tmp" ), strcat( Str2, "\\8191.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\8192.tmp" ), strcat( Str2, "\\8192.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\8193.tmp" ), strcat( Str2, "\\8193.tmq" ) );
#ifdef BIG
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\40970.tmp" ), strcat( Str2, "\\40970.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\81910.tmp" ), strcat( Str2, "\\81910.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\409700.tmp" ), strcat( Str2, "\\409700.tmq" ) );
#endif

//        Directory( Prefix );

        DbgPrint( "%s: Appending ....\n", Prefix );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str,    "\\0.tmp" ), strcat( Str2,    "\\0.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str,    "\\1.tmp" ), strcat( Str2,    "\\1.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str,  "\\511.tmp" ), strcat( Str2,  "\\511.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str,  "\\512.tmp" ), strcat( Str2,  "\\512.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str,  "\\513.tmp" ), strcat( Str2,  "\\513.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\1023.tmp" ), strcat( Str2, "\\1023.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\1024.tmp" ), strcat( Str2, "\\1024.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\1025.tmp" ), strcat( Str2, "\\1025.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\4095.tmp" ), strcat( Str2, "\\4095.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\4096.tmp" ), strcat( Str2, "\\4096.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\4097.tmp" ), strcat( Str2, "\\4097.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\8191.tmp" ), strcat( Str2, "\\8191.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\8192.tmp" ), strcat( Str2, "\\8192.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\8193.tmp" ), strcat( Str2, "\\8193.tmq" ) );
#ifdef BIG
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\40970.tmp" ), strcat( Str2, "\\40970.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\81910.tmp" ), strcat( Str2, "\\81910.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\409700.tmp" ), strcat( Str2, "\\409700.tmq" ) );
#endif

//        Directory( Prefix );

        DbgPrint( "%s: Deleteing ....\n", Prefix );
        strcpy( Str, Prefix ); Delete( strcat( Str,    "\\0.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,    "\\1.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,  "\\511.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,  "\\512.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,  "\\513.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\1023.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\1024.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\1025.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\4095.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\4096.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\4097.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\8191.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\8192.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\8193.tmp" ) );
#ifdef BIG
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\40970.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\81910.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\409700.tmp" ) );
#endif

//        Directory( Prefix );

    }

    DbgPrint( "%s: Done.\n", Prefix );

    Quit();

    NtTerminateThread(NtCurrentThread(), STATUS_SUCCESS);

    return; // TRUE;

}
#ifdef undef
VOID
FatMain()
{
    NTSTATUS Status;

    //
    // Wait for wakeup
    //

    if (!NT_SUCCESS(Status = NtWaitForSingleObject( StartSignal, TRUE, NULL))) {
        WaitForSingleObjectError( Status );
        return;
    }

    DbgPrint("Here Captain, number 0x%x.\n",
             (ULONG)NtCurrentTeb()->ClientId.UniqueThread);

    NtTerminateThread(NtCurrentThread(), STATUS_SUCCESS);
}
#endif

VOID
Upcase (
    IN OUT PUCHAR String
    )
{
    while (*String != '\0') {
        *String = (UCHAR)toupper(*String);
        String += 1;
    }
}


VOID Append(
    IN PCHAR FromName,
    IN PCHAR ToName
    )
{
    NTSTATUS Status;
    CHAR Buffer[BUFFERSIZE];

    HANDLE FromFileHandle;
    HANDLE ToFileHandle;

    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;

    LARGE_INTEGER ByteOffset;
    LARGE_INTEGER EofOffset;
    ULONG LogLsn;

    simprintf("Append ", 0);
    simprintf(FromName, 0);
    simprintf(" ", 0);
    simprintf(ToName, 0);
    simprintf("\n", 0);

    //
    //  Open the From file for read access
    //

//    RtlInitString( &NameString, FromName );

    RtlDosPathNameToNtPathName( FromName, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FromFileHandle,
                               FILE_READ_DATA,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status, FromName );
        return;
    }

    RtlFreeUnicodeString( &NameString );

    //
    //  Open the To file for write access
    //

//    RtlInitString( &NameString, ToName );

    RtlDosPathNameToNtPathName( ToName, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &ToFileHandle,
                               FILE_WRITE_DATA,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status, ToName );
        return;
    }

    RtlFreeUnicodeString( &NameString );

    //
    //  Now append the files
    //

    ByteOffset = LiFromLong( 0 );
    EofOffset = LiFromLong( FILE_WRITE_TO_END_OF_FILE );

    for (LogLsn = 0; TRUE; LogLsn += BUFFERSIZE/512) {

        ULONG ReadLength;

        //
        //  Read the next logical sectors in
        //

        ByteOffset.LowPart = LogLsn * 512;

        if (!NT_SUCCESS(Status = NtReadFile( FromFileHandle,
                                 (HANDLE)NULL,
                                 (PIO_APC_ROUTINE)NULL,
                                 (PVOID)NULL,
                                 &IoStatus,
                                 Buffer,
                                 BUFFERSIZE,
                                 &ByteOffset,
                                 (PULONG) NULL ))) {
            if (Status == STATUS_END_OF_FILE) {
                break;
            }
            ReadFileError( Status, FromName );
            break;
        }

        //
        //  Check how the read turned out
        //

        if (IoStatus.Status == STATUS_END_OF_FILE) {
            break;
        }
        CheckIoStatus( &IoStatus, BUFFERSIZE, TRUE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            break;
        }

        //
        //  Append the sectors to the To file
        //

        ReadLength = IoStatus.Information;
        if (!NT_SUCCESS(Status = NtWriteFile( ToFileHandle,
                                  (HANDLE)NULL,
                                  (PIO_APC_ROUTINE)NULL,
                                  (PVOID)NULL,
                                  &IoStatus,
                                  Buffer,
                                  IoStatus.Information,
                                  &EofOffset,
                                  (PULONG) NULL ))) {
            WriteFileError( Status, ToName );
            return;
        }

        //
        //  Check how the write turned out
        //

        CheckIoStatus( &IoStatus, ReadLength, FALSE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            IoStatusError( IoStatus.Status );
            break;
        }

        //
        //  If we didn't read or write a full buffer then the copy is done
        //

        if (IoStatus.Information < BUFFERSIZE) {
            break;
        }

    }

    if (!NT_SUCCESS(IoStatus.Status) && (IoStatus.Status != STATUS_END_OF_FILE)) {

        IoStatusError( IoStatus.Status );

    }

    //
    //  Close both files
    //

    if (!NT_SUCCESS(Status = NtClose( FromFileHandle ))) {
        CloseError( Status, FromName );
    }

    if (!NT_SUCCESS(Status = NtClose( ToFileHandle ))) {
        CloseError( Status, ToName );
    }

    //
    //  And return to our caller
    //

    return;

}


VOID Chmode(
    IN PCHAR Attrib,
    IN PCHAR String
    )
{
    CHAR Buffer[BUFFERSIZE];
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;

    ULONG FileAttribute;

    //
    //  Get the attribute
    //

    Upcase( (PUCHAR)Attrib );

    //
    //  Get the filename
    //

    simprintf("Chmode", 0);
    simprintf(String, 0);
    simprintf(" ", 0);
    simprintf(Attrib, 0);
    simprintf("\n", 0);

    //
    //  Decode the attributes
    //

    FileAttribute = 0;
    if (strpbrk(Attrib,"N") != NULL) {FileAttribute |= FILE_ATTRIBUTE_NORMAL;}
    if (strpbrk(Attrib,"R") != NULL) {FileAttribute |= FILE_ATTRIBUTE_READONLY;}
    if (strpbrk(Attrib,"H") != NULL) {FileAttribute |= FILE_ATTRIBUTE_HIDDEN;}
    if (strpbrk(Attrib,"S") != NULL) {FileAttribute |= FILE_ATTRIBUTE_SYSTEM;}
    if (strpbrk(Attrib,"A") != NULL) {FileAttribute |= FILE_ATTRIBUTE_ARCHIVE;}

    //
    //  Open the file for write attributes access
    //

//    RtlInitString( &NameString, String );

    RtlDosPathNameToNtPathName( String, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FileHandle,
                               FILE_WRITE_ATTRIBUTES,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status, String );
        return;
    }

    //
    //  Change the file attributes
    //

    ((PFILE_BASIC_INFORMATION)&Buffer[0])->CreationTime.HighPart = 0;
    ((PFILE_BASIC_INFORMATION)&Buffer[0])->CreationTime.LowPart = 0;

    ((PFILE_BASIC_INFORMATION)&Buffer[0])->LastAccessTime.HighPart = 0;
    ((PFILE_BASIC_INFORMATION)&Buffer[0])->LastAccessTime.LowPart = 0;

    ((PFILE_BASIC_INFORMATION)&Buffer[0])->LastWriteTime.HighPart = 0;
    ((PFILE_BASIC_INFORMATION)&Buffer[0])->LastWriteTime.LowPart = 0;

    ((PFILE_BASIC_INFORMATION)&Buffer[0])->FileAttributes = FileAttribute;

    if (!NT_SUCCESS(Status = NtSetInformationFile( FileHandle,
                                       &IoStatus,
                                       Buffer,
                                       sizeof(FILE_BASIC_INFORMATION),
                                       FileBasicInformation))) {
        SetInformationFileError( Status );
    }

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status, String );
    }

    //
    //  And return to our caller
    //

    RtlFreeUnicodeString( &NameString );

    return;

}


VOID Copy(
    IN PCHAR FromName,
    IN PCHAR ToName
    )
{
    CHAR Buffer[BUFFERSIZE];
    NTSTATUS Status;

    HANDLE FromFileHandle;
    HANDLE ToFileHandle;

    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;

    LARGE_INTEGER FromFileAllocation;

    LARGE_INTEGER ByteOffset;
    ULONG LogLsn;

    //
    //  Get both file names
    //

    simprintf("Copy ", 0);
    simprintf(FromName, 0);
    simprintf(" ", 0);
    simprintf(ToName, 0);
    simprintf("\n", 0);

    //
    //  Open the From file for read access
    //

//    RtlInitString( &NameString, FromName );

    RtlDosPathNameToNtPathName( FromName, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FromFileHandle,
                               FILE_READ_DATA | FILE_READ_ATTRIBUTES,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status, FromName );
        return;
    }

    RtlFreeUnicodeString( &NameString );

    //
    //  Get the size of the from file
    //

    if (!NT_SUCCESS(Status = NtQueryInformationFile( FromFileHandle,
                                         &IoStatus,
                                         Buffer,
                                         BUFFERSIZE,
                                         FileStandardInformation))) {
        QueryInformationFileError( Status );
        return;
    }
    FromFileAllocation = ((PFILE_STANDARD_INFORMATION)Buffer)->AllocationSize;

    //
    //  Create the To file
    //

//    RtlInitString( &NameString, ToName );

    RtlDosPathNameToNtPathName( ToName, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtCreateFile( &ToFileHandle,
                               FILE_WRITE_DATA,
                               &ObjectAttributes,
                               &IoStatus,
                               &FromFileAllocation,
                               FILE_ATTRIBUTE_NORMAL,
                               0L,
                               FILE_SUPERSEDE,
                               WriteThrough,
                               (PVOID)NULL,
                               0L ))) {
        CreateFileError( Status, ToName );
        return;
    }

    RtlFreeUnicodeString( &NameString );

    //
    //  Now copy the files
    //

    ByteOffset = LiFromLong( 0 );

    for (LogLsn = 0; TRUE; LogLsn += BUFFERSIZE/512) {

        ULONG ReadLength;

        //
        //  Read the next logical sectors in
        //

        ByteOffset.LowPart = LogLsn * 512;

        if (!NT_SUCCESS(Status = NtReadFile( FromFileHandle,
                                 (HANDLE)NULL,
                                 (PIO_APC_ROUTINE)NULL,
                                 (PVOID)NULL,
                                 &IoStatus,
                                 Buffer,
                                 BUFFERSIZE,
                                 &ByteOffset,
                                 (PULONG) NULL ))) {
            if (Status == STATUS_END_OF_FILE) {
                break;
            }
            ReadFileError( Status, FromName );
            break;
        }

        //
        //  Check how the read turned out
        //

        if (IoStatus.Status == STATUS_END_OF_FILE) {
            break;
        }
        CheckIoStatus( &IoStatus, BUFFERSIZE, TRUE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            break;
        }

        //
        //  Write the sectors out
        //

        ReadLength = IoStatus.Information;
        if (!NT_SUCCESS(Status = NtWriteFile( ToFileHandle,
                                  (HANDLE)NULL,
                                  (PIO_APC_ROUTINE)NULL,
                                  (PVOID)NULL,
                                  &IoStatus,
                                  Buffer,
                                  IoStatus.Information,
                                  &ByteOffset,
                                  (PULONG) NULL ))) {
            WriteFileError( Status, ToName );
            return;
        }

        //
        //  Check how the write turned out
        //

        CheckIoStatus( &IoStatus, ReadLength, FALSE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            IoStatusError( IoStatus.Status );
            break;
        }

        //
        //  If we didn't read or write a full buffer then the copy is done
        //

        if (IoStatus.Information < BUFFERSIZE) {
            break;
        }

    }

    if (!NT_SUCCESS(IoStatus.Status) && (IoStatus.Status != STATUS_END_OF_FILE)) {

        IoStatusError( IoStatus.Status );

    }

    //
    //  Close both files
    //

    if (!NT_SUCCESS(Status = NtClose( FromFileHandle ))) {
        CloseError( Status, FromName );
    }

    if (!NT_SUCCESS(Status = NtClose( ToFileHandle ))) {
        CloseError( Status, ToName );
    }

    //
    //  And return to our caller
    //

    return;

}


VOID Create(
    IN PCHAR String,
    IN ULONG Size
    )
{
    CHAR Buffer[BUFFERSIZE];
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;
    LARGE_INTEGER AllocationSize;

    LARGE_INTEGER ByteOffset;
    ULONG BufferLength;
    ULONG i;

    static CHAR FoxString[] = "The quick brown fox jumped over the lazy dog.\r\n";
    ULONG FoxLength;

    //
    //  Get the filename
    //

    simprintf("Create ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Create the new file
    //

    AllocationSize = LiFromUlong( Size );
//    RtlInitString( &NameString, String );

    RtlDosPathNameToNtPathName( String, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtCreateFile( &FileHandle,
                               FILE_WRITE_DATA,
                               &ObjectAttributes,
                               &IoStatus,
                               &AllocationSize,
                               FILE_ATTRIBUTE_NORMAL,
                               0L,
                               FILE_SUPERSEDE,
                               WriteThrough,
                               (PVOID)NULL,
                               0L ))) {
        CreateFileError( Status, String );
        return;
    }

    //
    //  create a test buffer to output
    //

    FoxLength = strlen(FoxString);
    for (i = FoxLength; i < BUFFERSIZE; i += FoxLength) {
        strcpy((PCHAR)&Buffer[i-FoxLength], FoxString);
    }
    BufferLength = i - FoxLength;

    //
    //  The main loop writes out the test buffer a BufferLength amount
    //  at a time
    //

    ByteOffset = LiFromLong( 0 );

    for (i = BufferLength; i < Size; i += BufferLength) {

        //
        //  Write the next buffer
        //

        ByteOffset.LowPart = i-BufferLength;

        if (!NT_SUCCESS(Status = NtWriteFile( FileHandle,
                                  (HANDLE)NULL,
                                  (PIO_APC_ROUTINE)NULL,
                                  (PVOID)NULL,
                                  &IoStatus,
                                  Buffer,
                                  BufferLength,
                                  &ByteOffset,
                                  (PULONG) NULL ))) {
            WriteFileError( Status, String );
            return;
        }

        //
        //  check how the write turned out
        //

        CheckIoStatus( &IoStatus, BufferLength, FALSE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            IoStatusError( IoStatus.Status );
            break;
        }

    }

    //
    //  Check for a residual to output
    //

    if (i - BufferLength < Size) {

        //
        //  Write out the residual buffer
        //

        ByteOffset.LowPart = i-BufferLength;

        if (!NT_SUCCESS(Status = NtWriteFile( FileHandle,
                                  (HANDLE)NULL,
                                  (PIO_APC_ROUTINE)NULL,
                                  (PVOID)NULL,
                                  &IoStatus,
                                  Buffer,
                                  Size - (i - BufferLength),
                                  &ByteOffset,
                                  (PULONG) NULL ))) {
            WriteFileError( Status, String );
            return;
        }

        //
        //  check how the write turned out
        //

        CheckIoStatus( &IoStatus, Size - (i - BufferLength), FALSE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            IoStatusError( IoStatus.Status );
        }

    }

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status, String );
    }

    //
    //  And return to our caller
    //

    RtlFreeUnicodeString( &NameString );

    return;

}


VOID DebugLevel()
{

#ifdef FATDBG
    //simprintf("Debug Trace Level %x\n", FatDebugTraceLevel);
#else
    //simprintf("System not compiled for debug tracing\n", 0);
#endif // FATDBG

    return;
}


VOID Delete(
    IN PCHAR String
    )
{
    CHAR Buffer[BUFFERSIZE];
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;

    //
    //  Get the filename
    //

    simprintf("Delete ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Open the file for delete access
    //

//    RtlInitString( &NameString, String );

    RtlDosPathNameToNtPathName( String, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtCreateFile( &FileHandle,
                               DELETE,
                               &ObjectAttributes,
                               &IoStatus,
                               (PLARGE_INTEGER)NULL,
                               0L,
                               0L,
                               FILE_OPEN,
                               WriteThrough,
                               (PVOID)NULL,
                               0L ))) {
        CreateFileError( Status, String );
        return;
    }

    //
    //  Mark the file for delete
    //

    ((PFILE_DISPOSITION_INFORMATION)&Buffer[0])->DeleteFile = TRUE;

    if (!NT_SUCCESS(Status = NtSetInformationFile( FileHandle,
                                       &IoStatus,
                                       Buffer,
                                       sizeof(FILE_DISPOSITION_INFORMATION),
                                       FileDispositionInformation))) {
        SetInformationFileError( Status );
        return;
    }

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status, String );
    }

    //
    //  And return to our caller
    //

    RtlFreeUnicodeString( &NameString );

    return;

}


VOID Directory(
    IN PCHAR String
    )
{
    CHAR Buffer[BUFFERSIZE];
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;

    NTSTATUS NtStatus;

    PFILE_ADIRECTORY_INFORMATION FileInfo;
//    ULONG i;

    //
    //  Get the filename
    //

    simprintf("Directory ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Open the file for list directory access
    //

//    RtlInitString( &NameString, String );

    RtlDosPathNameToNtPathName( String, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FileHandle,
                               FILE_LIST_DIRECTORY,
                               &ObjectAttributes,
                               &IoStatus,
                               FILE_SHARE_READ,
                               WriteThrough | FILE_DIRECTORY_FILE ))) {
        OpenFileError( Status, String );
        return;
    }

    //
    //  zero out the buffer so next time we'll recognize the end of data
    //

    RtlZeroMemory(Buffer, BUFFERSIZE);

    //
    //  Do the directory loop
    //

    for (NtStatus = NtQueryDirectoryFile( FileHandle,
                                          (HANDLE)NULL,
                                          (PIO_APC_ROUTINE)NULL,
                                          (PVOID)NULL,
                                          &IoStatus,
                                          Buffer,
                                          BUFFERSIZE,
                                          FileADirectoryInformation,
                                          FALSE,
                                          (PSTRING)NULL,
                                          TRUE);
         NT_SUCCESS(NtStatus);
         NtStatus = NtQueryDirectoryFile( FileHandle,
                                          (HANDLE)NULL,
                                          (PIO_APC_ROUTINE)NULL,
                                          (PVOID)NULL,
                                          &IoStatus,
                                          Buffer,
                                          BUFFERSIZE,
                                          FileADirectoryInformation,
                                          FALSE,
                                          (PSTRING)NULL,
                                          FALSE) ) {

        //
        //  Check the Irp for success
        //

        if (!NT_SUCCESS(IoStatus.Status)) {

            break;

        }

        //
        //  For every record in the buffer type out the directory information
        //

        //
        //  Point to the first record in the buffer, we are guaranteed to have
        //  one otherwise IoStatus would have been No More Files
        //

        FileInfo = (PFILE_ADIRECTORY_INFORMATION)&Buffer[0];

        while (TRUE) {

            //
            //  Lets put in some checks to make sure these are ok.
            //

            ASSERT(FileInfo->FileNameLength < MAXIMUM_FILENAME_LENGTH);
            ASSERT(FileInfo->NextEntryOffset < MAXIMUM_FILENAME_LENGTH+sizeof(FILE_ADIRECTORY_INFORMATION)+4);

            //
            //  Print out information about the file
            //

            simprintf("%8lx ", FileInfo->FileAttributes);
            simprintf("%8lx/", FileInfo->EndOfFile.LowPart);
            simprintf("%8lx ", FileInfo->AllocationSize.LowPart);

            {
                CHAR Saved;
                Saved = FileInfo->FileName[FileInfo->FileNameLength];
                FileInfo->FileName[FileInfo->FileNameLength] = 0;
                simprintf(FileInfo->FileName, 0);
                FileInfo->FileName[FileInfo->FileNameLength] = Saved;
            }

            simprintf("\n", 0);

            //
            //  Check if there is another record, if there isn't then we
            //  simply get out of this loop
            //

            if (FileInfo->NextEntryOffset == 0) {
                break;
            }

            //
            //  There is another record so advance FileInfo to the next
            //  record
            //

            FileInfo = (PFILE_ADIRECTORY_INFORMATION)(((PUCHAR)FileInfo) + FileInfo->NextEntryOffset);

        }

        //
        //  zero out the buffer so next time we'll recognize the end of data
        //

        RtlZeroMemory(Buffer, BUFFERSIZE);

    }

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status, String );
    }

    //
    //  And return to our caller
    //

    RtlFreeUnicodeString( &NameString );

    return;

}


VOID Mkdir(
    IN PCHAR String
    )
{
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;
    LARGE_INTEGER AllocationSize;

    //
    //  Get the filename
    //

    simprintf("Mkdir ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Create the new directory
    //

    AllocationSize = LiFromLong( 4 );
//    RtlInitString( &NameString, String );

    RtlDosPathNameToNtPathName( String, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtCreateFile( &FileHandle,
                               0,
                               &ObjectAttributes,
                               &IoStatus,
                               &AllocationSize,
                               0L,
                               0L,
                               FILE_CREATE,
                               WriteThrough | FILE_DIRECTORY_FILE,
                               (PVOID)NULL,
                               0L ))) {
        CreateFileError( Status, String );
        return;
    }

    //
    //  Now close the directory
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status, String );
    }

    //
    //  And return to our caller
    //

    RtlFreeUnicodeString( &NameString );

    return;

}


VOID Query(
    IN PCHAR String
    )
{
    CHAR Buffer[BUFFERSIZE];
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;
    ULONG i;

    PFILE_AALL_INFORMATION     AllInfo;
    PFILE_BASIC_INFORMATION    BasicInfo;
    PFILE_STANDARD_INFORMATION StandardInfo;
    PFILE_INTERNAL_INFORMATION InternalInfo;
    PFILE_EA_INFORMATION       EaInfo;
    PFILE_ACCESS_INFORMATION   AccessInfo;
    PFILE_ANAME_INFORMATION    NameInfo;

    //
    //  zero out the buffer so next time we'll recognize the end of data
    //

    for (i = 0; i < BUFFERSIZE; i += 1) { Buffer[i] = 0; }

    //
    //  Set up some local pointers
    //

    AllInfo      = (PFILE_AALL_INFORMATION)Buffer;
    BasicInfo    = &AllInfo->BasicInformation;
    StandardInfo = &AllInfo->StandardInformation;
    InternalInfo = &AllInfo->InternalInformation;
    EaInfo       = &AllInfo->EaInformation;
    AccessInfo   = &AllInfo->AccessInformation;
    NameInfo     = &AllInfo->NameInformation;

    //
    //  Get the filename
    //

    simprintf("Query ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Open the file for read attributes, read ea, and read control access
    //

//    RtlInitString( &NameString, String );

    RtlDosPathNameToNtPathName( String, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FileHandle,
                               FILE_READ_ATTRIBUTES | FILE_READ_EA | READ_CONTROL,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status, String );
        return;
    }

    //
    //  Query the file
    //

    if (!NT_SUCCESS(Status = NtQueryInformationFile( FileHandle,
                                         &IoStatus,
                                         Buffer,
                                         BUFFERSIZE,
                                         FileAAllInformation))) {
        QueryInformationFileError( Status );
        return;
    }

    //
    //  Output file name information
    //

    simprintf("\"", 0);
    simprintf(NameInfo->FileName, 0);
    simprintf("\"\n", 0);

    //
    //  Output the times
    //

    simprintf(" Create = ", 0); PrintTime( &BasicInfo->CreationTime ); simprintf("\n", 0);
    simprintf(" Access = ", 0); PrintTime( &BasicInfo->LastAccessTime ); simprintf("\n", 0);
    simprintf(" Write  = ", 0); PrintTime( &BasicInfo->LastWriteTime ); simprintf("\n", 0);

    //
    //  Output File size, and allocation size
    //

    simprintf(" Size  = %8lx\n", StandardInfo->EndOfFile.LowPart);
    simprintf(" Alloc = %8lx\n", StandardInfo->AllocationSize.LowPart);

    //
    //  Output File attributes, Device type, link count, and flags
    //

    simprintf(" Attrib  = %8lx\n", BasicInfo->FileAttributes);
//    simprintf(" DevType = %8lx\n", StandardInfo->DeviceType);
    simprintf(" Links   = %8lx\n", StandardInfo->NumberOfLinks);
    simprintf(" Dir     = %8lx\n", StandardInfo->Directory);
    simprintf(" Delete  = %8lx\n", StandardInfo->DeletePending);

    //
    //  Output the index number and ea size
    //

    simprintf(" Index   = %8lx\n", InternalInfo->IndexNumber.LowPart);
    simprintf(" EaSize  = %8lx\n", EaInfo->EaSize);

    //
    //  Output the file access flags
    //

    simprintf(" Flags = %8lx\n", AccessInfo->AccessFlags);

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status, String );
    }

    //
    //  And return to our caller
    //

    RtlFreeUnicodeString( &NameString );

    return;

}


VOID QVolume(
    IN PCHAR String
    )
{
    CHAR Buffer[BUFFERSIZE];
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;
    ULONG i;

    PFILE_FS_AVOLUME_INFORMATION VolumeInfo;

    //
    //  zero out the buffer so next time we'll recognize the end of data
    //

    for (i = 0; i < BUFFERSIZE; i += 1) { Buffer[i] = 0; }

    //
    //  Set up some local pointers
    //

    VolumeInfo = (PFILE_FS_AVOLUME_INFORMATION)Buffer;

    //
    //  Get the volume name
    //

    simprintf("QVolume ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Open the Volume for no access
    //

//    RtlInitString( &NameString, String );

    RtlDosPathNameToNtPathName( String, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FileHandle,
                               FILE_READ_ATTRIBUTES,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status, String );
        return;
    }

    //
    //  zero out the buffer so next time we'll recognize the end of data
    //

    for (i = 0; i < BUFFERSIZE; i += 1) { Buffer[i] = 0; }

    //
    //  Query the volume info
    //

    if (!NT_SUCCESS(Status = NtQueryVolumeInformationFile( FileHandle,
                                               &IoStatus,
                                               Buffer,
                                               BUFFERSIZE,
                                               FileAFsVolumeInformation))) {
        QueryVolumeInformationFileError( Status );
        return;
    }

    //
    //  Output Volume name information
    //

    simprintf("\"", 0);
    simprintf(VolumeInfo->VolumeLabel, 0);
    simprintf("\"\n", 0);

    //
    //  Output the volume serial number
    //

    simprintf(" SerialNum = %8lx\n", VolumeInfo->VolumeSerialNumber);

    //
    //  Now close the Volume
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status, String );
    }

    //
    //  And return to our caller
    //

    RtlFreeUnicodeString( &NameString );

    return;

}


VOID Rename()
{
    //simprintf("Rename not implemented\n", 0);
}


VOID SVolume(
    IN PCHAR String,
    IN PCHAR Label
    )
{
    CHAR Buffer[BUFFERSIZE];
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;
    ULONG i;

    PFILE_FS_ALABEL_INFORMATION LabelInfo;

    //
    //  zero out the buffer so next time we'll recognize the end of data
    //

    for (i = 0; i < BUFFERSIZE; i += 1) { Buffer[i] = 0; }

    //
    //  Set up some local pointers
    //

    LabelInfo = (PFILE_FS_ALABEL_INFORMATION)Buffer;

    //
    //  Get the volume name, and new label name
    //

    strcpy( LabelInfo->VolumeLabel, Label );

    LabelInfo->VolumeLabelLength = strlen(LabelInfo->VolumeLabel);

    if ((LabelInfo->VolumeLabelLength == 1) &&
        (LabelInfo->VolumeLabel[0] == '.')) {

        LabelInfo->VolumeLabelLength = 0;

    }

    simprintf("SVolume ", 0);
    simprintf(String, 0);
    simprintf(" ", 0);
    simprintf(LabelInfo->VolumeLabel, 0);
    simprintf("\n", 0);

    //
    //  Open the Volume for no access
    //

//    RtlInitString( &NameString, String );

    RtlDosPathNameToNtPathName( String, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FileHandle,
                               FILE_WRITE_ATTRIBUTES,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status, String );
        return;
    }

    //
    //  Set the volume info
    //

    if (!NT_SUCCESS(Status = NtSetVolumeInformationFile( FileHandle,
                                             &IoStatus,
                                             LabelInfo,
                                             BUFFERSIZE,
                                             FileAFsLabelInformation))) {
        SetVolumeInformationFileError( Status );
        return;
    }

    //
    //  Now close the Volume
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status, String );
    }

    //
    //  And return to our caller
    //

    RtlFreeUnicodeString( &NameString );

    return;

}


VOID Type(
    IN PCHAR String
    )
{
    CHAR Buffer[BUFFERSIZE];
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;

    LARGE_INTEGER ByteOffset;
    ULONG LogLsn;
    ULONG i;

    //
    //  Get the filename
    //

    simprintf("Type ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Open the file for read
    //

//    RtlInitString( &NameString, String );

    RtlDosPathNameToNtPathName( String, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FileHandle,
                               FILE_READ_DATA,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status, String );
        return;
    }

    //
    //  While there is data to be read we'll read a buffer and write it out
    //

    ByteOffset = LiFromLong( 0 );

    for (LogLsn = 0; TRUE; LogLsn += BUFFERSIZE/512) {

        //
        //  Read the next logical sector
        //

        ByteOffset.LowPart = LogLsn * 512;

        if (!NT_SUCCESS(Status = NtReadFile( FileHandle,
                                 (HANDLE)NULL,
                                 (PIO_APC_ROUTINE)NULL,
                                 (PVOID)NULL,
                                 &IoStatus,
                                 Buffer,
                                 BUFFERSIZE,
                                 &ByteOffset,
                                 (PULONG) NULL ))) {
            if (Status == STATUS_END_OF_FILE) {
                break;
            }
            ReadFileError( Status, String );
            break;
        }

        //
        //  check how the read turned out
        //

        if (IoStatus.Status == STATUS_END_OF_FILE) {
            break;
        }
        CheckIoStatus( &IoStatus, BUFFERSIZE, TRUE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            IoStatusError( IoStatus.Status );
            break;
        }

        //
        //  Write out the buffer
        //

        for (i = 0; i < IoStatus.Information; i += 1) {
            simprintf("%c", Buffer[i]);
        }

        //
        //  If we didn't read in a complete buffer then we're all done reading
        //  and can get out of here
        //

        if (IoStatus.Information < BUFFERSIZE) {
            break;
        }

    }

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status, String );
    }

    //
    //  And return to our caller
    //

    RtlFreeUnicodeString( &NameString );

    return;

}

VOID
Quit()
{
    simprintf("FatTest Exiting.\n", 0);
    return;
}


VOID
PrintTime (
    IN PLARGE_INTEGER Time
    )
{
    TIME_FIELDS TimeFields;

    static PCHAR Months[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
                            "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

    static PCHAR Days[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};

    RtlTimeToTimeFields( Time, &TimeFields );

    simprintf(" %4d-", TimeFields.Year);
    simprintf(Months[TimeFields.Month-1], 0);
    simprintf("-%2d", TimeFields.Day);

    simprintf(" %2d", TimeFields.Hour);
    simprintf(":%2d", TimeFields.Minute);
    simprintf(":%2d", TimeFields.Second);
    simprintf(".%3d (", TimeFields.Milliseconds);

    simprintf(Days[TimeFields.Weekday], 0);
    simprintf(")", 0);

    return;
}

VOID
WaitForSingleObjectError(
    IN NTSTATUS Status
    )
{
    DbgPrint(" WaitForSingleObject Error %X\n", Status);
}

VOID
CreateFileError(
    IN NTSTATUS Status,
    IN PUCHAR File
    )
{
    DbgPrint(" CreateFile Error %X on %s\n", Status, File);
}

VOID
OpenFileError(
    IN NTSTATUS Status,
    IN PUCHAR File
    )
{
    DbgPrint(" OpenFile Error %X on %s\n", Status, File);
}

VOID
ReadFileError(
    IN NTSTATUS Status,
    IN PUCHAR File
    )
{
    DbgPrint(" ReadFile Error %X on %s\n", Status, File);
}

VOID
WriteFileError(
    IN NTSTATUS Status,
    IN PUCHAR File
    )
{
    DbgPrint(" WriteFile Error %X on %s\n", Status, File);
}

VOID
CheckIoStatus(
    IN PIO_STATUS_BLOCK IoStatus,
    IN ULONG Length,
    IN BOOLEAN Read
    )
{
    if (!NT_SUCCESS(IoStatus->Status)) {
        DbgPrint(" IoStatus->Status Error %08lx\n", IoStatus->Status);
    }
    if ((!Read && (IoStatus->Information != Length))

            ||

        (Read && (IoStatus->Information > Length))) {

        DbgPrint(" IoStatus->Information Error %08lx\n", IoStatus->Information);
    }
}

VOID
SetInformationFileError(
    IN NTSTATUS Status
    )
{
    DbgPrint(" SetInfoFile Error %X\n", Status);
}

VOID
QueryInformationFileError(
    IN NTSTATUS Status
    )
{
    DbgPrint(" QueryInfoFile Error %X\n", Status);
}

VOID
SetVolumeInformationFileError(
    IN NTSTATUS Status
    )
{
    DbgPrint(" SetVolumeInfoFile Error %X\n", Status);
}

VOID
QueryVolumeInformationFileError(
    IN NTSTATUS Status
    )
{
    DbgPrint(" QueryVolumeInfoFile Error %X\n", Status);
}

VOID
CloseError(
    IN NTSTATUS Status,
    IN PUCHAR File
    )
{
    DbgPrint(" Close Error %8lx on %s\n", Status, File);
}

VOID
IoStatusError(
    IN NTSTATUS Status
    )
{
    DbgPrint(" IoStatus Error %8lx\n", Status);
}

VOID
CreateThreadError(
    IN NTSTATUS Status
    )
{
   DbgPrint(" CreateThread Error %8lx\n", Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\filter\fspydef.h ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    fspydef.h

Abstract:
    Header file which contains the definitions that may be
    shared with the file spy kernel debugger extensions

// @@BEGIN_DDKSPLIT

Author:

    
// @@END_DDKSPLIT

Environment:

    Kernel mode

// @@BEGIN_DDKSPLIT

Revision History:

   Split off from fspykern.h 
            - Ravisankar Pudipeddi [ravisp] 3-March-01

// @@END_DDKSPLIT
--*/
#ifndef __FSPYDEF_H__
#define __FSPYDEF_H__

#define HASH_SIZE            128        // MUST be a power of 2

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\filter\filespy.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    filespy.c

Abstract:

    This is the main module of FileSpy.

    As of the Windows XP SP1 IFS Kit version of this sample and later, this
    sample can be built for each build environment released with the IFS Kit
    with no additional modifications.  To provide this capability, additional
    compile-time logic was added -- see the '#if WINVER' locations.  Comments
    
    tagged with the 'VERSION NOTE' header have also been added as appropriate to
    describe how the logic must change between versions.

    If this sample is built in the Windows XP environment or later, it will run
    on Windows 2000 or later.  This is done by dynamically loading the routines
    that are only available on Windows XP or later and making run-time decisions
    to determine what code to execute.  Comments tagged with 'MULTIVERISON NOTE'
    mark the locations where such logic has been added.
    
Environment:

    Kernel mode

// @@BEGIN_DDKSPLIT

Author:

    George Jenkins (georgeje) 6-Jan-1999
    Neal Christiansen (nealch)
    Molly Brown (mollybro)  

Revision History:

    George Jenkins (georgeje) 6-Jan-1999    cloned from sfilter.c

    Molly Brown (mollybro) 28-Jun-2000  
        Cleaned up code and made it work with new FsFilter operations.

    Neal Christiansen (nealch)     06-Jul-2001
        Modified to use Stream Contexts to track names

    Molly Brown (mollybro)         21-May-2002
        Modify sample to make it support running on Windows 2000 or later if
        built in the latest build environment and allow it to be built in W2K 
        and later build environments.

// @@END_DDKSPLIT
--*/

#include <ntifs.h>
#include <stdlib.h>
#include "filespy.h"
#include "fspyKern.h"

//
// Global variables.
//

ULONG gFileSpyDebugLevel = DEFAULT_FILESPY_DEBUG_LEVEL;
#if WINVER >= 0x0501
ULONG gFileSpyAttachMode = FILESPY_ATTACH_ALL_VOLUMES;
#else
ULONG gFileSpyAttachMode = FILESPY_ATTACH_ON_DEMAND;
#endif

PDEVICE_OBJECT gControlDeviceObject;

PDRIVER_OBJECT gFileSpyDriverObject;

//
//  The list of device extensions for the volume device objects we are
//  attached to (the volumes we are spying on).  Note:  This list does NOT
//  include FileSystem control device objects we are attached to.  This
//  list is used to answer the question "Which volumes are we logging?"
//

FAST_MUTEX gSpyDeviceExtensionListLock;
LIST_ENTRY gSpyDeviceExtensionList;

//
// NOTE 1:  There are some cases where we need to hold both the 
//   gControlDeviceStateLock and the gOutputBufferLock at the same time.  In
//   these cases, you should acquire the gControlDeviceStateLock then the
//   gOutputBufferLock.
// NOTE 2:  The gControlDeviceStateLock MUST be a spinlock since we try to 
//   acquire it during the completion path in SpyLog, which could be called at
//   DISPATCH_LEVEL (only KSPIN_LOCKs can be acquired at DISPATCH_LEVEL).
//

CONTROL_DEVICE_STATE gControlDeviceState = CLOSED;
KSPIN_LOCK gControlDeviceStateLock;

// NOTE:  Like the gControlDeviceStateLock, gOutputBufferLock MUST be a spinlock
//   since we try to acquire it during the completion path in SpyLog, which 
//   could be called at DISPATCH_LEVEL (only KSPIN_LOCKs can be acquired at 
//   DISPATCH_LEVEL).
//
KSPIN_LOCK gOutputBufferLock;
LIST_ENTRY gOutputBufferList;

#ifndef MEMORY_DBG
NPAGED_LOOKASIDE_LIST gFreeBufferList;
#endif

ULONG gLogSequenceNumber = 0;
KSPIN_LOCK gLogSequenceLock;

UNICODE_STRING gVolumeString;
UNICODE_STRING gOverrunString;
UNICODE_STRING gPagingIoString;

LONG gMaxRecordsToAllocate = DEFAULT_MAX_RECORDS_TO_ALLOCATE;
LONG gRecordsAllocated = 0;

LONG gMaxNamesToAllocate = DEFAULT_MAX_NAMES_TO_ALLOCATE;
LONG gNamesAllocated = 0;

LONG gStaticBufferInUse = FALSE;
CHAR gOutOfMemoryBuffer[RECORD_SIZE];

#if WINVER >= 0x0501
//
//  The structure of function pointers for the functions that are not available
//  on all OS versions.
//

SPY_DYNAMIC_FUNCTION_POINTERS gSpyDynamicFunctions = {0};

ULONG gSpyOsMajorVersion = 0;
ULONG gSpyOsMinorVersion = 0;
#endif

//
//  Control fileSpy statistics
//

FILESPY_STATISTICS gStats;

//
//  This lock is used to synchronize our attaching to a given device object.
//  This lock fixes a race condition where we could accidently attach to the
//  same device object more then once.  This race condition only occurs if
//  a volume is being mounted at the same time as this filter is being loaded.
//  This problem will never occur if this filter is loaded at boot time before
//  any file systems are loaded.
//
//  This lock is used to atomically test if we are already attached to a given
//  device object and if not, do the attach.
//

FAST_MUTEX gSpyAttachLock;

//
//  Macro for validating the FastIo dispatch routines before calling
//  them in the FastIo pass through functions.
//

#define VALID_FAST_IO_DISPATCH_HANDLER(FastIoDispatchPtr, FieldName) \
    (((FastIoDispatchPtr) != NULL) && \
     (((FastIoDispatchPtr)->SizeOfFastIoDispatch) >= \
      (FIELD_OFFSET(FAST_IO_DISPATCH, FieldName) + sizeof(VOID *))) && \
     ((FastIoDispatchPtr)->FieldName != NULL))
    
//
//  list of known device types
//

const PCHAR DeviceTypeNames[] = {
    "",
    "BEEP",
    "CD_ROM",
    "CD_ROM_FILE_SYSTEM",
    "CONTROLLER",
    "DATALINK",
    "DFS",
    "DISK",
    "DISK_FILE_SYSTEM",
    "FILE_SYSTEM",
    "INPORT_PORT",
    "KEYBOARD",
    "MAILSLOT",
    "MIDI_IN",
    "MIDI_OUT",
    "MOUSE",
    "MULTI_UNC_PROVIDER",
    "NAMED_PIPE",
    "NETWORK",
    "NETWORK_BROWSER",
    "NETWORK_FILE_SYSTEM",
    "NULL",
    "PARALLEL_PORT",
    "PHYSICAL_NETCARD",
    "PRINTER",
    "SCANNER",
    "SERIAL_MOUSE_PORT",
    "SERIAL_PORT",
    "SCREEN",
    "SOUND",
    "STREAMS",
    "TAPE",
    "TAPE_FILE_SYSTEM",
    "TRANSPORT",
    "UNKNOWN",
    "VIDEO",
    "VIRTUAL_DISK",
    "WAVE_IN",
    "WAVE_OUT",
    "8042_PORT",
    "NETWORK_REDIRECTOR",
    "BATTERY",
    "BUS_EXTENDER",
    "MODEM",
    "VDM",
    "MASS_STORAGE",
    "SMB",
    "KS",
    "CHANGER",
    "SMARTCARD",
    "ACPI",
    "DVD",
    "FULLSCREEN_VIDEO",
    "DFS_FILE_SYSTEM",
    "DFS_VOLUME",
    "SERENUM",
    "TERMSRV",
    "KSEC"
};

//
//  We need this because the compiler doesn't like doing sizeof an external
//  array in the other file that needs it (fspylib.c)
//

ULONG SizeOfDeviceTypeNames = sizeof( DeviceTypeNames );

//
//  Since functions in drivers are non-pageable by default, these pragmas 
//  allow the driver writer to tell the system what functions can be paged.
//
//  Use the PAGED_CODE() macro at the beginning of these functions'
//  implementations while debugging to ensure that these routines are
//  never called at IRQL > APC_LEVEL (therefore the routine cannot
//  be paged).
//
#if DBG && WINVER >= 0x0501
VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );
#endif

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, DriverEntry)
#if DBG && WINVER >= 0x0501
#pragma alloc_text(PAGE, DriverUnload)
#endif
#pragma alloc_text(PAGE, SpyFsNotification)
#pragma alloc_text(PAGE, SpyClose)
#pragma alloc_text(PAGE, SpyFsControl)
#pragma alloc_text(PAGE, SpyFsControlMountVolume)
#pragma alloc_text(PAGE, SpyFsControlMountVolumeComplete)
#pragma alloc_text(PAGE, SpyFsControlLoadFileSystem)
#pragma alloc_text(PAGE, SpyFsControlLoadFileSystemComplete)
#pragma alloc_text(PAGE, SpyFastIoCheckIfPossible)
#pragma alloc_text(PAGE, SpyFastIoRead)
#pragma alloc_text(PAGE, SpyFastIoWrite)
#pragma alloc_text(PAGE, SpyFastIoQueryBasicInfo)
#pragma alloc_text(PAGE, SpyFastIoQueryStandardInfo)
#pragma alloc_text(PAGE, SpyFastIoLock)
#pragma alloc_text(PAGE, SpyFastIoUnlockSingle)
#pragma alloc_text(PAGE, SpyFastIoUnlockAll)
#pragma alloc_text(PAGE, SpyFastIoUnlockAllByKey)
#pragma alloc_text(PAGE, SpyFastIoDeviceControl)
#pragma alloc_text(PAGE, SpyFastIoDetachDevice)
#pragma alloc_text(PAGE, SpyFastIoQueryNetworkOpenInfo)
#pragma alloc_text(PAGE, SpyFastIoMdlRead)
#pragma alloc_text(PAGE, SpyFastIoPrepareMdlWrite)
#pragma alloc_text(PAGE, SpyFastIoReadCompressed)
#pragma alloc_text(PAGE, SpyFastIoWriteCompressed)
#pragma alloc_text(PAGE, SpyFastIoQueryOpen)
#pragma alloc_text(PAGE, SpyCommonDeviceIoControl)

#endif

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
)
/*++

Routine Description:

    This is the initialization routine for the general purpose file system
    filter driver.  This routine creates the device object that represents 
    this driver in the system and registers it for watching all file systems 
    that register or unregister themselves as active file systems.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/
{
    UNICODE_STRING nameString;
    NTSTATUS status;
    PFAST_IO_DISPATCH fastIoDispatch;
    ULONG i;
    UNICODE_STRING linkString;
    
    //////////////////////////////////////////////////////////////////////
    //
    //  General setup for all filter drivers.  This sets up the filter
    //  driver's DeviceObject and registers the callback routines for
    //  the filter driver.
    //
    //////////////////////////////////////////////////////////////////////

#if WINVER >= 0x0501
    //
    //  Try to load the dynamic functions that may be available for our use.
    //

    SpyLoadDynamicFunctions();

    //
    //  Now get the current OS version that we will use to determine what logic
    //  paths to take when this driver is built to run on various OS version.
    //

    SpyGetCurrentVersion();
#endif
    
    //
    //  Read the custom parameters for FileSpy from the registry
    //

    SpyReadDriverParameters( RegistryPath );

    if (FlagOn(gFileSpyDebugLevel,SPYDEBUG_BREAK_ON_DRIVER_ENTRY)) {

        DbgBreakPoint();
    }

    //
    //  Save our Driver Object.
    //

    gFileSpyDriverObject = DriverObject;

#if DBG && WINVER >= 0x0501

    //
    //  MULTIVERSION NOTE:
    //
    //  We can only support unload for testing environments if we can enumerate
    //  the outstanding device objects that our driver has.
    //

    //
    //  Unload is useful for development purposes. It is not recommended for 
    //  production versions. 
    //

    if (IS_WINDOWSXP_OR_LATER()) {

        ASSERT( NULL != gSpyDynamicFunctions.EnumerateDeviceObjectList );
        
        gFileSpyDriverObject->DriverUnload = DriverUnload;
    }
#endif

    //
    // Create the device object that will represent the FileSpy device.
    //

    RtlInitUnicodeString( &nameString, FILESPY_FULLDEVICE_NAME1 );
    
    //
    // Create the "control" device object.  Note that this device object does
    // not have a device extension (set to NULL).  Most of the fast IO routines
    // check for this condition to determine if the fast IO is directed at the
    // control device.
    //

    status = IoCreateDevice( DriverObject,
                             0,                 //  has no device extension
                             &nameString,
                             FILE_DEVICE_DISK_FILE_SYSTEM,
                             FILE_DEVICE_SECURE_OPEN,
                             FALSE,
                             &gControlDeviceObject);

    if (STATUS_OBJECT_PATH_NOT_FOUND == status) {

        //
        //  The "\FileSystem\Filter' path does not exist in the object name
        //  space, so we must be dealing with an OS pre-Windows XP.  Try
        //  the second name we have to see if we can create a device by that
        //  name.
        //

        RtlInitUnicodeString( &nameString, FILESPY_FULLDEVICE_NAME2 );

        status = IoCreateDevice( DriverObject,
                                 0,             //  has no device extension
                                 &nameString,
                                 FILE_DEVICE_DISK_FILE_SYSTEM,
                                 FILE_DEVICE_SECURE_OPEN,
                                 FALSE,
                                 &gControlDeviceObject);

        if (!NT_SUCCESS( status )) {
            
            SPY_LOG_PRINT( SPYDEBUG_ERROR,
                           ("FileSpy!DriverEntry: Error creating FileSpy control device \"%wZ\", error: %x\n",
                           &nameString,
                           status) );

            return status;
        }

        //
        //  We were able to successfully create the file spy control device
        //  using this second name, so we will now fall through and create the 
        //  symbolic link.
        //
        
    } else if (!NT_SUCCESS( status )) {

        SPY_LOG_PRINT( SPYDEBUG_ERROR,
                       ("FileSpy!DriverEntry: Error creating FileSpy control device \"%wZ\", error: %x\n",
                       &nameString,
                       status) );

        return status;

    }

    RtlInitUnicodeString( &linkString, FILESPY_DOSDEVICE_NAME );
    status = IoCreateSymbolicLink( &linkString, &nameString );

    if (!NT_SUCCESS(status)) {

        //
        //  Remove the existing symbol link and try and create it again.
        //  If this fails then quit.
        //

        IoDeleteSymbolicLink( &linkString );
        status = IoCreateSymbolicLink( &linkString, &nameString );

        if (!NT_SUCCESS(status)) {

            SPY_LOG_PRINT( SPYDEBUG_ERROR,
                           ("FileSpy!DriverEntry: IoCreateSymbolicLink failed\n") );

            IoDeleteDevice(gControlDeviceObject);
            return status;
        }
    }

    //
    // Initialize the driver object with this device driver's entry points.
    //

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {

        DriverObject->MajorFunction[i] = SpyDispatch;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE] = SpyCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = SpyClose;
    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL] = SpyFsControl;

    //
    // Allocate fast I/O data structure and fill it in.  This structure
    // is used to register the callbacks for FileSpy in the fast I/O
    // data paths.
    //

    fastIoDispatch = ExAllocatePoolWithTag( NonPagedPool, 
                                            sizeof( FAST_IO_DISPATCH ),
                                            FILESPY_POOL_TAG );

    if (!fastIoDispatch) {

        IoDeleteDevice( gControlDeviceObject );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( fastIoDispatch, sizeof( FAST_IO_DISPATCH ) );
    fastIoDispatch->SizeOfFastIoDispatch = sizeof( FAST_IO_DISPATCH );
    fastIoDispatch->FastIoCheckIfPossible = SpyFastIoCheckIfPossible;
    fastIoDispatch->FastIoRead = SpyFastIoRead;
    fastIoDispatch->FastIoWrite = SpyFastIoWrite;
    fastIoDispatch->FastIoQueryBasicInfo = SpyFastIoQueryBasicInfo;
    fastIoDispatch->FastIoQueryStandardInfo = SpyFastIoQueryStandardInfo;
    fastIoDispatch->FastIoLock = SpyFastIoLock;
    fastIoDispatch->FastIoUnlockSingle = SpyFastIoUnlockSingle;
    fastIoDispatch->FastIoUnlockAll = SpyFastIoUnlockAll;
    fastIoDispatch->FastIoUnlockAllByKey = SpyFastIoUnlockAllByKey;
    fastIoDispatch->FastIoDeviceControl = SpyFastIoDeviceControl;
    fastIoDispatch->FastIoDetachDevice = SpyFastIoDetachDevice;
    fastIoDispatch->FastIoQueryNetworkOpenInfo = SpyFastIoQueryNetworkOpenInfo;
    fastIoDispatch->MdlRead = SpyFastIoMdlRead;
    fastIoDispatch->MdlReadComplete = SpyFastIoMdlReadComplete;
    fastIoDispatch->PrepareMdlWrite = SpyFastIoPrepareMdlWrite;
    fastIoDispatch->MdlWriteComplete = SpyFastIoMdlWriteComplete;
    fastIoDispatch->FastIoReadCompressed = SpyFastIoReadCompressed;
    fastIoDispatch->FastIoWriteCompressed = SpyFastIoWriteCompressed;
    fastIoDispatch->MdlReadCompleteCompressed = SpyFastIoMdlReadCompleteCompressed;
    fastIoDispatch->MdlWriteCompleteCompressed = SpyFastIoMdlWriteCompleteCompressed;
    fastIoDispatch->FastIoQueryOpen = SpyFastIoQueryOpen;

    DriverObject->FastIoDispatch = fastIoDispatch;

//
//  VERSION NOTE:
//
//  There are 6 FastIO routines for which file system filters are bypassed as
//  the requests are passed directly to the base file system.  These 6 routines
//  are AcquireFileForNtCreateSection, ReleaseFileForNtCreateSection,
//  AcquireForModWrite, ReleaseForModWrite, AcquireForCcFlush, and 
//  ReleaseForCcFlush.
//
//  In Windows XP and later, the FsFilter callbacks were introduced to allow
//  filters to safely hook these operations.  See the IFS Kit documentation for
//  more details on how these new interfaces work.
//
//  MULTIVERSION NOTE:
//  
//  If built for Windows XP or later, this driver is built to run on 
//  multiple versions.  When this is the case, we will test
//  for the presence of FsFilter callbacks registration API.  If we have it,
//  then we will register for those callbacks, otherwise, we will not.
//

#if WINVER >= 0x0501

    {
        FS_FILTER_CALLBACKS fsFilterCallbacks;

        if (IS_WINDOWSXP_OR_LATER()) {

            ASSERT( NULL != gSpyDynamicFunctions.RegisterFileSystemFilterCallbacks );
            
            //
            //  This version of the OS exports FsRtlRegisterFileSystemFilterCallbacks,
            //  therefore it must support the FsFilter callbacks interface.  We
            //  will register to receive callbacks for these operations.
            //
        
            //
            //  Setup the callbacks for the operations we receive through
            //  the FsFilter interface.
            //

            fsFilterCallbacks.SizeOfFsFilterCallbacks = sizeof( FS_FILTER_CALLBACKS );
            fsFilterCallbacks.PreAcquireForSectionSynchronization = SpyPreFsFilterOperation;
            fsFilterCallbacks.PostAcquireForSectionSynchronization = SpyPostFsFilterOperation;
            fsFilterCallbacks.PreReleaseForSectionSynchronization = SpyPreFsFilterOperation;
            fsFilterCallbacks.PostReleaseForSectionSynchronization = SpyPostFsFilterOperation;
            fsFilterCallbacks.PreAcquireForCcFlush = SpyPreFsFilterOperation;
            fsFilterCallbacks.PostAcquireForCcFlush = SpyPostFsFilterOperation;
            fsFilterCallbacks.PreReleaseForCcFlush = SpyPreFsFilterOperation;
            fsFilterCallbacks.PostReleaseForCcFlush = SpyPostFsFilterOperation;
            fsFilterCallbacks.PreAcquireForModifiedPageWriter = SpyPreFsFilterOperation;
            fsFilterCallbacks.PostAcquireForModifiedPageWriter = SpyPostFsFilterOperation;
            fsFilterCallbacks.PreReleaseForModifiedPageWriter = SpyPreFsFilterOperation;
            fsFilterCallbacks.PostReleaseForModifiedPageWriter = SpyPostFsFilterOperation;

            status = (gSpyDynamicFunctions.RegisterFileSystemFilterCallbacks)( DriverObject, 
                                                                              &fsFilterCallbacks );

            if (!NT_SUCCESS( status )) {

                DriverObject->FastIoDispatch = NULL;
                ExFreePoolWithTag( fastIoDispatch, FILESPY_POOL_TAG );
                IoDeleteDevice( gControlDeviceObject );
                return status;
            }
        }
    }
#endif

    //////////////////////////////////////////////////////////////////////
    //
    //  Initialize global data structures that are used for FileSpy's
    //  logging of I/O operations.
    //
    //////////////////////////////////////////////////////////////////////

    //
    //  A fast mutex was used in this case because the mutex is never acquired
    //  at DPC level or above.  Spinlocks were chosen in other cases because
    //  they are acquired at DPC level or above.  Another consideration is
    //  that on an MP machine, a spin lock will literally spin trying to 
    //  acquire the lock when the lock is already acquired.  Acquiring a
    //  previously acquired fast mutex will suspend the thread, thus freeing
    //  up the processor.
    //
    
    ExInitializeFastMutex( &gSpyDeviceExtensionListLock );
    InitializeListHead( &gSpyDeviceExtensionList );

    KeInitializeSpinLock( &gControlDeviceStateLock );

    InitializeListHead( &gOutputBufferList );

    KeInitializeSpinLock( &gOutputBufferLock );
    KeInitializeSpinLock( &gLogSequenceLock );

    ExInitializeFastMutex( &gSpyAttachLock );

#ifndef MEMORY_DBG

    //
    //  When we aren't debugging our memory usage, we want to allocate 
    //  memory from a look-aside list for better performance.  Unfortunately,
    //  we cannot benefit from the memory debugging help of the Driver 
    //  Verifier if we allocate memory from a look-aside list.
    //

    ExInitializeNPagedLookasideList( &gFreeBufferList, 
                                     NULL/*ExAllocatePoolWithTag*/, 
                                     NULL/*ExFreePool*/, 
                                     0, 
                                     RECORD_SIZE, 
                                     FILESPY_LOGRECORD_TAG, 
                                     100 );
#endif

        
    //
    //  Initialize the naming environment
    //

    SpyInitNamingEnvironment();

    //
    //  Init internal strings
    //

    RtlInitUnicodeString(&gVolumeString, L"VOLUME");
    RtlInitUnicodeString(&gOverrunString, L"......");
    RtlInitUnicodeString(&gPagingIoString, L"Paging IO");

    //
    //  If we are supposed to attach to all devices, register a callback
    //  with IoRegisterFsRegistrationChange so that we are called whenever a
    //  file system registers with the IO Manager.
    //
    //  VERSION NOTE:
    //
    //  On Windows XP and later this will also enumerate all existing file
    //  systems (except the RAW file systems).  On Windows 2000 this does not
    //  enumerate the file systems that were loaded before this filter was
    //  loaded.
    //

    if (gFileSpyAttachMode == FILESPY_ATTACH_ALL_VOLUMES) {
    
        status = IoRegisterFsRegistrationChange( DriverObject, SpyFsNotification );
        
        if (!NT_SUCCESS( status )) {

            SPY_LOG_PRINT( SPYDEBUG_ERROR,
                           ("FileSpy!DriverEntry: Error registering FS change notification, status=%08x\n", 
                            status) );

            DriverObject->FastIoDispatch = NULL;
            ExFreePoolWithTag( fastIoDispatch, FILESPY_POOL_TAG );
            IoDeleteDevice( gControlDeviceObject );
            return status;
        }
    }

    //
    //  Clear the initializing flag on the control device object since we
    //  have now successfully initialized everything.
    //

    ClearFlag( gControlDeviceObject->Flags, DO_DEVICE_INITIALIZING );

    return STATUS_SUCCESS;
}

#if DBG && WINVER >= 0x0501

VOID
DriverUnload (
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine is called when a driver can be unloaded.  This performs all of
    the necessary cleanup for unloading the driver from memory.  Note that an
    error can not be returned from this routine.
    
    When a request is made to unload a driver the IO System will cache that
    information and not actually call this routine until the following states
    have occurred:
    - All device objects which belong to this filter are at the top of their
      respective attachment chains.
    - All handle counts for all device objects which belong to this filter have
      gone to zero.

    WARNING: Microsoft does not officially support the unloading of File
             System Filter Drivers.  This is an example of how to unload
             your driver if you would like to use it during development.
             This should not be made available in production code.

Arguments:

    DriverObject - Driver object for this module

Return Value:

    None.

--*/

{
    PFILESPY_DEVICE_EXTENSION devExt;
    PFAST_IO_DISPATCH fastIoDispatch;
    NTSTATUS status;
    ULONG numDevices;
    ULONG i;
    LARGE_INTEGER interval;
    UNICODE_STRING linkString;
#   define DEVOBJ_LIST_SIZE 64
    PDEVICE_OBJECT devList[DEVOBJ_LIST_SIZE];

    ASSERT(DriverObject == gFileSpyDriverObject);

    //
    //  Log we are unloading
    //

    SPY_LOG_PRINT( SPYDEBUG_DISPLAY_ATTACHMENT_NAMES,
                   ("FileSpy!DriverUnload:                        Unloading Driver (%p)\n",
                    DriverObject) );

    //
    //  Remove the symbolic link so no one else will be able to find it.
    //

    RtlInitUnicodeString( &linkString, FILESPY_DOSDEVICE_NAME );
    IoDeleteSymbolicLink( &linkString );

    //
    //  Don't get anymore file system change notifications
    //

    IoUnregisterFsRegistrationChange( DriverObject, SpyFsNotification );

    //
    //  This is the loop that will go through all of the devices we are attached
    //  to and detach from them.  Since we don't know how many there are and
    //  we don't want to allocate memory (because we can't return an error)
    //  we will free them in chunks using a local array on the stack.
    //

    for (;;) {

        //
        //  Get what device objects we can for this driver.  Quit if there
        //  are not any more.  Note that this routine should always be defined
        //  since this routine is only compiled for Windows XP and later.
        //

        ASSERT( NULL != gSpyDynamicFunctions.EnumerateDeviceObjectList );
        status = (gSpyDynamicFunctions.EnumerateDeviceObjectList)(
                        DriverObject,
                        devList,
                        sizeof(devList),
                        &numDevices);

        if (numDevices <= 0)  {

            break;
        }

        numDevices = min( numDevices, DEVOBJ_LIST_SIZE );

        //
        //  First go through the list and detach each of the devices.
        //  Our control device object does not have a DeviceExtension and
        //  is not attached to anything so don't detach it.
        //

        for (i=0; i < numDevices; i++) {

            devExt = devList[i]->DeviceExtension;
            if (NULL != devExt) {

                IoDetachDevice( devExt->AttachedToDeviceObject );
            }
        }

        //
        //  The IO Manager does not currently add a reference count to a device
        //  object for each outstanding IRP.  This means there is no way to
        //  know if there are any outstanding IRPs on the given device.
        //  We are going to wait for a reasonable amount of time for pending
        //  irps to complete.  
        //
        //  WARNING: This does not work 100% of the time and the driver may be
        //           unloaded before all IRPs are completed during high stress
        //           situations.  The system will fault if this occurs.  This
        //           is a sample of how to do this during testing.  This is
        //           not recommended for production code.
        //

        interval.QuadPart = (5 * DELAY_ONE_SECOND);      //delay 5 seconds
        KeDelayExecutionThread( KernelMode, FALSE, &interval );

        //
        //  Now go back through the list and delete the device objects.
        //

        for (i=0; i < numDevices; i++) {

            //
            //  See if this is our control device object.  If not then cleanup
            //  the device extension.  If so then clear the global pointer
            //  that references it.
            //

            if (NULL != devList[i]->DeviceExtension) {

                SpyCleanupMountedDevice( devList[i] );

            } else {

                ASSERT(devList[i] == gControlDeviceObject);
                ASSERT(gControlDeviceState == CLOSED);
                gControlDeviceObject = NULL;
            }

            //
            //  Delete the device object, remove reference counts added by
            //  IoEnumerateDeviceObjectList.  Note that the delete does
            //  not actually occur until the reference count goes to zero.
            //

            IoDeleteDevice( devList[i] );
            ObDereferenceObject( devList[i] );
        }
    }

    //
    //  Delete the look aside list.
    //

    ASSERT(IsListEmpty( &gSpyDeviceExtensionList ));

#ifndef MEMORY_DBG
    ExDeleteNPagedLookasideList( &gFreeBufferList );
#endif

    //
    //  Free our FastIO table
    //

    fastIoDispatch = DriverObject->FastIoDispatch;
    DriverObject->FastIoDispatch = NULL;
    ExFreePoolWithTag( fastIoDispatch, FILESPY_POOL_TAG );
}

#endif

VOID
SpyFsNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FsActive
    )
/*++

Routine Description:

    This routine is invoked whenever a file system has either registered or
    unregistered itself as an active file system.

    For the former case, this routine creates a device object and attaches it
    to the specified file system's device object.  This allows this driver
    to filter all requests to that file system.

    For the latter case, this file system's device object is located,
    detached, and deleted.  This removes this file system as a filter for
    the specified file system.

Arguments:

    DeviceObject - Pointer to the file system's device object.

    FsActive - Boolean indicating whether the file system has registered
        (TRUE) or unregistered (FALSE) itself as an active file system.

Return Value:

    None.

--*/
{
    UNICODE_STRING name;
    WCHAR nameBuffer[DEVICE_NAMES_SZ];

    PAGED_CODE();

    //
    //  Init local name buffer
    //

    RtlInitEmptyUnicodeString( &name, 
                               nameBuffer, 
                               sizeof( nameBuffer ) );

    //
    //  The DeviceObject passed in is always the base device object at this
    //  point because it is the file system's control device object.  We can
    //  just query this object's name directly.
    //
    
    SpyGetObjectName( DeviceObject, 
                      &name );

    //
    //  Display the names of all the file system we are notified of
    //

    SPY_LOG_PRINT( SPYDEBUG_DISPLAY_ATTACHMENT_NAMES,
                   ("FileSpy!SpyFsNotification:                   %s   %p \"%wZ\" (%s)\n",
                    (FsActive) ? "Activating file system  " : "Deactivating file system",
                    DeviceObject,
                    &name,
                    GET_DEVICE_TYPE_NAME(DeviceObject->DeviceType)) );

    //
    //  See if we want to ATTACH or DETACH from the given file system.
    //

    if (FsActive) {

        SpyAttachToFileSystemDevice( DeviceObject, &name );

    } else {

        SpyDetachFromFileSystemDevice( DeviceObject );
    }
}


NTSTATUS
SpyPassThrough (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
)
/*++

Routine Description:

    This routine is the main dispatch routine for the general purpose file
    system driver.  It simply passes requests onto the next driver in the
    stack, which is presumably a disk file system, while logging any
    relevant information if logging is turned on for this DeviceObject.

Arguments:

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

Note:

    This routine passes the I/O request through to the next driver
    *without* removing itself from the stack (like sfilter) since it could
    want to see the result of this I/O request.
    
    To remain in the stack, we have to copy the caller's parameters to the
    next stack location.  Note that we do not want to copy the caller's I/O
    completion routine into the next stack location, or the caller's routine
    will get invoked twice.  This is why we NULL out the Completion routine.
    If we are logging this device, we set our own Completion routine.
    
--*/
{
    PRECORD_LIST recordList = NULL;
    KEVENT waitEvent;
    NTSTATUS status;
    BOOLEAN syncToDispatch;

    ASSERT(IS_FILESPY_DEVICE_OBJECT( DeviceObject ));

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //

    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_IRP_OPS )) {

        SpyDumpIrpOperation( TRUE, Irp );
    }

    //
    //  See if we should log this IRP
    //
    
    if (SHOULD_LOG( DeviceObject )) {

        //
        // The ControlDevice is opened, so allocate the Record 
        // and log the Irp information if we have the memory.
        //

        recordList = SpyNewRecord(0);

        if (NULL != recordList) {

            SpyLogIrp( Irp, recordList );

            //
            //  Since we are logging this operation, we want to 
            //  call our completion routine.
            //

            IoCopyCurrentIrpStackLocationToNext( Irp );

            KeInitializeEvent( &waitEvent, 
                               NotificationEvent, 
                               FALSE );

            recordList->WaitEvent = &waitEvent;

            IoSetCompletionRoutine( Irp,
                                    SpyPassThroughCompletion,
                                    recordList,
                                    TRUE,
                                    TRUE,
                                    TRUE);
        } else {

            //
            //  We could not get a record to log with so get this driver out
            //  of the driver stack and get to the next driver as quickly as
            //  possible.
            //

            IoSkipCurrentIrpStackLocation( Irp );
        }

    } else {

        //
        //  We are not logging so get this driver out of the driver stack and
        //  get to the next driver as quickly as possible.
        //

        IoSkipCurrentIrpStackLocation( Irp );
    }

    //
    //  Determine if we are syncing back to the dispatch routine.  We need to
    //  do this before calling down because the recordList entry could be free
    //  upon return.
    //
    
    syncToDispatch = ((NULL != recordList) &&
                      (FlagOn(recordList->Flags,RLFL_SYNC_TO_DISPATCH)));

    //
    // Now call the next file system driver with the request.
    //

    status = IoCallDriver( ((PFILESPY_DEVICE_EXTENSION)DeviceObject->DeviceExtension)->AttachedToDeviceObject, Irp );

    //
    //  If we are logging and we need to synchronize back to our dispatch routine
    //  for completion processing, do it now.
    //

    if (syncToDispatch) {

        //
        //  We are syncing back to the dispatch routine, wait for the operation to
        //  complete.
        //

	    if (STATUS_PENDING == status) {

		    status = KeWaitForSingleObject( &waitEvent,
		                                    Executive,
		                                    KernelMode,
		                                    FALSE,
		                                    NULL );

	        ASSERT(STATUS_SUCCESS == status);
	    }

        //
        //  Verify the completion has actually been run
        //

        ASSERT(KeReadStateEvent(&waitEvent) || 
               !NT_SUCCESS(Irp->IoStatus.Status));

        //
        //  Do completion processing
        //

        SpyLogIrpCompletion( Irp, recordList );

        //
        //  Continue processing the operation
        //

        status = Irp->IoStatus.Status;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }

    return status;
}

NTSTATUS
SpyPassThroughCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
)
/*++

Routine Description:

    This routine is the completion routine SpyPassThrough.  This is used
    to log the information that can only be gathered after the I/O request
    has been completed.

    Once we are done logging all the information we care about, we append
    the record to the gOutputBufferList to be returned to the user.
    
    Note: This routine will only be set if we were trying to log the
        specified device when the Irp originated and we were able to
        allocate a record to store this logging information.

Arguments:

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.
    
    Context - Pointer to the RECORD_LIST structure in which we store the
        information we are logging.

Return Value:

    The function value is the status of the operation.

--*/
{
    PRECORD_LIST recordList = (PRECORD_LIST)Context;

    ASSERT(IS_FILESPY_DEVICE_OBJECT( DeviceObject ));
    UNREFERENCED_PARAMETER( DeviceObject );

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_IRP_OPS )) {

        SpyDumpIrpOperation( FALSE, Irp );
    }
    
    //
    //  If we are to SYNC back to the dispatch routine, signal the event
    //  and return
    //

    if (FlagOn(recordList->Flags,RLFL_SYNC_TO_DISPATCH)) {

        KeSetEvent( recordList->WaitEvent, IO_NO_INCREMENT, FALSE );
        
        //
        //  When syncing back to the dispatch routine do not propagate the
        //  IRP_PENDING flag.
        //

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    //
    //  Do completion log processing
    //

    SpyLogIrpCompletion( Irp, recordList );
        
    //
    //  Propagate the IRP pending flag.
    //

    if (Irp->PendingReturned) {
        
        IoMarkIrpPending( Irp );
    }

    return STATUS_SUCCESS;
}

NTSTATUS
SpyDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
)
/*++

Routine Description:

    This function completes all requests on the gControlDeviceObject 
    (FileSpy's device object) and passes all other requests on to the 
    SpyPassThrough function.

Arguments:

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    If this is a request on the gControlDeviceObject, STATUS_SUCCESS 
    will be returned unless the device is already attached.  In that case,
    STATUS_DEVICE_ALREADY_ATTACHED is returned.

    If this is a request on a device other than the gControlDeviceObject,
    the function will return the value of SpyPassThrough().

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack;
    
    if (DeviceObject == gControlDeviceObject) {

        //
        //  If the specified debug level is set, output what operation
        //  we are seeing to the debugger.
        //

        if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_IRP_OPS )) {

            SpyDumpIrpOperation( TRUE, Irp );
        }

        //
        //  A request is being made on our control device object
        //

        Irp->IoStatus.Information = 0;
    
        irpStack = IoGetCurrentIrpStackLocation( Irp );
       
        switch (irpStack->MajorFunction) {

            case IRP_MJ_DEVICE_CONTROL:

                //
                //  This is a private device control irp for our control device.
                //  Pass the parameter information along to the common routine
                //  use to service these requests.
                //
                //  All of FileSpy's IOCTLs are buffered, therefore both the
                //  input and output buffer are represented by the 
                //  Irp->AssociatedIrp.SystemBuffer.
                //
            
                status = SpyCommonDeviceIoControl( Irp->AssociatedIrp.SystemBuffer,
                                                   irpStack->Parameters.DeviceIoControl.InputBufferLength,
                                                   Irp->AssociatedIrp.SystemBuffer,
                                                   irpStack->Parameters.DeviceIoControl.OutputBufferLength,
                                                   irpStack->Parameters.DeviceIoControl.IoControlCode,
                                                   &Irp->IoStatus );
                break;

            case IRP_MJ_CLEANUP:
        
                //
                //  This is the cleanup that we will see when all references to a handle
                //  opened to filespy's control device object are cleaned up.  We don't
                //  have to do anything here since we wait until the actual IRP_MJ_CLOSE
                //  to clean up the name cache.  Just complete the IRP successfully.
                //

                status = STATUS_SUCCESS;

                break;
                
            default:

                status = STATUS_INVALID_DEVICE_REQUEST;
        }

        Irp->IoStatus.Status = status;

        //
        //  We have completed all processing for this IRP, so tell the 
        //  I/O Manager.  This IRP will not be passed any further down
        //  the stack since no drivers below FileSpy care about this 
        //  I/O operation that was directed to FileSpy.
        //

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;
    }

    return SpyPassThrough( DeviceObject, Irp );
}

NTSTATUS
SpyCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
)
/*++

Routine Description:

    This is the routine that is associated with IRP_MJ_CREATE irp.  If the 
    DeviceObject is the ControlDevice, we do the creation work for the 
    ControlDevice and complete the irp.  Otherwise, we pass through
    this irp for another device to complete.
    
    Note: Some of the code in this function duplicates the functions 
        SpyDispatch and SpyPassThrough, but a design decision was made that 
        it was worth the code duplication to break out the irp handlers 
        that can be pageable code.
    
Arguments:

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.
    
Return Value:

    If DeviceObject == gControlDeviceObject, then this function will 
    complete the Irp and return the status of that completion.  Otherwise,
    this function returns the result of calling SpyPassThrough.
    
--*/
{
    NTSTATUS status;
    KIRQL oldIrql;

    //
    //  See if they want to open the control device object for the filter.
    //  This will only allow one thread to have this object open at a time.
    //  All other requests will be failed.
    //

    if (DeviceObject == gControlDeviceObject) {

        //
        //  If the specified debug level is set, output what operation
        //  we are seeing to the debugger.
        //

        if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_IRP_OPS )) {

            SpyDumpIrpOperation( TRUE, Irp );
        }

        //
        //  A CREATE request is being made on our gControlDeviceObject.
        //  See if someone else has it open.  If so, disallow this open.
        //

        KeAcquireSpinLock( &gControlDeviceStateLock, &oldIrql );

        if (gControlDeviceState != CLOSED) {

            Irp->IoStatus.Status = STATUS_DEVICE_ALREADY_ATTACHED;
            Irp->IoStatus.Information = 0;

        } else {

            Irp->IoStatus.Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = FILE_OPENED;

            gControlDeviceState = OPENED;
        }

        KeReleaseSpinLock( &gControlDeviceStateLock, oldIrql );

        //
        // Since this is our gControlDeviceObject, we complete the
        // irp here.
        //

        status = Irp->IoStatus.Status;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;
    }

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );

    //
    // This is NOT our gControlDeviceObject, so let SpyPassThrough handle
    // it appropriately
    //

    return SpyPassThrough( DeviceObject, Irp );
}


NTSTATUS
SpyClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the routine that is associated with IRP_MJ_CLOSE irp.  If the 
    DeviceObject is the ControlDevice, we do the necessary cleanup and
    complete the irp.  Otherwise, we pass through this irp for another device
    to complete.
    
Arguments:

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.
    
Return Value:

    If DeviceObject == gControlDeviceObject, then this function will 
    complete the Irp and return the status of that completion.  Otherwise,
    this function returns the result of calling SpyPassThrough.
    
--*/
{
    PAGED_CODE();

    //
    //  See if they are closing the control device object for the filter.
    //

    if (DeviceObject == gControlDeviceObject) {

        //
        //  If the specified debug level is set, output what operation
        //  we are seeing to the debugger.
        //

        if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_IRP_OPS )) {

            SpyDumpIrpOperation( TRUE, Irp );
        }

        //
        //  A CLOSE request is being made on our gControlDeviceObject.
        //  Cleanup state.
        //

        SpyCloseControlDevice();

        //
        //  We have completed all processing for this IRP, so tell the 
        //  I/O Manager.  This IRP will not be passed any further down
        //  the stack since no drivers below FileSpy care about this 
        //  I/O operation that was directed to FileSpy.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_SUCCESS;
    }

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
 

    //
    //  Log (if it is turned on) and pass the request on.
    //

    return SpyPassThrough( DeviceObject, Irp );
}


NTSTATUS
SpyFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked whenever an I/O Request Packet (IRP) w/a major
    function code of IRP_MJ_FILE_SYSTEM_CONTROL is encountered.  For most
    IRPs of this type, the packet is simply passed through.  However, for
    some requests, special processing is required.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    //
    //  If this is for our control device object, fail the operation
    //

    if (gControlDeviceObject == DeviceObject) {

        //
        //  If the specified debug level is set, output what operation
        //  we are seeing to the debugger.
        //

        if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_IRP_OPS )) {

            SpyDumpIrpOperation( TRUE, Irp );
        }

        //
        //  If this device object is our control device object rather than 
        //  a mounted volume device object, then this is an invalid request.
        //

        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    ASSERT(IS_FILESPY_DEVICE_OBJECT( DeviceObject ));

    //
    //  Process the minor function code.
    //

    switch (pIrpSp->MinorFunction) {

        case IRP_MN_MOUNT_VOLUME:

            return SpyFsControlMountVolume ( DeviceObject, Irp );

        case IRP_MN_LOAD_FILE_SYSTEM:

            return SpyFsControlLoadFileSystem ( DeviceObject, Irp );

        case IRP_MN_USER_FS_REQUEST:
        {
            switch (pIrpSp->Parameters.FileSystemControl.FsControlCode) {

                case FSCTL_DISMOUNT_VOLUME:
                {
                    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;

                    SPY_LOG_PRINT( SPYDEBUG_DISPLAY_ATTACHMENT_NAMES,
                                   ("FILESPY!SpyFsControl:                        Dismounting volume         %p \"%wZ\"\n",
                                    devExt->AttachedToDeviceObject,
                                    &devExt->DeviceName) );
                    break;
                }
            }
            break;
        }
    } 

    //
    // This is a regular FSCTL that we need to let the filters see
    // Just do the callbacks for all the filters & passthrough
    //

    return SpyPassThrough( DeviceObject, Irp );
}


NTSTATUS
SpyFsControlCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is invoked for the completion of a mount/LoadFS request.  This
    will load the IRP and then signal the waiting dispatch routine.

Arguments:

    DeviceObject - Pointer to this driver's device object that was attached to
            the file system device object

    Irp - Pointer to the IRP that was just completed.

    Context - Pointer to the device object allocated during the down path so
            we wouldn't have to deal with errors here.

Return Value:

    The return value is always STATUS_SUCCESS.

--*/

{
    PRECORD_LIST recordList = ((PSPY_COMPLETION_CONTEXT)Context)->RecordList;

    ASSERT(IS_FILESPY_DEVICE_OBJECT( DeviceObject ));
    UNREFERENCED_PARAMETER( DeviceObject );

    //
    //  Log the completion (if we need to)
    //

    if (NULL != recordList) {

        SpyLogIrpCompletion( Irp, recordList );
    }

#if WINVER >= 0x0501
    if (IS_WINDOWSXP_OR_LATER()) {

        PKEVENT event = &((PSPY_COMPLETION_CONTEXT_WXP_OR_LATER)Context)->WaitEvent;

        //
        //  wakeup the dispatch routine
        //

        KeSetEvent(event, IO_NO_INCREMENT, FALSE);

    } else {
#endif

        //
        //  For Windows 2000, if we are not at passive level, we should 
        //  queue this work to a worker thread using the workitem that is in 
        //  Context.
        //

        if (KeGetCurrentIrql() > PASSIVE_LEVEL) {

            //
            //  We are not at passive level, but we need to be to do our work,
            //  so queue off to the worker thread.

            ExQueueWorkItem( &(((PSPY_COMPLETION_CONTEXT_W2K)Context)->WorkItem),
                             DelayedWorkQueue );

        } else {

            PSPY_COMPLETION_CONTEXT_W2K completionContext = Context;

            //
            //  We are already at passive level, so we will just call our 
            //  worker routine directly.
            //

            (completionContext->WorkItem.WorkerRoutine)(completionContext->WorkItem.Parameter);
        }

#if WINVER >= 0x0501
    }
#endif

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SpyFsControlMountVolume (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This processes a MOUNT VOLUME request

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation( Irp );
    PDEVICE_OBJECT newDeviceObject;
    PFILESPY_DEVICE_EXTENSION newDevExt;
    NTSTATUS status;
    PRECORD_LIST recordList = NULL;
    PSPY_COMPLETION_CONTEXT_W2K completionContext;

    PAGED_CODE();
    ASSERT(IS_FILESPY_DEVICE_OBJECT( DeviceObject ));

    //
    //  We should only see these FS_CTLs to control device objects.
    //
    
    ASSERT(!FlagOn(devExt->Flags,IsVolumeDeviceObject));

    //
    //  This is a mount request.  Create a device object that can be
    //  attached to the file system's volume device object if this request
    //  is successful.  We allocate this memory now since we can not return
    //  an error after the completion routine.
    //
    //  Since the device object we are going to attach to has not yet been
    //  created (it is created by the base file system) we are going to use
    //  the type of the file system control device object.  We are assuming
    //  that the file system control device object will have the same type
    //  as the volume device objects associated with it.
    //

    status = IoCreateDevice( gFileSpyDriverObject,
                             sizeof( FILESPY_DEVICE_EXTENSION ),
                             NULL,
                             DeviceObject->DeviceType,
                             0,
                             FALSE,
                             &newDeviceObject );

    if (!NT_SUCCESS( status )) {

        //
        //  If we can not attach to the volume, then simply skip it.
        //

        SPY_LOG_PRINT( SPYDEBUG_ERROR,
                       ("FileSpy!SpyFsControlMountVolume: Error creating volume device object, status=%08x\n", 
                        status) );

        return SpyPassThrough( DeviceObject, Irp );
    }

    //
    //  We need to save the RealDevice object pointed to by the vpb
    //  parameter because this vpb may be changed by the underlying
    //  file system.  Both FAT and CDFS may change the VPB address if
    //  the volume being mounted is one they recognize from a previous
    //  mount.
    //

    newDevExt = newDeviceObject->DeviceExtension;
    newDevExt->Flags = 0;
        
    newDevExt->DiskDeviceObject = pIrpSp->Parameters.MountVolume.Vpb->RealDevice;

    //
    //  Get the name of this device
    //

    RtlInitEmptyUnicodeString( &newDevExt->DeviceName, 
                               newDevExt->DeviceNameBuffer, 
                               sizeof(newDevExt->DeviceNameBuffer) );

    SpyGetObjectName( newDevExt->DiskDeviceObject, 
                      &newDevExt->DeviceName );

    //
    //  Since we have our own private completion routine we need to
    //  do our own logging of this operation, do it now.
    //

    if (SHOULD_LOG( DeviceObject )) {

        //
        // Lock the IRP if we can
        //

        recordList = SpyNewRecord(0);

        if (recordList) {

            SpyLogIrp( Irp, recordList );
        }
    }

    //
    //  Send the IRP to the legacy filters.  Note that the IRP we are sending
    //  down is for our CDO, not the new VDO that we have been passing to
    //  the mini-filters.
    //

    //
    //  VERSION NOTE:
    //
    //  On Windows 2000, we cannot simply synchronize back to the dispatch
    //  routine to do our post-mount processing.  We need to do this work at
    //  passive level, so we will queue that work to a worker thread from
    //  the completion routine.
    //
    //  For Windows XP and later, we can safely synchronize back to the dispatch
    //  routine.  The code below shows both methods.  Admittedly, the code
    //  would be simplified if you chose to only use one method or the other, 
    //  but you should be able to easily adapt this for your needs.
    //

#if WINVER >= 0x0501
    if (IS_WINDOWSXP_OR_LATER()) {

        SPY_COMPLETION_CONTEXT_WXP_OR_LATER completionContext;
        
        IoCopyCurrentIrpStackLocationToNext ( Irp );

        completionContext.RecordList = recordList;
        KeInitializeEvent( &completionContext.WaitEvent, 
                           NotificationEvent, 
                           FALSE );

        IoSetCompletionRoutine( Irp,
                                SpyFsControlCompletion,
                                &completionContext,     //context parameter
                                TRUE,
                                TRUE,
                                TRUE );

        status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );

        //
        //  Wait for the operation to complete
        //

    	if (STATUS_PENDING == status) {

    		status = KeWaitForSingleObject( &completionContext.WaitEvent,
    		                                Executive,
    		                                KernelMode,
    		                                FALSE,
    		                                NULL );
    	    ASSERT(STATUS_SUCCESS == status);
    	}

        //
        //  Verify the IoCompleteRequest was called
        //

        ASSERT(KeReadStateEvent(&completionContext.WaitEvent) ||
               !NT_SUCCESS(Irp->IoStatus.Status));

        status = SpyFsControlMountVolumeComplete( DeviceObject,
                                                  Irp,
                                                  newDeviceObject );
        
    } else {
#endif    
        completionContext = ExAllocatePoolWithTag( NonPagedPool, 
                                                   sizeof( SPY_COMPLETION_CONTEXT_W2K ),
                                                   FILESPY_POOL_TAG );

        if (completionContext == NULL) {

            IoSkipCurrentIrpStackLocation( Irp );

            status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );
            
        } else {
        
            completionContext->RecordList = recordList;

            ExInitializeWorkItem( &completionContext->WorkItem,
                                  SpyFsControlMountVolumeCompleteWorker,
                                  completionContext );
            completionContext->DeviceObject = DeviceObject,
            completionContext->Irp = Irp;
            completionContext->NewDeviceObject = newDeviceObject;

            IoCopyCurrentIrpStackLocationToNext ( Irp );

            IoSetCompletionRoutine( Irp,
                                    SpyFsControlCompletion,
                                    completionContext,     //context parameter
                                    TRUE,
                                    TRUE,
                                    TRUE );

            status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );
        }
#if WINVER >= 0x0501        
    }
#endif
    return status;
}

VOID
SpyFsControlMountVolumeCompleteWorker (
    IN PSPY_COMPLETION_CONTEXT_W2K Context
    )
/*++

Routine Description:

    The worker thread routine that will call our common routine to do the
    post-MountVolume work.

Arguments:

    Context - The context passed to this worker thread.
    
Return Value:

    None.

--*/
{
    SpyFsControlMountVolumeComplete( Context->DeviceObject,
                                     Context->Irp,
                                     Context->NewDeviceObject );

    ExFreePoolWithTag( Context, FILESPY_POOL_TAG );
}

NTSTATUS
SpyFsControlMountVolumeComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_OBJECT NewDeviceObject
    )
/*++

Routine Description:

    This does the post-Mount work and must be done at PASSIVE_LEVEL.

Arguments:

    DeviceObject - The device object for this operation,

    Irp - The IRP for this operation that we will complete once we are finished
        with it.
    
Return Value:

    Returns the status of the mount operation.

--*/
{
    PVPB vpb;
    PFILESPY_DEVICE_EXTENSION newDevExt = NewDeviceObject->DeviceExtension;
    PDEVICE_OBJECT attachedDeviceObject;
    NTSTATUS status;

    PAGED_CODE();
    
    //
    //  Get the correct VPB from the real device object saved in our
    //  device extension.  We do this because the VPB in the IRP stack
    //  may not be the correct VPB when we get here.  The underlying
    //  file system may change VPBs if it detects a volume it has
    //  mounted previously.
    //

    vpb = newDevExt->DiskDeviceObject->Vpb;

    //
    //  See if the mount was successful.
    //

    if (NT_SUCCESS( Irp->IoStatus.Status )) {

        //
        //  Acquire lock so we can atomically test if we area already attached
        //  and if not, then attach.  This prevents a double attach race
        //  condition.
        //

        ExAcquireFastMutex( &gSpyAttachLock );

        //
        //  The mount succeeded.  If we are not already attached, attach to the
        //  device object.  Note: one reason we could already be attached is
        //  if the underlying file system revived a previous mount.
        //

        if (!SpyIsAttachedToDevice( vpb->DeviceObject, &attachedDeviceObject )) {

            //
            //  Attach to the new mounted volume.  The correct file system device
            //  object that was just mounted is pointed to by the VPB.
            //

            status = SpyAttachToMountedDevice( vpb->DeviceObject,
                                               NewDeviceObject );

            if (!NT_SUCCESS( status )) {

                //
                //  The attachment failed, cleanup.  Since we are in the
                //  post-mount phase, we can not fail this operation.
                //  We simply won't be attached.  The only reason this should
                //  ever happen at this point is if somebody already started
                //  dismounting the volume therefore not attaching should
                //  not be a problem.
                //

                SpyCleanupMountedDevice( NewDeviceObject );
                IoDeleteDevice( NewDeviceObject );

            } else {

                //
                //  We completed initialization of this device object, so now
                //  clear the initializing flag.
                //

                ClearFlag( NewDeviceObject->Flags, DO_DEVICE_INITIALIZING );
            }

            ASSERT( NULL == attachedDeviceObject );

        } else {

            //
            //  We were already attached, cleanup device object
            //

            SPY_LOG_PRINT( SPYDEBUG_DISPLAY_ATTACHMENT_NAMES,
                           ("FileSpy!SpyFsControlMountVolume:             Mount volume failure for   %p \"%wZ\", already attached\n",
                            ((PFILESPY_DEVICE_EXTENSION)attachedDeviceObject->DeviceExtension)->AttachedToDeviceObject,
                            &newDevExt->DeviceName) );

            SpyCleanupMountedDevice( NewDeviceObject );
            IoDeleteDevice( NewDeviceObject );

            //
            //  Remove the reference added by SpyIsAttachedToDevice.
            //
        
            ObDereferenceObject( attachedDeviceObject );
        }

        //
        //  Release the lock
        //

        ExReleaseFastMutex( &gSpyAttachLock );

    } else {

        //
        //  Display why mount failed.  Setup the buffers.
        //

        SPY_LOG_PRINT( SPYDEBUG_DISPLAY_ATTACHMENT_NAMES,
                       ("FileSpy!SpyFsControlMountVolume:             Mount volume failure for   %p \"%wZ\", status=%08x\n",
                        DeviceObject,
                        &newDevExt->DeviceName,
                        Irp->IoStatus.Status) );

        //
        //  The mount request failed.  Cleanup and delete the device
        //  object we created
        //

        SpyCleanupMountedDevice( NewDeviceObject );
        IoDeleteDevice( NewDeviceObject );
    }

    //
    //  Continue processing the operation
    //

    status = Irp->IoStatus.Status;

    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}


NTSTATUS
SpyFsControlLoadFileSystem (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked whenever an I/O Request Packet (IRP) w/a major
    function code of IRP_MJ_FILE_SYSTEM_CONTROL is encountered.  For most
    IRPs of this type, the packet is simply passed through.  However, for
    some requests, special processing is required.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    NTSTATUS status;
    PSPY_COMPLETION_CONTEXT_W2K completionContext;
    PRECORD_LIST recordList = NULL;

    PAGED_CODE();
    ASSERT(IS_FILESPY_DEVICE_OBJECT( DeviceObject ));

    //
    //  This is a "load file system" request being sent to a file system
    //  recognizer device object.  This IRP_MN code is only sent to 
    //  file system recognizers.
    //
    //  NOTE:  Since we no longer are attaching to the standard Microsoft file
    //         system recognizers we will normally never execute this code.
    //         However, there might be 3rd party file systems which have their
    //         own recognizer which may still trigger this IRP.
    //

    SPY_LOG_PRINT( SPYDEBUG_DISPLAY_ATTACHMENT_NAMES,
                   ("FileSpy!SpyFsControlLoadFileSystem:          Loading File System, Detaching from \"%wZ\"\n",
                    &devExt->DeviceName) );

    //
    //  Since we have our own private completion routine we need to
    //  do our own logging of this operation, do it now.
    //

    if (SHOULD_LOG( DeviceObject )) {

        recordList = SpyNewRecord(0);

        if (recordList) {

            SpyLogIrp( Irp, recordList );
        }
    }

    //
    //  Set a completion routine so we can delete the device object when
    //  the load is complete.
    //

    //
    //  VERSION NOTE:
    //
    //  On Windows 2000, we cannot simply synchronize back to the dispatch
    //  routine to do our post-load filesystem processing.  We need to do 
    //  this work at passive level, so we will queue that work to a worker 
    //  thread from the completion routine.
    //
    //  For Windows XP and later, we can safely synchronize back to the dispatch
    //  routine.  The code below shows both methods.  Admittedly, the code
    //  would be simplified if you chose to only use one method or the other, 
    //  but you should be able to easily adapt this for your needs.
    //

#if WINVER >= 0x0501

    if (IS_WINDOWSXP_OR_LATER()) {

        SPY_COMPLETION_CONTEXT_WXP_OR_LATER completionContext;

        IoCopyCurrentIrpStackLocationToNext( Irp );

        completionContext.RecordList = recordList;
        KeInitializeEvent( &completionContext.WaitEvent, 
                           NotificationEvent, 
                           FALSE );

        IoSetCompletionRoutine(
            Irp,
            SpyFsControlCompletion,
            &completionContext,
            TRUE,
            TRUE,
            TRUE );

        //
        //  Detach from the file system recognizer device object.
        //

        IoDetachDevice( devExt->AttachedToDeviceObject );

        //
        //  Call the driver
        //

        status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );

        //
        //  Wait for the completion routine to be called
        //

    	if (STATUS_PENDING == status) {

    		status = KeWaitForSingleObject( &completionContext.WaitEvent, 
    		                                Executive, 
    		                                KernelMode, 
    		                                FALSE, 
    		                                NULL );

    	    ASSERT(STATUS_SUCCESS == status);
    	}

        ASSERT(KeReadStateEvent(&completionContext.WaitEvent) ||
               !NT_SUCCESS(Irp->IoStatus.Status));

        status = SpyFsControlLoadFileSystemComplete( DeviceObject, Irp );

    } else {
#endif
        completionContext = ExAllocatePoolWithTag( NonPagedPool,
                                                   sizeof( SPY_COMPLETION_CONTEXT_W2K ),
                                                   FILESPY_POOL_TAG );

        if (completionContext == NULL) {

            IoSkipCurrentIrpStackLocation( Irp );
            status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );

        } else {

            completionContext->RecordList = recordList;
            ExInitializeWorkItem( &completionContext->WorkItem,
                                  SpyFsControlLoadFileSystemCompleteWorker,
                                  completionContext );
            
            completionContext->DeviceObject = DeviceObject;
            completionContext->Irp = Irp;
            completionContext->NewDeviceObject = NULL;

            IoSetCompletionRoutine(
                Irp,
                SpyFsControlCompletion,
                &completionContext,
                TRUE,
                TRUE,
                TRUE );

            //
            //  Detach from the file system recognizer device object.
            //

            IoDetachDevice( devExt->AttachedToDeviceObject );

            //
            //  Call the driver
            //

            status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );
        }
#if WINVER >= 0x0501
    }
#endif     

    return status;
}

VOID
SpyFsControlLoadFileSystemCompleteWorker (
    IN PSPY_COMPLETION_CONTEXT_W2K Context
    )
/*++

Routine Description:

    The worker thread routine that will call our common routine to do the
    post-LoadFileSystem work.

Arguments:

    Context - The context passed to this worker thread.
    
Return Value:

    None.

--*/
{
    SpyFsControlLoadFileSystemComplete( Context->DeviceObject,
                                        Context->Irp );

    ExFreePoolWithTag( Context, FILESPY_POOL_TAG );
}

NTSTATUS
SpyFsControlLoadFileSystemComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This does the post-LoadFileSystem work and must be done at PASSIVE_LEVEL.

Arguments:

    DeviceObject - The device object for this operation,

    Irp - The IRP for this operation that we will complete once we are finished
        with it.
    
Return Value:

    Returns the status of the load file system operation.

--*/
{
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    NTSTATUS status;

    PAGED_CODE();
        
    //
    //  Display the name if requested
    //

    SPY_LOG_PRINT( SPYDEBUG_DISPLAY_ATTACHMENT_NAMES,
                   ("FileSpy!SpyFsControlLoadFileSystem:          Detaching from recognizer  %p \"%wZ\", status=%08x\n",
                    DeviceObject,
                    &devExt->DeviceName,
                    Irp->IoStatus.Status) );

    //
    //  Check status of the operation
    //

    if (!NT_SUCCESS( Irp->IoStatus.Status ) && 
        (Irp->IoStatus.Status != STATUS_IMAGE_ALREADY_LOADED)) {

        //
        //  The load was not successful.  Simply reattach to the recognizer
        //  driver in case it ever figures out how to get the driver loaded
        //  on a subsequent call.
        //

        SpyAttachDeviceToDeviceStack( DeviceObject, 
                                      devExt->AttachedToDeviceObject,
                                      &devExt->AttachedToDeviceObject );

        ASSERT(devExt->AttachedToDeviceObject != NULL);

    } else {

        //
        //  The load was successful, delete the Device object
        //

        SpyCleanupMountedDevice( DeviceObject );
        IoDeleteDevice( DeviceObject );
    }

    //
    //  Continue processing the operation
    //

    status = Irp->IoStatus.Status;

    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}

/////////////////////////////////////////////////////////////////////////////
//
//                      FastIO Handling routines
//
/////////////////////////////////////////////////////////////////////////////

BOOLEAN
SpyFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for checking to see
    whether fast I/O is possible for this file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be operated on.

    FileOffset - Byte offset in the file for the operation.

    Length - Length of the operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    CheckForReadOperation - Indicates whether the caller is checking for a
        read (TRUE) or a write operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.
    
--*/
{
    PDEVICE_OBJECT    deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN           returnValue = FALSE;
    PRECORD_LIST      recordList;
    BOOLEAN           shouldLog;
    
    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, CHECK_IF_POSSIBLE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( CHECK_IF_POSSIBLE,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        Length,
                                        Wait );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        //
        //  We have a valid DeviceObject, so look at its FastIoDispatch
        //  table for the next driver's Fast IO routine.
        //

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoCheckIfPossible )) {

            returnValue = (fastIoDispatch->FastIoCheckIfPossible)( FileObject,
                                                                   FileOffset,
                                                                   Length,
                                                                   Wait,
                                                                   LockKey,
                                                                   CheckForReadOperation,
                                                                   IoStatus,
                                                                   deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, CHECK_IF_POSSIBLE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O 
        // operation if we were able to allocate a RecordList to store 
        // this information
        //

        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }

    return returnValue;
}

BOOLEAN
SpyFastIoRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading from a
    file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be read.

    FileOffset - Byte offset in the file of the read.

    Length - Length of the read operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer to receive the data read.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;
    PRECORD_LIST recordList;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, READ );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( READ, 
                                        DeviceObject,
                                        FileObject, 
                                        FileOffset, 
                                        Length, 
                                        Wait );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoRead )) {

            returnValue = (fastIoDispatch->FastIoRead)( FileObject,
                                                        FileOffset,
                                                        Length,
                                                        Wait,
                                                        LockKey,
                                                        Buffer,
                                                        IoStatus,
                                                        deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, READ );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }                                                      
    
    return returnValue;
}

BOOLEAN
SpyFastIoWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing to a
    file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be written.

    FileOffset - Byte offset in the file of the write operation.

    Length - Length of the write operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer that contains the data to be
        written.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, WRITE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( WRITE,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        Length,
                                        Wait );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoWrite )) {

            returnValue = (fastIoDispatch->FastIoWrite)( FileObject,
                                                         FileOffset,
                                                         Length,
                                                         Wait,
                                                         LockKey,
                                                         Buffer,
                                                         IoStatus,
                                                         deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, WRITE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }

    return returnValue;
}
 
BOOLEAN
SpyFastIoQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying basic
    information about the file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;
    PRECORD_LIST recordList;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, QUERY_BASIC_INFO );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( QUERY_BASIC_INFO,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        Wait );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryBasicInfo )) {

            returnValue = (fastIoDispatch->FastIoQueryBasicInfo)( FileObject,
                                                                  Wait,
                                                                  Buffer,
                                                                  IoStatus,
                                                                  deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, QUERY_BASIC_INFO );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }

    return returnValue;
}
 
BOOLEAN
SpyFastIoQueryStandardInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying standard
    information about the file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, QUERY_STANDARD_INFO );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( QUERY_STANDARD_INFO,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        Wait );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;
    
    if (NULL != deviceObject) {
           
        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryStandardInfo )) {

            returnValue = (fastIoDispatch->FastIoQueryStandardInfo)( FileObject,
                                                                     Wait,
                                                                     Buffer,
                                                                     IoStatus,
                                                                     deviceObject );

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, QUERY_STANDARD_INFO );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {
        
        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //
        
        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }

    return returnValue;
}

BOOLEAN
SpyFastIoLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    IN BOOLEAN FailImmediately,
    IN BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for locking a byte
    range within a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be locked.

    FileOffset - Starting byte offset from the base of the file to be locked.

    Length - Length of the byte range to be locked.

    ProcessId - ID of the process requesting the file lock.

    Key - Lock key to associate with the file lock.

    FailImmediately - Indicates whether or not the lock request is to fail
        if it cannot be immediately be granted.

    ExclusiveLock - Indicates whether the lock to be taken is exclusive (TRUE)
        or shared.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, LOCK );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( LOCK,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        0,
                                        0 );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoLock )) {

            returnValue = (fastIoDispatch->FastIoLock)( FileObject,
                                                        FileOffset,
                                                        Length,
                                                        ProcessId,
                                                        Key,
                                                        FailImmediately,
                                                        ExclusiveLock,
                                                        IoStatus,
                                                        deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, LOCK );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }

    return returnValue;
}
 
BOOLEAN
SpyFastIoUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking a byte
    range within a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    FileOffset - Starting byte offset from the base of the file to be
        unlocked.

    Length - Length of the byte range to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the file lock.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, UNLOCK_SINGLE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( UNLOCK_SINGLE,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        0,
                                        0 );
    }


    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockSingle )) {

            returnValue = (fastIoDispatch->FastIoUnlockSingle)( FileObject,
                                                                FileOffset,
                                                                Length,
                                                                ProcessId,
                                                                Key,
                                                                IoStatus,
                                                                deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, UNLOCK_SINGLE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }

    return returnValue;
}
 
BOOLEAN
SpyFastIoUnlockAll (
    IN PFILE_OBJECT FileObject,
    IN PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, UNLOCK_ALL );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( UNLOCK_ALL,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        0 );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockAll )) {

            returnValue = (fastIoDispatch->FastIoUnlockAll)( FileObject,
                                                             ProcessId,
                                                             IoStatus,
                                                             deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, UNLOCK_ALL );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }

    return returnValue;
}

BOOLEAN
SpyFastIoUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    IN PVOID ProcessId,
    IN ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file based on a specified key.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the locks on the file to be released.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, UNLOCK_ALL_BY_KEY );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( UNLOCK_ALL_BY_KEY,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        0 );
    }

    //
    // Pass through logic for this type of Fast I/O
    //
    
    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockAllByKey )) {

            returnValue = (fastIoDispatch->FastIoUnlockAllByKey)( FileObject,
                                                                  ProcessId,
                                                                  Key,
                                                                  IoStatus,
                                                                  deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, UNLOCK_ALL_BY_KEY );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }

    return returnValue;
}

BOOLEAN
SpyFastIoDeviceControl (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for device I/O 
    control operations on a file.
    
    If this I/O is directed to gControlDevice, then the parameters specify
    control commands to FileSpy.  These commands are interpreted and handled
    appropriately.

    If this is I/O directed at another DriverObject, this function simply 
    invokes the next driver's corresponding routine, or returns FALSE if 
    the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object representing the device to be
        serviced.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    InputBuffer - Optional pointer to a buffer to be passed into the driver.

    InputBufferLength - Length of the optional InputBuffer, if one was
        specified.

    OutputBuffer - Optional pointer to a buffer to receive data from the
        driver.

    OutputBufferLength - Length of the optional OutputBuffer, if one was
        specified.

    IoControlCode - I/O control code indicating the operation to be performed
        on the device.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

Notes:

    This function does not check the validity of the input/output buffers
    because the ioctl's are implemented as METHOD_BUFFERED.  In this case,
    the I/O manager does the buffer validation checks for us.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //

    if (DeviceObject == gControlDeviceObject) {

        SpyCommonDeviceIoControl( InputBuffer,
                                  InputBufferLength,
                                  OutputBuffer,
                                  OutputBufferLength,
                                  IoControlCode,
                                  IoStatus );

        returnValue = TRUE;

    } else {

        ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );

        //
        //  If the specified debug level is set, output what operation
        //  we are seeing to the debugger.
        //
        
        if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

            SpyDumpFastIoOperation( TRUE, DEVICE_CONTROL );
        }
        
        //
        //  Perform filespy logging if we care about this device.
        //
        
        if (shouldLog = SHOULD_LOG(DeviceObject)) {

            //
            //
            // Log the necessary information for the start of the Fast I/O 
            // operation
            //

            recordList = SpyLogFastIoStart( DEVICE_CONTROL,
                                            DeviceObject,
                                            FileObject,
                                            NULL,
                                            0,
                                            Wait );
        }

        deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

        if (NULL != deviceObject) {

            fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

            if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoDeviceControl )) {

                returnValue = (fastIoDispatch->FastIoDeviceControl)( FileObject,
                                                                     Wait,
                                                                     InputBuffer,
                                                                     InputBufferLength,
                                                                     OutputBuffer,
                                                                     OutputBufferLength,
                                                                     IoControlCode,
                                                                     IoStatus,
                                                                     deviceObject);

            } else {

                IoStatus->Status = STATUS_SUCCESS;
            }
        }

        //
        //  If the specified debug level is set, output what operation
        //  we are seeing to the debugger.
        //
        
        if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

            SpyDumpFastIoOperation( FALSE, DEVICE_CONTROL );
        }
        
        //
        //  Perform filespy logging if we care about this device.
        //
        
        if (shouldLog) {

            //
            // Log the necessary information for the end of the Fast I/O 
            // operation if we were able to allocate a RecordList to store 
            // this information
            //

            if (recordList) {

                SpyLogFastIoComplete( IoStatus, recordList);
            }
        }
    }

    return returnValue;
}


VOID
SpyFastIoDetachDevice (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
)
/*++

Routine Description:

    This routine is invoked on the fast path to detach from a device that
    is being deleted.  This occurs when this driver has attached to a file
    system volume device object, and then, for some reason, the file system
    decides to delete that device (it is being dismounted, it was dismounted
    at some point in the past and its last reference has just gone away, etc.)

Arguments:

    SourceDevice - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

    TargetDevice - Pointer to the file system's volume device object.

Return Value:

    None.
    
--*/
{
    PRECORD_LIST recordList;
    BOOLEAN shouldLog;
    PFILESPY_DEVICE_EXTENSION devext;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( SourceDevice ) );

    devext = SourceDevice->DeviceExtension;

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, DETACH_DEVICE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(SourceDevice)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( DETACH_DEVICE, 
                                        SourceDevice, 
                                        NULL, 
                                        NULL, 
                                        0, 
                                        0 );
    }

    SPY_LOG_PRINT( SPYDEBUG_DISPLAY_ATTACHMENT_NAMES,
                   ("FileSpy!SpyFastIoDetachDevice:               Detaching from volume      %p \"%wZ\"\n",
                    TargetDevice,
                    &devext->DeviceName) );

    //
    // Detach from the file system's volume device object.
    //

    SpyCleanupMountedDevice( SourceDevice );
    IoDetachDevice( TargetDevice );
    IoDeleteDevice( SourceDevice );

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, DETACH_DEVICE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( NULL, recordList);
        }
    }
}
 
BOOLEAN
SpyFastIoQueryNetworkOpenInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying network
    information about a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller can handle the file system
        having to wait and tie up the current thread.

    Buffer - Pointer to a buffer to receive the network information about the
        file.

    IoStatus - Pointer to a variable to receive the final status of the query
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, QUERY_NETWORK_OPEN_INFO );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( QUERY_NETWORK_OPEN_INFO,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        Wait );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryNetworkOpenInfo )) {

            returnValue = (fastIoDispatch->FastIoQueryNetworkOpenInfo)( FileObject,
                                                                        Wait,
                                                                        Buffer,
                                                                        IoStatus,
                                                                        deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, QUERY_NETWORK_OPEN_INFO );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }

    return returnValue;
}

BOOLEAN
SpyFastIoMdlRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading a file
    using MDLs as buffers.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object that is to be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, MDL_READ );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( MDL_READ,
                                        DeviceObject,
                                        FileObject,                  
                                        FileOffset,                  
                                        Length,
                                        0 );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlRead )) {

            returnValue = (fastIoDispatch->MdlRead)( FileObject,
                                                     FileOffset,
                                                     Length,
                                                     LockKey,
                                                     MdlChain,
                                                     IoStatus,
                                                     deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, MDL_READ );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }

    return returnValue;
}
 
BOOLEAN
SpyFastIoMdlReadComplete (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read operation.

    This function simply invokes the next driver's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the MdlRead function is supported by the underlying driver, and
    therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL read upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.
    
--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, MDL_READ_COMPLETE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( MDL_READ_COMPLETE,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        0 );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlReadComplete )) {

            returnValue = (fastIoDispatch->MdlReadComplete)( FileObject,
                                                             MdlChain,
                                                             deviceObject);
        } 
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, MDL_READ_COMPLETE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {
        
        //
        // Log the necessary information for the end of the Fast I/O 
        // operation if we were able to allocate a RecordList to store 
        // this information
        //

        if (recordList) {

            SpyLogFastIoComplete( NULL, recordList);
        }
    }

    return returnValue;
}
 
BOOLEAN
SpyFastIoPrepareMdlWrite (
    IN  PFILE_OBJECT FileObject,
    IN  PLARGE_INTEGER FileOffset,
    IN  ULONG Length,
    IN  ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN  PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for preparing for an
    MDL write operation.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write 
        operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, PREPARE_MDL_WRITE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( PREPARE_MDL_WRITE,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        Length,
                                        0 );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, PrepareMdlWrite )) {

            returnValue = (fastIoDispatch->PrepareMdlWrite)( FileObject,
                                                             FileOffset,
                                                             Length,
                                                             LockKey,
                                                             MdlChain,
                                                             IoStatus,
                                                             deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, PREPARE_MDL_WRITE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }

    return returnValue;
}
 
BOOLEAN
SpyFastIoMdlWriteComplete (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL write operation.

    This function simply invokes the next driver's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the PrepareMdlWrite function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not
    assumed by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL write upon.

    FileOffset - Supplies the file offset at which the write took place.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, MDL_WRITE_COMPLETE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( MDL_WRITE_COMPLETE,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        0,
                                        0 );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlWriteComplete )) {

            returnValue = (fastIoDispatch->MdlWriteComplete)( FileObject,
                                                              FileOffset,
                                                              MdlChain,
                                                              deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, MDL_WRITE_COMPLETE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( NULL, recordList);
        }
    }

    return returnValue;
}
 
BOOLEAN
SpyFastIoReadCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading 
    compressed data from a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to a buffer to receive the compressed data read.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    CompressedDataInfo - A buffer to receive the description of the 
        compressed data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, READ_COMPRESSED );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( READ_COMPRESSED,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        Length,
                                        0 );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoReadCompressed )) {

            returnValue = (fastIoDispatch->FastIoReadCompressed)( FileObject,
                                                                  FileOffset,
                                                                  Length,
                                                                  LockKey,
                                                                  Buffer,
                                                                  MdlChain,
                                                                  IoStatus,
                                                                  CompressedDataInfo,
                                                                  CompressedDataInfoLength,
                                                                  deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, READ_COMPRESSED );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }

    return returnValue;
}
 
BOOLEAN
SpyFastIoWriteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing 
    compressed data to a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write 
        operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to the buffer containing the data to be written.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    CompressedDataInfo - A buffer to containing the description of the
        compressed data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, WRITE_COMPRESSED );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //
        
        recordList = SpyLogFastIoStart( WRITE_COMPRESSED,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        Length,
                                        0 );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoWriteCompressed )) {

            returnValue = (fastIoDispatch->FastIoWriteCompressed)( FileObject,
                                                                   FileOffset,
                                                                   Length,
                                                                   LockKey,
                                                                   Buffer,
                                                                   MdlChain,
                                                                   IoStatus,
                                                                   CompressedDataInfo,
                                                                   CompressedDataInfoLength,
                                                                   deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, WRITE_COMPRESSED );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }

    return returnValue;
}
 
BOOLEAN
SpyFastIoMdlReadCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read compressed operation.

    This function simply invokes the next driver's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the read compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not 
    assumed by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed read
        upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.
    
--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, MDL_READ_COMPLETE_COMPRESSED );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( MDL_READ_COMPLETE_COMPRESSED,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        0 );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlReadCompleteCompressed )) {

            returnValue = (fastIoDispatch->MdlReadCompleteCompressed)( FileObject,
                                                                       MdlChain,
                                                                       deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, MDL_READ_COMPLETE_COMPRESSED );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( NULL, recordList);
        }
    }

    return returnValue;
}
 
BOOLEAN
SpyFastIoMdlWriteCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing a
    write compressed operation.

    This function simply invokes the next driver's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the write compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not 
    assumed by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed write
        upon.

    FileOffset - Supplies the file offset at which the file write operation
        began.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, MDL_WRITE_COMPLETE_COMPRESSED );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( MDL_WRITE_COMPLETE_COMPRESSED,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        0,
                                        0 );
    }

    //
    // Pass through logic for this type of Fast I/O
    //
    
    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlWriteCompleteCompressed )) {

            returnValue = (fastIoDispatch->MdlWriteCompleteCompressed)( FileObject,
                                                                        FileOffset, 
                                                                        MdlChain,
                                                                        deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, MDL_WRITE_COMPLETE_COMPRESSED );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( NULL, recordList);
        }
    }

    return returnValue;
}
 
BOOLEAN
SpyFastIoQueryOpen (
    IN PIRP Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for opening a file
    and returning network information it.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    Irp - Pointer to a create IRP that represents this open operation.  It is
        to be used by the file system for common open/create code, but not
        actually completed.

    NetworkInformation - A buffer to receive the information required by the
        network about the file being opened.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN result = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, QUERY_OPEN );
    }

    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( QUERY_OPEN,
                                        DeviceObject,
                                        NULL,
                                        NULL,
                                        0,
                                        0 );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryOpen )) {

            PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );

            //
            //  Before calling the next filter, we must make sure their device
            //  object is in the current stack entry for the given IRP
            //

            irpSp->DeviceObject = deviceObject;

            result = (fastIoDispatch->FastIoQueryOpen)( Irp,
                                                        NetworkInformation,
                                                        deviceObject );
            //
            //  Restore the IRP back to our device object
            //

            irpSp->DeviceObject = DeviceObject;
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, QUERY_OPEN );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( &Irp->IoStatus, recordList);
        }
    }

    return result;
}

#if WINVER >= 0x0501 /* See comment in DriverEntry */

NTSTATUS
SpyPreFsFilterOperation (
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext
    )
/*++

Routine Description:

    This routine is the FS Filter pre-operation "pass through" routine.

Arguments:

    Data - The FS_FILTER_CALLBACK_DATA structure containing the information
        about this operation.
        
    CompletionContext - A context set by this operation that will be passed
        to the corresponding SpyPostFsFilterOperation call.
        
Return Value:

    Returns STATUS_SUCCESS if the operation can continue or an appropriate
    error code if the operation should fail.

--*/
{

    PDEVICE_OBJECT deviceObject;
    PRECORD_LIST recordList = NULL;
    BOOLEAN shouldLog;

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FSFILTER_OPS )) {

        SpyDumpFsFilterOperation( TRUE, Data );
    }

    deviceObject = Data->DeviceObject;

    ASSERT( IS_FILESPY_DEVICE_OBJECT( deviceObject ) );

    if (shouldLog = SHOULD_LOG( deviceObject )) {

        recordList = SpyNewRecord(0);

        if (recordList != NULL) {

            //
            //  Log the necessary information for the start of this
            //  operation.
            //

            SpyLogPreFsFilterOperation( Data, recordList );
        }
    }

    *CompletionContext = recordList;

    return STATUS_SUCCESS;
}

VOID
SpyPostFsFilterOperation (
    IN PFS_FILTER_CALLBACK_DATA Data,
    IN NTSTATUS OperationStatus,
    IN PVOID CompletionContext
    )
/*++

Routine Description:

    This routine is the FS Filter post-operation "pass through" routine.

Arguments:

    Data - The FS_FILTER_CALLBACK_DATA structure containing the information
        about this operation.
        
    OperationStatus - The status of this operation.        
    
    CompletionContext - A context that was set in the pre-operation 
        callback by this driver.
        
Return Value:

    None.
    
--*/
{

    PDEVICE_OBJECT deviceObject;
    PRECORD_LIST recordList = (PRECORD_LIST) CompletionContext;
    BOOLEAN shouldLog;

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //

    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FSFILTER_OPS )) {

        SpyDumpFsFilterOperation( FALSE, Data );
    }

    deviceObject = Data->DeviceObject;

    ASSERT( IS_FILESPY_DEVICE_OBJECT( deviceObject ) );

    if ((shouldLog = SHOULD_LOG( deviceObject )) &&
        (recordList != NULL)) {

        //
        //  Log the necessary information for the end of the Fast IO
        //  operation if we have a recordList.
        //

        SpyLogPostFsFilterOperation( OperationStatus, recordList );

        //
        //  Add recordList to our gOutputBufferList so that it gets up to 
        //  the user.  We don't have to worry about freeing the recordList
        //  at this time because it will get free when it is taken off
        //  gOutputBufferList.
        //

        SpyLog(recordList);       
        
    } else if (recordList != NULL) {

        //
        //  We are no longer logging for this device, so just
        //  free this recordList entry.
        //

        SpyFreeRecord( recordList );
    }
}

#endif

NTSTATUS
SpyCommonDeviceIoControl (
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    This routine does the common processing of interpreting the Device IO Control
    request.

Arguments:

    FileObject - The file object related to this operation.
    
    InputBuffer - The buffer containing the input parameters for this control
        operation.
        
    InputBufferLength - The length in bytes of InputBuffer.
    
    OutputBuffer - The buffer to receive any output from this control operation.
    
    OutputBufferLength - The length in bytes of OutputBuffer.
    
    IoControlCode - The control code specifying what control operation this is.
    
    IoStatus - Receives the status of this operation.
    
Return Value:

    None.
    
--*/
{
    PWSTR deviceName = NULL;
    FILESPYVER fileSpyVer;

    PAGED_CODE();

    ASSERT( IoStatus != NULL );
    
    IoStatus->Status      = STATUS_SUCCESS;
    IoStatus->Information = 0;

    //
    //  As we access the input and output buffers below, note that we wrap
    //  these accesses with a try/except.  Even though all of FileSpy's private
    //  IOCTLs are METHOD_BUFFERED, this is necessary when handling FileSpy's
    //  IOCTLs via the FASTIO path.  When the FASTIO path is called, the IO 
    //  Manager has not done the work to buffer the input buffer, output buffer 
    //  or both buffers (as specified by the IOCTL definition).  This work will
    //  only be done if the IOCTLs is passed down the IRP path after FALSE has
    //  been returned via the FASTIO path.  Therefore, the user could have
    //  passed down a bad buffer and we must protect ourself from that.
    //
    //  Note that we do not just wrap this entire routine with a try/except
    //  block because some of the helper routines will call back into
    //  the operating system (like SpyStartLoggingDevice and 
    //  SpyStopLoggingDevice) and we do not want to mask any exceptions that
    //  were raised by other components along these paths.
    //  

    switch (IoControlCode) {
        case FILESPY_Reset:
            IoStatus->Status = STATUS_INVALID_PARAMETER;
            break;

        //
        //      Request to start logging on a device
        //                                      

        case FILESPY_StartLoggingDevice:

            if (InputBuffer == NULL || InputBufferLength <= 0) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }
        
            //
            // Copy the device name and add a null to ensure that it is null terminated
            //

            deviceName =  ExAllocatePoolWithTag( NonPagedPool, 
                                                 InputBufferLength + sizeof(WCHAR),
                                                 FILESPY_POOL_TAG );

            if (NULL == deviceName) {

                IoStatus->Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            try {

                RtlCopyMemory( deviceName, InputBuffer, InputBufferLength );
                
            } except (EXCEPTION_EXECUTE_HANDLER) {

                IoStatus->Status = GetExceptionCode();
            }

            if (NT_SUCCESS( IoStatus->Status )) {
                
                deviceName[InputBufferLength / sizeof(WCHAR)] = UNICODE_NULL;
                IoStatus->Status = SpyStartLoggingDevice( deviceName );
            }
            break;  

        //
        //      Detach from a specified device
        //  

        case FILESPY_StopLoggingDevice:

            if (InputBuffer == NULL || InputBufferLength <= 0) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }
        
            //
            // Copy the device name and add a null to ensure that it is null terminated
            //

            deviceName =  ExAllocatePoolWithTag( NonPagedPool, 
                                                 InputBufferLength + sizeof(WCHAR),
                                                 FILESPY_POOL_TAG );

            if (NULL == deviceName) {

                IoStatus->Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            try {
                
                RtlCopyMemory( deviceName, InputBuffer, InputBufferLength );

            } except (EXCEPTION_EXECUTE_HANDLER) {

                IoStatus->Status = GetExceptionCode();
            }

            if (NT_SUCCESS( IoStatus->Status )) {
                
                deviceName[InputBufferLength / sizeof(WCHAR) - 1] = UNICODE_NULL;
                IoStatus->Status = SpyStopLoggingDevice( deviceName );
            }
            
            break;  

        //
        //      List all the devices that we are currently
        //      monitoring
        //

        case FILESPY_ListDevices:

            if (OutputBuffer == NULL || OutputBufferLength <= 0) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }

            try {

                IoStatus->Status = SpyGetAttachList( OutputBuffer,
                                                     OutputBufferLength,
                                                     &IoStatus->Information);
                
            } except (EXCEPTION_EXECUTE_HANDLER) {

                IoStatus->Status = GetExceptionCode();
            }

            break;

        //
        //      Return entries from the log buffer
        //                                      

        case FILESPY_GetLog:

            if (OutputBuffer == NULL || OutputBufferLength == 0) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }

            try {
                
                SpyGetLog( OutputBuffer, OutputBufferLength, IoStatus );
                
            } except (EXCEPTION_EXECUTE_HANDLER) {

                IoStatus->Status = GetExceptionCode();
            }
            
            break;

        //
        //      Return version of the FileSpy filter driver
        //                                      

        case FILESPY_GetVer:

            if ((OutputBufferLength < sizeof(FILESPYVER)) || 
                (OutputBuffer == NULL)) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;                    
            }
        
            fileSpyVer.Major = FILESPY_MAJ_VERSION;
            fileSpyVer.Minor = FILESPY_MIN_VERSION;
            IoStatus->Information = sizeof(FILESPYVER);

            try {        
                
                RtlCopyMemory(OutputBuffer, &fileSpyVer, sizeof(FILESPYVER));

            } except (EXCEPTION_EXECUTE_HANDLER) {

                IoStatus->Status = GetExceptionCode();
                IoStatus->Information = 0;
            }
        
            break;
    
        //
        //      Return hash table statistics
        //                                      

        case FILESPY_GetStats:

            if ((OutputBufferLength < sizeof(gStats)) || 
                (OutputBuffer == NULL)) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;                    
            }

            IoStatus->Information = sizeof(gStats);

            try {
                
                RtlCopyMemory( OutputBuffer, &gStats, sizeof(gStats) );

            } except (EXCEPTION_EXECUTE_HANDLER) {

                IoStatus->Status = GetExceptionCode();
                IoStatus->Information = 0;
            }
            
            break;
        
        default:

            IoStatus->Status = STATUS_INVALID_PARAMETER;
            break;
    }

    if (NULL != deviceName) {

        ExFreePoolWithTag( deviceName, FILESPY_POOL_TAG );
    }

  return IoStatus->Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\filter\fspykern.h ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    fspyKern.h

Abstract:
    Header file which contains the structures, type definitions,
    constants, global variables and function prototypes that are
    only visible within the kernel.

    As of the Windows XP SP1 IFS Kit version of this sample and later, this
    sample can be built for each build environment released with the IFS Kit
    with no additional modifications.  To provide this capability, additional
    compile-time logic was added -- see the '#if WINVER' locations.  Comments
    tagged with the 'VERSION NOTE' header have also been added as appropriate to
    describe how the logic must change between versions.

    If this sample is built in the Windows XP environment or later, it will run
    on Windows 2000 or later.  This is done by dynamically loading the routines
    that are only available on Windows XP or later and making run-time decisions
    to determine what code to execute.  Comments tagged with 'MULTIVERISON NOTE'
    mark the locations where such logic has been added.

// @@BEGIN_DDKSPLIT

Author:

    George Jenkins (georgeje)
    Neal Christiansen (nealch)
    Molly Brown (mollybro)  

// @@END_DDKSPLIT

Environment:

    Kernel mode

// @@BEGIN_DDKSPLIT

Revision History:
    Neal Christiansen (nealch) updated to support stream contexts

    Molly Brown (mollybro)         21-May-2002
        Modify sample to make it support running on Windows 2000 or later if
        built in the latest build environment and allow it to be built in W2K 
        and later build environments.

// @@END_DDKSPLIT
--*/
#ifndef __FSPYKERN_H__
#define __FSPYKERN_H__

//
//  VERSION NOTE:
//
//  The following useful macros are defined in NTIFS.H in Windows XP and later.
//  We will define them locally if we are building for the Windows 2000 
//  environment.
//

#if WINVER == 0x0500

//
//  These macros are used to test, set and clear flags respectively
//

#ifndef FlagOn
#define FlagOn(_F,_SF)        ((_F) & (_SF))
#endif

#ifndef BooleanFlagOn
#define BooleanFlagOn(F,SF)   ((BOOLEAN)(((F) & (SF)) != 0))
#endif

#ifndef SetFlag
#define SetFlag(_F,_SF)       ((_F) |= (_SF))
#endif

#ifndef ClearFlag
#define ClearFlag(_F,_SF)     ((_F) &= ~(_SF))
#endif


#define RtlInitEmptyUnicodeString(_ucStr,_buf,_bufSize) \
    ((_ucStr)->Buffer = (_buf), \
     (_ucStr)->Length = 0, \
     (_ucStr)->MaximumLength = (USHORT)(_bufSize))


#ifndef min
#define min(a,b) (((a) < (b)) ? (a) : (b))
#endif

#ifndef max
#define max(a,b) (((a) > (b)) ? (a) : (b))
#endif

#define ExFreePoolWithTag( a, b ) ExFreePool( (a) )
#endif /* WINVER == 0x0500 */

//
//  This controls how FileSpy is built.  It has 2 options:
//  0 - Build using NameHashing (old way, see fspyHash.c)
//  1 - Build using StreamContexts (new Way, see fspyCtx.c)
//
//  VERSION NOTE:
//  
//  Filter stream contexts are only supported on Windows XP and later
//  OS versions.  This support was not available in Windows 2000 or NT 4.0.
//

#define USE_STREAM_CONTEXTS 0

#if USE_STREAM_CONTEXTS && WINVER < 0x0501
#error Stream contexts on only supported on Windows XP or later.
#endif

//
//  POOL Tag definitions
//

#define FILESPY_POOL_TAG        'ypSF'          //misc POOL allocations
#define FILESPY_LOGRECORD_TAG   'rlSF'          //log record tag
#define FILESPY_CONTEXT_TAG     'xcSF'          //contexts tag

#ifndef INVALID_HANDLE_VALUE
#define INVALID_HANDLE_VALUE ((HANDLE) -1)
#endif

#define CONSTANT_UNICODE_STRING(s)   { sizeof( s ) - sizeof( WCHAR ), sizeof(s), s }

//
//  Delay values for KeDelayExecutionThread()
//  (Values are negative to represent relative time)
//

#define DELAY_ONE_MICROSECOND   (-10)
#define DELAY_ONE_MILLISECOND   (DELAY_ONE_MICROSECOND*1000)
#define DELAY_ONE_SECOND        (DELAY_ONE_MILLISECOND*1000)

//
//  Don't use look-aside-list in the debug versions
//

#if DBG
#define MEMORY_DBG
#endif

//---------------------------------------------------------------------------
//  Macros for FileSpy DbgPrint levels.
//---------------------------------------------------------------------------

#define SPY_LOG_PRINT( _dbgLevel, _string )                 \
    (FlagOn(gFileSpyDebugLevel,(_dbgLevel)) ?               \
        DbgPrint _string  :                                 \
        ((void)0))


//---------------------------------------------------------------------------
//      Generic Resource acquire/release macros
//---------------------------------------------------------------------------

#define SpyAcquireResourceExclusive( _r, _wait )                            \
    (ASSERT( ExIsResourceAcquiredExclusiveLite((_r)) ||                     \
            !ExIsResourceAcquiredSharedLite((_r)) ),                        \
     KeEnterCriticalRegion(),                                               \
     ExAcquireResourceExclusiveLite( (_r), (_wait) ))

#define SpyAcquireResourceShared( _r, _wait )                               \
    (KeEnterCriticalRegion(),                                               \
     ExAcquireResourceSharedLite( (_r), (_wait) ))

#define SpyReleaseResource( _r )                                            \
    (ASSERT( ExIsResourceAcquiredSharedLite((_r)) ||                        \
             ExIsResourceAcquiredExclusiveLite((_r)) ),                     \
     ExReleaseResourceLite( (_r) ),                                         \
     KeLeaveCriticalRegion())

//---------------------------------------------------------------------------
// Macro to test if we are logging for this device
//
// NOTE: We don't bother synchronizing to check the gControlDeviceState since
//   we can tolerate a stale value here.  We just look at it here to avoid 
//   doing the logging work if we can.  We synchronize to check the 
//   gControlDeviceState before we add the log record to the gOutputBufferList 
//   and discard the log record if the ControlDevice is no longer OPENED.
//---------------------------------------------------------------------------

#define SHOULD_LOG(pDeviceObject) \
    ((gControlDeviceState == OPENED) && \
     FlagOn(((PFILESPY_DEVICE_EXTENSION)(pDeviceObject)->DeviceExtension)->Flags,LogThisDevice))

     
//---------------------------------------------------------------------------
//      Global variables
//---------------------------------------------------------------------------

//
//  Debugger definitions
//

typedef enum _SPY_DEBUG_FLAGS {

    SPYDEBUG_DISPLAY_ATTACHMENT_NAMES       = 0x00000001,
    SPYDEBUG_ERROR                          = 0x00000002,
    SPYDEBUG_TRACE_NAME_REQUESTS            = 0x00000004,
    SPYDEBUG_TRACE_IRP_OPS                  = 0x00000010,
    SPYDEBUG_TRACE_FAST_IO_OPS              = 0x00000020,
    SPYDEBUG_TRACE_FSFILTER_OPS             = 0x00000040,
    SPYDEBUG_TRACE_CONTEXT_OPS              = 0x00000100,
    SPYDEBUG_TRACE_DETAILED_CONTEXT_OPS     = 0x00000200,
    SPYDEBUG_TRACE_MISMATCHED_NAMES         = 0x00001000,
    SPYDEBUG_ASSERT_MISMATCHED_NAMES        = 0x00002000,

    SPYDEBUG_BREAK_ON_DRIVER_ENTRY          = 0x80000000
} SPY_DEBUG_FLAGS;

//
//  FileSpy global variables
//

extern SPY_DEBUG_FLAGS gFileSpyDebugLevel;
extern ULONG gFileSpyAttachMode;

extern PDEVICE_OBJECT gControlDeviceObject;
extern PDRIVER_OBJECT gFileSpyDriverObject;

extern FAST_MUTEX gSpyDeviceExtensionListLock;
extern LIST_ENTRY gSpyDeviceExtensionList;

extern KSPIN_LOCK gOutputBufferLock;
extern LIST_ENTRY gOutputBufferList;

extern NPAGED_LOOKASIDE_LIST gFreeBufferList;

extern ULONG gLogSequenceNumber;
extern KSPIN_LOCK gLogSequenceLock;

extern UNICODE_STRING gVolumeString;
extern UNICODE_STRING gOverrunString;
extern UNICODE_STRING gPagingIoString;

extern LONG gStaticBufferInUse;
extern CHAR gOutOfMemoryBuffer[RECORD_SIZE];

//
//  Statistics definitions.  Note that we don't do interlocked operations
//  because loosing a count once in a while isn't important enough vs the
//  overhead.
//

extern FILESPY_STATISTICS gStats;

#define INC_STATS(field)    (gStats.field++)
#define INC_LOCAL_STATS(var) ((var)++)

//
//  Attachment lock
//

extern FAST_MUTEX gSpyAttachLock;

//
//  FileSpy Registry values
//

#define DEFAULT_MAX_RECORDS_TO_ALLOCATE 100;
#define DEFAULT_MAX_NAMES_TO_ALLOCATE   100;
#define DEFAULT_FILESPY_DEBUG_LEVEL     SPYDEBUG_ERROR;
#define MAX_RECORDS_TO_ALLOCATE         L"MaxRecords"
#define MAX_NAMES_TO_ALLOCATE           L"MaxNames"
#define DEBUG_LEVEL                     L"DebugFlags"
#define ATTACH_MODE                     L"AttachMode"

extern LONG gMaxRecordsToAllocate;
extern LONG gRecordsAllocated;
extern LONG gMaxNamesToAllocate;
extern LONG gNamesAllocated;

//
//  Our Control Device State information
//

typedef enum _CONTROL_DEVICE_STATE {

    OPENED,
    CLOSED,
    CLEANING_UP

} CONTROL_DEVICE_STATE;

extern CONTROL_DEVICE_STATE gControlDeviceState;
extern KSPIN_LOCK gControlDeviceStateLock;

//
//  Given a device type, return a valid name
//

extern const PCHAR DeviceTypeNames[];
extern ULONG SizeOfDeviceTypeNames;

#define GET_DEVICE_TYPE_NAME( _type ) \
            ((((_type) > 0) && ((_type) < (SizeOfDeviceTypeNames / sizeof(PCHAR)))) ? \
                DeviceTypeNames[ (_type) ] : \
                "[Unknown]")

//---------------------------------------------------------------------------
//      Global defines
//---------------------------------------------------------------------------

//
//  Macro to test for device types we want to attach to
//

#define IS_SUPPORTED_DEVICE_TYPE(_type) \
    (((_type) == FILE_DEVICE_DISK_FILE_SYSTEM) || \
     ((_type) == FILE_DEVICE_CD_ROM_FILE_SYSTEM) || \
     ((_type) == FILE_DEVICE_NETWORK_FILE_SYSTEM))

//
// Returns the number of BYTES unused in the RECORD_LIST structure
//

#define REMAINING_NAME_SPACE(RecordList) \
    (USHORT)(RECORD_SIZE - \
            (((RecordList)->LogRecord.Length) + sizeof(LIST_ENTRY)))

#define USER_NAMES_SZ   64

//---------------------------------------------------------------------------
//      NameLookup Flags
//---------------------------------------------------------------------------

//
//    These are flags passed to the name lookup routine to identify different
//    ways the name of a file can be obtained
//

typedef enum _NAME_LOOKUP_FLAGS {

    //
    //  If set, only check in the name cache for the file name.
    //

    NLFL_ONLY_CHECK_CACHE           = 0x00000001,

    //
    //  If set, don't lookup the name
    //

    NLFL_NO_LOOKUP                  = 0x00000002,

    //
    //  if set, we are in the CREATE operation and the full path filename may
    //  need to be built up from the related FileObject.
    //

    NLFL_IN_CREATE                  = 0x00000004,
                
    //
    //  if set and we are looking up the name in the file object, the file object
    //  does not actually contain a name but it contains a file/object ID.
    //

    NLFL_OPEN_BY_ID                 = 0x00000008,

    //
    //  If set, the target directory is being opened
    //

    NLFL_OPEN_TARGET_DIR            = 0x00000010

} NAME_LOOKUP_FLAGS;


//---------------------------------------------------------------------------
//      Device Extension defines
//---------------------------------------------------------------------------

typedef enum _FSPY_DEV_FLAGS {

    //
    //  If set, this is an attachment to a volume device object, 
    //  If not set, this is an attachment to a file system control device
    //  object.
    //

    IsVolumeDeviceObject = 0x00000001,

    //
    //  If set, logging is turned on for this device
    //

    LogThisDevice = 0x00000002,

    //
    //  If set, contexts are initialized
    //

    ContextsInitialized = 0x00000004,
    
    //
    //  If set, this is linked into the extension list
    //

    ExtensionIsLinked = 0x00000008

} FSPY_DEV_FLAGS;


//
// Define the device extension structure that the FileSpy driver
// adds to each device object it is attached to.  It stores
// the context FileSpy needs to perform its logging operations on
// a device.
//

typedef struct _FILESPY_DEVICE_EXTENSION {

    //
    //  Device Object this extension is attached to
    //

    PDEVICE_OBJECT ThisDeviceObject;

    //
    //  Device object this filter is directly attached to
    //

    PDEVICE_OBJECT AttachedToDeviceObject;

    //
    //  When attached to Volume Device Objects, the physical device object
    //  that represents that volume.  NULL when attached to Control Device
    //  objects.
    //

    PDEVICE_OBJECT DiskDeviceObject;

    //
    //  Linked list of devices we are attached to
    //

    LIST_ENTRY NextFileSpyDeviceLink;

    //
    //  Flags for this device
    //

    FSPY_DEV_FLAGS Flags;

    //
    //  Linked list of contexts associated with this volume along with the
    //  lock.
    //

    LIST_ENTRY CtxList;
    ERESOURCE CtxLock;

    //
    //  When renaming a directory there is a window where the current names
    //  in the context cache may be invalid.  To eliminate this window we
    //  increment this count every time we start doing a directory rename 
    //  and decrement this count when it is completed.  When this count is
    //  non-zero then we query for the name every time so we will get a
    //  correct name for that instance in time.
    //

    ULONG AllContextsTemporary;

    //
    //  Name for this device.  If attached to a Volume Device Object it is the
    //  name of the physical disk drive.  If attached to a Control Device
    //  Object it is the name of the Control Device Object.
    //

    UNICODE_STRING DeviceName;

    //
    // Names the user used to start logging this device
    //

    UNICODE_STRING UserNames;

    //
    //  Buffers used to hold the above unicode strings
    //  Note:  We keep these two forms of the name so that we can build
    //         a nicer looking name when we are printing out file names.
    //         We want just the "c:" type device name at the beginning
    //         of a file name, not "\device\hardiskVolume1".
    //

    WCHAR DeviceNameBuffer[DEVICE_NAMES_SZ];
    WCHAR UserNamesBuffer[USER_NAMES_SZ];

} FILESPY_DEVICE_EXTENSION, *PFILESPY_DEVICE_EXTENSION;


#define IS_FILESPY_DEVICE_OBJECT( _devObj )                               \
    (((_devObj) != NULL) &&                                               \
     ((_devObj)->DriverObject == gFileSpyDriverObject) &&                 \
     ((_devObj)->DeviceExtension != NULL))


#if WINVER >= 0x0501
//
//  MULTIVERSION NOTE:
//
//  If built in the Windows XP environment or later, we will dynamically import
//  the function pointers for routines that were not supported on Windows 2000
//  so that we can build a driver that will run, with modified logic, on 
//  Windows 2000 or later.
//
//  Below are the prototypes for the function pointers that we need to 
//  dynamically import because not all OS versions support these routines.
//

typedef
NTSTATUS
(*PSPY_REGISTER_FILE_SYSTEM_FILTER_CALLBACKS) (
    IN PDRIVER_OBJECT DriverObject,
    IN PFS_FILTER_CALLBACKS Callbacks
    );

typedef
NTSTATUS
(*PSPY_ENUMERATE_DEVICE_OBJECT_LIST) (
    IN  PDRIVER_OBJECT DriverObject,
    IN  PDEVICE_OBJECT *DeviceObjectList,
    IN  ULONG DeviceObjectListSize,
    OUT PULONG ActualNumberDeviceObjects
    );

typedef
NTSTATUS
(*PSPY_ATTACH_DEVICE_TO_DEVICE_STACK_SAFE) (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice,
    OUT PDEVICE_OBJECT *AttachedToDeviceObject
    );

typedef    
PDEVICE_OBJECT
(*PSPY_GET_LOWER_DEVICE_OBJECT) (
    IN  PDEVICE_OBJECT  DeviceObject
    );

typedef
PDEVICE_OBJECT
(*PSPY_GET_DEVICE_ATTACHMENT_BASE_REF) (
    IN PDEVICE_OBJECT DeviceObject
    );

typedef
NTSTATUS
(*PSPY_GET_DISK_DEVICE_OBJECT) (
    IN  PDEVICE_OBJECT  FileSystemDeviceObject,
    OUT PDEVICE_OBJECT  *DiskDeviceObject
    );

typedef
PDEVICE_OBJECT
(*PSPY_GET_ATTACHED_DEVICE_REFERENCE) (
    IN PDEVICE_OBJECT DeviceObject
    );

typedef
NTSTATUS
(*PSPY_GET_VERSION) (
    IN OUT PRTL_OSVERSIONINFOW VersionInformation
    );

typedef struct _SPY_DYNAMIC_FUNCTION_POINTERS {

    PSPY_REGISTER_FILE_SYSTEM_FILTER_CALLBACKS RegisterFileSystemFilterCallbacks;
    PSPY_ATTACH_DEVICE_TO_DEVICE_STACK_SAFE AttachDeviceToDeviceStackSafe;
    PSPY_ENUMERATE_DEVICE_OBJECT_LIST EnumerateDeviceObjectList;
    PSPY_GET_LOWER_DEVICE_OBJECT GetLowerDeviceObject;
    PSPY_GET_DEVICE_ATTACHMENT_BASE_REF GetDeviceAttachmentBaseRef;
    PSPY_GET_DISK_DEVICE_OBJECT GetDiskDeviceObject;
    PSPY_GET_ATTACHED_DEVICE_REFERENCE GetAttachedDeviceReference;
    PSPY_GET_VERSION GetVersion;

} SPY_DYNAMIC_FUNCTION_POINTERS, *PSPY_DYNAMIC_FUNCTION_POINTERS;

extern SPY_DYNAMIC_FUNCTION_POINTERS gSpyDynamicFunctions;

//
//  MULTIVERSION NOTE: For this version of the driver, we need to know the
//  current OS version while we are running to make decisions regarding what
//  logic to use when the logic cannot be the same for all platforms.  We
//  will look up the OS version in DriverEntry and store the values
//  in these global variables.
//

extern ULONG gSpyOsMajorVersion;
extern ULONG gSpyOsMinorVersion;

//
//  Here is what the major and minor versions should be for the various OS versions:
//
//  OS Name                                 MajorVersion    MinorVersion
//  ---------------------------------------------------------------------
//  Windows 2000                             5                 0
//  Windows XP                               5                 1
//  Windows Server 2003                      5                 2
//

#define IS_WINDOWSXP_OR_LATER() \
    (((gSpyOsMajorVersion == 5) && (gSpyOsMinorVersion >= 1)) || \
     (gSpyOsMajorVersion > 5))

#endif

//
//  Structure used to pass context information from dispatch routines to
//  completion routines for FSCTRL operations.  We need a different structures
//  for Windows 2000 from what we can use on Windows XP and later because
//  we handle the completion processing differently.
//

typedef struct _SPY_COMPLETION_CONTEXT {

    PRECORD_LIST RecordList;

} SPY_COMPLETION_CONTEXT, *PSPY_COMPLETION_CONTEXT;

typedef struct _SPY_COMPLETION_CONTEXT_W2K {

    SPY_COMPLETION_CONTEXT;
    
    WORK_QUEUE_ITEM WorkItem;
    PDEVICE_OBJECT DeviceObject;
    PIRP Irp;
    PDEVICE_OBJECT NewDeviceObject;

} SPY_COMPLETION_CONTEXT_W2K, *PSPY_COMPLETION_CONTEXT_W2K;

#if WINVER >= 0x0501
typedef struct _SPY_COMPLETION_CONTEXT_WXP_OR_LATER {

    SPY_COMPLETION_CONTEXT;
    
    KEVENT WaitEvent;

} SPY_COMPLETION_CONTEXT_WXP_OR_LATER, *PSPY_COMPLETION_CONTEXT_WXP_OR_LATER;
#endif

#ifndef FORCEINLINE
#define FORCEINLINE __inline
#endif

FORCEINLINE
VOID
SpyCopyFileNameToLogRecord( 
    PLOG_RECORD LogRecord,
    PUNICODE_STRING FileName
    )
/*++

Routine Description:

    Inline function to copy the file name into the log record.  The routine
    only copies as much of the file name into the log record as the log
    record allows.  Therefore, if the name is too long for the record, it will
    be truncated.  Also, the name is always NULL-terminated.

Arguments:

    LogRecord - The log record for which the name should be set.

    FileName - The file name to be set in the log record.

Return Value:

    None.

--*/
{                                                                          
    //
    //  Include space for NULL when copying the name
    //
    
    ULONG toCopy = min( MAX_NAME_SPACE,                                  
                        (ULONG)FileName->Length + sizeof( WCHAR ) );     
    
    RtlCopyMemory( LogRecord->Name,                                    
                   FileName->Buffer,                                       
                   toCopy - sizeof( WCHAR ) );
    
    //
    //  NULL terminate
    //
    
    LogRecord->Name[toCopy/sizeof( WCHAR ) - 1] = L'\0';
    LogRecord->Length += toCopy ;
}


    
////////////////////////////////////////////////////////////////////////
//
//    Prototypes for the routines this driver uses to filter the
//    the data that is being seen by this file systems.
//
//                   implemented in filespy.c
//
////////////////////////////////////////////////////////////////////////

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
SpyDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpyPassThrough (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpyPassThroughCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
SpyCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpyClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
SpyFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN        
SpyFastIoWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoQueryStandardInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoDeviceControl (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
SpyFastIoDetachDevice (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
    );

BOOLEAN
SpyFastIoQueryNetworkOpenInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoMdlRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoMdlReadComplete (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoPrepareMdlWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoMdlWriteComplete (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoReadCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoWriteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoMdlReadCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoMdlWriteCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoQueryOpen (
    IN PIRP Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN PDEVICE_OBJECT DeviceObject
    );

#if WINVER >= 0x0501 /* See comment in DriverEntry */

NTSTATUS
SpyPreFsFilterOperation (
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext
    );

VOID
SpyPostFsFilterOperation (
    IN PFS_FILTER_CALLBACK_DATA Data,
    IN NTSTATUS OperationStatus,
    IN PVOID CompletionContext
    );

#endif

NTSTATUS
SpyCommonDeviceIoControl (
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus
    );

//-----------------------------------------------------
//
//  These routines are only used if Filespy is attaching
//  to all volumes in the system instead of attaching to
//  volumes on demand.
//
//-----------------------------------------------------

NTSTATUS
SpyFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpyFsControlMountVolume (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SpyFsControlMountVolumeCompleteWorker (
    IN PSPY_COMPLETION_CONTEXT_W2K Context
    );

NTSTATUS
SpyFsControlMountVolumeComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_OBJECT NewDeviceObject
    );

NTSTATUS
SpyFsControlLoadFileSystem (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpyFsControlLoadFileSystemComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SpyFsControlLoadFileSystemCompleteWorker (
    IN PSPY_COMPLETION_CONTEXT_W2K Context
    );

VOID
SpyFsNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FsActive
    );

NTSTATUS
SpyMountCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
SpyLoadFsCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

////////////////////////////////////////////////////////////////////////
//
//                  Library support routines
//                   implemented in fspylib.c
//
////////////////////////////////////////////////////////////////////////

VOID
SpyReadDriverParameters (
    IN PUNICODE_STRING RegistryPath
    );

#if WINVER >= 0x0501
VOID
SpyLoadDynamicFunctions (
    );

VOID
SpyGetCurrentVersion (
    );
#endif
    
////////////////////////////////////////////////////////////////////////
//
//                  Memory allocation routines
//                   implemented in fspylib.c
//
////////////////////////////////////////////////////////////////////////

PVOID
SpyAllocateBuffer (
    IN OUT PLONG Counter,
    IN LONG MaxCounterValue,
    OUT PULONG RecordType
    );

VOID
SpyFreeBuffer (
    PVOID Buffer,
    PLONG Counter
    );

////////////////////////////////////////////////////////////////////////
//
//                      Logging routines
//                   implemented in fspylib.c
//
////////////////////////////////////////////////////////////////////////

PRECORD_LIST
SpyNewRecord (
    ULONG AssignedSequenceNumber
    );

VOID
SpyFreeRecord (
    PRECORD_LIST Record
    );

PRECORD_LIST
SpyLogFastIoStart (
    IN FASTIO_TYPE FastIoType,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait
    );

VOID
SpyLogFastIoComplete (
    IN PIO_STATUS_BLOCK ReturnStatus,
    IN PRECORD_LIST RecordList
    );

#if WINVER >= 0x0501 /* See comment in DriverEntry */

VOID
SpyLogPreFsFilterOperation (
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PRECORD_LIST RecordList
    );

VOID
SpyLogPostFsFilterOperation (
    IN NTSTATUS OperationStatus,
    OUT PRECORD_LIST RecordList
    );

#endif

NTSTATUS
SpyAttachDeviceToDeviceStack (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice,
    IN OUT PDEVICE_OBJECT *AttachedToDeviceObject
    );

NTSTATUS
SpyLog (
    IN PRECORD_LIST NewRecord
    );

////////////////////////////////////////////////////////////////////////
//
//                    FileName cache routines
//                    implemented in fspylib.c
//
////////////////////////////////////////////////////////////////////////

BOOLEAN
SpyGetFullPathName (
    IN PFILE_OBJECT FileObject,
    IN OUT PUNICODE_STRING FileName,
    IN PFILESPY_DEVICE_EXTENSION DeviceExtension,
    IN NAME_LOOKUP_FLAGS LookupFlags
    );

NTSTATUS
SpyQueryFileSystemForFileName (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT NextDeviceObject,
    IN ULONG FileNameInfoLength,
    OUT PFILE_NAME_INFORMATION FileNameInfo,
    OUT PULONG ReturnedLength
    );

NTSTATUS
SpyQueryInformationFile (
	IN PDEVICE_OBJECT NextDeviceObject,
	IN PFILE_OBJECT FileObject,
	OUT PVOID FileInformation,
	IN ULONG Length,
	IN FILE_INFORMATION_CLASS FileInformationClass,
	OUT PULONG LengthReturned OPTIONAL
    );

////////////////////////////////////////////////////////////////////////
//
//         Common attachment and detachment routines
//              implemented in fspylib.c
//
////////////////////////////////////////////////////////////////////////

NTSTATUS 
SpyIsAttachedToDeviceByUserDeviceName (
    IN PUNICODE_STRING DeviceName,
    IN OUT PBOOLEAN IsAttached,
    IN OUT PDEVICE_OBJECT *StackDeviceObject,
    IN OUT PDEVICE_OBJECT *OurAttachedDeviceObject
    );

BOOLEAN
SpyIsAttachedToDevice (
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject
    );

BOOLEAN
SpyIsAttachedToDeviceW2K (
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject
    );

#if WINVER >= 0x0501
BOOLEAN
SpyIsAttachedToDeviceWXPAndLater (
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject
    );
#endif

NTSTATUS
SpyAttachToMountedDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT FilespyDeviceObject
    );

VOID
SpyCleanupMountedDevice (
    IN PDEVICE_OBJECT DeviceObject
    );

////////////////////////////////////////////////////////////////////////
//
//           Helper routine for turning on/off logging on demand
//                  implemented in fspylib.c
//
////////////////////////////////////////////////////////////////////////

NTSTATUS
SpyGetDeviceObjectFromName (
    IN PUNICODE_STRING DeviceName,
    OUT PDEVICE_OBJECT *DeviceObject
    );

////////////////////////////////////////////////////////////////////////
//
//                 Start/stop logging routines and helper functions
//                  implemented in fspylib.c
//
////////////////////////////////////////////////////////////////////////

NTSTATUS
SpyAttachToDeviceOnDemand (
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING UserDeviceName,
    IN OUT PDEVICE_OBJECT *FileSpyDeviceObject
    );

NTSTATUS
SpyAttachToDeviceOnDemandW2K (
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING UserDeviceName,
    IN OUT PDEVICE_OBJECT *FileSpyDeviceObject
    );

#if WINVER >= 0x0501
NTSTATUS
SpyAttachToDeviceOnDemandWXPAndLater (
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING UserDeviceName,
    IN OUT PDEVICE_OBJECT *FileSpyDeviceObject
    );
#endif

NTSTATUS
SpyStartLoggingDevice (
    PWSTR UserDeviceName
    );

NTSTATUS
SpyStopLoggingDevice (
    PWSTR deviceName
    );

////////////////////////////////////////////////////////////////////////
//
//       Attaching/detaching to all volumes in system routines
//                  implemented in fspylib.c
//
////////////////////////////////////////////////////////////////////////

NTSTATUS
SpyAttachToFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
    );

VOID
SpyDetachFromFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject
    );

#if WINVER >= 0x0501
NTSTATUS
SpyEnumerateFileSystemVolumes (
    IN PDEVICE_OBJECT FSDeviceObject,
    IN PUNICODE_STRING Name
    );
#endif

////////////////////////////////////////////////////////////////////////
//
//             Private Filespy IOCTLs helper routines
//                  implemented in fspylib.c
//
////////////////////////////////////////////////////////////////////////

NTSTATUS
SpyGetAttachList (
    PVOID buffer,
    ULONG bufferSize,
    PULONG_PTR returnLength
    );

VOID
SpyGetLog (
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    );

VOID
SpyCloseControlDevice (
    );

////////////////////////////////////////////////////////////////////////
//
//               Device name tracking helper routines
//                  implemented in fspylib.c
//
////////////////////////////////////////////////////////////////////////

VOID
SpyGetObjectName (
    IN PVOID Object,
    IN OUT PUNICODE_STRING Name
    );

VOID
SpyGetBaseDeviceObjectName (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
    );

VOID
SpyCacheDeviceName (
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFindSubString (
    IN PUNICODE_STRING String,
    IN PUNICODE_STRING SubString
    );

VOID
SpyStoreUserName (
    IN PFILESPY_DEVICE_EXTENSION DeviceExtension,
    IN PUNICODE_STRING UserName
    );

////////////////////////////////////////////////////////////////////////
//
//                       Debug support routines
//                       implemented in fspylib.c
//
////////////////////////////////////////////////////////////////////////

VOID
SpyDumpIrpOperation (
    IN BOOLEAN InOriginatingPath,
    IN PIRP Irp
    );

VOID
SpyDumpFastIoOperation (
    IN BOOLEAN InPreOperation,
    IN FASTIO_TYPE FastIoOperation
    );

#if WINVER >= 0x0501 /* See comment in DriverEntry */

VOID
SpyDumpFsFilterOperation (
    IN BOOLEAN InPreOperationCallback,
    IN PFS_FILTER_CALLBACK_DATA Data
    );

#endif

////////////////////////////////////////////////////////////////////////
//
//                      COMMON Naming Routines    
//
//  Common named routines implemented differently between name Context
//  and name Hashing
//
////////////////////////////////////////////////////////////////////////

VOID
SpyInitNamingEnvironment(
    VOID
    );

VOID
SpyInitDeviceNamingEnvironment (
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
SpyCleanupDeviceNamingEnvironment (
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
SpySetName (
    IN PRECORD_LIST RecordList,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN ULONG LookupFlags,
    IN PVOID Context OPTIONAL
);

VOID
SpyNameDeleteAllNames (
    VOID
    );

VOID
SpyLogIrp (
    IN PIRP Irp,
    OUT PRECORD_LIST RecordList
    );

VOID
SpyLogIrpCompletion(
    IN PIRP Irp,
    PRECORD_LIST RecordList
    );


#if USE_STREAM_CONTEXTS

////////////////////////////////////////////////////////////////////////
//
//                  Stream Context name routines
//                    implemented in fspyCtx.c
//
////////////////////////////////////////////////////////////////////////

//
//  Context specific flags
//

typedef enum _CTX_FLAGS {
    //
    //  If set, then we are currently linked into the device extension linked
    //  list.  
    //

    CTXFL_InExtensionList       = 0x00000001,

    //
    //  If set, then we are linked into the stream list.  Note that there is
    //  a small period of time when we might be unlinked with this flag still
    //  set (when the file system is calling SpyDeleteContextCallback).  This is
    //  fine because we still handle not being found in the list when we do
    //  the search.  This flag handles the case when the file has been completely
    //  closed (and the memory freed) on us.
    //

    CTXFL_InStreamList          = 0x00000002,


    //
    //  If set, this is a temporary context and should not be linked into
    //  any of the context lists.  It will be freed as soon as the user is
    //  done with this operation.  
    //

    CTXFL_Temporary             = 0x00000100,

    //
    //  If set, we are performing a significant operation that affects the state
    //  of this context so we should not use it.  If someone tries to get this
    //  context then create a temporary context and return it.  Cases where this
    //  occurs:
    //  - Source file of a rename.
    //  - Source file for the creation of a hardlink
    //

    CTXFL_DoNotUse              = 0x00000200

} CTX_FLAGS;

//
//  Structure for tracking an individual stream context.  Note that the buffer
//  for the FileName is allocated as part of this structure and follows 
//  immediately after it.
//

typedef struct _SPY_STREAM_CONTEXT
{
    //
    //  OS Structure used to track contexts per stream.  Note how we use
    //  the following fields:
    //      OwnerID     -> Holds pointer to our DeviceExtension
    //      InstanceId  -> Holds Pointer to FsContext associated
    //                     with this structure
    //  We use these values to get back to these structures
    //

    FSRTL_PER_STREAM_CONTEXT ContextCtrl;

    //
    //  Linked list used to track contexts per device (in our device
    //  extension).
    //

    LIST_ENTRY ExtensionLink;

    //
    //  This is a counter of how many threads are currently using this
    //  context.  The count is used in this way:
    //  - It is set to 1 when it is created.
    //  - It is incremented every time it is returned to a thread
    //  - It is decremented when the thread is done with it.
    //  - It is decremented when the underlying stream that is using it is freed
    //  - The context is deleted when this count goes to zero
    //

    LONG UseCount;

    //
    //  Holds the name of the file
    //

    UNICODE_STRING Name;

    //
    //  Flags for this context.  All flags are set or cleared via
    //  the interlocked bit routines except when the entry is being
    //  created, at this time we know nobody is using this entry.
    //

    CTX_FLAGS Flags;

    //
    //  Contains the FSContext value for the stream we are attached to.  We
    //  track this so we can delete this entry at any time.
    //

    PFSRTL_ADVANCED_FCB_HEADER Stream;

} SPY_STREAM_CONTEXT, *PSPY_STREAM_CONTEXT;

//
//  Macros for locking the context lock
//

#define SpyAcquireContextLockShared(_devext) \
            SpyAcquireResourceShared( &(_devext)->CtxLock, TRUE )

#define SpyAcquireContextLockExclusive(_devext) \
            SpyAcquireResourceExclusive( &(_devext)->CtxLock, TRUE )

#define SpyReleaseContextLock(_devext) \
            SpyReleaseResource( &(_devext)->CtxLock )


VOID
SpyDeleteAllContexts (
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
SpyDeleteContext (
    IN PDEVICE_OBJECT DeviceObject,
    IN PSPY_STREAM_CONTEXT pContext
    );

VOID
SpyLinkContext ( 
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN OUT PSPY_STREAM_CONTEXT *ppContext
    );

NTSTATUS
SpyCreateContext (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN NAME_LOOKUP_FLAGS LookupFlags,
    OUT PSPY_STREAM_CONTEXT *pRetContext
    );

#define SpyFreeContext( pCtx ) \
    (ASSERT((pCtx)->UseCount == 0), \
     ExFreePool( (pCtx) ))

NTSTATUS
SpyGetContext (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT pFileObject,
    IN NAME_LOOKUP_FLAGS LookupFlags,
    OUT PSPY_STREAM_CONTEXT *pRetContext
    );

PSPY_STREAM_CONTEXT
SpyFindExistingContext (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject
    );

VOID
SpyReleaseContext (
    IN PSPY_STREAM_CONTEXT pContext
    );
#endif


#if !USE_STREAM_CONTEXTS
////////////////////////////////////////////////////////////////////////
//
//                  Name Hash support routines
//                  implemented in fspyHash.c
//
////////////////////////////////////////////////////////////////////////

typedef struct _HASH_ENTRY {

    LIST_ENTRY List;
    PFILE_OBJECT FileObject;
    UNICODE_STRING Name;

} HASH_ENTRY, *PHASH_ENTRY;


PHASH_ENTRY
SpyHashBucketLookup (
    PLIST_ENTRY ListHead,
    PFILE_OBJECT FileObject
);

VOID
SpyNameLookup (
    IN PRECORD_LIST RecordList,
    IN PFILE_OBJECT FileObject,
    IN ULONG LookupFlags,
    IN PFILESPY_DEVICE_EXTENSION DeviceExtension
    );

VOID
SpyNameDelete (
    IN PFILE_OBJECT FileObject
    );

#endif

//
//  Include definitions
//

#include "fspydef.h"

#endif /* __FSPYKERN_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\filter\fspyhash.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    filespy.c

Abstract:

    This module contains all of the routines for tracking names by
    hashing the fileObject.  This cache is limited in size by the
    following registry setting "MaxNames".

Environment:

    Kernel mode

// @@BEGIN_DDKSPLIT

Author:

    Neal Christiansen (nealch)     04-Jul-2001

Revision History:

    Ravisankar Pudipeddi (ravisp)  07-May-2002
        Make it work on IA64

// @@END_DDKSPLIT
--*/

#include <ntifs.h>
#include "filespy.h"
#include "fspyKern.h"


#if !USE_STREAM_CONTEXTS

////////////////////////////////////////////////////////////////////////
//
//                    Local definitions
//
////////////////////////////////////////////////////////////////////////

#define HASH_FUNC(FileObject) \
    (((UINT_PTR)(FileObject) >> 8) & (HASH_SIZE - 1))

////////////////////////////////////////////////////////////////////////
//
//                    Global Variables
//
////////////////////////////////////////////////////////////////////////

//
// NOTE:  Must use KSPIN_LOCKs to synchronize access to hash buckets since
//        we may try to acquire them at DISPATCH_LEVEL.
//

LIST_ENTRY gHashTable[HASH_SIZE];
KSPIN_LOCK gHashLockTable[HASH_SIZE];
ULONG gHashMaxCounters[HASH_SIZE];
ULONG gHashCurrentCounters[HASH_SIZE];

UNICODE_STRING OutOfBuffers = CONSTANT_UNICODE_STRING(L"[-=Out Of Buffers=-]");


////////////////////////////////////////////////////////////////////////
//
//                    Local prototypes
//
////////////////////////////////////////////////////////////////////////

VOID
SpyDeleteContextCallback(
    IN PVOID Context
    );


//
// linker commands
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, SpyInitNamingEnvironment)
#pragma alloc_text( PAGE, SpyInitDeviceNamingEnvironment)
#pragma alloc_text( PAGE, SpyCleanupDeviceNamingEnvironment)

#endif  // ALLOC_PRAGMA


////////////////////////////////////////////////////////////////////////
//
//                    Main routines
//
////////////////////////////////////////////////////////////////////////


VOID
SpyInitNamingEnvironment(
    VOID
    )
/*++

Routine Description:

    Init global variables

Arguments:

    None

Return Value:

    None.

--*/
{
    int i;

    //
    //  Initialize the hash table
    //
        
    for (i = 0; i < HASH_SIZE; i++){

        InitializeListHead(&gHashTable[i]);
        KeInitializeSpinLock(&gHashLockTable[i]);
    }
}


VOID
SpyInitDeviceNamingEnvironment (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Initialize the per DeviceObject naming environment

Arguments:

    DeviceObject - The device object to initialize

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER( DeviceObject );
}


VOID
SpyCleanupDeviceNamingEnvironment (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Initialize the per DeviceObject naming environment

Arguments:

    DeviceObject - The device object to initialize

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER( DeviceObject );
}


VOID
SpyLogIrp (
    IN PIRP Irp,
    OUT PRECORD_LIST RecordList
    )
/*++

Routine Description:

    Records the Irp necessary information according to LoggingFlags in
    RecordList.  For any activity on the Irp path of a device being
    logged, this function should get called twice: once on the Irp's
    originating path and once on the Irp's completion path.

Arguments:

    Irp - The Irp that contains the information we want to record.
    LoggingFlags - The flags that say what to log.
    RecordList - The PRECORD_LIST in which the Irp information is stored.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION pIrpStack;
    PRECORD_IRP pRecordIrp;
    ULONG lookupFlags;

    pRecordIrp = &RecordList->LogRecord.Record.RecordIrp;

    pIrpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Record the information we use for an originating Irp.  We first
    // need to initialize some of the RECORD_LIST and RECORD_IRP fields.
    // Then get the interesting information from the Irp.
    //

    SetFlag( RecordList->LogRecord.RecordType, RECORD_TYPE_IRP );

    pRecordIrp->IrpMajor        = pIrpStack->MajorFunction;
    pRecordIrp->IrpMinor        = pIrpStack->MinorFunction;
    pRecordIrp->IrpFlags        = Irp->Flags;
    pRecordIrp->FileObject      = (FILE_ID)pIrpStack->FileObject;
    pRecordIrp->DeviceObject    = (FILE_ID)pIrpStack->DeviceObject;
    pRecordIrp->ProcessId       = (FILE_ID)PsGetCurrentProcessId();
    pRecordIrp->ThreadId        = (FILE_ID)PsGetCurrentThreadId();
    pRecordIrp->Argument1       = pIrpStack->Parameters.Others.Argument1;
    pRecordIrp->Argument2       = pIrpStack->Parameters.Others.Argument2;
    pRecordIrp->Argument3       = pIrpStack->Parameters.Others.Argument3;
    pRecordIrp->Argument4       = pIrpStack->Parameters.Others.Argument4;

    if (IRP_MJ_CREATE == pRecordIrp->IrpMajor) {

		//
		//  Only record the desired access if this is a CREATE irp.
		//

        pRecordIrp->DesiredAccess = pIrpStack->Parameters.Create.SecurityContext->DesiredAccess;
    }

    KeQuerySystemTime(&(pRecordIrp->OriginatingTime));

    lookupFlags = 0;

    switch (pIrpStack->MajorFunction) {

        case IRP_MJ_CREATE:

            //
            // This is a CREATE so we need to invalidate the name currently
            // stored in the name cache for this FileObject.
            //

            SpyNameDelete(pIrpStack->FileObject);

            //
            //  Flag in Create
            //

            SetFlag( lookupFlags, NLFL_IN_CREATE );

            //
            //  Flag if opening the directory of the given file
            //

            if (FlagOn( pIrpStack->Flags, SL_OPEN_TARGET_DIRECTORY )) {

                SetFlag( lookupFlags, NLFL_OPEN_TARGET_DIR );
            }

            //
            //  Flag if opening by ID
            //

            if (FlagOn( pIrpStack->Parameters.Create.Options, FILE_OPEN_BY_FILE_ID )) {

                SetFlag( lookupFlags, NLFL_OPEN_BY_ID );
            }
            break;

        case IRP_MJ_CLOSE:
            //
            //  We can only look up the name in the name cache if this is a CLOSE.  
            //  It is possible that the close could be occurring during a cleanup 
            //  operation in the file system (i.e., before we have received the
            //  cleanup completion) and requesting the name would cause a deadlock
            //  in the file system.
            //  

            SetFlag( lookupFlags, NLFL_ONLY_CHECK_CACHE );
            break;
    }

    //
    //  If the flag IRP_PAGING_IO is set in this IRP, we cannot query the name
    //  because it can lead to deadlocks.  Therefore, add in the flag so that
    //  we will only try to find the name in our cache.
    //

    if (FlagOn( Irp->Flags, IRP_PAGING_IO )) {

        ASSERT( !FlagOn( lookupFlags, NLFL_NO_LOOKUP ) );

        SetFlag( lookupFlags, NLFL_ONLY_CHECK_CACHE );
    }

    SpySetName( RecordList, 
                pIrpStack->DeviceObject, 
                pIrpStack->FileObject, 
                lookupFlags, 
                NULL);
}


VOID
SpyLogIrpCompletion (
    IN PIRP Irp,
    OUT PRECORD_LIST RecordList
    )
/*++

Routine Description:

    Records the Irp necessary information according to LoggingFlags in
    RecordList.  For any activity on the Irp path of a device being
    logged, this function should get called twice: once on the Irp's
    originating path and once on the Irp's completion path.

Arguments:

    Irp - The Irp that contains the information we want to record.
    LoggingFlags - The flags that say what to log.
    RecordList - The PRECORD_LIST in which the Irp information is stored.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_OBJECT deviceObject = pIrpStack->DeviceObject;
    PRECORD_IRP pRecordIrp;

    //
    //  Process the log record
    //

    if (SHOULD_LOG( deviceObject )) {

        pRecordIrp = &RecordList->LogRecord.Record.RecordIrp;

        //
        // Record the information we use for a completion Irp.
        //

        pRecordIrp->ReturnStatus = Irp->IoStatus.Status;
        pRecordIrp->ReturnInformation = Irp->IoStatus.Information;
        KeQuerySystemTime(&pRecordIrp->CompletionTime);

        //
        //  Add recordList to our gOutputBufferList so that it gets up to 
        //  the user
        //
        
        SpyLog( RecordList );       

    } else {

        if (RecordList) {

            //
            //  Context is set with a RECORD_LIST, but we are no longer
            //  logging so free this record.
            //

            SpyFreeRecord( RecordList );
        }
    }

    switch (pIrpStack->MajorFunction) {

        case IRP_MJ_CREATE:
            //
            //  If the operation failed remove the name from the cache because
            //  it is stale
            //

            if (!NT_SUCCESS(Irp->IoStatus.Status) &&
                (pIrpStack->FileObject != NULL)) {

                SpyNameDelete(pIrpStack->FileObject);
            }
            break;

        case IRP_MJ_CLOSE:

            //
            //  Always remove the name on close
            //

            SpyNameDelete(pIrpStack->FileObject);
            break;


        case IRP_MJ_SET_INFORMATION:
            //
            //  If the operation was successful and it was a rename, always
            //  remove the name.  They can re-get it next time.
            //

            if (NT_SUCCESS(Irp->IoStatus.Status) &&
                (FileRenameInformation == 
                 pIrpStack->Parameters.SetFile.FileInformationClass)) {

                SpyNameDelete(pIrpStack->FileObject);
            }
            break;
    }
}


////////////////////////////////////////////////////////////////////////
//
//                    FileName cache routines
//
////////////////////////////////////////////////////////////////////////

PHASH_ENTRY
SpyHashBucketLookup (
    IN PLIST_ENTRY  ListHead,
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    This routine looks up the FileObject in the give hash bucket.  This routine
    does NOT lock the hash bucket.

Arguments:

    ListHead - hash list to search
    FileObject - the FileObject to look up.

Return Value:

    A pointer to the hash table entry.  NULL if not found

--*/
{
    PHASH_ENTRY pHash;
    PLIST_ENTRY pList;

    pList = ListHead->Flink;

    while (pList != ListHead){

        pHash = CONTAINING_RECORD( pList, HASH_ENTRY, List );

        if (FileObject == pHash->FileObject) {

            return pHash;
        }

        pList = pList->Flink;
    }

    return NULL;
}

VOID
SpySetName (
    IN PRECORD_LIST RecordList,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN ULONG LookupFlags,
    IN PVOID Context OPTIONAL
    )
/*++

Routine Description:

    This routine looks up the FileObject in the hash table.  If the FileObject
    is found in the hash table, copy the associated file name to RecordList.
    Otherwise, calls SpyGetFullPathName to try to get the name of the FileObject.
    If successful, copy the file name to the RecordList and insert into hash
    table.

Arguments:

    RecordList - RecordList to copy name to.
    FileObject - the FileObject to look up.
    LookInFileObject - see routine description
    DeviceExtension - contains the volume name (e.g., "c:") and
        the next device object which may be needed.

Return Value:

    None.
    
--*/
{
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    UINT_PTR hashIndex;
    KIRQL oldIrql;
    PHASH_ENTRY pHash;
    PHASH_ENTRY newHash;
    PLIST_ENTRY listHead;
    PUNICODE_STRING newName;
    PCHAR buffer;

    UNREFERENCED_PARAMETER( Context );

    if (FileObject == NULL) {

        return;
    }

    hashIndex = HASH_FUNC(FileObject);

    INC_STATS(TotalContextSearches);

    listHead = &gHashTable[hashIndex];

    //
    //  Don't bother checking the hash if we are in create, we must always
    //  generate a name
    //

    if (!FlagOn( LookupFlags, NLFL_IN_CREATE )) {

        KeAcquireSpinLock( &gHashLockTable[hashIndex], &oldIrql );

        pHash = SpyHashBucketLookup(&gHashTable[hashIndex], FileObject);

        if (pHash != NULL) {

            //
            //  Copy the file name to the LogRecord, make sure that it is NULL terminated,
            //  and increment the length of the LogRecord.
            //

            SpyCopyFileNameToLogRecord( &RecordList->LogRecord, &pHash->Name );
        
            KeReleaseSpinLock(&gHashLockTable[hashIndex], oldIrql);

            INC_STATS(TotalContextFound);

            return;
        }

        KeReleaseSpinLock(&gHashLockTable[hashIndex], oldIrql);
    }

    //
    //  If it is not in the table, try to add it.  We will not be able to look
    //  up the name if we are at DISPATCH_LEVEL.
    //

    buffer = SpyAllocateBuffer(&gNamesAllocated, gMaxNamesToAllocate, NULL);

    if (buffer != NULL) {
    
        newHash = (PHASH_ENTRY) buffer;
        newName = &newHash->Name;

        RtlInitEmptyUnicodeString(
                newName,
                (PWCHAR)(buffer + sizeof(HASH_ENTRY)),
                RECORD_SIZE - sizeof(HASH_ENTRY) );

        if (SpyGetFullPathName( FileObject, newName, devExt, LookupFlags )) {

            newHash->FileObject = FileObject;
            KeAcquireSpinLock(&gHashLockTable[hashIndex], &oldIrql);

            //
            //  Search again because it may have been stored in the
            //  hash table since we dropped the lock.
            //
			
			pHash = SpyHashBucketLookup(&gHashTable[hashIndex], FileObject);

            if (pHash != NULL) {

                //
                //  We found it in the hash table this time, so
                //  write the name we found to the LogRecord.
                //

                //
                //  Copy the file name to the LogRecord, make sure that it is NULL terminated,
                //  and increment the length of the LogRecord.
                //

                SpyCopyFileNameToLogRecord( &RecordList->LogRecord, &pHash->Name );

                KeReleaseSpinLock(&gHashLockTable[hashIndex], oldIrql);

                SpyFreeBuffer(buffer, &gNamesAllocated);

                return;
            }

            //
            // It wasn't found, add the new entry
            //

            //
            //  Copy the file name to the LogRecord, make sure that it is NULL terminated,
            //  and increment the length of the LogRecord.
            //

            SpyCopyFileNameToLogRecord( &RecordList->LogRecord, newName );

            InsertHeadList(listHead, &newHash->List);

            gHashCurrentCounters[hashIndex]++;

            if (gHashCurrentCounters[hashIndex] > gHashMaxCounters[hashIndex]) {

                gHashMaxCounters[hashIndex] = gHashCurrentCounters[hashIndex];
            }

            KeReleaseSpinLock(&gHashLockTable[hashIndex], oldIrql);

        } else {

            //
            //  We are not supposed to keep the log record entry, copy
            //  what ever they gave us in
            //

            SpyCopyFileNameToLogRecord( &RecordList->LogRecord, newName );

            INC_STATS(TotalContextTemporary);
            SpyFreeBuffer (buffer, &gNamesAllocated);
        }

    } else {

        //
        //  Set a default string even if there is no buffer
        //

        SpyCopyFileNameToLogRecord( &RecordList->LogRecord, &OutOfBuffers );
    }

    return;
}

VOID
SpyNameDeleteAllNames (
    VOID
    )
/*++

Routine Description:

    This will free all entries from the hash table

Arguments:

    None

Return Value:

    None


--*/
{
    KIRQL oldIrql;
    PHASH_ENTRY pHash;
    PLIST_ENTRY pList;
    ULONG i;

    INC_STATS(TotalContextDeleteAlls);
    for (i=0;i < HASH_SIZE;i++) {

        KeAcquireSpinLock(&gHashLockTable[i], &oldIrql);

        while (!IsListEmpty(&gHashTable[i])) {

            pList = RemoveHeadList(&gHashTable[i]);
            pHash = CONTAINING_RECORD( pList, HASH_ENTRY, List );
            SpyFreeBuffer( pHash, &gNamesAllocated);
        }

        gHashCurrentCounters[i] = 0;

        KeReleaseSpinLock(&gHashLockTable[i], oldIrql);
    }
}

VOID
SpyNameDelete (
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    This routine looks up the FileObject in the hash table.  If it is found,
    it deletes it and frees the memory.

Arguments:

    FileObject - the FileObject to look up.

Return Value:

    None


--*/
{
    UINT_PTR hashIndex;
    KIRQL oldIrql;
    PHASH_ENTRY pHash;
    PLIST_ENTRY pList;
    PLIST_ENTRY listHead;

    hashIndex = HASH_FUNC(FileObject);

    KeAcquireSpinLock(&gHashLockTable[hashIndex], &oldIrql);

    listHead = &gHashTable[hashIndex];

    pList = listHead->Flink;

    while(pList != listHead){

        pHash = CONTAINING_RECORD( pList, HASH_ENTRY, List );

        if (FileObject == pHash->FileObject) {

            INC_STATS(TotalContextNonDeferredFrees);
            gHashCurrentCounters[hashIndex]--;
            RemoveEntryList(pList);
            SpyFreeBuffer( pHash, &gNamesAllocated );
            break;
        }

        pList = pList->Flink;
    }

    KeReleaseSpinLock(&gHashLockTable[hashIndex], oldIrql);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\filter\fspyctx.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    context.c

Abstract:

    This module contains all of the routines for tracking names using
    the new Stream Context feature.  It does this by attaching a context
    structure to a stream whenever a new name is requested.  It does
    properly handle when files and directories are renamed.

    Note that StreamContexts are a new feature in the system and are not
    supported by all file systems.  All of the standard Microsoft file
    systems support them (ntfs, fat, cdfs, udfs, rdr2) but there may be 3rd
    party file systems that do not.  This is one of the main reasons why
    track names by stream contexts is not enabled by default.

Environment:

    Kernel mode

// @@BEGIN_DDKSPLIT
Author:

    Neal Christiansen (nealch)     27-Dec-2000

Revision History:

    Ravisankar Pudipeddi (ravisp)  07-May-2002
        Make it work on IA64

// @@END_DDKSPLIT
--*/

#include <ntifs.h>
#include "filespy.h"
#include "fspyKern.h"

#if USE_STREAM_CONTEXTS
#if WINVER < 0x0501
#error Stream contexts on only supported on Windows XP or later.
#endif

////////////////////////////////////////////////////////////////////////
//
//                    Local prototypes
//
////////////////////////////////////////////////////////////////////////

VOID
SpyDeleteContextCallback(
    IN PVOID Context
    );


//
// linker commands
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, SpyInitDeviceNamingEnvironment )
#pragma alloc_text( PAGE, SpyCleanupDeviceNamingEnvironment )
#pragma alloc_text( PAGE, SpyDeleteAllContexts )
#pragma alloc_text( PAGE, SpyDeleteContext )
#pragma alloc_text( PAGE, SpyDeleteContextCallback )
#pragma alloc_text( PAGE, SpyLinkContext )
#pragma alloc_text( PAGE, SpyCreateContext )
#pragma alloc_text( PAGE, SpyFindExistingContext )
#pragma alloc_text( PAGE, SpyReleaseContext )

#endif  // ALLOC_PRAGMA

///////////////////////////////////////////////////////////////////////////
//
//                      Context support routines
//
///////////////////////////////////////////////////////////////////////////

VOID
SpyInitNamingEnvironment(
    VOID
    )
/*++

Routine Description:

    Init global variables

Arguments:

    None

Return Value:

    None.

--*/
{
}


VOID
SpyLogIrp (
    IN PIRP Irp,
    OUT PRECORD_LIST RecordList
    )
/*++

Routine Description:

    Records the Irp necessary information according to LoggingFlags in
    RecordList.  For any activity on the Irp path of a device being
    logged, this function should get called twice: once on the Irp's
    originating path and once on the Irp's completion path.

Arguments:

    Irp - The Irp that contains the information we want to record.
    LoggingFlags - The flags that say what to log.
    RecordList - The PRECORD_LIST in which the Irp information is stored.
    Context - if non-zero, an existing context record for this entry.

Return Value:

    None.

--*/
{
    PRECORD_IRP pRecordIrp = &RecordList->LogRecord.Record.RecordIrp;
    PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_OBJECT deviceObject;
    PFILESPY_DEVICE_EXTENSION devExt;
    PSPY_STREAM_CONTEXT pContext;
    NAME_LOOKUP_FLAGS lookupFlags = 0;
    NTSTATUS status;
    FILE_STANDARD_INFORMATION standardInformation;

    //
    //  Init locals
    //

    deviceObject = pIrpStack->DeviceObject;
    devExt = deviceObject->DeviceExtension;

    //
    // Record the information we use for an originating Irp.  We first
    // need to initialize some of the RECORD_LIST and RECORD_IRP fields.
    // Then get the interesting information from the Irp.
    //

    SetFlag( RecordList->LogRecord.RecordType, RECORD_TYPE_IRP );

    pRecordIrp->IrpMajor        = pIrpStack->MajorFunction;
    pRecordIrp->IrpMinor        = pIrpStack->MinorFunction;
    pRecordIrp->IrpFlags        = Irp->Flags;
    pRecordIrp->FileObject      = (FILE_ID)pIrpStack->FileObject;
    pRecordIrp->DeviceObject    = (FILE_ID)deviceObject;
    pRecordIrp->ProcessId       = (FILE_ID)PsGetCurrentProcessId();
    pRecordIrp->ThreadId        = (FILE_ID)PsGetCurrentThreadId();
    pRecordIrp->Argument1       = pIrpStack->Parameters.Others.Argument1;
    pRecordIrp->Argument2       = pIrpStack->Parameters.Others.Argument2;
    pRecordIrp->Argument3       = pIrpStack->Parameters.Others.Argument3;
    pRecordIrp->Argument4       = pIrpStack->Parameters.Others.Argument4;

    KeQuerySystemTime( &pRecordIrp->OriginatingTime );

    //
    //  Do different things based on the operation
    //

    switch (pIrpStack->MajorFunction) {

        case IRP_MJ_CREATE:

            //
            //                      OPEN/CREATE file
			//
			//  Only record the desired access if this is a CREATE irp.
			//

            pRecordIrp->DesiredAccess = pIrpStack->Parameters.Create.SecurityContext->DesiredAccess;

            //
            //  Set out name lookup state
            //

            SetFlag( lookupFlags, NLFL_IN_CREATE );

            //
            //  Flag if opening the directory of the given file
            //

            if (FlagOn( pIrpStack->Flags, SL_OPEN_TARGET_DIRECTORY )) {

                SetFlag( lookupFlags, NLFL_OPEN_TARGET_DIR );
            }

            //
            //  Set if opening by ID
            //

            if (FlagOn( pIrpStack->Parameters.Create.Options, FILE_OPEN_BY_FILE_ID )) {

                SetFlag( lookupFlags, NLFL_OPEN_BY_ID );
            }

            //
            //  We are in pre-create, we can not attach a context to the file
            //  object yet so simply create a context.  If it fails no name
            //  will be logged.  
            //  Note:  We may already have a context on this file but we can't
            //         find it yet because the FsContext field is not setup yet.
            //         We go ahead and get a context so we will have a name if
            //         the operations fails.  We will detect the duplicate
            //         context during the post-create and delete the new one.
            //

            status = SpyCreateContext( deviceObject, 
                                       pIrpStack->FileObject,
                                       lookupFlags,
                                       &pContext );

            if (NT_SUCCESS(status)) {
        
                SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                               ("FileSpy!SpyLogIrp:             Created     (%p) Fl=%02x Use=%d \"%wZ\"\n",
                                 pContext,
                                 pContext->Flags,
                                 pContext->UseCount,
                                 &pContext->Name) );

                //
                //  If a context was found save it and mark that to sync back
                //  to the dispatch routine to complete this operation.
                //

                ASSERT(RecordList->NewContext == NULL);
                RecordList->NewContext = pContext;
                SetFlag( RecordList->Flags, RLFL_SYNC_TO_DISPATCH );
            }
            break;

        case IRP_MJ_CLOSE:


            //
            //                      CLOSE FILE
            //
            //  If this is a close we can only look up the name in the name
            //  cache.  It is possible that the close could be occurring
            //  during a cleanup  operation in the file system (i.e., before we
            //  have received the cleanup completion) and requesting the name
            //  would cause a deadlock in the file system.
            //  

            SetFlag( lookupFlags, NLFL_ONLY_CHECK_CACHE );
            break;

        case IRP_MJ_SET_INFORMATION:

            if (FileRenameInformation == 
                pIrpStack->Parameters.SetFile.FileInformationClass)
            {

                //
                //                      RENAME FILE
                //
                //  We are doing a rename.  First get a context for the
                //  given file.  If this fails, mark that we don't want to
                //  try and lookup a name.
                //  

                status = SpyGetContext( deviceObject,
                                        pIrpStack->FileObject,
                                        lookupFlags,
                                        &pContext );

                if (!NT_SUCCESS(status)) {

                    //
                    //  If we couldn't get a context simply delete all
                    //  existing ones (since we don't know what this rename
                    //  will change) and mark not to do a lookup.
                    //

                    SetFlag( lookupFlags, NLFL_NO_LOOKUP );
                    SpyDeleteAllContexts( deviceObject );
                    break;
                }

                //
                //  We retrieved a context, save it in the record and mark
                //  that we want to handle this during post rename.
                //

                ASSERT(RecordList->NewContext == NULL);
                RecordList->NewContext = pContext;
                SetFlag( RecordList->Flags, RLFL_SYNC_TO_DISPATCH );

                //
                //  We need to decide if we are renaming a file or a
                //  directory because we need to handle this differently
                //

                status = SpyQueryInformationFile( devExt->AttachedToDeviceObject,
                                                  pIrpStack->FileObject,
                                                  &standardInformation,
                                                  sizeof( standardInformation ),
                                                  FileStandardInformation,
                                                  NULL );

                if (!NT_SUCCESS(status)) {

                    //
                    //  We can't tell if it is a file or directory, assume
                    //  the worst case and handle it like a directory.
                    //

                    InterlockedIncrement( &devExt->AllContextsTemporary );
                    SpyDeleteAllContexts( deviceObject );
                    SetFlag( RecordList->Flags, RLFL_IS_DIRECTORY );
                    break;
                }

                if (standardInformation.Directory) {

                    //
                    //  Renaming a directory.  Mark that any contexts
                    //  created while the rename is in progress should be
                    //  temporary.  This way there is no window where
                    //  we may get an old stale name.  Then delete all
                    //  existing contexts.  NOTE:  the context we hold will
                    //  not actually be deleted until we release it.
                    //

                    InterlockedIncrement( &devExt->AllContextsTemporary );
                    SpyDeleteAllContexts( deviceObject );
                    SetFlag( RecordList->Flags, RLFL_IS_DIRECTORY );

                } else {

                    //
                    //  We are renaming a file.  Mark the context so it will
                    //  not be used.  This way if someone accesses this file
                    //  while it is being renamed they will lookup the
                    //  name again so we will always get an accurate name.
                    //  This context will be deleted during post rename
                    //  processing
                    //

                    SetFlag( pContext->Flags, CTXFL_DoNotUse);
                }
            }
            break;

    }

    //
    //  If the flag IRP_PAGING_IO is set in this IRP, we cannot query the name
    //  because it can lead to deadlocks.  Therefore, add in the flag so that
    //  we will only try to find the name in our cache.
    //

    if (FlagOn( Irp->Flags, IRP_PAGING_IO )) {

        ASSERT( !FlagOn( lookupFlags, NLFL_NO_LOOKUP ) );

        SetFlag( lookupFlags, NLFL_ONLY_CHECK_CACHE );
    }

    SpySetName( RecordList, 
                deviceObject,
                pIrpStack->FileObject,
                lookupFlags, 
                (PSPY_STREAM_CONTEXT)RecordList->NewContext );

}


VOID
SpyLogIrpCompletion(
    IN PIRP Irp,
    PRECORD_LIST RecordList
    )
/*++

Routine Description:

    This routine performs post-operation logging of the IRP.

Arguments:

    DeviceObject - Pointer to device object FileSpy attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.

    Record - RecordList

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PRECORD_IRP pRecordIrp;
    PDEVICE_OBJECT deviceObject;
    PFILESPY_DEVICE_EXTENSION devExt;
    PSPY_STREAM_CONTEXT pContext;

    //
    //  Init locals
    //

    deviceObject = pIrpStack->DeviceObject;
    devExt = deviceObject->DeviceExtension;

    ASSERT(deviceObject == 
           (PDEVICE_OBJECT)RecordList->LogRecord.Record.RecordIrp.DeviceObject);

    //
    //  Do completion processing based on the operation
    //
    
    switch (pIrpStack->MajorFunction) {    

        case IRP_MJ_CREATE:

            //
            //                  CREATE FILE
            //
            //  NOTE:  When processing CREATE completion IRPS this completion
            //         routine is never called at DISPATCH level, it is always
            //         synchronized back to the dispatch routine.  This is
            //         controlled by the setting of the RLFL_SYNC_TO_DISPATCH
            //         flag in the log record.
            //

            if (NULL != (pContext = RecordList->NewContext)) {

                //
                //  Mark context field so it won't be freed later
                //

                RecordList->NewContext = NULL;

                //
                //  If the operation succeeded and an FsContext is defined,
                //  then attach the context.  Else when the context is
                //  released it will be freed.
                //

                if (NT_SUCCESS(Irp->IoStatus.Status) &&
                    (NULL != pIrpStack->FileObject->FsContext)) {

                    SpyLinkContext( deviceObject,
                                    pIrpStack->FileObject,
                                    &pContext );

                    SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                                   ("FileSpy!SpyLogIrpCompletion:   Link        (%p) Fl=%02x Use=%d \"%wZ\"\n",
                                     pContext,
                                     pContext->Flags,
                                     pContext->UseCount,
                                     &pContext->Name) );
                }

                //
                //  Now release the context
                //

                SpyReleaseContext( pContext );
            }
            break;

        case IRP_MJ_SET_INFORMATION:

            if (FileRenameInformation == 
                pIrpStack->Parameters.SetFile.FileInformationClass)
            {

                //
                //                  RENAMING FILE
                //
                //  NOTE:  When processing RENAME completion IRPS this
                //         completion routine is never called at DISPATCH level,
                //         it is always synchronized back to the dispatch
                //         routine.  This is controlled by the setting of the
                //         RLFL_SYNC_TO_DISPATCH flag in the log record.
                //

                if (NULL != (pContext = RecordList->NewContext)) {

                    //
                    //  Mark context field so it won't be freed later
                    //

                    RecordList->NewContext = NULL;

                    //
                    //  See if renaming a directory
                    //

                    if (FlagOn(RecordList->Flags,RLFL_IS_DIRECTORY)) {

                        //
                        //  We were renaming a directory, decrement the
                        //  AllContexts temporary flag.  We need to always
                        //  do this, even on a failure
                        //

                        ASSERT(devExt->AllContextsTemporary > 0);
                        InterlockedDecrement( &devExt->AllContextsTemporary );
                        ASSERT(!FlagOn(pContext->Flags,CTXFL_DoNotUse));

                    } else {

                        //
                        //  We were renaming a file, delete the given context
                        //  if the operation was successful
                        //

                        ASSERT(FlagOn(pContext->Flags,CTXFL_DoNotUse));

                        if (NT_SUCCESS(Irp->IoStatus.Status)) {
            
                            SpyDeleteContext( deviceObject, pContext );
                        }
                    }

                    SpyReleaseContext( pContext );
                }
            }
            break;

        default:

            //
            //  Validate this field isn't set for anything else
            //

            ASSERT(RecordList->NewContext == NULL);
            break;
    }

    //
    //  Process the log record
    //

    if (SHOULD_LOG( deviceObject )) {

        pRecordIrp = &RecordList->LogRecord.Record.RecordIrp;

        //
        // Record the information we use for a completion Irp.
        //

        pRecordIrp->ReturnStatus = Irp->IoStatus.Status;
        pRecordIrp->ReturnInformation = Irp->IoStatus.Information;
        KeQuerySystemTime(&pRecordIrp->CompletionTime);

        //
        //  Add recordList to our gOutputBufferList so that it gets up to 
        //  the user
        //
        
        SpyLog( RecordList );       

    } else {

        if (RecordList) {

            //
            //  Context is set with a RECORD_LIST, but we are no longer
            //  logging so free this record.
            //

            SpyFreeRecord( RecordList );
        }
    }
}


VOID
SpySetName (
    IN PRECORD_LIST RecordList,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN NAME_LOOKUP_FLAGS LookupFlags,
    IN PSPY_STREAM_CONTEXT Context OPTIONAL
    )
/*++

Routine Description:

    This routine is used to set the file name.  This routine first tries to
    locate a context structure associated with the given stream.  If one is
    found the name is used from it.  If not found the name is looked up, and
    a context structure is created and attached to the given stream.

    In all cases some sort of name will be set.

Arguments:

    RecordList - RecordList to copy name to.
    LookupFlags - holds state flags for the lookup
    Context - optional context parameter.  If not defined one will be looked
        up.

Return Value:

    None.
    
--*/
{
    PRECORD_IRP pRecordIrp = &RecordList->LogRecord.Record.RecordIrp;
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    BOOLEAN releaseContext = FALSE;
    UNICODE_STRING fileName;
    WCHAR fileNameBuffer[MAX_PATH];

    ASSERT(IS_FILESPY_DEVICE_OBJECT( DeviceObject ));

    if (!ARGUMENT_PRESENT(Context) &&
        !FlagOn(LookupFlags,NLFL_NO_LOOKUP)) {

        //
        //  If no FileObject, just return
        //

        if (NULL == FileObject) {

            return;
        }

        //
        //  This will set the return context to NULL if no context
        //  could be created.
        //

        SpyGetContext( DeviceObject,
                       FileObject,
                       LookupFlags,
                       &Context );

        //
        //  Mark that we need to release this context (since we grabbed it)
        //

        releaseContext = TRUE;
    }

    //
    //  If we got a context, use the name from it.  If we didn't, at least
    //  put the device name out there
    //

    if (NULL != Context) {

        SpyCopyFileNameToLogRecord( &RecordList->LogRecord, 
                                    &Context->Name );

    } else {

        SPY_LOG_PRINT( SPYDEBUG_TRACE_DETAILED_CONTEXT_OPS, 
                       ("FileSpy!SpySetName:            NoCtx                              \"%wZ\"\n",
                        &devExt->UserNames) );

        RtlInitEmptyUnicodeString( &fileName, 
                                   fileNameBuffer, 
                                   sizeof(fileNameBuffer) );

        RtlCopyUnicodeString( &fileName, &devExt->UserNames );
        RtlAppendUnicodeToString( &fileName,
                                  L"[-=Context Allocate Failed=-]" );

        SpyCopyFileNameToLogRecord( &RecordList->LogRecord, 
                                    &fileName );
    }

    //
    //  Release the context if we grabbed it in this routine
    //

    if ((NULL != Context) && releaseContext) {

        SpyReleaseContext( Context );
    }
}


VOID
SpyNameDeleteAllNames()
/*++

Routine Description:

    This routine will walk through all attaches volumes and delete all
    contexts in each volume.
    
Arguments:

    None

Return Value:

    None

--*/
{
    PLIST_ENTRY link;
    PFILESPY_DEVICE_EXTENSION devExt;

    ExAcquireFastMutex( &gSpyDeviceExtensionListLock );

    for (link = gSpyDeviceExtensionList.Flink;
         link != &gSpyDeviceExtensionList;
         link = link->Flink)
    {

        devExt = CONTAINING_RECORD(link, FILESPY_DEVICE_EXTENSION, NextFileSpyDeviceLink);

        SpyDeleteAllContexts( devExt->ThisDeviceObject );
    }

    ExReleaseFastMutex( &gSpyDeviceExtensionListLock );
}


///////////////////////////////////////////////////////////////////////////
//
//                      Context support routines
//
///////////////////////////////////////////////////////////////////////////

VOID
SpyInitDeviceNamingEnvironment (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Initializes context information for a given device

Arguments:

    DeviceObject - Device to init

Return Value:

    None.

--*/
{
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;

    PAGED_CODE();
    ASSERT(IS_FILESPY_DEVICE_OBJECT(DeviceObject));

    InitializeListHead( &devExt->CtxList );
    ExInitializeResourceLite( &devExt->CtxLock );

    SetFlag( devExt->Flags, ContextsInitialized );
}


VOID
SpyCleanupDeviceNamingEnvironment (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Cleans up the context information for a given device

Arguments:

    DeviceObject - Device to cleanup

Return Value:

    None.

--*/
{
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;

    PAGED_CODE();
    ASSERT(IS_FILESPY_DEVICE_OBJECT(DeviceObject));

    //
    //  Cleanup if initialized
    //

    if (FlagOn(devExt->Flags,ContextsInitialized)) {

        //
        //  Delete all existing contexts
        //

        SpyDeleteAllContexts( DeviceObject );
        ASSERT(IsListEmpty( &devExt->CtxList ));

        //
        //  Release resource
        //

        ExDeleteResourceLite( &devExt->CtxLock );

        //
        //  Flag not initialized
        //

        ClearFlag( devExt->Flags, ContextsInitialized );
    }
}


VOID
SpyDeleteAllContexts (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This will free all existing contexts for the given device

Arguments:

    DeviceObject - Device to operate on

Return Value:

    None.

--*/
{
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    PLIST_ENTRY link;
    PSPY_STREAM_CONTEXT pContext;
    PFSRTL_PER_STREAM_CONTEXT ctxCtrl;
    LIST_ENTRY localHead;
    ULONG deleteNowCount = 0;
    ULONG deleteDeferredCount = 0;
    ULONG deleteInCallbackCount = 0;

    PAGED_CODE();
    ASSERT(IS_FILESPY_DEVICE_OBJECT(DeviceObject));

    INC_STATS(TotalContextDeleteAlls);

    InitializeListHead( &localHead );

    try {

        //
        //  Acquire list lock
        //

        SpyAcquireContextLockExclusive( devExt );

        //
        //  Walk the list of contexts and release each one
        //

        while (!IsListEmpty( &devExt->CtxList )) {

            //
            //  Unlink from top of list
            //

            link = RemoveHeadList( &devExt->CtxList );
            pContext = CONTAINING_RECORD( link, SPY_STREAM_CONTEXT, ExtensionLink );

            //
            //  Mark that we are unlinked from the list.  We need to do this
            //  because of the race condition between this routine and the
            //  deleteCallback from the FS.
            //

            ASSERT(FlagOn(pContext->Flags,CTXFL_InExtensionList));
            RtlInterlockedClearBitsDiscardReturn(&pContext->Flags,CTXFL_InExtensionList);

            //
            //  Try and remove ourselves from the File Systems context control
            //  structure.  Note that the file system could be trying to tear
            //  down their context control right now.  If they are then we 
            //  will get a NULL back from this call.  This is OK because it
            //  just means that they are going to free the memory, not us.
            //  NOTE:  This will be safe because we are holding the ContextLock
            //         exclusively.  If this were happening then they would be
            //         blocked in the callback routine on this lock which
            //         means the file system has not freed the memory for
            //         this yet.
            //  
            
            if (FlagOn(pContext->Flags,CTXFL_InStreamList)) {

                ctxCtrl = FsRtlRemovePerStreamContext( pContext->Stream,
                                                       devExt,
                                                       NULL );

                //
                //  Always clear the flag wether we found it in the list or
                //  not.  We can have the flag set and not be in the list if
                //  after we acquired the context list lock we context swapped
                //  and the file system is right now in SpyDeleteContextCallback
                //  waiting on the list lock.
                //

                RtlInterlockedClearBitsDiscardReturn(&pContext->Flags,CTXFL_InStreamList);

                //
                //  Handle wether we were still attached to the file or not.
                //

                if (NULL != ctxCtrl) {

                    ASSERT(pContext == CONTAINING_RECORD(ctxCtrl,SPY_STREAM_CONTEXT,ContextCtrl));

                    //
                    //  To save time we don't do the free now (with the lock
                    //  held).  We link into a local list and then free it
                    //  later (in this routine).  We can do this because it
                    //  is no longer on any list.
                    //

                    InsertHeadList( &localHead, &pContext->ExtensionLink );

                } else {

                    //
                    //  The context is in the process of being freed by the file
                    //  system.  Don't do anything with it here, it will be
                    //  freed in the callback.
                    //

                    INC_STATS(TotalContextsNotFoundInStreamList);
                    INC_LOCAL_STATS(deleteInCallbackCount);
                }
            }
        }
    } finally {

        SpyReleaseContextLock( devExt );
    }

    //
    //  We have removed everything from the list and released the list lock.
    //  Go through and figure out what entries we can free and then do it.
    //

    while (!IsListEmpty( &localHead )) {

        //
        //  Get next entry of the list and get our context back
        //

        link = RemoveHeadList( &localHead );
        pContext = CONTAINING_RECORD( link, SPY_STREAM_CONTEXT, ExtensionLink );

        //
        //  Decrement the USE count and see if we can free it now
        //

        ASSERT(pContext->UseCount > 0);

        if (InterlockedDecrement( &pContext->UseCount ) <= 0) {

            //
            //  No one is using it, free it now
            //

            SpyFreeContext( pContext );

            INC_STATS(TotalContextNonDeferredFrees);
            INC_LOCAL_STATS(deleteNowCount);

        } else {

            //
            //  Someone still has a pointer to it, it will get deleted
            //  later when they release
            //

            INC_LOCAL_STATS(deleteDeferredCount);
            SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                           ("FileSpy!SpyDeleteAllContexts:  DEFERRED    (%p) Fl=%02x Use=%d \"%wZ\"\n",
                             pContext,
                             pContext->Flags,
                             pContext->UseCount,
                             &pContext->Name) );
        }
    }

    SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                   ("FileSpy!SpyDeleteAllContexts:   %3d deleted now, %3d deferred, %3d close contention  \"%wZ\"\n",
                    deleteNowCount,
                    deleteDeferredCount,
                    deleteInCallbackCount,
                    &devExt->DeviceName) );
}


VOID
SpyDeleteContext (
    IN PDEVICE_OBJECT DeviceObject,
    IN PSPY_STREAM_CONTEXT pContext
    )
/*++

Routine Description:

    Unlink and release the given context.

Arguments:

    DeviceObject - Device to operate on

    pContext - The context to delete

Return Value:

    None.

--*/
{
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    PFSRTL_PER_STREAM_CONTEXT ctxCtrl;

    PAGED_CODE();
    ASSERT(IS_FILESPY_DEVICE_OBJECT(DeviceObject));

    SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                   ("FileSpy!SpyDeleteContext:                   (%p) Fl=%02x Use=%d \"%wZ\"\n",
                    pContext,
                    pContext->Flags,
                    pContext->UseCount,
                    &pContext->Name));

    //
    //  Acquire list lock
    //

    SpyAcquireContextLockExclusive( devExt );

    //
    //  Remove from extension list (if still in it)
    //

    if (FlagOn(pContext->Flags,CTXFL_InExtensionList)) {

        RemoveEntryList( &pContext->ExtensionLink );
        RtlInterlockedClearBitsDiscardReturn(&pContext->Flags,CTXFL_InExtensionList);
    }

    //
    //  See if still in stream list.
    //

    if (!FlagOn(pContext->Flags,CTXFL_InStreamList)) {

        //
        //  Not in stream list, release lock and return
        //

        SpyReleaseContextLock( devExt );

    } else {

        //
        //  Remove from Stream list
        //

        ctxCtrl = FsRtlRemovePerStreamContext( pContext->Stream,
                                               devExt,
                                               NULL );
        //
        //  Always clear the flag wether we found it in the list or not.  We
        //  can have the flag set and not be in the list if after we acquired
        //  the context list lock we context swapped and the file system 
        //  is right now in SpyDeleteContextCallback waiting on the list lock.
        //

        RtlInterlockedClearBitsDiscardReturn(&pContext->Flags,CTXFL_InStreamList);

        //
        //  Release list lock
        //

        SpyReleaseContextLock( devExt );

        //
        //  The context is now deleted from all of the lists and the lock is
        //  removed.  We need to see if we found this entry on the systems context
        //  list.  If not that means the callback was in the middle of trying
        //  to free this (while we were) and has already deleted it.
        //  If we found a structure then delete it now ourselves.
        //

        if (NULL != ctxCtrl) {

            ASSERT(pContext == CONTAINING_RECORD(ctxCtrl,SPY_STREAM_CONTEXT,ContextCtrl));

            //
            //  Decrement USE count, free context if zero
            //

            ASSERT(pContext->UseCount > 0);

            if (InterlockedDecrement( &pContext->UseCount ) <= 0) {

                INC_STATS(TotalContextNonDeferredFrees);
                SpyFreeContext( pContext );

            } else {

                SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                               ("FileSpy!SpyDeleteContext:      DEFERRED    (%p) Fl=%02x Use=%d \"%wZ\"\n",
                                pContext,
                                pContext->Flags,
                                pContext->UseCount,
                                &pContext->Name));
            }

        } else {

            INC_STATS(TotalContextsNotFoundInStreamList);
        }
    }
}


VOID
SpyDeleteContextCallback (
    IN PVOID Context
    )
/*++

Routine Description:

    This is called by base file systems when a context needs to be deleted.

Arguments:

    Context - The context structure being deleted

Return Value:

    None.

--*/
{
    PSPY_STREAM_CONTEXT pContext = Context;
    PFILESPY_DEVICE_EXTENSION devExt;
    
    PAGED_CODE();

    devExt = (PFILESPY_DEVICE_EXTENSION)pContext->ContextCtrl.OwnerId;

    SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                   ("FileSpy!SpyDeleteContextCallback:          (%p) Fl=%02x Use=%d \"%wZ\"\n",
                    pContext,
                    pContext->Flags,
                    pContext->UseCount,
                    &pContext->Name) );

    //
    //  When we get here we have already been removed from the stream list (by
    //  the calling file system), flag that this has happened.  
    //

    RtlInterlockedClearBitsDiscardReturn(&pContext->Flags,CTXFL_InStreamList);

    //
    //  Lock the context list lock in the extension
    //

    SpyAcquireContextLockExclusive( devExt );

    //
    //  See if we are still linked into the extension list.  If not then skip
    //  the unlinking.  This can happen if someone is trying to delete this
    //  context at the same time as we are.
    //

    if (FlagOn(pContext->Flags,CTXFL_InExtensionList)) {

        RemoveEntryList( &pContext->ExtensionLink );
        RtlInterlockedClearBitsDiscardReturn(&pContext->Flags,CTXFL_InExtensionList);
    }

    SpyReleaseContextLock( devExt );

    //
    //  Decrement USE count, free context if zero
    //

    ASSERT(pContext->UseCount > 0);

    if (InterlockedDecrement( &pContext->UseCount ) <= 0) {

        INC_STATS(TotalContextCtxCallbackFrees);
        SpyFreeContext( pContext );

    } else {

        SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                       ("FileSpy!SpyDeleteContextCB:    DEFFERED    (%p) Fl=%02x Use=%d \"%wZ\"\n",
                        pContext,
                        pContext->Flags,
                        pContext->UseCount,
                        &pContext->Name) );
    }
}


VOID
SpyLinkContext ( 
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN OUT PSPY_STREAM_CONTEXT *ppContext
    )
/*++

Routine Description:

    This will link the given context into the context list for the given
    device as well as into the given stream.

    NOTE:   It is possible for this entry to already exist in the table since
            between the time we initially looked and the time we inserted
            (which is now) someone else may have inserted one.  If we find an
            entry that already exists we will free the entry passed in and
            return the entry found.  

Arguments:

    DeviceObject - Device we are operating on

    FileObject - Represents the stream to link the context into

    ppContext - Enters with the context to link, returns with the context
            to use.  They may be different if the given context already
            exists.

Return Value:

    None.

--*/
{
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    NTSTATUS status;
    PSPY_STREAM_CONTEXT pContext = *ppContext;
    PSPY_STREAM_CONTEXT ctx;
    PFSRTL_PER_STREAM_CONTEXT ctxCtrl;
    
    PAGED_CODE();
    ASSERT(IS_FILESPY_DEVICE_OBJECT(DeviceObject));
    ASSERT(FileObject->FsContext != NULL);
    ASSERT(pContext != NULL);

    //
    //  If this is marked as a temporary context, return now.  Because we
    //  don't bump the reference count, when it is release it to be freed.
    //

    if (FlagOn(pContext->Flags,CTXFL_Temporary)) {

        ASSERT(!FlagOn(pContext->Flags,CTXFL_InExtensionList));
        return;
    }

    //
    //  We need to figure out if a duplicate entry already exists on
    //  the context list for this file object.  Acquire our list lock
    //  and then see if it exists.  If not, insert into the stream and
    //  volume lists.  If so, then simply free this new entry and return
    //  the original.
    //
    //  This can happen when:
    //  - Someone created an entry at the exact same time as we were
    //    creating an entry.
    //  - When someone does a create with overwrite or supersede we
    //    do not have the information yet to see if a context already
    //    exists.  Because of this we have to create a new context
    //    every time.  During post-create we then see if one already
    //    exists.
    //

    //
    //  Initialize the context control structure.  We do this now so we
    //  don't have to do it while the lock is held (even if we might
    //  have to free it because of a duplicate found)
    //

    FsRtlInitPerStreamContext( &pContext->ContextCtrl,
                               devExt,
                               NULL,
                               SpyDeleteContextCallback );

    //
    //  Save the stream we are associated with.
    //

    pContext->Stream = FsRtlGetPerStreamContextPointer(FileObject);

    //
    //  Acquire list lock exclusively
    //

    SpyAcquireContextLockExclusive( devExt );

    ASSERT(pContext->UseCount == 1);
    ASSERT(!FlagOn(pContext->Flags,CTXFL_InExtensionList));
    ASSERT(!FlagOn(pContext->Flags,CTXFL_Temporary));

    //
    //  See if we have an entry already on the list
    //

    ctxCtrl = FsRtlLookupPerStreamContext( FsRtlGetPerStreamContextPointer(FileObject),
                                           devExt,
                                           NULL );

    if (NULL != ctxCtrl) {

        //
        //  The context already exists so free the new one we just
        //  created.  First increment the use count on the one we found in
        //  the list.
        //

        ctx = CONTAINING_RECORD(ctxCtrl,SPY_STREAM_CONTEXT,ContextCtrl);

        ASSERT(ctx->Stream == FsRtlGetPerStreamContextPointer(FileObject));
        ASSERT(FlagOn(ctx->Flags,CTXFL_InExtensionList));
        ASSERT(ctx->UseCount > 0);

        //
        //  Bump ref count and release lock
        //

        InterlockedIncrement( &ctx->UseCount );

        SpyReleaseContextLock( devExt );

        //
        //  Since this cache is across opens on the same stream there are
        //  cases where the names will be different even though they are the
        //  same file.  These cases are:
        //      - One open could be by short name where another open
        //        is by long name.
        //      - This does not presently strip extended stream names like
        //        :$DATA
        //  When enabled this will display to the debugger screen when the
        //  names don't exactly match.  You can also break on this difference.
        //

        if (!RtlEqualUnicodeString( &pContext->Name,&ctx->Name,TRUE )) {

            SPY_LOG_PRINT( SPYDEBUG_TRACE_MISMATCHED_NAMES, 
                           ("FileSpy!SpyLinkContext:        Old Name:   (%p) Fl=%02x Use=%d \"%wZ\"\n"
                            "                               New Name:   (%p) Fl=%02x Use=%d \"%wZ\"\n",
                            ctx,
                            ctx->Flags,
                            ctx->UseCount,
                            &ctx->Name,
                            pContext,
                            pContext->Flags,
                            pContext->UseCount,
                            &pContext->Name) );

            if (FlagOn(gFileSpyDebugLevel,SPYDEBUG_ASSERT_MISMATCHED_NAMES)) {

                DbgBreakPoint();
            }
        }

        SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                       ("FileSpy!SpyLinkContext:        Rel Dup:    (%p) Fl=%02x Use=%d \"%wZ\"\n",
                        pContext,
                        pContext->Flags,
                        pContext->UseCount,
                        &pContext->Name) );

        //
        //  Free the new structure because it was already resident.  Note
        //  that this entry has never been linked into any lists so we know
        //  no one else has a reference to it.  Decrement use count to keep
        //  the ASSERTS happy then free the memory.
        //

        INC_STATS(TotalContextDuplicateFrees);

        pContext->UseCount--;
        SpyFreeContext( pContext );

        //
        //  Return the one we found in the list
        //

        *ppContext = ctx;

    } else {

        //
        //  The new context did not exist, insert this new one.
        //

        //
        //  Link into Stream context.  This can fail for the following
        //  reasons:
        //      This is a paging file
        //      This is a volume open
        //  If this happens then don't bump the reference count and it will be
        //  freed when the caller is done with it.
        //

        status = FsRtlInsertPerStreamContext( FsRtlGetPerStreamContextPointer(FileObject),
                                              &pContext->ContextCtrl );

        if (NT_SUCCESS(status)) {

            //
            //  Increment the USE count (because it is added to the stream)
            //

            InterlockedIncrement( &pContext->UseCount );

            //
            //  Link into Device extension
            //

            InsertHeadList( &devExt->CtxList, &pContext->ExtensionLink );

            //
            //  Mark that we have been inserted into both lists.  We don't have
            //  to do this interlocked because no one can access this entry
            //  until we release the context lock.
            //

            SetFlag( pContext->Flags, CTXFL_InExtensionList|CTXFL_InStreamList );

        }

        //
        //  Release lock
        //

        SpyReleaseContextLock( devExt );
    }
}


/***************************************************************************++

Routine Description:

    This will allocate and initialize a context structure but it does NOT
    link it into the context hash list.

Arguments:

Return Value:

--***************************************************************************/
NTSTATUS
SpyCreateContext (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN NAME_LOOKUP_FLAGS LookupFlags,
    OUT PSPY_STREAM_CONTEXT *pRetContext
    )
/*++

Routine Description:

    Allocate and initialize a context structure including retrieving the name.

Arguments:

    DeviceObject - Device to operate on

    FileObject - The stream the context is being created for

    LookupFlags - Flag telling how to do this create

    pRetContext - Receives the created context

Return Value:

    Status of the operation

--*/
{
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    PSPY_STREAM_CONTEXT ctx;
    ULONG contextSize;
    UNICODE_STRING fileName;
    WCHAR fileNameBuffer[MAX_PATH];
    BOOLEAN getNameResult;    


    PAGED_CODE();
    ASSERT(IS_FILESPY_DEVICE_OBJECT(DeviceObject));

    //
    //  Setup locals
    //

    *pRetContext = NULL;

    RtlInitEmptyUnicodeString( &fileName,
                               fileNameBuffer,
                               sizeof(fileNameBuffer) );

    //
    //  Get the filename string
    //

    getNameResult = SpyGetFullPathName( FileObject,
                                        &fileName,
                                        devExt,
                                        LookupFlags );

    //
    //  Allocate the context structure with space for the name
    //  added to the end.
    //

    contextSize = sizeof(SPY_STREAM_CONTEXT) + fileName.Length;

    ctx = ExAllocatePoolWithTag( NonPagedPool, 
                                 contextSize,
                                 FILESPY_CONTEXT_TAG );

    if (!ctx) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Init the context structure
    //

    RtlZeroMemory( ctx, sizeof(SPY_STREAM_CONTEXT) );
    ctx->UseCount = 1;
    
    //
    //  Insert the file name
    //

    RtlInitEmptyUnicodeString( &ctx->Name, 
                               (PWCHAR)(ctx + 1), 
                               contextSize - sizeof(SPY_STREAM_CONTEXT) );

    RtlCopyUnicodeString( &ctx->Name, &fileName );

    //
    //  If they don't want to keep this context, mark it temporary
    //

    if (!getNameResult) {

        SetFlag(ctx->Flags, CTXFL_Temporary);
        INC_STATS(TotalContextTemporary);
    }

    //
    //  Return the object context
    //

    INC_STATS(TotalContextCreated);
    *pRetContext = ctx;

    //
    //  Cleanup the local nameControl structure
    //

    return STATUS_SUCCESS;
}


NTSTATUS
SpyGetContext (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN NAME_LOOKUP_FLAGS LookupFlags,
    OUT PSPY_STREAM_CONTEXT *pRetContext
    )
/*++

Routine Description:

    This will see if a given context already exists.  If not it will create
    one and return it.  Note:  the return context pointer is NULL on a
    failure.

    This will also see if all contexts are to be temporary (global flag in
    the extension).  If so, a temporary context is always created.  It also
    sees if the found context is marked temporary (because it is being
    renamed).  If so, a temporary context is also created and returned.

Arguments:

    DeviceObject - Device to operate on

    FileObject - The stream the context is being looked up/created for

    LookupFlags - State flags incase a context is created

    pRetContext - Receives the found/created context

Return Value:

    Status of the operation

--*/
{
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    PSPY_STREAM_CONTEXT pContext;
    PFSRTL_PER_STREAM_CONTEXT ctxCtrl;
    NTSTATUS status;
    BOOLEAN makeTemporary = FALSE;

    ASSERT(IS_FILESPY_DEVICE_OBJECT(DeviceObject));

    //
    //  Bump total search count
    //

    INC_STATS(TotalContextSearches);

    //
    //  See if the all-contexts-temporary state is on.  If not then do
    //  the normal search.
    //

    if (devExt->AllContextsTemporary != 0) {

        //
        //  Mark that we want this context to be temporary
        //

        makeTemporary = TRUE;

    } else {

        //
        //                      NOT-TEMPORARY
        //  Try and locate the context structure.  We acquire the list lock
        //  so that we can guarantee that the context will not go away between
        //  the time when we find it and can increment the use count
        //

        SpyAcquireContextLockShared( devExt );

        ctxCtrl = FsRtlLookupPerStreamContext( FsRtlGetPerStreamContextPointer(FileObject),
                                               devExt,
                                               NULL );

        if (NULL != ctxCtrl) {

            //
            //  A context was attached to the given stream
            //

            pContext = CONTAINING_RECORD( ctxCtrl,
                                          SPY_STREAM_CONTEXT,
                                          ContextCtrl );

            ASSERT(pContext->Stream == FsRtlGetPerStreamContextPointer(FileObject));
            ASSERT(FlagOn(pContext->Flags,CTXFL_InExtensionList));
            ASSERT(!FlagOn(pContext->Flags,CTXFL_Temporary));
            ASSERT(pContext->UseCount > 0);

            //
            //  See if this is marked that we should not use it (happens when a
            //  file is being renamed).
            //

            if (FlagOn(pContext->Flags,CTXFL_DoNotUse)) {

                //
                //  We should not use this context, unlock and set flag so we
                //  will create a temporary context.
                //

                SpyReleaseContextLock( devExt );
                makeTemporary = TRUE;

            } else {

                //
                //  We want this context so bump the use count and release
                //  the lock
                //

                InterlockedIncrement( &pContext->UseCount );

                SpyReleaseContextLock( devExt );
                INC_STATS(TotalContextFound);

                SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                               ("FileSpy!SpyGetContext:         Found:      (%p) Fl=%02x Use=%d \"%wZ\"\n",
                                pContext,
                                pContext->Flags,
                                pContext->UseCount,
                                &pContext->Name) );

                //
                //  Return the found context
                //

                *pRetContext = pContext;
                return STATUS_SUCCESS;
            }

        } else {

            //
            //  We didn't find a context, release the lock
            //

            SpyReleaseContextLock( devExt );
        }
    }

    //
    //  For whatever reason, we did not find a context.
    //  See if contexts are supported for this particular file.  Note that
    //  NTFS does not presently support contexts on paging files.
    //

    if (!FsRtlSupportsPerStreamContexts(FileObject)) {

        INC_STATS(TotalContextsNotSupported);
        *pRetContext = NULL;
        return STATUS_NOT_SUPPORTED;
    }

    //
    //  If we get here we need to create a context, do it
    //

    status = SpyCreateContext( DeviceObject,
                               FileObject,
                               LookupFlags,
                               &pContext );
                               
    if (!NT_SUCCESS( status )) {

        *pRetContext = NULL;
        return status;
    }       

    //
    //  Mark context temporary (if requested)
    //

    if (makeTemporary) {

        SetFlag(pContext->Flags,CTXFL_Temporary);

        INC_STATS(TotalContextTemporary);

        SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                       ("FileSpy!SpyGetContext:         RenAllTmp:  (%p) Fl=%02x Use=%d \"%wZ\"\n",
                        pContext,
                        pContext->Flags,
                        pContext->UseCount,
                        &pContext->Name) );

    } else {

        //
        //  Insert the context into the linked list.  Note that the
        //  link routine will see if this entry has already been added to
        //  the list (could happen while we were building it).  If so it
        //  will release the one we created and use the one it found in
        //  the list.  It will return the new entry (if it was changed).
        //  The link routine properly handles temporary contexts.
        //

        SpyLinkContext( DeviceObject,
                        FileObject,
                        &pContext );
    }

    SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                   ("FileSpy!SrGetContext:          Created%s (%p) Fl=%02x Use=%d \"%wZ\"\n",
                    (FlagOn(pContext->Flags,CTXFL_Temporary) ? "Tmp:" : ":   "),
                    pContext,
                    pContext->Flags,
                    pContext->UseCount,
                    &pContext->Name) );

    //
    //  Return the context
    //

    ASSERT(pContext->UseCount > 0);

    *pRetContext = pContext;
    return STATUS_SUCCESS;
}


PSPY_STREAM_CONTEXT
SpyFindExistingContext (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    See if a context for the given stream already exists.  If so it will
    bump the reference count and return the context.  If not, NULL
    is returned.

Arguments:

    DeviceObject - Device to operate on

    FileObject - The stream the context is being looked up for

Return Value:

    Returns the found context


--*/
{
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    PSPY_STREAM_CONTEXT pContext;
    PFSRTL_PER_STREAM_CONTEXT ctxCtrl;

    PAGED_CODE();
    ASSERT(IS_FILESPY_DEVICE_OBJECT(DeviceObject));

    //
    //  Try and locate the context structure.  We acquire the list lock
    //  so that we can guarantee that the context will not go away between
    //  the time when we find it and can increment the use count
    //

    INC_STATS(TotalContextSearches);

    SpyAcquireContextLockShared( devExt );

    ctxCtrl = FsRtlLookupPerStreamContext( FsRtlGetPerStreamContextPointer(FileObject),
                                           devExt,
                                           NULL );

    if (NULL != ctxCtrl) {

        //
        //  We found the entry, increment use count
        //

        pContext = CONTAINING_RECORD(ctxCtrl,SPY_STREAM_CONTEXT,ContextCtrl);

        ASSERT(pContext->Stream == FsRtlGetPerStreamContextPointer(FileObject));
        ASSERT(pContext->UseCount > 0);

        InterlockedIncrement( &pContext->UseCount );

        //
        //  Release the list lock
        //

        SpyReleaseContextLock( devExt );
        INC_STATS(TotalContextFound);

        SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                       ("FileSpy!SpyFindExistingContext:Found:      (%p) Fl=%02x Use=%d \"%wZ\"\n",
                        pContext,
                        pContext->Flags,
                        pContext->UseCount,
                        &pContext->Name) );

    } else {

        //
        //  Release the list lock while we create the new context.
        //

        SpyReleaseContextLock( devExt );

        pContext = NULL;
    }

    return pContext;
}


VOID
SpyReleaseContext (
    IN PSPY_STREAM_CONTEXT pContext
    )
/*++

Routine Description:

    Decrement the use count for the given context.  If it goes to zero, free it

Arguments:

    pContext - The context to operate on

Return Value:

    None.

--*/
{
    PAGED_CODE();

    SPY_LOG_PRINT( SPYDEBUG_TRACE_DETAILED_CONTEXT_OPS, 
                   ("FileSpy!SpyReleaseContext:     Release     (%p) Fl=%02x Use=%d \"%wZ\"\n",
                    pContext,
                    pContext->Flags,
                    pContext->UseCount,
                    &pContext->Name) );

    //
    //  Decrement USE count, free context if zero
    //

    ASSERT(pContext->UseCount > 0);

    if (InterlockedDecrement( &pContext->UseCount ) <= 0) {

        ASSERT(!FlagOn(pContext->Flags,CTXFL_InExtensionList));

        //
        //  Free the memory
        //

        SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                       ("FileSpy!SpyReleaseContext:     Freeing     (%p) Fl=%02x Use=%d \"%wZ\"\n",
                         pContext,
                         pContext->Flags,
                         pContext->UseCount,
                         &pContext->Name) );

        INC_STATS(TotalContextDeferredFrees);
        SpyFreeContext( pContext );
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\filter\fspylib.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    fspyLib.c

Abstract:

    This contains library support routines for FileSpy.  These routines
    do the main work for logging the I/O operations --- creating the log
    records, recording the relevant information, attach/detach from
    devices, etc.

    As of the Windows XP SP1 IFS Kit version of this sample and later, this
    sample can be built for each build environment released with the IFS Kit
    with no additional modifications.  To provide this capability, additional
    compile-time logic was added -- see the '#if WINVER' locations.  Comments
    tagged with the 'VERSION NOTE' header have also been added as appropriate to
    describe how the logic must change between versions.

    If this sample is built in the Windows XP environment or later, it will run
    on Windows 2000 or later.  This is done by dynamically loading the routines
    that are only available on Windows XP or later and making run-time decisions
    to determine what code to execute.  Comments tagged with 'MULTIVERISON NOTE'
    mark the locations where such logic has been added.

Environment:

    Kernel mode

// @@BEGIN_DDKSPLIT

Author:

    George Jenkins (georgeje) 6-Jan-1999
    Neal Christiansen (nealch)
    Molly Brown (mollybro)  

Revision History:

    Neal Christiansen (nealch)     06-Jul-2001
        Modified to use Stream Contexts to track names

    Ravisankar Pudipeddi (ravisp)  07-May-2002
        Make it work on IA64

    Molly Brown (mollybro)         21-May-2002
        Modify sample to make it support running on Windows 2000 or later if
        built in the latest build environment and allow it to be built in W2K 
        and later build environments.
        
// @@END_DDKSPLIT
--*/

#include <stdio.h>

#include <ntifs.h>
#include "filespy.h"
#include "fspyKern.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, SpyReadDriverParameters)
#pragma alloc_text(PAGE, SpyAttachDeviceToDeviceStack)
#pragma alloc_text(PAGE, SpyQueryFileSystemForFileName)
#pragma alloc_text(PAGE, SpyQueryInformationFile)
#pragma alloc_text(PAGE, SpyIsAttachedToDeviceByUserDeviceName)
#pragma alloc_text(PAGE, SpyIsAttachedToDevice)
#pragma alloc_text(PAGE, SpyIsAttachedToDeviceW2K)
#pragma alloc_text(PAGE, SpyAttachToMountedDevice)
#pragma alloc_text(PAGE, SpyCleanupMountedDevice)
#pragma alloc_text(PAGE, SpyAttachToDeviceOnDemand)
#pragma alloc_text(PAGE, SpyAttachToDeviceOnDemandW2K)
#pragma alloc_text(PAGE, SpyStartLoggingDevice)
#pragma alloc_text(PAGE, SpyStopLoggingDevice)
#pragma alloc_text(PAGE, SpyAttachToFileSystemDevice)
#pragma alloc_text(PAGE, SpyDetachFromFileSystemDevice)
#pragma alloc_text(PAGE, SpyGetAttachList)
#pragma alloc_text(PAGE, SpyGetObjectName)


#if WINVER >= 0x0501
#pragma alloc_text(INIT, SpyLoadDynamicFunctions)
#pragma alloc_text(INIT, SpyGetCurrentVersion)
#pragma alloc_text(PAGE, SpyIsAttachedToDeviceWXPAndLater)
#pragma alloc_text(PAGE, SpyAttachToDeviceOnDemandWXPAndLater)
#pragma alloc_text(PAGE, SpyEnumerateFileSystemVolumes)
#pragma alloc_text(PAGE, SpyGetBaseDeviceObjectName)
#endif

#endif

//////////////////////////////////////////////////////////////////////////
//                                                                      //
//                     Library support routines                         //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID
SpyReadDriverParameters (
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine tries to read the FileSpy-specific parameters from
    the registry.  These values will be found in the registry location
    indicated by the RegistryPath passed in.

Arguments:

    RegistryPath - the path key which contains the values that are
        the FileSpy parameters

Return Value:

    None.

--*/
{
    OBJECT_ATTRIBUTES attributes;
    HANDLE driverRegKey;
    NTSTATUS status;
    ULONG bufferSize, resultLength;
    PVOID buffer = NULL;
    UNICODE_STRING valueName;
    PKEY_VALUE_PARTIAL_INFORMATION pValuePartialInfo;

    PAGED_CODE();

    //
    //  All the global values are already set to default values.  Any
    //  values we read from the registry will override these defaults.
    //
    
    //
    //  Do the initial setup to start reading from the registry.
    //

    InitializeObjectAttributes( &attributes,
								RegistryPath,
								OBJ_CASE_INSENSITIVE,
								NULL,
								NULL);

    status = ZwOpenKey( &driverRegKey,
						KEY_READ,
						&attributes);

    if (!NT_SUCCESS(status)) {

        driverRegKey = NULL;
        goto SpyReadDriverParameters_Exit;
    }

    bufferSize = sizeof( KEY_VALUE_PARTIAL_INFORMATION ) + sizeof( ULONG );
    buffer = ExAllocatePoolWithTag( NonPagedPool, bufferSize, FILESPY_POOL_TAG );

    if (NULL == buffer) {

        goto SpyReadDriverParameters_Exit;
    }

    //
    // Read the gMaxRecordsToAllocate from the registry
    //

    RtlInitUnicodeString(&valueName, MAX_RECORDS_TO_ALLOCATE);

    status = ZwQueryValueKey( driverRegKey,
							  &valueName,
							  KeyValuePartialInformation,
							  buffer,
							  bufferSize,
							  &resultLength);

    if (NT_SUCCESS(status)) {

        pValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
        ASSERT(pValuePartialInfo->Type == REG_DWORD);
        gMaxRecordsToAllocate = *((PLONG)&pValuePartialInfo->Data);

    }

    //
    // Read the gMaxNamesToAllocate from the registry
    //

    RtlInitUnicodeString(&valueName, MAX_NAMES_TO_ALLOCATE);

    status = ZwQueryValueKey( driverRegKey,
							  &valueName,
							  KeyValuePartialInformation,
							  buffer,
							  bufferSize,
							  &resultLength);

    if (NT_SUCCESS(status)) {

        pValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
        ASSERT(pValuePartialInfo->Type == REG_DWORD);
        gMaxNamesToAllocate = *((PLONG)&pValuePartialInfo->Data);

    }

    //
    // Read the initial debug setting from the registry
    //

    RtlInitUnicodeString(&valueName, DEBUG_LEVEL);

    status = ZwQueryValueKey( driverRegKey,
                              &valueName,
                              KeyValuePartialInformation,
                              buffer,
                              bufferSize,
                              &resultLength );

    if (NT_SUCCESS( status )) {

        pValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
        ASSERT( pValuePartialInfo->Type == REG_DWORD );
        gFileSpyDebugLevel |= *((PULONG)&pValuePartialInfo->Data);
        
    }
    
    //
    // Read the attachment mode setting from the registry
    //

    RtlInitUnicodeString(&valueName, ATTACH_MODE);

    status = ZwQueryValueKey( driverRegKey,
                              &valueName,
                              KeyValuePartialInformation,
                              buffer,
                              bufferSize,
                              &resultLength );

    if (NT_SUCCESS( status )) {

        pValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
        ASSERT( pValuePartialInfo->Type == REG_DWORD );
        gFileSpyAttachMode = *((PULONG)&pValuePartialInfo->Data);
    }
    
    goto SpyReadDriverParameters_Exit;

SpyReadDriverParameters_Exit:

    if (NULL != buffer) {

        ExFreePoolWithTag( buffer, FILESPY_POOL_TAG );
    }

    if (NULL != driverRegKey) {

        ZwClose(driverRegKey);
    }

    return;
}

#if WINVER >= 0x0501
VOID
SpyLoadDynamicFunctions (
    )
/*++

Routine Description:

    This routine tries to load the function pointers for the routines that
    are not supported on all versions of the OS.  These function pointers are
    then stored in the global structure gSpyDynamicFunctions.

    This support allows for one driver to be built that will run on all 
    versions of the OS Windows 2000 and greater.  Note that on Windows 2000, 
    the functionality may be limited.
    
Arguments:

    None.
    
Return Value:

    None.

--*/
{
    UNICODE_STRING functionName;

    RtlZeroMemory( &gSpyDynamicFunctions, sizeof( gSpyDynamicFunctions ) );

    //
    //  For each routine that we would want to use, lookup its address in the
    //  kernel or hal.  If it is not present, that field in our global
    //  gSpyDynamicFunctions structure will be set to NULL.
    //

    RtlInitUnicodeString( &functionName, L"FsRtlRegisterFileSystemFilterCallbacks" );
    gSpyDynamicFunctions.RegisterFileSystemFilterCallbacks = MmGetSystemRoutineAddress( &functionName );

    RtlInitUnicodeString( &functionName, L"IoAttachDeviceToDeviceStackSafe" );
    gSpyDynamicFunctions.AttachDeviceToDeviceStackSafe = MmGetSystemRoutineAddress( &functionName );
    
    RtlInitUnicodeString( &functionName, L"IoEnumerateDeviceObjectList" );
    gSpyDynamicFunctions.EnumerateDeviceObjectList = MmGetSystemRoutineAddress( &functionName );

    RtlInitUnicodeString( &functionName, L"IoGetLowerDeviceObject" );
    gSpyDynamicFunctions.GetLowerDeviceObject = MmGetSystemRoutineAddress( &functionName );

    RtlInitUnicodeString( &functionName, L"IoGetDeviceAttachmentBaseRef" );
    gSpyDynamicFunctions.GetDeviceAttachmentBaseRef = MmGetSystemRoutineAddress( &functionName );

    RtlInitUnicodeString( &functionName, L"IoGetDiskDeviceObject" );
    gSpyDynamicFunctions.GetDiskDeviceObject = MmGetSystemRoutineAddress( &functionName );

    RtlInitUnicodeString( &functionName, L"IoGetAttachedDeviceReference" );
    gSpyDynamicFunctions.GetAttachedDeviceReference = MmGetSystemRoutineAddress( &functionName );

    RtlInitUnicodeString( &functionName, L"RtlGetVersion" );
    gSpyDynamicFunctions.GetVersion = MmGetSystemRoutineAddress( &functionName );
}

VOID
SpyGetCurrentVersion (
    )
/*++

Routine Description:

    This routine reads the current OS version using the correct routine based
    on what routine is available.

Arguments:

    None.
    
Return Value:

    None.

--*/
{
    if (NULL != gSpyDynamicFunctions.GetVersion) {

        RTL_OSVERSIONINFOW versionInfo;
        NTSTATUS status;

        //
        //  VERSION NOTE: RtlGetVersion does a bit more than we need, but
        //  we are using it if it is available to show how to use it.  It
        //  is available on Windows XP and later.  RtlGetVersion and
        //  RtlVerifyVersionInfo (both documented in the IFS Kit docs) allow
        //  you to make correct choices when you need to change logic based
        //  on the current OS executing your code.
        //

        versionInfo.dwOSVersionInfoSize = sizeof( RTL_OSVERSIONINFOW );

        status = (gSpyDynamicFunctions.GetVersion)( &versionInfo );

        ASSERT( NT_SUCCESS( status ) );

        gSpyOsMajorVersion = versionInfo.dwMajorVersion;
        gSpyOsMinorVersion = versionInfo.dwMinorVersion;
        
    } else {

        PsGetVersion( &gSpyOsMajorVersion,
                      &gSpyOsMinorVersion,
                      NULL,
                      NULL );
    }
}

#endif
////////////////////////////////////////////////////////////////////////
//                                                                    //
//                  Memory allocation routines                        //
//                                                                    //
////////////////////////////////////////////////////////////////////////

PVOID
SpyAllocateBuffer (
    IN OUT PLONG Counter,
    IN LONG MaxCounterValue,
    OUT PULONG RecordType
    )
/*++

Routine Description:

    Allocates a new buffer from the gFreeBufferList if there is enough memory
    to do so and Counter does not exceed MaxCounterValue.  The RecordType
    is set to one of the record type constants based on the allocation state.

Arguments:

    Counter - (optional) the counter variable to test and increment if
        we can allocate
    MaxCounterValue - (ignored if Counter not given) the value which
        Counter should not exceed
    RecordType - (optional) set to one of the following:
        RECORD_TYPE_NORMAL  allocation succeeded
        RECORD_TYPE_OUT_OF_MEMORY allocation failed because the system was
                                  out of memory
        RECORD_TYPE_EXCEED_MEMORY_ALLOWANCE allocation failed because the
                                counter exceeded its maximum value.

Return Value:

    Pointer to the buffer allocate, or NULL if allocation failed (either
    because system is out of memory or we have exceeded the MaxCounterValue).

--*/
{
    PVOID newBuffer;
    ULONG newRecordType = RECORD_TYPE_NORMAL;

#ifdef MEMORY_DBG
    //
    //  When we are debugging the memory usage to make sure that we
    //  don't leak memory, we want to allocate the memory from pool
    //  so that we can use the Driver Verifier to help debug any
    //  memory problems.
    //

    newBuffer = ExAllocatePoolWithTag( NonPagedPool, 
                                       RECORD_SIZE, 
                                       FILESPY_LOGRECORD_TAG );
#else

    //
    //  When we are not debugging the memory usage, we use a look-aside
    //  list for better performance.
    //

    newBuffer = ExAllocateFromNPagedLookasideList( &gFreeBufferList );
#endif

    if (newBuffer) {

        if (Counter) {

            if (*Counter < MaxCounterValue) {

                InterlockedIncrement(Counter);

            } else {

				//
                // We've exceed our driver's memory limit so note that
                // and give back the record
				//

                SetFlag( newRecordType, 
                         (RECORD_TYPE_STATIC | RECORD_TYPE_EXCEED_MEMORY_ALLOWANCE) );

#ifdef MEMORY_DBG
                ExFreePoolWithTag( newBuffer, FILESPY_POOL_TAG );
#else
                ExFreeToNPagedLookasideList( &gFreeBufferList, newBuffer );
#endif

                newBuffer = NULL;
            }
        }

    }  else {

        SetFlag( newRecordType,
                 (RECORD_TYPE_STATIC | RECORD_TYPE_OUT_OF_MEMORY) );
    }

    if (RecordType) {

        *RecordType = newRecordType;
    }

    return newBuffer;
}

VOID
SpyFreeBuffer (
    IN PVOID Buffer,
    IN PLONG Counter
    )
/*++

Routine Description:

    Returns a Buffer to the gFreeBufferList.

Arguments:

    Buffer - the buffer to return to the gFreeBufferList

Return Value:

    None.

--*/
{

#ifdef MEMORY_DBG
    ExFreePoolWithTag( Buffer, FILESPY_POOL_TAG );
#else
    ExFreeToNPagedLookasideList( &gFreeBufferList, Buffer );
#endif

    //
    // Update the count
    //
    if (Counter) {

        InterlockedDecrement(Counter);
    }
}


////////////////////////////////////////////////////////////////////////
//                                                                    //
//                  Logging routines                                  //
//                                                                    //
////////////////////////////////////////////////////////////////////////

PRECORD_LIST
SpyNewRecord (
    IN ULONG AssignedSequenceNumber
    )
/*++

Routine Description:

    Allocates a new RECORD_LIST structure if there is enough memory to do so. A
    sequence number is updated for each request for a new record.

Arguments:

    AssignedSequenceNumber - 0 if you want this function to generate the
        next sequence number; if not 0, the new record is assigned the
        given sequence number.

Return Value:

    Pointer to the RECORD_LIST allocated, or NULL if no memory is available.

--*/
{
    PRECORD_LIST newRecord = NULL;
    ULONG currentSequenceNumber;
    KIRQL irql;
    ULONG initialRecordType;

    newRecord = (PRECORD_LIST) SpyAllocateBuffer( &gRecordsAllocated,
                                                  gMaxRecordsToAllocate,
                                                  &initialRecordType);

    KeAcquireSpinLock(&gLogSequenceLock, &irql);

    //
    // Assign a new sequence number if 0 was passed in, otherwise use the
    // number passed in
    //

    if (AssignedSequenceNumber == 0) {

        gLogSequenceNumber++;
        currentSequenceNumber = gLogSequenceNumber;

    } else {

        currentSequenceNumber = AssignedSequenceNumber;
    }


    if ((newRecord == NULL) &&
        !InterlockedCompareExchange( &gStaticBufferInUse, TRUE, FALSE)) {

        //
        // Toggle on our gStaticBufferInUse flag and use the static out of memory
        // buffer to record this log entry.  This special log record is used
        // to notify the user application that we are out of memory.  Log
        // request will be dropped until we can get more memory.
        //

        newRecord   = (PRECORD_LIST)gOutOfMemoryBuffer;
        newRecord->LogRecord.RecordType = initialRecordType;
        newRecord->LogRecord.Length = SIZE_OF_LOG_RECORD;
        newRecord->LogRecord.SequenceNumber = currentSequenceNumber;

    } else if (newRecord) {

		//
        // We were able to allocate a new record so initialize it
        // appropriately.
		//

        newRecord->LogRecord.RecordType = initialRecordType;
        newRecord->LogRecord.Length = SIZE_OF_LOG_RECORD;
        newRecord->LogRecord.SequenceNumber = currentSequenceNumber;
    }

    KeReleaseSpinLock(&gLogSequenceLock, irql);

    //
    //  Init record specific fields.
    //

    if (newRecord != NULL) {

        newRecord->NewContext = NULL;
        newRecord->WaitEvent = NULL;
        newRecord->Flags = 0;
    }

    return( newRecord );
}

VOID
SpyFreeRecord (
    IN PRECORD_LIST Record
    )
/*++

Routine Description:

    Frees a RECORD_LIST, which returns the memory to the gFreeBufferList look-aside
    list and updates the gRecordsAllocated count.

Arguments:

    Record - the record to free

Return Value:

    None.

--*/
{
    //
    //  If there is a context record defined, release it now
    //

#if USE_STREAM_CONTEXTS
    if (NULL != Record->NewContext) {

        SpyReleaseContext( Record->NewContext );
    }
#endif

    if (FlagOn( Record->LogRecord.RecordType, RECORD_TYPE_STATIC )) {

		//
        // This is our static record, so reset our gStaticBufferInUse
        // flag.
		//

        InterlockedExchange( &gStaticBufferInUse, FALSE );

    } else {

		//
        // This isn't our static memory buffer, so free the dynamically
        // allocated memory.
		//

        SpyFreeBuffer( Record, &gRecordsAllocated );
    }
}


PRECORD_LIST
SpyLogFastIoStart (
    IN FASTIO_TYPE FastIoType,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PLARGE_INTEGER FileOffset OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN BOOLEAN Wait	OPTIONAL
    )
/*++

Routine Description:

    Creates the log record if possible and records the necessary Fast I/O
    information at the beginning of the fast I/O operation in RecordList
    according to LoggingFlags.

    The optional arguments are not recorded for all Fast I/O types.  If
    the argument is not needed for a given Fast I/O type, the parameter
    was ignored.

Arguments:

    FastIoType - The type of fast I/O we are logging (REQUIRED)
    DeviceObject - The device object for our filter. (REQUIRED)
    FileObject - Pointer to the file object this operation is on (OPTIONAL)
    FileOffset - Pointer to the file offset for this operation (OPTIONAL)
    Length - Length of the data for this operation (OPTIONAL)
    Wait - Whether or not this operation can wait for a result (OPTIONAL)

Return Value:

    The RECORD_LIST structure created with the appropriate information
    filled in.  If a RECORD_LIST structure couldn't be allocated, NULL
    is returned.

--*/
{
    PRECORD_LIST    pRecordList;
    PRECORD_FASTIO  pRecordFastIo;
    PFILESPY_DEVICE_EXTENSION devExt;

    //
    // Try to get a new record
    //

    pRecordList = SpyNewRecord(0);

    //
    // If we didn't get a RECORD_LIST, exit and return NULL
    //

    if (pRecordList == NULL) {

        return NULL;
    }

    //
    // We got a RECORD_LIST, so now fill in the appropriate information
    //

    pRecordFastIo = &pRecordList->LogRecord.Record.RecordFastIo;

    //
    // Perform the necessary book keeping for the RECORD_LIST
    //

    SetFlag( pRecordList->LogRecord.RecordType, RECORD_TYPE_FASTIO );

    //
    // Set the RECORD_FASTIO fields that are set for all Fast I/O types
    //

    pRecordFastIo->Type = FastIoType;
    KeQuerySystemTime(&pRecordFastIo->StartTime);

    //
    // Get process and thread information
    //

    pRecordFastIo->ProcessId = (ULONG_PTR) PsGetCurrentProcessId();
    pRecordFastIo->ThreadId = (ULONG_PTR) PsGetCurrentThreadId();

    //
    // Record the information that is appropriate based on the
    // Fast I/O type
    //

    pRecordFastIo->FileObject = (FILE_ID)FileObject;
    pRecordFastIo->DeviceObject = (DEVICE_ID)DeviceObject;
    pRecordFastIo->FileOffset.QuadPart = ((FileOffset != NULL) ? FileOffset->QuadPart : 0);
    pRecordFastIo->Length = Length;
    pRecordFastIo->Wait = Wait;

    devExt = DeviceObject->DeviceExtension;

    if (FastIoType == CHECK_IF_POSSIBLE) {

        //
        //  On NTFS, locks are sometimes held but top-level irp is not set, 
        //  therefore it is not safe to query the base file system for the
        //  file name at this time.  If we've got it in the cache, we'll
        //  use it.  Otherwise, we will not return a name.
        //
        
        SpySetName(pRecordList, DeviceObject, FileObject, NLFL_ONLY_CHECK_CACHE, NULL);
        
    } else {

        SpySetName(pRecordList, DeviceObject, FileObject, 0, NULL);
    }

    return pRecordList;
}

VOID
SpyLogFastIoComplete (
    IN PIO_STATUS_BLOCK ReturnStatus,
    IN PRECORD_LIST RecordList
    )
/*++

Routine Description:

    Records the necessary Fast I/O information in RecordList according to
    LoggingFlags.

    The optional arguments are not recorded for all Fast I/O types.  If
    the argument is not needed for a given Fast I/O type, the parameter
    was ignored.

Arguments:
    ReturnStatus - The return value of the operation (OPTIONAL)
    RecordList - The PRECORD_LIST in which the Fast I/O information is stored.

Return Value:

    None.

--*/
{
    PRECORD_FASTIO pRecordFastIo;

    ASSERT(RecordList);

    pRecordFastIo = &RecordList->LogRecord.Record.RecordFastIo;

    //
    // Set the RECORD_FASTIO fields that are set for all Fast I/O types
    //

    KeQuerySystemTime(&pRecordFastIo->CompletionTime);

    if (ReturnStatus != NULL) {

        pRecordFastIo->ReturnStatus = ReturnStatus->Status;

    } else {

        pRecordFastIo->ReturnStatus = 0;
    }

    SpyLog(RecordList);
}

#if WINVER >= 0x0501 /* See comment in DriverEntry */

VOID
SpyLogPreFsFilterOperation (
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PRECORD_LIST RecordList
    )
{
    NAME_LOOKUP_FLAGS lookupFlags = 0;
    
    PRECORD_FS_FILTER_OPERATION pRecordFsFilterOp;

    pRecordFsFilterOp = &RecordList->LogRecord.Record.RecordFsFilterOp;
    
    //
    // Record the information we use for an originating Irp.  We first
    // need to initialize some of the RECORD_LIST and RECORD_IRP fields.
    // Then get the interesting information from the Irp.
    //

    SetFlag( RecordList->LogRecord.RecordType, RECORD_TYPE_FS_FILTER_OP );

    pRecordFsFilterOp->FsFilterOperation = Data->Operation;
    pRecordFsFilterOp->FileObject = (FILE_ID) Data->FileObject;
    pRecordFsFilterOp->DeviceObject = (FILE_ID) Data->DeviceObject;
    pRecordFsFilterOp->ProcessId = (FILE_ID)PsGetCurrentProcessId();
    pRecordFsFilterOp->ThreadId = (FILE_ID)PsGetCurrentThreadId();
    
    KeQuerySystemTime(&pRecordFsFilterOp->OriginatingTime);

    //
    //  Do not query for the name on any of the release operations
    //  because a file system resource is currently being held and
    //  we may deadlock.
    //

    switch (Data->Operation) {

        case FS_FILTER_RELEASE_FOR_CC_FLUSH:
        case FS_FILTER_RELEASE_FOR_SECTION_SYNCHRONIZATION:
        case FS_FILTER_RELEASE_FOR_MOD_WRITE:

            SPY_LOG_PRINT( SPYDEBUG_TRACE_DETAILED_CONTEXT_OPS, 
                           ("FileSpy!SpyLogPreFsFilterOp:   RelOper\n") );

            SetFlag( lookupFlags, NLFL_ONLY_CHECK_CACHE );
            break;
    }

    //
    //  Only set the volumeName if the next device is a file system
    //  since we only want to prepend the volumeName if we are on
    //  top of a local file system.
    //

    SpySetName( RecordList, Data->DeviceObject, Data->FileObject, lookupFlags, NULL);
}

VOID
SpyLogPostFsFilterOperation (
    IN NTSTATUS OperationStatus,
    OUT PRECORD_LIST RecordList
    )
{
    PRECORD_FS_FILTER_OPERATION pRecordFsFilterOp;

    pRecordFsFilterOp = &RecordList->LogRecord.Record.RecordFsFilterOp;
    
    //
    // Record the information we see in the post operation.
    //

    pRecordFsFilterOp->ReturnStatus = OperationStatus;
    KeQuerySystemTime(&pRecordFsFilterOp->CompletionTime);
}

#endif

NTSTATUS
SpyAttachDeviceToDeviceStack (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice,
    IN OUT PDEVICE_OBJECT *AttachedToDeviceObject
    )
/*++

Routine Description:

    This routine attaches the SourceDevice to the TargetDevice's stack and
    returns the device object SourceDevice was directly attached to in 
    AttachedToDeviceObject.  Note that the SourceDevice does not necessarily
    get attached directly to TargetDevice.  The SourceDevice will get attached
    to the top of the stack of which TargetDevice is a member.

    VERSION NOTE:

    In Windows XP, a new API was introduced to close a rare timing window that 
    can cause IOs to start being sent to a device before its 
    AttachedToDeviceObject is set in its device extension.  This is possible
    if a filter is attaching to a device stack while the system is actively
    processing IOs.  The new API closes this timing window by setting the
    device extension field that holds the AttachedToDeviceObject while holding
    the IO Manager's lock that protects the device stack.

    A sufficient work around for earlier versions of the OS is to set the
    AttachedToDeviceObject to the device object that the SourceDevice is most
    likely to attach to.  While it is possible that another filter will attach
    in between the SourceDevice and TargetDevice, this will prevent the
    system from bug checking if the SourceDevice receives IOs before the 
    AttachedToDeviceObject is correctly set.

    For a driver built in the Windows 2000 build environment, we will always 
    use the work-around code to attach.  For a driver that is built in the
    Windows XP or later build environments (therefore you are building a 
    multiversion driver), we will determine which method of attachment to use 
    based on which APIs are available.
    

Arguments:

    SourceDevice - The device object to be attached to the stack.

    TargetDevice - The device that we currently think is the top of the stack
        to which SourceDevice should be attached.

    AttachedToDeviceObject - This is set to the device object to which 
        SourceDevice is attached if the attach is successful.
        
Return Value:

    Return STATUS_SUCCESS if the device is successfully attached.  If 
    TargetDevice represents a stack to which devices can no longer be attached,
    STATUS_NO_SUCH_DEVICE is returned.

--*/
{

    PAGED_CODE();

#if WINVER >= 0x0501
    if (IS_WINDOWSXP_OR_LATER()) {

        ASSERT( NULL != gSpyDynamicFunctions.AttachDeviceToDeviceStackSafe );
        
        return (gSpyDynamicFunctions.AttachDeviceToDeviceStackSafe)( SourceDevice,
                                                                     TargetDevice,
                                                                     AttachedToDeviceObject );

    } else {
#endif

        *AttachedToDeviceObject = TargetDevice;
        *AttachedToDeviceObject = IoAttachDeviceToDeviceStack( SourceDevice,
                                                               TargetDevice );

        if (*AttachedToDeviceObject == NULL) {

            return STATUS_NO_SUCH_DEVICE;
        }

        return STATUS_SUCCESS;

#if WINVER >= 0x0501
    }
#endif

}

NTSTATUS
SpyLog (
    IN PRECORD_LIST NewRecord
    )
/*++

Routine Description:

    This routine appends the completed log record to the gOutputBufferList.

Arguments:

    NewRecord - The record to append to the gOutputBufferList

Return Value:

    The function returns STATUS_SUCCESS.

--*/
{
    KIRQL controlDeviceIrql;
    KIRQL outputBufferIrql;

    KeAcquireSpinLock( &gControlDeviceStateLock, &controlDeviceIrql );

    if (gControlDeviceState == OPENED) {

        //
        // The device is still open so add this record onto the list
        //

        KeAcquireSpinLock(&gOutputBufferLock, &outputBufferIrql);
        InsertTailList(&gOutputBufferList, &NewRecord->List);
        KeReleaseSpinLock(&gOutputBufferLock, outputBufferIrql);

    } else {

        //
        // We can no longer log this record, so free the record
        //

        SpyFreeRecord( NewRecord );

    }

    KeReleaseSpinLock( &gControlDeviceStateLock, controlDeviceIrql );

    return STATUS_SUCCESS;
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                    FileName cache routines                         //
//                                                                    //
////////////////////////////////////////////////////////////////////////

BOOLEAN
SpyGetFullPathName (
    IN PFILE_OBJECT FileObject,
    IN OUT PUNICODE_STRING FileName,
    IN PFILESPY_DEVICE_EXTENSION devExt,
    IN NAME_LOOKUP_FLAGS LookupFlags
    )
/*++

Routine Description:

    This routine retrieves the full pathname of the FileObject.  Note that
    the buffers containing pathname components may be stored in paged pool,
    therefore if we are at DISPATCH_LEVEL we cannot look up the name.

    The file is looked up one of the following ways based on the LookupFlags:
    1.  FlagOn( FileObject->Flags, FO_VOLUME_OPEN ) or (FileObject->FileName.Length == 0).
        This is a volume open, so just use DeviceName from the devExt 
        for the FileName, if it exists.
    2.  NAMELOOKUPFL_IN_CREATE and NAMELOOKUPFL_OPEN_BY_ID are set.
        This is an open by file id, so format the file id into the FileName
        string if there is enough room.
    3.  NAMELOOKUPFL_IN_CREATE set and FileObject->RelatedFileObject != NULL.
        This is a relative open, therefore the fullpath file name must
        be built up from the name of the FileObject->RelatedFileObject
        and FileObject->FileName.
    4.  NAMELOOKUPFL_IN_CREATE and FileObject->RelatedFileObject == NULL.
        This is an absolute open, therefore the fullpath file name is
        found in FileObject->FileName.
    5.  No LookupFlags set.
        This is a lookup sometime after CREATE.  FileObject->FileName is 
        no longer guaranteed to be valid, so use ObQueryNameString
        to get the fullpath name of the FileObject.
    
Arguments:

    FileObject - Pointer to the FileObject to the get name of.

    FileName - Unicode string that will be filled in with the filename,  It 
        is assumed that the caller allocates and frees the memory used by 
        the string.  The buffer and MaximumLength for this string should be 
        set.  If there is room in the buffer, the string will be NULL 
        terminated.

    devExt - Contains the device name and next device object
        which are needed to build the full path name.

    LookupFlags - The flags to say whether to get the name from the file
        object or to get the file id.

Return Value:

    Returns TRUE if the returned name should be saved in the cache,
    returns FALSE if the returned name should NOT be saved in the cache.
    In all cases some sort of valid name is always returned.

--*/
{
    NTSTATUS status;
    ULONG i;
    BOOLEAN retValue = TRUE;
    UCHAR buffer[sizeof(FILE_NAME_INFORMATION) + MAX_NAME_SPACE];

    //
    //  Copy over the name the user gave for this device.  These names
    //  should be meaningful to the user.  Note that we do not do this for
    //  NETWORK file system because internally they already show the
    //  connection name.  If this is a direct device open of the network
    //  file system device, we will copy over the device name to be
    //  returned to the user.
    //
    
    if (FILE_DEVICE_NETWORK_FILE_SYSTEM != devExt->ThisDeviceObject->DeviceType) {

        RtlCopyUnicodeString( FileName, &devExt->UserNames );
        
    } else if (FlagOn( FileObject->Flags, FO_DIRECT_DEVICE_OPEN )) {

        ASSERT( devExt->ThisDeviceObject->DeviceType == FILE_DEVICE_NETWORK_FILE_SYSTEM );
        RtlCopyUnicodeString( FileName, &devExt->DeviceName );

        //
        //  We are now done since there will be no more to the name in this
        //  case, so return TRUE.
        //
        
        return TRUE;
    }

    //
    //  See if we can request the name
    //

    if (FlagOn( LookupFlags, NLFL_ONLY_CHECK_CACHE )) {

        RtlAppendUnicodeToString( FileName, L"[-=Not In Cache=-]" );
        return FALSE;
    }

    //
    //  Can not get the name at DPC level
    //

    if (KeGetCurrentIrql() > APC_LEVEL) {

        RtlAppendUnicodeToString( FileName, L"[-=At DPC Level=-]" );
        return FALSE;
    }

    //
    //  If there is a ToplevelIrp then this is a nested operation and
    //  there might be other locks held.  Can not get name without the
    //  potential of deadlocking.
    //

    if (IoGetTopLevelIrp() != NULL) {

        RtlAppendUnicodeToString( FileName, L"[-=Nested Operation=-]" );
        return FALSE;
    }

    //
    //  CASE 1:  This FileObject refers to a Volume open.  Either the
    //           flag is set or no filename is specified.
    //

    if (FlagOn( FileObject->Flags, FO_VOLUME_OPEN ) ||
        (FlagOn( LookupFlags, NLFL_IN_CREATE ) &&
         (FileObject->FileName.Length == 0) && 
         (FileObject->RelatedFileObject == NULL))) {

        //
        //  We've already copied the VolumeName so just return.
        //

    }

    //
    //  CASE 2:  We are opening the file by ID.
    //

    else if (FlagOn( LookupFlags, NLFL_IN_CREATE ) &&
             FlagOn( LookupFlags, NLFL_OPEN_BY_ID )) {

#       define OBJECT_ID_KEY_LENGTH 16
        UNICODE_STRING fileIdName;

        RtlInitEmptyUnicodeString( &fileIdName,
                                   (PWSTR)buffer,
                                   sizeof(buffer) );

        if (FileObject->FileName.Length == sizeof(LONGLONG)) {

			//
            //  Opening by FILE ID, generate a name
			//
			
            swprintf( fileIdName.Buffer, 
                      L"<%016I64x>", 
                      *((PLONGLONG)FileObject->FileName.Buffer) );

        } else if ((FileObject->FileName.Length == OBJECT_ID_KEY_LENGTH) ||
                   (FileObject->FileName.Length == OBJECT_ID_KEY_LENGTH + 
                                                                sizeof(WCHAR)))
        {
            PUCHAR idBuffer;

            //
            //  Opening by Object ID, generate a name
            //

            idBuffer = (PUCHAR)&FileObject->FileName.Buffer[0];

            if (FileObject->FileName.Length != OBJECT_ID_KEY_LENGTH) {

                //
                //  Skip win32 backslash at start of buffer
                //
                idBuffer = (PUCHAR)&FileObject->FileName.Buffer[1];
            }

            swprintf( fileIdName.Buffer,
					  L"<%08x-%04hx-%04hx-%04hx-%04hx%08x>",
                      *(PULONG)&idBuffer[0],
                      *(PUSHORT)&idBuffer[0+4],
                      *(PUSHORT)&idBuffer[0+4+2],
                      *(PUSHORT)&idBuffer[0+4+2+2],
                      *(PUSHORT)&idBuffer[0+4+2+2+2],
                      *(PULONG)&idBuffer[0+4+2+2+2+2]);

        } else {

			//
            //  Unknown ID format
			//

            swprintf( fileIdName.Buffer,
                      L"[-=Unknown ID (Len=%u)=-]",
                      FileObject->FileName.Length);
        }

        fileIdName.Length = wcslen( fileIdName.Buffer ) * sizeof( WCHAR );

        //
        //  Append the fileIdName to FileName.
        //

        RtlAppendUnicodeStringToString( FileName, &fileIdName );

        //
        //  Don't cache the ID name
        //

        retValue = FALSE;
    } 

    //
    //  CASE 3: We are opening a file that has a RelatedFileObject.
    //
    
    else if (FlagOn( LookupFlags, NLFL_IN_CREATE ) &&
             (NULL != FileObject->RelatedFileObject)) {

        //
        //  Must be a relative open.  Use ObQueryNameString to get
        //  the name of the related FileObject.  Then we will append this
        //  fileObject's name.
        //
        //  Note: 
        //  The name in FileObject and FileObject->RelatedFileObject are accessible.  Names further up
        //  the related file object chain (ie FileObject->RelatedFileObject->RelatedFileObject)
        //  may not be accessible.  This is the reason we use ObQueryNameString
        //  to get the name for the RelatedFileObject.
        //

        PFILE_NAME_INFORMATION relativeNameInfo = (PFILE_NAME_INFORMATION)buffer;
        ULONG returnLength;

        status = SpyQueryFileSystemForFileName( FileObject->RelatedFileObject,
                                                devExt->AttachedToDeviceObject,
                                                sizeof( buffer ),
                                                relativeNameInfo,
                                                &returnLength );

        if (NT_SUCCESS( status ) &&
            ((FileName->Length + relativeNameInfo->FileNameLength + FileObject->FileName.Length + sizeof( L'\\' ))
             <= FileName->MaximumLength)) {

            //
            //  We were able to get the relative fileobject's name and we have
            //  enough room in the FileName buffer, so build up the file name
            //  in the following format:
            //      [volumeName]\[relativeFileObjectName]\[FileObjectName]
            //  The VolumeName is already in FileName if we've got one.
            //

            RtlCopyMemory( &FileName->Buffer[FileName->Length/sizeof(WCHAR)],
                           relativeNameInfo->FileName,
                           relativeNameInfo->FileNameLength );

            FileName->Length += (USHORT)relativeNameInfo->FileNameLength;

        } else if ((FileName->Length + FileObject->FileName.Length + sizeof(L"...\\")) <=
                   FileName->MaximumLength ) {

            //
            //  Either the query for the relative fileObject name was unsuccessful,
            //  or we don't have enough room for the relativeFileObject name, but we
            //  do have enough room for "...\[fileObjectName]" in FileName.
            //

            status = RtlAppendUnicodeToString( FileName, L"...\\" );
            ASSERT( status == STATUS_SUCCESS );
        }

        //
        //  If there is not a slash and the end of the related file object
        //  string and there is not a slash at the front of the file object
        //  string, then add one.
        //

        if (((FileName->Length < sizeof(WCHAR) ||
             (FileName->Buffer[(FileName->Length/sizeof(WCHAR))-1] != L'\\'))) &&
            ((FileObject->FileName.Length < sizeof(WCHAR)) ||
             (FileObject->FileName.Buffer[0] != L'\\')))
        {

            RtlAppendUnicodeToString( FileName, L"\\" );
        }

        //
        //  At this time, copy over the FileObject->FileName to the FileName
        //  unicode string.
        //

        RtlAppendUnicodeStringToString( FileName, &FileObject->FileName );
    }
    
    //
    //  CASE 4: We have a open on a file with an absolute path.
    //
    
    else if (FlagOn( LookupFlags, NLFL_IN_CREATE ) &&
             (FileObject->RelatedFileObject == NULL) ) {

        // 
        //  We have an absolute path, so try to copy that into FileName.
        //

        RtlAppendUnicodeStringToString( FileName, &FileObject->FileName );
    }

    //
    //  CASE 5: We are retrieving the file name sometime after the
    //  CREATE operation.
    //

    else if (!FlagOn( LookupFlags, NLFL_IN_CREATE )) {

        PFILE_NAME_INFORMATION nameInfo = (PFILE_NAME_INFORMATION)buffer;
        ULONG returnLength;

        status = SpyQueryFileSystemForFileName( FileObject,
                                                devExt->AttachedToDeviceObject,
                                                sizeof( buffer ),
                                                nameInfo,
                                                &returnLength );

        if (NT_SUCCESS( status )) {

            if ((FileName->Length + nameInfo->FileNameLength) <= FileName->MaximumLength) {

                //
                //  We've got enough room for the file name, so copy it into
                //  FileName.
                //

                RtlCopyMemory( &FileName->Buffer[FileName->Length/sizeof(WCHAR)],
                               nameInfo->FileName,
                               nameInfo->FileNameLength );

                FileName->Length += (USHORT)nameInfo->FileNameLength;
                               
            } else {

                //
                //  We don't have enough room for the file name, so copy our
                //  EXCEED_NAME_BUFFER error message.
                //

                RtlAppendUnicodeToString( FileName, 
                                          L"[-=Name To Large=-]" );
            }
            
        } else {

            //
            //  Got an error trying to get the file name from the base file system,
            //  so put that error message into FileName.
            //

            swprintf((PWCHAR)buffer,L"[-=Error 0x%x Getting Name=-]",status );

            RtlAppendUnicodeToString( FileName, (PWCHAR)buffer );

            //
            //  Don't cache an error-generated name
            //

            retValue = FALSE;
        }
    }

    //
    //  When we get here we have a valid name.
    //  Sometimes when we query a name it has a trailing slash, other times
    //  it doesn't.  To make sure the contexts are correct we are going to
    //  remove a trailing slash if there is not a ":" just before it.
    //

    if ((FileName->Length >= (2*sizeof(WCHAR))) &&
        (FileName->Buffer[(FileName->Length/sizeof(WCHAR))-1] == L'\\') &&
        (FileName->Buffer[(FileName->Length/sizeof(WCHAR))-2] != L':'))
    {

        FileName->Length -= sizeof(WCHAR);
    }

    //
    //  See if we are actually opening the target directory.  If so then
    //  remove the trailing name and slash.  Note that we won't remove
    //  the initial slash (just after the colon).
    //

    if (FlagOn( LookupFlags, NLFL_OPEN_TARGET_DIR ) &&
        (FileName->Length > 0))
    {
        i = (FileName->Length / sizeof(WCHAR)) - 1;

        //
        //  See if the path ends in a backslash, if so skip over it
        //  (since the file system did).
        //

        if ((i > 0) &&
            (FileName->Buffer[i] == L'\\') &&
            (FileName->Buffer[i-1] != L':')) {

            i--;
        }

        //
        //  Scan backwards over the last component
        //

        for ( ;
              i > 0;
              i-- )
        {

            if (FileName->Buffer[i] == L'\\') {

                if ((i > 0) && (FileName->Buffer[i-1] == L':')) {

                    i++;
                }

                FileName->Length = (USHORT)(i * sizeof(WCHAR));
                break;
            }
        }
    }

    return retValue;
}


NTSTATUS
SpyQueryCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT SynchronizingEvent
    )
/*++

Routine Description:

    This routine does the cleanup necessary once the query request completed
    by the file system.
    
Arguments:

    DeviceObject - This will be NULL since we originated this
        Irp.

    Irp - The io request structure containing the information
        about the current state of our file name query.

    SynchronizingEvent - The event to signal to notify the 
        originator of this request that the operation is
        complete.

Return Value:

    Returns STATUS_MORE_PROCESSING_REQUIRED so that IO Manager
    will not try to free the Irp again.

--*/
{

    UNREFERENCED_PARAMETER( DeviceObject );
    
    //
    //  Make sure that the Irp status is copied over to the user's
    //  IO_STATUS_BLOCK so that the originator of this irp will know
    //  the final status of this operation.
    //

    ASSERT( NULL != Irp->UserIosb );
    *Irp->UserIosb = Irp->IoStatus;

    //
    //  Signal SynchronizingEvent so that the originator of this
    //  Irp know that the operation is completed.
    //

    KeSetEvent( SynchronizingEvent, IO_NO_INCREMENT, FALSE );

    //
    //  We are now done, so clean up the irp that we allocated.
    //

    IoFreeIrp( Irp );

    //
    //  If we return STATUS_SUCCESS here, the IO Manager will
    //  perform the cleanup work that it thinks needs to be done
    //  for this IO operation.  This cleanup work includes:
    //  * Copying data from the system buffer to the user's buffer 
    //    if this was a buffered IO operation.
    //  * Freeing any MDLs that are in the Irp.
    //  * Copying the Irp->IoStatus to Irp->UserIosb so that the
    //    originator of this irp can see the final status of the
    //    operation.
    //  * If this was an asynchronous request or this was a 
    //    synchronous request that got pending somewhere along the
    //    way, the IO Manager will signal the Irp->UserEvent, if one 
    //    exists, otherwise it will signal the FileObject->Event.
    //    (This can have REALLY bad implications if the irp originator
    //     did not an Irp->UserEvent and the irp originator is not
    //     waiting on the FileObject->Event.  It would not be that
    //     farfetched to believe that someone else in the system is
    //     waiting on FileObject->Event and who knows who will be
    //     awoken as a result of the IO Manager signaling this event.
    //
    //  Since some of these operations require the originating thread's
    //  context (e.g., the IO Manager need the UserBuffer address to 
    //  be valid when copy is done), the IO Manager queues this work
    //  to an APC on the Irp's originating thread.
    //
    //  Since FileSpy allocated and initialized this irp, we know
    //  what cleanup work needs to be done.  We can do this cleanup
    //  work more efficiently than the IO Manager since we are handling
    //  a very specific case.  Therefore, it is better for us to
    //  perform the cleanup work here then free the irp than passing
    //  control back to the IO Manager to do this work.
    //
    //  By returning STATUS_MORE_PROCESS_REQUIRED, we tell the IO Manager 
    //  to stop processing this irp until it is told to restart processing
    //  with a call to IoCompleteRequest.  Since the IO Manager has
    //  already performed all the work we want it to do on this
    //  irp, we do the cleanup work, return STATUS_MORE_PROCESSING_REQUIRED,
    //  and ask the IO Manager to resume processing by calling 
    //  IoCompleteRequest.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
SpyQueryFileSystemForFileName (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT NextDeviceObject,
    IN ULONG FileNameInfoLength,
    OUT PFILE_NAME_INFORMATION FileNameInfo,
    OUT PULONG ReturnedLength
    )
/*++

Routine Description:

    This routine rolls an irp to query the name of the
    FileObject parameter from the base file system.

    Note:  ObQueryNameString CANNOT be used here because it
      would cause recursive lookup of the file name for FileObject.
      
Arguments:

    FileObject - the file object for which we want the name.
    NextDeviceObject - the device object for the next driver in the
        stack.  This is where we want to start our request
        for the name of FileObject.
    FileNameInfoLength - the length in bytes of FileNameInfo
        parameter.
    FileNameInfo - the buffer that will be receive the name
        information.  This must be memory that safe to write
        to from kernel space.
    ReturnedLength - the number of bytes written to FileNameInfo.
    
Return Value:

    Returns the status of the operation.
    
--*/
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;

    PAGED_CODE();

    irp = IoAllocateIrp( NextDeviceObject->StackSize, FALSE );
    
    if (irp == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Set our current thread as the thread for this
    //  irp so that the IO Manager always knows which
    //  thread to return to if it needs to get back into
    //  the context of the thread that originated this
    //  irp.
    //
    
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    //  Set that this irp originated from the kernel so that
    //  the IO Manager knows that the buffers do not
    //  need to be probed.
    //
    
    irp->RequestorMode = KernelMode;

    //
    //  Initialize the UserIosb and UserEvent in the 
    //

    ioStatus.Status = STATUS_SUCCESS;
    ioStatus.Information = 0;

    irp->UserIosb = &ioStatus;
    irp->UserEvent = NULL;        //already zeroed

    //
    //  Set the IRP_SYNCHRONOUS_API to denote that this
    //  is a synchronous IO request.
    //

    irp->Flags = IRP_SYNCHRONOUS_API;

    irpSp = IoGetNextIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_QUERY_INFORMATION;
    irpSp->FileObject = FileObject;

    //
    //  Setup the parameters for IRP_MJ_QUERY_INFORMATION.
    //  The buffer we want to be filled in should be placed in
    //  the system buffer.
    //

    irp->AssociatedIrp.SystemBuffer = FileNameInfo;

    irpSp->Parameters.QueryFile.Length = FileNameInfoLength;
    irpSp->Parameters.QueryFile.FileInformationClass = FileNameInformation;

    //
    //  Set up the completion routine so that we know when our
    //  request for the file name is completed.  At that time,
    //  we can free the irp.
    //
    
    KeInitializeEvent( &event, NotificationEvent, FALSE );

    IoSetCompletionRoutine( irp, 
                            SpyQueryCompletion, 
                            &event, 
                            TRUE, 
                            TRUE, 
                            TRUE );

    status = IoCallDriver( NextDeviceObject, irp );

    SPY_LOG_PRINT( SPYDEBUG_TRACE_NAME_REQUESTS,
                   ("FileSpy!SpyQueryFileSystemForFileName: Issued name request -- IoCallDriver status: 0x%08x\n",
                    status) );

    if (STATUS_PENDING == status) {

        (VOID) KeWaitForSingleObject( &event, 
                                      Executive, 
                                      KernelMode,
                                      FALSE,
                                      NULL );
    }

    ASSERT(KeReadStateEvent(&event) || !NT_SUCCESS(ioStatus.Status));

    SPY_LOG_PRINT( SPYDEBUG_TRACE_NAME_REQUESTS,
                   ("FileSpy!SpyQueryFileSystemForFileName: Finished waiting for name request to complete...\n") );

    *ReturnedLength = (ULONG) ioStatus.Information;
    return ioStatus.Status;
}


NTSTATUS
SpyQueryInformationFile (
	IN PDEVICE_OBJECT NextDeviceObject,
	IN PFILE_OBJECT FileObject,
	OUT PVOID FileInformation,
	IN ULONG Length,
	IN FILE_INFORMATION_CLASS FileInformationClass,
	OUT PULONG LengthReturned OPTIONAL
	)

/*++

Routine Description:

    This routine returns the requested information about a specified file.
    The information returned is determined by the FileInformationClass that
    is specified, and it is placed into the caller's FileInformation buffer.

Arguments:

    NextDeviceObject - Supplies the device object where this IO should start
        in the device stack.

    FileObject - Supplies the file object about which the requested
        information should be returned.

    FileInformation - Supplies a buffer to receive the requested information
        returned about the file.  This must be a buffer allocated from kernel
        space.

    Length - Supplies the length, in bytes, of the FileInformation buffer.

    FileInformationClass - Specifies the type of information which should be
        returned about the file.

    LengthReturned - the number of bytes returned if the operation was 
        successful.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp = NULL;
    PIO_STACK_LOCATION irpSp = NULL;
    IO_STATUS_BLOCK ioStatusBlock;
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();
    
    //
    //  In DBG builds, make sure that we have valid parameters before we do 
    //  any work here.
    //

    ASSERT( NULL != NextDeviceObject );
    ASSERT( NULL != FileObject );
    ASSERT( NULL != FileInformation );
    
    //
    //  The parameters look ok, so setup the Irp.
    //

    KeInitializeEvent( &event, NotificationEvent, FALSE );
    ioStatusBlock.Status = STATUS_SUCCESS;
    ioStatusBlock.Information = 0;

    irp = IoAllocateIrp( NextDeviceObject->StackSize, FALSE );
    
    if (irp == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Set our current thread as the thread for this
    //  irp so that the IO Manager always knows which
    //  thread to return to if it needs to get back into
    //  the context of the thread that originated this
    //  irp.
    //
    
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    //  Set that this irp originated from the kernel so that
    //  the IO Manager knows that the buffers do not
    //  need to be probed.
    //
    
    irp->RequestorMode = KernelMode;

    //
    //  Initialize the UserIosb and UserEvent in the 
    irp->UserIosb = &ioStatusBlock;
    irp->UserEvent = NULL;

    //
    //  Set the IRP_SYNCHRONOUS_API to denote that this
    //  is a synchronous IO request.
    //

    irp->Flags = IRP_SYNCHRONOUS_API;

    irpSp = IoGetNextIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_QUERY_INFORMATION;
    irpSp->FileObject = FileObject;

    //
    //  Setup the parameters for IRP_MJ_QUERY_INFORMATION.  These
    //  were supplied by the caller of this routine.
    //  The buffer we want to be filled in should be placed in
    //  the system buffer.
    //

    irp->AssociatedIrp.SystemBuffer = FileInformation;

    irpSp->Parameters.QueryFile.Length = Length;
    irpSp->Parameters.QueryFile.FileInformationClass = FileInformationClass;

    //
    //  Set up the completion routine so that we know when our
    //  request for the file name is completed.  At that time,
    //  we can free the irp.
    //
    
    IoSetCompletionRoutine( irp, 
                            SpyQueryCompletion, 
                            &event, 
                            TRUE, 
                            TRUE, 
                            TRUE );

    status = IoCallDriver( NextDeviceObject, irp );

    if (STATUS_PENDING == status) {

        KeWaitForSingleObject( &event, 
                               Executive, 
                               KernelMode,
                               FALSE,
                               NULL );
     }

    //
    //  Verify the completion has actually been run
    //

    ASSERT(KeReadStateEvent(&event) || !NT_SUCCESS(ioStatusBlock.Status));


    if (ARGUMENT_PRESENT(LengthReturned)) {

        *LengthReturned = (ULONG) ioStatusBlock.Information;
    }

    return ioStatusBlock.Status;
}


////////////////////////////////////////////////////////////////////////
//                                                                    //
//         Common attachment and detachment routines                  //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
//  VERSION NOTE:
//
//  To be able to safely find out if our filter is attached to a device given
//  its name on Windows 2000 and later, we need to use the approach in 
//  SpyIsAttachedToDeviceByUserDeviceName.  This method uses APIs that are
//  available on Windows 2000 and later.  On Windows XP or later, you could
//  change this routine to separate the translation from DeviceName to device
//  object from the search to see if our filter's device is attached to the
//  device stack.  In Windows XP and later, the logic to translate the 
//  DeviceName to the device object is the same, but you can use the logic
//  in SpyIsAttachedToDeviceWXPAndLater to find your filter's device object
//  in the device stack safely.
//

NTSTATUS 
SpyIsAttachedToDeviceByUserDeviceName (
    IN PUNICODE_STRING DeviceName,
    IN OUT PBOOLEAN IsAttached,
    IN OUT PDEVICE_OBJECT *StackDeviceObject,
    IN OUT PDEVICE_OBJECT *OurAttachedDeviceObject
    )
/*++

Routine Description:

    This routine maps a user's device name to a file system device stack, if
    one exists.  Then this routine walks the device stack to find a device
    object belonging to our driver.

    The APIs used here to walk the device stack are all safe to use while you
    are guaranteed that the device stack will not go away.  We enforce this
    guarantee
Arguments:

    DeviceName - The name provided by the user to identify this device.

    IsAttached - This is set to TRUE if our filter is attached to this device
        stack, otherwise this is set to FALSE.

    StackDeviceObject - Set to a device object in the stack identified by the
        DeviceName.  If this is non-NULL, the caller is responsible for removing
        the reference put on this object before it was returned.

    AttachedDeviceObject - Set to the deviceObject which FileSpy has previously 
        attached to the device stack identify by DeviceName.  If this is
        non-NULL, the caller is responsible for removing the reference put on
        this object before it was returned.

Return Value:

    Returns STATUS_SUCCESS if we were able to successfully translate the
    DeviceName into a device stack and return the StackDeviceObject.  If an
    error occurs during the translation of the DeviceName into a device stack,
    the appropriate error code is returned.

--*/
{
    WCHAR nameBuf[DEVICE_NAMES_SZ];
    UNICODE_STRING volumeNameUnicodeString;
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK openStatus;
    PFILE_OBJECT volumeFileObject;
    HANDLE fileHandle;
    PDEVICE_OBJECT baseFsDeviceObject;

    PAGED_CODE();

    //
    //  Initialize return state
    //

    ASSERT( NULL != StackDeviceObject );
    ASSERT( NULL != OurAttachedDeviceObject );
    ASSERT( NULL != IsAttached );
    
    *StackDeviceObject = NULL;
    *OurAttachedDeviceObject = NULL;
    *IsAttached = FALSE;

    //
    //  Setup the name to open
    //

    RtlInitEmptyUnicodeString( &volumeNameUnicodeString, nameBuf, sizeof( nameBuf ) );
    RtlAppendUnicodeToString( &volumeNameUnicodeString, L"\\DosDevices\\" );
    RtlAppendUnicodeStringToString( &volumeNameUnicodeString, DeviceName );

    InitializeObjectAttributes( &objectAttributes,
								&volumeNameUnicodeString,
								OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
								NULL,
								NULL);

    //
	// open the file object for the given device
	//

    status = ZwCreateFile( &fileHandle,
						   SYNCHRONIZE|FILE_READ_DATA,
						   &objectAttributes,
						   &openStatus,
						   NULL,
						   0,
						   FILE_SHARE_READ|FILE_SHARE_WRITE,
						   FILE_OPEN,
						   FILE_SYNCHRONOUS_IO_NONALERT,
						   NULL,
						   0);

    if (STATUS_OBJECT_PATH_NOT_FOUND == status ||
        STATUS_OBJECT_NAME_INVALID == status) {

        //
        //  Maybe this name didn't need the "\DosDevices\" prepended to the
        //  name.  Try the open again using just the DeviceName passed in.
        //

         InitializeObjectAttributes( &objectAttributes,
                                     DeviceName,
                                     OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                     NULL,
                                     NULL);

        //
    	// open the file object for the given device
    	//

        status = ZwCreateFile( &fileHandle,
    						   SYNCHRONIZE|FILE_READ_DATA,
    						   &objectAttributes,
    						   &openStatus,
    						   NULL,
    						   0,
    						   FILE_SHARE_READ|FILE_SHARE_WRITE,
    						   FILE_OPEN,
    						   FILE_SYNCHRONOUS_IO_NONALERT,
    						   NULL,
    						   0);

        if (!NT_SUCCESS( status )) {

            return status;
        }

        //
        //  We were able to open the device using the name passed in, so
        //  now we will fall through and do the rest of this work.
        //

    } else if (!NT_SUCCESS( status )) {

        return status;
    }

	//
    // get a pointer to the volumes file object
	//

    status = ObReferenceObjectByHandle( fileHandle,
										FILE_READ_DATA,
										*IoFileObjectType,
										KernelMode,
										&volumeFileObject,
										NULL);

    if(!NT_SUCCESS( status )) {

        ZwClose( fileHandle );
        return status;
    }

	//
    // Get the device object we want to attach to (parent device object in chain)
	//

    baseFsDeviceObject = IoGetBaseFileSystemDeviceObject( volumeFileObject );
    
    if (baseFsDeviceObject == NULL) {

        ObDereferenceObject( volumeFileObject );
        ZwClose( fileHandle );

        return STATUS_INVALID_DEVICE_STATE;
    }

    //
    //  Now see if we are attached to this device stack.  Note that we need to 
    //  keep this file object open while we do this search to ensure that the 
    //  stack won't get torn down while SpyIsAttachedToDevice does its work.
    //

    *IsAttached = SpyIsAttachedToDevice( baseFsDeviceObject,
                                         OurAttachedDeviceObject );
    
    //
    //  Return the base file system's device object to represent this device
    //  stack even if we didn't find our device object in the stack.
    //

    ObReferenceObject( baseFsDeviceObject );
    *StackDeviceObject = baseFsDeviceObject;

    //
    //  Close our handle
    //

    ObDereferenceObject( volumeFileObject );
    ZwClose( fileHandle );

    return STATUS_SUCCESS;
}

//
//  VERSION NOTE:
//  
//  In Windows 2000, the APIs to safely walk an arbitrary file system device 
//  stack were not supported.  If we can guarantee that a device stack won't 
//  be torn down during the walking of the device stack, we can walk from
//  the base file system's device object up to the top of the device stack
//  to see if we are attached.  We know the device stack will not go away if
//  we are in the process of processing a mount request OR we have a file object
//  open on this device.
//  
//  In Windows XP and later, the IO Manager provides APIs that will allow us to
//  walk through the chain safely using reference counts to protect the device 
//  object from going away while we are inspecting it.  This can be done at any
//  time.
//
//  MULTIVERSION NOTE:
//
//  If built for Windows XP or later, this driver is built to run on 
//  multiple versions.  When this is the case, we will test for the presence of
//  the new IO Manager routines that allow for a filter to safely walk the file
//  system device stack and use those APIs if they are present to determine if
//  we have already attached to this volume.  If these new IO Manager routines
//  are not present, we will assume that we are at the bottom of the file
//  system stack and walk up the stack looking for our device object.
//

BOOLEAN
SpyIsAttachedToDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL
    )
{
    PAGED_CODE();
    
#if WINVER >= 0x0501
    if (IS_WINDOWSXP_OR_LATER()) {

        ASSERT( NULL != gSpyDynamicFunctions.GetLowerDeviceObject &&
                NULL != gSpyDynamicFunctions.GetDeviceAttachmentBaseRef );
        
        return SpyIsAttachedToDeviceWXPAndLater( DeviceObject, AttachedDeviceObject );
    } else {
#endif

        return SpyIsAttachedToDeviceW2K( DeviceObject, AttachedDeviceObject );

#if WINVER >= 0x0501
    }
#endif    
}

BOOLEAN
SpyIsAttachedToDeviceW2K (
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL
    )
/*++

Routine Description:

    VERSION: Windows 2000

    This routine walks up the device stack from the DeviceObject passed in
    looking for a device object that belongs to our filter.

    Note:  For this routine to operate safely, the caller must ensure two
        things:
        * the DeviceObject is the base file system's device object and therefore
        is at the bottom of the file system stack
        * this device stack won't be going away while we walk up this stack.  If
        we currently have a file object open for this device stack or we are
        in the process of mounting this device, this guarantee is satisfied.

Arguments:

    DeviceObject - The device chain we want to look through

    AttachedDeviceObject - Set to the deviceObject which FileSpy
            has previously attached to DeviceObject.  If this is non-NULL,
            the caller must clear the reference put on this device object.

Return Value:

    TRUE if we are attached, FALSE if not

--*/
{
    PDEVICE_OBJECT currentDeviceObject;

    PAGED_CODE();

    for (currentDeviceObject = DeviceObject;
         currentDeviceObject != NULL;
         currentDeviceObject = currentDeviceObject->AttachedDevice) {

        if (IS_FILESPY_DEVICE_OBJECT( currentDeviceObject )) {

            //
            //  We are attached.  If requested, return the found device object.
            //

            if (ARGUMENT_PRESENT( AttachedDeviceObject )) {

                ObReferenceObject( currentDeviceObject );
                *AttachedDeviceObject = currentDeviceObject;
            }

            return TRUE;
        }
    }

    //
    //  We did not find ourselves on the attachment chain.  Return a NULL
    //  device object pointer (if requested) and return we did not find
    //  ourselves.
    //
    
    if (ARGUMENT_PRESENT(AttachedDeviceObject)) {

        *AttachedDeviceObject = NULL;
    }

    return FALSE;
}

#if WINVER >= 0x0501

BOOLEAN
SpyIsAttachedToDeviceWXPAndLater (
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL
    )
/*++

Routine Description:

    VERSION: Windows XP and later

    This walks down the attachment chain looking for a device object that
    belongs to this driver.  If one is found, the attached device object
    is returned in AttachedDeviceObject.

Arguments:

    DeviceObject - The device chain we want to look through

    AttachedDeviceObject - Set to the deviceObject which FileSpy
            has previously attached to DeviceObject.

Return Value:

    TRUE if we are attached, FALSE if not

--*/
{
    PDEVICE_OBJECT currentDevObj;
    PDEVICE_OBJECT nextDevObj;

    PAGED_CODE();
    
    //
    //  Get the device object at the TOP of the attachment chain
    //

    ASSERT( NULL != gSpyDynamicFunctions.GetAttachedDeviceReference );
    currentDevObj = (gSpyDynamicFunctions.GetAttachedDeviceReference)( DeviceObject );

    //
    //  Scan down the list to find our device object.
    //

    do {
    
        if (IS_FILESPY_DEVICE_OBJECT( currentDevObj )) {

            //
            //  We have found that we are already attached.  If we are
            //  returning the device object, leave it referenced else remove
            //  the reference.
            //

            if (NULL != AttachedDeviceObject) {

                *AttachedDeviceObject = currentDevObj;

            } else {

                ObDereferenceObject( currentDevObj );
            }

            return TRUE;
        }

        //
        //  Get the next attached object.  This puts a reference on 
        //  the device object.
        //

        ASSERT( NULL != gSpyDynamicFunctions.GetLowerDeviceObject );
        nextDevObj = (gSpyDynamicFunctions.GetLowerDeviceObject)( currentDevObj );

        //
        //  Dereference our current device object, before
        //  moving to the next one.
        //

        ObDereferenceObject( currentDevObj );

        currentDevObj = nextDevObj;
        
    } while (NULL != currentDevObj);
    
    //
    //  Mark no device returned
    //

    if (ARGUMENT_PRESENT(AttachedDeviceObject)) {

        *AttachedDeviceObject = NULL;
    }

    return FALSE;
}

#endif //WINVER >= 0x0501

NTSTATUS
SpyAttachToMountedDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT FilespyDeviceObject
    )
/*++

Routine Description:

    This routine will attach the FileSpyDeviceObject to the filter stack
    that DeviceObject is in.

    NOTE:  If there is an error in attaching, the caller is responsible
        for deleting the FilespyDeviceObject.
    
Arguments:

    DeviceObject - The device object in the stack to which we want to attach.

    FilespyDeviceObject - The filespy device object that is to be attached to
            "DeviceObject".
        
Return Value:

    Returns STATUS_SUCCESS if the filespy deviceObject could be attached,
    otherwise an appropriate error code is returned.
    
--*/
{
    PFILESPY_DEVICE_EXTENSION devExt = FilespyDeviceObject->DeviceExtension;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG i;

    PAGED_CODE();
    ASSERT( IS_FILESPY_DEVICE_OBJECT( FilespyDeviceObject ) );
#if WINVER >= 0x0501    
    ASSERT( !SpyIsAttachedToDevice( DeviceObject, NULL ) );
#endif
    
    //
    //  Insert pointer from extension back to owning device object
    //

    devExt->ThisDeviceObject = FilespyDeviceObject;

    //
    //  Propagate flags from Device Object we are trying to attach to.
    //  Note that we do this before the actual attachment to make sure
    //  the flags are properly set once we are attached (since an IRP
    //  can come in immediately after attachment but before the flags would
    //  be set).
    //

    if (FlagOn( DeviceObject->Flags, DO_BUFFERED_IO )) {

        SetFlag( FilespyDeviceObject->Flags, DO_BUFFERED_IO );
    }

    if (FlagOn( DeviceObject->Flags, DO_DIRECT_IO )) {

        SetFlag( FilespyDeviceObject->Flags, DO_DIRECT_IO );
    }

    //
    //  It is possible for this attachment request to fail because this device
    //  object has not finished initializing.  This can occur if this filter
    //  loaded just as this volume was being mounted.
    //

    for (i=0; i < 8; i++) {
        LARGE_INTEGER interval;

        //
        //  Attach our device object to the given device object
        //  The only reason this can fail is if someone is trying to dismount
        //  this volume while we are attaching to it.
        //

        status = SpyAttachDeviceToDeviceStack( FilespyDeviceObject,
                                               DeviceObject,
                                               &devExt->AttachedToDeviceObject );

        if (NT_SUCCESS(status) ) {

            //
            //  Do all common initializing of the device extension
            //

            SetFlag(devExt->Flags,IsVolumeDeviceObject);

            RtlInitEmptyUnicodeString( &devExt->UserNames,
                                       devExt->UserNamesBuffer,
                                       sizeof(devExt->UserNamesBuffer) );

            SpyInitDeviceNamingEnvironment( FilespyDeviceObject );

            SPY_LOG_PRINT( SPYDEBUG_DISPLAY_ATTACHMENT_NAMES,
                           ("FileSpy!SpyAttachToMountedDevice:            Attaching to volume        %p \"%wZ\"\n",
                            devExt->AttachedToDeviceObject,
                            &devExt->DeviceName) );

            //
            //  Add this device to our attachment list
            //

            ExAcquireFastMutex( &gSpyDeviceExtensionListLock );
            InsertTailList( &gSpyDeviceExtensionList, &devExt->NextFileSpyDeviceLink );
            ExReleaseFastMutex( &gSpyDeviceExtensionListLock );
            SetFlag(devExt->Flags,ExtensionIsLinked);

            return STATUS_SUCCESS;
        }

        //
        //  Delay, giving the device object a chance to finish its
        //  initialization so we can try again
        //

        interval.QuadPart = (500 * DELAY_ONE_MILLISECOND);      //delay 1/2 second
        KeDelayExecutionThread( KernelMode, FALSE, &interval );
    }

    return status;
}


VOID
SpyCleanupMountedDevice (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This cleans up any allocated memory in the device extension.

Arguments:

    DeviceObject - The device we are cleaning up

Return Value:

--*/
{        
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;

    PAGED_CODE();
    
    ASSERT(IS_FILESPY_DEVICE_OBJECT( DeviceObject ));

    SpyCleanupDeviceNamingEnvironment( DeviceObject );

    //
    //  Unlink from global list
    //

    if (FlagOn(devExt->Flags,ExtensionIsLinked)) {

        ExAcquireFastMutex( &gSpyDeviceExtensionListLock );
        RemoveEntryList( &devExt->NextFileSpyDeviceLink );
        ExReleaseFastMutex( &gSpyDeviceExtensionListLock );
        ClearFlag(devExt->Flags,ExtensionIsLinked);
    }
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                    Start/stop logging routines                     //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
//  VERSION NOTE:
//
//  On Windows 2000, we will try to attach a new FileSpy device object to the 
//  device stack represented by the DeviceObject parameter.  We cannot get the
//  real disk device at this time, so this field will be set to NULL in the 
//  device extension.  We also cannot get the device name as it is named
//  in the storage stack for this volume (e.g., \Device\HarddiskVolume1), so we 
//  will just use the user's name for the device for our device name.  On
//  Windows 2000, this information is only available as the device mounts.
//
//  On Windows XP and later, we will try to attach a new FileSpy device object
//  to the device stack represented by the DeviceObject parameter.  We are able
//  to get the disk device object for this stack, so that will be appropriately
//  set in the device extension.  We will also be able to get the device name
//  as it is named by the storage stack.
//
//  MULTIVERSION NOTE:
//
//  In SpyAttachToDeviceOnDemand, you see the code to determine which method of
//  determining if we are already attached based on the dynamically loaded
//  functions present.  If this driver is build for Windows 2000 specifically,
//  this logic will not be used.
//

NTSTATUS
SpyAttachToDeviceOnDemand (
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING UserDeviceName,
    IN OUT PDEVICE_OBJECT *FileSpyDeviceObject
    )
/*++

Routine Description:

    This routine does what is necessary to attach to a device sometime after
    the device has been mounted.

Arguments:

    DeviceObject - The device object that represents the file system stack
        for the volume named by UserDeviceName.

    UserDeviceName - Name of device for which logging should be started

    FileSpyDeviceObject - Set to the new filespy device object that was
        attached if we could successfully attach.
    
Return Value:

    STATUS_SUCCESS if we were able to attach, or an appropriate error code 
    otherwise.
    
--*/
{
    PAGED_CODE();
    
    //
    //  If this device is a DFS device, we do not want to attach to it, so
    //  do this quick check here and return an error if this is the case.
    //
    //  DFS will just redirect the operation to the appropriate redirector.  If
    //  you are interested in monitoring these IOs, you should attach to the 
    //  redirectors.  You cannot attach to these on demand by naming the DFS
    //  device, therefore we fail these requests.
    //

    if (DeviceObject->DeviceType == FILE_DEVICE_DFS) {

        return STATUS_NOT_SUPPORTED;
    }
    
#if WINVER >= 0x0501
    if (IS_WINDOWSXP_OR_LATER()) {

        ASSERT( NULL != gSpyDynamicFunctions.GetDeviceAttachmentBaseRef &&
                NULL != gSpyDynamicFunctions.GetDiskDeviceObject );
        
        return SpyAttachToDeviceOnDemandWXPAndLater( DeviceObject,
                                                     UserDeviceName,
                                                     FileSpyDeviceObject );
    } else {
#endif

        return SpyAttachToDeviceOnDemandW2K( DeviceObject,
                                             UserDeviceName,
                                             FileSpyDeviceObject );
#if WINVER >= 0x0501
    }
#endif    
}

NTSTATUS
SpyAttachToDeviceOnDemandW2K (
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING UserDeviceName,
    IN OUT PDEVICE_OBJECT *FileSpyDeviceObject
    )
/*++

Routine Description:

    VERSION: Windows 2000
    
    This routine does what is necessary to attach to a device sometime after
    the device has been mounted.

    Note that on Windows 2000, we cannot get the disk device object, therefore
    we will just use the User's device name as our name here.

Arguments:

    DeviceObject - The device object that represents the file system stack
        for the volume named by UserDeviceName.

    UserDeviceName - Name of device for which logging should be started

    FileSpyDeviceObject - Set to the new filespy device object that was
        attached if we could successfully attach.
    
Return Value:

    STATUS_SUCCESS if we were able to attach, or an appropriate error code 
    otherwise.
    
--*/
{
    NTSTATUS status;
    PFILESPY_DEVICE_EXTENSION devExt;

    PAGED_CODE();

    ASSERT( FileSpyDeviceObject != NULL );

    //
    //  Create a new device object so we can attach it in the filter stack
    //
    
    status = IoCreateDevice( gFileSpyDriverObject,
							 sizeof( FILESPY_DEVICE_EXTENSION ),
							 NULL,
							 DeviceObject->DeviceType,
							 0,
							 FALSE,
							 FileSpyDeviceObject );

    if (!NT_SUCCESS( status )) {

        return status;
    }

    //
    //  Set disk device object
    //

    devExt = (*FileSpyDeviceObject)->DeviceExtension;
    devExt->Flags = 0;

    //
    //  We cannot get the disk device object when we attach on demand in W2K.
    //
    
    devExt->DiskDeviceObject = NULL;

    //
    //  Set Device Name, we will just use the user's device name on W2K.
    //

    RtlInitEmptyUnicodeString( &devExt->DeviceName,
                               devExt->DeviceNameBuffer,
                               sizeof(devExt->DeviceNameBuffer) );

    RtlAppendUnicodeStringToString( &devExt->DeviceName,
                                    UserDeviceName );
  
    //
    //  Call the routine to attach to a mounted device.
    //

    status = SpyAttachToMountedDevice( DeviceObject,
                                       *FileSpyDeviceObject );

    if (!NT_SUCCESS( status )) {

        SPY_LOG_PRINT( SPYDEBUG_ERROR,
                       ("FileSpy!SpyStartLoggingDevice: Could not attach to \"%wZ\"; logging not started.\n",
                        UserDeviceName) );

        SpyCleanupMountedDevice( *FileSpyDeviceObject );
        IoDeleteDevice( *FileSpyDeviceObject );
        *FileSpyDeviceObject = NULL;
    }

    return status;
}

#if WINVER >= 0x0501

NTSTATUS
SpyAttachToDeviceOnDemandWXPAndLater (
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING UserDeviceName,
    IN OUT PDEVICE_OBJECT *FileSpyDeviceObject
    )
/*++

Routine Description:

    This routine does what is necessary to attach to a device sometime after
    the device has been mounted.

Arguments:

    DeviceObject - The device object that represents the file system stack
        for the volume named by UserDeviceName.

    UserDeviceName - Name of device for which logging should be started

    FileSpyDeviceObject - Set to the new filespy device object that was
        attached if we could successfully attach.
    
Return Value:

    STATUS_SUCCESS if we were able to attach, or an appropriate error code 
    otherwise.
    
--*/
{

    NTSTATUS status;
    PFILESPY_DEVICE_EXTENSION devExt;
    PDEVICE_OBJECT baseFileSystemDeviceObject = NULL;
    PDEVICE_OBJECT diskDeviceObject = NULL;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( UserDeviceName );
    ASSERT( FileSpyDeviceObject != NULL );

    //
    //  If this is a network file system, there will not be a disk device
    //  associated with this device, so there is no need to make this request
    //  of the IO Manager.  We will get the name of the network file system
    //  later from the baseFileSystemDeviceObject vs. the diskDeviceObject 
    //  which is used to retrieve the device name for local volumes.
    //

    baseFileSystemDeviceObject = (gSpyDynamicFunctions.GetDeviceAttachmentBaseRef)( DeviceObject );

    if (FILE_DEVICE_NETWORK_FILE_SYSTEM != baseFileSystemDeviceObject->DeviceType) {

        //
        //  If this is not a network file system, query the IO Manager to get
        //  the diskDeviceObject.  We will only attach if this device has a
        //  disk device object.
        //
        //  It may not have a disk device object for the following reasons:
        //  - It is a control device object for a driver
        //  - There is no media in the device.
        //

        status = (gSpyDynamicFunctions.GetDiskDeviceObject)( baseFileSystemDeviceObject, 
                                                            &diskDeviceObject );

        if (!NT_SUCCESS( status )) {

            SPY_LOG_PRINT( SPYDEBUG_ERROR,
                           ("FileSpy!SpyStartLoggingDevice: No disk device object exists for \"%wZ\"; cannot log this volume.\n",
                            UserDeviceName) );

            goto SpyAttachToDeviceOnDemand_Exit;
        }
    }
    
    //
    //  Create a new device object so we can attach it in the filter stack
    //
    
    status = IoCreateDevice( gFileSpyDriverObject,
							 sizeof( FILESPY_DEVICE_EXTENSION ),
							 NULL,
							 DeviceObject->DeviceType,
							 0,
							 FALSE,
							 FileSpyDeviceObject );

    if (!NT_SUCCESS( status )) {

        goto SpyAttachToDeviceOnDemand_Exit;
    }

    //
    //  Set disk device object
    //

    devExt = (*FileSpyDeviceObject)->DeviceExtension;
    devExt->Flags = 0;

    devExt->DiskDeviceObject = diskDeviceObject;

    //
    //  Set Device Name
    //

    RtlInitEmptyUnicodeString( &devExt->DeviceName,
                               devExt->DeviceNameBuffer,
                               sizeof(devExt->DeviceNameBuffer) );

    if (NULL != diskDeviceObject) {
        
        SpyGetObjectName( diskDeviceObject, 
                          &devExt->DeviceName );

    } else {

        ASSERT( NULL != baseFileSystemDeviceObject &&
                FILE_DEVICE_NETWORK_FILE_SYSTEM == baseFileSystemDeviceObject->DeviceType);

        SpyGetObjectName( baseFileSystemDeviceObject,
                          &devExt->DeviceName );
    }

    //
    //  Call the routine to attach to a mounted device.
    //

    status = SpyAttachToMountedDevice( DeviceObject,
                                       *FileSpyDeviceObject );


    if (!NT_SUCCESS( status )) {

        SPY_LOG_PRINT( SPYDEBUG_ERROR,
                       ("FileSpy!SpyStartLoggingDevice: Could not attach to \"%wZ\"; logging not started.\n",
                        UserDeviceName) );

        SpyCleanupMountedDevice( *FileSpyDeviceObject );
        IoDeleteDevice( *FileSpyDeviceObject );
        *FileSpyDeviceObject = NULL;
        goto SpyAttachToDeviceOnDemand_Exit;
    }

SpyAttachToDeviceOnDemand_Exit:

    if (NULL != baseFileSystemDeviceObject) {

        ObDereferenceObject( baseFileSystemDeviceObject );
    }

    if (NULL != diskDeviceObject) {

        ObDereferenceObject( diskDeviceObject );
    }
    
    return status;
}

#endif    

NTSTATUS
SpyStartLoggingDevice (
    IN PWSTR UserDeviceName
    )
/*++

Routine Description:

    This routine ensures that we are attached to the specified device
    then turns on logging for that device.
    
    Note:  Since all network drives through LAN Manager are represented by _
        one_ device object, we want to only attach to this device stack once
        and use only one device extension to represent all these drives.
        Since FileSpy does not do anything to filter I/O on the LAN Manager's
        device object to only log the I/O to the requested drive, the user
        will see all I/O to a network drive it he/she is attached to a
        network drive.

Arguments:

    UserDeviceName - Name of device for which logging should be started
    
Return Value:

    STATUS_SUCCESS if the logging has been successfully started, or
    an appropriate error code if the logging could not be started.
    
--*/
{
    UNICODE_STRING userDeviceName;
    NTSTATUS status;
    PFILESPY_DEVICE_EXTENSION devExt;
    BOOLEAN isAttached = FALSE;
    PDEVICE_OBJECT stackDeviceObject;
    PDEVICE_OBJECT filespyDeviceObject;

    PAGED_CODE();
    
    //
    //  Check to see if we have previously attached to this device by
    //  opening this device name then looking through its list of attached
    //  devices.
    //

    RtlInitUnicodeString( &userDeviceName, UserDeviceName );

    status = SpyIsAttachedToDeviceByUserDeviceName( &userDeviceName,
                                                    &isAttached,
                                                    &stackDeviceObject,
                                                    &filespyDeviceObject );

    if (!NT_SUCCESS( status )) {

        //
        //  There was an error, so return the error code.
        //
        
        return status;
    }
        
    if (isAttached) {

        //
        //  We are already attached, so just make sure that logging is turned on
        //  for this device.
        //

        ASSERT( NULL != filespyDeviceObject );

        devExt = filespyDeviceObject->DeviceExtension;
        SetFlag(devExt->Flags,LogThisDevice);

        SpyStoreUserName( devExt, &userDeviceName );

        //
        //  Clear the reference that was returned from SpyIsAttachedToDevice.
        //
        
        ObDereferenceObject( filespyDeviceObject );
        
    } else {

        status = SpyAttachToDeviceOnDemand( stackDeviceObject,
                                            &userDeviceName,
                                            &filespyDeviceObject );

        if (!NT_SUCCESS( status )) {

            ObDereferenceObject( stackDeviceObject );
            return status;
        }

        ASSERT( filespyDeviceObject != NULL );
        
        devExt = filespyDeviceObject->DeviceExtension;

        //
        //  We successfully attached so finish our device extension 
        //  initialization.  Along this code path, we want to turn on
        //  logging and store our device name.
        // 

        SetFlag(devExt->Flags,LogThisDevice);

        //
        //  We want to store the name that was used by the user-mode
        //  application to name this device.
        //

        SpyStoreUserName( devExt, &userDeviceName );

        //
        //
        //  Finished all initialization of the new device object,  so clear the
        //  initializing flag now.  This allows other filters to now attach
        //  to our device object.
        //
        //

        ClearFlag( filespyDeviceObject->Flags, DO_DEVICE_INITIALIZING );

    }

    ObDereferenceObject( stackDeviceObject );
    return STATUS_SUCCESS;
}

NTSTATUS
SpyStopLoggingDevice (
    IN PWSTR DeviceName
    )
/*++

Routine Description:

    This routine stop logging the specified device.  Since you can not
    physically detach from devices, this routine simply sets a flag saying
    to not log the device anymore.

    Note:  Since all network drives are represented by _one_ device object,
        and, therefore, one device extension, if the user detaches from one
        network drive, it has the affect of detaching from _all_ network
        devices.

Arguments:

    DeviceName - The name of the device to stop logging.

Return Value:
    NT Status code

--*/
{
    WCHAR nameBuf[DEVICE_NAMES_SZ];
    UNICODE_STRING volumeNameUnicodeString;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_OBJECT filespyDeviceObject;
    BOOLEAN isAttached = FALSE;
    PFILESPY_DEVICE_EXTENSION devExt;
    NTSTATUS status;

    PAGED_CODE();
    
    RtlInitEmptyUnicodeString( &volumeNameUnicodeString, nameBuf, sizeof( nameBuf ) );
    RtlAppendUnicodeToString( &volumeNameUnicodeString, DeviceName );

    status = SpyIsAttachedToDeviceByUserDeviceName( &volumeNameUnicodeString, 
                                                    &isAttached,
                                                    &deviceObject,
                                                    &filespyDeviceObject );

    if (!NT_SUCCESS( status )) {

        //
        //  We could not get the deviceObject from this DeviceName, so
        //  return the error code.
        //
        
        return status;
    }

    //
    //  Find Filespy's device object from the device stack to which
    //  deviceObject is attached.
    //

    if (isAttached) {

        //
        //  FileSpy is attached and FileSpy's deviceObject was returned.
        //

        ASSERT( NULL != filespyDeviceObject );

        devExt = filespyDeviceObject->DeviceExtension;

        //
        //  Stop logging
        //

        ClearFlag(devExt->Flags,LogThisDevice);

        status = STATUS_SUCCESS;

        ObDereferenceObject( filespyDeviceObject );

    } else {

        status = STATUS_INVALID_PARAMETER;
    }    

    ObDereferenceObject( deviceObject );

    return status;
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//       Attaching/detaching to all volumes in system routines        //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
SpyAttachToFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING DeviceName
    )
/*++

Routine Description:

    This will attach to the given file system device object.  We attach to
    these devices so we will know when new devices are mounted.

Arguments:

    DeviceObject - The device to attach to

    DeviceName - Contains the name of this device.

Return Value:

    Status of the operation

--*/
{
    PDEVICE_OBJECT filespyDeviceObject;
    PFILESPY_DEVICE_EXTENSION devExt;
    UNICODE_STRING fsrecName;
    NTSTATUS status;
    UNICODE_STRING tempName;
    WCHAR tempNameBuffer[DEVICE_NAMES_SZ];

    PAGED_CODE();

    //
    //  See if this is a file system we care about.  If not, return.
    //

    if (!IS_SUPPORTED_DEVICE_TYPE(DeviceObject->DeviceType)) {

        return STATUS_SUCCESS;
    }

    //
    //  See if this is Microsoft's file system recognizer device (see if the name of the
    //  driver is the FS_REC driver).  If so skip it.  We don't need to 
    //  attach to file system recognizer devices since we can just wait for the
    //  real file system driver to load.  Therefore, if we can identify them, we won't
    //  attach to them.
    //

    RtlInitUnicodeString( &fsrecName, L"\\FileSystem\\Fs_Rec" );

    RtlInitEmptyUnicodeString( &tempName,
                               tempNameBuffer,
                               sizeof(tempNameBuffer) );

    SpyGetObjectName( DeviceObject->DriverObject, &tempName );
    
    if (RtlCompareUnicodeString( &tempName, &fsrecName, TRUE ) == 0) {

        return STATUS_SUCCESS;
    }

    //
    //  Create a new device object we can attach with
    //

    status = IoCreateDevice( gFileSpyDriverObject,
                             sizeof( FILESPY_DEVICE_EXTENSION ),
                             (PUNICODE_STRING) NULL,
                             DeviceObject->DeviceType,
                             0,
                             FALSE,
                             &filespyDeviceObject );

    if (!NT_SUCCESS( status )) {

        SPY_LOG_PRINT( SPYDEBUG_ERROR,
                       ("FileSpy!SpyAttachToFileSystemDevice: Error creating volume device object for \"%wZ\", status=%08x\n",
                        DeviceName,
                        status) );
        return status;
    }

    //
    //  Load extension, set device object associated with extension
    //

    devExt = filespyDeviceObject->DeviceExtension;
    devExt->Flags = 0;

    devExt->ThisDeviceObject = filespyDeviceObject;

    //
    //  Propagate flags from Device Object we are trying to attach to.
    //  Note that we do this before the actual attachment to make sure
    //  the flags are properly set once we are attached (since an IRP
    //  can come in immediately after attachment but before the flags would
    //  be set).
    //

    if ( FlagOn( DeviceObject->Flags, DO_BUFFERED_IO )) {

        SetFlag( filespyDeviceObject->Flags, DO_BUFFERED_IO );
    }

    if ( FlagOn( DeviceObject->Flags, DO_DIRECT_IO )) {

        SetFlag( filespyDeviceObject->Flags, DO_DIRECT_IO );
    }

    if ( FlagOn( DeviceObject->Characteristics, FILE_DEVICE_SECURE_OPEN ) ) {

        SetFlag( filespyDeviceObject->Characteristics, FILE_DEVICE_SECURE_OPEN );
    }

    //
    //  Do the attachment
    //

    status = SpyAttachDeviceToDeviceStack( filespyDeviceObject, 
                                           DeviceObject, 
                                           &devExt->AttachedToDeviceObject );

    if (!NT_SUCCESS( status )) {

        SPY_LOG_PRINT( SPYDEBUG_ERROR,
                       ("FileSpy!SpyAttachToFileSystemDevice: Could not attach FileSpy to the filesystem control device object \"%wZ\".\n",
                        DeviceName) );

        goto ErrorCleanupDevice;
    }

    //
    //  Since this is an attachment to a file system control device object
    //  we are not going to log anything, but properly initialize our
    //  extension.
    //

    RtlInitEmptyUnicodeString( &devExt->DeviceName,
                               devExt->DeviceNameBuffer,
                               sizeof(devExt->DeviceNameBuffer) );

    RtlCopyUnicodeString( &devExt->DeviceName, DeviceName );        //Save Name

    RtlInitEmptyUnicodeString( &devExt->UserNames,
                               devExt->UserNamesBuffer,
                               sizeof(devExt->UserNamesBuffer) );
                               
    SpyInitDeviceNamingEnvironment( filespyDeviceObject );

    //
    //  The NETWORK device objects function as both CDOs (control device object)
    //  and VDOs (volume device object) so insert the NETWORK CDO devices into
    //  the list of attached device so we will properly enumerate it.
    //

    if (FILE_DEVICE_NETWORK_FILE_SYSTEM == DeviceObject->DeviceType) {

        ExAcquireFastMutex( &gSpyDeviceExtensionListLock );
        InsertTailList( &gSpyDeviceExtensionList, &devExt->NextFileSpyDeviceLink );
        ExReleaseFastMutex( &gSpyDeviceExtensionListLock );
        SetFlag(devExt->Flags,ExtensionIsLinked);
    }

    //
    //  Flag we are no longer initializing this device object
    //

    ClearFlag( filespyDeviceObject->Flags, DO_DEVICE_INITIALIZING );

    //
    //  Display who we have attached to
    //

    SPY_LOG_PRINT( SPYDEBUG_DISPLAY_ATTACHMENT_NAMES,
                   ("FileSpy!SpyAttachToFileSystemDevice:         Attaching to file system   %p \"%wZ\" (%s)\n",
                    DeviceObject,
                    &devExt->DeviceName,
                    GET_DEVICE_TYPE_NAME(filespyDeviceObject->DeviceType)) );

    //
    //  VERSION NOTE:
    //
    //  In Windows XP, the IO Manager provided APIs to safely enumerate all the
    //  device objects for a given driver.  This allows filters to attach to 
    //  all mounted volumes for a given file system at some time after the
    //  volume has been mounted.  There is no support for this functionality
    //  in Windows 2000.
    //
    //  MULTIVERSION NOTE:
    //
    //  If built for Windows XP or later, this driver is built to run on 
    //  multiple versions.  When this is the case, we will test
    //  for the presence of the new IO Manager routines that allow for volume 
    //  enumeration.  If they are not present, we will not enumerate the volumes
    //  when we attach to a new file system.
    //
    
#if WINVER >= 0x0501

    if (IS_WINDOWSXP_OR_LATER()) {

        ASSERT( NULL != gSpyDynamicFunctions.EnumerateDeviceObjectList &&
                NULL != gSpyDynamicFunctions.GetDiskDeviceObject &&
                NULL != gSpyDynamicFunctions.GetDeviceAttachmentBaseRef &&
                NULL != gSpyDynamicFunctions.GetLowerDeviceObject );

        //
        //  Enumerate all the mounted devices that currently
        //  exist for this file system and attach to them.
        //

        status = SpyEnumerateFileSystemVolumes( DeviceObject, &tempName );

        if (!NT_SUCCESS( status )) {

            SPY_LOG_PRINT( SPYDEBUG_ERROR,
                           ("FileSpy!SpyAttachToFileSystemDevice: Error attaching to existing volumes for \"%wZ\", status=%08x\n",
                            DeviceName,
                            status) );

            IoDetachDevice( devExt->AttachedToDeviceObject );
            goto ErrorCleanupDevice;
        }
    }
    
#endif

    return STATUS_SUCCESS;

    /////////////////////////////////////////////////////////////////////
    //                  Cleanup error handling
    /////////////////////////////////////////////////////////////////////

    ErrorCleanupDevice:
        SpyCleanupMountedDevice( filespyDeviceObject );
        IoDeleteDevice( filespyDeviceObject );

    return status;
}

VOID
SpyDetachFromFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Given a base file system device object, this will scan up the attachment
    chain looking for our attached device object.  If found it will detach
    us from the chain.

Arguments:

    DeviceObject - The file system device to detach from.

Return Value:

--*/ 
{
    PDEVICE_OBJECT ourAttachedDevice;
    PFILESPY_DEVICE_EXTENSION devExt;

    PAGED_CODE();

    //
    //  We have to iterate through the device objects in the filter stack
    //  attached to DeviceObject.  If we are attached to this filesystem device
    //  object, We should be at the top of the stack, but there is no guarantee.
    //  If we are in the stack and not at the top, we can safely call IoDetachDevice
    //  at this time because the IO Manager will only really detach our device
    //  object from the stack at a safe time.
    //

    //
    //  Skip the base file system device object (since it can't be us)
    //

    ourAttachedDevice = DeviceObject->AttachedDevice;

    while (NULL != ourAttachedDevice) {

        if (IS_FILESPY_DEVICE_OBJECT( ourAttachedDevice )) {

            devExt = ourAttachedDevice->DeviceExtension;

            //
            //  Display who we detached from
            //

            SPY_LOG_PRINT( SPYDEBUG_DISPLAY_ATTACHMENT_NAMES,
                           ("FileSpy!SpyDetachFromFileSystem:             Detaching from file system %p \"%wZ\" (%s)\n",
                            devExt->AttachedToDeviceObject,
                            &devExt->DeviceName,
                            GET_DEVICE_TYPE_NAME(ourAttachedDevice->DeviceType)) );
                                
            //
            //  Unlink from global list
            //

            if (FlagOn(devExt->Flags,ExtensionIsLinked)) {

                ExAcquireFastMutex( &gSpyDeviceExtensionListLock );
                RemoveEntryList( &devExt->NextFileSpyDeviceLink );
                ExReleaseFastMutex( &gSpyDeviceExtensionListLock );
                ClearFlag(devExt->Flags,ExtensionIsLinked);
            }

            //
            //  Detach us from the object just below us
            //  Cleanup and delete the object
            //

            SpyCleanupMountedDevice( ourAttachedDevice );
            IoDetachDevice( DeviceObject );
            IoDeleteDevice( ourAttachedDevice );

            return;
        }

        //
        //  Look at the next device up in the attachment chain
        //

        DeviceObject = ourAttachedDevice;
        ourAttachedDevice = ourAttachedDevice->AttachedDevice;
    }
}

#if WINVER >= 0x0501

NTSTATUS
SpyEnumerateFileSystemVolumes (
    IN PDEVICE_OBJECT FSDeviceObject,
    IN PUNICODE_STRING Name
    ) 
/*++

Routine Description:

    Enumerate all the mounted devices that currently exist for the given file
    system and attach to them.  We do this because this filter could be loaded
    at any time and there might already be mounted volumes for this file system.

Arguments:

    FSDeviceObject - The device object for the file system we want to enumerate

    Name - An already initialized unicode string used to retrieve names

Return Value:

    The status of the operation

--*/
{
    PDEVICE_OBJECT newDeviceObject;
    PFILESPY_DEVICE_EXTENSION newDevExt;
    PDEVICE_OBJECT *devList;
    PDEVICE_OBJECT diskDeviceObject;
    NTSTATUS status;
    ULONG numDevices;
    ULONG i;

    PAGED_CODE();

    //
    //  Find out how big of an array we need to allocate for the
    //  mounted device list.
    //

    ASSERT( NULL != gSpyDynamicFunctions.EnumerateDeviceObjectList );
    status = (gSpyDynamicFunctions.EnumerateDeviceObjectList)( FSDeviceObject->DriverObject,
                                                              NULL,
                                                              0,
                                                              &numDevices);

    //
    //  We only need to get this list of there are devices.  If we
    //  don't get an error there are no devices so go on.
    //

    if (!NT_SUCCESS( status )) {

        ASSERT(STATUS_BUFFER_TOO_SMALL == status);

        //
        //  Allocate memory for the list of known devices
        //

        numDevices += 8;        //grab a few extra slots

        devList = ExAllocatePoolWithTag( NonPagedPool, 
                                         (numDevices * sizeof(PDEVICE_OBJECT)), 
                                         FILESPY_POOL_TAG );
        if (NULL == devList) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Now get the list of devices.  If we get an error again
        //  something is wrong, so just fail.
        //

        status = (gSpyDynamicFunctions.EnumerateDeviceObjectList)(
                        FSDeviceObject->DriverObject,
                        devList,
                        (numDevices * sizeof(PDEVICE_OBJECT)),
                        &numDevices);

        if (!NT_SUCCESS( status ))  {

            ExFreePoolWithTag( devList, FILESPY_POOL_TAG );
            return status;
        }

        //
        //  Walk the given list of devices and attach to them if we should.
        //

        for (i=0; i < numDevices; i++) {

            //
            //  Do not attach if:
            //      - This is the control device object (the one passed in)
            //      - The device type does not match
            //      - We are already attached to it
            //

            if ((devList[i] != FSDeviceObject) && 
                (devList[i]->DeviceType == FSDeviceObject->DeviceType) &&
                !SpyIsAttachedToDevice( devList[i], NULL )) {

                //
                //  See if this device has a name.  If so, then it must
                //  be a control device so don't attach to it.  This handles
                //  drivers with more then one control device.
                //

                SpyGetBaseDeviceObjectName( devList[i], Name );

                if (Name->Length <= 0) {

                    //
                    //  Get the disk device object associated with this
                    //  file  system device object.  Only try to attach if we
                    //  have a disk device object.
                    //

                    ASSERT( NULL != gSpyDynamicFunctions.GetDiskDeviceObject );
                    status = (gSpyDynamicFunctions.GetDiskDeviceObject)( devList[i], &diskDeviceObject );

                    if (NT_SUCCESS( status )) {

                        //
                        //  Allocate a new device object to attach with
                        //

                        status = IoCreateDevice( gFileSpyDriverObject,
                                                 sizeof( FILESPY_DEVICE_EXTENSION ),
                                                 (PUNICODE_STRING) NULL,
                                                 devList[i]->DeviceType,
                                                 0,
                                                 FALSE,
                                                 &newDeviceObject );

                        if (NT_SUCCESS( status )) {

                            //
                            //  Set disk device object
                            //

                            newDevExt = newDeviceObject->DeviceExtension;
                            newDevExt->Flags = 0;

                            newDevExt->DiskDeviceObject = diskDeviceObject;
                    
                            //
                            //  Set Device Name
                            //

                            RtlInitEmptyUnicodeString( &newDevExt->DeviceName,
                                                       newDevExt->DeviceNameBuffer,
                                                       sizeof(newDevExt->DeviceNameBuffer) );

                            SpyGetObjectName( diskDeviceObject, 
                                              &newDevExt->DeviceName );

                            //
                            //  We have done a lot of work since the last time
                            //  we tested to see if we were already attached
                            //  to this device object.  Test again, this time
                            //  with a lock, and attach if we are not attached.
                            //  The lock is used to atomically test if we are
                            //  attached, and then do the attach.
                            //

                            ExAcquireFastMutex( &gSpyAttachLock );

                            if (!SpyIsAttachedToDevice( devList[i], NULL )) {

                                //
                                //  Attach to this device object
                                //

                                status = SpyAttachToMountedDevice( devList[i], 
                                                                   newDeviceObject );

                                //
                                //  Handle normal vs error cases, but keep going
                                //

                                if (NT_SUCCESS( status )) {

                                    //
                                    //  Finished all initialization of the new
                                    //  device object,  so clear the initializing
                                    //  flag now.  This allows other filters to
                                    //  now attach to our device object.
                                    //

                                    ClearFlag( newDeviceObject->Flags, DO_DEVICE_INITIALIZING );

                                } else {

                                    //
                                    //  The attachment failed, cleanup.  Note that
                                    //  we continue processing so we will cleanup
                                    //  the reference counts and try to attach to
                                    //  the rest of the volumes.
                                    //
                                    //  One of the reasons this could have failed
                                    //  is because this volume is just being
                                    //  mounted as we are attaching and the
                                    //  DO_DEVICE_INITIALIZING flag has not yet
                                    //  been cleared.  A filter could handle
                                    //  this situation by pausing for a short
                                    //  period of time and retrying the attachment.
                                    //

                                    SpyCleanupMountedDevice( newDeviceObject );
                                    IoDeleteDevice( newDeviceObject );
                                }

                            } else {

                                //
                                //  We were already attached, cleanup this
                                //  device object.
                                //

                                SpyCleanupMountedDevice( newDeviceObject );
                                IoDeleteDevice( newDeviceObject );
                            }

                            //
                            //  Release the lock
                            //

                            ExReleaseFastMutex( &gSpyAttachLock );

                        } else {

                            SPY_LOG_PRINT( SPYDEBUG_ERROR,
                                           ("FileSpy!SpyEnumberateFileSystemVolumes: Error creating volume device object, status=%08x\n",
                                            status) );
                        }
                        
                        //
                        //  Remove reference added by IoGetDiskDeviceObject.
                        //  We only need to hold this reference until we are
                        //  successfully attached to the current volume.  Once
                        //  we are successfully attached to devList[i], the
                        //  IO Manager will make sure that the underlying
                        //  diskDeviceObject will not go away until the file
                        //  system stack is torn down.
                        //

                        ObDereferenceObject( diskDeviceObject );
                    }
                }
            }

            //
            //  Dereference the object (reference added by 
            //  IoEnumerateDeviceObjectList)
            //

            ObDereferenceObject( devList[i] );
        }

        //
        //  We are going to ignore any errors received while loading.  We
        //  simply won't be attached to those volumes if we get an error
        //

        status = STATUS_SUCCESS;

        //
        //  Free the memory we allocated for the list
        //

        ExFreePoolWithTag( devList, FILESPY_POOL_TAG );
    }

    return status;
}
#endif

////////////////////////////////////////////////////////////////////////
//                                                                    //
//             Private Filespy IOCTLs helper routines                 //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
SpyGetAttachList (
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG_PTR ReturnLength
    )
/*++

Routine Description:
    This returns an array of structure identifying all of the devices
    we are currently physical attached to and whether logging is on or
    off for the given device

Arguments:
    buffer - buffer to receive the attachment list
    bufferSize - total size in bytes of the return buffer
    returnLength - receives number of bytes we actually return

Return Value:
    NT Status code

--*/
{
    PLIST_ENTRY link;
    PFILESPY_DEVICE_EXTENSION devExt;
    PATTACHED_DEVICE pAttDev;
    ULONG retlen = 0;
    UNICODE_STRING attachedDevName;

    PAGED_CODE();

    pAttDev = Buffer;

    try {

        ExAcquireFastMutex( &gSpyDeviceExtensionListLock );

        for (link = gSpyDeviceExtensionList.Flink;
             link != &gSpyDeviceExtensionList;
             link = link->Flink) {

            devExt = CONTAINING_RECORD(link, FILESPY_DEVICE_EXTENSION, NextFileSpyDeviceLink);

            if (BufferSize < sizeof(ATTACHED_DEVICE)) {

                break;
    		}

            pAttDev->LoggingOn = BooleanFlagOn(devExt->Flags,LogThisDevice);

            //
            //  We set up a unicode string to represent the buffer where we 
            //  want to copy the device name.  We will reserve space for the 
            //  terminating NULL that the caller is expecting.
            //
            //  NOTE: Since DeviceNames is an imbedded array in the
            //  ATTACHED_DEVICE structure, sizeof( pAttDev->DeviceNames ) 
            //  returns the correct size.  RtlCopyUnicodeString ensure that the
            //  copy does not extend past the MaximumLength of our destination
            //  string.
            //
            
            attachedDevName.MaximumLength = sizeof( pAttDev->DeviceNames ) - 
                                            sizeof( UNICODE_NULL );
            attachedDevName.Length = 0;
            attachedDevName.Buffer = pAttDev->DeviceNames;

            RtlCopyUnicodeString( &attachedDevName,
                                  &devExt->DeviceName );

            attachedDevName.Buffer[attachedDevName.Length/sizeof(WCHAR)] = UNICODE_NULL;

            retlen += sizeof( ATTACHED_DEVICE );
            BufferSize -= sizeof( ATTACHED_DEVICE );
            pAttDev++;
        }
             
    } finally {

        ExReleaseFastMutex( &gSpyDeviceExtensionListLock );
    }

    *ReturnLength = retlen;
    return STATUS_SUCCESS;
}

VOID
SpyGetLog (
    OUT PVOID            OutputBuffer,
    IN  ULONG            OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:
    This function fills OutputBuffer with as many LOG_RECORDs as possible.
    The LOG_RECORDs are variable sizes and are tightly packed in the
    OutputBuffer.

Arguments:
    OutputBuffer - the user's buffer to fill with the log data we have
        collected
    OutputBufferLength - the size in bytes of OutputBuffer
    IoStatus - is set to the correct return status information for this
        operation

Return Value:
    None

--*/
{
    PLIST_ENTRY pList = NULL;
    ULONG length = OutputBufferLength;
    PCHAR pOutBuffer = OutputBuffer;
    PLOG_RECORD pLogRecord = NULL;
    ULONG recordsAvailable = 0, logRecordLength;
    PRECORD_LIST pRecordList;
    KIRQL oldIrql;

    IoStatus->Information = 0;

    KeAcquireSpinLock(&gOutputBufferLock, &oldIrql);

    while (!IsListEmpty( &gOutputBufferList ) && (length > 0)) {

        pList = RemoveHeadList( &gOutputBufferList );

        pRecordList = CONTAINING_RECORD( pList, RECORD_LIST, List );

        pLogRecord = &pRecordList->LogRecord;

        recordsAvailable++;

		//
		//  Pack log records on PVOID boundaries to avoid alignment faults when accessing 
        //  the packed buffer on 64-bit architectures
        // 

        logRecordLength = ROUND_TO_SIZE( pLogRecord->Length, sizeof( PVOID ) );

        if (length < logRecordLength) {

            InsertHeadList( &gOutputBufferList, pList );
            break;
        }

        KeReleaseSpinLock( &gOutputBufferLock, oldIrql );

        //
        //  We wrap these logic in a try/finally because it is possible that our
        //  output buffer is invalid if we are coming through the FastIO path to
        //  service the FILESPY_GetLog IOCTLs.  If this is the case, the 
        //  exception will be caught in SpyFastIoDeviceControl, but we want to 
        //  make sure that we don't lose this current record we are dealing
        //  with.
        //
        
        try {

            //
            //  Copy of course the non-padded number of bytes
            //

            RtlCopyMemory( pOutBuffer, pLogRecord, pLogRecord->Length );

            //
            //  Adjust the log-record length to the padded length in the copied record 
            //

            ((PLOG_RECORD) pOutBuffer)->Length = logRecordLength;

            IoStatus->Information += logRecordLength;
           
            length -= logRecordLength;

            pOutBuffer += logRecordLength;

            SpyFreeRecord( pRecordList );
            pRecordList = NULL;
            
        } finally {

            if (pRecordList != NULL) {

                //
                //  We did not successfully process this record, so put it back
                //  on the gOutputBufferList.  The log records contain a sequence
                //  number, so the fact that this may disrupt the ordering of the
                //  log records is not a problem.
                //

                KeAcquireSpinLock( &gOutputBufferLock, &oldIrql );
                InsertHeadList( &gOutputBufferList, &pRecordList->List );
                KeReleaseSpinLock( &gOutputBufferLock, oldIrql );
            }
        }

        KeAcquireSpinLock( &gOutputBufferLock, &oldIrql );
    }

    KeReleaseSpinLock( &gOutputBufferLock, oldIrql );

	//
    // no copies occurred
	//

    if (length == OutputBufferLength && recordsAvailable > 0) {

        IoStatus->Status = STATUS_BUFFER_TOO_SMALL;
    }

    return;
}

VOID
SpyCloseControlDevice (
    )
/*++

Routine Description:

    This is the routine that is associated with IRP_MJ_
    This routine does the cleanup involved in closing the ControlDevice.
    On the close of the Control Device, we need to empty the queue of
    logRecords that are waiting to be returned to the user.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PLIST_ENTRY pList;
    PRECORD_LIST pRecordList;
    KIRQL oldIrql;

    //
    // Set the gControlDeviceState to CLEANING_UP so that we can
    // signal that we are cleaning up the device.
    //

    KeAcquireSpinLock( &gControlDeviceStateLock, &oldIrql );
    gControlDeviceState = CLEANING_UP;
    KeReleaseSpinLock( &gControlDeviceStateLock, oldIrql );

    KeAcquireSpinLock( &gOutputBufferLock, &oldIrql );

    while (!IsListEmpty( &gOutputBufferList )) {

        pList = RemoveHeadList( &gOutputBufferList );

        KeReleaseSpinLock( &gOutputBufferLock, oldIrql );

        pRecordList = CONTAINING_RECORD( pList, RECORD_LIST, List );

        SpyFreeRecord( pRecordList );

        KeAcquireSpinLock( &gOutputBufferLock, &oldIrql );
    }

    KeReleaseSpinLock( &gOutputBufferLock, oldIrql );

    SpyNameDeleteAllNames();

    //
    // All the cleanup is done, so set the gControlDeviceState
    // to CLOSED.
    //

    KeAcquireSpinLock( &gControlDeviceStateLock, &oldIrql );
    gControlDeviceState = CLOSED;
    KeReleaseSpinLock( &gControlDeviceStateLock, oldIrql );
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//               Device name tracking helper routines                 //
//                                                                    //
////////////////////////////////////////////////////////////////////////

VOID
SpyGetObjectName (
    IN PVOID Object,
    IN OUT PUNICODE_STRING Name
    )
/*++

Routine Description:

    This routine will return the name of the given object.
    If a name can not be found an empty string will be returned.

Arguments:

    Object - The object whose name we want

    Name - A unicode string that is already initialized with a buffer

Return Value:

    None

--*/
{
    NTSTATUS status;
    CHAR nibuf[512];        //buffer that receives NAME information and name
    POBJECT_NAME_INFORMATION nameInfo = (POBJECT_NAME_INFORMATION)nibuf;
    ULONG retLength;

    PAGED_CODE();

    status = ObQueryNameString( Object, 
                                nameInfo, 
                                sizeof(nibuf), 
                                &retLength );

    //
    //  Init current length, if we have an error a NULL string will be returned
    //

    Name->Length = 0;

    if (NT_SUCCESS( status )) {

        //
        //  Copy what we can of the name string
        //

        RtlCopyUnicodeString( Name, &nameInfo->Name );
    }
}

//
//  VERSION NOTE:
//
//  This helper routine is only needed when enumerating all volumes in the
//  system, which is only supported on Windows XP and later.
//

#if WINVER >= 0x0501

VOID
SpyGetBaseDeviceObjectName (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
    )
/*++

Routine Description:

    This locates the base device object in the given attachment chain and then
    returns the name of that object.

    If no name can be found, an empty string is returned.

Arguments:

    Object - The object whose name we want

    Name - A unicode string that is already initialized with a buffer

Return Value:

    None

--*/
{
    PAGED_CODE();
    
    //
    //  Get the base file system device object
    //

    ASSERT( NULL != gSpyDynamicFunctions.GetDeviceAttachmentBaseRef );
    DeviceObject = (gSpyDynamicFunctions.GetDeviceAttachmentBaseRef)( DeviceObject );

    //
    //  Get the name of that object
    //

    SpyGetObjectName( DeviceObject, Name );

    //
    //  Remove the reference added by IoGetDeviceAttachmentBaseRef
    //

    ObDereferenceObject( DeviceObject );
}

#endif

BOOLEAN
SpyFindSubString (
    IN PUNICODE_STRING String,
    IN PUNICODE_STRING SubString
    )
/*++

Routine Description:
    This routine looks to see if SubString is a substring of String.

Arguments:
    String - the string to search in
    SubString - the substring to find in String

Return Value:
    Returns TRUE if the substring is found in string and FALSE otherwise.
    
--*/
{
    ULONG index;

    //
    //  First, check to see if the strings are equal.
    //

    if (RtlEqualUnicodeString( String, SubString, TRUE )) {

        return TRUE;
    }

    //
    //  String and SubString aren't equal, so now see if SubString
    //  is in String any where.
    //

    for (index = 0;
         index + SubString->Length <= String->Length;
         index++) {

        if (_wcsnicmp( &String->Buffer[index], SubString->Buffer, SubString->Length ) == 0) {

            //
            //  SubString is found in String, so return TRUE.
            //
            
            return TRUE;
        }
    }

    return FALSE;
}

VOID
SpyStoreUserName (
    IN PFILESPY_DEVICE_EXTENSION devExt,
    IN PUNICODE_STRING UserName
    )
/*++

Routine Description:

    Stores the current device name in the device extension.  If
    this name is already in the device name list of this extension,
    it will not be added.  If there is already a name for this device, 
    the new device name is appended to the DeviceName in the device extension.
    
Arguments:

    devExt - The device extension that will store the
        device name.

    UserName - The device name as specified by the user to be stored.

Return Value:

    None

--*/
{
    //
    //  See if this UserName is already in the list of user names filespy
    //  keeps in its device extension.  If not, add it to the list.
    //

    if (!SpyFindSubString( &devExt->UserNames, UserName )) {

        //
        //  We didn't find this name in the list, so if there are no names 
        //  in the UserNames list, just append UserName.  Otherwise, append a
        //  delimiter then append UserName.
        //

        if (devExt->UserNames.Length == 0) {

            RtlAppendUnicodeStringToString( &devExt->UserNames, UserName );

        } else {

            RtlAppendUnicodeToString( &devExt->UserNames, L", " );
            RtlAppendUnicodeStringToString( &devExt->UserNames, UserName );
        }
    }

    //
    //  See if this UserName is already in the list of device names filespy
    //  keeps in its device extension.  If not, add it to the list.
    //

    if (!SpyFindSubString( &devExt->DeviceName, UserName )) {

        //
        //  We didn't find this name in the list, so if there are no names 
        //  in the UserNames list, just append UserName.  Otherwise, append a
        //  delimiter then append UserName.
        //

        if (devExt->DeviceName.Length == 0) {

            RtlAppendUnicodeStringToString( &devExt->DeviceName, UserName );

        } else {

            RtlAppendUnicodeToString( &devExt->DeviceName, L", " );
            RtlAppendUnicodeStringToString( &devExt->DeviceName, UserName );
        }
    }
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                        Debug support routines                      //
//                                                                    //
////////////////////////////////////////////////////////////////////////

VOID
SpyDumpIrpOperation (
    IN BOOLEAN InOriginatingPath,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is for debugging and prints out a string to the
    debugger specifying what Irp operation is being seen.
    
Arguments:

    InOriginatingPath - TRUE if we are in the originating path
        for the IRP, FALSE if in the completion path.

    Irp - The IRP for this operation.
        
Return Value:

    None.
    
--*/
{
    CHAR irpMajorString[OPERATION_NAME_BUFFER_SIZE];
    CHAR irpMinorString[OPERATION_NAME_BUFFER_SIZE];
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );

    GetIrpName(irpSp->MajorFunction,
               irpSp->MinorFunction,
               irpSp->Parameters.FileSystemControl.FsControlCode,
               irpMajorString,irpMinorString);


    if (InOriginatingPath) {

        DbgPrint( "FILESPY: Irp preoperation for %s %s\n", irpMajorString, irpMinorString );
            
    } else {
    
        DbgPrint( "FILESPY: Irp postoperation for %s %s\n", irpMajorString, irpMinorString );
    }
}

VOID
SpyDumpFastIoOperation (
    IN BOOLEAN InPreOperation,
    IN FASTIO_TYPE FastIoOperation
    )
/*++

Routine Description:

    This routine is for debugging and prints out a string to the
    debugger specifying what FsFilter operation is being seen.
    
Arguments:

    InPreOperation - TRUE if we have not called down to the next
        device in the stack, FALSE otherwise.

    FastIoOperation - The code for the Fast Io operation.
    
Return Value:

    None.
    
--*/
{
    CHAR operationString[OPERATION_NAME_BUFFER_SIZE];

    GetFastioName(FastIoOperation,
               operationString);


    if (InPreOperation) {
    
        DbgPrint( "FILESPY: Fast IO preOperation for %s\n", operationString );

    } else {

        DbgPrint( "FILESPY: Fast IO postOperation for %s\n", operationString );
    }
}

#if WINVER >= 0x0501 /* See comment in DriverEntry */

VOID
SpyDumpFsFilterOperation (
    IN BOOLEAN InPreOperationCallback,
    IN PFS_FILTER_CALLBACK_DATA Data
    )
/*++

Routine Description:

    This routine is for debugging and prints out a string to the
    debugger specifying what FsFilter operation is being seen.
    
Arguments:

    InPreOperationCallback - TRUE if we are in a preOperation 
        callback, FALSE otherwise.

    Data - The FS_FILTER_CALLBACK_DATA structure for this
        operation.
        
Return Value:

    None.
    
--*/
{
    CHAR operationString[OPERATION_NAME_BUFFER_SIZE];


    GetFsFilterOperationName(Data->Operation,operationString);

    if (InPreOperationCallback) {
    
        DbgPrint( "FILESPY: FsFilter preOperation for %s\n", operationString );

    } else {

        DbgPrint( "FILESPY: FsFilter postOperation for %s\n", operationString );
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\filter\filespy.h ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    filespy.h

Abstract:

    Header file which contains the structures, type definitions,
    and constants that are shared between the kernel mode driver, 
    filespy.sys, and the user mode executable, filespy.exe.

Environment:

    Kernel mode

// @@BEGIN_DDKSPLIT

Author:

    George Jenkins (georgeje) 6-Jan-1999
    Neal Christiansen (nealch)
    Molly Brown (mollybro)  

Revision History:

    Neal Christiansen (nealch)     06-Jul-2001
        Modified to use Stream Contexts to track names

    Ravisankar Pudipeddi (ravisp)  07-May-2002
        Make it work on IA64

// @@END_DDKSPLIT
--*/
#ifndef __FILESPY_H__
#define __FILESPY_H__

#include "filespyLib.h"


//
//  Enable these warnings in the code.
//

#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4101)   // Unreferenced local variable


#define FILESPY_Reset              (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x00, METHOD_BUFFERED, FILE_WRITE_ACCESS )
#define FILESPY_StartLoggingDevice (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x01, METHOD_BUFFERED, FILE_READ_ACCESS )
#define FILESPY_StopLoggingDevice  (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x02, METHOD_BUFFERED, FILE_READ_ACCESS )
#define FILESPY_GetLog             (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x03, METHOD_BUFFERED, FILE_READ_ACCESS )
#define FILESPY_GetVer             (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x04, METHOD_BUFFERED, FILE_READ_ACCESS )
#define FILESPY_ListDevices        (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x05, METHOD_BUFFERED, FILE_READ_ACCESS )
#define FILESPY_GetStats           (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x06, METHOD_BUFFERED, FILE_READ_ACCESS )

#define FILESPY_DRIVER_NAME      L"FILESPY.SYS"
#define FILESPY_DEVICE_NAME      L"FileSpy"
#define FILESPY_W32_DEVICE_NAME  L"\\\\.\\FileSpy"
#define FILESPY_DOSDEVICE_NAME   L"\\DosDevices\\FileSpy"
#define FILESPY_FULLDEVICE_NAME1 L"\\FileSystem\\Filters\\FileSpy"
#define FILESPY_FULLDEVICE_NAME2 L"\\FileSystem\\FileSpyCDO"

    
#define FILESPY_MAJ_VERSION 1
#define FILESPY_MIN_VERSION 0

#ifndef ROUND_TO_SIZE
#define ROUND_TO_SIZE(_length, _alignment)    \
            (((_length) + ((_alignment)-1)) & ~((_alignment) - 1))
#endif 

typedef struct _FILESPYVER {
    USHORT Major;
    USHORT Minor;
} FILESPYVER, *PFILESPYVER;

typedef ULONG_PTR FILE_ID;        //  To allow passing up PFILE_OBJECT as 
                                  //     unique file identifier in user-mode
typedef ULONG_PTR DEVICE_ID;      //  To allow passing up PDEVICE_OBJECT as
                                  //     unique device identifier in user-mode
typedef LONG NTSTATUS;            //  To allow status values to be passed up 
                                  //     to user-mode

//
//  This is set to the number of characters we want to allow the 
//  device extension to store for the various names used to identify
//  a device object.
//

#define DEVICE_NAMES_SZ  100

//
//  An array of these structures are returned when the attached device list is
//  returned.
//

typedef struct _ATTACHED_DEVICE {
    BOOLEAN LoggingOn;
    WCHAR DeviceNames[DEVICE_NAMES_SZ];
} ATTACHED_DEVICE, *PATTACHED_DEVICE;

#define MAX_BUFFERS     100

//
//  Attach modes for the filespy kernel driver
//

#define FILESPY_ATTACH_ON_DEMAND    1   
    //  Filespy will only attach to a volume when a user asks to start logging 
    //  that volume.
                                        
#define FILESPY_ATTACH_ALL_VOLUMES  2   
    //  VERSION NOTE:
    //  
    //  On Windows 2000, Filespy will attach to all volumes in the system that
    //  it sees mount but not turn on logging until requested to through the
    //  filespy user application.  Therefore, if filespy is set to mount on 
    //  demand, it will miss the mounting of the local volumes at boot time.  
    //  If filespy is set to load at boot time, it will see all the local 
    //  volumes be mounted and attach.  This can be beneficial if you want
    //  filespy to attach low in the device stack.
    //
    //  On Windows XP and later, Filespy will attach to all volumes in the
    //  system when it is loaded and all volumes that mount after Filespy is
    //  loaded.  Again, logging on these volumes will not be turned on until 
    //  the user asks it to be.
    //
                                        
//
//  Record types field definitions
//

typedef enum _RECORD_TYPE_FLAGS {

    RECORD_TYPE_STATIC                  = 0x80000000,
    RECORD_TYPE_NORMAL                  = 0x00000000,

    RECORD_TYPE_IRP                     = 0x00000001,
    RECORD_TYPE_FASTIO                  = 0x00000002,
#if WINVER >= 0x0501    
    RECORD_TYPE_FS_FILTER_OP            = 0x00000003,
#endif    

    RECORD_TYPE_OUT_OF_MEMORY           = 0x10000000,
    RECORD_TYPE_EXCEED_MEMORY_ALLOWANCE = 0x20000000

} RECORD_TYPE_FLAGS;

//
//  Macro to return the lower portion of RecordType
//

#define GET_RECORD_TYPE(pLogRecord) ((pLogRecord)->RecordType & 0x0000FFFF)

//
//  Structure defining the information recorded for an IRP operation
//

typedef struct _RECORD_IRP {

    LARGE_INTEGER OriginatingTime; //  The time the IRP originated
    LARGE_INTEGER CompletionTime;  //  The time the IRP was completed

    UCHAR IrpMajor;                //  From _IO_STACK_LOCATION
    UCHAR IrpMinor;                //  From _IO_STACK_LOCATION
    ULONG IrpFlags;                //  From _IRP (no cache, paging i/o, sync. 
                                   //  api, assoc. irp, buffered i/o, etc.)                   
    FILE_ID FileObject;            //  From _IO_STACK_LOCATION (This is the 
                                   //     PFILE_OBJECT, but this isn't 
                                   //     available in user-mode)
    DEVICE_ID DeviceObject;        //  From _IO_STACK_LOCATION (This is the 
                                   //     PDEVICE_OBJECT, but this isn't 
                                   //     available in user-mode)
    NTSTATUS ReturnStatus;         //  From _IRP->IoStatus.Status
    ULONG_PTR ReturnInformation;   //  From _IRP->IoStatus.Information
    FILE_ID ProcessId;
    FILE_ID ThreadId;
    
    //
    //  These fields are only filled in the appropriate
    //  Verbose mode.
    //
    
    PVOID Argument1;               //  
    PVOID Argument2;               //  Current IrpStackLocation
    PVOID Argument3;               //  Parameters
    PVOID Argument4;               //  
    ACCESS_MASK DesiredAccess;     //  Only used for CREATE irps

} RECORD_IRP, *PRECORD_IRP;

//
//  Structure defining the information recorded for a Fast IO operation
//

typedef struct _RECORD_FASTIO {

    LARGE_INTEGER StartTime;     //  Time Fast I/O request begins processing
    LARGE_INTEGER CompletionTime;//  Time Fast I/O request completes processing
    LARGE_INTEGER FileOffset;    //  Offset into the file for the I/O
    
    FILE_ID FileObject;          //  Parameter to FASTIO call
    DEVICE_ID DeviceObject;      //  Parameter to FASTIO call

    FILE_ID ProcessId;
    FILE_ID ThreadId;

    FASTIO_TYPE Type;            //  Type of FASTIO operation
    ULONG Length;                //  The length of data for the I/O operation

    NTSTATUS ReturnStatus;       //  From IO_STATUS_BLOCK

    BOOLEAN Wait;                //  Parameter to most FASTIO calls, signifies 
                                 //  if this operation can wait

} RECORD_FASTIO, *PRECORD_FASTIO;

#if WINVER >= 0x0501

//
//  Structure defining the information recorded for FsFilter operations
//

typedef struct _RECORD_FS_FILTER_OPERATION {

    LARGE_INTEGER OriginatingTime;
    LARGE_INTEGER CompletionTime;

    FILE_ID FileObject;
    DEVICE_ID DeviceObject;

    FILE_ID ProcessId;
    FILE_ID ThreadId;
    
    NTSTATUS ReturnStatus;

    UCHAR FsFilterOperation;

} RECORD_FS_FILTER_OPERATION, *PRECORD_FS_FILTER_OPERATION;

#endif

//
//  The three types of records that are possible.
//

typedef union _RECORD_IO {

    RECORD_IRP RecordIrp;
    RECORD_FASTIO RecordFastIo;
#if WINVER >= 0x0501   
    RECORD_FS_FILTER_OPERATION RecordFsFilterOp;
#endif

} RECORD_IO, *PRECORD_IO;


//
//  Log record structure defines the additional information needed for
//  managing the processing of the each IO FileSpy monitors.
//

typedef struct _LOG_RECORD {

    ULONG Length;           //  Length of record including header 
    ULONG SequenceNumber;
    RECORD_TYPE_FLAGS RecordType;
    RECORD_IO Record;
    WCHAR Name[0];          //  The name starts here

} LOG_RECORD, *PLOG_RECORD;


#define SIZE_OF_LOG_RECORD  (sizeof( LOG_RECORD )) 


//
//  This is the in-memory structure used to track log records.
//

typedef enum _RECORD_LIST_FLAGS {

    //
    //  If set, we want to sync this operation back to the dispatch routine
    //

    RLFL_SYNC_TO_DISPATCH       = 0x00000001,

    //
    //  During some operations (like rename) we need to know if the file is
    //  a file or directory.
    //

    RLFL_IS_DIRECTORY           = 0x00000002

} RECORD_LIST_FLAGS;

typedef struct _RECORD_LIST {

    LIST_ENTRY List;
    PVOID NewContext;
    PVOID WaitEvent;
    RECORD_LIST_FLAGS Flags;
    LOG_RECORD LogRecord;

} RECORD_LIST, *PRECORD_LIST;

#define SIZE_OF_RECORD_LIST (sizeof( RECORD_LIST ))

//
//  The statistics that are kept on the file name hash table
//  to monitor its efficiency.
//

typedef struct _FILESPY_STATISTICS {

    ULONG   TotalContextSearches;
    ULONG   TotalContextFound;
    ULONG   TotalContextCreated;
    ULONG   TotalContextTemporary;
    ULONG   TotalContextDuplicateFrees;
    ULONG   TotalContextCtxCallbackFrees;
    ULONG   TotalContextNonDeferredFrees;
    ULONG   TotalContextDeferredFrees;
    ULONG   TotalContextDeleteAlls;
    ULONG   TotalContextsNotSupported;
    ULONG   TotalContextsNotFoundInStreamList;

} FILESPY_STATISTICS, *PFILESPY_STATISTICS;

//
//  Maximum name length definitions
//

#ifndef MAX_PATH
#define MAX_PATH        384
#endif

#define MAX_NAME_SPACE  (MAX_PATH*sizeof(WCHAR))

//
//  Size of the actual records with the name built in.
//

#define RECORD_SIZE     (SIZE_OF_RECORD_LIST + MAX_NAME_SPACE)

#endif /* __FILESPY_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\fspykd\fspykd.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    FilmonKd.c

Abstract:

    KD Extension Api for examining FileSpy specific data structures.

    Note: While this extension can only build in the Windows XP and Server 2003
    environments, it can still be used to debug a version of this FileSpy
    sample built for Windows 2000.

// @@BEGIN_DDKSPLIT

Author:

    Molly Brown [MollyBro]    29-Apr-99

Revision History:

    Port to platform independent - 

                        Ravisankar Pudipeddi [ravisp] 3-March-01


// @@END_DDKSPLIT

Environment:

    User Mode.


--*/

#include "pch.h"

//
// Windows.h doesn't include this definition
//
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR Buffer;
} UNICODE_STRING, *PUNICODE_STRING;


#ifndef MAX
    #define MAX(a,b) (((a) > (b))?(a):(b))
#endif

/****************************************************************************
  Typedefs and constants
****************************************************************************/
typedef PVOID (*PSTRUCT_DUMP_ROUTINE)(
    IN ULONG64 Address,
    IN LONG Options,
    USHORT Processor,
    HANDLE hCurrentThread
    );

//
// The help strings printed out
//

static LPSTR Extensions[] = {
    "FileSpy Debugger Extensions:\n",
    "attachments [1|2]                  Dump all the devices FileSpy is attached to ",
    "devext      [address] [1|2]        Dump FileSpy device extension",
    "filenames   [1|2]                  Dumps all the file names cached",
    0
};


/******************************************************************************
    Function prototypes
******************************************************************************/
VOID
PrintHelp (
    VOID
    );

/******************************************************************************
    Useful macros
******************************************************************************/

#define xGetFieldValue(Address, Type, Field, Value)                         \
     {                                                                      \
        if (GetFieldValue(Address, Type, Field, Value)) {                   \
            dprintf("\nCould not read field %s of %s from address: %08p\n", \
                    (Field), (Type), (Address));                            \
            return;                                                         \
        }                                                                   \
     }
       
#define xGetFieldOffset(Type, Field, Offset)                                \
     {                                                                      \
        if (GetFieldOffset(Type, Field, Offset)) {                          \
            dprintf("\nCould not read offset of field %s from type %s\n",   \
                    (Field), (Type));                                       \
            return;                                                         \
        }                                                                   \
     }
   

/*++

/****************************************************************************
  Entry points, parameter parsers, etc. below
****************************************************************************/
VOID
DumpDeviceExtension (
    IN ULONG64 Address,
    IN LONG      Options,
    USHORT Processor,
    HANDLE hCurrentThread
    )

/*++

Routine Description:

    Dump a specific device extension.

Arguments:

    Address - Gives the address of the device extension to dump

Return Value:

    None

--*/

{
    ULONG64 pointer, pName;
    UNICODE_STRING string1, string2;
    PUCHAR  buffer;
    USHORT  length;
    ULONG   offset, offset2;
    ULONG   result;
    BOOLEAN boolean;


    UNREFERENCED_PARAMETER( Processor );
    UNREFERENCED_PARAMETER( hCurrentThread );

    dprintf( "\nFileSpy device extension: %08p", Address );


    //
    //  Dump the interesting parts of the device extension
    //
    if (Options <= 1) {
        //
        // Get the device name length
        //
        xGetFieldValue(Address, "FileSpy!_FILESPY_DEVICE_EXTENSION", "DeviceNames.Length", length);

        // Get offset, and addres of string
        //
        xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "DeviceNamesBuffer", &offset);
        pName = Address+offset;

        //
        // Allocate buffer to hold string.
        // We should not call any xGet* macros before freeing the buffer
        // as they might just return from the function on failure
        //
        buffer = LocalAlloc(LPTR, length);
                                 
        if (buffer == NULL) {
            return;
        }
        //
        // Read in the string: assuming it's NULL terminated here..
        //
        if (ReadMemory(pName,
                       buffer,
                       (ULONG) length,
                       &result) && (result == (ULONG) length)) {

            string1.Length = string1.MaximumLength = length;
            string1.Buffer = (PWSTR) buffer;

            dprintf( "\n\t(%3x) %s %wZ",
                      offset,
                      "DeviceNames                       ",
                      &string1);
        }
        //
        // Free the buffer
        //
        LocalFree(buffer);
        buffer = NULL;
        
        xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "LogThisDevice", &offset);
        xGetFieldValue(Address, "FileSpy!_FILESPY_DEVICE_EXTENSION", "LogThisDevice", boolean);

        dprintf( "\n\t(%3x) %s %s",
                 offset,
                 "LogThisDevice                     ",
                 (boolean ? "TRUE" : "FALSE") );
        

    } else if (Options == 2) {
        dprintf( "\n\t(OFF) %s",
                 "FIELD NAME                         VALUE");
        dprintf( "\n\t%s",
                 "----------------------------------------------");

        xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "AttachedToDeviceObject", &offset);
        xGetFieldValue(Address, "FileSpy!_FILESPY_DEVICE_EXTENSION", "AttachedToDeviceObject", pointer);
        dprintf( "\n\t(%3x) %s %08p",
                 offset,
                 "AttachedToDeviceObject            ",
                 pointer);

        xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "DiskDeviceObject", &offset);
        xGetFieldValue(Address, "FileSpy!_FILESPY_DEVICE_EXTENSION", "DiskDeviceObject", pointer);
        dprintf( "\n\t(%3x) %s %08p",
                 offset,
                 "DiskDeviceObject                  ",
                 pointer);

        xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "LogThisDevice", &offset);
        xGetFieldValue(Address, "FileSpy!_FILESPY_DEVICE_EXTENSION", "LogThisDevice", boolean);
        dprintf( "\n\t(%3x) %s %s",
                 offset,
                 "LogThisDevice                     ",
                 (boolean ? "TRUE" : "FALSE") );

        xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "DeviceNames.Length", &offset);
        xGetFieldValue(Address, "FileSpy!_FILESPY_DEVICE_EXTENSION", "DeviceNames.Length", length);
        dprintf( "\n\t(%3x) %s %04x",
                 offset,
                 "DeviceNames.Length(bytes)         ",
                 length);
        //
        // Save buffersize, since we need it later to print the string
        //
        string1.Length = string1.MaximumLength = length;
                 
        xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "DeviceNames.MaximumLength", &offset);
        xGetFieldValue(Address, "FileSpy!_FILESPY_DEVICE_EXTENSION", "DeviceNames.MaximumLength", length);
        dprintf( "\n\t(%3x) %s %04x",
                 offset,
                 "DeviceNames.MaximumLength(bytes)  ",
                 length);

        xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "DeviceNames.Buffer", &offset);
        xGetFieldValue(Address, "FileSpy!_FILESPY_DEVICE_EXTENSION", "DeviceNames.Buffer", pointer);
        dprintf( "\n\t(%3x) %s %08p",
                 offset,
                 "DeviceNames.Buffer                ",
                 pointer);

        
        xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "UserNames.Length", &offset);
        xGetFieldValue(Address, "FileSpy!_FILESPY_DEVICE_EXTENSION", "UserNames.Length", length);
        dprintf( "\n\t(%3x) %s %04x",
                 offset,
                 "UserNames.Length(bytes)           ",
                 length);

        //
        // Update size of buffer needed 
        //
        string2.Length = string2.MaximumLength = length;

        xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "UserNames.MaximumLength", &offset);
        xGetFieldValue(Address, "FileSpy!_FILESPY_DEVICE_EXTENSION", "UserNames.MaximumLength", length);
        dprintf( "\n\t(%3x) %s %04x",
                 offset,
                 "UserNames.MaximumLength(bytes)    ",
                 length);

        xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "UserNames.Buffer", &offset);
        xGetFieldValue(Address, "FileSpy!_FILESPY_DEVICE_EXTENSION", "UserNames.Buffer", pointer);
        dprintf( "\n\t(%3x) %s %08p",
                 offset,
                 "UserNames.Buffer                  ",
                 pointer);

        
        //
        // Get the device names buffer offset
        //
        xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "DeviceNamesBuffer", &offset);
        pName = Address+offset;

        //
        // Get the user names buffer offset
        //
        xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "UserNamesBuffer", &offset2);

        //
        // Allocate buffer large enough to hold the largest string
        // we will serialize access to it
        //
        buffer = LocalAlloc(LPTR, MAX(string1.MaximumLength,
                                      string2.MaximumLength));
        if (buffer == NULL) {
            return;
        }

        string1.Buffer = string2.Buffer = (PWSTR) buffer;

        if (ReadMemory(pName,
                       buffer,
                       string1.Length,
                       &result) && (result == string1.Length)) {

            dprintf( "\n\t(%3x) %s %wZ",
                      offset,
                      "DeviceNames                       ",
                      &string1);
        }

        pName = Address+offset2;
        if (ReadMemory(pName,
                       buffer,
                       string2.Length,
                       &result) && (result == string2.Length)) {

            dprintf( "\n\t(%3x) %s %wZ",
                      offset2,
                      "UserNames                         ",
                      &string2);
        }

        LocalFree(buffer);
        buffer = NULL;

    } else {
        dprintf ("\nNot a valid option");
    }
    dprintf( "\n" );
}


VOID
DumpAttachments (
    IN LONG Options,
    USHORT Processor,
    HANDLE hCurrentThread
    )
/*++

Routine Description:

    Dump the list of attached devices that is global to FileSpy.

Arguments:

    Options - Ignored for now

Return Value:

    None

--*/
{
    ULONG64 address, next;
    ULONG64 deviceExtensionAddress;
    ULONG linkOffset;

    UNREFERENCED_PARAMETER( Processor );
    UNREFERENCED_PARAMETER( hCurrentThread );

    address = GetExpression( "FileSpy!gSpyDeviceExtensionList" );

    dprintf( "\nAttachedDeviceList: %08p", address );


    //
    // Establish offset of the linking entry..
    //
    xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "NextFileSpyDeviceLink", &linkOffset);
    xGetFieldValue(address, "nt!_LIST_ENTRY", "Flink", next);

    while (next != address) {

        deviceExtensionAddress =  (next - linkOffset);
            // i.e., CONTAINING_RECORD( next, _FILESPY_DEVICE_EXTENSION, NextFileSpyDeviceLink );

        DumpDeviceExtension( 
            deviceExtensionAddress, 
            Options,
            Processor, 
            hCurrentThread );

        if (CheckControlC()) {
            return;
        }

        xGetFieldValue(next, "nt!_LIST_ENTRY", "Flink", next);
    }
}

VOID
DumpFileNameCache (
    IN LONG Options,
    USHORT  Processor,
    HANDLE  hCurrentThread
)
/*++

Routine Description:

    Dump all the fileObjects and file names that are currently in the
    file name cache

Arguments:

    Options - 1 dumps just the file objects and file names
              2 dumps the hash bucket labels along with the file objects
                and file names

Return Value:

    None

--*/
{
    ULONG64      address;
    ULONG64      next;
    ULONG64      pName;
    ULONG64      fileObject;
    ULONG64      pHashEntry;
    ULONG        length;
    ULONG        result;
    ULONG        linkOffset;
    UNICODE_STRING string;
    LIST_ENTRY64  listEntry;
    PUCHAR       buffer;
    INT         i;
    ULONG       nameCount = 0;

    UNREFERENCED_PARAMETER( Processor );
    UNREFERENCED_PARAMETER( hCurrentThread );

    address = GetExpression( "FileSpy!gHashTable" );
    dprintf( "\nHashTable: %08p\n", address);

    dprintf( "  FileObject  Length  FileName\n" );
    dprintf( "  -----------------------------------------\n" );

    xGetFieldOffset("FileSpy!_HASH_ENTRY", "List", &linkOffset);

    for (i=0; i < HASH_SIZE; i++) {

        if (!ReadListEntry(address, &listEntry)) {
            dprintf("Can't read hash table\n");
            return;
        }

        if (Options > 1) {
            dprintf ("Hash Bucket[%3d]\n", i);
        }

        next = listEntry.Flink;

        while (next != address) {

            pHashEntry =  next - linkOffset;// CONTAINING_RECORD( next, HASH_ENTRY, List );

            xGetFieldValue(pHashEntry, "FileSpy!_HASH_ENTRY", "FileObject", fileObject);
            xGetFieldValue(pHashEntry, "FileSpy!_HASH_ENTRY", "Name.Length", length);

            //
            // Get the names buffer pointer
            //
            xGetFieldValue(pHashEntry, "FileSpy!_HASH_ENTRY", "Name.Buffer", pName);
            //
            // Allocate buffer to hold the string
            //
            buffer = LocalAlloc(LPTR, length);
            if (buffer != NULL) {
                string.MaximumLength = string.Length = (USHORT) length;
                string.Buffer = (PWSTR) buffer;
                if (ReadMemory(pName,
                               buffer,
                               length,
                               &result) && (result == length)) {
                    dprintf (
                        "  %08p    %4d    %wZ\n", 
                        fileObject, 
                        length/sizeof(WCHAR),
                        &string);

                }
                //
                // Free the buffer
                //
                LocalFree(buffer);
                buffer = NULL;
            } else {
                dprintf("\nCould not allocate buffer to hold filename\n");
            }

            nameCount ++;

            if (CheckControlC()) {
                dprintf("%u Names in cache\n", nameCount);
                return;
            }
            
            if (!ReadListEntry(next, &listEntry)) {
                dprintf("Can't read hash table\n");
                return;
            }

            next = listEntry.Flink;
        }
        //
        // Advance address to next hash entry
        //
        if (IsPtr64()) {
            address += sizeof(LIST_ENTRY64);
        } else {
            address += sizeof(LIST_ENTRY);
        }
    }
    dprintf("%u Names in cache\n", nameCount);
}



VOID
ParseAndDump (
    IN PCSTR args,
    IN PSTRUCT_DUMP_ROUTINE DumpFunction,
    USHORT Processor,
    HANDLE hCurrentThread
    )

/*++

Routine Description:

    Parse command line arguments and dump an ntfs structure.

Arguments:

    Args - String of arguments to parse.

    DumpFunction - Function to call with parsed arguments.

Return Value:

    None

--*/

{
    UCHAR StringStructToDump[1024];  // See other kd routines for size
    ULONG64 StructToDump = 0;
    LONG Options = 0;

    //
    //  If the caller specified an address then that's the item we dump
    //
    if (args) {
       StructToDump = 0;
       Options = 0;

       StringStructToDump[0] = '\0';

        (VOID) sscanf(args,"%s %lx", StringStructToDump, &Options );

       StructToDump = GetExpression( StringStructToDump );

       if (StructToDump == 0){
         dprintf("unable to get expression %s\n",StringStructToDump);
         return;
       }

       (*DumpFunction) ( StructToDump, Options, Processor, hCurrentThread );

       dprintf( "\n" );
    } else {
       PrintHelp();
    }
}


VOID
PrintHelp (
    VOID
    )
/*++

Routine Description:

    Dump out one line of help for each DECLARE_API

Arguments:

    None

Return Value:

    None

--*/
{
    int i;

    for( i=0; Extensions[i]; i++ )
        dprintf( "   %s\n", Extensions[i] );
}


DECLARE_API( devext )

/*++

Routine Description:

    Dump device extension struct

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    ParseAndDump( 
        args, 
        (PSTRUCT_DUMP_ROUTINE) DumpDeviceExtension, 
        (USHORT)dwProcessor, 
        hCurrentThread );
}

DECLARE_API( attachments )

/*++

Routine Description:

    Dumps the list of devices we are currently attached to

Arguments:

    arg - [options]

Return Value:

    None

--*/

{
    LONG options = 0;
    
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentProcess );
    
    (VOID)sscanf(args,"%lx", &options );
    
    DumpAttachments( options, (USHORT)dwProcessor, hCurrentThread );
    
    dprintf( "\n" );
}

DECLARE_API( filenames )

/*++

Routine Description:

    Dumps all the entries in the file name cache

Arguments:

    arg - 

Return Value:

    None

--*/

{
    LONG options = 0;
    
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentProcess );
    
    (VOID)sscanf(args,"%lx", &options );

    DumpFileNameCache(options, (USHORT)dwProcessor, hCurrentThread );
    
}


DECLARE_API( help )

/*++

Routine Description:

    Dump the help for this debugger extension module.

Arguments:

    arg - None

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER( args );
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentProcess );
    UNREFERENCED_PARAMETER( hCurrentThread );
    UNREFERENCED_PARAMETER( dwProcessor );

    PrintHelp();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\fspykd\kdext.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdext.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.
// @@BEGIN_DDKSPLIT

Author:

    Wesley Witt (wesw) 26-Aug-1993
    Ravisankar Pudipeddi [ravisp] 3-March-01 (moved to filespy)

// @@END_DDKSPLIT

Environment:

    User Mode

--*/

#include "pch.h"
#pragma hdrstop

#include <ntverp.h>

//
// globals
//

EXT_API_VERSION        ApiVersion = { 6, 0, EXT_API_VERSION_NUMBER64, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
ULONG                  STeip;
ULONG                  STebp;
ULONG                  STesp;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;



DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    UNREFERENCED_PARAMETER( hModule );
    UNREFERENCED_PARAMETER( dwReserved );

    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    UNREFERENCED_PARAMETER( args );
    UNREFERENCED_PARAMETER( dwProcessor );
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentThread );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\lib\fsfilteroperationnames.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    irpName.c

Abstract:

    This module contains functions used to generate names for IRPs

// @@BEGIN_DDKSPLIT
Author:

    Neal Christiansen (NealCH) 27-Sep-2000

// @@END_DDKSPLIT

Environment:

    User mode


// @@BEGIN_DDKSPLIT
Revision History:

    Molly Brown (mollybro)         21-May-2002
        Modify sample to make it support running on Windows 2000 or later if
        built in the latest build environment and allow it to be built in W2K 
        and later build environments.

// @@END_DDKSPLIT
--*/

#include <ntifs.h>
#include <stdio.h>
#include "filespyLib.h"

#if WINVER >= 0x0501

VOID
GetFsFilterOperationName (
    IN UCHAR FsFilterOperation,
    OUT PCHAR FsFilterOperationName
    )
/*++

Routine Description:

    This routine translates the given FsFilter Operation code into a printable
    string which is returned.  

Arguments:

    FsFilterOperation - the FsFilter operation code to translate
    FsFilterOperationName - a buffer at least OPERATION_NAME_BUFFER_SIZE
                characters long that receives the name.

Return Value:

    None.

--*/
{
    PCHAR operationString;
    CHAR nameBuf[OPERATION_NAME_BUFFER_SIZE];

    switch (FsFilterOperation) {

        case FS_FILTER_ACQUIRE_FOR_CC_FLUSH:
            operationString = "ACQUIRE_FOR_CC_FLUSH";
            break;

        case FS_FILTER_RELEASE_FOR_CC_FLUSH:
            operationString = "RELEASE_FOR_CC_FLUSH";
            break;

        case FS_FILTER_ACQUIRE_FOR_SECTION_SYNCHRONIZATION:
            operationString = "ACQUIRE_FOR_SECTION_SYNC";
            break;

        case FS_FILTER_RELEASE_FOR_SECTION_SYNCHRONIZATION:
            operationString = "RELEASE_FOR_SECTION_SYNC";
            break;

        case FS_FILTER_ACQUIRE_FOR_MOD_WRITE:
            operationString = "ACQUIRE_FOR_MOD_WRITE";
            break;

        case FS_FILTER_RELEASE_FOR_MOD_WRITE:
            operationString = "RELEASE_FOR_MOD_WRITE";
            break;

        default:
            sprintf(nameBuf,"Unknown FsFilter operation (%u)",FsFilterOperation);
            operationString = nameBuf;
    }

    strcpy(FsFilterOperationName,operationString);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\lib\fastionames.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    irpName.c

Abstract:

    This module contains functions used to generate names for IRPs

// @@BEGIN_DDKSPLIT
Author:

    Neal Christiansen (NealCH) 27-Sep-2000

// @@END_DDKSPLIT

Environment:

    User mode


// @@BEGIN_DDKSPLIT
Revision History:

// @@END_DDKSPLIT
--*/

#include <ntifs.h>
#include <stdio.h>
#include "filespyLib.h"


VOID
GetFastioName (
    IN FASTIO_TYPE FastIoCode,
    OUT PCHAR FastIoName
    )
/*++

Routine Description:

    This routine translates the given FastIO code into a printable string which
    is returned.  

Arguments:

    FastIoCode - the FastIO code to translate
    FastioName - a buffer at least OPERATION_NAME_BUFFER_SIZE characters long
                 that receives the fastIO name.

Return Value:

    None.

--*/
{
    PCHAR fastIoString;
    CHAR nameBuf[OPERATION_NAME_BUFFER_SIZE];

    switch (FastIoCode) {

        case CHECK_IF_POSSIBLE:
            fastIoString = "CHECK_IF_POSSIBLE";
            break;

        case READ:
            fastIoString = "READ";
            break;

        case WRITE:
            fastIoString = "WRITE";
            break;

        case QUERY_BASIC_INFO:
            fastIoString = "QUERY_BASIC_INFO";
            break;

        case QUERY_STANDARD_INFO:
            fastIoString = "QUERY_STANDARD_INFO";
            break;

        case LOCK:
            fastIoString = "LOCK";
            break;

        case UNLOCK_SINGLE:
            fastIoString = "UNLOCK_SINGLE";
            break;

        case UNLOCK_ALL:
            fastIoString = "UNLOCK_ALL";
            break;

        case UNLOCK_ALL_BY_KEY:
            fastIoString = "UNLOCK_ALL_BY_KEY";
            break;

        case DEVICE_CONTROL:
            fastIoString = "DEVICE_CONTROL";
            break;

        case DETACH_DEVICE:
            fastIoString = "DETACH_DEVICE";
            break;

        case QUERY_NETWORK_OPEN_INFO:
            fastIoString = "QUERY_NETWORK_OPEN_INFO";
            break;

        case MDL_READ:
            fastIoString = "MDL_READ";
            break;

        case MDL_READ_COMPLETE:
            fastIoString = "MDL_READ_COMPLETE";
            break;

        case MDL_WRITE:
            fastIoString = "MDL_WRITE";
            break;

        case MDL_WRITE_COMPLETE:
            fastIoString = "MDL_WRITE_COMPLETE";
            break;

        case READ_COMPRESSED:
            fastIoString = "READ_COMPRESSED";
            break;

        case WRITE_COMPRESSED:
            fastIoString = "WRITE_COMPRESSED";
            break;

        case MDL_READ_COMPLETE_COMPRESSED:
            fastIoString = "MDL_READ_COMPLETE_COMPRESSED";
            break;

        case PREPARE_MDL_WRITE:
            fastIoString = "PREPARE_MDL_WRITE";
            break;

        case MDL_WRITE_COMPLETE_COMPRESSED:
            fastIoString = "MDL_WRITE_COMPLETE_COMPRESSED";
            break;

        case QUERY_OPEN:
            fastIoString = "QUERY_OPEN";
            break;

        default:
            sprintf(nameBuf,"Unknown FastIO operation (%u)",FastIoCode);
            fastIoString = nameBuf;
    }

    strcpy(FastIoName,fastIoString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\fspykd\pch.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pch.h

Abstract:

    Header file which allows kernel and user mode header files
	to be included together for compilation of debugger extensions.

// @@BEGIN_DDKSPLIT

Author:

    Molly Brown [MollyBro]    1-Mar-2000

Revision History:

	Molly Brown [MollyBro]
		
		Cleaned up this header file based on example in 
		"The Windows NT Device Driver Book" by Art Baker.

// @@END_DDKSPLIT

Environment:

    User Mode.

--*/
#include <windows.h>
#include <string.h>
#define KDEXT_64BIT
#include <wdbgexts.h>
#include <stdlib.h>
#include <stdio.h>
#include <fspydef.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\lib\irpnames.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    irpName.c

Abstract:

    This module contains functions used to generate names for IRPs

// @@BEGIN_DDKSPLIT
Author:

    Neal Christiansen (NealCH) 27-Sep-2000

// @@END_DDKSPLIT

Environment:

    User mode


// @@BEGIN_DDKSPLIT
Revision History:

    Molly Brown (mollybro)         21-May-2002
        Modify sample to make it support running on Windows 2000 or later if
        built in the latest build environment and allow it to be built in W2K 
        and later build environments.

// @@END_DDKSPLIT
--*/

#include <ntifs.h>
#include <stdio.h>
#include "filespyLib.h"

//
//  Globals
//

CHAR UnknownIrpMinor[] = "Unknown Irp minor code (%u)";


VOID
GetIrpName (
    IN UCHAR MajorCode,
    IN UCHAR MinorCode,
    IN ULONG FsctlCode,
    OUT PCHAR MajorCodeName,
    OUT PCHAR MinorCodeName
    )
/*++

Routine Description:

    This routine translates the given Irp codes into printable strings which
    are returned.  This guarantees to routine valid strings in each buffer.
    The MinorCode string may be a NULL string (not a null pointer).

Arguments:

    MajorCode - the IRP Major code of the operation
    MinorCode - the IRP Minor code of the operation
    FsctlCode - if this is an IRP_MJ_FILE_SYSTEM_CONTROL/IRP_MN_USER_FS_REQUEST
                operation then this is the FSCTL code whose name is also
                translated.  This name is returned as part of the MinorCode
                string.
    MajorCodeName - a string buffer at least OPERATION_NAME_BUFFER_SIZE
                characters long that receives the major code name.
    MinorCodeName - a string buffer at least OPERATION_NAME_BUFFER_SIZE
                characters long that receives the minor/fsctl code name.

Return Value:

    None.

--*/
{
    PCHAR irpMajorString;
    PCHAR irpMinorString = "";
    CHAR nameBuf[OPERATION_NAME_BUFFER_SIZE];

    switch (MajorCode) {
        case IRP_MJ_CREATE:
            irpMajorString = "IRP_MJ_CREATE";
            break;
        case IRP_MJ_CREATE_NAMED_PIPE:
            irpMajorString = "IRP_MJ_CREATE_NAMED_PIPE";
            break;
        case IRP_MJ_CLOSE:
            irpMajorString = "IRP_MJ_CLOSE";
            break;
        case IRP_MJ_READ:
            irpMajorString = "IRP_MJ_READ";
            switch (MinorCode) {
                case IRP_MN_NORMAL:
                    irpMinorString = "IRP_MN_NORMAL";
                    break;
                case IRP_MN_DPC:
                    irpMinorString = "IRP_MN_DPC";
                    break;
                case IRP_MN_MDL:
                    irpMinorString = "IRP_MN_MDL";
                    break;
                case IRP_MN_COMPLETE:
                    irpMinorString = "IRP_MN_COMPLETE";
                    break;
                case IRP_MN_COMPRESSED:
                    irpMinorString = "IRP_MN_COMPRESSED";
                    break;
                case IRP_MN_MDL_DPC:
                    irpMinorString = "IRP_MN_MDL_DPC";
                    break;
                case IRP_MN_COMPLETE_MDL:
                    irpMinorString = "IRP_MN_COMPLETE_MDL";
                    break;
                case IRP_MN_COMPLETE_MDL_DPC:
                    irpMinorString = "IRP_MN_COMPLETE_MDL_DPC";
                    break;
                default:
                    sprintf( nameBuf, UnknownIrpMinor, MinorCode );
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_WRITE:
            irpMajorString = "IRP_MJ_WRITE";
            switch (MinorCode) {
                case IRP_MN_NORMAL:
                    irpMinorString = "IRP_MN_NORMAL";
                    break;
                case IRP_MN_DPC:
                    irpMinorString = "IRP_MN_DPC";
                    break;
                case IRP_MN_MDL:
                    irpMinorString = "IRP_MN_MDL";
                    break;
                case IRP_MN_COMPLETE:
                    irpMinorString = "IRP_MN_COMPLETE";
                    break;
                case IRP_MN_COMPRESSED:
                    irpMinorString = "IRP_MN_COMPRESSED";
                    break;
                case IRP_MN_MDL_DPC:
                    irpMinorString = "IRP_MN_MDL_DPC";
                    break;
                case IRP_MN_COMPLETE_MDL:
                    irpMinorString = "IRP_MN_COMPLETE_MDL";
                    break;
                case IRP_MN_COMPLETE_MDL_DPC:
                    irpMinorString = "IRP_MN_COMPLETE_MDL_DPC";
                    break;
                default:
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_QUERY_INFORMATION:
            irpMajorString = "IRP_MJ_QUERY_INFORMATION";
            break;
        case IRP_MJ_SET_INFORMATION:
            irpMajorString = "IRP_MJ_SET_INFORMATION";
            break;
        case IRP_MJ_QUERY_EA:
            irpMajorString = "IRP_MJ_QUERY_EA";
            break;
        case IRP_MJ_SET_EA:
            irpMajorString = "IRP_MJ_SET_EA";
            break;
        case IRP_MJ_FLUSH_BUFFERS:
            irpMajorString = "IRP_MJ_FLUSH_BUFFERS";
            break;
        case IRP_MJ_QUERY_VOLUME_INFORMATION:
            irpMajorString = "IRP_MJ_QUERY_VOLUME_INFORMATION";
            break;
        case IRP_MJ_SET_VOLUME_INFORMATION:
            irpMajorString = "IRP_MJ_SET_VOLUME_INFORMATION";
            break;
        case IRP_MJ_DIRECTORY_CONTROL:
            irpMajorString = "IRP_MJ_DIRECTORY_CONTROL";
            switch (MinorCode) {
                case IRP_MN_QUERY_DIRECTORY:
                    irpMinorString = "IRP_MN_QUERY_DIRECTORY";
                    break;
                case IRP_MN_NOTIFY_CHANGE_DIRECTORY:
                    irpMinorString = "IRP_MN_NOTIFY_CHANGE_DIRECTORY";
                    break;
                default:
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_FILE_SYSTEM_CONTROL:
            irpMajorString = "IRP_MJ_FILE_SYSTEM_CONTROL";
            switch (MinorCode) {
                case IRP_MN_USER_FS_REQUEST:
                    switch (FsctlCode) {
                        case FSCTL_REQUEST_OPLOCK_LEVEL_1:
                            irpMinorString = "FSCTL_REQUEST_OPLOCK_LEVEL_1";
                            break;
                        case FSCTL_REQUEST_OPLOCK_LEVEL_2:
                            irpMinorString = "FSCTL_REQUEST_OPLOCK_LEVEL_2";
                            break;
                        case FSCTL_REQUEST_BATCH_OPLOCK:
                            irpMinorString = "FSCTL_REQUEST_BATCH_OPLOCK";
                            break;
                        case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
                            irpMinorString = "FSCTL_OPLOCK_BREAK_ACKNOWLEDGE";
                            break;
                        case FSCTL_OPBATCH_ACK_CLOSE_PENDING:
                            irpMinorString = "FSCTL_OPBATCH_ACK_CLOSE_PENDING";
                            break;
                        case FSCTL_OPLOCK_BREAK_NOTIFY:
                            irpMinorString = "FSCTL_OPLOCK_BREAK_NOTIFY";
                            break;
                        case FSCTL_LOCK_VOLUME:
                            irpMinorString = "FSCTL_LOCK_VOLUME";
                            break;
                        case FSCTL_UNLOCK_VOLUME:
                            irpMinorString = "FSCTL_UNLOCK_VOLUME";
                            break;
                        case FSCTL_DISMOUNT_VOLUME:
                            irpMinorString = "FSCTL_DISMOUNT_VOLUME";
                            break;
                        case FSCTL_IS_VOLUME_MOUNTED:
                            irpMinorString = "FSCTL_IS_VOLUME_MOUNTED";
                            break;
                        case FSCTL_IS_PATHNAME_VALID:
                            irpMinorString = "FSCTL_IS_PATHNAME_VALID";
                            break;
                        case FSCTL_MARK_VOLUME_DIRTY:
                            irpMinorString = "FSCTL_MARK_VOLUME_DIRTY";
                            break;
                        case FSCTL_QUERY_RETRIEVAL_POINTERS:
                            irpMinorString = "FSCTL_QUERY_RETRIEVAL_POINTERS";
                            break;
                        case FSCTL_GET_COMPRESSION:
                            irpMinorString = "FSCTL_GET_COMPRESSION";
                            break;
                        case FSCTL_SET_COMPRESSION:
                            irpMinorString = "FSCTL_SET_COMPRESSION";
                            break;
                        case FSCTL_MARK_AS_SYSTEM_HIVE:
                            irpMinorString = "FSCTL_MARK_AS_SYSTEM_HIVE";
                            break;
                        case FSCTL_OPLOCK_BREAK_ACK_NO_2:
                            irpMinorString = "FSCTL_OPLOCK_BREAK_ACK_NO_2";
                            break;
                        case FSCTL_INVALIDATE_VOLUMES:
                            irpMinorString = "FSCTL_INVALIDATE_VOLUMES";
                            break;
                        case FSCTL_QUERY_FAT_BPB:
                            irpMinorString = "FSCTL_QUERY_FAT_BPB";
                            break;
                        case FSCTL_REQUEST_FILTER_OPLOCK:
                            irpMinorString = "FSCTL_REQUEST_FILTER_OPLOCK";
                            break;
                        case FSCTL_FILESYSTEM_GET_STATISTICS:
                            irpMinorString = "FSCTL_FILESYSTEM_GET_STATISTICS";
                            break;
                        case FSCTL_GET_NTFS_VOLUME_DATA:
                            irpMinorString = "FSCTL_GET_NTFS_VOLUME_DATA";
                            break;
                        case FSCTL_GET_NTFS_FILE_RECORD:
                            irpMinorString = "FSCTL_GET_NTFS_FILE_RECORD";
                            break;
                        case FSCTL_GET_VOLUME_BITMAP:
                            irpMinorString = "FSCTL_GET_VOLUME_BITMAP";
                            break;
                        case FSCTL_GET_RETRIEVAL_POINTERS:
                            irpMinorString = "FSCTL_GET_RETRIEVAL_POINTERS";
                            break;
                        case FSCTL_MOVE_FILE:
                            irpMinorString = "FSCTL_MOVE_FILE";
                            break;
                        case FSCTL_IS_VOLUME_DIRTY:
                            irpMinorString = "FSCTL_IS_VOLUME_DIRTY";
                            break;
                        case FSCTL_ALLOW_EXTENDED_DASD_IO:
                            irpMinorString = "FSCTL_ALLOW_EXTENDED_DASD_IO";
                            break;
                        case FSCTL_FIND_FILES_BY_SID:
                            irpMinorString = "FSCTL_FIND_FILES_BY_SID";
                            break;
                        case FSCTL_SET_OBJECT_ID:
                            irpMinorString = "FSCTL_SET_OBJECT_ID";
                            break;
                        case FSCTL_GET_OBJECT_ID:
                            irpMinorString = "FSCTL_GET_OBJECT_ID";
                            break;
                        case FSCTL_DELETE_OBJECT_ID:
                            irpMinorString = "FSCTL_DELETE_OBJECT_ID";
                            break;
                        case FSCTL_SET_REPARSE_POINT:
                            irpMinorString = "FSCTL_SET_REPARSE_POINT";
                            break;
                        case FSCTL_GET_REPARSE_POINT:
                            irpMinorString = "FSCTL_GET_REPARSE_POINT";
                            break;
                        case FSCTL_DELETE_REPARSE_POINT:
                            irpMinorString = "FSCTL_DELETE_REPARSE_POINT";
                            break;
                        case FSCTL_ENUM_USN_DATA:
                            irpMinorString = "FSCTL_ENUM_USN_DATA";
                            break;
                        case FSCTL_SECURITY_ID_CHECK:
                            irpMinorString = "FSCTL_SECURITY_ID_CHECK";
                            break;
                        case FSCTL_READ_USN_JOURNAL:
                            irpMinorString = "FSCTL_READ_USN_JOURNAL";
                            break;
                        case FSCTL_SET_OBJECT_ID_EXTENDED:
                            irpMinorString = "FSCTL_SET_OBJECT_ID_EXTENDED";
                            break;
                        case FSCTL_CREATE_OR_GET_OBJECT_ID:
                            irpMinorString = "FSCTL_CREATE_OR_GET_OBJECT_ID";
                            break;
                        case FSCTL_SET_SPARSE:
                            irpMinorString = "FSCTL_SET_SPARSE";
                            break;
                        case FSCTL_SET_ZERO_DATA:
                            irpMinorString = "FSCTL_SET_ZERO_DATA";
                            break;
                        case FSCTL_QUERY_ALLOCATED_RANGES:
                            irpMinorString = "FSCTL_QUERY_ALLOCATED_RANGES";
                            break;
                        case FSCTL_SET_ENCRYPTION:
                            irpMinorString = "FSCTL_SET_ENCRYPTION";
                            break;
                        case FSCTL_ENCRYPTION_FSCTL_IO:
                            irpMinorString = "FSCTL_ENCRYPTION_FSCTL_IO";
                            break;
                        case FSCTL_WRITE_RAW_ENCRYPTED:
                            irpMinorString = "FSCTL_WRITE_RAW_ENCRYPTED";
                            break;
                        case FSCTL_READ_RAW_ENCRYPTED:
                            irpMinorString = "FSCTL_READ_RAW_ENCRYPTED";
                            break;
                        case FSCTL_CREATE_USN_JOURNAL:
                            irpMinorString = "FSCTL_CREATE_USN_JOURNAL";
                            break;
                        case FSCTL_READ_FILE_USN_DATA:
                            irpMinorString = "FSCTL_READ_FILE_USN_DATA";
                            break;
                        case FSCTL_WRITE_USN_CLOSE_RECORD:
                            irpMinorString = "FSCTL_WRITE_USN_CLOSE_RECORD";
                            break;
                        case FSCTL_EXTEND_VOLUME:
                            irpMinorString = "FSCTL_EXTEND_VOLUME";
                            break;
                        case FSCTL_QUERY_USN_JOURNAL:
                            irpMinorString = "FSCTL_QUERY_USN_JOURNAL";
                            break;
                        case FSCTL_DELETE_USN_JOURNAL:
                            irpMinorString = "FSCTL_DELETE_USN_JOURNAL";
                            break;
                        case FSCTL_MARK_HANDLE:
                            irpMinorString = "FSCTL_MARK_HANDLE";
                            break;
                        case FSCTL_SIS_COPYFILE:
                            irpMinorString = "FSCTL_SIS_COPYFILE";
                            break;
                        case FSCTL_SIS_LINK_FILES:
                            irpMinorString = "FSCTL_SIS_LINK_FILES";
                            break;
                        case FSCTL_HSM_MSG:
                            irpMinorString = "FSCTL_HSM_MSG";
                            break;
                        case FSCTL_HSM_DATA:
                            irpMinorString = "FSCTL_HSM_DATA";
                            break;
                        case FSCTL_RECALL_FILE:
                            irpMinorString = "FSCTL_RECALL_FILE";
                            break;
#if WINVER >= 0x0501                            
                        case FSCTL_READ_FROM_PLEX:
                            irpMinorString = "FSCTL_READ_FROM_PLEX";
                            break;
                        case FSCTL_FILE_PREFETCH:
                            irpMinorString = "FSCTL_FILE_PREFETCH";
                            break;
#endif                            
                        default:
                            sprintf(nameBuf,"Unknown FSCTL (%u)",MinorCode);
                            irpMinorString = nameBuf;
                            break;
                    }

                    sprintf(nameBuf,"%s (USER)",irpMinorString);
                    irpMinorString = nameBuf;
                    break;

                case IRP_MN_MOUNT_VOLUME:
                    irpMinorString = "IRP_MN_MOUNT_VOLUME";
                    break;
                case IRP_MN_VERIFY_VOLUME:
                    irpMinorString = "IRP_MN_VERIFY_VOLUME";
                    break;
                case IRP_MN_LOAD_FILE_SYSTEM:
                    irpMinorString = "IRP_MN_LOAD_FILE_SYSTEM";
                    break;
                case IRP_MN_TRACK_LINK:
                    irpMinorString = "IRP_MN_TRACK_LINK";
                    break;
                default:
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_DEVICE_CONTROL:
            irpMajorString = "IRP_MJ_DEVICE_CONTROL";
            switch (MinorCode) {
                case 0:
                    irpMinorString = "User request";
                    break;
                case IRP_MN_SCSI_CLASS:
                    irpMinorString = "IRP_MN_SCSI_CLASS";
                    break;
                default:
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_INTERNAL_DEVICE_CONTROL:
            irpMajorString = "IRP_MJ_INTERNAL_DEVICE_CONTROL";
            break;
        case IRP_MJ_SHUTDOWN:
            irpMajorString = "IRP_MJ_SHUTDOWN";
            break;
        case IRP_MJ_LOCK_CONTROL:
            irpMajorString = "IRP_MJ_LOCK_CONTROL";
            switch (MinorCode) {
                case IRP_MN_LOCK:
                    irpMinorString = "IRP_MN_LOCK";
                    break;
                case IRP_MN_UNLOCK_SINGLE:
                    irpMinorString = "IRP_MN_UNLOCK_SINGLE";
                    break;
                case IRP_MN_UNLOCK_ALL:
                    irpMinorString = "IRP_MN_UNLOCK_ALL";
                    break;
                case IRP_MN_UNLOCK_ALL_BY_KEY:
                    irpMinorString = "IRP_MN_UNLOCK_ALL_BY_KEY";
                    break;
                default:
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_CLEANUP:
            irpMajorString = "IRP_MJ_CLEANUP";
            break;
        case IRP_MJ_CREATE_MAILSLOT:
            irpMajorString = "IRP_MJ_CREATE_MAILSLOT";
            break;
        case IRP_MJ_QUERY_SECURITY:
            irpMajorString = "IRP_MJ_QUERY_SECURITY";
            break;
        case IRP_MJ_SET_SECURITY:
            irpMajorString = "IRP_MJ_SET_SECURITY";
            break;
        case IRP_MJ_POWER:
            irpMajorString = "IRP_MJ_POWER";
            switch (MinorCode) {
                case IRP_MN_WAIT_WAKE:
                    irpMinorString = "IRP_MN_WAIT_WAKE";
                    break;
                case IRP_MN_POWER_SEQUENCE:
                    irpMinorString = "IRP_MN_POWER_SEQUENCE";
                    break;
                case IRP_MN_SET_POWER:
                    irpMinorString = "IRP_MN_SET_POWER";
                    break;
                case IRP_MN_QUERY_POWER:
                    irpMinorString = "IRP_MN_QUERY_POWER";
                    break;
                default :
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_SYSTEM_CONTROL:
            irpMajorString = "IRP_MJ_SYSTEM_CONTROL";
            switch (MinorCode) {
                case IRP_MN_QUERY_ALL_DATA:
                    irpMinorString = "IRP_MN_QUERY_ALL_DATA";
                    break;
                case IRP_MN_QUERY_SINGLE_INSTANCE:
                    irpMinorString = "IRP_MN_QUERY_SINGLE_INSTANCE";
                    break;
                case IRP_MN_CHANGE_SINGLE_INSTANCE:
                    irpMinorString = "IRP_MN_CHANGE_SINGLE_INSTANCE";
                    break;
                case IRP_MN_CHANGE_SINGLE_ITEM:
                    irpMinorString = "IRP_MN_CHANGE_SINGLE_ITEM";
                    break;
                case IRP_MN_ENABLE_EVENTS:
                    irpMinorString = "IRP_MN_ENABLE_EVENTS";
                    break;
                case IRP_MN_DISABLE_EVENTS:
                    irpMinorString = "IRP_MN_DISABLE_EVENTS";
                    break;
                case IRP_MN_ENABLE_COLLECTION:
                    irpMinorString = "IRP_MN_ENABLE_COLLECTION";
                    break;
                case IRP_MN_DISABLE_COLLECTION:
                    irpMinorString = "IRP_MN_DISABLE_COLLECTION";
                    break;
                case IRP_MN_REGINFO:
                    irpMinorString = "IRP_MN_REGINFO";
                    break;
                case IRP_MN_EXECUTE_METHOD:
                    irpMinorString = "IRP_MN_EXECUTE_METHOD";
                    break;
                default :
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_DEVICE_CHANGE:
            irpMajorString = "IRP_MJ_DEVICE_CHANGE";
            break;
        case IRP_MJ_QUERY_QUOTA:
            irpMajorString = "IRP_MJ_QUERY_QUOTA";
            break;
        case IRP_MJ_SET_QUOTA:
            irpMajorString = "IRP_MJ_SET_QUOTA";
            break;
        case IRP_MJ_PNP:
            irpMajorString = "IRP_MJ_PNP";
            switch (MinorCode) {
                case IRP_MN_START_DEVICE:
                    irpMinorString = "IRP_MN_START_DEVICE";
                    break;
                case IRP_MN_QUERY_REMOVE_DEVICE:
                    irpMinorString = "IRP_MN_QUERY_REMOVE_DEVICE";
                    break;
                case IRP_MN_REMOVE_DEVICE:
                    irpMinorString = "IRP_MN_REMOVE_DEVICE";
                    break;
                case IRP_MN_CANCEL_REMOVE_DEVICE:
                    irpMinorString = "IRP_MN_CANCEL_REMOVE_DEVICE";
                    break;
                case IRP_MN_STOP_DEVICE:
                    irpMinorString = "IRP_MN_STOP_DEVICE";
                    break;
                case IRP_MN_QUERY_STOP_DEVICE:
                    irpMinorString = "IRP_MN_QUERY_STOP_DEVICE";
                    break;
                case IRP_MN_CANCEL_STOP_DEVICE:
                    irpMinorString = "IRP_MN_CANCEL_STOP_DEVICE";
                    break;
                case IRP_MN_QUERY_DEVICE_RELATIONS:
                    irpMinorString = "IRP_MN_QUERY_DEVICE_RELATIONS";
                    break;
                case IRP_MN_QUERY_INTERFACE:
                    irpMinorString = "IRP_MN_QUERY_INTERFACE";
                    break;
                case IRP_MN_QUERY_CAPABILITIES:
                    irpMinorString = "IRP_MN_QUERY_CAPABILITIES";
                    break;
                case IRP_MN_QUERY_RESOURCES:
                    irpMinorString = "IRP_MN_QUERY_RESOURCES";
                    break;
                case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
                    irpMinorString = "IRP_MN_QUERY_RESOURCE_REQUIREMENTS";
                    break;
                case IRP_MN_QUERY_DEVICE_TEXT:
                    irpMinorString = "IRP_MN_QUERY_DEVICE_TEXT";
                    break;
                case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
                    irpMinorString = "IRP_MN_FILTER_RESOURCE_REQUIREMENTS";
                    break;
                case IRP_MN_READ_CONFIG:
                    irpMinorString = "IRP_MN_READ_CONFIG";
                    break;
                case IRP_MN_WRITE_CONFIG:
                    irpMinorString = "IRP_MN_WRITE_CONFIG";
                    break;
                case IRP_MN_EJECT:
                    irpMinorString = "IRP_MN_EJECT";
                    break;
                case IRP_MN_SET_LOCK:
                    irpMinorString = "IRP_MN_SET_LOCK";
                    break;
                case IRP_MN_QUERY_ID:
                    irpMinorString = "IRP_MN_QUERY_ID";
                    break;
                case IRP_MN_QUERY_PNP_DEVICE_STATE:
                    irpMinorString = "IRP_MN_QUERY_PNP_DEVICE_STATE";
                    break;
                case IRP_MN_QUERY_BUS_INFORMATION:
                    irpMinorString = "IRP_MN_QUERY_BUS_INFORMATION";
                    break;
                case IRP_MN_DEVICE_USAGE_NOTIFICATION:
                    irpMinorString = "IRP_MN_DEVICE_USAGE_NOTIFICATION";
                    break;
                case IRP_MN_SURPRISE_REMOVAL:
                    irpMinorString = "IRP_MN_SURPRISE_REMOVAL";
                    break;
                case IRP_MN_QUERY_LEGACY_BUS_INFORMATION:
                    irpMinorString = "IRP_MN_QUERY_LEGACY_BUS_INFORMATION";
                    break;
                default :
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        default:
            sprintf(nameBuf,"Unknown Irp major code (%u)",MajorCode);
            irpMajorString = nameBuf;
    }

    strcpy(MajorCodeName,irpMajorString);
    strcpy(MinorCodeName,irpMinorString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\lib\filespylib.h ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    filespyLib.h

Abstract:

    This contains internal definitions from the fileSpy library
    
// @@BEGIN_DDKSPLIT
Author:

    Neal Christiansen (NealCH) 27-Sep-2000

// @@END_DDKSPLIT
Environment:

    Library used by both USER and KERNEL mode components

// @@BEGIN_DDKSPLIT
Revision History:

    Molly Brown (mollybro)         21-May-2002
        Modify sample to make it support running on Windows 2000 or later if
        built in the latest build environment and allow it to be built in W2K 
        and later build environments.

// @@END_DDKSPLIT
--*/

#ifndef __FILESPYLIB_H__
#define __FILESPYLIB_H__

#ifdef __cplusplus
extern "C" {
#endif

//
//  The types FASTIO that are available for the Type field of the 
//  RECORD_FASTIO structure.
//

typedef enum {

    CHECK_IF_POSSIBLE = 1,
    READ,
    WRITE,
    QUERY_BASIC_INFO,
    QUERY_STANDARD_INFO,
    LOCK,
    UNLOCK_SINGLE,
    UNLOCK_ALL,
    UNLOCK_ALL_BY_KEY,
    DEVICE_CONTROL,
    DETACH_DEVICE,
    QUERY_NETWORK_OPEN_INFO,
    MDL_READ,
    MDL_READ_COMPLETE,
    MDL_WRITE,
    MDL_WRITE_COMPLETE,
    READ_COMPRESSED,
    WRITE_COMPRESSED,
    MDL_READ_COMPLETE_COMPRESSED,
    PREPARE_MDL_WRITE,
    MDL_WRITE_COMPLETE_COMPRESSED,
    QUERY_OPEN,

    FASTIO_MAX_OPERATION=QUERY_OPEN
} FASTIO_TYPE/*, *PFASTIO_TYPE*/;

//
//  Size of return name buffers
//

#define OPERATION_NAME_BUFFER_SIZE 80

//
//  Function prototypes
//

extern
VOID
GetIrpName (
    IN UCHAR MajorCode,
    IN UCHAR MinorCode,
    IN ULONG FsctlCode,
    OUT PCHAR MajorCodeName,
    OUT PCHAR MinorCodeName);

extern
VOID
GetFastioName (
    IN FASTIO_TYPE FastioCode,
    OUT PCHAR FastioName);

#if WINVER >= 0x0501 /* See comment in DriverEntry */
extern
VOID
GetFsFilterOperationName (
    IN UCHAR FsFilterOperation,
    OUT PCHAR FsFilterOperationName);
#endif
    
//
//  Service definitions
//

#define FILESPY_SERVICE_NAME   L"FileSpy"
#define FILESPY_SERVICE_ACCESS (STANDARD_RIGHTS_REQUIRED | \
                                SERVICE_QUERY_CONFIG | \
                                SERVICE_QUERY_STATUS | \
                                SERVICE_START)

//
//  These are copied from NTIFS.H because we need them in user mode.
//

#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_QUERY_EA                 0x07
#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
#define IRP_MJ_DIRECTORY_CONTROL        0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
#define IRP_MJ_DEVICE_CONTROL           0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_CREATE_MAILSLOT          0x13
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_POWER                    0x16
#define IRP_MJ_SYSTEM_CONTROL           0x17
#define IRP_MJ_DEVICE_CHANGE            0x18
#define IRP_MJ_QUERY_QUOTA              0x19
#define IRP_MJ_SET_QUOTA                0x1a
#define IRP_MJ_PNP                      0x1b
#define IRP_MJ_MAXIMUM_FUNCTION         0x1b

#define IRP_MN_QUERY_DIRECTORY          0x01
#define IRP_MN_NOTIFY_CHANGE_DIRECTORY  0x02
#define IRP_MN_USER_FS_REQUEST          0x00
#define IRP_MN_MOUNT_VOLUME             0x01
#define IRP_MN_VERIFY_VOLUME            0x02
#define IRP_MN_LOAD_FILE_SYSTEM         0x03
#define IRP_MN_TRACK_LINK               0x04
#define IRP_MN_LOCK                     0x01
#define IRP_MN_UNLOCK_SINGLE            0x02
#define IRP_MN_UNLOCK_ALL               0x03
#define IRP_MN_UNLOCK_ALL_BY_KEY        0x04
#define IRP_MN_NORMAL                   0x00
#define IRP_MN_DPC                      0x01
#define IRP_MN_MDL                      0x02
#define IRP_MN_COMPLETE                 0x04
#define IRP_MN_COMPRESSED               0x08
#define IRP_MN_MDL_DPC                  (IRP_MN_MDL | IRP_MN_DPC)
#define IRP_MN_COMPLETE_MDL             (IRP_MN_COMPLETE | IRP_MN_MDL)
#define IRP_MN_COMPLETE_MDL_DPC         (IRP_MN_COMPLETE_MDL | IRP_MN_DPC)
#define IRP_MN_SCSI_CLASS               0x01
#define IRP_MN_START_DEVICE                 0x00
#define IRP_MN_QUERY_REMOVE_DEVICE          0x01
#define IRP_MN_REMOVE_DEVICE                0x02
#define IRP_MN_CANCEL_REMOVE_DEVICE         0x03
#define IRP_MN_STOP_DEVICE                  0x04
#define IRP_MN_QUERY_STOP_DEVICE            0x05
#define IRP_MN_CANCEL_STOP_DEVICE           0x06
#define IRP_MN_QUERY_DEVICE_RELATIONS       0x07
#define IRP_MN_QUERY_INTERFACE              0x08
#define IRP_MN_QUERY_CAPABILITIES           0x09
#define IRP_MN_QUERY_RESOURCES              0x0A
#define IRP_MN_QUERY_RESOURCE_REQUIREMENTS  0x0B
#define IRP_MN_QUERY_DEVICE_TEXT            0x0C
#define IRP_MN_FILTER_RESOURCE_REQUIREMENTS 0x0D
#define IRP_MN_READ_CONFIG                  0x0F
#define IRP_MN_WRITE_CONFIG                 0x10
#define IRP_MN_EJECT                        0x11
#define IRP_MN_SET_LOCK                     0x12
#define IRP_MN_QUERY_ID                     0x13
#define IRP_MN_QUERY_PNP_DEVICE_STATE       0x14
#define IRP_MN_QUERY_BUS_INFORMATION        0x15
#define IRP_MN_DEVICE_USAGE_NOTIFICATION    0x16
#define IRP_MN_SURPRISE_REMOVAL             0x17
#define IRP_MN_QUERY_LEGACY_BUS_INFORMATION 0x18
#define IRP_MN_WAIT_WAKE                    0x00
#define IRP_MN_POWER_SEQUENCE               0x01
#define IRP_MN_SET_POWER                    0x02
#define IRP_MN_QUERY_POWER                  0x03
#define IRP_MN_QUERY_ALL_DATA               0x00
#define IRP_MN_QUERY_SINGLE_INSTANCE        0x01
#define IRP_MN_CHANGE_SINGLE_INSTANCE       0x02
#define IRP_MN_CHANGE_SINGLE_ITEM           0x03
#define IRP_MN_ENABLE_EVENTS                0x04
#define IRP_MN_DISABLE_EVENTS               0x05
#define IRP_MN_ENABLE_COLLECTION            0x06
#define IRP_MN_DISABLE_COLLECTION           0x07
#define IRP_MN_REGINFO                      0x08
#define IRP_MN_EXECUTE_METHOD               0x09

//
//  Lists of IRP names and FASTIO names
//

extern PWCHAR IrpNameList[IRP_MJ_MAXIMUM_FUNCTION+1];
extern PWCHAR FastIoNameList[FASTIO_MAX_OPERATION];


#ifdef __cplusplus
}
#endif

#endif __FILESPYLIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\lib\namelists.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    irpNameList.c

Abstract:

    This module contains an array of unicode IRP names.

// @@BEGIN_DDKSPLIT
Author:

    Neal Christiansen (NealCH) 29-Sep-2000

// @@END_DDKSPLIT

Environment:

    User mode


// @@BEGIN_DDKSPLIT
Revision History:

// @@END_DDKSPLIT
--*/

#include <ntifs.h>
#include "filespyLib.h"

//
//  List of unicode irp names
//

PWCHAR IrpNameList[IRP_MJ_MAXIMUM_FUNCTION+1] = 
{
    L"IRP_MJ_CREATE",
    L"IRP_MJ_CREATE_NAMED_PIPE",
    L"IRP_MJ_CLOSE",
    L"IRP_MJ_READ",
    L"IRP_MJ_WRITE",
    L"IRP_MJ_QUERY_INFORMATION",
    L"IRP_MJ_SET_INFORMATION",
    L"IRP_MJ_QUERY_EA",
    L"IRP_MJ_SET_EA",
    L"IRP_MJ_FLUSH_BUFFERS",
    L"IRP_MJ_QUERY_VOLUME_INFORMATION",
    L"IRP_MJ_SET_VOLUME_INFORMATION",
    L"IRP_MJ_DIRECTORY_CONTROL",
    L"IRP_MJ_FILE_SYSTEM_CONTROL",
    L"IRP_MJ_DEVICE_CONTROL",
    L"IRP_MJ_INTERNAL_DEVICE_CONTROL",
    L"IRP_MJ_SHUTDOWN",
    L"IRP_MJ_LOCK_CONTROL",
    L"IRP_MJ_CLEANUP",
    L"IRP_MJ_CREATE_MAILSLOT",
    L"IRP_MJ_QUERY_SECURITY",
    L"IRP_MJ_SET_SECURITY",
    L"IRP_MJ_POWER",
    L"IRP_MJ_SYSTEM_CONTROL",
    L"IRP_MJ_DEVICE_CHANGE",
    L"IRP_MJ_QUERY_QUOTA",
    L"IRP_MJ_SET_QUOTA",
    L"IRP_MJ_PNP"
};


PWCHAR FastIoNameList[FASTIO_MAX_OPERATION] =
{
    L"CHECK_IF_POSSIBLE",
    L"READ",
    L"WRITE",
    L"QUERY_BASIC_INFO",
    L"QUERY_STANDARD_INFO",
    L"LOCK",
    L"UNLOCK_SINGLE",
    L"UNLOCK_ALL",
    L"UNLOCK_ALL_BY_KEY",
    L"DEVICE_CONTROL",
    L"DETACH_DEVICE",
    L"QUERY_NETWORK_OPEN_INFO",
    L"MDL_READ",
    L"MDL_READ_COMPLETE",
    L"MDL_WRITE",
    L"MDL_WRITE_COMPLETE",
    L"READ_COMPRESSED",
    L"WRITE_COMPRESSED",
    L"MDL_READ_COMPLETE_COMPRESSED",
    L"PREPARE_MDL_WRITE",
    L"MDL_WRITE_COMPLETE_COMPRESSED",
    L"QUERY_OPEN_STRING",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\user\fspylog.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    fspyLog.c

Abstract:

    This module contains functions used to retrieve and see the log records
    recorded by filespy.sys.

Environment:

    User mode

// @@BEGIN_DDKSPLIT
Author:

    Molly Brown (MollyBro) 21-Apr-1999

Revision History:

    Molly Brown (mollybro)         21-May-2002
        Modify sample to make it support running on Windows 2000 or later if
        built in the latest build environment and allow it to be built in W2K 
        and later build environments.

// @@END_DDKSPLIT
--*/
#include <stdio.h>
#include <windows.h>
#include <stdlib.h>
#include <winioctl.h>
#include "fspyLog.h"
#include "filespyLib.h"

#define TIME_BUFFER_LENGTH 20
#define TIME_ERROR         L"time error"

#define FlagOn(F,SF) ( \
    (((F) & (SF)))     \
)

DWORD WINAPI 
RetrieveLogRecords (
    LPVOID lpParameter
)
{
    PLOG_CONTEXT context = (PLOG_CONTEXT)lpParameter;
    CHAR buffer[BUFFER_SIZE];
    DWORD bytesReturned = 0;
    BOOL bResult;
    DWORD result;
    PLOG_RECORD pLogRecord;

    printf("Log: Starting up\n");

    while (TRUE) {

        //
        // Check to see if we should shut down
        //

        if (context->CleaningUp) {

            break;
        }

        //
        // Request log data from filespy
        //

        bResult = DeviceIoControl( context->Device,
                                   FILESPY_GetLog,
                                   NULL,
                                   0,
                                   buffer,
                                   BUFFER_SIZE,
                                   &bytesReturned,
                                   NULL);

        if (!bResult) {

            result = GetLastError();
            printf("ERROR controlling device: 0x%x\n", result);
        }

        //
        // Buffer is filled with a series of LOG_RECORD structures, one
        // right after another.  Each LOG_RECORD says how long it is, so
        // we know where the next LOG_RECORD begins.
        //

        pLogRecord = (PLOG_RECORD) buffer;

        //
        // Logic to write record to screen and/or file
        //

        while ((BYTE *) pLogRecord < buffer + bytesReturned) {

            PRECORD_IRP pRecordIrp;
            PRECORD_FASTIO pRecordFastIo;
#if WINVER >= 0x0501            
            PRECORD_FS_FILTER_OPERATION pRecordFsFilterOp;
#endif
            ULONG nameLength;

            //
            //  Calculate the length of the name in the log record.
            //
            
            nameLength = wcslen( pLogRecord->Name ) * sizeof( WCHAR );

            //
            // A LOG_RECORD could have Irp or FastIo data in it.  This
            // is denoted in the low-order byte of the RecordType flag.
            //

            switch (GET_RECORD_TYPE(pLogRecord)) {
            case RECORD_TYPE_IRP:

                //
                // We've got an Irp record, so output this data correctly.
                //
                pRecordIrp = &(pLogRecord->Record.RecordIrp);

                if (context->LogToScreen) {

                    IrpScreenDump( pLogRecord->SequenceNumber,
                                   pLogRecord->Name,
                                   nameLength,
                                   pRecordIrp,
                                   context->VerbosityFlags);
                }

                if (context->LogToFile) {

                    IrpFileDump( pLogRecord->SequenceNumber,
                                 pLogRecord->Name,
                                 nameLength,
                                 pRecordIrp, 
                                 context->OutputFile,
                                 context->VerbosityFlags);
                }
                break;

            case RECORD_TYPE_FASTIO:

                //
                // We've got a FastIo record, so output this data correctly.
                //

                pRecordFastIo = &(pLogRecord->Record.RecordFastIo);

                if (context->LogToScreen) {

                    FastIoScreenDump( pLogRecord->SequenceNumber,
                                      pLogRecord->Name,
                                      nameLength,
                                      pRecordFastIo);
                }

                if (context->LogToFile) {

                    FastIoFileDump( pLogRecord->SequenceNumber,
                                    pLogRecord->Name,
                                    nameLength,
                                    pRecordFastIo,
                                    context->OutputFile);
                }
                break;

#if WINVER >= 0x0501 /* See comment in DriverEntry */
            case RECORD_TYPE_FS_FILTER_OP:

                //
                //  We've got a FsFilter operation record, so output this
                //  data correctly.
                //

                pRecordFsFilterOp = &(pLogRecord->Record.RecordFsFilterOp);

                if (context->LogToScreen) {

                    FsFilterOperationScreenDump( pLogRecord->SequenceNumber,
                                                 pLogRecord->Name,
                                                 nameLength,
                                                 pRecordFsFilterOp );

                }

                if (context->LogToFile) {

                    FsFilterOperationFileDump( pLogRecord->SequenceNumber,
                                               pLogRecord->Name,
                                               nameLength,
                                               pRecordFsFilterOp,
                                               context->OutputFile );
                }
                break;
#endif                
                
            default:

                printf("FileSpy:  Unknown log record type\n");
            }

            //
            // The RecordType could also designate that we are out of memory
            // or hit our program defined memory limit, so check for these
            // cases.
            // 

            if (pLogRecord->RecordType & RECORD_TYPE_OUT_OF_MEMORY) {

                if (context->LogToScreen) {

                    printf("M %08X SYSTEM OUT OF MEMORY\n", pLogRecord->SequenceNumber);
                }

                if (context->LogToFile) {

                    fprintf(context->OutputFile, "M:\t%u", pLogRecord->SequenceNumber);
                }

            } else if (pLogRecord->RecordType & RECORD_TYPE_EXCEED_MEMORY_ALLOWANCE) {

                if (context->LogToScreen) {

                    printf("M %08X EXCEEDED MEMORY ALLOWANCE\n", pLogRecord->SequenceNumber);
                }

                if (context->LogToFile) {

                    fprintf(context->OutputFile, "M:\t%u", pLogRecord->SequenceNumber);
                }
            }

            //
            // Move to next LOG_RECORD
            //

            pLogRecord = (PLOG_RECORD) (((BYTE *) pLogRecord) + pLogRecord->Length);
        }

        if (bytesReturned == 0) {

            Sleep( 500 );
        }
    }

    printf("Log: Shutting down\n");
    ReleaseSemaphore(context->ShutDown, 1, NULL);
    printf("Log: All done\n");
    return 0;
}

VOID
PrintIrpCode (
    UCHAR MajorCode,
    UCHAR MinorCode,
    ULONG FsControlCode,
    FILE *OutputFile,
    BOOLEAN PrintMajorCode
    )
{
    CHAR irpMajorString[OPERATION_NAME_BUFFER_SIZE];
    CHAR irpMinorString[OPERATION_NAME_BUFFER_SIZE];
    CHAR formatBuf[OPERATION_NAME_BUFFER_SIZE*2];


    GetIrpName(MajorCode,MinorCode,FsControlCode,irpMajorString,irpMinorString);

    if (OutputFile) {

        sprintf(formatBuf, "%s  %s", irpMajorString, irpMinorString);
        fprintf(OutputFile, "\t%-50s", formatBuf);

    } else {

        if (PrintMajorCode) {

            printf("%-31s ", irpMajorString);

        } else {

            if (irpMinorString[0] != 0) {

                printf("                                                   %-35s\n",
                        irpMinorString);
            }
        }
    }
}

VOID
PrintFastIoType (
    FASTIO_TYPE Code,
    FILE *OutputFile
    )
{
    CHAR outputString[OPERATION_NAME_BUFFER_SIZE];

    GetFastioName(Code,outputString);

    if (OutputFile) {

        fprintf(OutputFile, "\t%-50s", outputString);

    } else {

        printf("%-31s ", outputString);
    }
}

#if WINVER >= 0x0501 /* See comment in DriverEntry */

VOID
PrintFsFilterOperation (
    UCHAR Operation,
    FILE *OutputFile
    )
{
    CHAR outputString[OPERATION_NAME_BUFFER_SIZE];

    GetFsFilterOperationName(Operation,outputString);

    if (OutputFile) {
    
        fprintf( OutputFile, "\t%-50s", outputString );
        
    } else {

        printf( "%-31s ", outputString );
    }
}

#endif

ULONG
FormatSystemTime (
    SYSTEMTIME *SystemTime,
    PWCHAR Buffer,
    ULONG BufferLength
)
/*++
Routine Name:

    FormatSystemTime

Routine Description:

    Formats the values in a SystemTime struct into the buffer
    passed in.  The resulting string is NULL terminated.  The format
    for the time is:
        hours:minutes:seconds:milliseconds

Arguments:

    SystemTime - the struct to format
    Buffer - the buffer to place the formatted time in
    BufferLength - the size of the buffer in characters

Return Value:

    The number of characters returned in Buffer.

--*/
{
    PWCHAR writePosition;
    ULONG returnLength = 0;

    writePosition = Buffer;

    if (BufferLength < TIME_BUFFER_LENGTH) {

        //
        // Buffer is too short so exit
        //

        return 0;
    }

    returnLength = swprintf( Buffer,
                             L"%02d:%02d:%02d:%03d",
                             SystemTime->wHour,
                             SystemTime->wMinute,
                             SystemTime->wSecond,
                             SystemTime->wMilliseconds);

    return returnLength;
}

VOID
IrpFileDump (
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_IRP RecordIrp,
    FILE *File,
    ULONG VerbosityFlags
)
/*++
Routine Name:

    IrpFileDump

Routine Description:

    Prints a Irp log record to the specified file.  The output is in a tab
    delimited format with the fields in the following order:

    SequenceNumber, OriginatingTime, CompletionTime, IrpMajor, IrpMinor,
    IrpFlags, NoCache, Paging I/O, Synchronous, Synchronous paging, FileName,
    ReturnStatus, FileName


Arguments:

    SequenceNumber - the sequence number for this log record
    Name - the name of the file that this Irp relates to
    NameLength - the length of Name in bytes
    RecordIrp - the Irp record to print
    File - the file to print to

Return Value:

    None.

--*/
{
    FILETIME    localTime;
    SYSTEMTIME  systemTime;
    WCHAR       time[TIME_BUFFER_LENGTH];

    fprintf(File, "I\t%08X", SequenceNumber);

    //
    // Convert originating time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordIrp->OriginatingTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        fprintf( File, "\t%-12S", time );

    } else {

        fprintf( File, "\t%-12S", TIME_ERROR );
    }

    //
    // Convert completion time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordIrp->CompletionTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );
    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        fprintf( File, "\t%-12S", time );

    } else {

        fprintf( File, "\t%-12S", TIME_ERROR );
    }

    fprintf( File, "\t%8x.%-4x ", RecordIrp->ProcessId, RecordIrp->ThreadId );

    PrintIrpCode( RecordIrp->IrpMajor, RecordIrp->IrpMinor, (ULONG)(ULONG_PTR)RecordIrp->Argument3, File, TRUE );

    fprintf( File, "\t%p", (PVOID)RecordIrp->DeviceObject );
    fprintf( File, "\t%p", (PVOID)RecordIrp->FileObject );
    fprintf( File, "\t%08lx:%08lx", RecordIrp->ReturnStatus, RecordIrp->ReturnInformation );

    //
    // Interpret set flags
    //

    fprintf( File, "\t%08lx ", RecordIrp->IrpFlags );
    fprintf( File, "%s", (RecordIrp->IrpFlags & IRP_NOCACHE) ? "N":"-" );
    fprintf( File, "%s", (RecordIrp->IrpFlags & IRP_PAGING_IO) ? "P":"-" );
    fprintf( File, "%s", (RecordIrp->IrpFlags & IRP_SYNCHRONOUS_API) ? "S":"-" );
    fprintf( File, "%s", (RecordIrp->IrpFlags & IRP_SYNCHRONOUS_PAGING_IO) ? "Y":"-" );

    if (FlagOn( VerbosityFlags, FS_VF_DUMP_PARAMETERS )) {

        fprintf( File,
                 "%p %p %p %p ", 
                 RecordIrp->Argument1,
                 RecordIrp->Argument2,
                 RecordIrp->Argument3,
                 RecordIrp->Argument4 );
        
        if (IRP_MJ_CREATE == RecordIrp->IrpMajor) {

            fprintf( File, "DesiredAccess->%08lx ", RecordIrp->DesiredAccess );
        }
    }

    fprintf( File, "\t%.*S", NameLength/sizeof(WCHAR), Name );
    fprintf( File, "\n" );
}

VOID
IrpScreenDump (
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_IRP RecordIrp,
    ULONG VerbosityFlags
)
/*++
Routine Name:

    IrpScreenDump

Routine Description:

    Prints a Irp log record to the screen in the following order:
    SequenceNumber, OriginatingTime, CompletionTime, IrpMajor, IrpMinor,
    IrpFlags, NoCache, Paging I/O, Synchronous, Synchronous paging,
    FileName, ReturnStatus, FileName

Arguments:

    SequenceNumber - the sequence number for this log record
    Name - the file name to which this Irp relates
    NameLength - the length of Name in bytes
    RecordIrp - the Irp record to print

Return Value:

    None.

--*/
{
    FILETIME localTime;
    SYSTEMTIME systemTime;
    WCHAR time[TIME_BUFFER_LENGTH];

    printf( "I %08X ", SequenceNumber );

    //
    // Convert originating time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordIrp->OriginatingTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        printf( "%-12S ", time );

    } else {

        printf( "%-12S ", TIME_ERROR );
    }

    //
    // Convert completion time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordIrp->CompletionTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        printf( "%-12S ", time );

    } else {

        printf( "%-12S ", TIME_ERROR );
    }

    printf( "%8x.%-4x ", RecordIrp->ProcessId, RecordIrp->ThreadId );

    PrintIrpCode( RecordIrp->IrpMajor, RecordIrp->IrpMinor, (ULONG)(ULONG_PTR)RecordIrp->Argument3, NULL, TRUE );

    printf( "%p ", (PVOID)RecordIrp->DeviceObject );
    printf( "%p ", (PVOID)RecordIrp->FileObject );
    printf( "%08lx:%08lx ", RecordIrp->ReturnStatus, RecordIrp->ReturnInformation );

    //
    // Interpret set flags
    //

    printf( "%08lx ", RecordIrp->IrpFlags );
    printf( "%s", (RecordIrp->IrpFlags & IRP_NOCACHE) ? "N":"-" );
    printf( "%s", (RecordIrp->IrpFlags & IRP_PAGING_IO) ? "P":"-" );
    printf( "%s", (RecordIrp->IrpFlags & IRP_SYNCHRONOUS_API) ? "S":"-" );
    printf( "%s ", (RecordIrp->IrpFlags & IRP_SYNCHRONOUS_PAGING_IO) ? "Y":"-" );

    if (FlagOn( VerbosityFlags, FS_VF_DUMP_PARAMETERS )) {

        printf( "%p %p %p %p  ", 
                RecordIrp->Argument1,
                RecordIrp->Argument2,
                RecordIrp->Argument3,
                RecordIrp->Argument4 );
        
        if (IRP_MJ_CREATE == RecordIrp->IrpMajor) {

            printf( "DesiredAccess->%08lx ", RecordIrp->DesiredAccess );
        }
    }

    printf( "%.*S", NameLength/sizeof(WCHAR), Name );
    printf( "\n" );
    PrintIrpCode( RecordIrp->IrpMajor, RecordIrp->IrpMinor, (ULONG)(ULONG_PTR)RecordIrp->Argument3, NULL, FALSE );
}

VOID
FastIoFileDump (
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FASTIO RecordFastIo,
    FILE *File
)
/*++
Routine Name:

    FastIoFileDump

Routine Description:

    Prints a FastIo log record to the specified file.  The output is in a tab
    delimited format with the fields in the following order:
    SequenceNumber, StartTime, CompletionTime, Fast I/O Type, FileName,
    Length, Wait, ReturnStatus, FileName

Arguments:

    SequenceNumber - the sequence number for this log record
    Name - the name of the file referenced by this Fast I/O operation
    NameLength - the length of name in bytes
    RecordFastIo - the FastIo record to print
    File - the file to print to

Return Value:

    None.

--*/
{
    SYSTEMTIME systemTime;
    FILETIME localTime;
    WCHAR time[TIME_BUFFER_LENGTH];

    fprintf( File, "F\t%08X", SequenceNumber );

    //
    // Convert start time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordFastIo->StartTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        fprintf( File, "\t%-12S", time );

    } else {

        fprintf( File, "\t%-12S", TIME_ERROR );
    }

    //
    // Convert completion time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordFastIo->CompletionTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        fprintf( File, "\t%-12S", time );

    } else {

        fprintf( File, "\t%-12S", TIME_ERROR );
    }

    fprintf( File, "\t%8x.%-4x ", RecordFastIo->ProcessId, RecordFastIo->ThreadId );

    PrintFastIoType( RecordFastIo->Type, File );

    fprintf( File, "\t%p", (PVOID)RecordFastIo->DeviceObject );
    fprintf( File, "\t%p", (PVOID)RecordFastIo->FileObject );
    fprintf( File, "\t%08x", RecordFastIo->ReturnStatus );

    fprintf( File, "\t%s", (RecordFastIo->Wait)?"T":"F" );
    fprintf( File, "\t%08x", RecordFastIo->Length );
    fprintf( File, "\t%016I64x ", RecordFastIo->FileOffset.QuadPart );

    fprintf( File, "\t%.*S", NameLength/sizeof(WCHAR), Name );
    fprintf( File, "\n" );
}

VOID
FastIoScreenDump (
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FASTIO RecordFastIo
)
/*++
Routine Name:

    FastIoScreenDump

Routine Description:

    Prints a FastIo log record to the screen in the following order:
    SequenceNumber, StartTime, CompletionTime, Fast I/O Type, FileName,
    Length, Wait, ReturnStatus, FileName

Arguments:

    SequenceNumber - the sequence number for this log record
    Name - the name of the file referenced by this Fast I/O operation
    NameLength - the length of name in bytes
    RecordIrp - the Irp record to print

Return Value:

    None.

--*/
{
    SYSTEMTIME systemTime;
    FILETIME localTime;
    WCHAR time[TIME_BUFFER_LENGTH];

    printf( "F %08X ", SequenceNumber );

    //
    // Convert start time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordFastIo->StartTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        printf( "%-12S ", time );

    } else {

        printf( "%-12S ", TIME_ERROR );
    }

    //
    // Convert completion time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordFastIo->CompletionTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        printf( "%-12S ", time );

    } else {

        printf( "%-12S ", TIME_ERROR );
    }

    printf( "%8x.%-4x ", RecordFastIo->ProcessId, RecordFastIo->ThreadId );

    PrintFastIoType( RecordFastIo->Type, NULL );

    printf( "%p ", (PVOID)RecordFastIo->DeviceObject );
    printf( "%p ", (PVOID)RecordFastIo->FileObject );
    printf( "%08x ", RecordFastIo->ReturnStatus );

    printf( "%s ", (RecordFastIo->Wait)?"T":"F" );
    printf( "%08x ", RecordFastIo->Length );
    printf( "%016I64x ", RecordFastIo->FileOffset.QuadPart );

    printf( "%.*S", NameLength/sizeof(WCHAR), Name );
    printf ("\n" );
}

#if WINVER >= 0x0501 /* See comment in DriverEntry */

VOID
FsFilterOperationFileDump (
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FS_FILTER_OPERATION RecordFsFilterOp,
    FILE *File
)
/*++
Routine Name:

    FsFilterOperationFileDump

Routine Description:

    Prints a FsFilterOperation log record to the specified file.  The output is in a tab
    delimited format with the fields in the following order:

    SequenceNumber, OriginatingTime, CompletionTime, ProcessId, ThreadId,
    Operation, FileObject, ReturnStatus, FileName

Arguments:

    SequenceNumber - the sequence number for this log record
    Name - the name of the file that this operation relates to
    NameLength - the length of Name in bytes
    RecordFsFilterOp - the FsFilter operation record to print
    File - the file to print to

Return Value:

    None.

--*/
{
    FILETIME    localTime;
    SYSTEMTIME  systemTime;
    WCHAR       time[TIME_BUFFER_LENGTH];

    fprintf(File, "O\t%08X", SequenceNumber);

    //
    // Convert originating time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordFsFilterOp->OriginatingTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        fprintf( File, "\t%-12S", time );

    } else {

        fprintf( File, "\t%-12S", TIME_ERROR );
    }

    //
    // Convert completion time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordFsFilterOp->CompletionTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );
    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        fprintf( File, "\t%-12S", time );

    } else {

        fprintf( File, "\t%-12S", TIME_ERROR );
    }

    //
    //  Output the process and thread id
    //

    fprintf( File, "\t%8x.%-4x ", RecordFsFilterOp->ProcessId, RecordFsFilterOp->ThreadId );

    //
    //  Output the FsFilter operation parameters
    //
    
    PrintFsFilterOperation( RecordFsFilterOp->FsFilterOperation, File );

    fprintf( File, "\t%p", (PVOID)RecordFsFilterOp->DeviceObject );
    fprintf( File, "\t%p", (PVOID)RecordFsFilterOp->FileObject );
    fprintf( File, "\t%08lx", RecordFsFilterOp->ReturnStatus );
    fprintf( File, "\t%.*S", NameLength/sizeof(WCHAR), Name );
    fprintf( File, "\n" );
}

VOID
FsFilterOperationScreenDump (
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FS_FILTER_OPERATION RecordFsFilterOp
)
/*++
Routine Name:

    FsFilterOperationScreenDump

Routine Description:

    Prints a FsFilterOperation log record to the screen in the following order:
    
    SequenceNumber, OriginatingTime, CompletionTime, ProcessId, ThreadId,
    Operation, FileObject, ReturnStatus, FileName

Arguments:

    SequenceNumber - the sequence number for this log record
    Name - the file name to which this Irp relates
    NameLength - the length of name in bytes
    RecordFsFilterOp - the FsFilterOperation record to print

Return Value:

    None.

--*/
{
    FILETIME localTime;
    SYSTEMTIME systemTime;
    WCHAR time[TIME_BUFFER_LENGTH];

    printf( "O %08X ", SequenceNumber );

    //
    // Convert originating time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordFsFilterOp->OriginatingTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        printf( "%-12S ", time );

    } else {

        printf( "%-12S ", TIME_ERROR );
    }

    //
    // Convert completion time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordFsFilterOp->CompletionTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        printf( "%-12S ", time );

    } else {

        printf( "%-12S ", TIME_ERROR );
    }

    printf( "%8x.%-4x ", RecordFsFilterOp->ProcessId, RecordFsFilterOp->ThreadId );

    PrintFsFilterOperation( RecordFsFilterOp->FsFilterOperation, NULL );

    //
    // Print FsFilter operation specific values.
    //

    printf( "%p ", (PVOID)RecordFsFilterOp->DeviceObject );
    printf( "%p ", (PVOID)RecordFsFilterOp->FileObject );
    printf( "%08lx ", RecordFsFilterOp->ReturnStatus );
    printf( "%.*S", NameLength/sizeof(WCHAR),Name );
    printf( "\n" );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\user\fspylog.h ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    log.h

Abstract:

    This module contains the structures and prototypes used by the user 
    program to retrieve and see the log records recorded by filespy.sys.
    
// @@BEGIN_DDKSPLIT
Author:

    Molly Brown (MollyBro) 21-Apr-1999

// @@END_DDKSPLIT
Environment:

    User mode


// @@BEGIN_DDKSPLIT
Revision History:

    Molly Brown (mollybro)         21-May-2002
        Modify sample to make it support running on Windows 2000 or later if
        built in the latest build environment and allow it to be built in W2K 
        and later build environments.

// @@END_DDKSPLIT
--*/
#ifndef __FSPYLOG_H__
#define __FSPYLOG_H__

#include <stdio.h>
#include "filespy.h"

#define BUFFER_SIZE     4096

typedef struct _LOG_CONTEXT{
    HANDLE  Device;
    BOOLEAN LogToScreen;
    BOOLEAN LogToFile;
    ULONG   VerbosityFlags;     //  FS_VF_DUMP_PARAMETERS, etc.
    FILE   *OutputFile;

    BOOLEAN NextLogToScreen;

    // For synchronizing shutting down of both threads
    BOOLEAN CleaningUp;
    HANDLE  ShutDown;
}LOG_CONTEXT, *PLOG_CONTEXT;

DWORD WINAPI 
RetrieveLogRecords(
    LPVOID lpParameter
);
                
VOID
IrpFileDump(
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_IRP RecordIrp,
    FILE *File,
    ULONG Verbosity
);

VOID
IrpScreenDump(
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_IRP RecordIrp,
    ULONG Verbosity
);

VOID
FastIoFileDump(
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FASTIO RecordFastIo,
    FILE *File
);

VOID
FastIoScreenDump(
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FASTIO RecordFastIo
);

#if WINVER >= 0x0501 /* See comment in DriverEntry */

VOID
FsFilterOperationFileDump (
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FS_FILTER_OPERATION RecordFsFilterOp,
    FILE *File
);

VOID
FsFilterOperationScreenDump (
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FS_FILTER_OPERATION RecordFsFilterOp
);

#endif

#define IRP_NOCACHE                     0x00000001
#define IRP_PAGING_IO                   0x00000002
#define IRP_SYNCHRONOUS_API             0x00000004
#define IRP_SYNCHRONOUS_PAGING_IO       0x00000040

#if WINVER >= 0x0501 
#define FS_FILTER_ACQUIRE_FOR_SECTION_SYNCHRONIZATION    (UCHAR)-1
#define FS_FILTER_RELEASE_FOR_SECTION_SYNCHRONIZATION    (UCHAR)-2
#define FS_FILTER_ACQUIRE_FOR_MOD_WRITE                  (UCHAR)-3
#define FS_FILTER_RELEASE_FOR_MOD_WRITE                  (UCHAR)-4
#define FS_FILTER_ACQUIRE_FOR_CC_FLUSH                   (UCHAR)-5
#define FS_FILTER_RELEASE_FOR_CC_FLUSH                   (UCHAR)-6
#endif

//
//  Verbosity flags.
//

#define FS_VF_DUMP_PARAMETERS           0x00000001

#endif __FSPYLOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\define.h ===
#pragma once

#define DEVICE_NAME_SIZE 64
#define NAME_SIZE 384


#define IRP_NOCACHE                     0x00000001
#define IRP_PAGING_IO                   0x00000002
#define IRP_SYNCHRONOUS_API             0x00000004
#define IRP_SYNCHRONOUS_PAGING_IO       0x00000040

#define FS_FILTER_ACQUIRE_FOR_SECTION_SYNCHRONIZATION    (UCHAR)-1
#define FS_FILTER_RELEASE_FOR_SECTION_SYNCHRONIZATION    (UCHAR)-2
#define FS_FILTER_ACQUIRE_FOR_MOD_WRITE                  (UCHAR)-3
#define FS_FILTER_RELEASE_FOR_MOD_WRITE                  (UCHAR)-4
#define FS_FILTER_ACQUIRE_FOR_CC_FLUSH                   (UCHAR)-5
#define FS_FILTER_RELEASE_FOR_CC_FLUSH                   (UCHAR)-6
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\drive.cpp ===
#include "global.h"
#include "protos.h"

#define DRIVE_STRING_LENGTH 512

USHORT BuildDriveTable(VOLINFO *pVolInfo)
{
    WCHAR sDriveString[DRIVE_STRING_LENGTH];
    PWCHAR sDrive;
    USHORT  index;

    GetLogicalDriveStrings(DRIVE_STRING_LENGTH, sDriveString);

    index = 0;

    for (sDrive = sDriveString; *sDrive != NULL; sDrive += 4, index ++) {

        pVolInfo[index].nDriveName = sDrive[0];
        pVolInfo[index].nType = GetDriveType( sDrive );
        pVolInfo[index].bHook = FALSE;
        
        switch (pVolInfo[index].nType) {
        case DRIVE_FIXED:
            pVolInfo[index].nImage = IMAGE_FIXEDDRIVE;
            break;

        case DRIVE_CDROM:
            pVolInfo[index].nImage = IMAGE_CDROMDRIVE;
            break;

        case DRIVE_REMOVABLE:
            pVolInfo[index].nImage = IMAGE_REMOVABLEDRIVE;
            break;

        case DRIVE_REMOTE:
            pVolInfo[index].nImage = IMAGE_REMOTEDRIVE;
            break;

        default:
            pVolInfo[index].nImage = IMAGE_UNKNOWNDRIVE;
            break;
        }
    }
    
    return index;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\declare.h ===
#pragma once

#include "define.h"

//
// This file contains all data structure declarations 
//


struct VolumeInfo
{
    char nDriveName;
    char sVolumeLable[20];
    char nType;
    char nHook;
    char nImage;
};

typedef struct VolumeInfo VOLINFO;
  
typedef ULONG FILE_ID;
typedef LONG NTSTATUS;

#define LOG_ORIGINATING_IRP  0x0001
#define LOG_COMPLETION_IRP   0x0002

/* The types FASTIO that are available for the Type field of the 
   RECORD_FASTIO structure. */
typedef enum {
    CHECK_IF_POSSIBLE = 1,
    READ,
    WRITE,
    QUERY_BASIC_INFO,
    QUERY_STANDARD_INFO,
    LOCK,
    UNLOCK_SINGLE,
    UNLOCK_ALL,
    UNLOCK_ALL_BY_KEY,
    DEVICE_CONTROL,
    ACQUIRE_FILE,
    RELEASE_FILE,
    DETACH_DEVICE,
    QUERY_NETWORK_OPEN_INFO,
    ACQUIRE_FOR_MOD_WRITE,
    MDL_READ,
    MDL_READ_COMPLETE,
    MDL_WRITE,
    MDL_WRITE_COMPLETE,
    READ_COMPRESSED,
    WRITE_COMPRESSED,
    MDL_READ_COMPLETE_COMPRESSED,
    PREPARE_MDL_WRITE,
    MDL_WRITE_COMPLETE_COMPRESSED,
    QUERY_OPEN,
    RELEASE_FOR_MOD_WRITE,
    ACQUIRE_FOR_CC_FLUSH,
    RELEASE_FOR_CC_FLUSH
} FASTIO_TYPE, *PFASTIO_TYPE;

typedef struct _RECORD_IRP 
{
    LARGE_INTEGER   OriginatingTime; // The time the IRP orginated
    LARGE_INTEGER   CompletionTime;  // The time the IRP was completed

    UCHAR        IrpMajor;        // From _IO_STACK_LOCATION
    UCHAR        IrpMinor;        // From _IO_STACK_LOCATION
    ULONG        IrpFlags;        // From _IRP (no cache, paging i/o, sync. 
                                  // api, assoc. irp, buffered i/o, etc.)                   
    FILE_ID      FileObject;      // From _IO_STACK_LOCATION (This is the 
                                  //     PFILE_OBJECT, but this isn't 
                                  //     available in user-mode)
    NTSTATUS     ReturnStatus;    // From _IRP->IoStatus.Status
    ULONG    ReturnInformation; // From _IRP->IoStatus.Information
    FILE_ID      ProcessId;
    FILE_ID      ThreadId;
} RECORD_IRP, *PRECORD_IRP;

typedef struct _RECORD_FASTIO 
{
    LARGE_INTEGER StartTime;     // Time Fast I/O request begins processing
    LARGE_INTEGER CompletionTime;// Time Fast I/O request completes processing
    FASTIO_TYPE   Type;          // Type of FASTIO operation
    FILE_ID       FileObject;    // Parameter to FASTIO call, should be 
                                 //     unique identifier in user space
    LARGE_INTEGER FileOffset;    // Offset into the file where the I/O is 
                                 //     taking place
    ULONG         Length;        // The length of data for the I/O operation
    BOOLEAN       Wait;          // Parameter to most FASTIO calls, signifies 
                                 //     if this operation can wait
    NTSTATUS      ReturnStatus;  // From IO_STATUS_BLOCK
    ULONG         Reserved;      // Reserved space
    FILE_ID       ProcessId;
    FILE_ID       ThreadId;
} RECORD_FASTIO, *PRECORD_FASTIO;


typedef union _RECORD_IO 
{
    RECORD_IRP      RecordIrp;
    RECORD_FASTIO   RecordFastIo;
} RECORD_IO, *PRECORD_IO;

typedef struct _LOG_RECORD 
{
    ULONG       Length;          // Length of record including header 
    ULONG       SequenceNumber;
    ULONG       RecordType;
    RECORD_IO   Record;
    WCHAR       Name[MAX_PATH];
} LOG_RECORD, *PLOG_RECORD;

typedef struct _PATTACHED_DEVICE
{
    BOOLEAN     LogState;
    WCHAR       DeviceName[DEVICE_NAME_SIZE];
} ATTACHED_DEVICE, *PATTACHED_DEVICE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\fastioview.cpp ===
// FastIoView.cpp : implementation file
//

#include "stdafx.h"
#include "FileSpyApp.h"
#include "FastIoView.h"

#include "global.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFastIoView

IMPLEMENT_DYNCREATE(CFastIoView, CListView)

CFastIoView::CFastIoView()
{
	pFastIoView = (LPVOID) this;
}

CFastIoView::~CFastIoView()
{
}


BEGIN_MESSAGE_MAP(CFastIoView, CListView)
	//{{AFX_MSG_MAP(CFastIoView)
	ON_WM_KEYDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFastIoView drawing

void CFastIoView::OnDraw(CDC* pDC)
{
    UNREFERENCED_PARAMETER( pDC );
    
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here
}

/////////////////////////////////////////////////////////////////////////////
// CFastIoView diagnostics+

#ifdef _DEBUG
void CFastIoView::AssertValid() const
{
	CListView::AssertValid();
}

void CFastIoView::Dump(CDumpContext& dc) const
{
	CListView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CFastIoView message handlers

BOOL CFastIoView::PreCreateWindow(CREATESTRUCT& cs) 
{
	// TODO: Add your specialized code here and/or call the base class
	cs.style |= LVS_REPORT | WS_HSCROLL | WS_VSCROLL;
	return CListView::PreCreateWindow(cs);
}

void CFastIoView::OnInitialUpdate() 
{
	CListView::OnInitialUpdate();
	
	// TODO: Add your specialized code here and/or call the base class
	//
	// Add the list header items
	//
	GetListCtrl().InsertColumn(0, L"S. No", LVCFMT_LEFT, 50);
	GetListCtrl().InsertColumn(1, L"Fast IO Entry", LVCFMT_LEFT, 100);
	GetListCtrl().InsertColumn(2, L"FileObject", LVCFMT_LEFT, 75);
	GetListCtrl().InsertColumn(3, L"Name", LVCFMT_LEFT, 250);
	GetListCtrl().InsertColumn(4, L"Offset", LVCFMT_LEFT, 100);
	GetListCtrl().InsertColumn(5, L"Length", LVCFMT_LEFT, 100);
	GetListCtrl().InsertColumn(6, L"Wait", LVCFMT_LEFT, 100);
	GetListCtrl().InsertColumn(7, L"Process:Thread", LVCFMT_LEFT, 100);
	GetListCtrl().InsertColumn(8, L"OrgnTime", LVCFMT_LEFT, 78);
	GetListCtrl().InsertColumn(9, L"CompTime", LVCFMT_LEFT, 78);
	GetListCtrl().InsertColumn(10, L"Return Status", LVCFMT_LEFT, 100);
}

void CFastIoView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	// TODO: Add your message handler code here and/or call default
	int ti, oldti;
	
	if (nChar == VK_DELETE)
	{
		ti = 0;
		oldti = 0;
		while(ti < GetListCtrl().GetItemCount())
		{
			if (GetListCtrl().GetItemState(ti, LVIS_SELECTED) & LVIS_SELECTED)
			{
				GetListCtrl().DeleteItem(ti);
				oldti = ti;
			}
			else
			{
				ti++;
			}
		}
		if (oldti < GetListCtrl().GetItemCount())
		{
			GetListCtrl().SetItemState(oldti, LVIS_SELECTED, LVIS_SELECTED);
		}
		else
		{
			GetListCtrl().SetItemState(oldti-1, LVIS_SELECTED, LVIS_SELECTED);
		}
	}
	
	CListView::OnKeyDown(nChar, nRepCnt, nFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\fastioview.h ===
#if !defined(AFX_FASTIOVIEW_H__9C4DA95F_33EF_42EF_B16F_81656827DECA__INCLUDED_)
#define AFX_FASTIOVIEW_H__9C4DA95F_33EF_42EF_B16F_81656827DECA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// FastIoView.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFastIoView view

class CFastIoView : public CListView
{
protected:
	CFastIoView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CFastIoView)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFastIoView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CFastIoView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CFastIoView)
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FASTIOVIEW_H__9C4DA95F_33EF_42EF_B16F_81656827DECA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\drvcomm.cpp ===
#include "global.h"
#include "protos.h"

#include "filespyview.h"
#include "fastioview.h"
#include "fsfilterview.h"
#include "leftview.h"
#include "filespyLib.h"

void DisplayIrpFields(CFileSpyView *pView, PLOG_RECORD pLog);
void DisplayFastIoFields(CFastIoView *pView, PLOG_RECORD pLog);
void DisplayFsFilterFields(CFsFilterView *pView, PLOG_RECORD pLog);

DWORD StartFileSpy(void)
{

    DWORD nBytesNeeded;
    CLeftView *pDriveView;

    pDriveView = (CLeftView *) pLeftView;

    // Open Service control manager
    hSCManager = OpenSCManager (NULL, NULL, SC_MANAGER_ALL_ACCESS) ;

    hService = OpenServiceW(hSCManager, FILESPY_SERVICE_NAME, FILESPY_SERVICE_ACCESS);
    if (hService == NULL)
    {
        DisplayError(GetLastError());
        return 0;
    }

    if (!QueryServiceStatusEx( hService,
                               SC_STATUS_PROCESS_INFO,
                               (UCHAR *)&ServiceInfo,
                               sizeof(ServiceInfo),
                               &nBytesNeeded)) 
    {
        DisplayError(GetLastError());
        CloseServiceHandle(hSCManager);
        CloseServiceHandle(hService);
        MessageBox(NULL, L"Unable to query Service status information", L"Startup Error", MB_OK|MB_ICONEXCLAMATION);
        return 0;
    }

    if(ServiceInfo.dwCurrentState != SERVICE_RUNNING) {
        //
        // Service hasn't been started yet, so try to start service
        //
        if (!StartService(hService, 0, NULL))
        {
            CloseServiceHandle(hSCManager);
            CloseServiceHandle(hService);
            MessageBox(NULL, L"Unable to start service", L"Startup Error", MB_OK|MB_ICONSTOP);
            return 0;
        }
    }
   
    //
    //  Open the device that is used to talk to FileSpy.
    //
    hDevice = CreateFile( FILESPY_W32_DEVICE_NAME,
                          GENERIC_READ | GENERIC_WRITE,
                          0,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL );
    if (hDevice == INVALID_HANDLE_VALUE) 
    {
        CloseServiceHandle(hSCManager);
        CloseServiceHandle(hService);
        MessageBox(NULL, L"Unable to open FileSpy device", L"Device Error", MB_OK|MB_ICONSTOP);
        return 0;
    }

    QueryDeviceAttachments();
    pDriveView->UpdateImage();

    // Create the polling thread
    hPollThread = CreateThread(NULL, 0, PollFileSpy, NULL, 0, &nPollThreadId);

    return 1;
}

DWORD ShutdownFileSpy(void)
{
    USHORT ti;

    for (ti = 0; ti < nTotalDrives; ti++)
    {
        if (VolInfo[ti].bHook)
        {
            DetachFromDrive( VolInfo[ti].nDriveName );
        }
    }
    CloseHandle(hDevice);
    CloseServiceHandle(hService);
    CloseServiceHandle(hSCManager);
    return 1;
}

BOOL QueryDeviceAttachments(void)
{
    WCHAR Buffer[BUFFER_SIZE];
    ULONG nBytesReturned;
    BOOL nReturnValue;
    USHORT ti;
    PATTACHED_DEVICE pDevice;

    nReturnValue = DeviceIoControl(hDevice, FILESPY_ListDevices, NULL, 0, Buffer, sizeof( Buffer ), &nBytesReturned, NULL);

    if (nReturnValue && nBytesReturned)
    {
        pDevice = (PATTACHED_DEVICE) Buffer;
        while ( ((char *)pDevice) < (((char *)Buffer) + nBytesReturned))
        {
            if (pDevice->LoggingOn)
            {
                //
                // Locate this drive in VolInfo and set its attachment status
                //
                for (ti = 0; ti < nTotalDrives; ti++)
                {
                    if (VolInfo[ti].nDriveName == towupper( pDevice->DeviceNames[0] ))
                    {
                        VolInfo[ti].bHook = 1;
                        VolInfo[ti].nImage += IMAGE_ATTACHSTART;
                    }
                }
            }
            pDevice++;
        }
    }       
    return nReturnValue;
}

DWORD AttachToDrive(WCHAR cDriveName)
{
    WCHAR sDriveString[5];
    DWORD nResult, nBytesReturned;

    wcscpy(sDriveString, L" :\0");
    sDriveString[0] = cDriveName;

    nResult = DeviceIoControl( hDevice, 
                               FILESPY_StartLoggingDevice, 
                               sDriveString, 
                               sizeof( sDriveString), 
                               NULL, 
                               0, 
                               &nBytesReturned, 
                               NULL);
    if (!nResult)
    {
        DisplayError(GetLastError());
        return 0;
    }
    return 1;
}

DWORD DetachFromDrive(WCHAR cDriveName)
{
    WCHAR sDriveString[5];
    DWORD nResult, nBytesReturned;

    wcscpy(sDriveString, L" :\0");
    sDriveString[0] = cDriveName;

    nResult = DeviceIoControl( hDevice, 
                               FILESPY_StopLoggingDevice, 
                               sDriveString, 
                               sizeof(sDriveString), 
                               NULL, 
                               0, 
                               &nBytesReturned, 
                               NULL );
    if (!nResult)
    {
        DisplayError(GetLastError());
        return 0;
    }
    return 1;
}

DWORD WINAPI PollFileSpy(LPVOID pParm)
{
    char pBuffer[BUFFER_SIZE];
    DWORD nBytesReturned, nResult;
    PLOG_RECORD pLog;
    CFileSpyView *pIrpView;
    CFastIoView *pFastView;
    CFsFilterView *pFilterView;    

    UNREFERENCED_PARAMETER( pParm );
    
    pIrpView = (CFileSpyView *) pSpyView;
    pFastView = (CFastIoView *) pFastIoView;
    pFilterView = (CFsFilterView *) pFsFilterView;
    
    while (1)
    {
        //
        // Start receiving log
        //
        nResult = DeviceIoControl(hDevice, FILESPY_GetLog, NULL, 0, pBuffer, \
                                    BUFFER_SIZE, &nBytesReturned, NULL);

		if (nResult) {

	        if (nBytesReturned > 0)
	        {
	            pLog = (PLOG_RECORD) pBuffer;

				while ((CHAR *) pLog < pBuffer + nBytesReturned) {

					switch (GET_RECORD_TYPE(pLog))
					{
					case RECORD_TYPE_IRP:
						DisplayIrpFields(pIrpView, pLog);
						break;
					case RECORD_TYPE_FASTIO:
						DisplayFastIoFields(pFastView, pLog);
						break;
				    case RECORD_TYPE_FS_FILTER_OP:
				        DisplayFsFilterFields(pFilterView, pLog);
				        break;
					default:
						//
						// Special handling required
						break;
					}

					//
					//  Move to the next LogRecord
					//

					pLog = (PLOG_RECORD) (((CHAR *) pLog) + pLog->Length);
				}
	        } 
	        else 
	        {
	            Sleep( 500 );
	        }
	        
	    } else {

	        return 1;

        }
    }
    return 1;
}

void DisplayIrpFields(CFileSpyView *pView, PLOG_RECORD pLog)
{
    INT nItem;
    CHAR cStr[NAME_SIZE], cMnStr[NAME_SIZE];
    WCHAR sStr[NAME_SIZE], sMnStr[NAME_SIZE];
    ULONG nameLength;

    if (IRPFilter[pLog->Record.RecordIrp.IrpMajor] == 0)
    {
        return;
    }
    else
    {
        if (nSuppressPagingIO && (pLog->Record.RecordIrp.IrpFlags & IRP_PAGING_IO || pLog->Record.RecordIrp.IrpFlags & IRP_SYNCHRONOUS_PAGING_IO))
        {
            return;
        }
    }

    nItem = pView->GetListCtrl().GetItemCount();

    //
    // nItem is 1 based but when we insert/delete items ListCtrl takes 0 based parameter
    // so automatically nItem gives an insertion number which is the last item
    //
    pView->GetListCtrl().InsertItem( nItem,L" " );
    pView->GetListCtrl().EnsureVisible( nItem, FALSE );

    //
    //  Sequence number
    //
    swprintf( sStr, L"%06X ", pLog->SequenceNumber );
    pView->GetListCtrl().SetItemText( nItem, 0, sStr );
    
    //
    //  Irp major and minor strings
    //
    
    GetIrpName( pLog->Record.RecordIrp.IrpMajor, 
                pLog->Record.RecordIrp.IrpMinor,
                (ULONG)(ULONG_PTR)pLog->Record.RecordIrp.Argument3,
                cStr, 
                cMnStr);
   
    MultiByteToWideChar(CP_ACP,0,cStr,-1,sStr,sizeof(sStr)/sizeof(WCHAR));
    MultiByteToWideChar(CP_ACP,0,cMnStr,-1,sMnStr,sizeof(sStr)/sizeof(WCHAR));

    pView->GetListCtrl().SetItemText( nItem, 1, sStr);
    pView->GetListCtrl().SetItemText( nItem, 2, sMnStr);
    
    //
    //  FileObject
    //
    swprintf( sStr, 
              L"%08X", 
              pLog->Record.RecordIrp.FileObject );
    pView->GetListCtrl().SetItemText( nItem, 3, sStr );

    //
    //  FileName
    //
    nameLength = pLog->Length - SIZE_OF_LOG_RECORD;
    swprintf( sStr, L"%.*s", nameLength/sizeof(WCHAR), pLog->Name );
    pView->GetListCtrl().SetItemText( nItem, 4, sStr );

    //
    //  Process and thread ids
    //
    swprintf( sStr, 
              L"%08X:%08X", 
              pLog->Record.RecordIrp.ProcessId, 
              pLog->Record.RecordIrp.ThreadId );
    pView->GetListCtrl().SetItemText( nItem, 5, sStr );

    //
    //  Originating time
    //
    GetTimeString( (FILETIME *) &pLog->Record.RecordIrp.OriginatingTime, sStr );
    pView->GetListCtrl().SetItemText( nItem, 6, sStr );

    //
    //  Completion time
    //
    GetTimeString( (FILETIME *) &pLog->Record.RecordIrp.CompletionTime, sStr );
    pView->GetListCtrl().SetItemText( nItem, 7, sStr );

    //
    //  Irp flags
    //
    GetFlagsString( pLog->Record.RecordIrp.IrpFlags, sStr );
    pView->GetListCtrl().SetItemText( nItem, 8, sStr );

    //
    //  Sequence number
    //
    swprintf( sStr, 
              L"%08lX:%08lX", 
              pLog->Record.RecordIrp.ReturnStatus, 
              pLog->Record.RecordIrp.ReturnInformation);
    pView->GetListCtrl().SetItemText( nItem, 9, sStr );
}

void DisplayFastIoFields(CFastIoView *pView, PLOG_RECORD pLog)
{
    INT nItem;
    CHAR cStr[NAME_SIZE];
    WCHAR sStr[NAME_SIZE];
    ULONG nameLength;

    if (FASTIOFilter[pLog->Record.RecordFastIo.Type] == 0)
    {
        return;
    }

    nItem = pView->GetListCtrl().GetItemCount();

    //
    // nItem is 1 based but when we insert/delete items ListCtrl takes 0 based parameter
    // so automatically nItem gives an insertion number which is the last item
    //
    pView->GetListCtrl().InsertItem( nItem, L" " );
    pView->GetListCtrl().EnsureVisible( nItem, FALSE );

    //
    //  Sequence number
    //
    swprintf( sStr, L"%06X ", pLog->SequenceNumber );
    pView->GetListCtrl().SetItemText( nItem, 0, sStr );

    //
    //  Fast IO type
    //
    GetFastioName( pLog->Record.RecordFastIo.Type, cStr );
    MultiByteToWideChar(CP_ACP,0,cStr,-1,sStr,sizeof(sStr)/sizeof(WCHAR));

    pView->GetListCtrl().SetItemText( nItem, 1, sStr );

    //
    //  FileObject
    //
    swprintf( sStr, L"%08X", pLog->Record.RecordFastIo.FileObject) ;
    pView->GetListCtrl().SetItemText( nItem, 2, sStr ); 

    //
    //  File name
    //
    nameLength = pLog->Length - SIZE_OF_LOG_RECORD;
    swprintf( sStr, L"%.*s", nameLength/sizeof(WCHAR), pLog->Name );
    pView->GetListCtrl().SetItemText( nItem, 3, sStr );

    //
    //  File offset
    //
    swprintf( sStr, L"%08X", pLog->Record.RecordFastIo.FileOffset );
    pView->GetListCtrl().SetItemText( nItem, 4, sStr );

    //
    //  File length
    //
    swprintf( sStr, L"%08X", pLog->Record.RecordFastIo.Length );
    pView->GetListCtrl().SetItemText( nItem, 5, sStr );
    
    //
    //  Fast IO can wait
    //
    if (pLog->Record.RecordFastIo.Wait)
    {
        pView->GetListCtrl().SetItemText(nItem, 6, L"True");
    }
    else
    {
        pView->GetListCtrl().SetItemText(nItem, 6, L"False");
    }
    
    //
    //  Thread and process ids
    //
    swprintf( sStr, 
             L"%08X:%08X", 
             pLog->Record.RecordFastIo.ProcessId, 
             pLog->Record.RecordFastIo.ThreadId );
    pView->GetListCtrl().SetItemText( nItem, 7, sStr );

    //
    //  Start time
    //
    GetTimeString( (FILETIME *) &pLog->Record.RecordFastIo.StartTime, 
                   sStr);
    pView->GetListCtrl().SetItemText( nItem, 8, sStr );

    //
    //  Completion time
    //
    GetTimeString( (FILETIME *) &pLog->Record.RecordFastIo.CompletionTime, sStr );
    pView->GetListCtrl().SetItemText( nItem, 9, sStr );

    //
    //  Return status
    //
    swprintf( sStr, L"%08X", pLog->Record.RecordFastIo.ReturnStatus );
    pView->GetListCtrl().SetItemText( nItem, 10, sStr );
}

void DisplayFsFilterFields(CFsFilterView *pView, PLOG_RECORD pLog)
{
    INT nItem;
    CHAR cStr[NAME_SIZE];
    WCHAR sStr[NAME_SIZE];
    ULONG nameLength;

    nItem = pView->GetListCtrl().GetItemCount();

    //
    // nItem is 1 based but when we insert/delete items ListCtrl takes 0 based parameter
    // so automatically nItem gives an insertion number which is the last item
    //
    pView->GetListCtrl().InsertItem( nItem, L" " );
    pView->GetListCtrl().EnsureVisible( nItem, FALSE );

    //
    //  Sequence number
    //
    swprintf( sStr, L"%06X ", pLog->SequenceNumber );
    pView->GetListCtrl().SetItemText( nItem, 0, sStr );

    //
    //  Fs Filter operation
    //
    
    GetFsFilterOperationName( pLog->Record.RecordFsFilterOp.FsFilterOperation, cStr );
    MultiByteToWideChar(CP_ACP,0,cStr,-1,sStr,sizeof(sStr)/sizeof(WCHAR));

    pView->GetListCtrl().SetItemText( nItem, 1, sStr );

    //
    //  FileObject
    //
    swprintf( sStr, L"%08X", pLog->Record.RecordFsFilterOp.FileObject );
    pView->GetListCtrl().SetItemText( nItem, 2, sStr );

    //
    //  File name
    //
    nameLength = pLog->Length - SIZE_OF_LOG_RECORD;
    swprintf( sStr, L"%.*s", nameLength/sizeof(WCHAR), pLog->Name );
    pView->GetListCtrl().SetItemText( nItem, 3, sStr );

    //
    //  Process and thread id
    //
    swprintf( sStr, 
              L"%08X:%08X", 
              pLog->Record.RecordFsFilterOp.ProcessId, 
              pLog->Record.RecordFsFilterOp.ThreadId );
    pView->GetListCtrl().SetItemText( nItem, 4, sStr );

    //
    //  Originating time
    //
    GetTimeString( (FILETIME *) &pLog->Record.RecordFsFilterOp.OriginatingTime, sStr );
    pView->GetListCtrl().SetItemText( nItem, 5, sStr );

    //
    //  Completion time
    //
    GetTimeString( (FILETIME *) &pLog->Record.RecordFsFilterOp.CompletionTime, sStr );
    pView->GetListCtrl().SetItemText( nItem, 6, sStr );

    //
    //  Return status
    //
    swprintf( sStr, L"%08X", pLog->Record.RecordFsFilterOp.ReturnStatus );
    pView->GetListCtrl().SetItemText( nItem, 7, sStr );
}

void GetFlagsString(DWORD nFlags, PWCHAR sStr)
{

    swprintf(sStr, L"%08lX ", nFlags);
    
    if (nFlags & IRP_NOCACHE)
    {
        wcscat( sStr, L"NOCACHE ");
    }
    if (nFlags & IRP_PAGING_IO)
    {
        wcscat(sStr, L"PAGEIO ");
    }
    if (nFlags & IRP_SYNCHRONOUS_API)
    {
        wcscat(sStr, L"SYNCAPI ");
    }
    if (nFlags & IRP_SYNCHRONOUS_PAGING_IO)
    {
        wcscat(sStr, L"SYNCPAGEIO");
    }
}


void GetTimeString(FILETIME *pFileTime, PWCHAR sStr)
{
    FILETIME LocalFileTime;
    SYSTEMTIME SystemTime;

    FileTimeToLocalFileTime(pFileTime, &LocalFileTime);
    FileTimeToSystemTime(&LocalFileTime, &SystemTime);

    swprintf( sStr, 
              L"%02d:%02d:%02d:%03d", 
              SystemTime.wHour, 
              SystemTime.wMinute,
              SystemTime.wSecond, 
              SystemTime.wMilliseconds);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\user\fspyuser.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    fspyUser.c

Abstract:

    This file contains the implementation for the main function of the 
    user application piece of FileSpy.  This function is responsible for
    controlling the command mode available to the user to control the 
    kernel mode driver.
    
Environment:

    User mode

// @@BEGIN_DDKSPLIT
Author:

    George Jenkins (GeorgeJe)                       

Revision History:                     

    Molly Brown (MollyBro) 21-Apr-1999
        Broke out the logging code and added command mode functionality.

    Neal Christiansen (nealch)     06-Jul-2001
        Updated cash statistics for use with contexts

// @@END_DDKSPLIT
--*/

#include <windows.h>                
#include <stdlib.h>
#include <stdio.h>
#include <winioctl.h>
#include <string.h>
#include <crtdbg.h>
#include "filespy.h"
#include "fspyLog.h"
#include "filespyLib.h"

#define SUCCESS              0
#define USAGE_ERROR          1
#define EXIT_INTERPRETER     2
#define EXIT_PROGRAM         4

#define INTERPRETER_EXIT_COMMAND1 "go"
#define INTERPRETER_EXIT_COMMAND2 "g"
#define PROGRAM_EXIT_COMMAND      "exit"

#define ToggleFlag(V, F) (V = (((V) & (F)) ? (V & (~F)) : (V | F)))

DWORD
InterpretCommand(
    int argc,
    char *argv[],
    PLOG_CONTEXT Context
);

BOOL
ListDevices(
    PLOG_CONTEXT Context
);

BOOL
ListHashStats(
    PLOG_CONTEXT Context
);

VOID
DisplayError (
   DWORD Code
   );

int _cdecl main(int argc, char *argv[])
{
    SC_HANDLE               hSCManager = NULL;
    SC_HANDLE               hService = NULL;
    SERVICE_STATUS_PROCESS  serviceInfo;
    DWORD                   bytesNeeded;
    HANDLE                  hDevice = NULL;
    BOOL                    bResult;
    DWORD                   result;
    ULONG                   threadId;
    HANDLE                  thread = NULL;
    LOG_CONTEXT             context;
    INT                     inputChar;


    //
    // Initialize handle in case of error
    //

    context.ShutDown = NULL;
    context.VerbosityFlags = 0;

    //
    // Start the kernel mode driver through the service manager
    //
    
    hSCManager = OpenSCManager (NULL, NULL, SC_MANAGER_ALL_ACCESS) ;
    if (NULL == hSCManager) {
        result = GetLastError();
        printf("ERROR opening Service Manager...\n");
        DisplayError( result );
        goto Main_Continue;
    }


    hService = OpenService( hSCManager,
                            FILESPY_SERVICE_NAME,
                            FILESPY_SERVICE_ACCESS);

    if (NULL == hService) {
        result = GetLastError();
        printf("ERROR opening FileSpy Service...\n");
        DisplayError( result );
        goto Main_Continue;
    }

    if (!QueryServiceStatusEx( hService,
                               SC_STATUS_PROCESS_INFO,
                               (UCHAR *)&serviceInfo,
                               sizeof(serviceInfo),
                               &bytesNeeded))
    {
        result = GetLastError();
        printf("ERROR querrying status of FileSpy Service...\n");
        DisplayError( result );
        goto Main_Continue;
    }

    if(serviceInfo.dwCurrentState != SERVICE_RUNNING) {
        //
        // Service hasn't been started yet, so try to start service
        //
        if (!StartService(hService, 0, NULL)) {
            result = GetLastError();
            printf("ERROR starting FileSpy service...\n");
            DisplayError( result );
            goto Main_Continue;
        }
    }
   

Main_Continue:
    printf("Hit [Enter] to begin command mode...\n");

    //
    //  Open the device that is used to talk to FileSpy.
    //
    printf("FileSpy:  Opening device...\n");
    
    hDevice = CreateFile( FILESPY_W32_DEVICE_NAME,
                          GENERIC_READ | GENERIC_WRITE,
                          0,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL);
    if (hDevice == INVALID_HANDLE_VALUE) {
        result = GetLastError();
        printf("ERROR opening device...\n");
        DisplayError( result );
        goto Main_Exit;
    }
    
    //
    //  Initialize the fields of the LOG_CONTEXT.
    //
    context.Device = hDevice;
    context.ShutDown = CreateSemaphore(
        NULL, 
        0, 
        1, 
        L"FileSpy shutdown");

    if (context.ShutDown == NULL) {
        //
        //  Insufficient memory for this semaphore, so shutdown.
        //

        printf( "ERROR insufficient memory\n" );
        goto Main_Exit;
    }
    
    context.CleaningUp = FALSE;
    context.LogToScreen = context.NextLogToScreen = TRUE;
    context.LogToFile = FALSE;
    context.OutputFile = NULL;

    //
    // Check the valid parameters for startup
    //
    if (argc > 1) {
        if (InterpretCommand(argc - 1, &(argv[1]), &context) == USAGE_ERROR) {
            goto Main_Exit;
        }
    }

    //
    // Propagate the /s switch to the variable that the logging
    // thread checks.
    //
    context.LogToScreen = context.NextLogToScreen;

    //
    // Check to see what devices we are attached to from
    // previous runs of this program.
    //
    bResult = ListDevices(&context);
    if (!bResult) {
        result = GetLastError();
        printf("ERROR listing devices...\n");
        DisplayError( result );
    }

    //
    // Create the thread to read the log records that are gathered
    // by filespy.sys.
    //
    printf("FileSpy:  Creating logging thread...\n");
    thread = CreateThread(
        NULL,
        0,
        RetrieveLogRecords,
        (LPVOID)&context,
        0,
        &threadId);
    if (!thread) {
        result = GetLastError();
        printf("ERROR creating logging thread...\n");
        DisplayError( result );
        goto Main_Exit;
    }

    while (inputChar = getchar()) {
        CHAR    commandLine[81];
        INT     parmCount, count, ch;
        CHAR  **parms;
        BOOLEAN newParm;
        DWORD   returnValue = SUCCESS;

        if (inputChar == '\n') {
            //
            // Start command interpreter.  First we must turn off logging
            // to screen if we are.  Also, remember the state of logging
            // to the screen, so that we can reinstate that when command
            // interpreter is finished.
            //
            context.NextLogToScreen = context.LogToScreen;
            context.LogToScreen = FALSE;

            while (returnValue != EXIT_INTERPRETER) {
                //
                // Print prompt
                //
                printf(">");

                //
                // Read in next line, keeping track of the number of parameters 
                // as you go
                //
                parmCount = 1;
                for (count = 0; 
                     (count < 80) && ((ch = getchar())!= '\n'); 
                     count++) {
                    commandLine[count] = (CHAR)ch;
                    if (ch == ' ') {
                        parmCount ++;
                    }
                }
                commandLine[count] = '\0';
    
                parms = (CHAR **)malloc(parmCount * sizeof(CHAR *));
    
                parmCount = 0;
                newParm = TRUE;
                for (count = 0; commandLine[count] != '\0'; count++) {
                    if (newParm) {
                        parms[parmCount] = &(commandLine[count]);
                        parmCount ++;
                    }
                    if (commandLine[count] == ' ' ) {
                        newParm = TRUE;
                    } else {
                        newParm = FALSE;
                    }
                }
    
                //
                // We've got our parameter count and parameter list, so
                // send it off to be interpreted.
                //
                returnValue = InterpretCommand(parmCount, parms, &context);
                free(parms);
                if (returnValue == EXIT_PROGRAM) {
                    // Time to stop the program
                    goto Main_Cleanup;
                }
            }

            // Set LogToScreen appropriately based on any commands seen
            context.LogToScreen = context.NextLogToScreen;

            if (context.LogToScreen) {
                printf("Should be logging to screen...\n");
            }
        }
    }

Main_Cleanup:
    //
    // Clean up the threads, then fall through to Main_Exit
    //

    printf("FileSpy:  Cleaning up...\n");
    // 
    // Set the Cleaning up flag to TRUE to notify other threads
    // that we are cleaning up
    //
    context.CleaningUp = TRUE;

    // 
    // Wait for everyone to shut down
    //
    WaitForSingleObject(context.ShutDown, INFINITE);
    if (context.LogToFile) {
        fclose(context.OutputFile);
    }

Main_Exit:
    // 
    // Clean up the data that is always around and exit
    //
    if(context.ShutDown) {
        CloseHandle(context.ShutDown);
    }
    if (thread) {
        CloseHandle(thread);
    }

    if(hSCManager) {
        CloseServiceHandle(hSCManager);
    }
    if(hService) {
        CloseServiceHandle(hService);
    }
    if (hDevice) {
        CloseHandle(hDevice);
    }
    
    printf("FileSpy:  All done\n");
    return 0;  

}


DWORD
InterpretCommand(
    int argc,
    char *argv[],
    PLOG_CONTEXT Context
)
{
    int         parmIndex;
    CHAR       *parm;      
    BOOL        bResult;
    DWORD       result;
    DWORD       returnValue = SUCCESS;
    CHAR        buffer[BUFFER_SIZE];
    DWORD       bufferLength;
    DWORD       bytesReturned;

    //
    // Interpret the command line parameters
    //
    for (parmIndex = 0; parmIndex < argc; parmIndex++) {
        parm = argv[parmIndex];
        if (parm[0] == '/') {
            //
            // Have the beginning of a switch
            //
            switch (parm[1]) {
            case 'a':
            case 'A':
                //
                // Attach to the specified drive letter
                //
                parmIndex++;
                if (parmIndex >= argc) {
                    //
                    // Not enough parameters
                    //
                    goto InterpretCommand_Usage;
                }
                parm = argv[parmIndex];
                printf("\tAttaching to %s\n", parm);
                bufferLength = MultiByteToWideChar(
                    CP_ACP,
                    MB_ERR_INVALID_CHARS,
                    parm,
                    -1,
                    (LPWSTR)buffer,
                    BUFFER_SIZE/sizeof(WCHAR));
                
                bResult = DeviceIoControl(
                    Context->Device,
                    FILESPY_StartLoggingDevice,
                    buffer,
                    bufferLength * sizeof(WCHAR),
                    NULL,
                    0,
                    &bytesReturned,
                    NULL);
                if (!bResult) {
                    result = GetLastError();
                    printf("ERROR attaching to device...\n");
                    DisplayError( result );
                }
                
                break;

            case 'd':
            case 'D':
                //
                // Detach to the specified drive letter
                //
                parmIndex++;
                if (parmIndex >= argc) {
                    //
                    // Not enough parameters
                    //
                    goto InterpretCommand_Usage;
                }
                parm = argv[parmIndex];
                printf("\tDetaching from %s\n", parm);
                bufferLength = MultiByteToWideChar(
                    CP_ACP,
                    MB_ERR_INVALID_CHARS,
                    parm,
                    -1,
                    (LPWSTR)buffer,
                    BUFFER_SIZE/sizeof(WCHAR));
                
                bResult = DeviceIoControl(
                    Context->Device,
                    FILESPY_StopLoggingDevice,
                    buffer,
                    bufferLength * sizeof(WCHAR),
                    NULL,
                    0,
                    &bytesReturned,
                    NULL);
                
                if (!bResult) {
                    result = GetLastError();
                    printf("ERROR detaching to device...\n");
                    DisplayError( result );
                }
                break;
            
            case 'h':
            case 'H':
                ListHashStats(Context);
                break;

            case 'l':
            case 'L':
                //
                // List all devices that are currently being monitored
                //
                bResult = ListDevices(Context);
                if (!bResult) {
                    result = GetLastError();
                    printf("ERROR listing devices...\n");
                    DisplayError( result );
                }
                
                break;

            case 's':
            case 'S':
                //
                // Output logging results to screen, save new value to
                // instate when command interpreter is exited.
                //
                if (Context->NextLogToScreen) {
                    printf("\tTurning off logging to screen\n");
                } else {
                    printf("\tTurning on logging to screen\n");
                }
                Context->NextLogToScreen = !Context->NextLogToScreen;
                break;

            case 'f':
            case 'F':
                //
                // Output logging results to file
                //
                if (Context->LogToFile) {
                    printf("\tStop logging to file \n");
                    Context->LogToFile = FALSE;
                    _ASSERT(Context->OutputFile);
                    fclose(Context->OutputFile);
                    Context->OutputFile = NULL;
                } else {
                    parmIndex++;
                    if (parmIndex >= argc) {
                        // Not enough parameters
                        goto InterpretCommand_Usage;
                    }
                    parm = argv[parmIndex];
                    Context->OutputFile = fopen(parm, "w");

                    if (Context->OutputFile == NULL) {
                        result = GetLastError();
                        printf("\nERROR opening \"%s\"...\n",parm);
                        DisplayError( result );

                        returnValue = USAGE_ERROR;
                        goto InterpretCommand_Exit;
                    }
                    
                    Context->LogToFile = TRUE;
                    printf("\tLog to file %s\n", parm);
                }
                break;

            case 'v':
            case 'V':
                //
                // Toggle the specified verbosity flag.
                //
                parmIndex++;
                if (parmIndex >= argc) {
                    //
                    // Not enough parameters
                    //
                    goto InterpretCommand_Usage;
                }
                parm = argv[parmIndex];
                switch(parm[0]) {
                case 'p':
                case 'P':
                    ToggleFlag( Context->VerbosityFlags, FS_VF_DUMP_PARAMETERS );
                    break;

                default:                    
                    //
                    // Invalid switch, goto usage
                    //
                    goto InterpretCommand_Usage;
                }
                break;

            default:
                //
                // Invalid switch, goto usage
                //
                goto InterpretCommand_Usage;
            }
        } else {
            //
            // Look for "go" or "g" to see if we should exit interpreter
            //
            if (!_strnicmp(
                    parm, 
                    INTERPRETER_EXIT_COMMAND1, 
                    sizeof(INTERPRETER_EXIT_COMMAND1))) {
                returnValue = EXIT_INTERPRETER;
                goto InterpretCommand_Exit;
            }
            if (!_strnicmp(
                    parm, 
                    INTERPRETER_EXIT_COMMAND2, 
                    sizeof(INTERPRETER_EXIT_COMMAND2))) {
                returnValue = EXIT_INTERPRETER;
                goto InterpretCommand_Exit;
            }
            //
            // Look for "exit" to see if we should exit program
            //
            if (!_strnicmp(
                    parm, 
                    PROGRAM_EXIT_COMMAND, 
                    sizeof(PROGRAM_EXIT_COMMAND))) {
                returnValue = EXIT_PROGRAM;
                goto InterpretCommand_Exit;
            }
            //
            // Invalid parameter
            //
            goto InterpretCommand_Usage;
        }
    }

InterpretCommand_Exit:
    return returnValue;

InterpretCommand_Usage:
    printf("Valid switches: [/a <drive>] [/d <drive>] [/h] [/l] [/s] [/f [<file name>] [/v <flag>]]\n"
           "\t[/a <drive>] attaches monitor to <drive>\n"
           "\t[/d <drive>] detaches monitor from <drive>\n"
           "\t[/h] print filename hash statistics\n"
           "\t[/l] lists all the drives the monitor is currently attached to\n"
           "\t[/s] turns on and off showing logging output on the screen\n"
           "\t[/f [<file name>]] turns on and off logging to the specified file\n"
           "\t[/v <flag>] toggles a verbosity flag.  Valid verbosity flags are:\n"
           "\t\tp (dump irp parameters)\n"
           "If you are in command mode,\n"
           "\t[go|g] will exit command mode\n"
           "\t[exit] will terminate this program\n"
           );
    returnValue = USAGE_ERROR;
    goto InterpretCommand_Exit;
}

BOOL
ListHashStats(
    PLOG_CONTEXT Context
)
{
    ULONG bytesReturned;
    BOOL returnValue;
    FILESPY_STATISTICS stats;

    returnValue = DeviceIoControl( Context->Device,
                                   FILESPY_GetStats,
                                   NULL,
                                   0,
                                   (CHAR *) &stats,
                                   BUFFER_SIZE,
                                   &bytesReturned,
                                   NULL );

    if (returnValue) {
        printf("         STATISTICS\n");
        printf("---------------------------------\n");
        printf("%-40s %8d\n", 
               "Name lookups",
               stats.TotalContextSearches);

        printf("%-40s %8d\n",
               "Name lookup hits",
               stats.TotalContextFound);

        if (stats.TotalContextSearches) {
            printf(
                "%-40s %8.2f%%\n",
                "Hit ratio",
                ((FLOAT) stats.TotalContextFound / (FLOAT) stats.TotalContextSearches) * 100.);
        }

        printf("%-40s %8d\n",
               "Names created",
               stats.TotalContextCreated);

        printf("%-40s %8d\n",
               "Temporary Names created",
               stats.TotalContextTemporary);

        printf("%-40s %8d\n",
               "Duplicate names created",
               stats.TotalContextDuplicateFrees);

        printf("%-40s %8d\n",
               "Context callback frees",
               stats.TotalContextCtxCallbackFrees);

        printf("%-40s %8d\n",
               "NonDeferred context frees",
               stats.TotalContextNonDeferredFrees);

        printf("%-40s %8d\n",
               "Deferred context frees",
               stats.TotalContextDeferredFrees);

        printf("%-40s %8d\n",
               "Delete all contexts",
               stats.TotalContextDeleteAlls);

        printf("%-40s %8d\n",
               "Contexts not supported",
               stats.TotalContextsNotSupported);

        printf("%-40s %8d\n",
               "Contexts not found attached to stream",
               stats.TotalContextsNotFoundInStreamList);
    }
    
    return returnValue;
}


BOOL
ListDevices(
    PLOG_CONTEXT Context
)
{
    CHAR             buffer[BUFFER_SIZE];
    ULONG            bytesReturned;
    BOOL             returnValue;

    returnValue = DeviceIoControl(
        Context->Device,
        FILESPY_ListDevices,
        NULL,
        0,
        buffer,
        BUFFER_SIZE,
        &bytesReturned,
        NULL);

    if (returnValue) {
        PATTACHED_DEVICE device = (PATTACHED_DEVICE) buffer;


        printf("DEVICE NAME                           | LOGGING STATUS\n");
        printf("------------------------------------------------------\n");

        if (bytesReturned == 0) {
            printf("No devices attached\n");
        } else {
            while ((BYTE *)device < buffer + bytesReturned) {
                printf(
                    "%-38S| %s\n", 
                    device->DeviceNames, 
                    (device->LoggingOn)?"ON":"OFF");
                device ++;
            }
        }
    }

    return returnValue;
}

VOID
DisplayError (
   DWORD Code
   )

/*++

Routine Description:

   This routine will display an error message based off of the Win32 error
   code that is passed in. This allows the user to see an understandable
   error message instead of just the code.

Arguments:

   Code - The error code to be translated.

Return Value:

   None.

--*/

{
   WCHAR                                    buffer[80] ;
   DWORD                                    count ;

   //
   // Translate the Win32 error code into a useful message.
   //

   count = FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM,
                          NULL,
                          Code,
                          0,
                          buffer,
                          sizeof( buffer )/sizeof( WCHAR ),
                          NULL) ;

   //
   // Make sure that the message could be translated.
   //

   if (count == 0) {

      printf("\nError could not be translated.\n Code: %d\n", Code) ;
      return;
   }
   else {

      //
      // Display the translated error.
      //

      printf("%S\n", buffer) ;
      return;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\filespydoc.cpp ===
// FileSpyDoc.cpp : implementation of the CFileSpyDoc class
//

#include "stdafx.h"
#include "FileSpyApp.h"

#include "global.h"
#include "FileSpyDoc.h"
#include "filespyview.h"
#include "fastioview.h"
#include "fsfilterview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFileSpyDoc

IMPLEMENT_DYNCREATE(CFileSpyDoc, CDocument)

BEGIN_MESSAGE_MAP(CFileSpyDoc, CDocument)
	//{{AFX_MSG_MAP(CFileSpyDoc)
	ON_COMMAND(ID_FILE_SAVE, OnFileSave)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFileSpyDoc construction/destruction

CFileSpyDoc::CFileSpyDoc()
{
	// TODO: add one-time construction code here

}

CFileSpyDoc::~CFileSpyDoc()
{
}

BOOL CFileSpyDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	// TODO: add reinitialization code here
	// (SDI documents will reuse this document)

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CFileSpyDoc serialization

void CFileSpyDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CFileSpyDoc diagnostics

#ifdef _DEBUG
void CFileSpyDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CFileSpyDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CFileSpyDoc commands


void CFileSpyDoc::OnFileSave() 
{
	// TODO: Add your command handler code here
	OPENFILENAME OpenFileName;
	WCHAR sFilePath[1024];
	WCHAR sFileName[1024];
	WCHAR sFileStr[2048];
	WCHAR sStr[1024];
	WCHAR CRLF[3];
	WCHAR TAB[1];
	HANDLE hFile;
	long nSaved;
	int nMBRet, ti, nCount, tj;
	CFileSpyView *pIrp = (CFileSpyView *) pSpyView;
	CFastIoView *pFast = (CFastIoView *) pFastIoView;
	CFsFilterView *pFsFilter = (CFsFilterView *) pFsFilterView;
	DWORD nBytesWritten;


	if (pIrp->GetListCtrl().GetItemCount() == 0 && pFast->GetListCtrl().GetItemCount() == 0)
	{
		MessageBox(NULL, L"Nothing to save", L"FileSpy", MB_OK);
		return;
	}

	wcscpy(sFilePath, L"FILESPY.LOG");
	sFileName[0] = 0;
	OpenFileName.lStructSize = sizeof(OpenFileName);
	OpenFileName.hwndOwner = AfxGetMainWnd()->m_hWnd;
	OpenFileName.hInstance = AfxGetInstanceHandle();
	OpenFileName.Flags = OFN_HIDEREADONLY|OFN_NOREADONLYRETURN|OFN_PATHMUSTEXIST;
	OpenFileName.lpstrFilter = NULL;
	OpenFileName.lpstrCustomFilter = NULL;
	OpenFileName.nFilterIndex = 0;
	OpenFileName.lpstrFileTitle = sFileName;
	OpenFileName.nMaxFileTitle = 512;
	OpenFileName.lpstrInitialDir = NULL;
	OpenFileName.lpstrTitle = NULL;
	OpenFileName.lpstrDefExt = NULL;
	OpenFileName.lpfnHook = NULL;
	OpenFileName.lpstrFile = sFilePath;
	OpenFileName.nMaxFile = 512;

	if (!GetSaveFileName(&OpenFileName))
	{
		return;
	}
	hFile = CreateFile(sFilePath, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile != INVALID_HANDLE_VALUE)
	{
		nMBRet = MessageBox(NULL, L"The selected file already exists. Do you want to append to it?", L"FileSpy", MB_YESNOCANCEL);
		if (nMBRet == IDCANCEL)
		{
			return;
		}
		if (nMBRet == IDYES)
		{
			SetFilePointer(hFile, 0, NULL, FILE_END);
		}
		else
		{
			CloseHandle(hFile);
			hFile = CreateFile(sFilePath, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		}
	}
	else
	{
		hFile = CreateFile(sFilePath, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	}
	if (hFile == INVALID_HANDLE_VALUE)
	{
		MessageBox(NULL, L"File creation error", L"FileSpy - Error", MB_OK);
		return;
	}

	CRLF[0] = 0x0D;
	CRLF[1] = 0x0A;
	CRLF[2] = 0;
	TAB[0] = 0x9;
	TAB[1] = 0;

	WriteFile(hFile, CRLF, 2, &nBytesWritten, NULL);
	//
	// Write IRP header string
	//


	//
	// Start saving the traces now
	// First save IRP traces and then FASTIO
	//
	nCount = pIrp->GetListCtrl().GetItemCount();
	for (ti = 0; ti < nCount; ti++)
	{
		pIrp->GetListCtrl().GetItemText(ti, 0, sStr, 1024);
		wcscpy(sFileStr, sStr);
		for (tj = 1; tj < 10; tj++)
		{
			wcscat(sFileStr, TAB);
			pIrp->GetListCtrl().GetItemText(ti, tj, sStr, 1024);
			wcscat(sFileStr, sStr);
		}
		wcscat(sFileStr, CRLF);
		WriteFile(hFile, sFileStr, wcslen(sFileStr), &nBytesWritten, NULL);
	}
	nSaved = nCount;

	//
	// FastIO View now
	//
	nCount = pFast->GetListCtrl().GetItemCount();
	for (ti = 0; ti < nCount; ti++)
	{
		pFast->GetListCtrl().GetItemText(ti, 0, sStr, 1024);
		wcscpy(sFileStr, sStr);
		for (tj = 1; tj < 11; tj++)
		{
			wcscat(sFileStr, TAB);
			pFast->GetListCtrl().GetItemText(ti, tj, sStr, 1024);
			wcscat(sFileStr, sStr);
		}
		wcscat(sFileStr, CRLF);
		WriteFile(hFile, sFileStr, wcslen(sFileStr), &nBytesWritten, NULL);
	}
	CloseHandle(hFile);
	nSaved += nCount;
	swprintf(sStr, L"%ld traces saved", nSaved);
	MessageBox(NULL, sStr, L"FileSpy", MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\filespyapp.h ===
// FileSpy.h : main header file for the FILESPY application
//

#if !defined(AFX_FILESPY_H__177A9CDF_B3B4_41D6_B48C_79D0F309D152__INCLUDED_)
#define AFX_FILESPY_H__177A9CDF_B3B4_41D6_B48C_79D0F309D152__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CFileSpyApp:
// See FileSpy.cpp for the implementation of this class
//

class CFileSpyApp : public CWinApp
{
public:
	CFileSpyApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFileSpyApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation
	//{{AFX_MSG(CFileSpyApp)
	afx_msg void OnAppAbout();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FILESPY_H__177A9CDF_B3B4_41D6_B48C_79D0F309D152__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\filespydoc.h ===
// FileSpyDoc.h : interface of the CFileSpyDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_FILESPYDOC_H__C8DFCE29_6D9F_4261_A9AA_2306759C3BB7__INCLUDED_)
#define AFX_FILESPYDOC_H__C8DFCE29_6D9F_4261_A9AA_2306759C3BB7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CFileSpyDoc : public CDocument
{
protected: // create from serialization only
	CFileSpyDoc();
	DECLARE_DYNCREATE(CFileSpyDoc)

// Attributes
public:
	LPVOID pBuffer;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFileSpyDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CFileSpyDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CFileSpyDoc)
	afx_msg void OnFileSave();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FILESPYDOC_H__C8DFCE29_6D9F_4261_A9AA_2306759C3BB7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\filespy.cpp ===
// FileSpy.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "FileSpyApp.h"

#include "MainFrm.h"
#include "FileSpyDoc.h"
#include "LeftView.h"

#define  MAINMODULE
#include "global.h"
#undef   MAINMODULE

#include "protos.h"
#include "init.cpp"
#include "drvcomm.cpp"
#include "support.cpp"
#include "drive.cpp"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFileSpyApp

BEGIN_MESSAGE_MAP(CFileSpyApp, CWinApp)
	//{{AFX_MSG_MAP(CFileSpyApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFileSpyApp construction

CFileSpyApp::CFileSpyApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CFileSpyApp object

CFileSpyApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CFileSpyApp initialization

BOOL CFileSpyApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Change the registry key under which our settings are stored.
	// TODO: You should modify this string to be something appropriate
	// such as the name of your company or organization.
	SetRegistryKey(_T("Local AppWizard-Generated Applications"));

	LoadStdProfileSettings(0);  // Load standard INI file options (including MRU)


	//
	// Program Initialization
	//
	ProgramInit();


	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
		RUNTIME_CLASS(CFileSpyDoc),
		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
		RUNTIME_CLASS(CLeftView));
	AddDocTemplate(pDocTemplate);

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo)) {
		return FALSE;
    }

	if (!StartFileSpy()) {
	    return FALSE;
	}

	//
	//Set main window title
	//
	m_pMainWnd->SetWindowText(L"FileSpy");


	// The one and only window has been initialized, so show and update it.
	m_pMainWnd->ShowWindow(SW_SHOW);
	m_pMainWnd->UpdateWindow();

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CFileSpyApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CFileSpyApp message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\filespyview.cpp ===
// FileSpyView.cpp : implementation of the CFileSpyView class
//

#include "stdafx.h"
#include "FileSpyApp.h"

#include "FileSpyDoc.h"
#include "FileSpyView.h"

#include "global.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFileSpyView

IMPLEMENT_DYNCREATE(CFileSpyView, CListView)

BEGIN_MESSAGE_MAP(CFileSpyView, CListView)
	//{{AFX_MSG_MAP(CFileSpyView)
	ON_WM_KEYDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFileSpyView construction/destruction

CFileSpyView::CFileSpyView()
{
	// TODO: add construction code here
	pSpyView = (LPVOID) this;
}

CFileSpyView::~CFileSpyView()
{
}

BOOL CFileSpyView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs
	cs.style |= LVS_REPORT | WS_HSCROLL | WS_VSCROLL;
	return CListView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CFileSpyView drawing

void CFileSpyView::OnDraw(CDC* pDC)
{
    UNREFERENCED_PARAMETER( pDC );
    
	CFileSpyDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	CListCtrl& refCtrl = GetListCtrl();
	refCtrl.InsertItem(0, L"Item!");
	// TODO: add draw code for native data here
}

void CFileSpyView::OnInitialUpdate()
{
	CListView::OnInitialUpdate();


	// TODO: You may populate your ListView with items by directly accessing
	//  its list control through a call to GetListCtrl().

	//
	// Add the list header items
	//
	GetListCtrl().InsertColumn(0, L"S. No", LVCFMT_LEFT, 50);
	GetListCtrl().InsertColumn(1, L"Major Code", LVCFMT_LEFT, 100);
	GetListCtrl().InsertColumn(2, L"Minor Code", LVCFMT_LEFT, 100);
	GetListCtrl().InsertColumn(3, L"FileObject", LVCFMT_LEFT, 75);
	GetListCtrl().InsertColumn(4, L"Name", LVCFMT_LEFT, 250);
	GetListCtrl().InsertColumn(5, L"Process:Thread", LVCFMT_LEFT, 100);
	GetListCtrl().InsertColumn(6, L"OrgnTime", LVCFMT_LEFT, 78);
	GetListCtrl().InsertColumn(7, L"CompTime", LVCFMT_LEFT, 78);
	GetListCtrl().InsertColumn(8, L"Flags", LVCFMT_LEFT, 175);
	GetListCtrl().InsertColumn(9, L"Status:RetInfo", LVCFMT_LEFT, 100);
}

/////////////////////////////////////////////////////////////////////////////
// CFileSpyView diagnostics

#ifdef _DEBUG
void CFileSpyView::AssertValid() const
{
	CListView::AssertValid();
}

void CFileSpyView::Dump(CDumpContext& dc) const
{
	CListView::Dump(dc);
}

CFileSpyDoc* CFileSpyView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CFileSpyDoc)));
	return (CFileSpyDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CFileSpyView message handlers
void CFileSpyView::OnStyleChanged(int nStyleType, LPSTYLESTRUCT lpStyleStruct)
{
	//TODO: add code to react to the user changing the view style of your window
	UNREFERENCED_PARAMETER( nStyleType );
	UNREFERENCED_PARAMETER( lpStyleStruct );
}


void CFileSpyView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint) 
{
	// TODO: Add your specialized code here and/or call the base class
	UNREFERENCED_PARAMETER( pSender );
	UNREFERENCED_PARAMETER( lHint );
	UNREFERENCED_PARAMETER( pHint );
}


void CFileSpyView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	// TODO: Add your message handler code here and/or call default
	int ti, oldti;
	
	if (nChar == VK_DELETE)
	{
		ti = 0;
		oldti = 0;
		while(ti < GetListCtrl().GetItemCount())
		{
			if (GetListCtrl().GetItemState(ti, LVIS_SELECTED) & LVIS_SELECTED)
			{
				GetListCtrl().DeleteItem(ti);
				oldti = ti;
			}
			else
			{
				ti++;
			}
		}
		if (oldti < GetListCtrl().GetItemCount())
		{
			GetListCtrl().SetItemState(oldti, LVIS_SELECTED, LVIS_SELECTED);
		}
		else
		{
			GetListCtrl().SetItemState(oldti-1, LVIS_SELECTED, LVIS_SELECTED);
		}
	}
	CListView::OnKeyDown(nChar, nRepCnt, nFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\filespyview.h ===
// FileSpyView.h : interface of the CFileSpyView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_FILESPYVIEW_H__D19318D3_9763_4FDC_93B8_535C29C978B1__INCLUDED_)
#define AFX_FILESPYVIEW_H__D19318D3_9763_4FDC_93B8_535C29C978B1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CFileSpyView : public CListView
{
protected: // create from serialization only
	CFileSpyView();
	DECLARE_DYNCREATE(CFileSpyView)

// Attributes
public:
	CFileSpyDoc* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFileSpyView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual void OnInitialUpdate(); // called first time after construct
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CFileSpyView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CFileSpyView)
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
	afx_msg void OnStyleChanged(int nStyleType, LPSTYLESTRUCT lpStyleStruct);
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in FileSpyView.cpp
inline CFileSpyDoc* CFileSpyView::GetDocument()
   { return (CFileSpyDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FILESPYVIEW_H__D19318D3_9763_4FDC_93B8_535C29C978B1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\filterdlg.cpp ===
// FilterDlg.cpp : implementation file
//

#include "stdafx.h"
#include "FileSpyApp.h"
#include "FilterDlg.h"
#include "filespyLib.h"

#include "global.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFilterDlg dialog
#define OFFSET_FIRST	2
#define OFFSET_OTHER	6


CFilterDlg::CFilterDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CFilterDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFilterDlg)
	//}}AFX_DATA_INIT
	m_pImageList = new CImageList;
	m_pImageList->Create(IDB_STATEIMAGELIST,16,0,RGB(255,255,255));
}

CFilterDlg::~CFilterDlg(void)
{
	if (m_pImageList)
	{
		delete m_pImageList;
	}
}


void CFilterDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFilterDlg)
	DDX_Control(pDX, IDC_SUPPRESSPAGEIO, m_SuppressPageIo);
	DDX_Control(pDX, IDC_IRPLIST, m_IrpList);
	DDX_Control(pDX, IDC_FASTIOLIST, m_FastList);
	//}}AFX_DATA_MAP
}

LPCTSTR CFilterDlg::MakeShortString(CDC* pDC, LPCTSTR lpszLong, int nColumnLen, int nOffset)
{
	static const _TCHAR szThreeDots[] = _T("...");

	int nStringLen = lstrlen(lpszLong);

	if(nStringLen == 0 ||
		(pDC->GetTextExtent(lpszLong, nStringLen).cx + nOffset) <= nColumnLen)
	{
		return(lpszLong);
	}

	static _TCHAR szShort[MAX_PATH];

	lstrcpy(szShort,lpszLong);
	int nAddLen = pDC->GetTextExtent(szThreeDots,sizeof(szThreeDots)).cx;

	for(int i = nStringLen-1; i > 0; i--)
	{
		szShort[i] = 0;
		if((pDC->GetTextExtent(szShort, i).cx + nOffset + nAddLen)
			<= nColumnLen)
		{
			break;
		}
	}

	lstrcat(szShort, szThreeDots);
	return(szShort);
}

BEGIN_MESSAGE_MAP(CFilterDlg, CDialog)
	//{{AFX_MSG_MAP(CFilterDlg)
	ON_BN_CLICKED(IDC_IRPSELECTALL, OnIrpselectall)
	ON_BN_CLICKED(IDC_FASTIOSELECTALL, OnFastioselectall)
	ON_NOTIFY(NM_CLICK, IDC_IRPLIST, OnClickIrplist)
	ON_NOTIFY(NM_CLICK, IDC_FASTIOLIST, OnClickFastiolist)
	ON_BN_CLICKED(IDC_FASTIODESELECTALL, OnFastiodeselectall)
	ON_BN_CLICKED(IDC_IRPDESELECTALL, OnIrpdeselectall)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFilterDlg message handlers


BOOL CFilterDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	// TODO: Add extra initialization here
	int ti;
	LV_COLUMN ListColumn;
	LV_ITEM ListItem;

	m_IrpList.SetImageList(m_pImageList, LVSIL_STATE);
	m_FastList.SetImageList(m_pImageList, LVSIL_STATE);

	ListColumn.mask = LVCF_TEXT|LVCF_WIDTH;
	ListColumn.pszText = L"IRP Codes";
	ListColumn.cx = 145;
	m_IrpList.InsertColumn(0, &ListColumn);

	ListColumn.mask = LVCF_TEXT|LVCF_WIDTH;
	ListColumn.pszText = L"FASTIO Entries";
	ListColumn.cx = 145;
	m_FastList.InsertColumn(0, &ListColumn);


	// Create IRP list
	for (ti = 0; ti < IRP_MJ_MAXIMUM_FUNCTION+1; ti++)
	{
		ListItem.mask = LVIF_TEXT|LVIF_STATE;
		ListItem.iItem = m_IrpList.GetItemCount();
		ListItem.iSubItem = 0;
		ListItem.iImage = 1;
		if (IRPFilter[ti])
		{
			ListItem.state = INDEXTOSTATEIMAGEMASK(2);
		}
		else
		{
			ListItem.state = INDEXTOSTATEIMAGEMASK(1);
		}
		ListItem.stateMask = LVIS_STATEIMAGEMASK;
		ListItem.pszText = IrpNameList[ti];
		m_IrpList.InsertItem(&ListItem);
	}
	
	// Create FASTIO List
	for (ti = 0; ti < FASTIO_MAX_OPERATION; ti++)
	{
		ListItem.mask = LVIF_TEXT|LVIF_STATE;
		ListItem.iItem = m_FastList.GetItemCount();
		ListItem.iSubItem = 0;
		ListItem.iImage = 1;
		if (FASTIOFilter[ti])
		{
			ListItem.state = INDEXTOSTATEIMAGEMASK(2);
		}
		else
		{
			ListItem.state = INDEXTOSTATEIMAGEMASK(1);
		}
		ListItem.stateMask = LVIS_STATEIMAGEMASK;
		ListItem.pszText = FastIoNameList[ti];
		m_FastList.InsertItem(&ListItem);
	}

	// Set SupressPagingIO state
	if (nSuppressPagingIO)
	{
		m_SuppressPageIo.SendMessage(BM_SETCHECK, BST_CHECKED, 0);
	}
	else
	{
		m_SuppressPageIo.SendMessage(BM_SETCHECK, BST_UNCHECKED, 0);
	}
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CFilterDlg::OnIrpselectall() 
{
	// TODO: Add your control notification handler code here
	int ti;
	
	for (ti = 0; ti < IRP_MJ_MAXIMUM_FUNCTION+1; ti++)
	{
		m_IrpList.SetItemState(ti, INDEXTOSTATEIMAGEMASK(2), LVIS_STATEIMAGEMASK);
	}
}

void CFilterDlg::OnFastioselectall() 
{
	// TODO: Add your control notification handler code here
	int ti;
	
	for (ti = 0; ti < FASTIO_MAX_OPERATION; ti++)
	{
		m_FastList.SetItemState(ti, INDEXTOSTATEIMAGEMASK(2), LVIS_STATEIMAGEMASK);
	}
}

void CFilterDlg::OnClickIrplist(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// TODO: Add your control notification handler code here
	LVHITTESTINFO hti;
	int nHit;
	UINT State;
	CRect rect;
	CPoint point;
	RECT rectWindow;

	UNREFERENCED_PARAMETER( pNMHDR );
	
	*pResult = 0;

	GetCursorPos(&point);
	m_IrpList.GetWindowRect(&rectWindow);
	point.x = point.x - rectWindow.left;
	point.y = point.y - rectWindow.top;

	hti.pt.x = point.x;
	hti.pt.y = point.y;

	
	nHit = m_IrpList.HitTest(&hti);

	if (nHit == -1)
	{
		return;
	}

	if (!(hti.flags & LVHT_ONITEMSTATEICON))
	{
		return;
	}
	else
	{
		State = m_IrpList.GetItemState(nHit, LVIS_STATEIMAGEMASK);
		if (State == 8192)
		{
			m_IrpList.SetItemState(nHit, INDEXTOSTATEIMAGEMASK(1), LVIS_STATEIMAGEMASK);
			m_IrpList.GetItemRect(nHit, &rect, LVIR_BOUNDS);
			::InvalidateRect(m_IrpList.m_hWnd, LPRECT(rect), TRUE);
		}
		else
		{
			m_IrpList.SetItemState(nHit, INDEXTOSTATEIMAGEMASK(2), LVIS_STATEIMAGEMASK);
		}
	}
}

void CFilterDlg::OnClickFastiolist(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// TODO: Add your control notification handler code here
	LVHITTESTINFO hti;
	int nHit;
	UINT State;
	CRect rect;
	CPoint point;
	RECT rectWindow;

	UNREFERENCED_PARAMETER( pNMHDR );
	
	*pResult = 0;

	GetCursorPos(&point);
	m_FastList.GetWindowRect(&rectWindow);
	point.x = point.x - rectWindow.left;
	point.y = point.y - rectWindow.top;

	hti.pt.x = point.x;
	hti.pt.y = point.y;

	
	nHit = m_FastList.HitTest(&hti);

	if (nHit == -1)
	{
		return;
	}

	if (!(hti.flags & LVHT_ONITEMSTATEICON))
	{
		return;
	}
	else
	{
		State = m_FastList.GetItemState(nHit, LVIS_STATEIMAGEMASK);
		if (State == 8192)
		{
			m_FastList.SetItemState(nHit, INDEXTOSTATEIMAGEMASK(1), LVIS_STATEIMAGEMASK);
			m_FastList.GetItemRect(nHit, &rect, LVIR_BOUNDS);
			::InvalidateRect(m_FastList.m_hWnd, LPRECT(rect), TRUE);
		}
		else
		{
			m_FastList.SetItemState(nHit, INDEXTOSTATEIMAGEMASK(2), LVIS_STATEIMAGEMASK);
		}
	}
}

void CFilterDlg::OnOK() 
{
	// TODO: Add extra validation here
	int ti;

	for (ti = 0; ti < IRP_MJ_MAXIMUM_FUNCTION+1; ti++)
	{
		if (m_IrpList.GetItemState(ti, LVIS_STATEIMAGEMASK) == 8192)
		{
			IRPFilter[ti] = 1;
		}
		else
		{
			IRPFilter[ti] = 0;
		}
	}

	for (ti = 0; ti < FASTIO_MAX_OPERATION; ti++)
	{
		if (m_FastList.GetItemState(ti, LVIS_STATEIMAGEMASK) == 8192)
		{
			FASTIOFilter[ti] = 1;
		}
		else
		{
			FASTIOFilter[ti] = 0;
		}

	}

	if (m_SuppressPageIo.SendMessage(BM_GETCHECK, 0, 0) == BST_CHECKED)
	{
		nSuppressPagingIO = 1;
	}
	else
	{
		nSuppressPagingIO = 0;
	}
	CDialog::OnOK();
}


void CFilterDlg::OnFastiodeselectall() 
{
	// TODO: Add your control notification handler code here
	int ti;
	
	for (ti = 0; ti < FASTIO_MAX_OPERATION; ti++)
	{
		m_FastList.SetItemState(ti, INDEXTOSTATEIMAGEMASK(1), LVIS_STATEIMAGEMASK);
	}
}

void CFilterDlg::OnIrpdeselectall() 
{
	// TODO: Add your control notification handler code here
	int ti;
	
	for (ti = 0; ti < IRP_MJ_MAXIMUM_FUNCTION+1; ti++)
	{
		m_IrpList.SetItemState(ti, INDEXTOSTATEIMAGEMASK(1), LVIS_STATEIMAGEMASK);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\global.h ===
#ifndef __GLOBAL_H__
#define __GLOBAL_H__

#include <filespy.h>
#include "define.h"

#include <windows.h>
#include <winioctl.h>
#include <winsvc.h>

// Global variables

#ifdef MAINMODULE
#define EXTERN
#else
#define EXTERN extern
#endif

//
// Buffer size
//
#define BUFFER_SIZE 4096

//
// Image list values
//
#define IMAGE_FIXEDDRIVE 0
#define IMAGE_REMOTEDRIVE 1
#define IMAGE_REMOVABLEDRIVE 2
#define IMAGE_CDROMDRIVE 3
#define IMAGE_UNKNOWNDRIVE 4
#define IMAGE_SPY	5
#define IMAGE_ATTACHSTART 6

typedef struct _VOLINFO
{
    WCHAR nDriveName;
    WCHAR sVolumeLable[20];
    ULONG nType;
    BOOLEAN bHook;
    CCHAR nImage;
} VOLINFO, *PVOLINFO;

EXTERN SC_HANDLE hSCManager;
EXTERN SC_HANDLE hService;
EXTERN SERVICE_STATUS_PROCESS ServiceInfo;
EXTERN HANDLE hDevice;
EXTERN ULONG nPollThreadId;
EXTERN HANDLE hPollThread;
EXTERN VOLINFO VolInfo[26];
EXTERN USHORT nTotalDrives;
EXTERN LPVOID pSpyView;
EXTERN LPVOID pFastIoView;
EXTERN LPVOID pFsFilterView;
EXTERN LPVOID pLeftView;
EXTERN int IRPFilter[IRP_MJ_MAXIMUM_FUNCTION+1];
EXTERN int FASTIOFilter[FASTIO_MAX_OPERATION];
EXTERN int nSuppressPagingIO;

#endif /* __GLOBAL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\fsfilterview.h ===
#if !defined(AFX_FSFILTERVIEW_H__9C4DA95F_33EF_42EF_B16F_81656827DECA__INCLUDED_)
#define AFX_FSFILTERVIEW_H__9C4DA95F_33EF_42EF_B16F_81656827DECA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// FsFilterView.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFsFilterView view

class CFsFilterView : public CListView
{
protected:
	CFsFilterView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CFsFilterView)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFsFilterView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CFsFilterView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CFsFilterView)
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FASTIOVIEW_H__9C4DA95F_33EF_42EF_B16F_81656827DECA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\filterdlg.h ===
#if !defined(AFX_FILTERDLG_H__89CBEC30_0250_4AF7_AABB_B1AD9251C0FF__INCLUDED_)
#define AFX_FILTERDLG_H__89CBEC30_0250_4AF7_AABB_B1AD9251C0FF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// FilterDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFilterDlg dialog

class CFilterDlg : public CDialog
{
// Construction
public:
	CFilterDlg(CWnd* pParent = NULL);   // standard constructor
	~CFilterDlg(void);
	LPCTSTR MakeShortString(CDC* pDC, LPCTSTR lpszLong, int nColumnLen, int nOffset);
	CImageList *m_pImageList;

// Dialog Data
	//{{AFX_DATA(CFilterDlg)
	enum { IDD = IDD_IRPFASTIOFILTER };
	CButton	m_SuppressPageIo;
	CButton	m_ApplyInDriver;
	CButton	m_ApplyInDisplay;
	CListCtrl	m_IrpList;
	CListCtrl	m_FastList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFilterDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFilterDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnIrpselectall();
	afx_msg void OnFastioselectall();
	afx_msg void OnClickIrplist(NMHDR* pNMHDR, LRESULT* pResult);
	virtual void OnOK();
	afx_msg void OnClickFastiolist(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnFastiodeselectall();
	afx_msg void OnIrpdeselectall();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FILTERDLG_H__89CBEC30_0250_4AF7_AABB_B1AD9251C0FF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\init.cpp ===
//
// Initialize or allocate any global resources here
//
void ProgramInit(void)
{
	int ti;
	nTotalDrives = BuildDriveTable(VolInfo);

	for (ti = 0; ti < IRP_MJ_MAXIMUM_FUNCTION+1; ti++)
	{
		//
		// Enabled by default
		//
		IRPFilter[ti] = 1;
	}

	for (ti = 0; ti < FASTIO_MAX_OPERATION; ti++)
	{
		//
		// Enabled by default
		//
		FASTIOFilter[ti] = 1;
	}

	//
	// Disabled by default
	//
	nSuppressPagingIO = 0;
}

//
// Release any global resources here
//
void ProgramExit(void)
{
	//
	// !?!
	// Before we get here MFC terminates this thread!!!
	// 
	TerminateThread(hPollThread, 1);

	ShutdownFileSpy();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\fsfilterview.cpp ===
// FastIoView.cpp : implementation file
//

#include "stdafx.h"
#include "FileSpyApp.h"
#include "FsFilterView.h"

#include "global.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFsFilterView

IMPLEMENT_DYNCREATE(CFsFilterView, CListView)

CFsFilterView::CFsFilterView()
{
	pFsFilterView = (LPVOID) this;
}

CFsFilterView::~CFsFilterView()
{
}


BEGIN_MESSAGE_MAP(CFsFilterView, CListView)
	//{{AFX_MSG_MAP(CFsFilterView)
	ON_WM_KEYDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFsFilterView drawing

void CFsFilterView::OnDraw(CDC* pDC)
{
    UNREFERENCED_PARAMETER( pDC );
    
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here
}

/////////////////////////////////////////////////////////////////////////////
// CFsFilterView diagnostics+

#ifdef _DEBUG
void CFsFilterView::AssertValid() const
{
	CListView::AssertValid();
}

void CFsFilterView::Dump(CDumpContext& dc) const
{
	CListView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CFsFilterView message handlers

BOOL CFsFilterView::PreCreateWindow(CREATESTRUCT& cs) 
{
	// TODO: Add your specialized code here and/or call the base class
	cs.style |= LVS_REPORT | WS_HSCROLL | WS_VSCROLL;
	return CListView::PreCreateWindow(cs);
}

void CFsFilterView::OnInitialUpdate() 
{
	CListView::OnInitialUpdate();
	
	// TODO: Add your specialized code here and/or call the base class
	//
	// Add the list header items
	//
	GetListCtrl().InsertColumn(0, L"S. No", LVCFMT_LEFT, 50);
	GetListCtrl().InsertColumn(1, L"FsFilter Operation", LVCFMT_LEFT, 100);
	GetListCtrl().InsertColumn(2, L"FileObject", LVCFMT_LEFT, 75);
	GetListCtrl().InsertColumn(3, L"Name", LVCFMT_LEFT, 250);
	GetListCtrl().InsertColumn(4, L"Process:Thread", LVCFMT_LEFT, 100);
	GetListCtrl().InsertColumn(5, L"OrgnTime", LVCFMT_LEFT, 78);
	GetListCtrl().InsertColumn(6, L"CompTime", LVCFMT_LEFT, 78);
	GetListCtrl().InsertColumn(7, L"Return Status", LVCFMT_LEFT, 100);
}

void CFsFilterView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	// TODO: Add your message handler code here and/or call default
	int ti, oldti;
	
	if (nChar == VK_DELETE)
	{
		ti = 0;
		oldti = 0;
		while(ti < GetListCtrl().GetItemCount())
		{
			if (GetListCtrl().GetItemState(ti, LVIS_SELECTED) & LVIS_SELECTED)
			{
				GetListCtrl().DeleteItem(ti);
				oldti = ti;
			}
			else
			{
				ti++;
			}
		}
		if (oldti < GetListCtrl().GetItemCount())
		{
			GetListCtrl().SetItemState(oldti, LVIS_SELECTED, LVIS_SELECTED);
		}
		else
		{
			GetListCtrl().SetItemState(oldti-1, LVIS_SELECTED, LVIS_SELECTED);
		}
	}
	
	CListView::OnKeyDown(nChar, nRepCnt, nFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\leftview.cpp ===
// LeftView.cpp : implementation of the CLeftView class
//

#include "stdafx.h"
#include "FileSpyApp.h"

#include "FileSpyDoc.h"
#include "LeftView.h"

#include "global.h"
#include "protos.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLeftView

IMPLEMENT_DYNCREATE(CLeftView, CTreeView)

BEGIN_MESSAGE_MAP(CLeftView, CTreeView)
	//{{AFX_MSG_MAP(CLeftView)
	ON_WM_RBUTTONDOWN()
	ON_WM_RBUTTONUP()
	ON_COMMAND(IDR_MENUATTACH, OnMenuattach)
	ON_COMMAND(IDR_MENUDETACH, OnMenudetach)
	ON_COMMAND(IDR_MENUATTACHALL, OnMenuattachall)
	ON_COMMAND(IDR_MENUDETACHALL, OnMenudetachall)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLeftView construction/destruction

CLeftView::CLeftView()
{
	// TODO: add construction code here
	m_pImageList = new CImageList;
	m_pImageList->Create(IDB_DRIVEIMAGELIST,16,0,RGB(255,255,255));
	nRButtonSet = 0;
	pLeftView = (LPVOID) this;
}

CLeftView::~CLeftView()
{
	if (m_pImageList)
	{
		delete m_pImageList;
	}
}

BOOL CLeftView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs
	cs.style |= TVS_HASBUTTONS | TVS_HASLINES | TVS_LINESATROOT | TVS_SHOWSELALWAYS;
	return CTreeView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CLeftView drawing

void CLeftView::OnDraw(CDC* pDC)
{
    UNREFERENCED_PARAMETER( pDC );
    
	CFileSpyDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	// TODO: add draw code for native data here
}


void CLeftView::OnInitialUpdate()
{
	CTreeView::OnInitialUpdate();

	// TODO: You may populate your TreeView with items by directly accessing
 	//  its tree control through a call to GetTreeCtrl().

	USHORT ti;
	WCHAR sDriveString[30];

	//
	// Set the image list first
	//
	GetTreeCtrl().SetImageList(m_pImageList, TVSIL_NORMAL);

	//
	// Add a root node and name it "FileSpy"
	//
	hRootItem = GetTreeCtrl().InsertItem(L"FileSpy", IMAGE_SPY, IMAGE_SPY);

	//
	// Add drive names to LeftView
	//
	for (ti = 0; ti < nTotalDrives; ti++)
	{
		switch (VolInfo[ti].nType)
		{
		case DRIVE_FIXED:
			wcscpy( sDriveString, L"[ :] Local Disk" );
			break;
		case DRIVE_REMOTE:
			wcscpy( sDriveString, L"[ :] Remote" );
			break;
		case DRIVE_REMOVABLE:
			wcscpy( sDriveString, L"[ :] Removable" );
			break;
		case DRIVE_CDROM:
			wcscpy( sDriveString, L"[ :] CD-ROM" );
			break;
		default:
			wcscpy( sDriveString, L"[ :] Unknown" );
			break;
		}
		sDriveString[1] = VolInfo[ti].nDriveName;
		GetTreeCtrl().InsertItem( sDriveString, 
		                          VolInfo[ti].nImage, 
		                          VolInfo[ti].nImage, 
		                          hRootItem );
	}

	GetTreeCtrl().Expand(hRootItem, TVE_EXPAND);
}

/////////////////////////////////////////////////////////////////////////////
// CLeftView diagnostics

#ifdef _DEBUG
void CLeftView::AssertValid() const
{
	CTreeView::AssertValid();
}

void CLeftView::Dump(CDumpContext& dc) const
{
	CTreeView::Dump(dc);
}

CFileSpyDoc* CLeftView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CFileSpyDoc)));
	return (CFileSpyDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CLeftView message handlers

void CLeftView::OnRButtonDown(UINT nFlags, CPoint point) 
{
    UNREFERENCED_PARAMETER( nFlags );
    UNREFERENCED_PARAMETER( point );
    
	// TODO: Add your message handler code here and/or call default
	nRButtonSet = 1;
//	CTreeView::OnRButtonDown(nFlags, point);
}

void CLeftView::OnRButtonUp(UINT nFlags, CPoint point) 
{
	// TODO: Add your message handler code here and/or call default
	HTREEITEM hItem;
	CMenu menu, *menupopup;
	RECT rect;
	UINT ret;

	hItem = GetTreeCtrl().HitTest(point);

	if (hItem != NULL && hItem != hRootItem && nRButtonSet)
	{
		GetTreeCtrl().SelectItem(hItem);
		menu.LoadMenu(IDR_LEFTVIEWMENU);
		menupopup = menu.GetSubMenu(0);
		GetWindowRect(&rect);
		if (VolInfo[GetAssociatedVolumeIndex(hItem)].bHook)
		{
			ret = menupopup->EnableMenuItem(IDR_MENUATTACH, MF_DISABLED|MF_GRAYED);
			ret = menupopup->EnableMenuItem(IDR_MENUDETACH, MF_ENABLED);
		}
		else
		{
			ret = menupopup->EnableMenuItem(IDR_MENUATTACH, MF_ENABLED);
			ret = menupopup->EnableMenuItem(IDR_MENUDETACH, MF_DISABLED|MF_GRAYED);
		}
		menupopup->TrackPopupMenu(TPM_LEFTALIGN, rect.left+point.x, rect.top+point.y, this);
		CTreeView::OnRButtonUp(nFlags, point);
	}
	else
	{
		if (hItem != NULL && hItem == hRootItem && nRButtonSet)
		{
			GetTreeCtrl().SelectItem(hItem);
			menu.LoadMenu(IDR_LEFTVIEWSPYMENU);
			menupopup = menu.GetSubMenu(0);
			GetWindowRect(&rect);
			ret = menupopup->EnableMenuItem(IDR_MENUATTACHALL, MF_ENABLED);
			ret = menupopup->EnableMenuItem(IDR_MENUDETACHALL, MF_ENABLED);
			menupopup->TrackPopupMenu(TPM_LEFTALIGN, rect.left+point.x, rect.top+point.y, this);
			CTreeView::OnRButtonUp(nFlags, point);
		}	
	}
	nRButtonSet = 0;
}

void CLeftView::OnMenuattach() 
{
	// TODO: Add your command handler code here
	HTREEITEM hItem;
	hItem = GetTreeCtrl().GetSelectedItem();

	if (AttachToDrive(VolInfo[GetAssociatedVolumeIndex(hItem)].nDriveName))
	{
		VolInfo[GetAssociatedVolumeIndex(hItem)].bHook = TRUE;
		GetTreeCtrl().SetItemImage( hItem, 
                                    VolInfo[GetAssociatedVolumeIndex(hItem)].nImage+IMAGE_ATTACHSTART,
                                    VolInfo[GetAssociatedVolumeIndex(hItem)].nImage+IMAGE_ATTACHSTART );
	}
}

void CLeftView::OnMenudetach() 
{
	// TODO: Add your command handler code here
	HTREEITEM hItem;
	hItem = GetTreeCtrl().GetSelectedItem();

	if (DetachFromDrive(VolInfo[GetAssociatedVolumeIndex(hItem)].nDriveName))
	{
		VolInfo[GetAssociatedVolumeIndex(hItem)].bHook = 0;
		GetTreeCtrl().SetItemImage(hItem, 
			VolInfo[GetAssociatedVolumeIndex(hItem)].nImage, \
			VolInfo[GetAssociatedVolumeIndex(hItem)].nImage);
	}
}

void CLeftView::OnMenuattachall() 
{
	// TODO: Add your command handler code here
	USHORT ti;
	HTREEITEM hItem;

	for (ti = 0; ti < nTotalDrives; ti++)
	{
		if (AttachToDrive(VolInfo[ti].nDriveName))
		{
			VolInfo[ti].bHook = TRUE;
			hItem = GetAssociatedhItem(VolInfo[ti].nDriveName);
			if (hItem)
			{
				GetTreeCtrl().SetItemImage(hItem, 
					VolInfo[ti].nImage+IMAGE_ATTACHSTART, \
					VolInfo[ti].nImage+IMAGE_ATTACHSTART);
			}
		}
	}
}

void CLeftView::OnMenudetachall() 
{
	// TODO: Add your command handler code here
	USHORT ti;
	HTREEITEM hItem;

	for (ti = 0; ti < nTotalDrives; ti++)
	{
		if (DetachFromDrive(VolInfo[ti].nDriveName))
		{
			VolInfo[ti].bHook = FALSE;
			hItem = GetAssociatedhItem(VolInfo[ti].nDriveName);
			if (hItem)
			{
				GetTreeCtrl().SetItemImage(hItem, VolInfo[ti].nImage, VolInfo[ti].nImage);
			}
		}
	}	
}

/*
void CLeftView::OnMenuscannewvolume() 
{
	// TODO: Add your command handler code here

	VOLINFO NewVol[26];
	DWORD nNewTotalDrives;
	USHORT ti, tj;
	HTREEITEM hItem;
	
	BuildDriveTable(NewVol, nNewTotalDrives);

	// We should remember the old hook status
	for (ti = 0; ti < nNewTotalDrives; ti++)
	{
		for (tj = 0; tj < nTotalDrives; tj++)
		{
			if (NewVol[ti].nDriveName == VolInfo[tj].nDriveName)
			{
				NewVol[ti].nHook = VolInfo[tj].nHook;
				break;
			}
		}
	}
}
*/

USHORT CLeftView::GetAssociatedVolumeIndex(HTREEITEM hItem)
{
	CString cs;
	USHORT ti;
	PWCHAR sDriveString;

	cs = GetTreeCtrl().GetItemText(hItem);
	sDriveString = cs.GetBuffer(20);


	for (ti = 0; ti < nTotalDrives; ti++)
	{
		if (VolInfo[ti].nDriveName == sDriveString[1])
		{
			return ti;
		}
	}
	return 0; // still a valid value but this will not happen
}

HTREEITEM CLeftView::GetAssociatedhItem(WCHAR cDriveName)
{
	HTREEITEM hItem;
	CString cs;
	PWCHAR sDriveString;

	hItem = GetTreeCtrl().GetChildItem(hRootItem);
	while (hItem)
	{
		cs = GetTreeCtrl().GetItemText(hItem);
		sDriveString = cs.GetBuffer(20);
		if (cDriveName == sDriveString[1])
		{
			break;
		}
		hItem = GetTreeCtrl().GetNextSiblingItem(hItem);
	}
	return hItem;
}

void CLeftView::UpdateImage(void)
{

	USHORT ti;
	HTREEITEM hItem;

	for (ti = 0; ti < nTotalDrives; ti++)
	{
		hItem = GetAssociatedhItem(VolInfo[ti].nDriveName);
		GetTreeCtrl().SetItemImage(hItem, VolInfo[ti].nImage, VolInfo[ti].nImage);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\leftview.h ===
// LeftView.h : interface of the CLeftView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_LEFTVIEW_H__F23CDADF_7629_455B_AEBF_9968AB10CA64__INCLUDED_)
#define AFX_LEFTVIEW_H__F23CDADF_7629_455B_AEBF_9968AB10CA64__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CFileSpyDoc;

class CLeftView : public CTreeView
{
protected: // create from serialization only
	CLeftView();
	DECLARE_DYNCREATE(CLeftView)

// Attributes
public:
	CFileSpyDoc* GetDocument();
	CImageList *m_pImageList;
	HTREEITEM hRootItem;
	char nRButtonSet;

// Operations
public:
	USHORT GetAssociatedVolumeIndex(HTREEITEM hItem);
	HTREEITEM GetAssociatedhItem(WCHAR cDriveName);
	void UpdateImage(void);
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLeftView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual void OnInitialUpdate(); // called first time after construct
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CLeftView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CLeftView)
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMenuattach();
	afx_msg void OnMenudetach();
	afx_msg void OnMenuattachall();
	afx_msg void OnMenudetachall();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in LeftView.cpp
inline CFileSpyDoc* CLeftView::GetDocument()
   { return (CFileSpyDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LEFTVIEW_H__F23CDADF_7629_455B_AEBF_9968AB10CA64__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "FileSpyApp.h"

#include "MainFrm.h"
#include "LeftView.h"
#include "FileSpyView.h"
#include "FastIoView.h"
#include "FsFilterView.h"
#include "FilterDlg.h"

#include "global.h"
#include "protos.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
    ON_WM_CREATE()
    ON_WM_DESTROY()
    ON_COMMAND(ID_EDIT_FILTERS, OnEditFilters)
    ON_COMMAND(ID_EDIT_CLEARFASTIO, OnEditClearfastio)
    ON_COMMAND(ID_EDIT_CLEARIRP, OnEditClearirp)
    ON_COMMAND(ID_EDIT_CLEARFSFILTER, OnEditClearfsfilter)
    //}}AFX_MSG_MAP
    // Global help commands
    ON_COMMAND(ID_HELP_FINDER, CFrameWnd::OnHelpFinder)
    ON_COMMAND(ID_HELP, CFrameWnd::OnHelp)
    ON_COMMAND(ID_CONTEXT_HELP, CFrameWnd::OnContextHelp)
    ON_COMMAND(ID_DEFAULT_HELP, CFrameWnd::OnHelpFinder)
    ON_UPDATE_COMMAND_UI_RANGE(AFX_ID_VIEW_MINIMUM, AFX_ID_VIEW_MAXIMUM, OnUpdateViewStyles)
    ON_COMMAND_RANGE(AFX_ID_VIEW_MINIMUM, AFX_ID_VIEW_MAXIMUM, OnViewStyle)
END_MESSAGE_MAP()

static UINT indicators[] =
{
    ID_SEPARATOR,           // status line indicator
    ID_INDICATOR_CAPS,
    ID_INDICATOR_NUM,
    ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
    // TODO: add member initialization code here
    
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;
    
    if (!m_wndToolBar.CreateEx(this) ||
        !m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
    {
        TRACE0("Failed to create toolbar\n");
        return -1;      // fail to create
    }
/*  if (!m_wndDlgBar.Create(this, IDR_MAINFRAME, 
        CBRS_ALIGN_TOP, AFX_IDW_DIALOGBAR))
    {
        TRACE0("Failed to create dialogbar\n");
        return -1;      // fail to create
    }
*/
    if (!m_wndReBar.Create(this) ||
        !m_wndReBar.AddBar(&m_wndToolBar)) /*||
        !m_wndReBar.AddBar(&m_wndDlgBar)) */
    {
        TRACE0("Failed to create rebar\n");
        return -1;      // fail to create
    }

    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,
          sizeof(indicators)/sizeof(UINT)))
    {
        TRACE0("Failed to create status bar\n");
        return -1;      // fail to create
    }

    // TODO: Remove this if you don't want tool tips
    m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
        CBRS_TOOLTIPS | CBRS_FLYBY);

    return 0;
}

BOOL CMainFrame::OnCreateClient(LPCREATESTRUCT /*lpcs*/,
    CCreateContext* pContext)
{
    // create splitter window
    if (!m_wndSplitter.CreateStatic(this, 1, 2))
        return FALSE;
    if (!m_wndSplitter2.CreateStatic(&m_wndSplitter, 3, 1, WS_CHILD|WS_VISIBLE|WS_BORDER, m_wndSplitter.IdFromRowCol(0, 1)))
    {
        m_wndSplitter.DestroyWindow();
        return FALSE;
    }

    if (!m_wndSplitter.CreateView(0, 0, RUNTIME_CLASS(CLeftView), CSize(100, 100), pContext) ||
        !m_wndSplitter2.CreateView(0, 0, RUNTIME_CLASS(CFileSpyView), CSize(100, 100), pContext) ||
        !m_wndSplitter2.CreateView(1, 0, RUNTIME_CLASS(CFastIoView), CSize(100, 100), pContext) ||
        !m_wndSplitter2.CreateView(2, 0, RUNTIME_CLASS(CFsFilterView), CSize(100, 100), pContext))
    {
        m_wndSplitter.DestroyWindow();
        return FALSE;
    }
    m_wndSplitter.SetColumnInfo(0, 170, 0);
    m_wndSplitter2.SetRowInfo(0, 225, 0);
    m_wndSplitter.RecalcLayout();
    m_wndSplitter.RecalcLayout();

    return TRUE;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    if( !CFrameWnd::PreCreateWindow(cs) )
        return FALSE;
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
    CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

CFileSpyView* CMainFrame::GetRightPane()
{
    CWnd* pWnd = m_wndSplitter.GetPane(0, 1);
    CFileSpyView* pView = DYNAMIC_DOWNCAST(CFileSpyView, pWnd);
    return pView;
}

void CMainFrame::OnUpdateViewStyles(CCmdUI* pCmdUI)
{
    // TODO: customize or extend this code to handle choices on the
    // View menu.

    CFileSpyView* pView = GetRightPane(); 

    // if the right-hand pane hasn't been created or isn't a view,
    // disable commands in our range

    if (pView == NULL)
        pCmdUI->Enable(FALSE);
    else
    {
        DWORD dwStyle = pView->GetStyle() & LVS_TYPEMASK;

        // if the command is ID_VIEW_LINEUP, only enable command
        // when we're in LVS_ICON or LVS_SMALLICON mode

        if (pCmdUI->m_nID == ID_VIEW_LINEUP)
        {
            if (dwStyle == LVS_ICON || dwStyle == LVS_SMALLICON)
                pCmdUI->Enable();
            else
                pCmdUI->Enable(FALSE);
        }
        else
        {
            // otherwise, use dots to reflect the style of the view
            pCmdUI->Enable();
            BOOL bChecked = FALSE;

            switch (pCmdUI->m_nID)
            {
            case ID_VIEW_DETAILS:
                bChecked = (dwStyle == LVS_REPORT);
                break;

            case ID_VIEW_SMALLICON:
                bChecked = (dwStyle == LVS_SMALLICON);
                break;

            case ID_VIEW_LARGEICON:
                bChecked = (dwStyle == LVS_ICON);
                break;

            case ID_VIEW_LIST:
                bChecked = (dwStyle == LVS_LIST);
                break;

            default:
                bChecked = FALSE;
                break;
            }

            pCmdUI->SetRadio(bChecked ? 1 : 0);
        }
    }
}


void CMainFrame::OnViewStyle(UINT nCommandID)
{
    // TODO: customize or extend this code to handle choices on the
    // View menu.
    CFileSpyView* pView = GetRightPane();

    // if the right-hand pane has been created and is a CFileSpyView,
    // process the menu commands...
    if (pView != NULL)
    {
        DWORD dwStyle = (DWORD)-1;

        switch (nCommandID)
        {
        case ID_VIEW_LINEUP:
            {
                // ask the list control to snap to grid
                CListCtrl& refListCtrl = pView->GetListCtrl();
                refListCtrl.Arrange(LVA_SNAPTOGRID);
            }
            break;

        // other commands change the style on the list control
        case ID_VIEW_DETAILS:
            dwStyle = LVS_REPORT;
            break;

        case ID_VIEW_SMALLICON:
            dwStyle = LVS_SMALLICON;
            break;

        case ID_VIEW_LARGEICON:
            dwStyle = LVS_ICON;
            break;

        case ID_VIEW_LIST:
            dwStyle = LVS_LIST;
            break;
        }

        // change the style; window will repaint automatically
        if (dwStyle != -1)
            pView->ModifyStyle(LVS_TYPEMASK, dwStyle);
    }
}

void CMainFrame::OnDestroy() 
{
    CFrameWnd::OnDestroy();
    
    // TODO: Add your message handler code here
    ProgramExit();  
}

void CMainFrame::OnEditFilters() 
{
    // TODO: Add your command handler code here
    CFilterDlg cfd;

    cfd.DoModal();
    
}

void CMainFrame::OnEditClearfastio() 
{
    // TODO: Add your command handler code here
    CFastIoView *pView;

    pView = (CFastIoView *) pFastIoView;
    pView->GetListCtrl().DeleteAllItems();
}

void CMainFrame::OnEditClearirp() 
{
    // TODO: Add your command handler code here
    CFileSpyView* pView;
    
    pView = (CFileSpyView *) pSpyView;
    pView->GetListCtrl().DeleteAllItems();
}

void CMainFrame::OnEditClearfsfilter() 
{
    // TODO: Add your command handler code here
    CFsFilterView* pView;
    
    pView = (CFsFilterView *) pFsFilterView;
    pView->GetListCtrl().DeleteAllItems();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	FileSpy.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__7F1D7310_0433_406F_8D82_205D723EAE2F__INCLUDED_)
#define AFX_MAINFRM_H__7F1D7310_0433_406F_8D82_205D723EAE2F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CFileSpyView;

class CMainFrame : public CFrameWnd
{
	
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
protected:
	CSplitterWnd m_wndSplitter;
	CSplitterWnd m_wndSplitter2;
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	public:
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
	CFileSpyView* GetRightPane();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;
	CReBar      m_wndReBar;
	CDialogBar      m_wndDlgBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnEditFilters();
	afx_msg void OnEditClearfsfilter();
	afx_msg void OnEditClearfastio();
	afx_msg void OnEditClearirp();
	//}}AFX_MSG
	afx_msg void OnUpdateViewStyles(CCmdUI* pCmdUI);
	afx_msg void OnViewStyle(UINT nCommandID);
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__7F1D7310_0433_406F_8D82_205D723EAE2F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by FileSpy.rc
//
#define IDD_ABOUTBOX                    100
#define ID_VIEW_ARRANGE                 127
#define IDR_MAINFRAME                   128
#define IDR_FILESPTYPE                  129
#define IDB_DRIVEIMAGELIST              130
#define IDR_LEFTVIEWMENU                131
#define IDR_LEFTVIEWSPYMENU             132
#define IDD_IRPFASTIOFILTER             133
#define IDB_STATEIMAGELIST              134
#define IDC_IRPLIST                     1000
#define IDC_SUPPRESSPAGEIO              1002
#define IDC_FASTIOLIST                  1003
#define IDC_IRPSELECTALL                1007
#define IDC_FASTIOSELECTALL             1008
#define IDC_IRPDESELECTALL              1009
#define IDC_FASTIODESELECTALL           1010
#define ID_EDIT_OPTIONS                 32771
#define IDR_MENUATTACH                  32772
#define IDR_MENUDETACH                  32773
#define IDR_MENUATTACHALL               32776
#define IDR_DETACHALL                   32777
#define IDR_MENUDETACHALL               32778
#define ID_EDIT_FILTERS                 32780
#define ID_EDIT_CLEARIRP                32781
#define ID_EDIT_CLEARFASTIO             32782
#define ID_EDIT_CLEARFSFILTER           32783

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        135
#define _APS_NEXT_COMMAND_VALUE         32783
#define _APS_NEXT_CONTROL_VALUE         1011
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\protos.h ===
#include "global.h"

//
// Init.cpp
//
void ProgramInit(void);
void ProgramExit(void);

//
// DrvComm.cpp
//
DWORD StartFileSpy(void);
DWORD ShutdownFileSpy(void);
BOOL QueryDeviceAttachments(void);
DWORD AttachToDrive(WCHAR cDriveName);
DWORD DetachFromDrive(WCHAR cDriveName);
DWORD WINAPI PollFileSpy(LPVOID pParm);
void GetFlagsString(DWORD nFlags, PWCHAR sStr);
void GetTimeString(FILETIME *pFileTime, PWCHAR sStr);

//
// Support.cpp
//
void DisplayError(DWORD nCode);

//
// Drive.cpp
//
USHORT BuildDriveTable(VOLINFO *pVolInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#pragma warning( disable : 4100 )   // Disable unreferenced local warning
#pragma warning( disable : 4200 )   // Disable nonstandard extensions warning

#if !defined(AFX_STDAFX_H__1F8039B8_3194_48E0_9C9A_3236C0654B33__INCLUDED_)
#define AFX_STDAFX_H__1F8039B8_3194_48E0_9C9A_3236C0654B33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxres.h>
#include <afxcview.h>
#include <afxdtctl.h>       // MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1F8039B8_3194_48E0_9C9A_3236C0654B33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\support.cpp ===
void DisplayError(DWORD nCode)

/*++

Routine Description:

   This routine will display an error message based off of the Win32 error
   code that is passed in. This allows the user to see an understandable
   error message instead of just the code.

Arguments:

   Code - The error code to be translated.

Return Value:

   None.

--*/

{
   WCHAR sBuffer[200];
   DWORD nCount ;

   //
   // Translate the Win32 error code into a useful message.
   //

   nCount = FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM,
                          NULL,
                          nCode,
                          0,
                          sBuffer,
                          sizeof( sBuffer )/sizeof( WCHAR ),
                          NULL) ;

   //
   // Make sure that the message could be translated.
   //

	if (nCount == 0) 
	{ 
		swprintf(sBuffer, L"Unable to translate error code %d", nCode);
		MessageBox(NULL, sBuffer, L"Translation Error", MB_OK);
	}
	else
	{
		//
		// Display the translated error.
		//
		MessageBox(NULL, sBuffer, L"Error", MB_OK);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\iotest\filter\iotest.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    ioTest.c

Abstract:

    This is the main module of IoTest.

// @@BEGIN_DDKSPLIT

Author:

    Molly Brown (mollybro)  

// @@END_DDKSPLIT

Environment:

    Kernel mode

// @@BEGIN_DDKSPLIT

Revision History:

    Molly Brown (mollybro) 02-Dec-2000  
        Based on Filespy, created filter to test IO generation.

// @@END_DDKSPLIT
--*/

#include <ntifs.h>
#include <stdlib.h>
#include "ioTest.h"
#include "ioTestKern.h"

BOOLEAN gPending = TRUE;

//
// Global storage for this file system filter driver.
//

#if DBG
ULONG gIoTestDebugLevel = IOTESTDEBUG_DISPLAY_ATTACHMENT_NAMES | IOTESTDEBUG_ERROR | IOTESTDEBUG_TESTS;
#else
ULONG gIoTestDebugLevel = DEFAULT_IOTEST_DEBUG_LEVEL;
#endif

ULONG gIoTestAttachMode = IOTEST_ATTACH_ALL_VOLUMES;

PDEVICE_OBJECT gControlDeviceObject;

PDRIVER_OBJECT gIoTestDriverObject;

//
//  The list of device extensions for the volume device objects we are
//  attached to (the volumes we are spying on).  Note:  This list does NOT
//  include FileSystem control device objects we are attached to.  This
//  list is used to answer the question "Which volumes are we logging?"
//

FAST_MUTEX gIoTestDeviceExtensionListLock;
LIST_ENTRY gIoTestDeviceExtensionList;

//
// NOTE 1:  There are some cases where we need to hold both the 
//   gControlDeviceStateLock and the gOutputBufferLock at the same time.  In
//   these cases, you should acquire the gControlDeviceStateLock then the
//   gOutputBufferLock.
// NOTE 2:  The gControlDeviceStateLock MUST be a spinlock since we try to 
//   acquire it during the completion path in IoTestLog, which could be called at
//   DISPATCH_LEVEL (only KSPIN_LOCKs can be acquired at DISPATCH_LEVEL).
//

CONTROL_DEVICE_STATE gControlDeviceState = CLOSED;
KSPIN_LOCK gControlDeviceStateLock;

// NOTE:  Like the gControlDeviceStateLock, gOutputBufferLock MUST be a spinlock
//   since we try to acquire it during the completion path in IoTestLog, which 
//   could be called at DISPATCH_LEVEL (only KSPIN_LOCKs can be acquired at 
//   DISPATCH_LEVEL).
//
KSPIN_LOCK gOutputBufferLock;
LIST_ENTRY gOutputBufferList;

NPAGED_LOOKASIDE_LIST gFreeBufferList;

ULONG gLogSequenceNumber = 0;
KSPIN_LOCK gLogSequenceLock;

UNICODE_STRING gVolumeString;
UNICODE_STRING gOverrunString;
UNICODE_STRING gPagingIoString;

//
// NOTE:  Like above for the ControlDeviceLock, we must use KSPIN_LOCKs
//   to synchronize access to hash buckets since we may call try to
//   acquire them at DISPATCH_LEVEL.
//

LIST_ENTRY gHashTable[HASH_SIZE];
KSPIN_LOCK gHashLockTable[HASH_SIZE];
ULONG gHashMaxCounters[HASH_SIZE];
ULONG gHashCurrentCounters[HASH_SIZE];

HASH_STATISTICS gHashStat;

LONG gMaxRecordsToAllocate = DEFAULT_MAX_RECORDS_TO_ALLOCATE;
LONG gRecordsAllocated = 0;

LONG gMaxNamesToAllocate = DEFAULT_MAX_NAMES_TO_ALLOCATE;
LONG gNamesAllocated = 0;

LONG gStaticBufferInUse = FALSE;
CHAR gOutOfMemoryBuffer[RECORD_SIZE];


//
// Macro to test if we are logging for this device
// NOTE: We don't bother synchronizing to check the gControlDeviceState since
//   we can tolerate a stale value here.  We just look at it here to avoid 
//   doing the logging work if we can.  We synchronize to check the 
//   gControlDeviceState before we add the log record to the gOutputBufferList 
//   and discard the log record if the ControlDevice is no longer OPENED.
//

#define SHOULD_LOG(pDeviceObject) \
    ((gControlDeviceState == OPENED) && \
     (((PIOTEST_DEVICE_EXTENSION)(pDeviceObject)->DeviceExtension)->LogThisDevice))
     
//
//  Macro for validating the FastIo dispatch routines before calling
//  them in the FastIo pass through functions.
//

#define VALID_FAST_IO_DISPATCH_HANDLER(FastIoDispatchPtr, FieldName) \
    (((FastIoDispatchPtr) != NULL) && \
     (((FastIoDispatchPtr)->SizeOfFastIoDispatch) >= \
      (FIELD_OFFSET(FAST_IO_DISPATCH, FieldName) + sizeof(VOID *))) && \
     ((FastIoDispatchPtr)->FieldName != NULL))
    

//
//  list of known device types
//

const PCHAR DeviceTypeNames[] = {
    "",
    "BEEP",
    "CD_ROM",
    "CD_ROM_FILE_SYSTEM",
    "CONTROLLER",
    "DATALINK",
    "DFS",
    "DISK",
    "DISK_FILE_SYSTEM",
    "FILE_SYSTEM",
    "INPORT_PORT",
    "KEYBOARD",
    "MAILSLOT",
    "MIDI_IN",
    "MIDI_OUT",
    "MOUSE",
    "MULTI_UNC_PROVIDER",
    "NAMED_PIPE",
    "NETWORK",
    "NETWORK_BROWSER",
    "NETWORK_FILE_SYSTEM",
    "NULL",
    "PARALLEL_PORT",
    "PHYSICAL_NETCARD",
    "PRINTER",
    "SCANNER",
    "SERIAL_MOUSE_PORT",
    "SERIAL_PORT",
    "SCREEN",
    "SOUND",
    "STREAMS",
    "TAPE",
    "TAPE_FILE_SYSTEM",
    "TRANSPORT",
    "UNKNOWN",
    "VIDEO",
    "VIRTUAL_DISK",
    "WAVE_IN",
    "WAVE_OUT",
    "8042_PORT",
    "NETWORK_REDIRECTOR",
    "BATTERY",
    "BUS_EXTENDER",
    "MODEM",
    "VDM",
    "MASS_STORAGE",
    "SMB",
    "KS",
    "CHANGER",
    "SMARTCARD",
    "ACPI",
    "DVD",
    "FULLSCREEN_VIDEO",
    "DFS_FILE_SYSTEM",
    "DFS_VOLUME",
    "SERENUM",
    "TERMSRV",
    "KSEC"
};

//
//  We need this because the compiler doesn't like doing sizeof an externed
//  array in the other file that needs it (fspylib.c)
//

ULONG SizeOfDeviceTypeNames = sizeof( DeviceTypeNames );

//
//  Since functions in drivers are non-pagable by default, these pragmas 
//  allow the driver writer to tell the system what functions can be paged.
//
//  Use the PAGED_CODE() macro at the beginning of these functions'
//  implementations while debugging to ensure that these routines are
//  never called at IRQL > APC_LEVEL (therefore the routine cannot
//  be paged).
//

VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, DriverUnload)
#pragma alloc_text(INIT, IoTestReadDriverParameters)
#pragma alloc_text(PAGE, IoTestClose)
#pragma alloc_text(PAGE, IoTestFsControl)
#pragma alloc_text(PAGE, IoTestFastIoCheckIfPossible)
#pragma alloc_text(PAGE, IoTestFastIoRead)
#pragma alloc_text(PAGE, IoTestFastIoWrite)
#pragma alloc_text(PAGE, IoTestFastIoQueryBasicInfo)
#pragma alloc_text(PAGE, IoTestFastIoQueryStandardInfo)
#pragma alloc_text(PAGE, IoTestFastIoLock)
#pragma alloc_text(PAGE, IoTestFastIoUnlockSingle)
#pragma alloc_text(PAGE, IoTestFastIoUnlockAll)
#pragma alloc_text(PAGE, IoTestFastIoUnlockAllByKey)
#pragma alloc_text(PAGE, IoTestFastIoDeviceControl)
#pragma alloc_text(PAGE, IoTestFastIoDetachDevice)
#pragma alloc_text(PAGE, IoTestFastIoQueryNetworkOpenInfo)
#pragma alloc_text(PAGE, IoTestFastIoMdlRead)
#pragma alloc_text(PAGE, IoTestFastIoPrepareMdlWrite)
#pragma alloc_text(PAGE, IoTestFastIoReadCompressed)
#pragma alloc_text(PAGE, IoTestFastIoWriteCompressed)
#pragma alloc_text(PAGE, IoTestFastIoQueryOpen)
#pragma alloc_text(PAGE, IoTestPreFsFilterOperation)
#pragma alloc_text(PAGE, IoTestPostFsFilterOperation)
#endif
 
NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
)
/*++

Routine Description:

    This is the initialization routine for the general purpose file system
    filter driver.  This routine creates the device object that represents 
    this driver in the system and registers it for watching all file systems 
    that register or unregister themselves as active file systems.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/
{
    UNICODE_STRING nameString;
    NTSTATUS status;
    PFAST_IO_DISPATCH fastIoDispatch;
    ULONG i;
    UNICODE_STRING linkString;
    FS_FILTER_CALLBACKS fsFilterCallbacks;
    
    //////////////////////////////////////////////////////////////////////
    //                                                                  //
    //  General setup for all filter drivers.  This sets up the filter  //
    //  driver's DeviceObject and registers the callback routines for   //
    //  the filter driver.                                              //
    //                                                                  //
    //////////////////////////////////////////////////////////////////////

    //
    //  Read the custom parameters for IoTest from the registry
    //

    IoTestReadDriverParameters( RegistryPath );

#if DBG
    //DbgBreakPoint();
#endif

    //
    //  Save our Driver Object.
    //

    gIoTestDriverObject = DriverObject;
    gIoTestDriverObject->DriverUnload = DriverUnload;

    //
    // Create the device object that will represent the IoTest device.
    //

    RtlInitUnicodeString( &nameString, IOTEST_FULLDEVICE_NAME );
    
    //
    // Create the "control" device object.  Note that this device object does
    // not have a device extension (set to NULL).  Most of the fast IO routines
    // check for this condition to determine if the fast IO is directed at the
    // control device.
    //

    status = IoCreateDevice( DriverObject,
                             0,
                             &nameString,
                             FILE_DEVICE_DISK_FILE_SYSTEM,
                             0,
                             FALSE,
                             &gControlDeviceObject);

    if (!NT_SUCCESS( status )) {

        IOTEST_DBG_PRINT1( IOTESTDEBUG_ERROR,
                            "IOTEST (DriverEntry): Error creating IoTest device, error: %x\n",
                            status );

        return status;

    } else {

        RtlInitUnicodeString( &linkString, IOTEST_DOSDEVICE_NAME );
        status = IoCreateSymbolicLink( &linkString, &nameString );

        if (!NT_SUCCESS(status)) {

            //
            //  Remove the existing symbol link and try and create it again.
            //  If this fails then quit.
            //

            IoDeleteSymbolicLink( &linkString );
            status = IoCreateSymbolicLink( &linkString, &nameString );

            if (!NT_SUCCESS(status)) {

                IOTEST_DBG_PRINT0( IOTESTDEBUG_ERROR,
                                    "IOTEST (DriverEntry): IoCreateSymbolicLink failed\n" );
                IoDeleteDevice(gControlDeviceObject);
                return status;
            }
        }
    }

    //
    // Initialize the driver object with this device driver's entry points.
    //

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {

        DriverObject->MajorFunction[i] = IoTestDispatch;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE] = IoTestCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = IoTestClose;
    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL] = IoTestFsControl;

    //
    // Allocate fast I/O data structure and fill it in.  This structure
    // is used to register the callbacks for IoTest in the fast I/O
    // data paths.
    //

    fastIoDispatch = ExAllocatePool( NonPagedPool, sizeof( FAST_IO_DISPATCH ) );

    if (!fastIoDispatch) {

        IoDeleteDevice( gControlDeviceObject );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( fastIoDispatch, sizeof( FAST_IO_DISPATCH ) );
    fastIoDispatch->SizeOfFastIoDispatch = sizeof( FAST_IO_DISPATCH );
    fastIoDispatch->FastIoCheckIfPossible = IoTestFastIoCheckIfPossible;
    fastIoDispatch->FastIoRead = IoTestFastIoRead;
    fastIoDispatch->FastIoWrite = IoTestFastIoWrite;
    fastIoDispatch->FastIoQueryBasicInfo = IoTestFastIoQueryBasicInfo;
    fastIoDispatch->FastIoQueryStandardInfo = IoTestFastIoQueryStandardInfo;
    fastIoDispatch->FastIoLock = IoTestFastIoLock;
    fastIoDispatch->FastIoUnlockSingle = IoTestFastIoUnlockSingle;
    fastIoDispatch->FastIoUnlockAll = IoTestFastIoUnlockAll;
    fastIoDispatch->FastIoUnlockAllByKey = IoTestFastIoUnlockAllByKey;
    fastIoDispatch->FastIoDeviceControl = IoTestFastIoDeviceControl;
    fastIoDispatch->FastIoDetachDevice = IoTestFastIoDetachDevice;
    fastIoDispatch->FastIoQueryNetworkOpenInfo = IoTestFastIoQueryNetworkOpenInfo;
    fastIoDispatch->MdlRead = IoTestFastIoMdlRead;
    fastIoDispatch->MdlReadComplete = IoTestFastIoMdlReadComplete;
    fastIoDispatch->PrepareMdlWrite = IoTestFastIoPrepareMdlWrite;
    fastIoDispatch->MdlWriteComplete = IoTestFastIoMdlWriteComplete;
    fastIoDispatch->FastIoReadCompressed = IoTestFastIoReadCompressed;
    fastIoDispatch->FastIoWriteCompressed = IoTestFastIoWriteCompressed;
    fastIoDispatch->MdlReadCompleteCompressed = IoTestFastIoMdlReadCompleteCompressed;
    fastIoDispatch->MdlWriteCompleteCompressed = IoTestFastIoMdlWriteCompleteCompressed;
    fastIoDispatch->FastIoQueryOpen = IoTestFastIoQueryOpen;

    DriverObject->FastIoDispatch = fastIoDispatch;

    //
    //  Setup the callbacks for the operations we receive through
    //  the FsFilter interface.
    //

    fsFilterCallbacks.SizeOfFsFilterCallbacks = sizeof( FS_FILTER_CALLBACKS );
    fsFilterCallbacks.PreAcquireForSectionSynchronization = IoTestPreFsFilterOperation;
    fsFilterCallbacks.PostAcquireForSectionSynchronization = IoTestPostFsFilterOperation;
    fsFilterCallbacks.PreReleaseForSectionSynchronization = IoTestPreFsFilterOperation;
    fsFilterCallbacks.PostReleaseForSectionSynchronization = IoTestPostFsFilterOperation;
    fsFilterCallbacks.PreAcquireForCcFlush = IoTestPreFsFilterOperation;
    fsFilterCallbacks.PostAcquireForCcFlush = IoTestPostFsFilterOperation;
    fsFilterCallbacks.PreReleaseForCcFlush = IoTestPreFsFilterOperation;
    fsFilterCallbacks.PostReleaseForCcFlush = IoTestPostFsFilterOperation;
    fsFilterCallbacks.PreAcquireForModifiedPageWriter = IoTestPreFsFilterOperation;
    fsFilterCallbacks.PostAcquireForModifiedPageWriter = IoTestPostFsFilterOperation;
    fsFilterCallbacks.PreReleaseForModifiedPageWriter = IoTestPreFsFilterOperation;
    fsFilterCallbacks.PostReleaseForModifiedPageWriter = IoTestPostFsFilterOperation;

    status = FsRtlRegisterFileSystemFilterCallbacks( DriverObject, &fsFilterCallbacks );

    if (!NT_SUCCESS( status )) {

        DriverObject->FastIoDispatch = NULL;
        ExFreePool( fastIoDispatch );
        IoDeleteDevice( gControlDeviceObject );
        return status;
    }

    //////////////////////////////////////////////////////////////////////
    //                                                                  //
    //  Initialize global data structures that are used for IoTest's   //
    //  logging of I/O operations.                                      //
    //                                                                  //
    //////////////////////////////////////////////////////////////////////

    //
    //  A fast mutex was used in this case because the mutex is never acquired
    //  at DPC level or above.  Spinlocks were chosen in other cases because
    //  they are acquired at DPC level or above.  Another consideration is
    //  that on an MP machine, a spin lock will literally spin trying to 
    //  acquire the lock when the lock is already acquired.  Acquiring a
    //  previously acquired fast mutex will suspend the thread, thus freeing
    //  up the processor.
    //
    
    ExInitializeFastMutex( &gIoTestDeviceExtensionListLock );
    InitializeListHead( &gIoTestDeviceExtensionList );

    KeInitializeSpinLock( &gControlDeviceStateLock );

    InitializeListHead( &gOutputBufferList );

    KeInitializeSpinLock( &gOutputBufferLock );
    KeInitializeSpinLock( &gLogSequenceLock );


#ifndef MEMORY_DBG

    //
    //  When we aren't debugging our memory usage, we want to allocate 
    //  memory from a look-aside list for better performance.  Unfortunately,
    //  we cannot benefit from the memory debugging help of the Driver 
    //  Verifier if we allocate memory from a look-aside list.
    //

    ExInitializeNPagedLookasideList( &gFreeBufferList, 
                                     NULL/*ExAllocatePoolWithTag*/, 
                                     NULL/*ExFreePool*/, 
                                     0, 
                                     RECORD_SIZE, 
                                     MSFM_TAG, 
                                     100 );
#endif

    //
    //  Initialize the hash table
    //
        
    for (i = 0; i < HASH_SIZE; i++){

        InitializeListHead(&gHashTable[i]);
        KeInitializeSpinLock(&gHashLockTable[i]);
    }

    RtlInitUnicodeString(&gVolumeString, L"VOLUME");
    RtlInitUnicodeString(&gOverrunString, L"......");
    RtlInitUnicodeString(&gPagingIoString, L"Paging IO");

    //
    //  If we are supposed to attach to all devices, register a callback
    //  with IoRegisterFsRegistrationChange.
    //

    if (gIoTestAttachMode == IOTEST_ATTACH_ALL_VOLUMES) {
    
        status = IoRegisterFsRegistrationChange( DriverObject, IoTestFsNotification );
        
        if (!NT_SUCCESS( status )) {

            IOTEST_DBG_PRINT1( IOTESTDEBUG_ERROR,
                                "IOTEST (DriverEntry): Error registering FS change notification, status=%08x\n", 
                                status );

            DriverObject->FastIoDispatch = NULL;
            ExFreePool( fastIoDispatch );
            IoDeleteDevice( gControlDeviceObject );
            return status;
        }
    }

    //
    //  Clear the initializing flag on the control device object since we
    //  have now successfully initialized everything.
    //

    ClearFlag( gControlDeviceObject->Flags, DO_DEVICE_INITIALIZING );

    return STATUS_SUCCESS;
}


VOID
DriverUnload (
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine is called when a driver can be unloaded.  This performs all of
    the necessary cleanup for unloading the driver from memory.  Note that an
    error can not be returned from this routine.
    
    When a request is made to unload a driver the IO System will cache that
    information and not actually call this routine until the following states
    have occurred:
    - All device objects which belong to this filter are at the top of their
      respective attachment chains.
    - All handle counts for all device objects which belong to this filter have
      gone to zero.

    WARNING: Microsoft does not officially support the unloading of File
             System Filter Drivers.  This is an example of how to unload
             your driver if you would like to use it during development.
             This should not be made available in production code.

Arguments:

    DriverObject - Driver object for this module

Return Value:

    None.

--*/

{
    PIOTEST_DEVICE_EXTENSION devExt;
    PFAST_IO_DISPATCH fastIoDispatch;
    NTSTATUS status;
    ULONG numDevices;
    ULONG i;
    LARGE_INTEGER interval;
    UNICODE_STRING linkString;
#   define DEVOBJ_LIST_SIZE 64
    PDEVICE_OBJECT devList[DEVOBJ_LIST_SIZE];

    ASSERT(DriverObject == gIoTestDriverObject);

    //
    //  Log we are unloading
    //

    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_DISPLAY_ATTACHMENT_NAMES )) {

        DbgPrint( "IOTEST (DriverUnload): Unloading Driver (%p)\n",DriverObject);
    }

    //
    //  Remove the symbolic link so no one else will be able to find it.
    //

    RtlInitUnicodeString( &linkString, IOTEST_DOSDEVICE_NAME );
    IoDeleteSymbolicLink( &linkString );

    //
    //  Don't get anymore file system change notifications
    //

    IoUnregisterFsRegistrationChange( DriverObject, IoTestFsNotification );

    //
    //  This is the loop that will go through all of the devices we are attached
    //  to and detach from them.  Since we don't know how many there are and
    //  we don't want to allocate memory (because we can't return an error)
    //  we will free them in chunks using a local array on the stack.
    //

    for (;;) {

        //
        //  Get what device objects we can for this driver.  Quit if there
        //  are not any more.
        //

        status = IoEnumerateDeviceObjectList(
                        DriverObject,
                        devList,
                        sizeof(devList),
                        &numDevices);

        if (numDevices <= 0)  {

            break;
        }

        numDevices = min( numDevices, DEVOBJ_LIST_SIZE );

        //
        //  First go through the list and detach each of the devices.
        //  Our control device object does not have a DeviceExtension and
        //  is not attached to anything so don't detach it.
        //

        for (i=0; i < numDevices; i++) {

            devExt = devList[i]->DeviceExtension;
            if (NULL != devExt) {

                IoDetachDevice( devExt->AttachedToDeviceObject );
            }
        }

        //
        //  The IO Manager does not currently add a refrence count to a device
        //  object for each outstanding IRP.  This means there is no way to
        //  know if there are any outstanding IRPs on the given device.
        //  We are going to wait for a reonsable amount of time for pending
        //  irps to complete.  
        //
        //  WARNING: This does not work 100% of the time and the driver may be
        //           unloaded before all IRPs are completed during high stress
        //           situations.  The system will fault if this occurs.  This
        //           is a sample of how to do this during testing.  This is
        //           not recommended for production code.
        //

        interval.QuadPart = -5 * (10 * 1000 * 1000);      //delay 5 seconds
        KeDelayExecutionThread( KernelMode, FALSE, &interval );

        //
        //  Now go back through the list and delete the device objects.
        //

        for (i=0; i < numDevices; i++) {

            //
            //  See if this is our control device object.  If not then cleanup
            //  the device extension.  If so then clear the global pointer
            //  that refrences it.
            //

            if (NULL != devList[i]->DeviceExtension) {

                IoTestCleanupMountedDevice( devList[i] );

            } else {

                ASSERT(devList[i] == gControlDeviceObject);
                ASSERT(gControlDeviceState == CLOSED);
                gControlDeviceObject = NULL;
            }

            //
            //  Delete the device object, remove refrence counts added by
            //  IoEnumerateDeviceObjectList.  Note that the delete does
            //  not actually occur until the refrence count goes to zero.
            //

            IoDeleteDevice( devList[i] );
            ObDereferenceObject( devList[i] );
        }
    }

    //
    //  Delete the look aside list.
    //

    ASSERT(IsListEmpty( &gIoTestDeviceExtensionList ));
    ExDeleteNPagedLookasideList( &gFreeBufferList );

    //
    //  Free our FastIO table
    //

    fastIoDispatch = DriverObject->FastIoDispatch;
    DriverObject->FastIoDispatch = NULL;
    ExFreePool( fastIoDispatch );
}


VOID
IoTestFsNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FsActive
    )
/*++

Routine Description:

    This routine is invoked whenever a file system has either registered or
    unregistered itself as an active file system.

    For the former case, this routine creates a device object and attaches it
    to the specified file system's device object.  This allows this driver
    to filter all requests to that file system.

    For the latter case, this file system's device object is located,
    detached, and deleted.  This removes this file system as a filter for
    the specified file system.

Arguments:

    DeviceObject - Pointer to the file system's device object.

    FsActive - Boolean indicating whether the file system has registered
        (TRUE) or unregistered (FALSE) itself as an active file system.

Return Value:

    None.

--*/
{
    UNICODE_STRING name;
    WCHAR nameBuffer[DEVICE_NAMES_SZ];

    RtlInitEmptyUnicodeString( &name, nameBuffer, sizeof( nameBuffer ) );

    //
    //  Display the names of all the file system we are notified of
    //

    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_DISPLAY_ATTACHMENT_NAMES )) {

        IoTestGetBaseDeviceObjectName( DeviceObject, &name );
        DbgPrint( "IOTEST (IoTestFsNotification): %s       \"%wZ\" (%s)\n",
                  (FsActive) ? "Activating file system  " : "Deactivating file system",
                  &name,
                  GET_DEVICE_TYPE_NAME(DeviceObject->DeviceType));
    }

    //
    //  See if we want to ATTACH or DETACH from the given file system.
    //

    if (FsActive) {

        IoTestAttachToFileSystemDevice( DeviceObject, &name );

    } else {

        IoTestDetachFromFileSystemDevice( DeviceObject );
    }
}


NTSTATUS
IoTestPassThrough (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
)
/*++

Routine Description:

    This routine is the main dispatch routine for the general purpose file
    system driver.  It simply passes requests onto the next driver in the
    stack, which is presumably a disk file system, while logging any
    relevant information if logging is turned on for this DeviceObject.

Arguments:

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

Note:

    This routine passes the I/O request through to the next driver
    *without* removing itself from the stack (like sfilter) since it could
    want to see the result of this I/O request.
    
    To remain in the stack, we have to copy the caller's parameters to the
    next stack location.  Note that we do not want to copy the caller's I/O
    completion routine into the next stack location, or the caller's routine
    will get invoked twice.  This is why we NULL out the Completion routine.
    If we are logging this device, we set our own Completion routine.
    
--*/
{
    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //

    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_IRP_OPS )) {

        IoTestDumpIrpOperation( TRUE, Irp );
    }

    //
    //  See if we should log this IRP
    //
    
    if (SHOULD_LOG( DeviceObject )) {
        PRECORD_LIST recordList;

        //
        // The ControlDevice is opened, so allocate the Record 
        // and log the Irp information if we have the memory.
        //

        recordList = IoTestNewRecord(0);

        if (recordList) {

            IoTestLogIrp( Irp, LOG_ORIGINATING_IRP, recordList );

            IoTestLog( recordList );
        }
    }

    //
    //  For the IoTest filter, we don't wait to see the outcome of the operation
    //  so just skip setting a completion routine.
    //

    IoSkipCurrentIrpStackLocation( Irp );

    //
    // Now call the next file system driver with the request.
    //
    
    return IoCallDriver( ((PIOTEST_DEVICE_EXTENSION)DeviceObject->DeviceExtension)->AttachedToDeviceObject, Irp );
}

#if 0
NTSTATUS
IoTestPassThroughCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
)
/*++

Routine Description:

    This routine is the completion routine IoTestPassThrough.  This is used
    to log the information that can only be gathered after the I/O request
    has been completed.

    Once we are done logging all the information we care about, we append
    the record to the gOutputBufferList to be returned to the user.
    
    Note: This routine will only be set if we were trying to log the
        specified device when the Irp originated and we were able to
        allocate a record to store this logging information.

Arguments:

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.
    
    Context - Pointer to the RECORD_LIST structure in which we store the
        information we are logging.

Return Value:

    The function value is the status of the operation.

--*/
{
    PRECORD_LIST recordList;

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_IRP_OPS )) {

        IoTestDumpIrpOperation( FALSE, Irp );
    }
    
    recordList = (PRECORD_LIST)Context;

    if (SHOULD_LOG( DeviceObject )) {

        IoTestLogIrp( Irp, LOG_COMPLETION_IRP, recordList );
        
        //
        //  Add recordList to our gOutputBufferList so that it gets up to 
        //  the user
        //
        
        IoTestLog( recordList );       

    } else {

        if (recordList) {

            //
            //  Context is set with a RECORD_LIST, but we are no longer
            //  logging so free this record.
            //

            IoTestFreeRecord( recordList );
        }
    }
    
    //
    //  If the operation failed and this was a create, remove the name
    //  from the cache.
    //

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation( Irp );

        if ((IRP_MJ_CREATE == irpStack->MajorFunction) &&
            (irpStack->FileObject != NULL)) {

            IoTestNameDelete(irpStack->FileObject);
        }
    }
    
    //
    //  Propagate the IRP pending flag.  All completion routines
    //  need to do this.
    //

    if (Irp->PendingReturned) {
        
        IoMarkIrpPending( Irp );
    }

    return STATUS_SUCCESS;
}
#endif

NTSTATUS
IoTestDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
)
/*++

Routine Description:

    This function completes all requests on the gControlDeviceObject 
    (IoTest's device object) and passes all other requests on to the 
    IoTestPassThrough function.

Arguments:

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    If this is a request on the gControlDeviceObject, STATUS_SUCCESS 
    will be returned unless the device is already attached.  In that case,
    STATUS_DEVICE_ALREADY_ATTACHED is returned.

    If this is a request on a device other than the gControlDeviceObject,
    the function will return the value of IoTestPassThrough().

--*/
{
    ULONG status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack;
    
    if (DeviceObject == gControlDeviceObject) {

        //
        //  A request is being made on our device object, gControlDeviceObject.
        //

        Irp->IoStatus.Information = 0;
    
        irpStack = IoGetCurrentIrpStackLocation( Irp );
       
        switch (irpStack->MajorFunction) {
        case IRP_MJ_DEVICE_CONTROL:

            //
            //  This is a private device control irp for our control device.
            //  Pass the parameter information along to the common routine
            //  use to service these requests.
            //
            
            status = IoTestCommonDeviceIoControl( irpStack->Parameters.DeviceIoControl.Type3InputBuffer,
                                               irpStack->Parameters.DeviceIoControl.InputBufferLength,
                                               Irp->UserBuffer,
                                               irpStack->Parameters.DeviceIoControl.OutputBufferLength,
                                               irpStack->Parameters.DeviceIoControl.IoControlCode,
                                               &Irp->IoStatus,
                                               irpStack->DeviceObject );
            break;

        case IRP_MJ_CLEANUP:
        
            //
            //  This is the cleanup that we will see when all references to a handle
            //  opened to filespy's control device object are cleaned up.  We don't
            //  have to do anything here since we wait until the actual IRP_MJ_CLOSE
            //  to clean up the name cache.  Just complete the IRP successfully.
            //

            status = STATUS_SUCCESS;

            break;
                
        default:

            status = STATUS_INVALID_DEVICE_REQUEST;
        }

        Irp->IoStatus.Status = status;

        //
        //  We have completed all processing for this IRP, so tell the 
        //  I/O Manager.  This IRP will not be passed any further down
        //  the stack since no drivers below IoTest care about this 
        //  I/O operation that was directed to IoTest.
        //

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;
    }

    return IoTestPassThrough( DeviceObject, Irp );
}

NTSTATUS
IoTestCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
)
/*++

Routine Description:

    This is the routine that is associated with IRP_MJ_CREATE irp.  If the 
    DeviceObject is the ControlDevice, we do the creation work for the 
    ControlDevice and complete the irp.  Otherwise, we pass through
    this irp for another device to complete.
    
    Note: Some of the code in this function duplicates the functions 
        IoTestDispatch and IoTestPassThrough, but a design decision was made that 
        it was worth the code duplication to break out the irp handlers 
        that can be pagable code.
    
Arguments:

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.
    
Return Value:

    If DeviceObject == gControlDeviceObject, then this function will 
    complete the Irp and return the status of that completion.  Otherwise,
    this function returns the result of calling IoTestPassThrough.
    
--*/
{
    PIO_STACK_LOCATION currentIrpSp;
    KIRQL oldIrql;

    //
    //  See if they want to open the control device object for the filter.
    //  This will only allow one thread to have this object open at a time.
    //  All other requests will be failed.
    //

    if (DeviceObject == gControlDeviceObject) {
        ULONG status;

        //
        //  A CREATE request is being made on our gControlDeviceObject.
        //  See if someone else has it open.  If so, disallow this open.
        //

        KeAcquireSpinLock( &gControlDeviceStateLock, &oldIrql );

        if (gControlDeviceState != CLOSED) {

            Irp->IoStatus.Status = STATUS_DEVICE_ALREADY_ATTACHED;
            Irp->IoStatus.Information = 0;

        } else {

            Irp->IoStatus.Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = FILE_OPENED;

            gControlDeviceState = OPENED;
        }

        KeReleaseSpinLock( &gControlDeviceStateLock, oldIrql );

        //
        // Since this is our gControlDeviceObject, we complete the
        // irp here.
        //

        status = Irp->IoStatus.Status;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;
    }

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );

    //
    //
    // This is a CREATE so we need to invalidate the name currently
    // stored in the name cache for this FileObject.  We need to do
    // this as long as our ControlDevice is open so that we keep the
    // name cache up-to-date.
    //

    currentIrpSp = IoGetCurrentIrpStackLocation( Irp );

    if (OPENED == gControlDeviceState) {

        IoTestNameDelete(currentIrpSp->FileObject);
    }

    //
    // This is NOT our gControlDeviceObject, so let IoTestPassThrough handle
    // it appropriately
    //

    return IoTestPassThrough( DeviceObject, Irp );
}


NTSTATUS
IoTestClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the routine that is associated with IRP_MJ_CLOSE irp.  If the 
    DeviceObject is the ControlDevice, we do the necessary cleanup and
    complete the irp.  Otherwise, we pass through this irp for another device
    to complete.
    
Arguments:

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.
    
Return Value:

    If DeviceObject == gControlDeviceObject, then this function will 
    complete the Irp and return the status of that completion.  Otherwise,
    this function returns the result of calling IoTestPassThrough.
    
--*/
{
    PFILE_OBJECT savedFileObject;
    NTSTATUS status;
 
    PAGED_CODE();

    //
    //  See if they are closing the control device object for the filter.
    //

    if (DeviceObject == gControlDeviceObject) {

        //
        //  A CLOSE request is being made on our gControlDeviceObject.
        //  Cleanup state.
        //

        IoTestCloseControlDevice();

        //
        //  We have completed all processing for this IRP, so tell the 
        //  I/O Manager.  This IRP will not be passed any further down
        //  the stack since no drivers below IoTest care about this 
        //  I/O operation that was directed to IoTest.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_SUCCESS;
    }

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
 
    //
    //  Save a pointer to the file object we are closing so we can remove
    //  the name from our cache after we have completed the operation.
    //

    savedFileObject = IoGetCurrentIrpStackLocation(Irp)->FileObject;

    //
    //  Log (if it is turned on) and pass the request on.
    //

    status = IoTestPassThrough( DeviceObject, Irp );
    
    //
    // See if the FileObject's name is being
    // cached and remove it from the cache if it is.  We want to do this
    // as long as the ControlDevice is opened so that we purge the
    // cache as accurately as possible.
    //
 
    if (OPENED == gControlDeviceState) {
 
        IoTestNameDelete( savedFileObject );
    }
 
 
    return status;
}


//
//  Structures used to transfer context from IoTestFsControl to the associated
//  completion routine.  We needed this because we needed to pass allocated
//  LOGGING structure to the completion routine
//

typedef struct FS_CONTROL_COMPLETION_CONTEXT {
    PKEVENT WaitEvent;
    PRECORD_LIST RecordList;
    MINI_DEVICE_STACK DeviceObjects;
} FS_CONTROL_COMPLETION_CONTEXT, *PFS_CONTROL_COMPLETION_CONTEXT;



NTSTATUS
IoTestFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked whenever an I/O Request Packet (IRP) w/a major
    function code of IRP_MJ_FILE_SYSTEM_CONTROL is encountered.  For most
    IRPs of this type, the packet is simply passed through.  However, for
    some requests, special processing is required.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    PIOTEST_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    PIOTEST_DEVICE_EXTENSION newDevExt;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );
    PRECORD_LIST recordList = NULL;
    KEVENT waitEvent;
    NTSTATUS status;
    PVPB vpb;
    FS_CONTROL_COMPLETION_CONTEXT completionContext;

    PAGED_CODE();

    //
    //  If this is for our control device object, fail the operation
    //

    if (gControlDeviceObject == DeviceObject) {

        //
        //  If this device object is our control device object rather than 
        //  a mounted volume device object, then this is an invalid request.
        //

        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    ASSERT(IS_IOTEST_DEVICE_OBJECT( DeviceObject ));

    //
    //  Begin by determining the minor function code for this file system control
    //  function.
    //

    if (irpSp->MinorFunction == IRP_MN_MOUNT_VOLUME) {

        //
        //  This is a mount request.  Create a device object that can be
        //  attached to the file system's volume device object if this request
        //  is successful.  We allocate this memory now since we can not return
        //  an error in the completion routine.
        //

        status = IoTestCreateDeviceObjects( DeviceObject, 
                                            irpSp->Parameters.MountVolume.Vpb->RealDevice, 
                                            &(completionContext.DeviceObjects) );
        
        if (NT_SUCCESS( status )) {

            //
            //  Since we have our own private completion routine we need to
            //  do our own logging of this operation, do it now.
            //

            if (SHOULD_LOG( DeviceObject )) {

                //
                // The ControlDevice is opened, so allocate the Record 
                // and log the Irp information if we have the memory.
                //

                recordList = IoTestNewRecord(0);

                if (recordList) {

                    IoTestLogIrp( Irp, LOG_ORIGINATING_IRP, recordList );
                }
            }

            //
            //  Get a new IRP stack location and set our mount completion
            //  routine.  Pass along the address of the device object we just
            //  created as its context.
            //

            KeInitializeEvent( &waitEvent, SynchronizationEvent, FALSE );

            IoCopyCurrentIrpStackLocationToNext( Irp );

            completionContext.WaitEvent = &waitEvent;
            completionContext.RecordList = recordList;

            IoSetCompletionRoutine( Irp,
                                    IoTestMountCompletion,
                                    &completionContext,     //context parameter
                                    TRUE,
                                    TRUE,
                                    TRUE );

            //
            //  Call the driver
            //

            status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );

            //
            //  Wait for the completion routine to be called
            //

	        if (STATUS_PENDING == status) {

		        NTSTATUS localStatus = KeWaitForSingleObject(&waitEvent, Executive, KernelMode, FALSE, NULL);
		        ASSERT(STATUS_SUCCESS == localStatus);
	        }

            //
            //  Get the correct VPB from the real device object saved in our
            //  device extension.  We do this because the VPB in the IRP stack
            //  may not be the correct VPB when we get here.  The underlying
            //  file system may change VPBs if it detects a volume it has
            //  mounted previously.
            //

            newDevExt = completionContext.DeviceObjects.Bottom->DeviceExtension;
            vpb = newDevExt->DiskDeviceObject->Vpb;

            //
            //  If the operation succeeded and we are not alreayd attached,
            //  attach to the device object.
            //

            if (NT_SUCCESS( Irp->IoStatus.Status ) && 
                !IoTestIsAttachedToDevice( TOP_FILTER, vpb->DeviceObject, NULL )) {

                //
                //  The FileSystem has successfully completed the mount, which means
                //  it has created the DeviceObject to which we want to attach.  The
                //  Irp parameters contain the Vpb which allows us to get to the
                //  following two things:
                //      1. The device object created by the file system to represent
                //         the volume it just mounted.
                //      2. The device object of the StorageDeviceObject which we
                //         can use to get the name of this volume.  We will pass
                //         this into IoTestAttachToMountedDevice so that it can
                //         use it at needed.
                //

                status = IoTestAttachDeviceObjects( &(completionContext.DeviceObjects),
                                                    vpb->DeviceObject,
                                                    newDevExt->DiskDeviceObject );

                //
                //  This should never fail.
                //
        
                ASSERT( NT_SUCCESS( status ) );

            } else {

                //
                //  Display why mount failed.  Setup the buffers.
                //

                if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_DISPLAY_ATTACHMENT_NAMES )) {

                    RtlInitEmptyUnicodeString( &newDevExt->DeviceNames, 
                                               newDevExt->DeviceNamesBuffer, 
                                               sizeof( newDevExt->DeviceNamesBuffer ) );
                    IoTestGetObjectName( vpb->RealDevice, &newDevExt->DeviceNames );

                    if (!NT_SUCCESS( Irp->IoStatus.Status )) {

                        DbgPrint( "IOTEST (IoTestMountCompletion): Mount volume failure for      \"%wZ\", status=%08x\n",
                                  &newDevExt->DeviceNames,
                                  Irp->IoStatus.Status );

                    } else {

                        DbgPrint( "IOTEST (IoTestMountCompletion): Mount volume failure for      \"%wZ\", already attached\n",
                                  &newDevExt->DeviceNames );
                    }
                }
            }

            //
            //  Continue processing the operation
            //

            status = Irp->IoStatus.Status;

            IoCompleteRequest( Irp, IO_NO_INCREMENT );

            return status;

        } else {

            IOTEST_DBG_PRINT1( IOTESTDEBUG_ERROR,
                                "IOTEST (IoTestFsControl): Error creating volume device object, status=%08x\n", 
                                status );

            //
            //  Something went wrong so this volume cannot be filtered.  Simply
            //  allow the system to continue working normally, if possible.
            //

            return IoTestPassThrough( DeviceObject, Irp );
        }

    } else if (irpSp->MinorFunction == IRP_MN_LOAD_FILE_SYSTEM) {

        //
        //  This is a "load file system" request being sent to a file system
        //  recognizer device object.  This IRP_MN code is only sent to 
        //  file system recognizers.
        //

        IOTEST_DBG_PRINT1( IOTESTDEBUG_DISPLAY_ATTACHMENT_NAMES,
                            "IOTEST (IoTestFsControl): Loading File System, Detaching from \"%wZ\"\n",
                            &devExt->DeviceNames );

        //
        //  Since we have our own private completion routine we need to
        //  do our own logging of this operation, do it now.
        //

        if (SHOULD_LOG( DeviceObject )) {

            //
            // The ControlDevice is opened, so allocate the Record 
            // and log the Irp information if we have the memory.
            //

            recordList = IoTestNewRecord(0);

            if (recordList) {

                IoTestLogIrp( Irp, LOG_ORIGINATING_IRP, recordList );
            }
        }

        //
        //  Set a completion routine so we can delete the device object when
        //  the detach is complete.
        //

        KeInitializeEvent( &waitEvent, SynchronizationEvent, FALSE );

        IoCopyCurrentIrpStackLocationToNext( Irp );

        completionContext.WaitEvent = &waitEvent;
        completionContext.RecordList = recordList;

        IoSetCompletionRoutine(
            Irp,
            IoTestLoadFsCompletion,
            &completionContext,
            TRUE,
            TRUE,
            TRUE );

        //
        //  Detach from the recognizer device.
        //

        IoDetachDevice( devExt->AttachedToDeviceObject );

        //
        //  Call the driver
        //

        status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );

        //
        //  Wait for the completion routine to be called
        //

	    if (STATUS_PENDING == status) {

		    NTSTATUS localStatus = KeWaitForSingleObject(&waitEvent, Executive, KernelMode, FALSE, NULL);
		    ASSERT(STATUS_SUCCESS == localStatus);
	    }

        //
        //  Display the name if requested
        //

        IOTEST_DBG_PRINT2( IOTESTDEBUG_DISPLAY_ATTACHMENT_NAMES,
                            "IOTEST (IoTestLoadFsCompletion): Detaching from recognizer  \"%wZ\", status=%08x\n",
                            &devExt->DeviceNames,
                            Irp->IoStatus.Status );

        //
        //  Check status of the operation
        //

        if (!NT_SUCCESS( Irp->IoStatus.Status )) {

            //
            //  The load was not successful.  Simply reattach to the recognizer
            //  driver in case it ever figures out how to get the driver loaded
            //  on a subsequent call.
            //

            IoAttachDeviceToDeviceStack( DeviceObject, devExt->AttachedToDeviceObject );

        } else {

            //
            //  The load was successful, delete the Device object attached to the
            //  recognizer.
            //

            IoTestCleanupMountedDevice( DeviceObject );
            IoDeleteDevice( DeviceObject );
        }

        //
        //  Continue processing the operation
        //

        status = Irp->IoStatus.Status;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return status;

    } else {

        //
        //  Simply pass this file system control request through.
        //

        return IoTestPassThrough( DeviceObject, Irp );
    }
}

#if 0
NTSTATUS
IoTestSetInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //

    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_IRP_OPS )) {

        IoTestDumpIrpOperation( TRUE, Irp );
    }

    //
    //  See if we should log this IRP
    //

    if (SHOULD_LOG( DeviceObject )) {
        PRECORD_LIST recordList;

        //
        // The ControlDevice is opened, so allocate the Record 
        // and log the Irp information if we have the memory.
        //

        recordList = IoTestNewRecord(0);

        if (recordList) {

            IoTestLogIrp( Irp, LOG_ORIGINATING_IRP, recordList );

            //
            //  Since we are logging this operation, we want to 
            //  call our completion routine.
            //

            IoCopyCurrentIrpStackLocationToNext( Irp );
            IoSetCompletionRoutine( Irp,
                                    IoTestPassThroughCompletion,
                                    (PVOID)recordList,
                                    TRUE,
                                    TRUE,
                                    TRUE);
        } else {

            //
            //  We could not get a record to log with so get this driver out
            //  of the driver stack and get to the next driver as quickly as
            //  possible.
            //

            IoSkipCurrentIrpStackLocation( Irp );
        }

    } else {

        //
        //  We are not logging so get this driver out of the driver stack and
        //  get to the next driver as quickly as possible.
        //

        IoSkipCurrentIrpStackLocation( Irp );
    }

    //
    // Now call the next file system driver with the request.
    //

    return IoCallDriver( ((PIOTEST_DEVICE_EXTENSION)DeviceObject->DeviceExtension)->AttachedToDeviceObject, Irp );
}
#endif

NTSTATUS
IoTestMountCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is invoked for the completion of a mount request.  If the
    mount was successful, then this file system attaches its device object to
    the file system's volume device object.  Otherwise, the interim device
    object is deleted.

Arguments:

    DeviceObject - Pointer to this driver's device object that was attached to
            the file system device object

    Irp - Pointer to the IRP that was just completed.

    Context - Pointer to the device object allocated during the down path so
            we wouldn't have to deal with errors here.

Return Value:

    The return value is always STATUS_SUCCESS.

--*/

{
    PKEVENT event = ((PFS_CONTROL_COMPLETION_CONTEXT)Context)->WaitEvent;
    PRECORD_LIST recordList = ((PFS_CONTROL_COMPLETION_CONTEXT)Context)->RecordList;

    ASSERT(IS_IOTEST_DEVICE_OBJECT( DeviceObject ));

    //
    //  Log the completion routine
    //

    if (SHOULD_LOG( DeviceObject )) {

        IoTestLogIrp( Irp, LOG_COMPLETION_IRP, recordList );
        
        //
        //  Add recordList to our gOutputBufferList so that it gets up to 
        //  the user
        //
        
        IoTestLog( recordList );       

    } else {

        if (recordList) {

            //
            //  Context is set with a RECORD_LIST, but we are no longer
            //  logging so free this record.
            //

            IoTestFreeRecord( recordList );
        }
    }

    //
    //  If an event routine is defined, signal it
    //

    KeSetEvent(event, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
IoTestLoadFsCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is invoked upon completion of an FSCTL function to load a
    file system driver (as the result of a file system recognizer seeing
    that an on-disk structure belonged to it).  A device object has already
    been created by this driver (DeviceObject) so that it can be attached to
    the newly loaded file system.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet representing the file system
          driver load request.

    Context - Context parameter for this driver, unused.

Return Value:

    The function value for this routine is always success.

--*/

{
    PKEVENT event = ((PFS_CONTROL_COMPLETION_CONTEXT)Context)->WaitEvent;
    PRECORD_LIST recordList = ((PFS_CONTROL_COMPLETION_CONTEXT)Context)->RecordList;

    ASSERT(IS_IOTEST_DEVICE_OBJECT( DeviceObject ));

    //
    //  Log the completion routine
    //

    if (SHOULD_LOG( DeviceObject )) {

        IoTestLogIrp( Irp, LOG_COMPLETION_IRP, recordList );
        
        //
        //  Add recordList to our gOutputBufferList so that it gets up to 
        //  the user
        //
        
        IoTestLog( recordList );       

    } else {

        if (recordList) {

            //
            //  Context is set with a RECORD_LIST, but we are no longer
            //  logging so free this record.
            //

            IoTestFreeRecord( recordList );
        }
    }

    //
    //  If an event routine is defined, signal it
    //

    KeSetEvent(event, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


BOOLEAN
IoTestFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for checking to see
    whether fast I/O is possible for this file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be operated on.

    FileOffset - Byte offset in the file for the operation.

    Length - Length of the operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    CheckForReadOperation - Indicates whether the caller is checking for a
        read (TRUE) or a write operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.
    
--*/
{
    PDEVICE_OBJECT    deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN           returnValue = FALSE;
    PRECORD_LIST      recordList;
    BOOLEAN           shouldLog;
    
    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, CHECK_IF_POSSIBLE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( CHECK_IF_POSSIBLE,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        Length,
                                        Wait );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        //
        //  We have a valid DeviceObject, so look at its FastIoDispatch
        //  table for the next driver's Fast IO routine.
        //

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoCheckIfPossible )) {

            returnValue = (fastIoDispatch->FastIoCheckIfPossible)( FileObject,
                                                                   FileOffset,
                                                                   Length,
                                                                   Wait,
                                                                   LockKey,
                                                                   CheckForReadOperation,
                                                                   IoStatus,
                                                                   deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, CHECK_IF_POSSIBLE );
    }
    
    return returnValue;
}

BOOLEAN
IoTestFastIoRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading from a
    file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be read.

    FileOffset - Byte offset in the file of the read.

    Length - Length of the read operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer to receive the data read.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;
    PRECORD_LIST recordList;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, READ );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( READ, 
                                        DeviceObject,
                                        FileObject, 
                                        FileOffset, 
                                        Length, 
                                        Wait );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoRead )) {

            returnValue = (fastIoDispatch->FastIoRead)( FileObject,
                                                        FileOffset,
                                                        Length,
                                                        Wait,
                                                        LockKey,
                                                        Buffer,
                                                        IoStatus,
                                                        deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, READ );
    }
    
    return returnValue;
}

BOOLEAN
IoTestFastIoWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing to a
    file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be written.

    FileOffset - Byte offset in the file of the write operation.

    Length - Length of the write operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer that contains the data to be
        written.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, WRITE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( WRITE,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        Length,
                                        Wait );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoWrite )) {

            returnValue = (fastIoDispatch->FastIoWrite)( FileObject,
                                                         FileOffset,
                                                         Length,
                                                         Wait,
                                                         LockKey,
                                                         Buffer,
                                                         IoStatus,
                                                         deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, WRITE );
    }
    
    return returnValue;
}
 
BOOLEAN
IoTestFastIoQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying basic
    information about the file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;
    PRECORD_LIST recordList;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, QUERY_BASIC_INFO );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( QUERY_BASIC_INFO,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        Wait );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryBasicInfo )) {

            returnValue = (fastIoDispatch->FastIoQueryBasicInfo)( FileObject,
                                                                  Wait,
                                                                  Buffer,
                                                                  IoStatus,
                                                                  deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, QUERY_BASIC_INFO );
    }
    
    return returnValue;
}
 
BOOLEAN
IoTestFastIoQueryStandardInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying standard
    information about the file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, QUERY_STANDARD_INFO );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( QUERY_STANDARD_INFO,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        Wait );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;
    
    if (NULL != deviceObject) {
           
        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryStandardInfo )) {

            returnValue = (fastIoDispatch->FastIoQueryStandardInfo)( FileObject,
                                                                     Wait,
                                                                     Buffer,
                                                                     IoStatus,
                                                                     deviceObject );

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, QUERY_STANDARD_INFO );
    }
    
    return returnValue;
}

BOOLEAN
IoTestFastIoLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    IN BOOLEAN FailImmediately,
    IN BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for locking a byte
    range within a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be locked.

    FileOffset - Starting byte offset from the base of the file to be locked.

    Length - Length of the byte range to be locked.

    ProcessId - ID of the process requesting the file lock.

    Key - Lock key to associate with the file lock.

    FailImmediately - Indicates whether or not the lock request is to fail
        if it cannot be immediately be granted.

    ExclusiveLock - Indicates whether the lock to be taken is exclusive (TRUE)
        or shared.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, LOCK );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( LOCK,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        0,
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoLock )) {

            returnValue = (fastIoDispatch->FastIoLock)( FileObject,
                                                        FileOffset,
                                                        Length,
                                                        ProcessId,
                                                        Key,
                                                        FailImmediately,
                                                        ExclusiveLock,
                                                        IoStatus,
                                                        deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, LOCK );
    }
    
    return returnValue;
}
 
BOOLEAN
IoTestFastIoUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking a byte
    range within a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    FileOffset - Starting byte offset from the base of the file to be
        unlocked.

    Length - Length of the byte range to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the file lock.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, UNLOCK_SINGLE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( UNLOCK_SINGLE,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        0,
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }


    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockSingle )) {

            returnValue = (fastIoDispatch->FastIoUnlockSingle)( FileObject,
                                                                FileOffset,
                                                                Length,
                                                                ProcessId,
                                                                Key,
                                                                IoStatus,
                                                                deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, UNLOCK_SINGLE );
    }
    
    return returnValue;
}
 
BOOLEAN
IoTestFastIoUnlockAll (
    IN PFILE_OBJECT FileObject,
    IN PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, UNLOCK_ALL );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( UNLOCK_ALL,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockAll )) {

            returnValue = (fastIoDispatch->FastIoUnlockAll)( FileObject,
                                                             ProcessId,
                                                             IoStatus,
                                                             deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, UNLOCK_ALL );
    }
    
    return returnValue;
}

BOOLEAN
IoTestFastIoUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    IN PVOID ProcessId,
    IN ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file based on a specified key.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the locks on the file to be released.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, UNLOCK_ALL_BY_KEY );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( UNLOCK_ALL_BY_KEY,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //
    
    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockAllByKey )) {

            returnValue = (fastIoDispatch->FastIoUnlockAllByKey)( FileObject,
                                                                  ProcessId,
                                                                  Key,
                                                                  IoStatus,
                                                                  deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, UNLOCK_ALL_BY_KEY );
    }
    
    return returnValue;
}

BOOLEAN
IoTestFastIoDeviceControl (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for device I/O 
    control operations on a file.
    
    If this I/O is directed to gControlDevice, then the parameters specify
    control commands to IoTest.  These commands are interpreted and handled
    appropriately.

    If this is I/O directed at another DriverObject, this function simply 
    invokes the next driver's corresponding routine, or returns FALSE if 
    the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object representing the device to be
        serviced.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    InputBuffer - Optional pointer to a buffer to be passed into the driver.

    InputBufferLength - Length of the optional InputBuffer, if one was
        specified.

    OutputBuffer - Optional pointer to a buffer to receive data from the
        driver.

    OutputBufferLength - Length of the optional OutputBuffer, if one was
        specified.

    IoControlCode - I/O control code indicating the operation to be performed
        on the device.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

Notes:

    This function does not check the validity of the input/output buffers because
    the ioctl's are implemented as METHOD_BUFFERED.  In this case, the I/O manager
    does the buffer validation checks for us.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //

    if (DeviceObject == gControlDeviceObject) {

        IoTestCommonDeviceIoControl( InputBuffer,
                                     InputBufferLength,
                                     OutputBuffer,
                                     OutputBufferLength,
                                     IoControlCode,
                                     IoStatus,
                                     DeviceObject );

        returnValue = TRUE;

    } else {

        ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );

        //
        //  If the specified debug level is set, output what operation
        //  we are seeing to the debugger.
        //
        
        if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

            IoTestDumpFastIoOperation( TRUE, DEVICE_CONTROL );
        }
        
        //
        //  Perform filespy logging if we care about this device.
        //
        
        if (shouldLog = SHOULD_LOG(DeviceObject)) {

            //
            //
            // Log the necessary information for the start of the Fast I/O 
            // operation
            //

            recordList = IoTestLogFastIoStart( DEVICE_CONTROL,
                                            DeviceObject,
                                            FileObject,
                                            NULL,
                                            0,
                                            Wait );
            if (recordList != NULL) {
                
                IoTestLog(recordList);
            }
        }

        deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

        if (NULL != deviceObject) {

            fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

            if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoDeviceControl )) {

                returnValue = (fastIoDispatch->FastIoDeviceControl)( FileObject,
                                                                     Wait,
                                                                     InputBuffer,
                                                                     InputBufferLength,
                                                                     OutputBuffer,
                                                                     OutputBufferLength,
                                                                     IoControlCode,
                                                                     IoStatus,
                                                                     deviceObject);

            } else {

                IoStatus->Status = STATUS_SUCCESS;
            }
        }

        //
        //  If the specified debug level is set, output what operation
        //  we are seeing to the debugger.
        //
        
        if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

            IoTestDumpFastIoOperation( FALSE, DEVICE_CONTROL );
        }
    }
        
    return returnValue;
}


VOID
IoTestFastIoDetachDevice (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
)
/*++

Routine Description:

    This routine is invoked on the fast path to detach from a device that
    is being deleted.  This occurs when this driver has attached to a file
    system volume device object, and then, for some reason, the file system
    decides to delete that device (it is being dismounted, it was dismounted
    at some point in the past and its last reference has just gone away, etc.)

Arguments:

    SourceDevice - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

    TargetDevice - Pointer to the file system's volume device object.

Return Value:

    None.
    
--*/
{
    PRECORD_LIST recordList;
    BOOLEAN shouldLog;
    PIOTEST_DEVICE_EXTENSION devext;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( SourceDevice ) );

    devext = SourceDevice->DeviceExtension;

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, DETACH_DEVICE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(SourceDevice)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( DETACH_DEVICE, 
                                        SourceDevice, 
                                        NULL, 
                                        NULL, 
                                        0, 
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    IOTEST_DBG_PRINT1( IOTESTDEBUG_DISPLAY_ATTACHMENT_NAMES,
                        "IOTEST (IoTestFastIoDetachDevice): Detaching from volume      \"%wZ\"\n",
                        &devext->DeviceNames );

    //
    // Detach from the file system's volume device object.
    //

    IoTestCleanupMountedDevice( SourceDevice );
    IoDetachDevice( TargetDevice );
    IoDeleteDevice( SourceDevice );

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, DETACH_DEVICE );
    }
}
 
BOOLEAN
IoTestFastIoQueryNetworkOpenInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying network
    information about a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller can handle the file system
        having to wait and tie up the current thread.

    Buffer - Pointer to a buffer to receive the network information about the
        file.

    IoStatus - Pointer to a variable to receive the final status of the query
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, QUERY_NETWORK_OPEN_INFO );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( QUERY_NETWORK_OPEN_INFO,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        Wait );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryNetworkOpenInfo )) {

            returnValue = (fastIoDispatch->FastIoQueryNetworkOpenInfo)( FileObject,
                                                                        Wait,
                                                                        Buffer,
                                                                        IoStatus,
                                                                        deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, QUERY_NETWORK_OPEN_INFO );
    }
    
    return returnValue;
}

BOOLEAN
IoTestFastIoMdlRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading a file
    using MDLs as buffers.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object that is to be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, MDL_READ );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( MDL_READ,
                                        DeviceObject,
                                        FileObject,                  
                                        FileOffset,                  
                                        Length,
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlRead )) {

            returnValue = (fastIoDispatch->MdlRead)( FileObject,
                                                     FileOffset,
                                                     Length,
                                                     LockKey,
                                                     MdlChain,
                                                     IoStatus,
                                                     deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, MDL_READ );
    }

    return returnValue;
}
 
BOOLEAN
IoTestFastIoMdlReadComplete (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read operation.

    This function simply invokes the next driver's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the MdlRead function is supported by the underlying driver, and
    therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL read upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.
    
--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, MDL_READ_COMPLETE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( MDL_READ_COMPLETE,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlReadComplete )) {

            returnValue = (fastIoDispatch->MdlReadComplete)( FileObject,
                                                             MdlChain,
                                                             deviceObject);
        } 
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, MDL_READ_COMPLETE );
    }
    
    return returnValue;
}
 
BOOLEAN
IoTestFastIoPrepareMdlWrite (
    IN  PFILE_OBJECT FileObject,
    IN  PLARGE_INTEGER FileOffset,
    IN  ULONG Length,
    IN  ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN  PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for preparing for an
    MDL write operation.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write 
        operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

// ISSUE-2000-04-26-mollybro Check if this will get an IRP if FALSE is returned 

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, PREPARE_MDL_WRITE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( PREPARE_MDL_WRITE,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        Length,
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, PrepareMdlWrite )) {

            returnValue = (fastIoDispatch->PrepareMdlWrite)( FileObject,
                                                             FileOffset,
                                                             Length,
                                                             LockKey,
                                                             MdlChain,
                                                             IoStatus,
                                                             deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, PREPARE_MDL_WRITE );
    }
    
    return returnValue;
}
 
BOOLEAN
IoTestFastIoMdlWriteComplete (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL write operation.

    This function simply invokes the next driver's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the PrepareMdlWrite function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not
    assumed by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL write upon.

    FileOffset - Supplies the file offset at which the write took place.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, MDL_WRITE_COMPLETE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( MDL_WRITE_COMPLETE,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        0,
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlWriteComplete )) {

            returnValue = (fastIoDispatch->MdlWriteComplete)( FileObject,
                                                              FileOffset,
                                                              MdlChain,
                                                              deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, MDL_WRITE_COMPLETE );
    }
    
    return returnValue;
}
 
BOOLEAN
IoTestFastIoReadCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading 
    compressed data from a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to a buffer to receive the compressed data read.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    CompressedDataInfo - A buffer to receive the description of the 
        compressed data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, READ_COMPRESSED );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( READ_COMPRESSED,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        Length,
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoReadCompressed )) {

            returnValue = (fastIoDispatch->FastIoReadCompressed)( FileObject,
                                                                  FileOffset,
                                                                  Length,
                                                                  LockKey,
                                                                  Buffer,
                                                                  MdlChain,
                                                                  IoStatus,
                                                                  CompressedDataInfo,
                                                                  CompressedDataInfoLength,
                                                                  deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, READ_COMPRESSED );
    }

    return returnValue;
}
 
BOOLEAN
IoTestFastIoWriteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing 
    compressed data to a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write 
        operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to the buffer containing the data to be written.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    CompressedDataInfo - A buffer to containing the description of the
        compressed data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, WRITE_COMPRESSED );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //
        
        recordList = IoTestLogFastIoStart( WRITE_COMPRESSED,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        Length,
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoWriteCompressed )) {

            returnValue = (fastIoDispatch->FastIoWriteCompressed)( FileObject,
                                                                   FileOffset,
                                                                   Length,
                                                                   LockKey,
                                                                   Buffer,
                                                                   MdlChain,
                                                                   IoStatus,
                                                                   CompressedDataInfo,
                                                                   CompressedDataInfoLength,
                                                                   deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, WRITE_COMPRESSED );
    }
    
    return returnValue;
}
 
BOOLEAN
IoTestFastIoMdlReadCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read compressed operation.

    This function simply invokes the next driver's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the read compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not 
    assumed by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed read
        upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.
    
--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, MDL_READ_COMPLETE_COMPRESSED );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( MDL_READ_COMPLETE_COMPRESSED,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlReadCompleteCompressed )) {

            returnValue = (fastIoDispatch->MdlReadCompleteCompressed)( FileObject,
                                                                       MdlChain,
                                                                       deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, MDL_READ_COMPLETE_COMPRESSED );
    }
    
    return returnValue;
}
 
BOOLEAN
IoTestFastIoMdlWriteCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing a
    write compressed operation.

    This function simply invokes the next driver's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the write compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not 
    assumed by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed write
        upon.

    FileOffset - Supplies the file offset at which the file write operation
        began.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, MDL_WRITE_COMPLETE_COMPRESSED );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( MDL_WRITE_COMPLETE_COMPRESSED,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        0,
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //
    
    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlWriteCompleteCompressed )) {

            returnValue = (fastIoDispatch->MdlWriteCompleteCompressed)( FileObject,
                                                                        FileOffset, 
                                                                        MdlChain,
                                                                        deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, MDL_WRITE_COMPLETE_COMPRESSED );
    }
    
    return returnValue;
}
 
BOOLEAN
IoTestFastIoQueryOpen (
    IN PIRP Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for opening a file
    and returning network information it.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    Irp - Pointer to a create IRP that represents this open operation.  It is
        to be used by the file system for common open/create code, but not
        actually completed.

    NetworkInformation - A buffer to receive the information required by the
        network about the file being opened.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN result = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, QUERY_OPEN );
    }

    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( QUERY_OPEN,
                                        DeviceObject,
                                        NULL,
                                        NULL,
                                        0,
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryOpen )) {

            PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );

            irpSp->DeviceObject = deviceObject;

            result = (fastIoDispatch->FastIoQueryOpen)( Irp,
                                                        NetworkInformation,
                                                        deviceObject );
            if (!result) {

                irpSp->DeviceObject = DeviceObject;
            }
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, QUERY_OPEN );
    }
    
    return result;
}

NTSTATUS
IoTestPreFsFilterOperation (
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext
    )
/*++

Routine Description:

    This routine is the FS Filter pre-operation "pass through" routine.

Arguments:

    Data - The FS_FILTER_CALLBACK_DATA structure containing the information
        about this operation.
        
    CompletionContext - A context set by this operation that will be passed
        to the corresponding IoTestPostFsFilterOperation call.
        
Return Value:

    Returns STATUS_SUCCESS if the operation can continue or an appropriate
    error code if the operation should fail.

--*/
{

    PDEVICE_OBJECT deviceObject;
    PRECORD_LIST recordList = NULL;
    BOOLEAN shouldLog;

    UNREFERENCED_PARAMETER( CompletionContext );
    
    PAGED_CODE();

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FSFILTER_OPS )) {

        IoTestDumpFsFilterOperation( TRUE, Data );
    }

    deviceObject = Data->DeviceObject;

    ASSERT( IS_IOTEST_DEVICE_OBJECT( deviceObject ) );

    if (shouldLog = SHOULD_LOG( deviceObject )) {

        recordList = IoTestNewRecord(0);

        if (recordList != NULL) {

            //
            //  Log the necessary information for the start of this
            //  operation.
            //

            IoTestLogPreFsFilterOperation( Data, recordList );
            
            //
            //  Add recordList to our gOutputBufferList so that it gets up to 
            //  the user.  We don't have to worry about freeing the recordList
            //  at this time because it will get free when it is taken off
            //  gOutputBufferList.
            //

            IoTestLog(recordList);       
        }
    }

    return STATUS_SUCCESS;
}

VOID
IoTestPostFsFilterOperation (
    IN PFS_FILTER_CALLBACK_DATA Data,
    IN NTSTATUS OperationStatus,
    IN PVOID CompletionContext
    )
/*++

Routine Description:

    This routine is the FS Filter post-operation "pass through" routine.

Arguments:

    Data - The FS_FILTER_CALLBACK_DATA structure containing the information
        about this operation.
        
    OperationStatus - The status of this operation.        
    
    CompletionContext - A context that was set in the pre-operation 
        callback by this driver.
        
Return Value:

    None.
    
--*/
{

    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( OperationStatus );
    UNREFERENCED_PARAMETER( CompletionContext );

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //

    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FSFILTER_OPS )) {

        IoTestDumpFsFilterOperation( FALSE, Data );
    }

    deviceObject = Data->DeviceObject;

    ASSERT( IS_IOTEST_DEVICE_OBJECT( deviceObject ) );

#if 0
    if ((shouldLog = SHOULD_LOG( deviceObject )) &&
        (recordList != NULL)) {

        //
        //  Log the necessary information for the end of the Fast IO
        //  operation if we have a recordList.
        //

        IoTestLogPostFsFilterOperation( OperationStatus, recordList );

        //
        //  Add recordList to our gOutputBufferList so that it gets up to 
        //  the user.  We don't have to worry about freeing the recordList
        //  at this time because it will get free when it is taken off
        //  gOutputBufferList.
        //

        IoTestLog(recordList);       
        
    } else if (recordList != NULL) {

        //
        //  We are no longer logging for this device, so just
        //  free this recordList entry.
        //

        IoTestFreeRecord( recordList );
    }
#endif
}

NTSTATUS
IoTestCommonDeviceIoControl (
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine does the common processing of interpreting the Device IO Control
    request.

Arguments:

    FileObject - The file object related to this operation.
    
    InputBuffer - The buffer containing the input parameters for this control
        operation.
        
    InputBufferLength - The length in bytes of InputBuffer.
    
    OutputBuffer - The buffer to receive any output from this control operation.
    
    OutputBufferLength - The length in bytes of OutputBuffer.
    
    IoControlCode - The control code specifying what control operation this is.
    
    IoStatus - Receives the status of this operation.
    
    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.
        
Return Value:

    None.
    
--*/
{
    PWSTR deviceName = NULL;
    IOTESTVER fileIoTestVer;

    ASSERT( IoStatus != NULL );
    
    IoStatus->Status      = STATUS_SUCCESS;
    IoStatus->Information = 0;

    try {

        switch (IoControlCode) {
        case IOTEST_Reset:
            IoStatus->Status = STATUS_INVALID_PARAMETER;
            break;

        //
        //      Request to start logging on a device
        //                                      

        case IOTEST_StartLoggingDevice:

            if (InputBuffer == NULL || InputBufferLength <= 0) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }
            
            //
            // Copy the device name and add a null to ensure that it is null terminated
            //

            deviceName =  ExAllocatePool( NonPagedPool, InputBufferLength + sizeof(WCHAR) );

            if (NULL == deviceName) {

                IoStatus->Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            
            RtlCopyMemory( deviceName, InputBuffer, InputBufferLength );
            deviceName[InputBufferLength / sizeof(WCHAR) - 1] = UNICODE_NULL;

            IoStatus->Status = IoTestStartLoggingDevice( DeviceObject,deviceName );
            break;  

        //
        //      Detach from a specified device
        //  

        case IOTEST_StopLoggingDevice:

            if (InputBuffer == NULL || InputBufferLength <= 0) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }
            
            //
            // Copy the device name and add a null to ensure that it is null terminated
            //

            deviceName =  ExAllocatePool( NonPagedPool, InputBufferLength + sizeof(WCHAR) );

            if (NULL == deviceName) {

                IoStatus->Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            
            RtlCopyMemory( deviceName, InputBuffer, InputBufferLength );
            deviceName[InputBufferLength / sizeof(WCHAR) - 1] = UNICODE_NULL;

            IoStatus->Status = IoTestStopLoggingDevice( deviceName );
            break;  

        //
        //      List all the devices that we are currently
        //      monitoring
        //

        case IOTEST_ListDevices:

            if (OutputBuffer == NULL || OutputBufferLength <= 0) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }
                        
            IoStatus->Status = IoTestGetAttachList( OutputBuffer,
                                                    OutputBufferLength,
                                                    &IoStatus->Information);
            break;

        //
        //      Return entries from the log buffer
        //                                      

        case IOTEST_GetLog:

            if (OutputBuffer == NULL || OutputBufferLength == 0) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }

            IoTestGetLog( OutputBuffer, OutputBufferLength, IoStatus );
            break;

        //
        //      Return version of the IoTest filter driver
        //                                      

        case IOTEST_GetVer:

            if ((OutputBufferLength < sizeof(IOTESTVER)) || 
                (OutputBuffer == NULL)) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;                    
            }
            
            fileIoTestVer.Major = IOTEST_MAJ_VERSION;
            fileIoTestVer.Minor = IOTEST_MIN_VERSION;
            
            RtlCopyMemory(OutputBuffer, &fileIoTestVer, sizeof(IOTESTVER));
            
            IoStatus->Information = sizeof (IOTESTVER);
            break;
        
        //
        //      Return hash table statistics
        //                                      

        case IOTEST_GetStats:

            if ((OutputBufferLength < sizeof(HASH_STATISTICS)) || 
                (OutputBuffer == NULL)) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;                    
            }

            RtlCopyMemory( OutputBuffer, &gHashStat, sizeof (HASH_STATISTICS) );
            IoStatus->Information = sizeof (HASH_STATISTICS);
            break;

        //
        //     Tests
        //

        case IOTEST_ReadTest:

            if ((OutputBufferLength < sizeof( IOTEST_STATUS )) ||
                (OutputBuffer == NULL) ||
                (InputBufferLength < sizeof( IOTEST_READ_WRITE_PARAMETERS )) ||
                (InputBuffer == NULL )) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }

            IoTestReadTestDriver( InputBuffer,
                                  InputBufferLength,
                                  OutputBuffer,
                                  OutputBufferLength );

            IoStatus->Status = STATUS_SUCCESS;
            IoStatus->Information = sizeof( IOTEST_STATUS );
            break;

        case IOTEST_RenameTest:

            if ((OutputBufferLength < sizeof( IOTEST_STATUS )) ||
                (OutputBuffer == NULL) ||
                (InputBufferLength < sizeof( IOTEST_RENAME_PARAMETERS )) ||
                (InputBuffer == NULL )) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }

            IoTestRenameTestDriver( InputBuffer,
                                    InputBufferLength,
                                    OutputBuffer,
                                    OutputBufferLength );

            IoStatus->Status = STATUS_SUCCESS;
            IoStatus->Information = sizeof( IOTEST_STATUS );
            break;
            
        case IOTEST_ShareTest:

            if ((OutputBufferLength < sizeof( IOTEST_STATUS )) ||
                (OutputBuffer == NULL) ||
                (InputBufferLength < sizeof( IOTEST_SHARE_PARAMETERS )) ||
                (InputBuffer == NULL )) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }

            IoTestShareTestDriver( InputBuffer,
                                   InputBufferLength,
                                   OutputBuffer,
                                   OutputBufferLength );

            IoStatus->Status = STATUS_SUCCESS;
            IoStatus->Information = sizeof( IOTEST_STATUS );
            break;
            
        default:

            IoStatus->Status = STATUS_INVALID_PARAMETER;
            break;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred while attempting to access
        // one of the caller's parameters.  Simply return an appropriate
        // error status code.
        //

        IoStatus->Status = GetExceptionCode();

    }

    if (NULL != deviceName) {

        ExFreePool( deviceName );
    }

  return IoStatus->Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\iotest\filter\iotestlib.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    ioTestLib.c

Abstract:

    This contains library support routines for IoTest.  These routines
    do the main work for logging the I/O operations --- creating the log
    records, recording the relevant information, attach/detach from
    devices, etc.

// @@BEGIN_DDKSPLIT

Author:

    Molly Brown (mollybro)  

// @@END_DDKSPLIT

Environment:

    Kernel mode

// @@BEGIN_DDKSPLIT
Revision History:

// @@END_DDKSPLIT
--*/

#include <stdio.h>

#include <ntifs.h>
#include "ioTest.h"
#include "ioTestKern.h"

//
//  NameLookup Flags
//
//    These are flags passed to the name lookup routine to identify different
//    ways the name of a file can be obtained
//

#define NAMELOOKUPFL_ONLY_CHECK_CACHE           0x00000001
                // If set, only check in the name cache for the file name.

#define NAMELOOKUPFL_IN_CREATE                  0x00000002
                // if set, we are in the CREATE operation and the full path 
                // filename may need to be built up from the related FileObject.
                
#define NAMELOOKUPFL_OPEN_BY_ID                 0x00000004
                // if set and we are looking up the name in the file object,
                // the file object does not actually contain a name but it
                // contains a file/object ID.

//
//  Macro for copying file name into LogRecord.
//

#define COPY_FILENAME_TO_LOG_RECORD( _logRecord, _hashName, _bytesToCopy ) \
    RtlCopyMemory( (_logRecord).Name, (_hashName), (_bytesToCopy) );       \
    (_logRecord).Length += (_bytesToCopy)

#define NULL_TERMINATE_UNICODE_STRING(_string)                                    \
{                                                                                 \
    ASSERT( (_string)->Length <= (_string)->MaximumLength );                      \
    if ((_string)->Length == (_string)->MaximumLength) {                          \
        (_string)->Length -= sizeof( UNICODE_NULL );                              \
    }                                                                             \
    (_string)->Buffer[(_string)->Length/sizeof( WCHAR )] = UNICODE_NULL;  \
}

#define IOTEST_EXCEED_NAME_BUFFER_MESSAGE           L"FILE NAME EXCEEDS BUFFER SIZE"
#define IOTEST_EXCEED_NAME_BUFFER_MESSAGE_LENGTH    (sizeof( IOTEST_EXCEED_NAME_BUFFER_MESSAGE ) - sizeof( UNICODE_NULL ))
#define IOTEST_ERROR_RETRIEVING_NAME_MESSAGE        L"ERROR RETRIEVING FILE NAME"
#define IOTEST_ERROR_RETRIEVING_NAME_MESSAGE_LENGTH (sizeof( IOTEST_ERROR_RETRIEVING_NAME_MESSAGE ) - sizeof( UNICODE_NULL ))
#define IOTEST_MAX_ERROR_MESSAGE_LENGTH             (max( IOTEST_ERROR_RETRIEVING_NAME_MESSAGE_LENGTH, IOTEST_EXCEED_NAME_BUFFER_MESSAGE_LENGTH))

//////////////////////////////////////////////////////////////////////////
//                                                                      //
//                     Library support routines                         //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID
IoTestReadDriverParameters (
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine tries to read the IoTest-specific parameters from
    the registry.  These values will be found in the registry location
    indicated by the RegistryPath passed in.

Arguments:

    RegistryPath - the path key which contains the values that are
        the IoTest parameters

Return Value:

    None.

--*/
{

    OBJECT_ATTRIBUTES attributes;
    HANDLE driverRegKey;
    NTSTATUS status;
    ULONG bufferSize, resultLength;
    PVOID buffer = NULL;
    UNICODE_STRING valueName;
    PKEY_VALUE_PARTIAL_INFORMATION pValuePartialInfo;

    //
    //  All the global values are already set to default values.  Any
    //  values we read from the registry will override these defaults.
    //
    
    //
    //  Do the initial setup to start reading from the registry.
    //

    InitializeObjectAttributes( &attributes,
								RegistryPath,
								OBJ_CASE_INSENSITIVE,
								NULL,
								NULL);

    status = ZwOpenKey( &driverRegKey,
						KEY_READ,
						&attributes);

    if (!NT_SUCCESS(status)) {

        driverRegKey = NULL;
        goto IoTestReadDriverParameters_Exit;
    }

    bufferSize = sizeof( KEY_VALUE_PARTIAL_INFORMATION ) + sizeof( ULONG );
    buffer = ExAllocatePool( NonPagedPool, bufferSize );

    if (NULL == buffer) {

        goto IoTestReadDriverParameters_Exit;
    }

    //
    // Read the gMaxRecordsToAllocate from the registry
    //

    RtlInitUnicodeString(&valueName, MAX_RECORDS_TO_ALLOCATE);

    status = ZwQueryValueKey( driverRegKey,
							  &valueName,
							  KeyValuePartialInformation,
							  buffer,
							  bufferSize,
							  &resultLength);

    if (NT_SUCCESS(status)) {

        pValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
        ASSERT(pValuePartialInfo->Type == REG_DWORD);
        gMaxRecordsToAllocate = *((PLONG)&(pValuePartialInfo->Data));

    }

    //
    // Read the gMaxNamesToAllocate from the registry
    //

    RtlInitUnicodeString(&valueName, MAX_NAMES_TO_ALLOCATE);

    status = ZwQueryValueKey( driverRegKey,
							  &valueName,
							  KeyValuePartialInformation,
							  buffer,
							  bufferSize,
							  &resultLength);

    if (NT_SUCCESS(status)) {

        pValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
        ASSERT(pValuePartialInfo->Type == REG_DWORD);
        gMaxNamesToAllocate = *((PLONG)&(pValuePartialInfo->Data));

    }

    //
    // Read the initial debug setting from the registry
    //

    RtlInitUnicodeString(&valueName, DEBUG_LEVEL);

    status = ZwQueryValueKey( driverRegKey,
                              &valueName,
                              KeyValuePartialInformation,
                              buffer,
                              bufferSize,
                              &resultLength );

    if (NT_SUCCESS( status )) {

        pValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
        ASSERT( pValuePartialInfo->Type == REG_DWORD );
        gIoTestDebugLevel |= *((PULONG)&(pValuePartialInfo->Data));
        
    }
    
    //
    // Read the attachment mode setting from the registry
    //

    RtlInitUnicodeString(&valueName, ATTACH_MODE);

    status = ZwQueryValueKey( driverRegKey,
                              &valueName,
                              KeyValuePartialInformation,
                              buffer,
                              bufferSize,
                              &resultLength );

    if (NT_SUCCESS( status )) {

        pValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
        ASSERT( pValuePartialInfo->Type == REG_DWORD );
        gIoTestAttachMode = *((PULONG)&(pValuePartialInfo->Data));
        
    }
    
    goto IoTestReadDriverParameters_Exit;

IoTestReadDriverParameters_Exit:

    if (NULL != buffer) {

        ExFreePool(buffer);
    }

    if (NULL != driverRegKey) {

        ZwClose(driverRegKey);
    }

    return;
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                  Memory allocation routines                        //
//                                                                    //
////////////////////////////////////////////////////////////////////////

PVOID
IoTestAllocateBuffer (
    IN OUT PLONG Counter,
    IN LONG MaxCounterValue,
    OUT PULONG RecordType
    )
/*++

Routine Description:

    Allocates a new buffer from the gFreeBufferList if there is enough memory
    to do so and Counter does not exceed MaxCounterValue.  The RecordType
    is set to one of the record type constants based on the allocation state.

Arguments:

    Counter - (optional) the counter variable to test and increment if
        we can allocate
    MaxCounterValue - (ignored if Counter not given) the value which
        Counter should not exceed
    RecordType - (optional) set to one of the following:
        RECORD_TYPE_NORMAL  allocation succeeded
        RECORD_TYPE_OUT_OF_MEMORY allocation failed because the system was
                                  out of memory
        RECORD_TYPE_EXCEED_MEMORY_ALLOWANCE allocation failed because the
                                counter exceeded its maximum value.

Return Value:

    Pointer to the buffer allocate, or NULL if allocation failed (either
    because system is out of memory or we have exceeded the MaxCounterValue).

--*/
{
    PVOID newBuffer;
    ULONG newRecordType = RECORD_TYPE_NORMAL;

#ifdef MEMORY_DBG
    //
    //  When we are debugging the memory usage to make sure that we
    //  don't leak memory, we want to allocate the memory from pool
    //  so that we can use the Driver Verifier to help debug any
    //  memory problems.
    //

    newBuffer = ExAllocatePoolWithTag( NonPagedPool, RECORD_SIZE, MSFM_TAG );
#else

    //
    //  When we are not debugging the memory usage, we use a look-aside
    //  list for better performance.
    //

    newBuffer = ExAllocateFromNPagedLookasideList( &gFreeBufferList );
#endif

    if (newBuffer) {

        if (Counter) {

            if (*Counter < MaxCounterValue) {

                InterlockedIncrement(Counter);

            } else {

				//
                // We've exceed our driver's memory limit so note that
                // and give back the record
				//

                SetFlag( newRecordType, 
                         (RECORD_TYPE_STATIC | RECORD_TYPE_EXCEED_MEMORY_ALLOWANCE) );

#ifdef MEMORY_DBG
                ExFreePool( newBuffer );
#else
                ExFreeToNPagedLookasideList( &gFreeBufferList, newBuffer );
#endif

                newBuffer = NULL;
            }
        }

    }  else {

        SetFlag( newRecordType,
                 (RECORD_TYPE_STATIC | RECORD_TYPE_OUT_OF_MEMORY) );
    }

    if (RecordType) {

        *RecordType = newRecordType;
    }

    return newBuffer;
}

VOID
IoTestFreeBuffer (
    IN PVOID Buffer,
    IN PLONG Counter
    )
/*++

Routine Description:

    Returns a Buffer to the gFreeBufferList.

Arguments:

    Buffer - the buffer to return to the gFreeBufferList

Return Value:

    None.

--*/
{

#ifdef MEMORY_DBG
    ExFreePool( Buffer );
#else
    ExFreeToNPagedLookasideList( &gFreeBufferList, Buffer );
#endif

    //
    // Update the count
    //
    if (Counter) {

        InterlockedDecrement(Counter);
    }
}


////////////////////////////////////////////////////////////////////////
//                                                                    //
//                  Logging routines                                  //
//                                                                    //
////////////////////////////////////////////////////////////////////////

PRECORD_LIST
IoTestNewRecord (
    IN ULONG AssignedSequenceNumber
    )
/*++

Routine Description:

    Allocates a new RECORD_LIST structure if there is enough memory to do so. A
    sequence number is updated for each request for a new record.

Arguments:

    AssignedSequenceNumber - 0 if you want this function to generate the
        next sequence number; if not 0, the new record is assigned the
        given sequence number.

Return Value:

    Pointer to the RECORD_LIST allocated, or NULL if no memory is available.

--*/
{
    PRECORD_LIST newRecord = NULL;
    ULONG currentSequenceNumber;
    KIRQL irql;
    ULONG initialRecordType;

    newRecord = (PRECORD_LIST) IoTestAllocateBuffer( &gRecordsAllocated,
                                                  gMaxRecordsToAllocate,
                                                  &initialRecordType);

    KeAcquireSpinLock(&gLogSequenceLock, &irql);

    //
    // Assign a new sequence number if 0 was passed in, otherwise use the
    // number passed in
    //

    if (AssignedSequenceNumber == 0) {

        gLogSequenceNumber++;
        currentSequenceNumber = gLogSequenceNumber;

    } else {

        currentSequenceNumber = AssignedSequenceNumber;
    }


    if ((newRecord == NULL) &&
        !InterlockedCompareExchange( &gStaticBufferInUse, TRUE, FALSE)) {

        //
        // Toggle on our gStaticBufferInUse flag and use the static out of memory
        // buffer to record this log entry.  This special log record is used
        // to notify the user application that we are out of memory.  Log
        // request will be dropped until we can get more memory.
        //

        newRecord   = (PRECORD_LIST)gOutOfMemoryBuffer;
        newRecord->LogRecord.RecordType = initialRecordType;
        newRecord->LogRecord.Length = SIZE_OF_LOG_RECORD;
        newRecord->LogRecord.SequenceNumber = currentSequenceNumber;

    } else if (newRecord) {

		//
        // We were able to allocate a new record so initialize it
        // appropriately.
		//

        newRecord->LogRecord.RecordType = initialRecordType;
        newRecord->LogRecord.Length = SIZE_OF_LOG_RECORD;
        newRecord->LogRecord.SequenceNumber = currentSequenceNumber;
    }

    KeReleaseSpinLock(&gLogSequenceLock, irql);

    return( newRecord );
}

VOID
IoTestFreeRecord (
    IN PRECORD_LIST Record
    )
/*++

Routine Description:

    Frees a RECORD_LIST, which returns the memory to the gFreeBufferList look-aside
    list and updates the gRecordsAllocated count.

Arguments:

    Record - the record to free

Return Value:

    None.

--*/
{
    if (FlagOn( Record->LogRecord.RecordType, RECORD_TYPE_STATIC )) {

		//
        // This is our static record, so reset our gStaticBufferInUse
        // flag.
		//

        InterlockedExchange( &gStaticBufferInUse, FALSE );

    } else {

		//
        // This isn't our static memory buffer, so free the dynamically
        // allocated memory.
		//

        IoTestFreeBuffer( Record, &gRecordsAllocated );
    }
}

VOID
IoTestLogIrp (
    IN PIRP Irp,
    IN UCHAR LoggingFlags,
    OUT PRECORD_LIST RecordList
    )
/*++

Routine Description:

    Records the Irp necessary information according to LoggingFlags in
    RecordList.  For any activity on the Irp path of a device being
    logged, this function should get called twice: once on the Irp's
    originating path and once on the Irp's completion path.

Arguments:

    Irp - The Irp that contains the information we want to record.
    LoggingFlags - The flags that say what to log.
    RecordList - The PRECORD_LIST in which the Irp information is stored.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION pIrpStack;
    PRECORD_IRP pRecordIrp;
    PIOTEST_DEVICE_EXTENSION deviceExtension;
    ULONG lookupFlags;

    pRecordIrp = &RecordList->LogRecord.Record.RecordIrp;

    pIrpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = pIrpStack->DeviceObject->DeviceExtension;


    if (FlagOn( LoggingFlags, LOG_ORIGINATING_IRP )) {

        //
        // Record the information we use for an originating Irp.  We first
        // need to initialize some of the RECORD_LIST and RECORD_IRP fields.
        // Then get the interesting information from the Irp.
        //

        SetFlag( RecordList->LogRecord.RecordType, RECORD_TYPE_IRP );

        RecordList->LogRecord.DeviceType = deviceExtension->Type;
        
        pRecordIrp->IrpMajor        = pIrpStack->MajorFunction;
        pRecordIrp->IrpMinor        = pIrpStack->MinorFunction;
        pRecordIrp->IrpFlags        = Irp->Flags;
        pRecordIrp->FileObject      = (FILE_ID)pIrpStack->FileObject;
        pRecordIrp->ProcessId       = (FILE_ID)PsGetCurrentProcessId();
        pRecordIrp->ThreadId        = (FILE_ID)PsGetCurrentThreadId();
        pRecordIrp->Argument1       = pIrpStack->Parameters.Others.Argument1;
        pRecordIrp->Argument2       = pIrpStack->Parameters.Others.Argument2;
        pRecordIrp->Argument3       = pIrpStack->Parameters.Others.Argument3;
        pRecordIrp->Argument4       = pIrpStack->Parameters.Others.Argument4;

        if (IRP_MJ_CREATE == pRecordIrp->IrpMajor) {

			//
			//  Only record the desired access if this is a CREATE irp.
			//

            pRecordIrp->DesiredAccess = pIrpStack->Parameters.Create.SecurityContext->DesiredAccess;
        }

        KeQuerySystemTime(&(pRecordIrp->OriginatingTime));

        lookupFlags = 0;

        if (IRP_MJ_CREATE == pIrpStack->MajorFunction) {

            SetFlag( lookupFlags, NAMELOOKUPFL_IN_CREATE );

            if (FlagOn( pIrpStack->Parameters.Create.Options, FILE_OPEN_BY_FILE_ID )) {

                SetFlag( lookupFlags, NAMELOOKUPFL_OPEN_BY_ID );
            }
        }

        //
        //  We can only look up the name in the name cache if this is a CLOSE.  
        //  It is possible that the close could be occurring during a cleanup 
        //  operation in the file system (i.e., before we have received the
        //  cleanup completion) and requesting the name would cause a deadlock
        //  in the file system.
        //  
        if (pIrpStack->MajorFunction == IRP_MJ_CLOSE) {

            SetFlag( lookupFlags, NAMELOOKUPFL_ONLY_CHECK_CACHE );
        }

        IoTestNameLookup( RecordList, pIrpStack->FileObject, lookupFlags, deviceExtension);
    }

#if 0
    if (FlagOn( LoggingFlags, LOG_COMPLETION_IRP )) {

        //
        // Record the information we use for a completion Irp.
        //

        pRecordIrp->ReturnStatus = Irp->IoStatus.Status;
        pRecordIrp->ReturnInformation = Irp->IoStatus.Information;
        KeQuerySystemTime(&(pRecordIrp->CompletionTime));
    }
#endif     
}

PRECORD_LIST
IoTestLogFastIoStart (
    IN FASTIO_TYPE FastIoType,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PLARGE_INTEGER FileOffset OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN BOOLEAN Wait	OPTIONAL
    )
/*++

Routine Description:

    Creates the log record if possible and records the necessary Fast I/O
    information at the beginning of the fast I/O operation in RecordList
    according to LoggingFlags.

    The optional arguments are not recorded for all Fast I/O types.  If
    the argument is not needed for a given Fast I/O type, the parameter
    was ignored.

Arguments:

    FastIoType - The type of fast I/O we are logging (REQUIRED)
    DeviceObject - The device object for our filter. (REQUIRED)
    FileObject - Pointer to the file object this operation is on (OPTIONAL)
    FileOffset - Pointer to the file offset for this operation (OPTIONAL)
    Length - Length of the data for this operation (OPTIONAL)
    Wait - Whether or not this operation can wait for a result (OPTIONAL)

Return Value:

    The RECORD_LIST structure created with the appropriate information
    filled in.  If a RECORD_LIST structure couldn't be allocated, NULL
    is returned.

--*/
{
    PRECORD_LIST    pRecordList;
    PRECORD_FASTIO  pRecordFastIo;
    PIOTEST_DEVICE_EXTENSION deviceExtension;

    //
    // Try to get a new record
    //

    pRecordList = IoTestNewRecord(0);

    //
    // If we didn't get a RECORD_LIST, exit and return NULL
    //

    if (pRecordList == NULL) {

        return NULL;
    }

    deviceExtension = DeviceObject->DeviceExtension;
    
    //
    // We got a RECORD_LIST, so now fill in the appropriate information
    //

    pRecordFastIo = &pRecordList->LogRecord.Record.RecordFastIo;

    //
    // Perform the necessary book keeping for the RECORD_LIST
    //

    SetFlag( pRecordList->LogRecord.RecordType, RECORD_TYPE_FASTIO );

    //
    //  Record which device is seeing this operation.
    //
    
    pRecordList->LogRecord.DeviceType = deviceExtension->Type;

    //
    // Set the RECORD_FASTIO fields that are set for all Fast I/O types
    //

    pRecordFastIo->Type = FastIoType;
    KeQuerySystemTime(&(pRecordFastIo->StartTime));

    //
    // Get process and thread information
    //

    pRecordFastIo->ProcessId = (ULONG_PTR) PsGetCurrentProcessId();
    pRecordFastIo->ThreadId = (ULONG_PTR) PsGetCurrentThreadId();

    //
    // Record the information that is appropriate based on the
    // Fast I/O type
    //

    pRecordFastIo->FileObject = (FILE_ID)FileObject;
    pRecordFastIo->FileOffset.QuadPart = ((FileOffset != NULL) ? FileOffset->QuadPart : 0);
    pRecordFastIo->Length = Length;
    pRecordFastIo->Wait = Wait;

    IoTestNameLookup(pRecordList, FileObject, 0, deviceExtension);

    return pRecordList;
}

#if 0
VOID
IoTestLogFastIoComplete (
    IN PIO_STATUS_BLOCK ReturnStatus,
    IN PRECORD_LIST RecordList
    )
/*++

Routine Description:

    Records the necessary Fast I/O information in RecordList according to
    LoggingFlags.

    The optional arguments are not recorded for all Fast I/O types.  If
    the argument is not needed for a given Fast I/O type, the parameter
    was ignored.

Arguments:
    ReturnStatus - The return value of the operation (OPTIONAL)
    RecordList - The PRECORD_LIST in which the Fast I/O information is stored.

Return Value:

    None.

--*/
{
    PRECORD_FASTIO pRecordFastIo;

    ASSERT(RecordList);

    pRecordFastIo = &RecordList->LogRecord.Record.RecordFastIo;

    //
    // Set the RECORD_FASTIO fields that are set for all Fast I/O types
    //

    KeQuerySystemTime(&(pRecordFastIo->CompletionTime));

    if (ReturnStatus != NULL) {

        pRecordFastIo->ReturnStatus = ReturnStatus->Status;

    } else {

        pRecordFastIo->ReturnStatus = 0;
    }

    IoTestLog(RecordList);
}
#endif

VOID
IoTestLogPreFsFilterOperation (
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PRECORD_LIST RecordList
    )
{
    PIOTEST_DEVICE_EXTENSION deviceExtension;
    
    PRECORD_FS_FILTER_OPERATION pRecordFsFilterOp;

    deviceExtension = Data->DeviceObject->DeviceExtension;

    pRecordFsFilterOp = &RecordList->LogRecord.Record.RecordFsFilterOp;
    
    //
    // Record the information we use for an originating Irp.  We first
    // need to initialize some of the RECORD_LIST and RECORD_IRP fields.
    // Then get the interesting information from the Irp.
    //

    SetFlag( RecordList->LogRecord.RecordType, RECORD_TYPE_FS_FILTER_OP );

    RecordList->LogRecord.DeviceType = deviceExtension->Type;
    
    pRecordFsFilterOp->FsFilterOperation = Data->Operation;
    pRecordFsFilterOp->FileObject = (FILE_ID) Data->FileObject;
    pRecordFsFilterOp->ProcessId = (FILE_ID)PsGetCurrentProcessId();
    pRecordFsFilterOp->ThreadId = (FILE_ID)PsGetCurrentThreadId();
    
    KeQuerySystemTime(&(pRecordFsFilterOp->OriginatingTime));

    //
    //  Only set the volumeName if the next device is a file system
    //  since we only want to prepend the volumeName if we are on
    //  top of a local file system.
    //

    IoTestNameLookup( RecordList, Data->FileObject, 0, deviceExtension);
}

#if 0
VOID
IoTestLogPostFsFilterOperation (
    IN NTSTATUS OperationStatus,
    OUT PRECORD_LIST RecordList
    )
{
    PRECORD_FS_FILTER_OPERATION pRecordFsFilterOp;

    pRecordFsFilterOp = &RecordList->LogRecord.Record.RecordFsFilterOp;
    
    //
    // Record the information we see in the post operation.
    //

    pRecordFsFilterOp->ReturnStatus   = OperationStatus;
    KeQuerySystemTime(&(pRecordFsFilterOp->CompletionTime));
}
#endif

NTSTATUS
IoTestLog (
    IN PRECORD_LIST NewRecord
    )
/*++

Routine Description:

    This routine appends the completed log record to the gOutputBufferList.

Arguments:

    NewRecord - The record to append to the gOutputBufferList

Return Value:

    The function returns STATUS_SUCCESS.



--*/
{
    KIRQL controlDeviceIrql;
    KIRQL outputBufferIrql;

    KeAcquireSpinLock( &gControlDeviceStateLock, &controlDeviceIrql );

    if (gControlDeviceState == OPENED) {

        //
        // The device is still open so add this record onto the list
        //

        KeAcquireSpinLock(&gOutputBufferLock, &outputBufferIrql);
        InsertTailList(&gOutputBufferList, &NewRecord->List);
        KeReleaseSpinLock(&gOutputBufferLock, outputBufferIrql);

    } else {

        //
        // We can no longer log this record, so free the record
        //

        IoTestFreeRecord( NewRecord );

    }

    KeReleaseSpinLock( &gControlDeviceStateLock, controlDeviceIrql );

    return STATUS_SUCCESS;
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                    FileName cache routines                         //
//                                                                    //
////////////////////////////////////////////////////////////////////////

PHASH_ENTRY
IoTestHashBucketLookup (
    IN PLIST_ENTRY  ListHead,
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    This routine looks up the FileObject in the give hash bucket.  This routine
    does NOT lock the hash bucket.

Arguments:

    ListHead - hash list to search
    FileObject - the FileObject to look up.

Return Value:

    A pointer to the hash table entry.  NULL if not found

--*/
{
    PHASH_ENTRY pHash;
    PLIST_ENTRY pList;

    pList = ListHead->Flink;

    while (pList != ListHead){

        pHash = CONTAINING_RECORD( pList, HASH_ENTRY, List );

        if (FileObject == pHash->FileObject) {

            return pHash;
        }

        pList = pList->Flink;
    }

    return NULL;
}

VOID
IoTestNameLookup (
    IN PRECORD_LIST RecordList,
    IN PFILE_OBJECT FileObject,
    IN ULONG LookupFlags,
    IN PIOTEST_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    This routine looks up the FileObject in the hash table.  If the FileObject
    is found in the hash table, copy the associated file name to RecordList.
    Otherwise, calls IoTestGetFullPathName to try to get the name of the FileObject.
    If successful, copy the file name to the RecordList and insert into hash
    table.

Arguments:

    RecordList - RecordList to copy name to.
    FileObject - the FileObject to look up.
    LookInFileObject - see routine description
    DeviceExtension - contains the volume name (e.g., "c:") and
        the next device object which may be needed.

Return Value:

    None.
    
--*/
{
    UINT_PTR hashIndex;
    KIRQL oldIrql;
    PHASH_ENTRY pHash;
    PHASH_ENTRY newHash;
    PLIST_ENTRY listHead;
    PUNICODE_STRING newName;
    PCHAR buffer;
    SHORT bytesToCopy;

    if (FileObject == NULL) {

        return;
    }

    hashIndex = HASH_FUNC(FileObject);

    gHashStat.Lookups++;

    KeAcquireSpinLock( &gHashLockTable[hashIndex], &oldIrql );

    listHead = &gHashTable[hashIndex];

    pHash = IoTestHashBucketLookup(&gHashTable[hashIndex], FileObject);

    if (pHash != NULL) {

        bytesToCopy = min( MAX_NAME_SPACE, pHash->Name.Length );

        ASSERT((bytesToCopy > 0) && (bytesToCopy <= MAX_NAME_SPACE));

        //
        //  Copy the file name to the LogRecord, make sure that it is NULL terminated,
        //  and increment the length of the LogRecord.
        //

        COPY_FILENAME_TO_LOG_RECORD( RecordList->LogRecord, pHash->Name.Buffer, bytesToCopy );
        
        KeReleaseSpinLock(&gHashLockTable[hashIndex], oldIrql);

        gHashStat.LookupHits++;

        return;
    }

    KeReleaseSpinLock(&gHashLockTable[hashIndex], oldIrql);

    if (FlagOn( LookupFlags, NAMELOOKUPFL_ONLY_CHECK_CACHE )) {

        //
        //  We didn't find the name in the cache, but we can't ask the 
        //  file system now, so just return.
        //

        return;
    }

    //
    //  If it is not in the table, try to add it.  We will not be able to look up
    //  the name if we are at DISPATCH_LEVEL.
    //

    buffer = IoTestAllocateBuffer(&gNamesAllocated, gMaxNamesToAllocate, NULL);

    if (buffer != NULL) {
    
        newHash = (PHASH_ENTRY) buffer;
        newName = &newHash->Name;

        RtlInitEmptyUnicodeString(
                newName,
                (PWCHAR)(buffer + sizeof(HASH_ENTRY)),
                RECORD_SIZE - sizeof(HASH_ENTRY) );

        if (IoTestGetFullPathName( FileObject, newName, DeviceExtension, LookupFlags )) {

            newHash->FileObject = FileObject;
            KeAcquireSpinLock(&gHashLockTable[hashIndex], &oldIrql);

            //
            //  Search again because it may have been stored in the
            //  hash table since we dropped the lock.
            //
			
			pHash = IoTestHashBucketLookup(&gHashTable[hashIndex], FileObject);

            if (pHash != NULL) {

                //
                //  We found it in the hash table this time, so
                //  write the name we found to the LogRecord.
                //

                bytesToCopy = min(
                    MAX_NAME_SPACE,
                    pHash->Name.Length );

                ASSERT( (bytesToCopy > 0) && (bytesToCopy <= MAX_NAME_SPACE) );

                //
                //  Copy the file name to the LogRecord, make sure that it is NULL terminated,
                //  and increment the length of the LogRecord.
                //

                COPY_FILENAME_TO_LOG_RECORD( RecordList->LogRecord, pHash->Name.Buffer, bytesToCopy );

                KeReleaseSpinLock(&gHashLockTable[hashIndex], oldIrql);

                IoTestFreeBuffer(buffer, &gNamesAllocated);

                return;
            }

            //
            // It wasn't found, add the new entry
            //

            bytesToCopy = min( MAX_NAME_SPACE, newHash->Name.Length );

            ASSERT(bytesToCopy > 0 && bytesToCopy <= MAX_NAME_SPACE);

            //
            //  Copy the file name to the LogRecord, make sure that it is NULL terminated,
            //  and increment the length of the LogRecord.
            //

            COPY_FILENAME_TO_LOG_RECORD( RecordList->LogRecord, newHash->Name.Buffer, bytesToCopy );

            InsertHeadList(listHead, &newHash->List);

            gHashCurrentCounters[hashIndex]++;

            if (gHashCurrentCounters[hashIndex] > gHashMaxCounters[hashIndex]) {

                gHashMaxCounters[hashIndex] = gHashCurrentCounters[hashIndex];
            }

            KeReleaseSpinLock(&gHashLockTable[hashIndex], oldIrql);

        } else {

            IoTestFreeBuffer (buffer, &gNamesAllocated);
        }
    }

    return;
}

VOID
IoTestNameDeleteAllNames (
    VOID
    )
/*++

Routine Description:

    This will free all entries from the hash table

Arguments:

    None

Return Value:

    None


--*/
{
    KIRQL oldIrql;
    PHASH_ENTRY pHash;
    PLIST_ENTRY pList;
    ULONG i;

    for (i=0;i < HASH_SIZE;i++) {

        KeAcquireSpinLock(&gHashLockTable[i], &oldIrql);

        while (!IsListEmpty(&gHashTable[i])) {

            pList = RemoveHeadList(&gHashTable[i]);
            pHash = CONTAINING_RECORD( pList, HASH_ENTRY, List );
            IoTestFreeBuffer( pHash, &gNamesAllocated);
        }

        gHashCurrentCounters[i] = 0;

        KeReleaseSpinLock(&gHashLockTable[i], oldIrql);
    }
}

VOID
IoTestNameDelete (
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    This routine looks up the FileObject in the hash table.  If it is found,
    it deletes it and frees the memory.

Arguments:

    FileObject - the FileObject to look up.

Return Value:

    None


--*/
{
    UINT_PTR hashIndex;
    KIRQL oldIrql;
    PHASH_ENTRY pHash;
    PLIST_ENTRY pList;
    PLIST_ENTRY listHead;

    hashIndex = HASH_FUNC(FileObject);

    gHashStat.DeleteLookups++;

    KeAcquireSpinLock(&gHashLockTable[hashIndex], &oldIrql);

    listHead = &gHashTable[hashIndex];

    pList = listHead->Flink;

    while(pList != listHead){

        pHash = CONTAINING_RECORD( pList, HASH_ENTRY, List );

        if (FileObject == pHash->FileObject) {

            gHashStat.DeleteLookupHits++;
            gHashCurrentCounters[hashIndex]--;
            RemoveEntryList(pList);
            IoTestFreeBuffer( pHash, &gNamesAllocated );
            break;
        }

        pList = pList->Flink;
    }

    KeReleaseSpinLock(&gHashLockTable[hashIndex], oldIrql);
}

BOOLEAN
IoTestGetFullPathName (
    IN PFILE_OBJECT FileObject,
    IN OUT PUNICODE_STRING FileName,
    IN PIOTEST_DEVICE_EXTENSION DeviceExtension,
    IN ULONG LookupFlags
    )
/*++

Routine Description:

    This routine retrieves the full pathname of the FileObject.  Note that
    the buffers containing pathname components may be stored in paged pool,
    therefore if we are at DISPATCH_LEVEL we cannot look up the name.

    The file is looked up one of the following ways based on the LookupFlags:
    1.  FlagOn( FileObject->Flags, FO_VOLUME_OPEN ) or FileObject->FileName.Length == 0.
        This is a volume open, so just use DeviceName from the DeviceExtension 
        for the FileName, if it exists.
    2.  NAMELOOKUPFL_IN_CREATE and NAMELOOKUPFL_OPEN_BY_ID are set.
        This is an open by file id, so format the file id into the FileName
        string if there is enough room.
    3.  NAMELOOKUPFL_IN_CREATE set and FileObject->RelatedFileObject != NULL.
        This is a relative open, therefore the fullpath file name must
        be built up from the name of the FileObject->RelatedFileObject
        and FileObject->FileName.
    4.  NAMELOOKUPFL_IN_CREATE and FileObject->RelatedFileObject == NULL.
        This is an absolute open, therefore the fullpath file name is
        found in FileObject->FileName.
    5.  No LookupFlags set.
        This is a lookup sometime after CREATE.  FileObject->FileName is 
        no longer guaranteed to be valid, so use ObQueryNameString
        to get the fullpath name of the FileObject.
    
Arguments:

    FileObject - Pointer to the FileObject to the get name of.

    FileName - Unicode string that will be filled in with the filename,  It 
        is assumed that the caller allocates and frees the memory used by 
        the string.  The buffer and MaximumLength for this string should be 
        set.  If there is room in the buffer, the string will be NULL 
        terminated.

    DeviceExtension - Contains the device name and next device object
        which are needed to build the full path name.

    LookupFlags - The flags to say whether to get the name from the file
        object or to get the file id.

Return Value:

    Returns TRUE if the name is successfully found (the name could
    be a NULL string) and should be copied into the LogRecord, or FALSE 
    if the FileName should not be copied into the LogRecord.

--*/
{
    NTSTATUS status;

    //
    //  Check to make sure that parameters are valid.
    //
    
    if ((NULL == FileObject) ||
        (NULL == FileName) ||
        (NULL == DeviceExtension) ||
        (FlagOn( LookupFlags, NAMELOOKUPFL_OPEN_BY_ID ) &&
         !FlagOn( LookupFlags, NAMELOOKUPFL_IN_CREATE ))) {

        return FALSE;
    }

    //
    // Names buffers in file objects might be paged.
    //

    if (KeGetCurrentIrql() > PASSIVE_LEVEL) {

        return FALSE;
    }

    //
    //  Copy over the name the user gave for this device.  These names
    //  should be meaningful to the user.
    //
    
    RtlCopyUnicodeString( FileName, &(DeviceExtension->UserNames) );

    //
    //  Make sure we at least have enough room for our name error messages.
    //

    if ((FileName->Length + IOTEST_MAX_ERROR_MESSAGE_LENGTH) > FileName->MaximumLength) {

        return FALSE;
    }

    //
    //  Do a quick check here to see if we even have enough
    //  room in FileName for the FileObject->FileName.  If
    //  not, there is no use doing the work to build up the
    //  rest of the name.
    //

    if ((FileName->Length + FileObject->FileName.Length) > FileName->MaximumLength) {

        //
        //  We don't have enough room in FileName, so just return
        //  IOTEST_EXCEED_NAME_BUFFER_MESSAGE
        //

        RtlAppendUnicodeToString( FileName, IOTEST_EXCEED_NAME_BUFFER_MESSAGE );
        
        return TRUE;
    }
       
    //
    //  CASE 1:  This FileObject refers to a Volume open.
    //

    if (FlagOn( FileObject->Flags, FO_VOLUME_OPEN )) {

        //
        //  We've already copied over VolumeName to FileName if
        //  we've got VolumeName, so just return.
        //

        return TRUE;
    }

    //
    //  CASE 2:  We are opening the file by ID.
    //

    else if (FlagOn( LookupFlags, NAMELOOKUPFL_IN_CREATE ) &&
             FlagOn( LookupFlags, NAMELOOKUPFL_OPEN_BY_ID )) {

#       define OBJECT_ID_KEY_LENGTH 16
#       define OBJECT_ID_STRING_LENGTH 64

        UNICODE_STRING fileIdName;
        WCHAR fileIdBuffer[OBJECT_ID_STRING_LENGTH];
        PUCHAR idBuffer;

        if (FileObject->FileName.Length == sizeof(LONGLONG)) {

			//
            //  Opening by FILE ID, generate a name
			//
			
            PLONGLONG fileref;

            fileref = (PLONGLONG) FileObject->FileName.Buffer;

            swprintf( fileIdBuffer, L"<%016I64x>", *fileref );

        } else if ((FileObject->FileName.Length == OBJECT_ID_KEY_LENGTH) ||
                   (FileObject->FileName.Length == OBJECT_ID_KEY_LENGTH + sizeof(WCHAR))) {

            //
            //  Opening by Object ID, generate a name
            //

            idBuffer = (PUCHAR)&FileObject->FileName.Buffer[0];

            if (FileObject->FileName.Length != OBJECT_ID_KEY_LENGTH) {

                //
                //  Skip win32k backslash at start of buffer
                //
                idBuffer = (PUCHAR)&FileObject->FileName.Buffer[1];
            }

            swprintf( fileIdBuffer,
					  L"<%08x-%04hx-%04hx-%04hx-%04hx%08x>",
                      *(PULONG)&idBuffer[0],
                      *(PUSHORT)&idBuffer[0+4],
                      *(PUSHORT)&idBuffer[0+4+2],
                      *(PUSHORT)&idBuffer[0+4+2+2],
                      *(PUSHORT)&idBuffer[0+4+2+2+2],
                      *(PULONG)&idBuffer[0+4+2+2+2+2]);

        } else {

			//
            //  Unknown ID format
			//

            swprintf( fileIdBuffer,
                      L"<Unknown ID (Len=%u)>",
                      FileObject->FileName.Length);
        }

        fileIdName.MaximumLength = sizeof( fileIdBuffer );
        fileIdName.Buffer = fileIdBuffer;
        fileIdName.Length = wcslen( fileIdBuffer ) * sizeof( WCHAR );

        //
        //  Try to append the fileIdName to FileName.
        //

        status = RtlAppendUnicodeStringToString( FileName, &fileIdName );

        if (!NT_SUCCESS( status )) {

            //
            //  We don't have enough room for the file name, so copy our
            //  EXCEED_NAME_BUFFER error message.
            //

            RtlAppendUnicodeToString( FileName, IOTEST_EXCEED_NAME_BUFFER_MESSAGE );
        }

        return TRUE;
    } 

    //
    //  CASE 3: We are opening a file that has a RelatedFileObject.
    //
    
    else if (FlagOn( LookupFlags, NAMELOOKUPFL_IN_CREATE ) &&
             (FileObject->RelatedFileObject != NULL)) {

        //
        //  Must be a relative open.  Use ObQueryNameString to get
        //  the name of the related FileObject.  Then we will append this
        //  fileObject's name.
        //
        //  Note: 
        //  The name in FileObject and FileObject->RelatedFileObject are accessible.  Names further up
        //  the related file object chain (ie FileObject->RelatedFileObject->RelatedFileObject)
        //  may not be accessible.  This is the reason we use ObQueryNameString
        //  to get the name for the RelatedFileObject.
        //

        CHAR buffer [(MAX_PATH * sizeof( WCHAR )) + sizeof( ULONG )];
        PFILE_NAME_INFORMATION relativeNameInfo = (PFILE_NAME_INFORMATION) buffer;
        NTSTATUS status;
        ULONG returnLength;

        status = IoTestQueryFileSystemForFileName( FileObject->RelatedFileObject,
                                                DeviceExtension->AttachedToDeviceObject,
                                                sizeof( buffer ),
                                                relativeNameInfo,
                                                &returnLength );

        if (NT_SUCCESS( status ) &&
            ((FileName->Length + relativeNameInfo->FileNameLength + FileObject->FileName.Length + sizeof( L'\\' ))
             <= FileName->MaximumLength)) {

            //
            //  We were able to get the relative fileobject's name and we have
            //  enough room in the FileName buffer, so build up the file name
            //  in the following format:
            //      [volumeName]\[relativeFileObjectName]\[FileObjectName]
            //  The VolumeName is already in FileName if we've got one.
            //

            RtlCopyMemory( &FileName->Buffer[FileName->Length/sizeof(WCHAR)],
                           relativeNameInfo->FileName,
                           relativeNameInfo->FileNameLength );
            FileName->Length += (USHORT)relativeNameInfo->FileNameLength;

        } else if ((FileName->Length + FileObject->FileName.Length + sizeof(L"...\\")) <=
                   FileName->MaximumLength ) {

            //
            //  Either the query for the relative fileObject name was unsuccessful,
            //  or we don't have enough room for the relativeFileObject name, but we
            //  do have enough room for "...\[fileObjectName]" in FileName.
            //

            status = RtlAppendUnicodeToString( FileName, L"...\\" );
            ASSERT( status == STATUS_SUCCESS );
        }

        //
        //  At this time, copy over the FileObject->FileName to the FileName
        //  unicode string.  If we get a failure return FALSE from this routine.
        //

        status = RtlAppendUnicodeStringToString( FileName, &(FileObject->FileName) );

        if (!NT_SUCCESS( status )) {

            //
            //  We should have had enough space to copy the FileObject->FileName,
            //  so there must be something wrong with FileName now, so return
            //  FALSE so that the data in FileName will not get copied into
            //  the log record.
            //

            return FALSE;
        }

        return TRUE;
    }
    
    //
    //  CASE 4: We have a open on a file with an absolute path.
    //
    
    else if (FlagOn( LookupFlags, NAMELOOKUPFL_IN_CREATE ) &&
             (FileObject->RelatedFileObject == NULL) ) {

        // 
        //  We have an absolute path, so try to copy that into FileName.
        //

        status = RtlAppendUnicodeStringToString( FileName, &(FileObject->FileName) );

        if (!NT_SUCCESS( status )) {

            //
            //  We don't have enough room for the file name, so copy our
            //  EXCEED_NAME_BUFFER error message.
            //

            RtlAppendUnicodeToString( FileName, IOTEST_EXCEED_NAME_BUFFER_MESSAGE );
        }
        
        return TRUE;
    }

    //
    //  CASE 5: We are retrieving the file name sometime after the
    //  CREATE operation.
    //

    else if(!FlagOn( LookupFlags, NAMELOOKUPFL_IN_CREATE )) {

        CHAR buffer [(MAX_PATH * sizeof( WCHAR )) + sizeof( ULONG )];
        PFILE_NAME_INFORMATION nameInfo = (PFILE_NAME_INFORMATION) buffer;
        NTSTATUS status;
        ULONG returnLength;

        status = IoTestQueryFileSystemForFileName( FileObject,
                                                DeviceExtension->AttachedToDeviceObject,
                                                sizeof( buffer ),
                                                nameInfo,
                                                &returnLength );

        if (NT_SUCCESS( status )) {

            if ((FileName->Length + nameInfo->FileNameLength) <= FileName->MaximumLength) {

                //
                //  We've got enough room for the file name, so copy it into
                //  FileName.
                //

                RtlCopyMemory( &FileName->Buffer[FileName->Length/sizeof(WCHAR)],
                               nameInfo->FileName,
                               nameInfo->FileNameLength );
                FileName->Length += (USHORT)nameInfo->FileNameLength;
                               
            } else {

                //
                //  We don't have enough room for the file name, so copy our
                //  EXCEED_NAME_BUFFER error message.
                //

                RtlAppendUnicodeToString( FileName, IOTEST_EXCEED_NAME_BUFFER_MESSAGE );
            }
            
        } else {

            //
            //  Got an error trying to get the file name from the base file system,
            //  so put that error message into FileName.
            //

            RtlAppendUnicodeToString( FileName, IOTEST_ERROR_RETRIEVING_NAME_MESSAGE );
        }
        
        return TRUE;
    }

    //
    //  Shouldn't get here -- we didn't fall into one of the
    //  above legitimate cases, so ASSERT and return FALSE.
    //

    ASSERT( FALSE );

    return FALSE;
}

NTSTATUS
IoTestQueryFileSystemForFileName (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT NextDeviceObject,
    IN ULONG FileNameInfoLength,
    OUT PFILE_NAME_INFORMATION FileNameInfo,
    OUT PULONG ReturnedLength
    )
/*++

Routine Description:

    This routine rolls an irp to query the name of the
    FileObject parameter from the base file system.

    Note:  ObQueryNameString CANNOT be used here because it
      would cause recursive lookup of the file name for FileObject.
      
Arguments:

    FileObject - the file object for which we want the name.
    NextDeviceObject - the device object for the next driver in the
        stack.  This is where we want to start our request
        for the name of FileObject.
    FileNameInfoLength - the length in bytes of FileNameInfo
        parameter.
    FileNameInfo - the buffer that will be receive the name
        information.  This must be memory that safe to write
        to from kernel space.
    ReturnedLength - the number of bytes written to FileNameInfo.
    
Return Value:

    Returns the status of the operation.
    
--*/
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;

    KeInitializeEvent( &event, SynchronizationEvent, FALSE );
    ioStatus.Status = STATUS_SUCCESS;
    ioStatus.Information = 0;

    irp = IoAllocateIrp( NextDeviceObject->StackSize, FALSE );
    
    if (irp == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  We don't need to take a reference on the FileObject
    //  here because we are going to perform our IO request
    //  synchronously and the current operation already
    //  has a reference for the FileObject.
    //
    
    irp->Tail.Overlay.OriginalFileObject = FileObject;

    //
    //  Set our current thread as the thread for this
    //  irp so that the IO Manager always knows which
    //  thread to return to if it needs to get back into
    //  the context of the thread that originated this
    //  irp.
    //
    
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    //  Set that this irp originated from the kernel so that
    //  the IO Manager knows that the buffers do not
    //  need to be probed.
    //
    
    irp->RequestorMode = KernelMode;

    //
    //  Initialize the UserIosb and UserEvent in the 
    irp->UserIosb = &ioStatus;
    irp->UserEvent = NULL;

    //
    //  Set the IRP_SYNCHRONOUS_API to denote that this
    //  is a synchronous IO request.
    //

    irp->Flags = IRP_SYNCHRONOUS_API;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;
    irp->Overlay.AsynchronousParameters.UserApcContext = NULL;

    irpSp = IoGetNextIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_QUERY_INFORMATION;
    irpSp->FileObject = FileObject;

    //
    //  Setup the parameters for IRP_MJ_QUERY_INFORMATION.
    //  The buffer we want to be filled in should be placed in
    //  the system buffer.
    //

    irp->AssociatedIrp.SystemBuffer = FileNameInfo;

    irpSp->Parameters.QueryFile.Length = FileNameInfoLength;
    irpSp->Parameters.QueryFile.FileInformationClass = FileNameInformation;

    //
    //  Set up the completion routine so that we know when our
    //  request for the file name is completed.  At that time,
    //  we can free the irp.
    //
    
    IoSetCompletionRoutine( irp, 
                            IoTestQueryFileSystemForNameCompletion, 
                            &event, 
                            TRUE, 
                            TRUE, 
                            TRUE );

    status = IoCallDriver( NextDeviceObject, irp );

    IOTEST_DBG_PRINT1( IOTESTDEBUG_TRACE_NAME_REQUESTS,
                        "IOTEST (IoTestQueryFileSystemForFileName): Issued name request -- IoCallDriver status: 0x%08x\n",
                        status );

    (VOID) KeWaitForSingleObject( &event, 
                                  Executive, 
                                  KernelMode,
                                  FALSE,
                                  NULL );
    status = ioStatus.Status;

    IOTEST_DBG_PRINT0( IOTESTDEBUG_TRACE_NAME_REQUESTS,
                        "IOTEST (IoTestQueryFileSystemForFileName): Finished waiting for name request to complete...\n" );

    *ReturnedLength = (ULONG) ioStatus.Information;
    return status;
}

NTSTATUS
IoTestQueryFileSystemForNameCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT SynchronizingEvent
    )
/*++

Routine Description:

    This routine does the cleanup necessary once the request
    for a file name is completed by the file system.
    
Arguments:

    DeviceObject - This will be NULL since we originated this
        Irp.

    Irp - The io request structure containing the information
        about the current state of our file name query.

    SynchronizingEvent - The event to signal to notify the 
        originator of this request that the operation is
        complete.

Return Value:

    Returns STATUS_MORE_PROCESSING_REQUIRED so that IO Manager
    will not try to free the Irp again.

--*/
{

    UNREFERENCED_PARAMETER( DeviceObject );
    
    //
    //  Make sure that the Irp status is copied over to the user's
    //  IO_STATUS_BLOCK so that the originator of this irp will know
    //  the final status of this operation.
    //

    ASSERT( NULL != Irp->UserIosb );
    *Irp->UserIosb = Irp->IoStatus;

    //
    //  Signal SynchronizingEvent so that the originator of this
    //  Irp know that the operation is completed.
    //

    KeSetEvent( SynchronizingEvent, IO_NO_INCREMENT, FALSE );

    //
    //  We are now done, so clean up the irp that we allocated.
    //

    IoFreeIrp( Irp );

    //
    //  If we return STATUS_SUCCESS here, the IO Manager will
    //  perform the cleanup work that it thinks needs to be done
    //  for this IO operation.  This cleanup work includes:
    //  * Copying data from the system buffer to the user's buffer 
    //    if this was a buffered IO operation.
    //  * Freeing any MDLs that are in the Irp.
    //  * Copying the Irp->IoStatus to Irp->UserIosb so that the
    //    originator of this irp can see the final status of the
    //    operation.
    //  * If this was an asynchronous request or this was a 
    //    synchronous request that got pending somewhere along the
    //    way, the IO Manager will signal the Irp->UserEvent, if one 
    //    exists, otherwise it will signal the FileObject->Event.
    //    (This can have REALLY bad implications if the irp originator
    //     did not an Irp->UserEvent and the irp originator is not
    //     waiting on the FileObject->Event.  It would not be that
    //     farfetched to believe that someone else in the system is
    //     waiting on FileObject->Event and who knows who will be
    //     awoken as a result of the IO Manager signaling this event.
    //
    //  Since some of these operations require the originating thread's
    //  context (e.g., the IO Manager need the UserBuffer address to 
    //  be valid when copy is done), the IO Manager queues this work
    //  to an APC on the Irp's orginating thread.
    //
    //  Since IoTest allocated and initialized this irp, we know
    //  what cleanup work needs to be done.  We can do this cleanup
    //  work more efficiently than the IO Manager since we are handling
    //  a very specific case.  Therefore, it is better for us to
    //  perform the cleanup work here then free the irp than passing
    //  control back to the IO Manager to do this work.
    //
    //  By returning STATUS_MORE_PROCESS_REQUIRED, we tell the IO Manager 
    //  to stop processing this irp until it is told to restart processing
    //  with a call to IoCompleteRequest.  Since the IO Manager has
    //  already performed all the work we want it to do on this
    //  irp, we do the cleanup work, return STATUS_MORE_PROCESSING_REQUIRED,
    //  and ask the IO Manager to resume processing by calling 
    //  IoCompleteRequest.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//         Common attachment and detachment routines                  //
//                                                                    //
////////////////////////////////////////////////////////////////////////

BOOLEAN
IoTestIsAttachedToDevice (
    IOTEST_DEVICE_TYPE DeviceType,
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL
    )
/*++

Routine Description:

    This walks down the attachment chain looking for a device object that
    belongs to this driver.  If one is found, the attached device object
    is returned in AttachedDeviceObject.

    Note:  If AttachedDeviceObject is returned with a non-NULL value,
           there is a reference on the AttachedDeviceObject that must
           be cleared by the caller.

Arguments:

    DeviceObject - The device chain we want to look through

    AttachedDeviceObject - Set to the deviceObject which IoTest
        has previously attached to DeviceObject.

Return Value:

    TRUE if we are attached, FALSE if not

--*/
{
    PDEVICE_OBJECT currentDevObj;
    PDEVICE_OBJECT nextDevObj;
    PIOTEST_DEVICE_EXTENSION currentDevExt;

    currentDevObj = IoGetAttachedDeviceReference( DeviceObject );
    ASSERT( currentDevObj != NULL );

    //
    //  CurrentDevObj has the top of the attachment chain.  Scan
    //  down the list to find our device object.

    do {

        currentDevExt = currentDevObj->DeviceExtension;
        
        if (IS_IOTEST_DEVICE_OBJECT( currentDevObj ) &&
            currentDevExt->Type == DeviceType) {

            //
            //  We have found that we are already attached.  If we are
            //  returning the device object we are attached to then leave the
            //  refrence on it.  If not then remove the refrence.
            //

            if (NULL != AttachedDeviceObject) {

                *AttachedDeviceObject = currentDevObj;

            } else {

                ObDereferenceObject( currentDevObj );
            }

            return TRUE;
        }

        //
        //  Get the next attached object.  This puts a reference on 
        //  the device object.
        //

        nextDevObj = IoGetLowerDeviceObject( currentDevObj );

        //
        //  Dereference our current device object, before
        //  moving to the next one.
        //

        ObDereferenceObject( currentDevObj );

        currentDevObj = nextDevObj;
        
    } while (NULL != currentDevObj);
    
    return FALSE;
}

NTSTATUS
IoTestAttachToMountedDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT IoTestDeviceObject,
    IN PDEVICE_OBJECT DiskDeviceObject,
    IN IOTEST_DEVICE_TYPE DeviceType
    )
/*++

Routine Description:

    This routine will attach the IoTestDeviceObject to the filter stack
    that DeviceObject is in.

    NOTE:  If there is an error in attaching, the caller is responsible
        for deleting the IoTestDeviceObject.
    
Arguments:

    DeviceObject - A device object in the stack to which we want to attach.

    IoTestDeviceObject - The filespy device object that has been created
        to attach to this filter stack.

    DiskDeviceObject - The device object the disk with which this file system
        filter stack is associated.

    DeviceType - The IoTest device type for the device being attached
        to the mounted volume.
            
Return Value:

    Returns STATUS_SUCCESS if the filespy deviceObject could be attached,
    otherwise an appropriate error code is returned.
    
--*/
{
    PIOTEST_DEVICE_EXTENSION devext;
    NTSTATUS status = STATUS_SUCCESS;

    ASSERT( IS_IOTEST_DEVICE_OBJECT( IoTestDeviceObject ) );
    ASSERT( !IoTestIsAttachedToDevice ( DeviceType, DeviceObject, NULL ) );
    
    devext = IoTestDeviceObject->DeviceExtension;

    devext->AttachedToDeviceObject = IoAttachDeviceToDeviceStack( IoTestDeviceObject,
                                                                  DeviceObject );

    if (devext->AttachedToDeviceObject == NULL ) {

        status = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        //
        //  Do all common initializing of the device extension
        //

        devext->Type = DeviceType;

        //
        //  We just want to attach to the device, but not actually
        //  start logging.
        //
        
        devext->LogThisDevice = FALSE;

        RtlInitEmptyUnicodeString( &(devext->DeviceNames), 
                                   devext->DeviceNamesBuffer, 
                                   sizeof( devext->DeviceNamesBuffer ) );
        RtlInitEmptyUnicodeString( &(devext->UserNames),
                                   devext->UserNamesBuffer,
                                   sizeof( devext->UserNamesBuffer ) );

        //
        //  Store off the DiskDeviceObject.  We shouldn't need it
        //  later since we have already successfully attached to the
        //  filter stack, but it may be helpful for debugging.
        //  
        
        devext->DiskDeviceObject = DiskDeviceObject;                         

        //
        //  Try to get the device name so that we can store it in the
        //  device extension.
        //

        IoTestCacheDeviceName( IoTestDeviceObject );

        if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_DISPLAY_ATTACHMENT_NAMES )) {

            switch ( devext->Type ) {
            case TOP_FILTER:
                DbgPrint( "IOTEST (IoTestAttachToMountedDevice): Attaching TOP_FILTER to volume %p       \"%wZ\"\n", 
                          devext->AttachedToDeviceObject,
                          &devext->DeviceNames);
                break;

            case BOTTOM_FILTER:
                DbgPrint( "IOTEST (IoTestAttachToMountedDevice): Attaching BOTTOM_FILTER to volume %p     \"%wZ\"\n", 
                          devext->AttachedToDeviceObject,
                          &devext->DeviceNames );
                break;
                
            default:
                DbgPrint( "IOTEST (IoTestAttachToMountedDevice): Attaching UNKNOWN FILTER TYPE to volume %p \"%wZ\"\n", 
                          devext->AttachedToDeviceObject,
                          &devext->DeviceNames );
                
            }
        }

        //
        //  Set our deviceObject flags based on the 
        //   flags send in the next driver's device object.
        //
        
        if (FlagOn( DeviceObject->Flags, DO_BUFFERED_IO )) {

            SetFlag( IoTestDeviceObject->Flags, DO_BUFFERED_IO );
        }

        if (FlagOn( DeviceObject->Flags, DO_DIRECT_IO )) {

            SetFlag( IoTestDeviceObject->Flags, DO_DIRECT_IO );
        }

        //
        //  Add this device to our attachment list
        //

        devext->IsVolumeDeviceObject = TRUE;

        ExAcquireFastMutex( &gIoTestDeviceExtensionListLock );
        InsertTailList( &gIoTestDeviceExtensionList, &devext->NextIoTestDeviceLink );
        ExReleaseFastMutex( &gIoTestDeviceExtensionListLock );

        ClearFlag( IoTestDeviceObject->Flags, DO_DEVICE_INITIALIZING );
    }

    return status;
}


VOID
IoTestCleanupMountedDevice (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This cleans up any allocated memory in the device extension.

Arguments:

    DeviceObject - The device we are cleaning up

Return Value:

--*/
{        
    PIOTEST_DEVICE_EXTENSION devext = DeviceObject->DeviceExtension;

    ASSERT(IS_IOTEST_DEVICE_OBJECT( DeviceObject ));

    //
    //  Unlink from global list
    //

    if (devext->IsVolumeDeviceObject) {

        ExAcquireFastMutex( &gIoTestDeviceExtensionListLock );
        RemoveEntryList( &devext->NextIoTestDeviceLink );
        ExReleaseFastMutex( &gIoTestDeviceExtensionListLock );
        devext->IsVolumeDeviceObject = FALSE;
    }
}


////////////////////////////////////////////////////////////////////////
//                                                                    //
//           Helper routine for turning on/off logging on demand      //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
IoTestGetDeviceObjectFromName (
    IN PUNICODE_STRING DeviceName,
    OUT PDEVICE_OBJECT *DeviceObject
    )
/*++

Routine Description:

    This routine
    
Arguments:

    DeviceName - Name of device for which we want the deviceObject.
    DeviceObject - Set to the DeviceObject for this device name if
        we can successfully retrieve it.

    Note:  If the DeviceObject is returned, it is returned with a
        reference that must be cleared by the caller once the caller
        is finished with it.

Return Value:

    STATUS_SUCCESS if the deviceObject was retrieved from the
    name, and an error code otherwise.
    
--*/
{
    WCHAR nameBuf[DEVICE_NAMES_SZ];
    UNICODE_STRING volumeNameUnicodeString;
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK openStatus;
    PFILE_OBJECT volumeFileObject;
    HANDLE fileHandle;
    PDEVICE_OBJECT nextDeviceObject;

    RtlInitEmptyUnicodeString( &volumeNameUnicodeString, nameBuf, sizeof( nameBuf ) );
    RtlAppendUnicodeToString( &volumeNameUnicodeString, L"\\DosDevices\\" );
    RtlAppendUnicodeStringToString( &volumeNameUnicodeString, DeviceName );

    InitializeObjectAttributes( &objectAttributes,
								&volumeNameUnicodeString,
								OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
								NULL,
								NULL);

    //
	// open the file object for the given device
	//

    status = ZwCreateFile( &fileHandle,
						   SYNCHRONIZE|FILE_READ_DATA,
						   &objectAttributes,
						   &openStatus,
						   NULL,
						   0,
						   FILE_SHARE_READ|FILE_SHARE_WRITE,
						   FILE_OPEN,
						   FILE_SYNCHRONOUS_IO_NONALERT,
						   NULL,
						   0);

    if(!NT_SUCCESS( status )) {

        return status;
    }

	//
    // get a pointer to the volumes file object
	//

    status = ObReferenceObjectByHandle( fileHandle,
										FILE_READ_DATA,
										*IoFileObjectType,
										KernelMode,
										&volumeFileObject,
										NULL);

    if(!NT_SUCCESS( status )) {

        ZwClose( fileHandle );
        return status;
    }

	//
    // Get the device object we want to attach to (parent device object in chain)
	//

    nextDeviceObject = IoGetRelatedDeviceObject( volumeFileObject );
    
    if (nextDeviceObject == NULL) {

        ObDereferenceObject( volumeFileObject );
        ZwClose( fileHandle );

        return status;
    }

    ObDereferenceObject( volumeFileObject );
    ZwClose( fileHandle );

    ASSERT( NULL != DeviceObject );

    ObReferenceObject( nextDeviceObject );
    
    *DeviceObject = nextDeviceObject;

    return STATUS_SUCCESS;
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                    Start/stop logging routines                     //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
IoTestStartLoggingDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PWSTR UserDeviceName
    )
/*++

Routine Description:

    This routine ensures that we are attached to the specified device
    then turns on logging for that device.
    
    Note:  Since all network drives through LAN Manager are represented by _
        one_ device object, we want to only attach to this device stack once
        and use only one device extension to represent all these drives.
        Since IoTest does not do anything to filter I/O on the LAN Manager's
        device object to only log the I/O to the requested drive, the user
        will see all I/O to a network drive it he/she is attached to a
        network drive.

Arguments:

    DeviceObject - Device object for IOTEST driver

    UserDeviceName - Name of device for which logging should be started
    
Return Value:

    STATUS_SUCCESS if the logging has been successfully started, or
    an appropriate error code if the logging could not be started.
    
--*/
{
    UNICODE_STRING userDeviceName;
    NTSTATUS status;
    PIOTEST_DEVICE_EXTENSION devext;
    PDEVICE_OBJECT nextDeviceObject;
    PDEVICE_OBJECT diskDeviceObject;
    MINI_DEVICE_STACK ioTestDevObjects;

    UNREFERENCED_PARAMETER( DeviceObject );
    
    //
    //  Check to see if we have previously attached to this device by
    //  opening this device name then looking through its list of attached
    //  devices.
    //

    RtlInitUnicodeString( &userDeviceName, UserDeviceName );

    status = IoTestGetDeviceObjectFromName( &userDeviceName, &nextDeviceObject );

    if (!NT_SUCCESS( status )) {

        //
        //  There was an error, so return the error code.
        //
        
        return status;
    }

    if (IoTestIsAttachedToDevice( TOP_FILTER, nextDeviceObject, &(ioTestDevObjects.Top))) {

        //
        //  We are already attached, so just make sure that logging is turned on
        //  for both the top and bottom IoTest device in this stack.
        //

        ASSERT( NULL != ioTestDevObjects.Top );

        devext = ioTestDevObjects.Top->DeviceExtension;
        devext->LogThisDevice = TRUE;

        IoTestStoreUserName( devext, &userDeviceName );

        //
        //  We don't need to take a reference on the Bottom device object
        //  here because our reference on Top is protecting Bottom from
        //  going away.
        //
        
        ioTestDevObjects.Bottom = devext->AttachedToDeviceObject;
        
        devext = ioTestDevObjects.Bottom->DeviceExtension;
        devext->LogThisDevice = TRUE;
        IoTestStoreUserName( devext, &userDeviceName );

        //
        //  Clear the reference that was returned from IoTestIsAttachedToDevice.
        //
        
        ObDereferenceObject( ioTestDevObjects.Top );
        
    } else {

        //
        //  We are not already attached, so create the IoTest device objects and
        //  attach it to this device object.
        //

        //
        //  Get the disk device object associated with this
        //  file  system device object.  Only try to attach if we
        //  have a disk device object.  If the device does not
        //  have a disk device object, it is a control device object
        //  for a driver and we don't want to attach to those
        //  device objects.
        //

        status = IoGetDiskDeviceObject( nextDeviceObject, &diskDeviceObject );

        if (!NT_SUCCESS( status )) {

            IOTEST_DBG_PRINT1( IOTESTDEBUG_ERROR,
                                "IOTEST (IoTestStartLoggingDevice): No disk device object exists for \"%wZ\"; cannot log this volume.\n",
                                &userDeviceName );
            ObDereferenceObject( nextDeviceObject );
            return status;
        }
        //
        //  Create the new IoTest device objects so we can attach it in the filter stack
        //

        status = IoTestCreateDeviceObjects(nextDeviceObject, 
                                           diskDeviceObject,
                                           &ioTestDevObjects);
        
        if (!NT_SUCCESS( status )) {

            ObDereferenceObject( diskDeviceObject );
            ObDereferenceObject( nextDeviceObject );
            return status;
        }
        
        //
        //  Call the routine to attach to a mounted device.
        //

        status = IoTestAttachDeviceObjects( &ioTestDevObjects,
                                            nextDeviceObject, 
                                            diskDeviceObject );
        
        //
        //  Clear the reference on diskDeviceObject that was
        //  added by IoGetDiskDeviceObject.
        //

        ObDereferenceObject( diskDeviceObject );

        if (!NT_SUCCESS( status )) {

            IOTEST_DBG_PRINT1( IOTESTDEBUG_ERROR,
                                "IOTEST (IoTestStartLoggingDevice): Could not attach to \"%wZ\"; logging not started.\n",
                                &userDeviceName );

            IoTestCleanupDeviceObjects( &ioTestDevObjects );
            ObDereferenceObject( nextDeviceObject );
            return status;
        }

        //
        //  We successfully attached so do any more device extension 
        //  initialization we need.  Along this code path, we want to
        //  turn on logging and store our device name for both the top and
        //  bottom device objects.
        // 

        devext = ioTestDevObjects.Top->DeviceExtension;
        devext->LogThisDevice = TRUE;
        IoTestStoreUserName( devext, &userDeviceName );

        devext = ioTestDevObjects.Bottom->DeviceExtension;
        devext->LogThisDevice = TRUE;
        IoTestStoreUserName( devext, &userDeviceName );
    }

    ObDereferenceObject( nextDeviceObject );
    return STATUS_SUCCESS;
}

NTSTATUS
IoTestStopLoggingDevice (
    IN PWSTR DeviceName
    )
/*++

Routine Description:

    This routine stop logging the specified device.  Since you can not
    physically detach from devices, this routine simply sets a flag saying
    to not log the device anymore.

    Note:  Since all network drives are represented by _one_ device object,
        and, therefore, one device extension, if the user detaches from one
        network drive, it has the affect of detaching from _all_ network
        devices.

Arguments:

    DeviceName - The name of the device to stop logging.

Return Value:
    NT Status code

--*/
{
    WCHAR nameBuf[DEVICE_NAMES_SZ];
    UNICODE_STRING volumeNameUnicodeString;
    PDEVICE_OBJECT deviceObject;
    MINI_DEVICE_STACK ioTestDevObjects;
    PIOTEST_DEVICE_EXTENSION devext;
    NTSTATUS status;
    
    RtlInitEmptyUnicodeString( &volumeNameUnicodeString, nameBuf, sizeof( nameBuf ) );
    RtlAppendUnicodeToString( &volumeNameUnicodeString, DeviceName );

    status = IoTestGetDeviceObjectFromName( &volumeNameUnicodeString, &deviceObject );

    if (!NT_SUCCESS( status )) {

        //
        //  We could not get the deviceObject from this DeviceName, so
        //  return the error code.
        //
        
        return status;
    }

    //
    //  Find IoTest's device object from the device stack to which
    //  deviceObject is attached.
    //

    if (IoTestIsAttachedToDevice( TOP_FILTER, deviceObject, &(ioTestDevObjects.Top) )) {

        //
        //  IoTest is attached and IoTest's deviceObject was returned.
        //

        ASSERT( NULL != ioTestDevObjects.Top );

        devext = ioTestDevObjects.Top->DeviceExtension;
        devext->LogThisDevice = FALSE;

        ioTestDevObjects.Bottom = devext->AttachedToDeviceObject;
        
        devext = ioTestDevObjects.Bottom->DeviceExtension;
        devext->LogThisDevice = FALSE;

        status = STATUS_SUCCESS;

    } else {

        status = STATUS_INVALID_PARAMETER;
    }    

    ObDereferenceObject( deviceObject );
    ObDereferenceObject( ioTestDevObjects.Bottom );

    return status;
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//       Attaching/detaching to all volumes in system routines        //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
IoTestCreateDeviceObjects (
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT RealDeviceObject OPTIONAL,
    IN OUT PMINI_DEVICE_STACK IoTestDevObjects
    )
{
    NTSTATUS status;
    PIOTEST_DEVICE_EXTENSION newDevExt;
    
    ASSERT( IoTestDevObjects != NULL );

    //
    //  Create BOTTOM_FILTER and initialize its device extension.
    //
    
    status = IoCreateDevice( gIoTestDriverObject,
                             sizeof( IOTEST_DEVICE_EXTENSION ),
                             NULL,
                             DeviceObject->DeviceType,
                             0,
                             FALSE,
                             &(IoTestDevObjects->Bottom) );

    if (!NT_SUCCESS( status )) {
#if DBG
        DbgPrint( "IOTEST: Error creating BOTTOM volume device object, status=%08x\n", status );
#endif

        goto IoTestCreateDeviceObjects_Exit;
    }

    //
    //  We need to save the RealDevice object pointed to by the vpb
    //  parameter because this vpb may be changed by the underlying
    //  file system.  Both FAT and CDFS may change the VPB address if
    //  the volume being mounted is one they recognize from a previous
    //  mount.
    //
    //  We store it in the device extension instead of just in the mount
    //  completion context because it is useful to keep around for 
    //  debugging purposes.
    //

    newDevExt = (IoTestDevObjects->Bottom)->DeviceExtension;
    newDevExt->Type = BOTTOM_FILTER;
    newDevExt->DiskDeviceObject = RealDeviceObject;

    //
    //  Create TOP_FILTER and initialize its device extension.
    //
    
    status = IoCreateDevice( gIoTestDriverObject,
                             sizeof( IOTEST_DEVICE_EXTENSION ),
                             NULL,
                             DeviceObject->DeviceType,
                             0,
                             FALSE,
                             &(IoTestDevObjects->Top) );

    if (!NT_SUCCESS( status )) {
#if DBG
        DbgPrint( "IOTEST: Error creating TOP volume device object, status=%08x\n", status );
#endif

        goto IoTestCreateDeviceObjects_Exit;
    }

    newDevExt = (IoTestDevObjects->Bottom)->DeviceExtension;
    newDevExt->Type = TOP_FILTER;
    newDevExt->DiskDeviceObject = RealDeviceObject;

IoTestCreateDeviceObjects_Exit:

    return status;
}

NTSTATUS
IoTestAttachDeviceObjects (
    IN PMINI_DEVICE_STACK IoTestDevObjects,
    IN PDEVICE_OBJECT MountedDevice,
    IN PDEVICE_OBJECT DiskDevice
    )
{
    NTSTATUS status;
    PIOTEST_DEVICE_EXTENSION devExt;

    status = IoTestAttachToMountedDevice( MountedDevice,
                                          IoTestDevObjects->Bottom, 
                                          DiskDevice,
                                          BOTTOM_FILTER );
    if (!NT_SUCCESS( status )) {

#if DBG
        DbgPrint( "IOTEST: Error attaching BOTTOM volume device object, status=%08x\n", status );
#endif

        //
        //  Neither the top or bottom device objects are attached yet, so just
        //  cleanup both device objects.
        //
        IoTestCleanupDeviceObjects( IoTestDevObjects );

        goto IoTestAttachDeviceObjects_Exit;
    }

    status = IoTestAttachToMountedDevice( MountedDevice,
                                          IoTestDevObjects->Top, 
                                          DiskDevice,
                                          TOP_FILTER );
    if (!NT_SUCCESS( status )) {

#if DBG
        DbgPrint( "IOTEST: Error attaching TOP volume device object, status=%08x\n", status );
#endif

        //
        //  Detach the bottom filter since we can't attach both the bottom
        //  and top filters.
        //
        devExt = IoTestDevObjects->Bottom->DeviceExtension;
        IoDetachDevice( devExt->AttachedToDeviceObject );

        //
        //  Then cleanup both our top and bottom device objects.
        //
        IoTestCleanupDeviceObjects( IoTestDevObjects );
        
        goto IoTestAttachDeviceObjects_Exit;
    }

IoTestAttachDeviceObjects_Exit:

    return status;
}

VOID
IoTestCleanupDeviceObjects (
    IN PMINI_DEVICE_STACK IoTestDevObjects
    )
{
    IoTestCleanupMountedDevice( IoTestDevObjects->Top );
    IoDeleteDevice( IoTestDevObjects->Top );
    IoTestCleanupMountedDevice( IoTestDevObjects->Bottom );
    IoDeleteDevice( IoTestDevObjects->Bottom );

    IoTestDevObjects->Top = NULL;
    IoTestDevObjects->Bottom = NULL;
}
NTSTATUS
IoTestAttachToFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
    )
/*++

Routine Description:

    This will attach to the given file system device object.  We attach to
    these devices so we will know when new devices are mounted.

Arguments:

    DeviceObject - The device to attach to

    Name - An already initialized unicode string used to retrieve names.
        NOTE:  The only reason this parameter is passed in is to conserve         
        stack space.  In most cases, the caller to this function has already
        allocated a buffer to temporarily store the device name and there
        is no reason this function and the functions it calls can't share
        the same buffer.

Return Value:

    Status of the operation

--*/
{
    PDEVICE_OBJECT filespyDeviceObject;
    PDEVICE_OBJECT attachedToDevObj;
    PIOTEST_DEVICE_EXTENSION devExt;
    UNICODE_STRING fsrecName;
    NTSTATUS status;

    PAGED_CODE();

    //
    //  See if this is a file system we care about.  If not, return.
    //

    if (!IS_DESIRED_DEVICE_TYPE(DeviceObject->DeviceType)) {

        return STATUS_SUCCESS;
    }

    //
    //  See if this is Microsoft's file system recognizer device (see if the name of the
    //  driver is the FS_REC driver).  If so skip it.  We don't need to 
    //  attach to file system recognizer devices since we can just wait for the
    //  real file system driver to load.  Therefore, if we can identify them, we won't
    //  attach to them.
    //

    RtlInitUnicodeString( &fsrecName, L"\\FileSystem\\Fs_Rec" );
    IoTestGetObjectName( DeviceObject->DriverObject, Name );
    
    if (RtlCompareUnicodeString( Name, &fsrecName, TRUE ) == 0) {

        return STATUS_SUCCESS;
    }

    //
    //  Create a new device object we can attach with
    //

    status = IoCreateDevice( gIoTestDriverObject,
                             sizeof( IOTEST_DEVICE_EXTENSION ),
                             (PUNICODE_STRING) NULL,
                             DeviceObject->DeviceType,
                             0,
                             FALSE,
                             &filespyDeviceObject );

    if (!NT_SUCCESS( status )) {

        IOTEST_DBG_PRINT0( IOTESTDEBUG_ERROR,
                            "IOTEST (IoTestAttachToFileSystem): Could not create a IoTest device object to attach to the filesystem.\n" );
        return status;
    }

    //
    //  Do the attachment
    //

    attachedToDevObj = IoAttachDeviceToDeviceStack( filespyDeviceObject, DeviceObject );

    if (attachedToDevObj == NULL) {

        IOTEST_DBG_PRINT0( IOTESTDEBUG_ERROR,
                            "IOTEST (IoTestAttachToFileSystem): Could not attach IoTest to the filesystem control device object.\n" );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorCleanupDevice;
    }

    //
    //  Finish initializing our device extension
    //

    devExt = filespyDeviceObject->DeviceExtension;
    devExt->AttachedToDeviceObject = attachedToDevObj;

    //
    //  Propagate flags from Device Object we attached to
    //

    if ( FlagOn( attachedToDevObj->Flags, DO_BUFFERED_IO )) {

        SetFlag( filespyDeviceObject->Flags, DO_BUFFERED_IO );
    }

    if ( FlagOn( attachedToDevObj->Flags, DO_DIRECT_IO )) {

        SetFlag( filespyDeviceObject->Flags, DO_DIRECT_IO );
    }

    //
    //  Since this is an attachment to a file system control device object
    //  we are not going to log anything, but properly initialize our
    //  extension.
    //

    devExt->LogThisDevice = FALSE;
    devExt->IsVolumeDeviceObject = FALSE;

    RtlInitEmptyUnicodeString( &(devExt->DeviceNames),
                               devExt->DeviceNamesBuffer,
                               sizeof( devExt->DeviceNamesBuffer ) );
                               
    RtlInitEmptyUnicodeString( &(devExt->UserNames),
                               devExt->UserNamesBuffer,
                               sizeof( devExt->UserNamesBuffer ) );
                               
    ClearFlag( filespyDeviceObject->Flags, DO_DEVICE_INITIALIZING );

    //
    //  Display who we have attached to
    //

    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_DISPLAY_ATTACHMENT_NAMES )) {

        IoTestCacheDeviceName( filespyDeviceObject );
        DbgPrint( "IOTEST (IoTestAttachToFileSystem): Attaching to file system   \"%wZ\" (%s)\n",
                  &devExt->DeviceNames,
                  GET_DEVICE_TYPE_NAME(filespyDeviceObject->DeviceType) );
    }

    //
    //  Enumerate all the mounted devices that currently
    //  exist for this file system and attach to them.
    //

    status = IoTestEnumerateFileSystemVolumes( DeviceObject, Name );

    if (!NT_SUCCESS( status )) {

        IOTEST_DBG_PRINT2( IOTESTDEBUG_ERROR,
                            "IOTEST (IoTestAttachToFileSystem): Error attaching to existing volumes for \"%wZ\", status=%08x\n",
                            &devExt->DeviceNames,
                            status );

        goto ErrorCleanupAttachment;
    }

    return STATUS_SUCCESS;

    /////////////////////////////////////////////////////////////////////
    //                  Cleanup error handling
    /////////////////////////////////////////////////////////////////////

    ErrorCleanupAttachment:
        IoDetachDevice( filespyDeviceObject );

    ErrorCleanupDevice:
        IoTestCleanupMountedDevice( filespyDeviceObject );
        IoDeleteDevice( filespyDeviceObject );

    return status;
}

VOID
IoTestDetachFromFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Given a base file system device object, this will scan up the attachment
    chain looking for our attached device object.  If found it will detach
    us from the chain.

Arguments:

    DeviceObject - The file system device to detach from.

Return Value:

--*/ 
{
    PDEVICE_OBJECT ourAttachedDevice;
    PIOTEST_DEVICE_EXTENSION devExt;

    PAGED_CODE();

    //
    //  We have to iterate through the device objects in the filter stack
    //  attached to DeviceObject.  If we are attached to this filesystem device
    //  object, We should be at the top of the stack, but there is no guarantee.
    //  If we are in the stack and not at the top, we can safely call IoDetachDevice
    //  at this time because the IO Manager will only really detach our device
    //  object from the stack at a safe time.
    //

    //
    //  Skip the base file system device object (since it can't be us)
    //

    ourAttachedDevice = DeviceObject->AttachedDevice;

    while (NULL != ourAttachedDevice) {

        if (IS_IOTEST_DEVICE_OBJECT( ourAttachedDevice )) {

            devExt = ourAttachedDevice->DeviceExtension;

            //
            //  Display who we detached from
            //

            IOTEST_DBG_PRINT2( IOTESTDEBUG_DISPLAY_ATTACHMENT_NAMES,
                                "IOTEST (IoTestDetachFromFileSystem): Detaching from file system \"%wZ\" (%s)\n",
                                &devExt->DeviceNames,
                                GET_DEVICE_TYPE_NAME(ourAttachedDevice->DeviceType) );
                                
            //
            //  Detach us from the object just below us
            //  Cleanup and delete the object
            //

            IoTestCleanupMountedDevice( ourAttachedDevice );
            IoDetachDevice( DeviceObject );
            IoDeleteDevice( ourAttachedDevice );

            return;
        }

        //
        //  Look at the next device up in the attachment chain
        //

        DeviceObject = ourAttachedDevice;
        ourAttachedDevice = ourAttachedDevice->AttachedDevice;
    }
}

NTSTATUS
IoTestEnumerateFileSystemVolumes (
    IN PDEVICE_OBJECT FSDeviceObject,
    IN PUNICODE_STRING Name
    ) 
/*++

Routine Description:

    Enumerate all the mounted devices that currently exist for the given file
    system and attach to them.  We do this because this filter could be loaded
    at any time and there might already be mounted volumes for this file system.

Arguments:

    FSDeviceObject - The device object for the file system we want to enumerate

    Name - An already initialized unicode string used to retrieve names

Return Value:

    The status of the operation

--*/
{
    PDEVICE_OBJECT *devList;
    PDEVICE_OBJECT diskDeviceObject;
    NTSTATUS status;
    ULONG numDevices;
    ULONG i;

    PAGED_CODE();

    //
    //  Find out how big of an array we need to allocate for the
    //  mounted device list.
    //

    status = IoEnumerateDeviceObjectList( FSDeviceObject->DriverObject,
                                          NULL,
                                          0,
                                          &numDevices);

    //
    //  We only need to get this list of there are devices.  If we
    //  don't get an error there are no devices so go on.
    //

    if (!NT_SUCCESS( status )) {

        ASSERT(STATUS_BUFFER_TOO_SMALL == status);

        //
        //  Allocate memory for the list of known devices
        //

        numDevices += 8;        //grab a few extra slots

        devList = ExAllocatePoolWithTag( NonPagedPool, 
                                         (numDevices * sizeof(PDEVICE_OBJECT)), 
                                         IOTEST_POOL_TAG );
        if (NULL == devList) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Now get the list of devices.  If we get an error again
        //  something is wrong, so just fail.
        //

        status = IoEnumerateDeviceObjectList(
                        FSDeviceObject->DriverObject,
                        devList,
                        (numDevices * sizeof(PDEVICE_OBJECT)),
                        &numDevices);

        if (!NT_SUCCESS( status ))  {

            ExFreePool( devList );
            return status;
        }

        //
        //  Walk the given list of devices and attach to them if we should.
        //

        for (i=0; i < numDevices; i++) {

            //
            //  Do not attach if:
            //      - This is the control device object (the one passed in)
            //      - We are already attached to it
            //

            if ((devList[i] != FSDeviceObject) && 
                !IoTestIsAttachedToDevice( TOP_FILTER, devList[i], NULL )) {

                //
                //  See if this device has a name.  If so, then it must
                //  be a control device so don't attach to it.  This handles
                //  drivers with more then one control device.
                //

                IoTestGetBaseDeviceObjectName( devList[i], Name );

                if (Name->Length <= 0) {

                    //
                    //  Get the disk device object associated with this
                    //  file  system device object.  Only try to attach if we
                    //  have a disk device object.
                    //

                    status = IoGetDiskDeviceObject( devList[i], &diskDeviceObject );

                    if (NT_SUCCESS( status )) {

                        MINI_DEVICE_STACK ioTestDeviceObjects;

                        //
                        //  Allocate a new device object to attach with
                        //

                        status = IoTestCreateDeviceObjects( devList[i],
                                                            diskDeviceObject,
                                                            &ioTestDeviceObjects );
                        
                        if (NT_SUCCESS( status )) {

                            //
                            //  Attach to this device object
                            //

                            status = IoTestAttachDeviceObjects( &ioTestDeviceObjects,
                                                                devList[i],
                                                                diskDeviceObject );

                            //
                            //  This shouldn't fail.
                            //
                            
                            ASSERT( NT_SUCCESS( status ));
                        } else {

                            IOTEST_DBG_PRINT0( IOTESTDEBUG_ERROR,
                                                "IOTEST (IoTestEnumberateFileSystemVolumes): Cannot attach IoTest device object to volume.\n" );
                        }
                        
                        //
                        //  Remove reference added by IoGetDiskDeviceObject.
                        //  We only need to hold this reference until we are
                        //  successfully attached to the current volume.  Once
                        //  we are successfully attached to devList[i], the
                        //  IO Manager will make sure that the underlying
                        //  diskDeviceObject will not go away until the file
                        //  system stack is torn down.
                        //

                        ObDereferenceObject( diskDeviceObject );
                    }
                }
            }

            //
            //  Dereference the object (reference added by 
            //  IoEnumerateDeviceObjectList)
            //

            ObDereferenceObject( devList[i] );
        }

        //
        //  We are going to ignore any errors received while mounting.  We
        //  simply won't be attached to those volumes if we get an error
        //

        status = STATUS_SUCCESS;

        //
        //  Free the memory we allocated for the list
        //

        ExFreePool( devList );
    }

    return status;
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//             Private IoTest IOCTLs helper routines                 //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
IoTestGetAttachList (
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG_PTR ReturnLength
    )
/*++

Routine Description:
    This returns an array of structure identifying all of the devices
    we are currently physical attached to and whether logging is on or
    off for the given device

Arguments:
    buffer - buffer to receive the attachment list
    bufferSize - total size in bytes of the return buffer
    returnLength - receives number of bytes we actually return

Return Value:
    NT Status code

--*/
{
    PLIST_ENTRY link;
    PIOTEST_DEVICE_EXTENSION pDevext;
    PATTACHED_DEVICE pAttDev;
    ULONG retlen = 0;

    pAttDev = Buffer;

    ExAcquireFastMutex( &gIoTestDeviceExtensionListLock );

    for (link = gIoTestDeviceExtensionList.Flink;
         link != &gIoTestDeviceExtensionList;
         link = link->Flink) {

        pDevext = CONTAINING_RECORD(link, IOTEST_DEVICE_EXTENSION, NextIoTestDeviceLink);

        if (BufferSize < sizeof(ATTACHED_DEVICE)) {

            break;
		}

        pAttDev->LoggingOn = pDevext->LogThisDevice;
        pAttDev->DeviceType = pDevext->Type;
        wcscpy( pAttDev->DeviceNames, pDevext->DeviceNamesBuffer );
        retlen += sizeof( ATTACHED_DEVICE );
        BufferSize -= sizeof( ATTACHED_DEVICE );
        pAttDev++;
    }

    ExReleaseFastMutex( &gIoTestDeviceExtensionListLock );

    *ReturnLength = retlen;
    return STATUS_SUCCESS;
}

VOID
IoTestGetLog (
    OUT PVOID            OutputBuffer,
    IN  ULONG            OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:
    This function fills OutputBuffer with as many LOG_RECORDs as possible.
    The LOG_RECORDs are variable sizes and are tightly packed in the
    OutputBuffer.

Arguments:
    OutputBuffer - the user's buffer to fill with the log data we have
        collected
    OutputBufferLength - the size in bytes of OutputBuffer
    IoStatus - is set to the correct return status information for this
        operation

Return Value:
    None

--*/
{
    PLIST_ENTRY pList = NULL;
    ULONG length = OutputBufferLength;
    PCHAR pOutBuffer = OutputBuffer;
    PLOG_RECORD pLogRecord = NULL;
    ULONG recordsAvailable = 0;
    PRECORD_LIST pRecordList;
    KIRQL oldIrql;

    IoStatus->Information = 0;

    KeAcquireSpinLock(&gOutputBufferLock, &oldIrql);

    while (!IsListEmpty( &gOutputBufferList ) && (length > 0)) {
        pList = RemoveHeadList( &gOutputBufferList );

        pRecordList = CONTAINING_RECORD( pList, RECORD_LIST, List );

        pLogRecord = &pRecordList->LogRecord;

        recordsAvailable++;

		//
        // put it back if we've run out of room
		//

        if (length < pLogRecord->Length) {

            InsertHeadList( &gOutputBufferList, pList );
            break;
        }

        KeReleaseSpinLock( &gOutputBufferLock, oldIrql );

        RtlCopyMemory( pOutBuffer, pLogRecord, pLogRecord->Length );

        IoStatus->Information += pLogRecord->Length;
        length -= pLogRecord->Length;
        pOutBuffer += pLogRecord->Length;

        IoTestFreeRecord( pRecordList );

        KeAcquireSpinLock( &gOutputBufferLock, &oldIrql );
    }

    KeReleaseSpinLock( &gOutputBufferLock, oldIrql );

	//
    // no copies occurred
	//

    if (length == OutputBufferLength && recordsAvailable > 0) {

        IoStatus->Status = STATUS_BUFFER_TOO_SMALL;
    }

    return;
}


VOID
IoTestFlushLog (
    )
/*++

Routine Description:
    This function removes all the LOG_RECORDs from the queue.

Arguments:

Return Value:
    None

--*/
{
    PLIST_ENTRY pList = NULL;
    PRECORD_LIST pRecordList;
    KIRQL oldIrql;

    KeAcquireSpinLock(&gOutputBufferLock, &oldIrql);

    while (!IsListEmpty( &gOutputBufferList )) {
        
        pList = RemoveHeadList( &gOutputBufferList );

        pRecordList = CONTAINING_RECORD( pList, RECORD_LIST, List );

        IoTestFreeRecord( pRecordList );
    }

    KeReleaseSpinLock( &gOutputBufferLock, oldIrql );

    return;
}
VOID
IoTestCloseControlDevice (
    )
/*++

Routine Description:

    This is the routine that is associated with IRP_MJ_
    This routine does the cleanup involved in closing the ControlDevice.
    On the close of the Control Device, we need to empty the queue of
    logRecords that are waiting to be returned to the user.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PLIST_ENTRY pList;
    PRECORD_LIST pRecordList;
    KIRQL oldIrql;

    //
    // Set the gControlDeviceState to CLEANING_UP so that we can
    // signal that we are cleaning up the device.
    //

    KeAcquireSpinLock( &gControlDeviceStateLock, &oldIrql );
    gControlDeviceState = CLEANING_UP;
    KeReleaseSpinLock( &gControlDeviceStateLock, oldIrql );

    KeAcquireSpinLock( &gOutputBufferLock, &oldIrql );

    while (!IsListEmpty( &gOutputBufferList )) {

        pList = RemoveHeadList( &gOutputBufferList );

        KeReleaseSpinLock( &gOutputBufferLock, oldIrql );

        pRecordList = CONTAINING_RECORD( pList, RECORD_LIST, List );

        IoTestFreeRecord( pRecordList );

        KeAcquireSpinLock( &gOutputBufferLock, &oldIrql );
    }

    KeReleaseSpinLock( &gOutputBufferLock, oldIrql );

    IoTestNameDeleteAllNames();

    //
    // All the cleanup is done, so set the gControlDeviceState
    // to CLOSED.
    //

    KeAcquireSpinLock( &gControlDeviceStateLock, &oldIrql );
    gControlDeviceState = CLOSED;
    KeReleaseSpinLock( &gControlDeviceStateLock, oldIrql );
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//               Device name tracking helper routines                 //
//                                                                    //
////////////////////////////////////////////////////////////////////////

VOID
IoTestGetObjectName (
    IN PVOID Object,
    IN OUT PUNICODE_STRING Name
    )
/*++

Routine Description:

    This routine will return the name of the given object.
    If a name can not be found an empty string will be returned.

Arguments:

    Object - The object whose name we want

    Name - A unicode string that is already initialized with a buffer

Return Value:

    None

--*/
{
    NTSTATUS status;
    CHAR nibuf[512];        //buffer that receives NAME information and name
    POBJECT_NAME_INFORMATION nameInfo = (POBJECT_NAME_INFORMATION)nibuf;
    ULONG retLength;

    status = ObQueryNameString( Object, nameInfo, sizeof(nibuf), &retLength);

    Name->Length = 0;
    if (NT_SUCCESS( status )) {

        RtlCopyUnicodeString( Name, &nameInfo->Name );
    }
}

VOID
IoTestGetBaseDeviceObjectName (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
    )
/*++

Routine Description:

    This locates the base device object in the given attachment chain and then
    returns the name of that object.

    If no name can be found, an empty string is returned.

Arguments:

    Object - The object whose name we want

    Name - A unicode string that is already initialized with a buffer

Return Value:

    None

--*/
{
    //
    //  Get the base file system device object
    //

    DeviceObject = IoGetDeviceAttachmentBaseRef( DeviceObject );

    //
    //  Get the name of that object
    //

    IoTestGetObjectName( DeviceObject, Name );

    //
    //  Remove the reference added by IoGetDeviceAttachmentBaseRef
    //

    ObDereferenceObject( DeviceObject );
}

VOID
IoTestCacheDeviceName (
    IN PDEVICE_OBJECT DeviceObject
    ) 
/*++

Routine Description:

    This routines tries to set a name into the device extension of the given
    device object. 
    
    It will try and get the name from:
        - The device object
        - The disk device object if there is one

Arguments:

    DeviceObject - The object we want a name for

Return Value:

    None

--*/
{
    PIOTEST_DEVICE_EXTENSION devExt;

    ASSERT(IS_IOTEST_DEVICE_OBJECT( DeviceObject ));

    devExt = DeviceObject->DeviceExtension;

    //
    //  Get the name of the given device object.
    //

    IoTestGetBaseDeviceObjectName( DeviceObject, &(devExt->DeviceNames) );

    //
    //  If we didn't get a name and there is a REAL device object, lookup
    //  that name.
    //

    if ((devExt->DeviceNames.Length <= 0) && (NULL != devExt->DiskDeviceObject)) {

        IoTestGetObjectName( devExt->DiskDeviceObject, &(devExt->DeviceNames) );
    }
}

BOOLEAN
IoTestFindSubString (
    IN PUNICODE_STRING String,
    IN PUNICODE_STRING SubString
    )
/*++

Routine Description:
    This routine looks to see if SubString is a substring of String.

Arguments:
    String - the string to search in
    SubString - the substring to find in String

Return Value:
    Returns TRUE if the substring is found in string and FALSE otherwise.
    
--*/
{
    ULONG index;

    //
    //  First, check to see if the strings are equal.
    //

    if (RtlEqualUnicodeString( String, SubString, TRUE )) {

        return TRUE;
    }

    //
    //  String and SubString aren't equal, so now see if SubString
    //  in in String any where.
    //

    for (index = 0;
         index + SubString->Length <= String->Length;
         index++) {

        if (_wcsnicmp( &(String->Buffer[index]), SubString->Buffer, SubString->Length ) == 0) {

            //
            //  SubString is found in String, so return TRUE.
            //
            return TRUE;
        }
    }

    return FALSE;
}

VOID
IoTestStoreUserName (
    IN PIOTEST_DEVICE_EXTENSION DeviceExtension,
    IN PUNICODE_STRING UserName
    )
/*++

Routine Description:

    Stores the current device name in the device extension.  If
    this name is already in the device name list of this extension,
    it will not be added.  If there is already a name for this device, 
    the new device name is appended to the DeviceName in the device extension.
    
Arguments:

    DeviceExtension - The device extension that will store the
        device name.

    UserName - The device name as specified by the user to be stored.

Return Value:

    None

--*/
{
    //
    //  See if this UserName is already in the list of user names filespy
    //  keeps in its device extension.  If not, add it to the list.
    //

    if (!IoTestFindSubString( &(DeviceExtension->UserNames), UserName )) {

        //
        //  We didn't find this name in the list, so if there are no names 
        //  in the UserNames list, just append UserName.  Otherwise, append a
        //  delimiter then append UserName.
        //

        if (DeviceExtension->UserNames.Length == 0) {

            RtlAppendUnicodeStringToString( &DeviceExtension->UserNames, UserName );

        } else {

            RtlAppendUnicodeToString( &DeviceExtension->UserNames, L", " );
            RtlAppendUnicodeStringToString( &DeviceExtension->UserNames, UserName );
        }
    }

    //
    //  See if this UserName is already in the list of device names filespy
    //  keeps in its device extension.  If not, add it to the list.
    //

    if (!IoTestFindSubString( &(DeviceExtension->DeviceNames), UserName )) {

        //
        //  We didn't find this name in the list, so if there are no names 
        //  in the UserNames list, just append UserName.  Otherwise, append a
        //  delimiter then append UserName.
        //

        if (DeviceExtension->DeviceNames.Length == 0) {

            RtlAppendUnicodeStringToString( &DeviceExtension->DeviceNames, UserName );

        } else {

            RtlAppendUnicodeToString( &DeviceExtension->DeviceNames, L", " );
            RtlAppendUnicodeStringToString( &DeviceExtension->DeviceNames, UserName );
        }
    }
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                        Debug support routines                      //
//                                                                    //
////////////////////////////////////////////////////////////////////////

VOID
IoTestDumpIrpOperation (
    IN BOOLEAN InOriginatingPath,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is for debugging and prints out a string to the
    debugger specifying what Irp operation is being seen.
    
Arguments:

    InOriginatingPath - TRUE if we are in the originating path
        for the IRP, FALSE if in the completion path.

    Irp - The IRP for this operation.
        
Return Value:

    None.
    
--*/
{
    CHAR irpMajorString[OPERATION_NAME_BUFFER_SIZE];
    CHAR irpMinorString[OPERATION_NAME_BUFFER_SIZE];
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );

    GetIrpName(irpSp->MajorFunction,
               irpSp->MinorFunction,
               irpSp->Parameters.FileSystemControl.FsControlCode,
               irpMajorString,irpMinorString);


    if (InOriginatingPath) {

        DbgPrint( "IOTEST: Irp preoperation for %s %s\n", irpMajorString, irpMinorString );
            
    } else {
    
        DbgPrint( "IOTEST: Irp postoperation for %s %s\n", irpMajorString, irpMinorString );
    }
}

VOID
IoTestDumpFastIoOperation (
    IN BOOLEAN InPreOperation,
    IN FASTIO_TYPE FastIoOperation
    )
/*++

Routine Description:

    This routine is for debugging and prints out a string to the
    debugger specifying what FsFilter operation is being seen.
    
Arguments:

    InPreOperation - TRUE if we have not called down to the next
        device in the stack, FALSE otherwise.

    FastIoOperation - The code for the Fast Io operation.
    
Return Value:

    None.
    
--*/
{
    CHAR operationString[OPERATION_NAME_BUFFER_SIZE];

    GetFastioName(FastIoOperation,
               operationString);


    if (InPreOperation) {
    
        DbgPrint( "IOTEST: Fast IO preOperation for %s\n", operationString );

    } else {

        DbgPrint( "IOTEST: Fast IO postOperation for %s\n", operationString );
    }
}

VOID
IoTestDumpFsFilterOperation (
    IN BOOLEAN InPreOperationCallback,
    IN PFS_FILTER_CALLBACK_DATA Data
    )
/*++

Routine Description:

    This routine is for debugging and prints out a string to the
    debugger specifying what FsFilter operation is being seen.
    
Arguments:

    InPreOperationCallback - TRUE if we are in a preOperation 
        callback, FALSE otherwise.

    Data - The FS_FILTER_CALLBACK_DATA structure for this
        operation.
        
Return Value:

    None.
    
--*/
{
    CHAR operationString[OPERATION_NAME_BUFFER_SIZE];


    GetFsFilterOperationName(Data->Operation,operationString);

    if (InPreOperationCallback) {
    
        DbgPrint( "IOTEST: FsFilter preOperation for %s\n", operationString );

    } else {

        DbgPrint( "IOTEST: FsFilter postOperation for %s\n", operationString );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\iotest\filter\iotest.h ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    filespy.h

Abstract:

    Header file which contains the structures, type definitions,
    and constants that are shared between the kernel mode driver, 
    filespy.sys, and the user mode executable, filespy.exe.

// @@BEGIN_DDKSPLIT

Author:

    George Jenkins (georgeje) 6-Jan-1999
    Neal Christiansen (nealch)
    Molly Brown (mollybro)  

// @@END_DDKSPLIT

Environment:

    Kernel mode

// @@BEGIN_DDKSPLIT

Revision History:

// @@END_DDKSPLIT
--*/
#ifndef __IOTEST_H__
#define __IOTEST_H__

#include "ioTestLib.h"

//
//  Enable these warnings in the code.
//

#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4101)   // Unreferenced local variable

#define USE_DO_HINT

#define IOTEST_Reset              (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x00, METHOD_BUFFERED, FILE_WRITE_ACCESS )
#define IOTEST_StartLoggingDevice (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x01, METHOD_BUFFERED, FILE_READ_ACCESS )
#define IOTEST_StopLoggingDevice  (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x02, METHOD_BUFFERED, FILE_READ_ACCESS )
#define IOTEST_GetLog             (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x03, METHOD_BUFFERED, FILE_READ_ACCESS )
#define IOTEST_GetVer             (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x04, METHOD_BUFFERED, FILE_READ_ACCESS )
#define IOTEST_ListDevices        (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x05, METHOD_BUFFERED, FILE_READ_ACCESS )
#define IOTEST_GetStats           (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x06, METHOD_BUFFERED, FILE_READ_ACCESS )
#define IOTEST_ReadTest           (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x07, METHOD_BUFFERED, FILE_READ_ACCESS )
#define IOTEST_RenameTest         (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x08, METHOD_BUFFERED, FILE_READ_ACCESS )
#define IOTEST_ShareTest          (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x09, METHOD_BUFFERED, FILE_READ_ACCESS )

#define IOTEST_DRIVER_NAME     L"IOTEST.SYS"
#define IOTEST_DEVICE_NAME     L"IoTest"
#define IOTEST_W32_DEVICE_NAME L"\\\\.\\IoTest"
#define IOTEST_DOSDEVICE_NAME  L"\\DosDevices\\IoTest"
#define IOTEST_FULLDEVICE_NAME L"\\FileSystem\\Filters\\IoTest"

    
#define IOTEST_MAJ_VERSION 1
#define IOTEST_MIN_VERSION 0

typedef struct _IOTESTVER {
    USHORT Major;
    USHORT Minor;
} IOTESTVER, *PIOTESTVER;

typedef ULONG_PTR FILE_ID;        //  To allow passing up PFILE_OBJECT as 
                                  //     unique file identifier in user-mode
typedef LONG NTSTATUS;            //  To allow status values to be passed up 
                                  //     to user-mode

//
//  This is set to the number of characters we want to allow the 
//  device extension to store for the various names used to identify
//  a device object.
//
#define DEVICE_NAMES_SZ  100

//
//  An array of these structures are returned when the attached device list is
//  returned.
//

typedef struct _ATTACHED_DEVICE {
    BOOLEAN LoggingOn;
    enum _IOTEST_DEVICE_TYPE DeviceType;
    WCHAR DeviceNames[DEVICE_NAMES_SZ];
} ATTACHED_DEVICE, *PATTACHED_DEVICE;

#define MAX_BUFFERS     100

//
//  Attach modes for the filespy kernel driver
//

#define IOTEST_ATTACH_ON_DEMAND    1   //  Filespy will only attach to a volume
                                        //  when a user asks to start logging that
                                        //  volume.
                                        
#define IOTEST_ATTACH_ALL_VOLUMES  2   //  Filespy will attach to all volumes
                                        //  in the system at the time the driver
                                        //  is loaded and will attach to all volumes
                                        //  that appear in the system while the 
                                        //  filespy driver is loaded.  Logging on these
                                        //  volumes will not be turned on until the 
                                        //  user asks it to be.
                                        
//
//  The valid record types.
//

#define RECORD_TYPE_STATIC                  0x80000000
#define RECORD_TYPE_NORMAL                  0X00000000

#define RECORD_TYPE_IRP                     0x00000001
#define RECORD_TYPE_FASTIO                  0x00000002
#define RECORD_TYPE_FS_FILTER_OP            0x00000003
#define RECORD_TYPE_OUT_OF_MEMORY           0x10000000
#define RECORD_TYPE_EXCEED_MEMORY_ALLOWANCE 0x20000000

#ifndef NOTHING
#define NOTHING
#endif

//
//  Macro to return the lower byte of RecordType
//

#define GET_RECORD_TYPE(pLogRecord) ((pLogRecord)->RecordType & 0x0000FFFF)

#define LOG_ORIGINATING_IRP  0x0001
#define LOG_COMPLETION_IRP   0x0002

typedef enum _IOTEST_DEVICE_TYPE {

    TOP_FILTER,      //  Closest to the IO Mananger
    BOTTOM_FILTER    // Closest to the file system

} IOTEST_DEVICE_TYPE, *PIOTEST_DEVICE_TYPE;

typedef struct _EXPECTED_OPERATION {

    IOTEST_DEVICE_TYPE Device;
    UCHAR Op;

} EXPECTED_OPERATION, *PEXPECTED_OPERATION;

//
//  Structure defining the information recorded for an IRP operation
//

typedef struct _RECORD_IRP {

    LARGE_INTEGER OriginatingTime; //  The time the IRP originated

    UCHAR IrpMajor;                //  From _IO_STACK_LOCATION
    UCHAR IrpMinor;                //  From _IO_STACK_LOCATION
    ULONG IrpFlags;                //  From _IRP (no cache, paging i/o, sync. 
                                   //  api, assoc. irp, buffered i/o, etc.)                   
    FILE_ID FileObject;            //  From _IO_STACK_LOCATION (This is the 
                                   //     PFILE_OBJECT, but this isn't 
                                   //     available in user-mode)
    FILE_ID ProcessId;
    FILE_ID ThreadId;
    
    //
    //  These fields are only filled in the appropriate
    //  Verbose mode.
    //
    
    PVOID Argument1;               //  
    PVOID Argument2;               //  Current IrpStackLocation
    PVOID Argument3;               //  Parameters
    PVOID Argument4;               //  
    ACCESS_MASK DesiredAccess;     //  Only used for CREATE irps

} RECORD_IRP, *PRECORD_IRP;

//
//  Structure defining the information recorded for a Fast IO operation
//

typedef struct _RECORD_FASTIO {

    LARGE_INTEGER StartTime;     //  Time Fast I/O request begins processing
    FASTIO_TYPE Type;            //  Type of FASTIO operation
    FILE_ID FileObject;          //  Parameter to FASTIO call, should be 
                                 //    unique identifier in user space
    LARGE_INTEGER FileOffset;    //  Offset into the file where the I/O is 
                                 //    taking place
    ULONG Length;                //  The length of data for the I/O operation
    BOOLEAN Wait;                //  Parameter to most FASTIO calls, signifies 
                                 //    if this operation can wait
    FILE_ID ProcessId;
    FILE_ID ThreadId;

} RECORD_FASTIO, *PRECORD_FASTIO;

//
//  Structure defining the information recorded for FsFilter operations
//

typedef struct _RECORD_FS_FILTER_OPERATION {

    LARGE_INTEGER OriginatingTime;

    UCHAR FsFilterOperation;
    FILE_ID FileObject;

    FILE_ID ProcessId;
    FILE_ID ThreadId;
    
} RECORD_FS_FILTER_OPERATION, *PRECORD_FS_FILTER_OPERATION;

//
//  The two types of records that are possible.
//

typedef union _RECORD_IO {

    RECORD_IRP RecordIrp;
    RECORD_FASTIO RecordFastIo;
    RECORD_FS_FILTER_OPERATION RecordFsFilterOp;

} RECORD_IO, *PRECORD_IO;


//
//  Log record structure defines the additional information needed for
//  managing the processing of the each IO IoTest monitors.
//

typedef struct _LOG_RECORD {

    ULONG Length;           //  Length of record including header 
    ULONG SequenceNumber;
    IOTEST_DEVICE_TYPE DeviceType;
    ULONG RecordType;
    RECORD_IO Record;
    WCHAR Name[1];          //  Really want a 0 sized array here, but since
                            //  some compilers don't like that, making the
                            //  variable sized array of size 1 to hold
                            //  this place.

} LOG_RECORD, *PLOG_RECORD;

#define SIZE_OF_LOG_RECORD  (sizeof( LOG_RECORD ) - sizeof( WCHAR ))

typedef struct _RECORD_LIST {

    LIST_ENTRY List;
    LOG_RECORD LogRecord;

} RECORD_LIST, *PRECORD_LIST;

#define SIZE_OF_RECORD_LIST (SIZE_OF_LOG_RECORD + sizeof( LIST_ENTRY ))


//
//  The statistics that are kept on the file name hash table
//  to monitor its efficiency.
//

typedef struct _HASH_STATISTICS {

    ULONG Lookups;
    ULONG LookupHits;
    ULONG DeleteLookups;
    ULONG DeleteLookupHits;

} HASH_STATISTICS, *PHASH_STATISTICS;

#ifndef MAX_PATH
#define MAX_PATH        260
#endif
#define RECORD_SIZE     ((MAX_PATH*sizeof(WCHAR))+SIZE_OF_RECORD_LIST)

typedef enum _IOTEST_PHASE {

    IoTestSetup,
    IoTestAction,
    IoTestValidation,
    IoTestCleanup,
    IoTestCompleted

} IOTEST_PHASE, *PIOTEST_PHASE;

typedef struct _IOTEST_STATUS {

    IOTEST_PHASE Phase;
    NTSTATUS TestResult;

} IOTEST_STATUS, *PIOTEST_STATUS;

#define DEVICE_NAME_SZ 64

#define IO_TEST_NO_FLAGS                     0x0
#define IO_TEST_TOP_OF_STACK                 0x00000001
#define IO_TEST_SAME_VOLUME_MOUNT_POINT      0x00000002
#define IO_TEST_DIFFERENT_VOLUME_MOUNT_POINT 0x00000004

typedef struct _IOTEST_READ_WRITE_PARAMETERS {

    ULONG Flags;
    ULONG DriveNameLength;
    ULONG FileNameLength;
    ULONG FileDataLength;

    WCHAR DriveNameBuffer[DEVICE_NAME_SZ];
    WCHAR FileNameBuffer[MAX_PATH];
    CHAR FileData[1];

} IOTEST_READ_WRITE_PARAMETERS, *PIOTEST_READ_WRITE_PARAMETERS;

typedef struct _IOTEST_RENAME_PARAMETERS {

    ULONG Flags;
    ULONG DriveNameLength;
    ULONG SourceFileNameLength;
    ULONG TargetFileNameLength;

    WCHAR DriveNameBuffer[DEVICE_NAME_SZ];
    WCHAR SourceFileNameBuffer[MAX_PATH];
    WCHAR TargetFileNameBuffer[MAX_PATH];
    
} IOTEST_RENAME_PARAMETERS, *PIOTEST_RENAME_PARAMETERS;

typedef struct _IOTEST_SHARE_PARAMETERS {

    ULONG Flags;
    ULONG DriveNameLength;
    ULONG FileNameLength;

    WCHAR DriveNameBuffer[DEVICE_NAME_SZ];
    WCHAR FileNameBuffer[MAX_PATH];
    
} IOTEST_SHARE_PARAMETERS, *PIOTEST_SHARE_PARAMETERS;

#endif /* __IOTEST_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\iotest\filter\iotestsup.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    ioTestSup.c

Abstract:

    This contains test routines for IoTest.

// @@BEGIN_DDKSPLIT

Author:

    Molly Brown (mollybro)  

// @@END_DDKSPLIT

Environment:

    Kernel mode

// @@BEGIN_DDKSPLIT
Revision History:

// @@END_DDKSPLIT
--*/

#include <stdio.h>

#include <ntifs.h>
#include "ioTest.h"
#include "ioTestKern.h"

NTSTATUS
IoTestFindTopDeviceObject (
    IN PUNICODE_STRING DriveName,
    OUT PDEVICE_OBJECT *IoTestDeviceObject
    )
{
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_OBJECT ioTestDeviceObject;

    ASSERT( IoTestDeviceObject != NULL );
    
    status = IoTestGetDeviceObjectFromName( DriveName, &deviceObject );

    if (!NT_SUCCESS( status )) {

        //
        //  There was an error, so return the error code.
        //
        
        return status;
    }

    if (IoTestIsAttachedToDevice( TOP_FILTER, 
                                  deviceObject, 
                                  &(ioTestDeviceObject))) {

        ASSERT( ioTestDeviceObject != NULL );

        status = STATUS_SUCCESS;

    } else {

        status = STATUS_INVALID_PARAMETER;
    }

    ObDereferenceObject( deviceObject );
    
    *IoTestDeviceObject = ioTestDeviceObject;

    return status;
}

#define FILE_NAME_HEADER L"\\??\\"

NTSTATUS
IoTestGenerateFileName (
    IN PUNICODE_STRING FileName,
    OUT PUNICODE_STRING RealFileName
    )
{
    PWCHAR realFileNameBuffer;

    ASSERT( FileName != NULL );
    ASSERT( RealFileName != NULL );
    
    //
    //  Must prefix the filename coming in with \\??\\
    //

    realFileNameBuffer = ExAllocatePoolWithTag( PagedPool,
                                                FileName->Length + sizeof( FILE_NAME_HEADER ),
                                                IOTEST_POOL_TAG );
    if (realFileNameBuffer == NULL) {

        IOTEST_DBG_PRINT0( IOTESTDEBUG_TESTS,
                           "(IoTestGenerateFileName) Cannot allocate a buffer for filename\n" );
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    realFileNameBuffer[0] = UNICODE_NULL;

    RtlInitEmptyUnicodeString( RealFileName, 
                               realFileNameBuffer, 
                               FileName->Length + sizeof( FILE_NAME_HEADER ));

    RtlAppendUnicodeToString( RealFileName, FILE_NAME_HEADER );
    RtlAppendUnicodeStringToString( RealFileName, FileName );

    return STATUS_SUCCESS;
}

NTSTATUS
IoTestReadTestDriver (
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    )
{
    UNICODE_STRING deviceName;
    UNICODE_STRING fileName;
    PIOTEST_READ_WRITE_PARAMETERS parms = InputBuffer;
    PIOTEST_STATUS testStatus = OutputBuffer;
    PDEVICE_OBJECT ioTestDeviceObject, targetDevice;
    NTSTATUS status;

    UNREFERENCED_PARAMETER( InputBufferLength );
    UNREFERENCED_PARAMETER( OutputBufferLength );

    RtlInitUnicodeString(&deviceName, parms->DriveNameBuffer);
    status = IoTestPrepareDevicesForTest( &deviceName, &ioTestDeviceObject);

    if (!NT_SUCCESS( status )) {

        return status;
    }

    ASSERT( ioTestDeviceObject != NULL );

    if (FlagOn( parms->Flags, IO_TEST_TOP_OF_STACK)) {

        targetDevice = NULL;

    } else {

        targetDevice = IO_TEST_TARGET_DEVICE( ioTestDeviceObject );
    }

    RtlInitUnicodeString(&fileName, parms->FileNameBuffer);
    
    IoTestReadTest( &fileName,
                    parms->FileData,
                    parms->FileDataLength,
                    targetDevice,
                    testStatus );

    IoTestCleanupDevicesForTest( ioTestDeviceObject );
    
    return STATUS_SUCCESS;
    
}

NTSTATUS
IoTestReadTest (
    IN PUNICODE_STRING FileName,
    IN PVOID FileData,
    IN ULONG FileDataLength,
    IN PDEVICE_OBJECT TargetDevice,
    OUT PIOTEST_STATUS TestStatus
    )
{
    OBJECT_ATTRIBUTES objAttribs;
    UNICODE_STRING realFileName;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;
    PVOID readData = NULL;

    ASSERT( TestStatus != NULL );

    //
    //  Must prefix the filename coming in with \\??\\
    //

    realFileName.Buffer = NULL;
    status = IoTestGenerateFileName( FileName, 
                                     &realFileName );

    if (!NT_SUCCESS( status )) {

        TestStatus->Phase = IoTestSetup;
        TestStatus->TestResult = status;

        IOTEST_DBG_PRINT0( IOTESTDEBUG_TESTS,
                           "(IoTestReadTest) Setup -- Cannot allocate a buffer for filename\n" );
        goto IoReadTest_Cleanup;
    }
    
    InitializeObjectAttributes( &objAttribs,
                                &realFileName,
                                OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );

    status = IoTestCreateFile( &fileHandle,
                               FILE_GENERIC_READ,
                               &objAttribs,
                               &ioStatus,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ,
                               FILE_OPEN,
                               FILE_SYNCHRONOUS_IO_NONALERT,
                               NULL,
                               0,
                               0,
                               TargetDevice );

    if (!NT_SUCCESS( status )) {

        TestStatus->Phase = IoTestSetup;
        TestStatus->TestResult = status;

        IOTEST_DBG_PRINT1( IOTESTDEBUG_TESTS,
                           "(IoTestReadTest) Setup -- Cannot open handle to %wZ\n",
                           FileName );
        goto IoReadTest_Cleanup;
    }

    readData = ExAllocatePoolWithTag( PagedPool,
                                      FileDataLength,
                                      IOTEST_POOL_TAG );

    if (NULL == readData) {

        TestStatus->Phase = IoTestSetup;
        TestStatus->TestResult = STATUS_INSUFFICIENT_RESOURCES;
        IOTEST_DBG_PRINT0( IOTESTDEBUG_TESTS,
                           "(IoTestReadTest) Setup -- Cannot allocate read buffer.\n");
        goto IoReadTest_Cleanup;
    }
        
    status = ZwReadFile( fileHandle,
                         NULL,
                         NULL,
                         NULL,
                         &ioStatus,
                         readData,
                         FileDataLength,
                         NULL,
                         NULL );

    if (!NT_SUCCESS( status )) {

        TestStatus->Phase = IoTestAction;
        TestStatus->TestResult = status;
        IOTEST_DBG_PRINT2( IOTESTDEBUG_TESTS,
                           "(IoTestReadTest) Action -- Cannot read file %wZ - status 0x%08x.\n",
                           FileName,
                           status );
        goto IoReadTest_Cleanup;
    }

    if (ioStatus.Information != FileDataLength) {

        TestStatus->Phase = IoTestAction;
        TestStatus->TestResult = status;
        IOTEST_DBG_PRINT1( IOTESTDEBUG_TESTS,
                           "(IoTestReadTest) Action -- Didn't read enough from file %wZ.\n",
                           FileName );
        goto IoReadTest_Cleanup;
    }

    //
    //  Validate the data we read from the disk.
    //

    status = IoTestCompareData( FileData,
                                readData,
                                FileDataLength );
    
                               
    if (!NT_SUCCESS( status )) {

        TestStatus->Phase = IoTestValidation;
        TestStatus->TestResult = status;
        IOTEST_DBG_PRINT1( IOTESTDEBUG_TESTS,
                           "(IoTestReadTest) Validation -- The data read doesn't match what was expected from file %wZ.\n",
                           FileName );
        goto IoReadTest_Cleanup;
    }

    //
    //  The test completed successfully, so update the TestStatus structure
    //  and cleanup.
    //

    TestStatus->Phase = IoTestCompleted;
    TestStatus->TestResult = STATUS_SUCCESS;
    
IoReadTest_Cleanup:

    if (fileHandle != INVALID_HANDLE_VALUE) {

        ZwClose( fileHandle );
    }

    if (readData != NULL) {

        ExFreePool( readData );
    }

    if (realFileName.Buffer != NULL) {

        ExFreePool( realFileName.Buffer );
    }

    return status;
}

NTSTATUS
IoTestRenameTestDriver (
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    )
{
    UNICODE_STRING deviceName;
    UNICODE_STRING sourceFileName, targetFileName;
    PIOTEST_RENAME_PARAMETERS parms = InputBuffer;
    PIOTEST_STATUS testStatus = OutputBuffer;
    PDEVICE_OBJECT ioTestDeviceObject, targetDevice;
    NTSTATUS status;

    UNREFERENCED_PARAMETER( InputBufferLength );
    UNREFERENCED_PARAMETER( OutputBufferLength );

    RtlInitUnicodeString(&deviceName, parms->DriveNameBuffer);
    status = IoTestPrepareDevicesForTest( &deviceName, &ioTestDeviceObject);

    if (!NT_SUCCESS( status )) {

        return status;
    }

    ASSERT( ioTestDeviceObject != NULL );

    if (FlagOn( parms->Flags, IO_TEST_TOP_OF_STACK)) {

        targetDevice = NULL;

    } else {

        targetDevice = IO_TEST_TARGET_DEVICE( ioTestDeviceObject );
    }

    RtlInitUnicodeString( &sourceFileName, parms->SourceFileNameBuffer );
    RtlInitUnicodeString( &targetFileName, parms->TargetFileNameBuffer );
    
    IoTestRenameTest( &sourceFileName,
                      &targetFileName,
                      targetDevice,
                      testStatus );

    IoTestCleanupDevicesForTest( ioTestDeviceObject );

    return STATUS_SUCCESS;
}

NTSTATUS
IoTestRenameTest (
    IN PUNICODE_STRING SourceFileName,
    IN PUNICODE_STRING TargetFileName,
    IN PDEVICE_OBJECT TargetDevice,
    OUT PIOTEST_STATUS TestStatus
    )
{
    OBJECT_ATTRIBUTES objAttribs;
    UNICODE_STRING realSourceFileName, realTargetFileName;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    PFILE_RENAME_INFORMATION renameInfo = NULL;
    ULONG renameInfoSize = 0;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;

    ASSERT( TestStatus != NULL );

    //
    //  Must prefix the filename coming in with \\??\\
    //

    realSourceFileName.Buffer = NULL;
    realTargetFileName.Buffer = NULL;
    status = IoTestGenerateFileName( SourceFileName, 
                                     &realSourceFileName );

    if (!NT_SUCCESS( status )) {

        TestStatus->Phase = IoTestSetup;
        TestStatus->TestResult = status;

        IOTEST_DBG_PRINT0( IOTESTDEBUG_TESTS,
                           "(IoTestRenameTest) Setup -- Cannot allocate a buffer for source filename\n" );
        goto IoRenameTest_Cleanup;
    }
    
    status = IoTestGenerateFileName( TargetFileName, 
                                     &realTargetFileName );

    if (!NT_SUCCESS( status )) {

        TestStatus->Phase = IoTestSetup;
        TestStatus->TestResult = status;

        IOTEST_DBG_PRINT0( IOTESTDEBUG_TESTS,
                           "(IoTestRenameTest) Setup -- Cannot allocate a buffer for target filename\n" );
        goto IoRenameTest_Cleanup;
    }

    InitializeObjectAttributes( &objAttribs,
                                &realSourceFileName,
                                OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );

    status = IoTestCreateFile( &fileHandle,
                               FILE_GENERIC_WRITE,
                               &objAttribs,
                               &ioStatus,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ | FILE_SHARE_DELETE,
                               FILE_OPEN,
                               FILE_SYNCHRONOUS_IO_NONALERT,
                               NULL,
                               0,
                               0,
                               TargetDevice );

    if (!NT_SUCCESS( status )) {

        TestStatus->Phase = IoTestSetup;
        TestStatus->TestResult = status;

        IOTEST_DBG_PRINT1( IOTESTDEBUG_TESTS,
                           "(IoTestRenameTest) Setup -- Cannot open handle to %wZ\n",
                           SourceFileName );
        goto IoRenameTest_Cleanup;
    }

    renameInfoSize = sizeof(FILE_RENAME_INFORMATION) + realTargetFileName.Length;
    renameInfo = ExAllocatePoolWithTag( PagedPool,
                                        renameInfoSize,
                                        IOTEST_POOL_TAG );

    if (NULL == renameInfo) {

        TestStatus->Phase = IoTestSetup;
        TestStatus->TestResult = STATUS_INSUFFICIENT_RESOURCES;
        IOTEST_DBG_PRINT0( IOTESTDEBUG_TESTS,
                           "(IoTestRenameTest) Setup -- Cannot allocate rename information buffer.\n");
        goto IoRenameTest_Cleanup;
    }

    renameInfo->ReplaceIfExists = FALSE;
    renameInfo->RootDirectory = NULL;
    renameInfo->FileNameLength = realTargetFileName.Length;
    RtlCopyMemory( renameInfo->FileName, 
                   realTargetFileName.Buffer, 
                   realTargetFileName.Length );
        
    status = ZwSetInformationFile( fileHandle,
                                   &ioStatus,
                                   renameInfo,
                                   renameInfoSize,
                                   FileRenameInformation );

    if (!NT_SUCCESS( status )) {

        TestStatus->Phase = IoTestAction;
        TestStatus->TestResult = status;
        IOTEST_DBG_PRINT3( IOTESTDEBUG_TESTS,
                           "(IoTestRenameTest) Action -- Cannot rename file %wZ to %wZ- status 0x%08x.\n",
                           SourceFileName,
                           TargetFileName,
                           status );
        goto IoRenameTest_Cleanup;
    }

    //
    //  The test completed successfully, so update the TestStatus structure
    //  and cleanup.
    //

    TestStatus->Phase = IoTestCompleted;
    TestStatus->TestResult = STATUS_SUCCESS;
    
IoRenameTest_Cleanup:

    if (fileHandle != INVALID_HANDLE_VALUE) {

        ZwClose( fileHandle );
    }

    if (realSourceFileName.Buffer != NULL) {

        ExFreePool( realSourceFileName.Buffer );
    }

    if (realTargetFileName.Buffer != NULL) {

        ExFreePool( realTargetFileName.Buffer );
    }

    if (renameInfo != NULL) {

        ExFreePool( renameInfo );
    }
    
    return status;
}

NTSTATUS
IoTestShareTestDriver (
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    )
{
    UNICODE_STRING deviceName;
    UNICODE_STRING fileName;
    PIOTEST_SHARE_PARAMETERS parms = InputBuffer;
    PIOTEST_STATUS testStatus = OutputBuffer;
    PDEVICE_OBJECT ioTestDeviceObject, targetDevice;
    NTSTATUS status;

    UNREFERENCED_PARAMETER( InputBufferLength );
    UNREFERENCED_PARAMETER( OutputBufferLength );

    RtlInitUnicodeString(&deviceName, parms->DriveNameBuffer);
    status = IoTestPrepareDevicesForTest( &deviceName, &ioTestDeviceObject);

    if (!NT_SUCCESS( status )) {

        return status;
    }

    ASSERT( ioTestDeviceObject != NULL );

    if (FlagOn( parms->Flags, IO_TEST_TOP_OF_STACK)) {

        targetDevice = NULL;

    } else {

        targetDevice = IO_TEST_TARGET_DEVICE( ioTestDeviceObject );
    }

    RtlInitUnicodeString( &fileName, parms->FileNameBuffer );
    
    IoTestShareTest( &fileName,
                     targetDevice,
                     testStatus );

    IoTestCleanupDevicesForTest( ioTestDeviceObject );

    return STATUS_SUCCESS;
}

NTSTATUS
IoTestShareTest (
    IN PUNICODE_STRING FileName,
    IN PDEVICE_OBJECT TargetDevice,
    OUT PIOTEST_STATUS TestStatus
    )
{
    OBJECT_ATTRIBUTES objAttribs;
    UNICODE_STRING realFileName;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;

    ASSERT( TestStatus != NULL );

    //
    //  Must prefix the filename coming in with \\??\\
    //

    realFileName.Buffer = NULL;
    status = IoTestGenerateFileName( FileName, 
                                     &realFileName );

    if (!NT_SUCCESS( status )) {

        TestStatus->Phase = IoTestSetup;
        TestStatus->TestResult = status;

        IOTEST_DBG_PRINT0( IOTESTDEBUG_TESTS,
                           "(IoTestShareTest) Setup -- Cannot allocate a buffer for filename\n" );
        goto IoShareTest_Cleanup;
    }
    
    InitializeObjectAttributes( &objAttribs,
                                &realFileName,
                                OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );

    status = IoTestCreateFile( &fileHandle,
                               FILE_GENERIC_WRITE,
                               &objAttribs,
                               &ioStatus,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ | FILE_SHARE_DELETE | FILE_SHARE_DELETE,
                               FILE_OPEN,
                               FILE_SYNCHRONOUS_IO_NONALERT,
                               NULL,
                               0,
                               IO_IGNORE_SHARE_ACCESS_CHECK,
                               TargetDevice );

    if (!NT_SUCCESS( status )) {

        TestStatus->Phase = IoTestSetup;
        TestStatus->TestResult = status;

        IOTEST_DBG_PRINT1( IOTESTDEBUG_TESTS,
                           "(IoTestShareTest) Setup -- Cannot open handle to %wZ\n",
                           FileName );
        goto IoShareTest_Cleanup;
    }

    //
    //  The test completed successfully, so update the TestStatus structure
    //  and cleanup.
    //

    TestStatus->Phase = IoTestCompleted;
    TestStatus->TestResult = STATUS_SUCCESS;
    
IoShareTest_Cleanup:

    if (fileHandle != INVALID_HANDLE_VALUE) {

        ZwClose( fileHandle );
    }

    if (realFileName.Buffer != NULL) {

        ExFreePool( realFileName.Buffer );
    }

    return status;
}

NTSTATUS
IoTestPrepareDevicesForTest (
    IN PUNICODE_STRING DeviceName,
    OUT PDEVICE_OBJECT* IoTestDeviceObject
    )
{
    PIOTEST_DEVICE_EXTENSION topDevExt, botDevExt;
    PDEVICE_OBJECT ioTestDeviceObject;
    NTSTATUS status;

    status = IoTestFindTopDeviceObject( DeviceName, &ioTestDeviceObject);

    if (!NT_SUCCESS( status )) {

        return status;
    }

    ASSERT( ioTestDeviceObject != NULL );

    //
    //  Turn off log, flush log, turn on log
    //

    topDevExt = ioTestDeviceObject->DeviceExtension;
    botDevExt = topDevExt->AttachedToDeviceObject->DeviceExtension;
    
    topDevExt->LogThisDevice = FALSE;
    botDevExt->LogThisDevice = FALSE;

    IoTestFlushLog();

    topDevExt->LogThisDevice = TRUE;
    botDevExt->LogThisDevice = TRUE;

    if (IoTestDeviceObject != NULL) {

        *IoTestDeviceObject = ioTestDeviceObject;
    }

    return STATUS_SUCCESS;
}

VOID
IoTestCleanupDevicesForTest (
    IN PDEVICE_OBJECT IoTestDeviceObject
    )
{
    PIOTEST_DEVICE_EXTENSION topDevExt, botDevExt;
   
    topDevExt = IoTestDeviceObject->DeviceExtension;
    botDevExt = topDevExt->AttachedToDeviceObject->DeviceExtension;
    
    //
    //  Turn off log.
    //

    topDevExt->LogThisDevice = FALSE;
    botDevExt->LogThisDevice = FALSE;

    //
    // Clear the reference on IoTestDeviceObject added by IoTestFindDeviceObject
    // in IoTestPrepareDevicesForTest.
    //

    ObDereferenceObject( IoTestDeviceObject );
}

NTSTATUS
IoTestCompareData (
    IN PCHAR OriginalData,
    IN PCHAR TestData,
    IN ULONG DataLength
    )
{
    ULONG i;

    for (i=0; i < DataLength; i++) {

        if (OriginalData[i] != TestData[i]) {

            return STATUS_DATA_ERROR;
        }
    }
    
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\iotest\filter\iotestkern.h ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    ioTestKern.h

Abstract:
    Header file which contains the structures, type definitions,
    constants, global variables and function prototypes that are
    only visible within the kernel.

// @@BEGIN_DDKSPLIT

Author:

    Molly Brown (mollybro)  

// @@END_DDKSPLIT

Environment:

    Kernel mode

// @@BEGIN_DDKSPLIT

Revision History:

// @@END_DDKSPLIT
--*/
#ifndef __IOTESTKERN_H__
#define __IOTESTKERN_H__

#define DBGSTATIC

#define MSFM_TAG 'YPSF'             // memory allocation tag value
#define USE_LOOKASIDE_LIST 0        // do NOT use look aside lists (use Allocate Pool)

#ifndef INVALID_HANDLE_VALUE
#define INVALID_HANDLE_VALUE (HANDLE) -1
#endif

#define HASH_SIZE            128        // MUST be a power of 2

//
//  Macros for IoTest DbgPrint levels.
//

#if DBG
#define IOTEST_DBG_PRINT0( _dbgLevel, _string )          \
    {                                                     \
        if (FlagOn( gIoTestDebugLevel, (_dbgLevel) )) {  \
            DbgPrint( (_string) );                        \
        }                                                 \
    }

#define IOTEST_DBG_PRINT1( _dbgLevel, _formatString, _parm1 )  \
    {                                                           \
        if (FlagOn( gIoTestDebugLevel, (_dbgLevel) )) {        \
            DbgPrint( (_formatString), (_parm1) );              \
        }                                                       \
    }

#define IOTEST_DBG_PRINT2( _dbgLevel, _formatString, _parm1, _parm2 )  \
    {                                                                   \
        if (FlagOn( gIoTestDebugLevel, (_dbgLevel) )) {                \
            DbgPrint( (_formatString), (_parm1), (_parm2) );            \
        }                                                               \
    }

#define IOTEST_DBG_PRINT3( _dbgLevel, _formatString, _parm1, _parm2, _parm3 )  \
    {                                                                           \
        if (FlagOn( gIoTestDebugLevel, (_dbgLevel) )) {                        \
            DbgPrint( (_formatString), (_parm1), (_parm2), (_parm3) );          \
        }                                                                       \
    }

#else

#define IOTEST_DBG_PRINT0( _dbgLevel, _string )
#define IOTEST_DBG_PRINT1( _dbgLevel, _formatString, _parm1 ) 
#define IOTEST_DBG_PRINT2( _dbgLevel, _formatString, _parm1, _parm2 )
#define IOTEST_DBG_PRINT3( _dbgLevel, _formatString, _parm1, _parm2, _parm3 )

#endif

//---------------------------------------------------------------------------
//      Global variables
//---------------------------------------------------------------------------
#define IOTESTDEBUG_DISPLAY_ATTACHMENT_NAMES    0x00000001
#define IOTESTDEBUG_ERROR                       0x00000002
#define IOTESTDEBUG_TRACE_NAME_REQUESTS         0x00000004
#define IOTESTDEBUG_TRACE_IRP_OPS               0x00000010
#define IOTESTDEBUG_TRACE_FAST_IO_OPS           0x00000020
#define IOTESTDEBUG_TRACE_FSFILTER_OPS          0x00000040
#define IOTESTDEBUG_TESTS                       0x00000100

extern ULONG gIoTestDebugLevel;
extern ULONG gIoTestAttachMode;

extern PDEVICE_OBJECT gControlDeviceObject;
extern PDRIVER_OBJECT gIoTestDriverObject;

extern FAST_MUTEX gIoTestDeviceExtensionListLock;
extern LIST_ENTRY gIoTestDeviceExtensionList;

extern KSPIN_LOCK gOutputBufferLock;
extern LIST_ENTRY gOutputBufferList;

extern NPAGED_LOOKASIDE_LIST gFreeBufferList;

extern ULONG gLogSequenceNumber;
extern KSPIN_LOCK gLogSequenceLock;

extern UNICODE_STRING gVolumeString;
extern UNICODE_STRING gOverrunString;
extern UNICODE_STRING gPagingIoString;

extern LIST_ENTRY gHashTable[HASH_SIZE];
extern KSPIN_LOCK gHashLockTable[HASH_SIZE];
extern ULONG gHashMaxCounters[HASH_SIZE];
extern ULONG gHashCurrentCounters[HASH_SIZE];

extern HASH_STATISTICS gHashStat;

#define DEFAULT_MAX_RECORDS_TO_ALLOCATE 100;
#define DEFAULT_MAX_NAMES_TO_ALLOCATE   100;
#define DEFAULT_IOTEST_DEBUG_LEVEL     IOTESTDEBUG_ERROR;
#define MAX_RECORDS_TO_ALLOCATE         L"MaxRecords"
#define MAX_NAMES_TO_ALLOCATE           L"MaxNames"
#define DEBUG_LEVEL                     L"DebugFlags"
#define ATTACH_MODE                     L"AttachMode"


extern LONG gMaxRecordsToAllocate;
extern LONG gRecordsAllocated;
extern LONG gMaxNamesToAllocate;
extern LONG gNamesAllocated;

extern LONG gStaticBufferInUse;
extern CHAR gOutOfMemoryBuffer[RECORD_SIZE];

#define IOTEST_POOL_TAG    ' ToI'

//
//  Given a device type, return a valid name
//

extern const PCHAR DeviceTypeNames[];
extern ULONG SizeOfDeviceTypeNames;

#define GET_DEVICE_TYPE_NAME( _type ) \
            ((((_type) > 0) && ((_type) < (SizeOfDeviceTypeNames / sizeof(PCHAR)))) ? \
                DeviceTypeNames[ (_type) ] : \
                "[Unknown]")

//
//  Macro to test for device types we want to attach to
//

#define IS_DESIRED_DEVICE_TYPE(_type) \
    (((_type) == FILE_DEVICE_DISK_FILE_SYSTEM) || \
     ((_type) == FILE_DEVICE_CD_ROM_FILE_SYSTEM) || \
     ((_type) == FILE_DEVICE_NETWORK_FILE_SYSTEM))

//
// Returns the number of BYTES unused in the RECORD_LIST structure
//

#define REMAINING_NAME_SPACE(RecordList) \
    (USHORT)(RECORD_SIZE - \
            (((RecordList)->LogRecord.Length) + sizeof(LIST_ENTRY)))


//
// The maximum number of BYTES that can be used to store the file name in the
// RECORD_LIST structure
//

#define MAX_NAME_SPACE (RECORD_SIZE - SIZE_OF_RECORD_LIST)

#define HASH_FUNC(FileObject) \
    (((UINT_PTR)(FileObject) >> 8) & (HASH_SIZE - 1))

typedef struct _HASH_ENTRY {

    LIST_ENTRY List;
    PFILE_OBJECT FileObject;
    UNICODE_STRING Name;

} HASH_ENTRY, *PHASH_ENTRY;

#define USER_NAMES_SZ   64

//
// Define the device extension structure that the IoTest driver
// adds to each device object it is attached to.  It stores
// the context IoTest needs to perform its logging operations on
// a device.
//

typedef struct _IOTEST_DEVICE_EXTENSION {

    IOTEST_DEVICE_TYPE Type;    

    PDEVICE_OBJECT AttachedToDeviceObject;   // device object we are attached to
    PDEVICE_OBJECT DiskDeviceObject;         // the device object at the top of
                                             //   storage stack; used in 
                                             //   IoTestMountCompletion
    BOOLEAN LogThisDevice;
    BOOLEAN IsVolumeDeviceObject;            // if TRUE this is an attachment to
                                             // a volume device object, if FALSE
                                             // this is an attachment to a file
                                             // system control device object.
    LIST_ENTRY NextIoTestDeviceLink;        // linked list of devices we are
                                             //     attached to
    UNICODE_STRING DeviceNames;              // receives name of device
    UNICODE_STRING UserNames;                // names that the user used to 
                                             //   start logging this device
    WCHAR DeviceNamesBuffer[DEVICE_NAMES_SZ];// holds actual device names
    WCHAR UserNamesBuffer[USER_NAMES_SZ];    // holds actual user names

    //
    //  Note: We keep these two forms of the name so that we can build
    //    a nicer looking name when we are printing out file names.
    //    We want just the "c:" type device name at the beginning
    //    of a file name, not "\device\hardiskVolume1".
    //

} IOTEST_DEVICE_EXTENSION, *PIOTEST_DEVICE_EXTENSION;

typedef struct _MINI_DEVICE_STACK {
    
    PDEVICE_OBJECT Top;
    PDEVICE_OBJECT Bottom;

} MINI_DEVICE_STACK, *PMINI_DEVICE_STACK;

#define IS_IOTEST_DEVICE_OBJECT( _devObj )                               \
    (((_devObj) != NULL) &&                                               \
     ((_devObj)->DriverObject == gIoTestDriverObject) &&                 \
     ((_devObj)->DeviceExtension != NULL))
    
#define IS_TOP_FILTER_DEVICE_OBJECT( _devObj) \
    (IS_IOTEST_DEVICE_OBJECT(_devObj) && \
     (_devObj)->DeviceType == TOP_FILTER)

#define IS_BOTTOM_FILTER_DEVICE_OBJECT( _devObj) \
    (IS_IOTEST_DEVICE_OBJECT(_devObj) && \
     (_devObj)->DeviceType == BOTTOM_FILTER)

#define IO_TEST_TARGET_DEVICE( _devObj ) \
    (((PIOTEST_DEVICE_EXTENSION)((_devObj)->DeviceExtension))->AttachedToDeviceObject)

typedef enum _CONTROL_DEVICE_STATE {

    OPENED,
    CLOSED,
    CLEANING_UP

} CONTROL_DEVICE_STATE;

extern CONTROL_DEVICE_STATE gControlDeviceState;
extern KSPIN_LOCK gControlDeviceStateLock;

#ifdef USE_DO_HINT

#define IoTestCreateFile( F, D, O, I, A, FA, SA, CD, CO, EB, EL, OP, DO ) \
    IoCreateFileSpecifyDeviceObjectHint((F),                          \
                                        (D),                          \
                                        (O),                          \
                                        (I),                          \
                                        (A),                          \
                                        (FA),                         \
                                        (SA),                         \
                                        (CD),                         \
                                        (CO),                         \
                                        (EB),                         \
                                        (EL),                         \
                                        CreateFileTypeNone,           \
                                        NULL,                         \
                                        IO_NO_PARAMETER_CHECKING | (OP),     \
                                        (DO) );

#else

#define IoTestCreateFile( F, D, O, I, A, FA, SA, CD, CO, EB, EL, OP, DO ) \
    ZwCreateFile((F),                          \
                 (D),                          \
                 (O),                          \
                 (I),                          \
                 (A),                          \
                 (FA),                         \
                 (SA),                         \
                 (CD),                         \
                 (CO),                         \
                 (EB),                         \
                 (EL) );
#endif /* USE_DO_HINT */
////////////////////////////////////////////////////////////////////////
//                                                                    //
//    Prototypes for the routines this driver uses to filter the      //
//    the data that is being seen by this file systems.               //
//                                                                    //
//                   implemented in filespy.c                         //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
);

VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
);

NTSTATUS
IoTestDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

NTSTATUS
IoTestPassThrough (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

NTSTATUS
IoTestPassThroughCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
);

NTSTATUS
IoTestCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

NTSTATUS
IoTestClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
IoTestFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN        
IoTestFastIoWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoQueryStandardInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoDeviceControl (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

VOID
IoTestFastIoDetachDevice (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
);

BOOLEAN
IoTestFastIoQueryNetworkOpenInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoMdlRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoMdlReadComplete (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoPrepareMdlWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoMdlWriteComplete (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoReadCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoWriteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoMdlReadCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoMdlWriteCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoQueryOpen (
    IN PIRP Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN PDEVICE_OBJECT DeviceObject
);

NTSTATUS
IoTestPreFsFilterOperation (
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext
);

VOID
IoTestPostFsFilterOperation (
    IN PFS_FILTER_CALLBACK_DATA Data,
    IN NTSTATUS OperationStatus,
    IN PVOID CompletionContext
);

NTSTATUS
IoTestCommonDeviceIoControl (
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

//-----------------------------------------------------
//
//  This routines are only used if Filespy is attaching
//  to all volume in the system instead of attaching to
//  volumes on demand.
//
//-----------------------------------------------------

NTSTATUS
IoTestFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

NTSTATUS
IoTestSetInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

VOID
IoTestFsNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FsActive
);

NTSTATUS
IoTestMountCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
);

NTSTATUS
IoTestLoadFsCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
);

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                  Library support routines                          //
//                   implemented in iotestlib.c                         //
//                                                                    //
////////////////////////////////////////////////////////////////////////

VOID
IoTestReadDriverParameters (
    IN PUNICODE_STRING RegistryPath
);

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                  Memory allocation routines                        //
//                   implemented in iotestlib.c                         //
//                                                                    //
////////////////////////////////////////////////////////////////////////

PVOID
IoTestAllocateBuffer (
    IN OUT PLONG Counter,
    IN LONG MaxCounterValue,
    OUT PULONG RecordType
);

VOID
IoTestFreeBuffer (
    PVOID Buffer,
    PLONG Counter
);

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                      Logging routines                              //
//                   implemented in iotestlib.c                         //
//                                                                    //
////////////////////////////////////////////////////////////////////////

PRECORD_LIST
IoTestNewRecord (
    ULONG AssignedSequenceNumber
);

VOID
IoTestFreeRecord (
    PRECORD_LIST Record
);

VOID
IoTestLogIrp (
    IN PIRP Irp,
    IN UCHAR LoggingFlags,
    OUT PRECORD_LIST RecordList
);

PRECORD_LIST
IoTestLogFastIoStart (
    IN FASTIO_TYPE FastIoType,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait
);

VOID
IoTestLogFastIoComplete (
    IN PIO_STATUS_BLOCK ReturnStatus,
    IN PRECORD_LIST RecordList
);

VOID
IoTestLogPreFsFilterOperation (
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PRECORD_LIST RecordList
    );

VOID
IoTestLogPostFsFilterOperation (
    IN NTSTATUS OperationStatus,
    OUT PRECORD_LIST RecordList
    );

NTSTATUS
IoTestLog (
    IN PRECORD_LIST NewRecord
);

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                    FileName cache routines                         //
//                    implemented in iotestlib.c                        //
//                                                                    //
////////////////////////////////////////////////////////////////////////

PHASH_ENTRY
IoTestHashBucketLookup (
    PLIST_ENTRY ListHead,
    PFILE_OBJECT FileObject
);

VOID
IoTestNameLookup (
    IN PRECORD_LIST RecordList,
    IN PFILE_OBJECT FileObject,
    IN ULONG LookupFlags,
    IN PIOTEST_DEVICE_EXTENSION DeviceExtension
);

VOID
IoTestNameDeleteAllNames (
    VOID
);

VOID
IoTestNameDelete (
    IN PFILE_OBJECT FileObject
);

BOOLEAN
IoTestGetFullPathName (
    IN PFILE_OBJECT FileObject,
    IN OUT PUNICODE_STRING FileName,
    IN PIOTEST_DEVICE_EXTENSION DeviceExtension,
    IN ULONG LookupFlags
);

NTSTATUS
IoTestQueryFileSystemForFileName (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT NextDeviceObject,
    IN ULONG FileNameInfoLength,
    OUT PFILE_NAME_INFORMATION FileNameInfo,
    OUT PULONG ReturnedLength
);

NTSTATUS
IoTestQueryFileSystemForNameCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT SynchronizingEvent
);

////////////////////////////////////////////////////////////////////////
//                                                                    //
//         Common attachment and detachment routines                  //
//              implemented in iotestlib.c                              //
//                                                                    //
////////////////////////////////////////////////////////////////////////

BOOLEAN
IoTestIsAttachedToDevice (
    IOTEST_DEVICE_TYPE DeviceType,
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL
);

NTSTATUS
IoTestAttachToMountedDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT IoTestDeviceObject,
    IN PDEVICE_OBJECT DiskDeviceObject,
    IN IOTEST_DEVICE_TYPE DeviceType
);

VOID
IoTestCleanupMountedDevice (
    IN PDEVICE_OBJECT DeviceObject
    );

////////////////////////////////////////////////////////////////////////
//                                                                    //
//           Helper routine for turning on/off logging on demand      //
//                  implemented in iotestlib.c                          //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
IoTestGetDeviceObjectFromName (
    IN PUNICODE_STRING DeviceName,
    OUT PDEVICE_OBJECT *DeviceObject
);

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                 Start/stop logging routines                        //
//                  implemented in iotestlib.c                          //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
IoTestStartLoggingDevice (
    PDEVICE_OBJECT DeviceObject,
    PWSTR UserDeviceName
);

NTSTATUS
IoTestStopLoggingDevice (
    PWSTR deviceName
);

////////////////////////////////////////////////////////////////////////
//                                                                    //
//       Attaching/detaching to all volumes in system routines        //
//                  implemented in iotestlib.c                          //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
IoTestCreateDeviceObjects (
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT RealDeviceObject OPTIONAL,
    IN OUT PMINI_DEVICE_STACK Context
    );

NTSTATUS
IoTestAttachDeviceObjects (
    IN PMINI_DEVICE_STACK Context,
    IN PDEVICE_OBJECT MountedDevice,
    IN PDEVICE_OBJECT DiskDevice
    );

VOID
IoTestCleanupDeviceObjects (
    IN PMINI_DEVICE_STACK Context
    );
    
NTSTATUS
IoTestAttachToFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
);

VOID
IoTestDetachFromFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject
);

NTSTATUS
IoTestEnumerateFileSystemVolumes (
    IN PDEVICE_OBJECT FSDeviceObject,
    IN PUNICODE_STRING Name
);

////////////////////////////////////////////////////////////////////////
//                                                                    //
//             Private Filespy IOCTLs helper routines                 //
//                  implemented in iotestlib.c                          //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
IoTestGetAttachList (
    PVOID buffer,
    ULONG bufferSize,
    PULONG_PTR returnLength
);

VOID
IoTestGetLog (
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
);

VOID
IoTestFlushLog (
);

VOID
IoTestCloseControlDevice (
);

////////////////////////////////////////////////////////////////////////
//                                                                    //
//               Device name tracking helper routines                 //
//                  implemented in iotestlib.c                          //
//                                                                    //
////////////////////////////////////////////////////////////////////////

VOID
IoTestGetObjectName (
    IN PVOID Object,
    IN OUT PUNICODE_STRING Name
);

VOID
IoTestGetBaseDeviceObjectName (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
);

VOID
IoTestCacheDeviceName (
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFindSubString (
    IN PUNICODE_STRING String,
    IN PUNICODE_STRING SubString
);

VOID
IoTestStoreUserName (
    IN PIOTEST_DEVICE_EXTENSION DeviceExtension,
    IN PUNICODE_STRING UserName
);

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                        Debug support routines                      //
//                       implemented in iotestlib.c                     //
//                                                                    //
////////////////////////////////////////////////////////////////////////

VOID
IoTestDumpIrpOperation (
    IN BOOLEAN InOriginatingPath,
    IN PIRP Irp
);

VOID
IoTestDumpFastIoOperation (
    IN BOOLEAN InPreOperation,
    IN FASTIO_TYPE FastIoOperation
);

VOID
IoTestDumpFsFilterOperation (
    IN BOOLEAN InPreOperationCallback,
    IN PFS_FILTER_CALLBACK_DATA Data
);

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                        Test routines routines                      //
//                       implemented in iotestlib.c                     //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
IoTestFindTopDeviceObject (
    IN PUNICODE_STRING DriveName,
    OUT PDEVICE_OBJECT *IoTestDeviceObject
    );

NTSTATUS
IoTestReadTestDriver (
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    );

NTSTATUS
IoTestReadTest (
    IN PUNICODE_STRING FileName,
    IN PVOID FileData,
    IN ULONG FileDataLength,
    IN PDEVICE_OBJECT TargetDevice,
    OUT PIOTEST_STATUS TestStatus
    );

NTSTATUS
IoTestRenameTestDriver (
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    );

NTSTATUS
IoTestRenameTest (
    IN PUNICODE_STRING SourceFileName,
    IN PUNICODE_STRING TargetFileName,
    IN PDEVICE_OBJECT TargetDevice,
    OUT PIOTEST_STATUS TestStatus
    );

NTSTATUS
IoTestShareTestDriver (
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    );

NTSTATUS
IoTestShareTest (
    IN PUNICODE_STRING FileName,
    IN PDEVICE_OBJECT DeviceObject,
    OUT PIOTEST_STATUS TestStatus
    );

NTSTATUS
IoTestPrepareDevicesForTest (
    IN PUNICODE_STRING DeviceName,
    OUT PDEVICE_OBJECT* IoTestTopDeviceObject
    );

VOID
IoTestCleanupDevicesForTest (
    IN PDEVICE_OBJECT IoTestTopDeviceObject
    );

NTSTATUS
IoTestCompareData (
    IN PCHAR OriginalData,
    IN PCHAR TestData,
    IN ULONG DataLength
    );


#endif /* __IOTESTKERN_H__ */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\iotest\lib\fsfilteroperationnames.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    irpName.c

Abstract:

    This module contains functions used to generate names for IRPs

// @@BEGIN_DDKSPLIT
Author:

    Neal Christiansen (NealCH) 27-Sep-2000

// @@END_DDKSPLIT

Environment:

    User mode


// @@BEGIN_DDKSPLIT
Revision History:

// @@END_DDKSPLIT
--*/

#include <ntifs.h>
#include <stdio.h>
#include "ioTestLib.h"


VOID
GetFsFilterOperationName (
    IN UCHAR FsFilterOperation,
    OUT PCHAR FsFilterOperationName
    )
/*++

Routine Description:

    This routine translates the given FsFilter Operation code into a printable
    string which is returned.  

Arguments:

    FsFilterOperation - the FsFilter operation code to translate
    FsFilterOperationName - a buffer at least OPERATION_NAME_BUFFER_SIZE
                characters long that receives the name.

Return Value:

    None.

--*/
{
    PCHAR operationString;
    CHAR nameBuf[OPERATION_NAME_BUFFER_SIZE];

    switch (FsFilterOperation) {

        case FS_FILTER_ACQUIRE_FOR_CC_FLUSH:
            operationString = "ACQUIRE_FOR_CC_FLUSH";
            break;

        case FS_FILTER_RELEASE_FOR_CC_FLUSH:
            operationString = "RELEASE_FOR_CC_FLUSH";
            break;

        case FS_FILTER_ACQUIRE_FOR_SECTION_SYNCHRONIZATION:
            operationString = "ACQUIRE_FOR_SECTION_SYNC";
            break;

        case FS_FILTER_RELEASE_FOR_SECTION_SYNCHRONIZATION:
            operationString = "RELEASE_FOR_SECTION_SYNC";
            break;

        case FS_FILTER_ACQUIRE_FOR_MOD_WRITE:
            operationString = "ACQUIRE_FOR_MOD_WRITE";
            break;

        case FS_FILTER_RELEASE_FOR_MOD_WRITE:
            operationString = "RELEASE_FOR_MOD_WRITE";
            break;

        default:
            sprintf(nameBuf,"Unknown FsFilter operation (%u)",FsFilterOperation);
            operationString = nameBuf;
    }

    strcpy(FsFilterOperationName,operationString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\iotest\lib\fastionames.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    irpName.c

Abstract:

    This module contains functions used to generate names for IRPs

// @@BEGIN_DDKSPLIT
Author:

    Neal Christiansen (NealCH) 27-Sep-2000

// @@END_DDKSPLIT

Environment:

    User mode


// @@BEGIN_DDKSPLIT
Revision History:

// @@END_DDKSPLIT
--*/

#include <ntifs.h>
#include <stdio.h>
#include "ioTestLib.h"


VOID
GetFastioName (
    IN FASTIO_TYPE FastIoCode,
    OUT PCHAR FastIoName
    )
/*++

Routine Description:

    This routine translates the given FastIO code into a printable string which
    is returned.  

Arguments:

    FastIoCode - the FastIO code to translate
    FastioName - a buffer at least OPERATION_NAME_BUFFER_SIZE characters long
                 that receives the fastIO name.

Return Value:

    None.

--*/
{
    PCHAR fastIoString;
    CHAR nameBuf[OPERATION_NAME_BUFFER_SIZE];

    switch (FastIoCode) {

        case CHECK_IF_POSSIBLE:
            fastIoString = "CHECK_IF_POSSIBLE";
            break;

        case READ:
            fastIoString = "READ";
            break;

        case WRITE:
            fastIoString = "WRITE";
            break;

        case QUERY_BASIC_INFO:
            fastIoString = "QUERY_BASIC_INFO";
            break;

        case QUERY_STANDARD_INFO:
            fastIoString = "QUERY_STANDARD_INFO";
            break;

        case LOCK:
            fastIoString = "LOCK";
            break;

        case UNLOCK_SINGLE:
            fastIoString = "UNLOCK_SINGLE";
            break;

        case UNLOCK_ALL:
            fastIoString = "UNLOCK_ALL";
            break;

        case UNLOCK_ALL_BY_KEY:
            fastIoString = "UNLOCK_ALL_BY_KEY";
            break;

        case DEVICE_CONTROL:
            fastIoString = "DEVICE_CONTROL";
            break;

        case DETACH_DEVICE:
            fastIoString = "DETACH_DEVICE";
            break;

        case QUERY_NETWORK_OPEN_INFO:
            fastIoString = "QUERY_NETWORK_OPEN_INFO";
            break;

        case MDL_READ:
            fastIoString = "MDL_READ";
            break;

        case MDL_READ_COMPLETE:
            fastIoString = "MDL_READ_COMPLETE";
            break;

        case MDL_WRITE:
            fastIoString = "MDL_WRITE";
            break;

        case MDL_WRITE_COMPLETE:
            fastIoString = "MDL_WRITE_COMPLETE";
            break;

        case READ_COMPRESSED:
            fastIoString = "READ_COMPRESSED";
            break;

        case WRITE_COMPRESSED:
            fastIoString = "WRITE_COMPRESSED";
            break;

        case MDL_READ_COMPLETE_COMPRESSED:
            fastIoString = "MDL_READ_COMPLETE_COMPRESSED";
            break;

        case PREPARE_MDL_WRITE:
            fastIoString = "PREPARE_MDL_WRITE";
            break;

        case MDL_WRITE_COMPLETE_COMPRESSED:
            fastIoString = "MDL_WRITE_COMPLETE_COMPRESSED";
            break;

        case QUERY_OPEN:
            fastIoString = "QUERY_OPEN";
            break;

        default:
            sprintf(nameBuf,"Unknown FastIO operation (%u)",FastIoCode);
            fastIoString = nameBuf;
    }

    strcpy(FastIoName,fastIoString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\iotest\lib\iotestlib.h ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    ioTestLib.h

Abstract:

    This contains internal defintions from the fileSpy library
    
// @@BEGIN_DDKSPLIT
Author:

    Neal Christiansen (NealCH) 27-Sep-2000

// @@END_DDKSPLIT
Environment:

    Library used by both USER and KERNEL mode components

// @@BEGIN_DDKSPLIT
Revision History:

// @@END_DDKSPLIT
--*/

#ifndef __IOTESTLIB_H__
#define __IOTESTLIB_H__

#ifdef __cplusplus
extern "C" {
#endif

//
//  The types FASTIO that are available for the Type field of the 
//  RECORD_FASTIO structure.
//

typedef enum {

    CHECK_IF_POSSIBLE = 1,
    READ,
    WRITE,
    QUERY_BASIC_INFO,
    QUERY_STANDARD_INFO,
    LOCK,
    UNLOCK_SINGLE,
    UNLOCK_ALL,
    UNLOCK_ALL_BY_KEY,
    DEVICE_CONTROL,
    DETACH_DEVICE,
    QUERY_NETWORK_OPEN_INFO,
    MDL_READ,
    MDL_READ_COMPLETE,
    MDL_WRITE,
    MDL_WRITE_COMPLETE,
    READ_COMPRESSED,
    WRITE_COMPRESSED,
    MDL_READ_COMPLETE_COMPRESSED,
    PREPARE_MDL_WRITE,
    MDL_WRITE_COMPLETE_COMPRESSED,
    QUERY_OPEN,

    FASTIO_MAX_OPERATION=QUERY_OPEN
} FASTIO_TYPE/*, *PFASTIO_TYPE*/;

//
//  Size of return name buffers
//

#define OPERATION_NAME_BUFFER_SIZE 80

//
//  Function prototypes
//

extern
VOID
GetIrpName (
    IN UCHAR MajorCode,
    IN UCHAR MinorCode,
    IN ULONG FsctlCode,
    OUT PCHAR MajorCodeName,
    OUT PCHAR MinorCodeName);

extern
VOID
GetFastioName (
    IN FASTIO_TYPE FastioCode,
    OUT PCHAR FastioName);

extern
VOID
GetFsFilterOperationName (
    IN UCHAR FsFilterOperation,
    OUT PCHAR FsFilterOperationName);

//
//  Service definitions
//

#define IOTEST_SERVICE_NAME   L"IoTest"
#define IOTEST_SERVICE_ACCESS (STANDARD_RIGHTS_REQUIRED | \
                                SERVICE_QUERY_CONFIG | \
                                SERVICE_QUERY_STATUS | \
                                SERVICE_START)

//
//  These are copied from NTIFS.H because we need them in user mode.
//

#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_QUERY_EA                 0x07
#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
#define IRP_MJ_DIRECTORY_CONTROL        0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
#define IRP_MJ_DEVICE_CONTROL           0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_CREATE_MAILSLOT          0x13
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_POWER                    0x16
#define IRP_MJ_SYSTEM_CONTROL           0x17
#define IRP_MJ_DEVICE_CHANGE            0x18
#define IRP_MJ_QUERY_QUOTA              0x19
#define IRP_MJ_SET_QUOTA                0x1a
#define IRP_MJ_PNP                      0x1b
#define IRP_MJ_MAXIMUM_FUNCTION         0x1b

#define IRP_MN_QUERY_DIRECTORY          0x01
#define IRP_MN_NOTIFY_CHANGE_DIRECTORY  0x02
#define IRP_MN_USER_FS_REQUEST          0x00
#define IRP_MN_MOUNT_VOLUME             0x01
#define IRP_MN_VERIFY_VOLUME            0x02
#define IRP_MN_LOAD_FILE_SYSTEM         0x03
#define IRP_MN_TRACK_LINK               0x04
#define IRP_MN_LOCK                     0x01
#define IRP_MN_UNLOCK_SINGLE            0x02
#define IRP_MN_UNLOCK_ALL               0x03
#define IRP_MN_UNLOCK_ALL_BY_KEY        0x04
#define IRP_MN_NORMAL                   0x00
#define IRP_MN_DPC                      0x01
#define IRP_MN_MDL                      0x02
#define IRP_MN_COMPLETE                 0x04
#define IRP_MN_COMPRESSED               0x08
#define IRP_MN_MDL_DPC                  (IRP_MN_MDL | IRP_MN_DPC)
#define IRP_MN_COMPLETE_MDL             (IRP_MN_COMPLETE | IRP_MN_MDL)
#define IRP_MN_COMPLETE_MDL_DPC         (IRP_MN_COMPLETE_MDL | IRP_MN_DPC)
#define IRP_MN_SCSI_CLASS               0x01
#define IRP_MN_START_DEVICE                 0x00
#define IRP_MN_QUERY_REMOVE_DEVICE          0x01
#define IRP_MN_REMOVE_DEVICE                0x02
#define IRP_MN_CANCEL_REMOVE_DEVICE         0x03
#define IRP_MN_STOP_DEVICE                  0x04
#define IRP_MN_QUERY_STOP_DEVICE            0x05
#define IRP_MN_CANCEL_STOP_DEVICE           0x06
#define IRP_MN_QUERY_DEVICE_RELATIONS       0x07
#define IRP_MN_QUERY_INTERFACE              0x08
#define IRP_MN_QUERY_CAPABILITIES           0x09
#define IRP_MN_QUERY_RESOURCES              0x0A
#define IRP_MN_QUERY_RESOURCE_REQUIREMENTS  0x0B
#define IRP_MN_QUERY_DEVICE_TEXT            0x0C
#define IRP_MN_FILTER_RESOURCE_REQUIREMENTS 0x0D
#define IRP_MN_READ_CONFIG                  0x0F
#define IRP_MN_WRITE_CONFIG                 0x10
#define IRP_MN_EJECT                        0x11
#define IRP_MN_SET_LOCK                     0x12
#define IRP_MN_QUERY_ID                     0x13
#define IRP_MN_QUERY_PNP_DEVICE_STATE       0x14
#define IRP_MN_QUERY_BUS_INFORMATION        0x15
#define IRP_MN_DEVICE_USAGE_NOTIFICATION    0x16
#define IRP_MN_SURPRISE_REMOVAL             0x17
#define IRP_MN_QUERY_LEGACY_BUS_INFORMATION 0x18
#define IRP_MN_WAIT_WAKE                    0x00
#define IRP_MN_POWER_SEQUENCE               0x01
#define IRP_MN_SET_POWER                    0x02
#define IRP_MN_QUERY_POWER                  0x03
#define IRP_MN_QUERY_ALL_DATA               0x00
#define IRP_MN_QUERY_SINGLE_INSTANCE        0x01
#define IRP_MN_CHANGE_SINGLE_INSTANCE       0x02
#define IRP_MN_CHANGE_SINGLE_ITEM           0x03
#define IRP_MN_ENABLE_EVENTS                0x04
#define IRP_MN_DISABLE_EVENTS               0x05
#define IRP_MN_ENABLE_COLLECTION            0x06
#define IRP_MN_DISABLE_COLLECTION           0x07
#define IRP_MN_REGINFO                      0x08
#define IRP_MN_EXECUTE_METHOD               0x09

//
//  Lists of IRP names and FASTIO names
//

extern PWCHAR IrpNameList[IRP_MJ_MAXIMUM_FUNCTION+1];
extern PWCHAR FastIoNameList[FASTIO_MAX_OPERATION];


#ifdef __cplusplus
}
#endif

#endif __IOTESTLIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\iotest\lib\irpnames.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    irpName.c

Abstract:

    This module contains functions used to generate names for IRPs

// @@BEGIN_DDKSPLIT
Author:

    Neal Christiansen (NealCH) 27-Sep-2000

// @@END_DDKSPLIT

Environment:

    User mode


// @@BEGIN_DDKSPLIT
Revision History:

// @@END_DDKSPLIT
--*/

#include <ntifs.h>
#include <stdio.h>
#include "ioTestLib.h"

//
//  Globals
//

CHAR UnknownIrpMinor[] = "Unknown Irp minor code (%u)";


VOID
GetIrpName (
    IN UCHAR MajorCode,
    IN UCHAR MinorCode,
    IN ULONG FsctlCode,
    OUT PCHAR MajorCodeName,
    OUT PCHAR MinorCodeName
    )
/*++

Routine Description:

    This routine translates the given Irp codes into printable strings which
    are returned.  This guarentees to routine valid strings in each buffer.
    The MinorCode string may be a NULL string (not a null pointer).

Arguments:

    MajorCode - the IRP Major code of the operation
    MinorCode - the IRP Minor code of the operation
    FsctlCode - if this is an IRP_MJ_FILE_SYSTEM_CONTROL/IRP_MN_USER_FS_REQUEST
                operation then this is the FSCTL code whose name is also
                translated.  This name is returned as part of the MinorCode
                string.
    MajorCodeName - a string buffer at least OPERATION_NAME_BUFFER_SIZE
                characters long that receives the major code name.
    MinorCodeName - a string buffer at least OPERATION_NAME_BUFFER_SIZE
                characters long that receives the minor/fsctl code name.

Return Value:

    None.

--*/
{
    PCHAR irpMajorString;
    PCHAR irpMinorString = "";
    CHAR nameBuf[OPERATION_NAME_BUFFER_SIZE];

    switch (MajorCode) {
        case IRP_MJ_CREATE:
            irpMajorString = "IRP_MJ_CREATE";
            break;
        case IRP_MJ_CREATE_NAMED_PIPE:
            irpMajorString = "IRP_MJ_CREATE_NAMED_PIPE";
            break;
        case IRP_MJ_CLOSE:
            irpMajorString = "IRP_MJ_CLOSE";
            break;
        case IRP_MJ_READ:
            irpMajorString = "IRP_MJ_READ";
            switch (MinorCode) {
                case IRP_MN_NORMAL:
                    irpMinorString = "IRP_MN_NORMAL";
                    break;
                case IRP_MN_DPC:
                    irpMinorString = "IRP_MN_DPC";
                    break;
                case IRP_MN_MDL:
                    irpMinorString = "IRP_MN_MDL";
                    break;
                case IRP_MN_COMPLETE:
                    irpMinorString = "IRP_MN_COMPLETE";
                    break;
                case IRP_MN_COMPRESSED:
                    irpMinorString = "IRP_MN_COMPRESSED";
                    break;
                case IRP_MN_MDL_DPC:
                    irpMinorString = "IRP_MN_MDL_DPC";
                    break;
                case IRP_MN_COMPLETE_MDL:
                    irpMinorString = "IRP_MN_COMPLETE_MDL";
                    break;
                case IRP_MN_COMPLETE_MDL_DPC:
                    irpMinorString = "IRP_MN_COMPLETE_MDL_DPC";
                    break;
                default:
                    sprintf( nameBuf, UnknownIrpMinor, MinorCode );
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_WRITE:
            irpMajorString = "IRP_MJ_WRITE";
            switch (MinorCode) {
                case IRP_MN_NORMAL:
                    irpMinorString = "IRP_MN_NORMAL";
                    break;
                case IRP_MN_DPC:
                    irpMinorString = "IRP_MN_DPC";
                    break;
                case IRP_MN_MDL:
                    irpMinorString = "IRP_MN_MDL";
                    break;
                case IRP_MN_COMPLETE:
                    irpMinorString = "IRP_MN_COMPLETE";
                    break;
                case IRP_MN_COMPRESSED:
                    irpMinorString = "IRP_MN_COMPRESSED";
                    break;
                case IRP_MN_MDL_DPC:
                    irpMinorString = "IRP_MN_MDL_DPC";
                    break;
                case IRP_MN_COMPLETE_MDL:
                    irpMinorString = "IRP_MN_COMPLETE_MDL";
                    break;
                case IRP_MN_COMPLETE_MDL_DPC:
                    irpMinorString = "IRP_MN_COMPLETE_MDL_DPC";
                    break;
                default:
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_QUERY_INFORMATION:
            irpMajorString = "IRP_MJ_QUERY_INFORMATION";
            break;
        case IRP_MJ_SET_INFORMATION:
            irpMajorString = "IRP_MJ_SET_INFORMATION";
            break;
        case IRP_MJ_QUERY_EA:
            irpMajorString = "IRP_MJ_QUERY_EA";
            break;
        case IRP_MJ_SET_EA:
            irpMajorString = "IRP_MJ_SET_EA";
            break;
        case IRP_MJ_FLUSH_BUFFERS:
            irpMajorString = "IRP_MJ_FLUSH_BUFFERS";
            break;
        case IRP_MJ_QUERY_VOLUME_INFORMATION:
            irpMajorString = "IRP_MJ_QUERY_VOLUME_INFORMATION";
            break;
        case IRP_MJ_SET_VOLUME_INFORMATION:
            irpMajorString = "IRP_MJ_SET_VOLUME_INFORMATION";
            break;
        case IRP_MJ_DIRECTORY_CONTROL:
            irpMajorString = "IRP_MJ_DIRECTORY_CONTROL";
            switch (MinorCode) {
                case IRP_MN_QUERY_DIRECTORY:
                    irpMinorString = "IRP_MN_QUERY_DIRECTORY";
                    break;
                case IRP_MN_NOTIFY_CHANGE_DIRECTORY:
                    irpMinorString = "IRP_MN_NOTIFY_CHANGE_DIRECTORY";
                    break;
                default:
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_FILE_SYSTEM_CONTROL:
            irpMajorString = "IRP_MJ_FILE_SYSTEM_CONTROL";
            switch (MinorCode) {
                case IRP_MN_USER_FS_REQUEST:
                    switch (FsctlCode) {
                        case FSCTL_REQUEST_OPLOCK_LEVEL_1:
                            irpMinorString = "FSCTL_REQUEST_OPLOCK_LEVEL_1";
                            break;
                        case FSCTL_REQUEST_OPLOCK_LEVEL_2:
                            irpMinorString = "FSCTL_REQUEST_OPLOCK_LEVEL_2";
                            break;
                        case FSCTL_REQUEST_BATCH_OPLOCK:
                            irpMinorString = "FSCTL_REQUEST_BATCH_OPLOCK";
                            break;
                        case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
                            irpMinorString = "FSCTL_OPLOCK_BREAK_ACKNOWLEDGE";
                            break;
                        case FSCTL_OPBATCH_ACK_CLOSE_PENDING:
                            irpMinorString = "FSCTL_OPBATCH_ACK_CLOSE_PENDING";
                            break;
                        case FSCTL_OPLOCK_BREAK_NOTIFY:
                            irpMinorString = "FSCTL_OPLOCK_BREAK_NOTIFY";
                            break;
                        case FSCTL_LOCK_VOLUME:
                            irpMinorString = "FSCTL_LOCK_VOLUME";
                            break;
                        case FSCTL_UNLOCK_VOLUME:
                            irpMinorString = "FSCTL_UNLOCK_VOLUME";
                            break;
                        case FSCTL_DISMOUNT_VOLUME:
                            irpMinorString = "FSCTL_DISMOUNT_VOLUME";
                            break;
                        case FSCTL_IS_VOLUME_MOUNTED:
                            irpMinorString = "FSCTL_IS_VOLUME_MOUNTED";
                            break;
                        case FSCTL_IS_PATHNAME_VALID:
                            irpMinorString = "FSCTL_IS_PATHNAME_VALID";
                            break;
                        case FSCTL_MARK_VOLUME_DIRTY:
                            irpMinorString = "FSCTL_MARK_VOLUME_DIRTY";
                            break;
                        case FSCTL_QUERY_RETRIEVAL_POINTERS:
                            irpMinorString = "FSCTL_QUERY_RETRIEVAL_POINTERS";
                            break;
                        case FSCTL_GET_COMPRESSION:
                            irpMinorString = "FSCTL_GET_COMPRESSION";
                            break;
                        case FSCTL_SET_COMPRESSION:
                            irpMinorString = "FSCTL_SET_COMPRESSION";
                            break;
                        case FSCTL_MARK_AS_SYSTEM_HIVE:
                            irpMinorString = "FSCTL_MARK_AS_SYSTEM_HIVE";
                            break;
                        case FSCTL_OPLOCK_BREAK_ACK_NO_2:
                            irpMinorString = "FSCTL_OPLOCK_BREAK_ACK_NO_2";
                            break;
                        case FSCTL_INVALIDATE_VOLUMES:
                            irpMinorString = "FSCTL_INVALIDATE_VOLUMES";
                            break;
                        case FSCTL_QUERY_FAT_BPB:
                            irpMinorString = "FSCTL_QUERY_FAT_BPB";
                            break;
                        case FSCTL_REQUEST_FILTER_OPLOCK:
                            irpMinorString = "FSCTL_REQUEST_FILTER_OPLOCK";
                            break;
                        case FSCTL_FILESYSTEM_GET_STATISTICS:
                            irpMinorString = "FSCTL_FILESYSTEM_GET_STATISTICS";
                            break;
                        case FSCTL_GET_NTFS_VOLUME_DATA:
                            irpMinorString = "FSCTL_GET_NTFS_VOLUME_DATA";
                            break;
                        case FSCTL_GET_NTFS_FILE_RECORD:
                            irpMinorString = "FSCTL_GET_NTFS_FILE_RECORD";
                            break;
                        case FSCTL_GET_VOLUME_BITMAP:
                            irpMinorString = "FSCTL_GET_VOLUME_BITMAP";
                            break;
                        case FSCTL_GET_RETRIEVAL_POINTERS:
                            irpMinorString = "FSCTL_GET_RETRIEVAL_POINTERS";
                            break;
                        case FSCTL_MOVE_FILE:
                            irpMinorString = "FSCTL_MOVE_FILE";
                            break;
                        case FSCTL_IS_VOLUME_DIRTY:
                            irpMinorString = "FSCTL_IS_VOLUME_DIRTY";
                            break;
                        case FSCTL_ALLOW_EXTENDED_DASD_IO:
                            irpMinorString = "FSCTL_ALLOW_EXTENDED_DASD_IO";
                            break;
                        case FSCTL_FIND_FILES_BY_SID:
                            irpMinorString = "FSCTL_FIND_FILES_BY_SID";
                            break;
                        case FSCTL_SET_OBJECT_ID:
                            irpMinorString = "FSCTL_SET_OBJECT_ID";
                            break;
                        case FSCTL_GET_OBJECT_ID:
                            irpMinorString = "FSCTL_GET_OBJECT_ID";
                            break;
                        case FSCTL_DELETE_OBJECT_ID:
                            irpMinorString = "FSCTL_DELETE_OBJECT_ID";
                            break;
                        case FSCTL_SET_REPARSE_POINT:
                            irpMinorString = "FSCTL_SET_REPARSE_POINT";
                            break;
                        case FSCTL_GET_REPARSE_POINT:
                            irpMinorString = "FSCTL_GET_REPARSE_POINT";
                            break;
                        case FSCTL_DELETE_REPARSE_POINT:
                            irpMinorString = "FSCTL_DELETE_REPARSE_POINT";
                            break;
                        case FSCTL_ENUM_USN_DATA:
                            irpMinorString = "FSCTL_ENUM_USN_DATA";
                            break;
                        case FSCTL_SECURITY_ID_CHECK:
                            irpMinorString = "FSCTL_SECURITY_ID_CHECK";
                            break;
                        case FSCTL_READ_USN_JOURNAL:
                            irpMinorString = "FSCTL_READ_USN_JOURNAL";
                            break;
                        case FSCTL_SET_OBJECT_ID_EXTENDED:
                            irpMinorString = "FSCTL_SET_OBJECT_ID_EXTENDED";
                            break;
                        case FSCTL_CREATE_OR_GET_OBJECT_ID:
                            irpMinorString = "FSCTL_CREATE_OR_GET_OBJECT_ID";
                            break;
                        case FSCTL_SET_SPARSE:
                            irpMinorString = "FSCTL_SET_SPARSE";
                            break;
                        case FSCTL_SET_ZERO_DATA:
                            irpMinorString = "FSCTL_SET_ZERO_DATA";
                            break;
                        case FSCTL_QUERY_ALLOCATED_RANGES:
                            irpMinorString = "FSCTL_QUERY_ALLOCATED_RANGES";
                            break;
                        case FSCTL_SET_ENCRYPTION:
                            irpMinorString = "FSCTL_SET_ENCRYPTION";
                            break;
                        case FSCTL_ENCRYPTION_FSCTL_IO:
                            irpMinorString = "FSCTL_ENCRYPTION_FSCTL_IO";
                            break;
                        case FSCTL_WRITE_RAW_ENCRYPTED:
                            irpMinorString = "FSCTL_WRITE_RAW_ENCRYPTED";
                            break;
                        case FSCTL_READ_RAW_ENCRYPTED:
                            irpMinorString = "FSCTL_READ_RAW_ENCRYPTED";
                            break;
                        case FSCTL_CREATE_USN_JOURNAL:
                            irpMinorString = "FSCTL_CREATE_USN_JOURNAL";
                            break;
                        case FSCTL_READ_FILE_USN_DATA:
                            irpMinorString = "FSCTL_READ_FILE_USN_DATA";
                            break;
                        case FSCTL_WRITE_USN_CLOSE_RECORD:
                            irpMinorString = "FSCTL_WRITE_USN_CLOSE_RECORD";
                            break;
                        case FSCTL_EXTEND_VOLUME:
                            irpMinorString = "FSCTL_EXTEND_VOLUME";
                            break;
                        case FSCTL_QUERY_USN_JOURNAL:
                            irpMinorString = "FSCTL_QUERY_USN_JOURNAL";
                            break;
                        case FSCTL_DELETE_USN_JOURNAL:
                            irpMinorString = "FSCTL_DELETE_USN_JOURNAL";
                            break;
                        case FSCTL_MARK_HANDLE:
                            irpMinorString = "FSCTL_MARK_HANDLE";
                            break;
                        case FSCTL_SIS_COPYFILE:
                            irpMinorString = "FSCTL_SIS_COPYFILE";
                            break;
                        case FSCTL_SIS_LINK_FILES:
                            irpMinorString = "FSCTL_SIS_LINK_FILES";
                            break;
                        case FSCTL_HSM_MSG:
                            irpMinorString = "FSCTL_HSM_MSG";
                            break;
                        case FSCTL_HSM_DATA:
                            irpMinorString = "FSCTL_HSM_DATA";
                            break;
                        case FSCTL_RECALL_FILE:
                            irpMinorString = "FSCTL_RECALL_FILE";
                            break;
                        case FSCTL_READ_FROM_PLEX:
                            irpMinorString = "FSCTL_READ_FROM_PLEX";
                            break;
                        case FSCTL_FILE_PREFETCH:
                            irpMinorString = "FSCTL_FILE_PREFETCH";
                            break;
                        default:
                            sprintf(nameBuf,"Unknown FSCTL (%u)",MinorCode);
                            irpMinorString = nameBuf;
                            break;
                    }

                    sprintf(nameBuf,"%s (USER)",irpMinorString);
                    irpMinorString = nameBuf;
                    break;

                case IRP_MN_MOUNT_VOLUME:
                    irpMinorString = "IRP_MN_MOUNT_VOLUME";
                    break;
                case IRP_MN_VERIFY_VOLUME:
                    irpMinorString = "IRP_MN_VERIFY_VOLUME";
                    break;
                case IRP_MN_LOAD_FILE_SYSTEM:
                    irpMinorString = "IRP_MN_LOAD_FILE_SYSTEM";
                    break;
                case IRP_MN_TRACK_LINK:
                    irpMinorString = "IRP_MN_TRACK_LINK";
                    break;
                default:
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_DEVICE_CONTROL:
            irpMajorString = "IRP_MJ_DEVICE_CONTROL";
            switch (MinorCode) {
                case 0:
                    irpMinorString = "User request";
                    break;
                case IRP_MN_SCSI_CLASS:
                    irpMinorString = "IRP_MN_SCSI_CLASS";
                    break;
                default:
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_INTERNAL_DEVICE_CONTROL:
            irpMajorString = "IRP_MJ_INTERNAL_DEVICE_CONTROL";
            break;
        case IRP_MJ_SHUTDOWN:
            irpMajorString = "IRP_MJ_SHUTDOWN";
            break;
        case IRP_MJ_LOCK_CONTROL:
            irpMajorString = "IRP_MJ_LOCK_CONTROL";
            switch (MinorCode) {
                case IRP_MN_LOCK:
                    irpMinorString = "IRP_MN_LOCK";
                    break;
                case IRP_MN_UNLOCK_SINGLE:
                    irpMinorString = "IRP_MN_UNLOCK_SINGLE";
                    break;
                case IRP_MN_UNLOCK_ALL:
                    irpMinorString = "IRP_MN_UNLOCK_ALL";
                    break;
                case IRP_MN_UNLOCK_ALL_BY_KEY:
                    irpMinorString = "IRP_MN_UNLOCK_ALL_BY_KEY";
                    break;
                default:
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_CLEANUP:
            irpMajorString = "IRP_MJ_CLEANUP";
            break;
        case IRP_MJ_CREATE_MAILSLOT:
            irpMajorString = "IRP_MJ_CREATE_MAILSLOT";
            break;
        case IRP_MJ_QUERY_SECURITY:
            irpMajorString = "IRP_MJ_QUERY_SECURITY";
            break;
        case IRP_MJ_SET_SECURITY:
            irpMajorString = "IRP_MJ_SET_SECURITY";
            break;
        case IRP_MJ_POWER:
            irpMajorString = "IRP_MJ_POWER";
            switch (MinorCode) {
                case IRP_MN_WAIT_WAKE:
                    irpMinorString = "IRP_MN_WAIT_WAKE";
                    break;
                case IRP_MN_POWER_SEQUENCE:
                    irpMinorString = "IRP_MN_POWER_SEQUENCE";
                    break;
                case IRP_MN_SET_POWER:
                    irpMinorString = "IRP_MN_SET_POWER";
                    break;
                case IRP_MN_QUERY_POWER:
                    irpMinorString = "IRP_MN_QUERY_POWER";
                    break;
                default :
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_SYSTEM_CONTROL:
            irpMajorString = "IRP_MJ_SYSTEM_CONTROL";
            switch (MinorCode) {
                case IRP_MN_QUERY_ALL_DATA:
                    irpMinorString = "IRP_MN_QUERY_ALL_DATA";
                    break;
                case IRP_MN_QUERY_SINGLE_INSTANCE:
                    irpMinorString = "IRP_MN_QUERY_SINGLE_INSTANCE";
                    break;
                case IRP_MN_CHANGE_SINGLE_INSTANCE:
                    irpMinorString = "IRP_MN_CHANGE_SINGLE_INSTANCE";
                    break;
                case IRP_MN_CHANGE_SINGLE_ITEM:
                    irpMinorString = "IRP_MN_CHANGE_SINGLE_ITEM";
                    break;
                case IRP_MN_ENABLE_EVENTS:
                    irpMinorString = "IRP_MN_ENABLE_EVENTS";
                    break;
                case IRP_MN_DISABLE_EVENTS:
                    irpMinorString = "IRP_MN_DISABLE_EVENTS";
                    break;
                case IRP_MN_ENABLE_COLLECTION:
                    irpMinorString = "IRP_MN_ENABLE_COLLECTION";
                    break;
                case IRP_MN_DISABLE_COLLECTION:
                    irpMinorString = "IRP_MN_DISABLE_COLLECTION";
                    break;
                case IRP_MN_REGINFO:
                    irpMinorString = "IRP_MN_REGINFO";
                    break;
                case IRP_MN_EXECUTE_METHOD:
                    irpMinorString = "IRP_MN_EXECUTE_METHOD";
                    break;
                default :
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_DEVICE_CHANGE:
            irpMajorString = "IRP_MJ_DEVICE_CHANGE";
            break;
        case IRP_MJ_QUERY_QUOTA:
            irpMajorString = "IRP_MJ_QUERY_QUOTA";
            break;
        case IRP_MJ_SET_QUOTA:
            irpMajorString = "IRP_MJ_SET_QUOTA";
            break;
        case IRP_MJ_PNP:
            irpMajorString = "IRP_MJ_PNP";
            switch (MinorCode) {
                case IRP_MN_START_DEVICE:
                    irpMinorString = "IRP_MN_START_DEVICE";
                    break;
                case IRP_MN_QUERY_REMOVE_DEVICE:
                    irpMinorString = "IRP_MN_QUERY_REMOVE_DEVICE";
                    break;
                case IRP_MN_REMOVE_DEVICE:
                    irpMinorString = "IRP_MN_REMOVE_DEVICE";
                    break;
                case IRP_MN_CANCEL_REMOVE_DEVICE:
                    irpMinorString = "IRP_MN_CANCEL_REMOVE_DEVICE";
                    break;
                case IRP_MN_STOP_DEVICE:
                    irpMinorString = "IRP_MN_STOP_DEVICE";
                    break;
                case IRP_MN_QUERY_STOP_DEVICE:
                    irpMinorString = "IRP_MN_QUERY_STOP_DEVICE";
                    break;
                case IRP_MN_CANCEL_STOP_DEVICE:
                    irpMinorString = "IRP_MN_CANCEL_STOP_DEVICE";
                    break;
                case IRP_MN_QUERY_DEVICE_RELATIONS:
                    irpMinorString = "IRP_MN_QUERY_DEVICE_RELATIONS";
                    break;
                case IRP_MN_QUERY_INTERFACE:
                    irpMinorString = "IRP_MN_QUERY_INTERFACE";
                    break;
                case IRP_MN_QUERY_CAPABILITIES:
                    irpMinorString = "IRP_MN_QUERY_CAPABILITIES";
                    break;
                case IRP_MN_QUERY_RESOURCES:
                    irpMinorString = "IRP_MN_QUERY_RESOURCES";
                    break;
                case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
                    irpMinorString = "IRP_MN_QUERY_RESOURCE_REQUIREMENTS";
                    break;
                case IRP_MN_QUERY_DEVICE_TEXT:
                    irpMinorString = "IRP_MN_QUERY_DEVICE_TEXT";
                    break;
                case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
                    irpMinorString = "IRP_MN_FILTER_RESOURCE_REQUIREMENTS";
                    break;
                case IRP_MN_READ_CONFIG:
                    irpMinorString = "IRP_MN_READ_CONFIG";
                    break;
                case IRP_MN_WRITE_CONFIG:
                    irpMinorString = "IRP_MN_WRITE_CONFIG";
                    break;
                case IRP_MN_EJECT:
                    irpMinorString = "IRP_MN_EJECT";
                    break;
                case IRP_MN_SET_LOCK:
                    irpMinorString = "IRP_MN_SET_LOCK";
                    break;
                case IRP_MN_QUERY_ID:
                    irpMinorString = "IRP_MN_QUERY_ID";
                    break;
                case IRP_MN_QUERY_PNP_DEVICE_STATE:
                    irpMinorString = "IRP_MN_QUERY_PNP_DEVICE_STATE";
                    break;
                case IRP_MN_QUERY_BUS_INFORMATION:
                    irpMinorString = "IRP_MN_QUERY_BUS_INFORMATION";
                    break;
                case IRP_MN_DEVICE_USAGE_NOTIFICATION:
                    irpMinorString = "IRP_MN_DEVICE_USAGE_NOTIFICATION";
                    break;
                case IRP_MN_SURPRISE_REMOVAL:
                    irpMinorString = "IRP_MN_SURPRISE_REMOVAL";
                    break;
                case IRP_MN_QUERY_LEGACY_BUS_INFORMATION:
                    irpMinorString = "IRP_MN_QUERY_LEGACY_BUS_INFORMATION";
                    break;
                default :
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        default:
            sprintf(nameBuf,"Unknown Irp major code (%u)",MajorCode);
            irpMajorString = nameBuf;
    }

    strcpy(MajorCodeName,irpMajorString);
    strcpy(MinorCodeName,irpMinorString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\iotest\user\iotestlog.h ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    log.h

Abstract:

    This module contains the structures and prototypes used by the user 
    program to retrieve and see the log records recorded by filespy.sys.
    
// @@BEGIN_DDKSPLIT
Author:

    Molly Brown (MollyBro) 21-Apr-1999

// @@END_DDKSPLIT
Environment:

    User mode


// @@BEGIN_DDKSPLIT
Revision History:

// @@END_DDKSPLIT
--*/
#ifndef __IOTESTLOG_H__
#define __IOTESTLOG_H__

#include <stdio.h>
#include "ioTest.h"

#define BUFFER_SIZE     4096

typedef struct _LOG_CONTEXT{
    HANDLE  Device;
    BOOLEAN LogToScreen;
    BOOLEAN LogToFile;
    ULONG   VerbosityFlags;     //  FS_VF_DUMP_PARAMETERS, etc.
    FILE   *OutputFile;

    BOOLEAN NextLogToScreen;

    // For synchronizing shutting down of both threads
    BOOLEAN CleaningUp;
    HANDLE  ShutDown;
}LOG_CONTEXT, *PLOG_CONTEXT;

DWORD WINAPI 
RetrieveLogRecords(
    LPVOID lpParameter
);
                
VOID
IrpFileDump(
    IOTEST_DEVICE_TYPE DeviceType,
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_IRP RecordIrp,
    FILE *File,
    ULONG Verbosity
);

VOID
IrpScreenDump(
    IOTEST_DEVICE_TYPE DeviceType,
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_IRP RecordIrp,
    ULONG Verbosity
);

VOID
FastIoFileDump(
    IOTEST_DEVICE_TYPE DeviceType,
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FASTIO RecordFastIo,
    FILE *File
);

VOID
FastIoScreenDump(
    IOTEST_DEVICE_TYPE DeviceType,
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FASTIO RecordFastIo
);

VOID
FsFilterOperationFileDump (
    IOTEST_DEVICE_TYPE DeviceType,
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FS_FILTER_OPERATION RecordFsFilterOp,
    FILE *File
);

VOID
FsFilterOperationScreenDump (
    IOTEST_DEVICE_TYPE DeviceType,
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FS_FILTER_OPERATION RecordFsFilterOp
);

#define IRP_NOCACHE                     0x00000001
#define IRP_PAGING_IO                   0x00000002
#define IRP_SYNCHRONOUS_API             0x00000004
#define IRP_SYNCHRONOUS_PAGING_IO       0x00000040

#define FS_FILTER_ACQUIRE_FOR_SECTION_SYNCHRONIZATION    (UCHAR)-1
#define FS_FILTER_RELEASE_FOR_SECTION_SYNCHRONIZATION    (UCHAR)-2
#define FS_FILTER_ACQUIRE_FOR_MOD_WRITE                  (UCHAR)-3
#define FS_FILTER_RELEASE_FOR_MOD_WRITE                  (UCHAR)-4
#define FS_FILTER_ACQUIRE_FOR_CC_FLUSH                   (UCHAR)-5
#define FS_FILTER_RELEASE_FOR_CC_FLUSH                   (UCHAR)-6

//
//  Verbosity flags.
//

#define FS_VF_DUMP_PARAMETERS           0x00000001

VOID
DisplayError (
   DWORD Code
   );

VOID
ReadTest (
    PLOG_CONTEXT Context,
    PWCHAR DriveName,
    ULONG  DriveNameLength,
    BOOLEAN TopOfStack
    );

VOID
RenameTest (
    PLOG_CONTEXT Context,
    PWCHAR DriveName,
    ULONG  DriveNameLength,
    BOOLEAN TopOfStack
    );

VOID
ShareTest (
    PLOG_CONTEXT Context,
    PWCHAR DriveName,
    ULONG  DriveNameLength,
    BOOLEAN TopOfStack
    );

DWORD WINAPI 
VerifyCurrentLogRecords (
    PLOG_CONTEXT Context,
    PEXPECTED_OPERATION ExpectedOps
);

#endif __IOTESTLOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\iotest\user\iotestlog.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    fspyLog.c

Abstract:

    This module contains functions used to retrieve and see the log records
    recorded by filespy.sys.

// @@BEGIN_DDKSPLIT
Author:

    Molly Brown (MollyBro) 21-Apr-1999

// @@END_DDKSPLIT

Environment:

    User mode


// @@BEGIN_DDKSPLIT
Revision History:

// @@END_DDKSPLIT
--*/
#include <stdio.h>
#include <windows.h>
#include <stdlib.h>
#include <winioctl.h>
#include "ioTestLog.h"
#include "ioTestLib.h"

#define TIME_BUFFER_LENGTH 20
#define TIME_ERROR         L"time error"

#define FlagOn(F,SF) ( \
    (((F) & (SF)))     \
)

VOID
DumpLogRecord (
    PLOG_RECORD pLogRecord,
    PLOG_CONTEXT context
    )
{
    PRECORD_IRP pRecordIrp;
    PRECORD_FASTIO pRecordFastIo;
    PRECORD_FS_FILTER_OPERATION pRecordFsFilterOp;
    ULONG nameLength;

    //
    //  Calculate the length of the name in the log record.
    //
    
    nameLength = pLogRecord->Length - SIZE_OF_LOG_RECORD;

    //
    // A LOG_RECORD could have Irp or FastIo data in it.  This
    // is denoted in the low-order byte of the RecordType flag.
    //

    switch (GET_RECORD_TYPE(pLogRecord)) {
    case RECORD_TYPE_IRP:

        //
        // We've got an Irp record, so output this data correctly.
        //
        pRecordIrp = &(pLogRecord->Record.RecordIrp);

        if (context->LogToScreen) {

            IrpScreenDump( pLogRecord->DeviceType,
                           pLogRecord->SequenceNumber,
                           pLogRecord->Name,
                           nameLength,
                           pRecordIrp,
                           context->VerbosityFlags);
        }

        if (context->LogToFile) {

            IrpFileDump( pLogRecord->DeviceType,
                         pLogRecord->SequenceNumber,
                         pLogRecord->Name,
                         nameLength,
                         pRecordIrp, 
                         context->OutputFile,
                         context->VerbosityFlags);
        }
        break;

    case RECORD_TYPE_FASTIO:

        //
        // We've got a FastIo record, so output this data correctly.
        //

        pRecordFastIo = &(pLogRecord->Record.RecordFastIo);

        if (context->LogToScreen) {

            FastIoScreenDump( pLogRecord->DeviceType,
                              pLogRecord->SequenceNumber,
                              pLogRecord->Name,
                              nameLength,
                              pRecordFastIo);
        }

        if (context->LogToFile) {

            FastIoFileDump( pLogRecord->DeviceType,
                            pLogRecord->SequenceNumber,
                            pLogRecord->Name,
                            nameLength,
                            pRecordFastIo,
                            context->OutputFile);
        }
        break;

    case RECORD_TYPE_FS_FILTER_OP:

        //
        //  We've got a FsFilter operation record, so output this
        //  data correctly.
        //

        pRecordFsFilterOp = &(pLogRecord->Record.RecordFsFilterOp);

        if (context->LogToScreen) {

            FsFilterOperationScreenDump( pLogRecord->DeviceType,
                                         pLogRecord->SequenceNumber,
                                         pLogRecord->Name,
                                         nameLength,
                                         pRecordFsFilterOp );

        }

        if (context->LogToFile) {

            FsFilterOperationFileDump( pLogRecord->DeviceType,
                                       pLogRecord->SequenceNumber,
                                       pLogRecord->Name,
                                       nameLength,
                                       pRecordFsFilterOp,
                                       context->OutputFile );
        }
        break;
        
    default:

        printf("Filmon:  Unknown log record type\n");
    }

    //
    // The RecordType could also designate that we are out of memory
    // or hit our program defined memory limit, so check for these
    // cases.
    // 

    if (pLogRecord->RecordType & RECORD_TYPE_OUT_OF_MEMORY) {

        if (context->LogToScreen) {

            printf("M %08X SYSTEM OUT OF MEMORY\n", pLogRecord->SequenceNumber);
        }

        if (context->LogToFile) {

            fprintf(context->OutputFile, "M:\t%u", pLogRecord->SequenceNumber);
        }

    } else if (pLogRecord->RecordType & RECORD_TYPE_EXCEED_MEMORY_ALLOWANCE) {

        if (context->LogToScreen) {

            printf("M %08X EXCEEDED MEMORY ALLOWANCE\n", pLogRecord->SequenceNumber);
        }

        if (context->LogToFile) {

            fprintf(context->OutputFile, "M:\t%u", pLogRecord->SequenceNumber);
        }
    }

}

DWORD WINAPI 
VerifyCurrentLogRecords (
    PLOG_CONTEXT Context,
    PEXPECTED_OPERATION ExpectedOps
)
{
    CHAR buffer[BUFFER_SIZE];
    DWORD bytesReturned = 0;
    BOOL bResult;
    DWORD result;
    PLOG_RECORD pLogRecord;
    BOOL askForMore = TRUE;
    BOOL testPassed = FALSE;
    ULONG currentOp = 0;
#ifdef USE_DO_HINT    
    BOOL keepVerifying = TRUE;
#else
    BOOL seenFirstOp = FALSE;
#endif /* USE_DO_HINT */

    while (askForMore) {

        //
        // Check to see if we should shut down
        //

        if (Context->CleaningUp) {

            break;
        }

        //
        // Request log data from filespy
        //

        bResult = DeviceIoControl( Context->Device,
                                   IOTEST_GetLog,
                                   NULL,
                                   0,
                                   buffer,
                                   BUFFER_SIZE,
                                   &bytesReturned,
                                   NULL);

        if (!bResult) {

            result = GetLastError();
            printf("ERROR controlling device: 0x%x\n", result);
        }

        //
        // Buffer is filled with a series of LOG_RECORD structures, one
        // right after another.  Each LOG_RECORD says how long it is, so
        // we know where the next LOG_RECORD begins.
        //

        pLogRecord = (PLOG_RECORD) buffer;

        //
        // Logic to write record to screen and/or file
        //

        while ((BYTE *) pLogRecord < buffer + bytesReturned) {

            PRECORD_IRP pRecordIrp;

            DumpLogRecord( pLogRecord, Context );

            switch (GET_RECORD_TYPE(pLogRecord)) {
            case RECORD_TYPE_IRP:
                
                pRecordIrp = &(pLogRecord->Record.RecordIrp);

#ifdef USE_DO_HINT
                if (keepVerifying) {

                    if (pRecordIrp->IrpMajor == ExpectedOps[currentOp].Op) {
                        if(pLogRecord->DeviceType != ExpectedOps[currentOp].Device) {

                            keepVerifying = FALSE;
                            
                        } else {

                            currentOp ++;
                        }
                    }
                }

#else

                //
                //  If we are not using the DeviceObject hint, we expect to
                //  see log entries from both the TOP and BOTTOM filters 
                //  for each expected operation.  So that we don't have to 
                //  redefine the ExpectedOperation array, just ignore the
                //  device in the array and check to make sure that you see
                //  a log record for the TOP_FILTER then the BOTTOM_FILTER for
                //  each operation in the array.
                //
                
                if (!seenFirstOp) {
                    
                    if ((pLogRecord->DeviceType == TOP_FILTER) &&
                        (pRecordIrp->IrpMajor == ExpectedOps[currentOp].Op)) {

                        seenFirstOp = TRUE;
                    }
                    
                } else {
                
                    if ((pLogRecord->DeviceType == BOTTOM_FILTER) &&
                        (pRecordIrp->IrpMajor == ExpectedOps[currentOp].Op)) {

                        seenFirstOp = FALSE;
                        currentOp ++;
                    }
                }
#endif /* USE_DO_HINT */                

                break;

            default:
    
                //
                //  ignore
                //
                ;
            }

            //
            // Move to next LOG_RECORD
            //

            pLogRecord = (PLOG_RECORD) (((BYTE *) pLogRecord) + pLogRecord->Length);
        }

        if (bytesReturned == 0) {

            askForMore = FALSE;
        }
    }

    if (ExpectedOps[currentOp].Op == IRP_MJ_MAXIMUM_FUNCTION + 1) {

        testPassed = TRUE;
    }

    if (testPassed) {

        printf( "User log verification:\tPASSED - Expected operations seen.\n" );

    } else {

        printf( "User log verification:\tFAILED - Expected operations NOT seen.\n" );
    }

    return testPassed;
}

DWORD WINAPI 
RetrieveLogRecords (
    LPVOID lpParameter
)
{
    PLOG_CONTEXT context = (PLOG_CONTEXT)lpParameter;
    CHAR buffer[BUFFER_SIZE];
    DWORD bytesReturned = 0;
    BOOL bResult;
    DWORD result;
    PLOG_RECORD pLogRecord;

    printf("Log: Starting up\n");

    while (TRUE) {

        //
        // Check to see if we should shut down
        //

        if (context->CleaningUp) {

            break;
        }

        //
        // Request log data from filespy
        //

        bResult = DeviceIoControl( context->Device,
                                   IOTEST_GetLog,
                                   NULL,
                                   0,
                                   buffer,
                                   BUFFER_SIZE,
                                   &bytesReturned,
                                   NULL);

        if (!bResult) {

            result = GetLastError();
            printf("ERROR controlling device: 0x%x\n", result);
        }

        //
        // Buffer is filled with a series of LOG_RECORD structures, one
        // right after another.  Each LOG_RECORD says how long it is, so
        // we know where the next LOG_RECORD begins.
        //

        pLogRecord = (PLOG_RECORD) buffer;

        //
        // Logic to write record to screen and/or file
        //

        while ((BYTE *) pLogRecord < buffer + bytesReturned) {


            DumpLogRecord( pLogRecord, context );

            //
            // Move to next LOG_RECORD
            //

            pLogRecord = (PLOG_RECORD) (((BYTE *) pLogRecord) + pLogRecord->Length);
        }

        if (bytesReturned == 0) {

            Sleep( 500 );
        }
    }

    printf("Log: Shutting down\n");
    ReleaseSemaphore(context->ShutDown, 1, NULL);
    printf("Log: All done\n");
    return 0;
}

VOID
PrintIrpCode (
    UCHAR MajorCode,
    UCHAR MinorCode,
    ULONG FsControlCode,
    FILE *OutputFile,
    BOOLEAN PrintMajorCode
    )
{
    CHAR irpMajorString[OPERATION_NAME_BUFFER_SIZE];
    CHAR irpMinorString[OPERATION_NAME_BUFFER_SIZE];
    CHAR formatBuf[OPERATION_NAME_BUFFER_SIZE*2];


    GetIrpName(MajorCode,MinorCode,FsControlCode,irpMajorString,irpMinorString);

    if (OutputFile) {

        sprintf(formatBuf, "%s  %s", irpMajorString, irpMinorString);
        fprintf(OutputFile, "\t%-50s", formatBuf);

    } else {

        if (PrintMajorCode) {

            printf("%-31s ", irpMajorString);

        } else {

            if (irpMinorString[0] != 0) {

                printf("                                         %-35s\n",
                        irpMinorString);
            }
        }
    }
}

VOID
PrintFastIoType (
    FASTIO_TYPE Code,
    FILE *OutputFile
    )
{
    CHAR outputString[OPERATION_NAME_BUFFER_SIZE];

    GetFastioName(Code,outputString);

    if (OutputFile) {

        fprintf(OutputFile, "%-50s", outputString);

    } else {

        printf("%-31s ", outputString);
    }
}

VOID
PrintFsFilterOperation (
    UCHAR Operation,
    FILE *OutputFile
    )
{
    CHAR outputString[OPERATION_NAME_BUFFER_SIZE];

    GetFsFilterOperationName(Operation,outputString);

    if (OutputFile) {
    
        fprintf( OutputFile, "%-50s", outputString );
        
    } else {

        printf( "%-31s ", outputString );
    }
}

ULONG
FormatSystemTime (
    SYSTEMTIME *SystemTime,
    PWCHAR Buffer,
    ULONG BufferLength
)
/*++
Routine Name:

    FormatSystemTime

Routine Description:

    Formats the values in a SystemTime struct into the buffer
    passed in.  The resulting string is NULL terminated.  The format
    for the time is:
        hours:minutes:seconds:milliseconds

Arguments:

    SystemTime - the struct to format
    Buffer - the buffer to place the formatted time in
    BufferLength - the size of the buffer in characters

Return Value:

    The number of characters returned in Buffer.

--*/
{
    PWCHAR writePosition;
    ULONG returnLength = 0;

    writePosition = Buffer;

    if (BufferLength < TIME_BUFFER_LENGTH) {

        //
        // Buffer is too short so exit
        //

        return 0;
    }

    returnLength = swprintf( Buffer,
                             L"%02d:%02d:%02d:%03d",
                             SystemTime->wHour,
                             SystemTime->wMinute,
                             SystemTime->wSecond,
                             SystemTime->wMilliseconds);

    return returnLength;
}

VOID
IrpFileDump (
    IOTEST_DEVICE_TYPE DeviceType,
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_IRP RecordIrp,
    FILE *File,
    ULONG VerbosityFlags
)
/*++
Routine Name:

    IrpFileDump

Routine Description:

    Prints a Irp log record to the specified file.  The output is in a tab
    delimited format with the fields in the following order:

    SequenceNumber, OriginatingTime, CompletionTime, IrpMajor, IrpMinor,
    IrpFlags, NoCache, Paging I/O, Synchronous, Synchronous paging, FileName,
    ReturnStatus, FileName


Arguments:

    SequenceNumber - the sequence number for this log record
    Name - the name of the file that this Irp relates to
    NameLength - the length of Name in bytes
    RecordIrp - the Irp record to print
    File - the file to print to

Return Value:

    None.

--*/
{
    FILETIME    localTime;
    SYSTEMTIME  systemTime;
    WCHAR       time[TIME_BUFFER_LENGTH];

    switch (DeviceType) {
    case TOP_FILTER:
        fprintf(File, "TOP\tI\t%08X", SequenceNumber);
        break;
    case BOTTOM_FILTER:
        fprintf(File, "BOT\tI\t%08X", SequenceNumber);
        break;
    default:
        fprintf(File, "UNK\tI\t%08X", SequenceNumber);
        break;       
    }

    //
    // Convert originating time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordIrp->OriginatingTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        fprintf( File, "\t%-12S", time );

    } else {

        fprintf( File, "\t%-12S", TIME_ERROR );
    }

    fprintf( File, "\t%8x.%-4x ", RecordIrp->ProcessId, RecordIrp->ThreadId );

    PrintIrpCode( RecordIrp->IrpMajor, RecordIrp->IrpMinor, (ULONG)(ULONG_PTR)RecordIrp->Argument3, File, TRUE );

    fprintf( File, "\t%08p", RecordIrp->FileObject );

    //
    // Interpret set flags
    //

    fprintf( File, "\t%08lx ", RecordIrp->IrpFlags );
    fprintf( File, "%s", (RecordIrp->IrpFlags & IRP_NOCACHE) ? "N":"-" );
    fprintf( File, "%s", (RecordIrp->IrpFlags & IRP_PAGING_IO) ? "P":"-" );
    fprintf( File, "%s", (RecordIrp->IrpFlags & IRP_SYNCHRONOUS_API) ? "S":"-" );
    fprintf( File, "%s", (RecordIrp->IrpFlags & IRP_SYNCHRONOUS_PAGING_IO) ? "Y":"-" );

    if (FlagOn( VerbosityFlags, FS_VF_DUMP_PARAMETERS )) {

        fprintf( File,
                 "%p %p %p %p ", 
                 RecordIrp->Argument1,
                 RecordIrp->Argument2,
                 RecordIrp->Argument3,
                 RecordIrp->Argument4 );
        
        if (IRP_MJ_CREATE == RecordIrp->IrpMajor) {

            fprintf( File, "DesiredAccess->%08lx ", RecordIrp->DesiredAccess );
        }
    }

    fprintf( File, "\t%.*S", NameLength/sizeof(WCHAR), Name );
    fprintf( File, "\n" );
}

VOID
IrpScreenDump (
    IOTEST_DEVICE_TYPE DeviceType,
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_IRP RecordIrp,
    ULONG VerbosityFlags
)
/*++
Routine Name:

    IrpScreenDump

Routine Description:

    Prints a Irp log record to the screen in the following order:
    SequenceNumber, OriginatingTime, CompletionTime, IrpMajor, IrpMinor,
    IrpFlags, NoCache, Paging I/O, Synchronous, Synchronous paging,
    FileName, ReturnStatus, FileName

Arguments:

    SequenceNumber - the sequence number for this log record
    Name - the file name to which this Irp relates
    NameLength - the length of Name in bytes
    RecordIrp - the Irp record to print

Return Value:

    None.

--*/
{
    FILETIME localTime;
    SYSTEMTIME systemTime;
    WCHAR time[TIME_BUFFER_LENGTH];

    switch (DeviceType) {
    case TOP_FILTER:
        printf("TOP I %08X", SequenceNumber);
        break;
    case BOTTOM_FILTER:
        printf("BOT I %08X", SequenceNumber);
        break;
    default:
        printf("UNK I %08X", SequenceNumber);
        break;       
    }

    //
    // Convert originating time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordIrp->OriginatingTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        printf( "%-12S ", time );

    } else {

        printf( "%-12S ", TIME_ERROR );
    }

    printf( "%8x.%-4x ", RecordIrp->ProcessId, RecordIrp->ThreadId );

    PrintIrpCode( RecordIrp->IrpMajor, RecordIrp->IrpMinor, (ULONG)(ULONG_PTR)RecordIrp->Argument3, NULL, TRUE );

    printf( "%08p ", RecordIrp->FileObject );

    //
    // Interpret set flags
    //

    printf( "%08lx ", RecordIrp->IrpFlags );
    printf( "%s", (RecordIrp->IrpFlags & IRP_NOCACHE) ? "N":"-" );
    printf( "%s", (RecordIrp->IrpFlags & IRP_PAGING_IO) ? "P":"-" );
    printf( "%s", (RecordIrp->IrpFlags & IRP_SYNCHRONOUS_API) ? "S":"-" );
    printf( "%s ", (RecordIrp->IrpFlags & IRP_SYNCHRONOUS_PAGING_IO) ? "Y":"-" );

    if (FlagOn( VerbosityFlags, FS_VF_DUMP_PARAMETERS )) {

        printf( "%p %p %p %p  ", 
                RecordIrp->Argument1,
                RecordIrp->Argument2,
                RecordIrp->Argument3,
                RecordIrp->Argument4 );
        
        if (IRP_MJ_CREATE == RecordIrp->IrpMajor) {

            printf( "DesiredAccess->%08lx ", RecordIrp->DesiredAccess );
        }
    }

    printf( "%.*S", NameLength/sizeof(WCHAR), Name );
    printf( "\n" );
    PrintIrpCode( RecordIrp->IrpMajor, RecordIrp->IrpMinor, (ULONG)(ULONG_PTR)RecordIrp->Argument3, NULL, FALSE );
}

VOID
FastIoFileDump (
    IOTEST_DEVICE_TYPE DeviceType,
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FASTIO RecordFastIo,
    FILE *File
)
/*++
Routine Name:

    FastIoFileDump

Routine Description:

    Prints a FastIo log record to the specified file.  The output is in a tab
    delimited format with the fields in the following order:
    SequenceNumber, StartTime, CompletionTime, Fast I/O Type, FileName,
    Length, Wait, ReturnStatus, FileName

Arguments:

    SequenceNumber - the sequence number for this log record
    Name - the name of the file referenced by this Fast I/O operation
    NameLength - the length of name in bytes
    RecordFastIo - the FastIo record to print
    File - the file to print to

Return Value:

    None.

--*/
{
    SYSTEMTIME systemTime;
    FILETIME localTime;
    WCHAR time[TIME_BUFFER_LENGTH];

    switch (DeviceType) {
    case TOP_FILTER:
        fprintf(File, "TOP\tF\t%08X", SequenceNumber);
        break;
    case BOTTOM_FILTER:
        fprintf(File, "BOT\tF\t%08X", SequenceNumber);
        break;
    default:
        fprintf(File, "UNK\tF\t%08X", SequenceNumber);
        break;       
    }

    //
    // Convert start time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordFastIo->StartTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        fprintf( File, "\t%-12S", time );

    } else {

        fprintf( File, "\t%-12S", TIME_ERROR );
    }

    fprintf( File, "\t%8x.%-4x ", RecordFastIo->ProcessId, RecordFastIo->ThreadId );

    fprintf( File, "\t" );
    PrintFastIoType( RecordFastIo->Type, File );

    fprintf( File, "\t%08p", RecordFastIo->FileObject );

    fprintf( File, "\t%s", (RecordFastIo->Wait)?"T":"F" );
    fprintf( File, "\t%08x", RecordFastIo->Length );
    fprintf( File, "\t%016I64x ", RecordFastIo->FileOffset );

    fprintf( File, "\t%.*S", NameLength/sizeof(WCHAR), Name );
    fprintf( File, "\n" );
}

VOID
FastIoScreenDump (
    IOTEST_DEVICE_TYPE DeviceType,
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FASTIO RecordFastIo
)
/*++
Routine Name:

    FastIoScreenDump

Routine Description:

    Prints a FastIo log record to the screen in the following order:
    SequenceNumber, StartTime, CompletionTime, Fast I/O Type, FileName,
    Length, Wait, ReturnStatus, FileName

Arguments:

    SequenceNumber - the sequence number for this log record
    Name - the name of the file referenced by this Fast I/O operation
    NameLength - the length of name in bytes
    RecordIrp - the Irp record to print

Return Value:

    None.

--*/
{
    SYSTEMTIME systemTime;
    FILETIME localTime;
    WCHAR time[TIME_BUFFER_LENGTH];

    switch (DeviceType) {
    case TOP_FILTER:
        printf("TOP F %08X", SequenceNumber);
        break;
    case BOTTOM_FILTER:
        printf("BOT F %08X", SequenceNumber);
        break;
    default:
        printf("UNK F %08X", SequenceNumber);
        break;       
    }
    
    //
    // Convert start time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordFastIo->StartTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        printf( "%-12S ", time );

    } else {

        printf( "%-12S ", TIME_ERROR );
    }

    printf( "%8x.%-4x ", RecordFastIo->ProcessId, RecordFastIo->ThreadId );

    PrintFastIoType( RecordFastIo->Type, NULL );

    printf( "%08p ", RecordFastIo->FileObject );

    printf( "%s ", (RecordFastIo->Wait)?"T":"F" );
    printf( "%08x ", RecordFastIo->Length );
    printf( "%016I64x ", RecordFastIo->FileOffset );

    printf( "%.*S", NameLength/sizeof(WCHAR), Name );
    printf ("\n" );
}

VOID
FsFilterOperationFileDump (
    IOTEST_DEVICE_TYPE DeviceType,
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FS_FILTER_OPERATION RecordFsFilterOp,
    FILE *File
)
/*++
Routine Name:

    FsFilterOperationFileDump

Routine Description:

    Prints a FsFilterOperation log record to the specified file.  The output is in a tab
    delimited format with the fields in the following order:

    SequenceNumber, OriginatingTime, CompletionTime, ProcessId, ThreadId,
    Operation, FileObject, ReturnStatus, FileName

Arguments:

    SequenceNumber - the sequence number for this log record
    Name - the name of the file that this operation relates to
    NameLength - the length of Name in bytes
    RecordFsFilterOp - the FsFilter operation record to print
    File - the file to print to

Return Value:

    None.

--*/
{
    FILETIME    localTime;
    SYSTEMTIME  systemTime;
    WCHAR       time[TIME_BUFFER_LENGTH];

    switch (DeviceType) {
    case TOP_FILTER:
        fprintf(File, "TOP\tO\t%08X", SequenceNumber);
        break;
    case BOTTOM_FILTER:
        fprintf(File, "BOT\tO\t%08X", SequenceNumber);
        break;
    default:
        fprintf(File, "UNK\tO\t%08X", SequenceNumber);
        break;       
    }

    //
    // Convert originating time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordFsFilterOp->OriginatingTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        fprintf( File, "\t%-12S", time );

    } else {

        fprintf( File, "\t%-12S", TIME_ERROR );
    }

    //
    //  Output the process and thread id
    //

    fprintf( File, "\t%8x.%-4x ", RecordFsFilterOp->ProcessId, RecordFsFilterOp->ThreadId );

    //
    //  Output the FsFilter operation parameters
    //
    
    PrintFsFilterOperation( RecordFsFilterOp->FsFilterOperation, File );

    fprintf( File, "\t%08p", RecordFsFilterOp->FileObject );
    fprintf( File, "\t%.*S", NameLength/sizeof(WCHAR), Name );
    fprintf( File, "\n" );
}

VOID
FsFilterOperationScreenDump (
    IOTEST_DEVICE_TYPE DeviceType,
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FS_FILTER_OPERATION RecordFsFilterOp
)
/*++
Routine Name:

    FsFilterOperationScreenDump

Routine Description:

    Prints a FsFilterOperation log record to the screen in the following order:
    
    SequenceNumber, OriginatingTime, CompletionTime, ProcessId, ThreadId,
    Operation, FileObject, ReturnStatus, FileName

Arguments:

    SequenceNumber - the sequence number for this log record
    Name - the file name to which this Irp relates
    NameLength - the length of name in bytes
    RecordFsFilterOp - the FsFilterOperation record to print

Return Value:

    None.

--*/
{
    FILETIME localTime;
    SYSTEMTIME systemTime;
    WCHAR time[TIME_BUFFER_LENGTH];

    switch (DeviceType) {
    case TOP_FILTER:
        printf("TOP O %08X", SequenceNumber);
        break;
    case BOTTOM_FILTER:
        printf("BOT O %08X", SequenceNumber);
        break;
    default:
        printf("UNK O %08X", SequenceNumber);
        break;       
    }

    //
    // Convert originating time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordFsFilterOp->OriginatingTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        printf( "%-12S ", time );

    } else {

        printf( "%-12S ", TIME_ERROR );
    }

    printf( "%8x.%-4x ", RecordFsFilterOp->ProcessId, RecordFsFilterOp->ThreadId );

    PrintFsFilterOperation( RecordFsFilterOp->FsFilterOperation, NULL );

    //
    // Print FsFilter operation specific values.
    //

    printf( "%08p ", RecordFsFilterOp->FileObject );
    printf( "%.*S", NameLength/sizeof(WCHAR),Name );
    printf( "\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\iotest\user\iotestuser.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    fspyUser.c

Abstract:

    This file contains the implementation for the main function of the 
    user application piece of IoTest.  This function is responsible for
    controlling the command mode available to the user to control the 
    kernel mode driver.
    
// @@BEGIN_DDKSPLIT
Author:

    George Jenkins (GeorgeJe)                       

// @@END_DDKSPLIT
Environment:

    User mode


// @@BEGIN_DDKSPLIT

Revision History:

    Molly Brown (MollyBro) 21-Apr-1999
        Broke out the logging code and added command mode functionality.

// @@END_DDKSPLIT
--*/

#include <windows.h>                
#include <stdlib.h>
#include <stdio.h>
#include <winioctl.h>
#include <string.h>
#include <crtdbg.h>
#include "ioTest.h"
#include "ioTestLog.h"
#include "ioTestLib.h"

#define SUCCESS              0
#define USAGE_ERROR          1
#define EXIT_INTERPRETER     2
#define EXIT_PROGRAM         4

#define INTERPRETER_EXIT_COMMAND1 "go"
#define INTERPRETER_EXIT_COMMAND2 "g"
#define PROGRAM_EXIT_COMMAND      "exit"

#define ToggleFlag(V, F) (V = (((V) & (F)) ? (V & (~F)) : (V | F)))

DWORD
InterpretCommand(
    int argc,
    char *argv[],
    PLOG_CONTEXT Context
);

BOOL
ListDevices(
    PLOG_CONTEXT Context
);

VOID
DisplayError (
   DWORD Code
   );

int _cdecl main(int argc, char *argv[])
{
    SC_HANDLE               hSCManager = NULL;
    SC_HANDLE               hService = NULL;
    SERVICE_STATUS_PROCESS  serviceInfo;
    DWORD                   bytesNeeded;
    HANDLE                  hDevice = INVALID_HANDLE_VALUE;
    DWORD                   result;
    LOG_CONTEXT             context;

    //
    // Initialize handle in case of error
    //

    context.ShutDown = NULL;
    context.VerbosityFlags = 0;

    //
    // Start the kernel mode driver through the service manager
    //
    
    hSCManager = OpenSCManager (NULL, NULL, SC_MANAGER_ALL_ACCESS) ;
    hService = OpenService( hSCManager,
                            IOTEST_SERVICE_NAME,
                            IOTEST_SERVICE_ACCESS);
    if (!QueryServiceStatusEx( hService,
                               SC_STATUS_PROCESS_INFO,
                               (UCHAR *)&serviceInfo,
                               sizeof(serviceInfo),
                               &bytesNeeded)) {
        result = GetLastError();
        DisplayError( result );
        goto Main_Exit;
    }

    if(serviceInfo.dwCurrentState != SERVICE_RUNNING) {
        //
        // Service hasn't been started yet, so try to start service
        //
        if (!StartService(hService, 0, NULL)) {
            result = GetLastError();
            printf("ERROR starting IoTest...\n");
            DisplayError( result );
            goto Main_Exit;
        }
    }
   
    //
    //  Open the device that is used to talk to IoTest.
    //
    
    hDevice = CreateFile( IOTEST_W32_DEVICE_NAME,
                          GENERIC_READ | GENERIC_WRITE,
                          0,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL);
    if (hDevice == INVALID_HANDLE_VALUE) {
        result = GetLastError();
        printf("ERROR opening device...\n");
        DisplayError( result );
        goto Main_Exit;
    }
    
    //
    //  Initialize the fields of the LOG_CONTEXT.
    //
    context.Device = hDevice;
    context.CleaningUp = FALSE;
    context.LogToScreen = TRUE;
    context.LogToFile = FALSE;
    context.OutputFile = NULL;

    //
    // Check the valid parameters for startup
    //
    InterpretCommand(argc - 1, &(argv[1]), &context);

    // 
    // Wait for everyone to shut down
    //
    if (context.LogToFile) {
        fclose(context.OutputFile);
    }

Main_Exit:
    // 
    // Clean up the data that is alway around and exit
    //
    if(hSCManager) {
        CloseServiceHandle(hSCManager);
    }
    if(hService) {
        CloseServiceHandle(hService);
    }
    if (hDevice != INVALID_HANDLE_VALUE) {
        CloseHandle(hDevice);
    }
    
    return 0;  

}


DWORD
InterpretCommand(
    int argc,
    char *argv[],
    PLOG_CONTEXT Context
)
{
    int         parmIndex;
    CHAR       *parm;      
    BOOL        bResult;
    DWORD       result;
    DWORD       returnValue = SUCCESS;
    CHAR        buffer[BUFFER_SIZE];
    DWORD       bufferLength;

    if (argc == 0) {

        goto InterpretCommand_Usage;
    }
    
    //
    // Interprete the command line parameters
    //
    for (parmIndex = 0; parmIndex < argc; parmIndex++) {
        parm = argv[parmIndex];
        if (parm[0] == '/') {
            //
            // Have the beginning of a switch
            //
            switch (parm[1]) {
            case 'l':
            case 'L':
                //
                // List all devices that are currently being monitored
                //
                bResult = ListDevices(Context);
                if (!bResult) {
                    result = GetLastError();
                    printf("ERROR listing devices...\n");
                    DisplayError( result );
                }
                
                break;

            case 'n':
            case 'N':
                //
                // Run RENAME test on specified drive
                //
                parmIndex++;
                if (parmIndex >= argc) {
                    //
                    // Not enough parameters
                    //
                    goto InterpretCommand_Usage;
                }
                parm = argv[parmIndex];
                printf("\tPerforming RENAME test on %s\n", parm);
                bufferLength = MultiByteToWideChar(
                    CP_ACP,
                    MB_ERR_INVALID_CHARS,
                    parm,
                    -1,
                    (LPWSTR)buffer,
                    BUFFER_SIZE/sizeof(WCHAR));

                RenameTest( Context, (LPWSTR)buffer, bufferLength * sizeof(WCHAR), FALSE );
                RenameTest( Context, (LPWSTR)buffer, bufferLength * sizeof(WCHAR), TRUE );
                
                break;

            case 'r':
            case 'R':
                //
                // Run READ test on specified drive
                //
                parmIndex++;
                if (parmIndex >= argc) {
                    //
                    // Not enough parameters
                    //
                    goto InterpretCommand_Usage;
                }
                parm = argv[parmIndex];
                printf("\tPerforming READ test on %s\n", parm);
                bufferLength = MultiByteToWideChar(
                    CP_ACP,
                    MB_ERR_INVALID_CHARS,
                    parm,
                    -1,
                    (LPWSTR)buffer,
                    BUFFER_SIZE/sizeof(WCHAR));

                ReadTest( Context, (LPWSTR)buffer, bufferLength * sizeof(WCHAR), FALSE );
                ReadTest( Context, (LPWSTR)buffer, bufferLength * sizeof(WCHAR), TRUE );
                
                break;

            case 'h':
            case 'H':
                //
                // Run SHARE test on specified drive
                //
                parmIndex++;
                if (parmIndex >= argc) {
                    //
                    // Not enough parameters
                    //
                    goto InterpretCommand_Usage;
                }
                parm = argv[parmIndex];
                printf("\tPerforming SHARE test on %s\n", parm);
                bufferLength = MultiByteToWideChar(
                    CP_ACP,
                    MB_ERR_INVALID_CHARS,
                    parm,
                    -1,
                    (LPWSTR)buffer,
                    BUFFER_SIZE/sizeof(WCHAR));

                ShareTest( Context, (LPWSTR)buffer, bufferLength * sizeof(WCHAR), FALSE );
                ShareTest( Context, (LPWSTR)buffer, bufferLength * sizeof(WCHAR), TRUE );
                
                break;

            case 's':
            case 'S':
                //
                // Output logging results to screen, save new value to
                // instate when command interpreter is exited.
                //
                if (Context->NextLogToScreen) {
                    printf("\tTurning off logging to screen\n");
                } else {
                    printf("\tTurning on logging to screen\n");
                }
                Context->NextLogToScreen = !Context->NextLogToScreen;
                break;

            case 'f':
            case 'F':
                //
                // Output logging results to file
                //
                if (Context->LogToFile) {
                    printf("\tStop logging to file \n");
                    Context->LogToFile = FALSE;
                    _ASSERT(Context->OutputFile);
                    fclose(Context->OutputFile);
                    Context->OutputFile = NULL;
                } else {
                    parmIndex++;
                    if (parmIndex >= argc) {
                        // Not enough parameters
                        goto InterpretCommand_Usage;
                    }
                    parm = argv[parmIndex];
                    printf("\tLog to file %s\n", parm);
                    Context->OutputFile = fopen(parm, "w");
                    _ASSERT(Context->OutputFile);
                    Context->LogToFile = TRUE;
                }
                break;

            case '?':
            default:
                //
                // Invalid switch, goto usage
                //
                goto InterpretCommand_Usage;
            }
        } else {
            //
            // Invalid parameter
            //
            goto InterpretCommand_Usage;
        }
    }

InterpretCommand_Exit:
    return returnValue;

InterpretCommand_Usage:
    printf("Usage: [[/r <drive>]...] [[/n <drive>]...] [[/h <drive>]...] [/l] [/s] [/f <file name>] \n"
           "\t[/r <drive>] runs the READ test on <drive>\n"
           "\t[/n <drive>] runs the RENAME test on <drive>\n"
           "\t[/h <drive>] runs the SHARE test on <drive>\n"
           "\n"
           "\t[/l] lists all the drives the monitor is currently attached to\n"
           "\t[/s] turns on and off showing logging output on the screen\n"
           "\t[/f <file name>] turns on and off logging to the specified file\n"
           );
    returnValue = USAGE_ERROR;
    goto InterpretCommand_Exit;
}

BOOL
ListDevices(
    PLOG_CONTEXT Context
)
{
    CHAR             buffer[BUFFER_SIZE];
    ULONG            bytesReturned;
    BOOL             returnValue;

    returnValue = DeviceIoControl(
        Context->Device,
        IOTEST_ListDevices,
        NULL,
        0,
        buffer,
        BUFFER_SIZE,
        &bytesReturned,
        NULL);

    if (returnValue) {
        PATTACHED_DEVICE device = (PATTACHED_DEVICE) buffer;


        printf("DEVICE NAME                       | LOGGING STATUS\n");
        printf("--------------------------------------------------\n");

        if (bytesReturned == 0) {
            printf("No devices attached\n");
        } else {
            while ((BYTE *)device < buffer + bytesReturned) {
                switch (device->DeviceType) {
                case TOP_FILTER:
                    printf(
                        "TOP %-30S| %s\n",
                        device->DeviceNames, 
                        (device->LoggingOn)?"ON":"OFF");
                    break;
                    
                case BOTTOM_FILTER:
                    printf(
                        "BOT %-30S| %s\n",
                        device->DeviceNames, 
                        (device->LoggingOn)?"ON":"OFF");
                    break;
                }
                device ++;
            }
        }
    }

    return returnValue;
}

VOID
DisplayError (
   DWORD Code
   )

/*++

Routine Description:

   This routine will display an error message based off of the Win32 error
   code that is passed in. This allows the user to see an understandable
   error message instead of just the code.

Arguments:

   Code - The error code to be translated.

Return Value:

   None.

--*/

{
   WCHAR                                    buffer[80] ;
   DWORD                                    count ;

   //
   // Translate the Win32 error code into a useful message.
   //

   count = FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM,
                          NULL,
                          Code,
                          0,
                          buffer,
                          sizeof (buffer),
                          NULL) ;

   //
   // Make sure that the message could be translated.
   //

   if (count == 0) {

      printf("\nError could not be translated.\n Code: %d\n", Code) ;
      return;
   }
   else {

      //
      // Display the translated error.
      //

      printf("%S\n", buffer) ;
      return;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\iotest\lib\namelists.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    irpNameList.c

Abstract:

    This module contains an array of unicode IRP names.

// @@BEGIN_DDKSPLIT
Author:

    Neal Christiansen (NealCH) 29-Sep-2000

// @@END_DDKSPLIT

Environment:

    User mode


// @@BEGIN_DDKSPLIT
Revision History:

// @@END_DDKSPLIT
--*/

#include <ntifs.h>
#include "ioTestLib.h"

//
//  List of unicode irp names
//

PWCHAR IrpNameList[IRP_MJ_MAXIMUM_FUNCTION+1] = 
{
    L"IRP_MJ_CREATE",
    L"IRP_MJ_CREATE_NAMED_PIPE",
    L"IRP_MJ_CLOSE",
    L"IRP_MJ_READ",
    L"IRP_MJ_WRITE",
    L"IRP_MJ_QUERY_INFORMATION",
    L"IRP_MJ_SET_INFORMATION",
    L"IRP_MJ_QUERY_EA",
    L"IRP_MJ_SET_EA",
    L"IRP_MJ_FLUSH_BUFFERS",
    L"IRP_MJ_QUERY_VOLUME_INFORMATION",
    L"IRP_MJ_SET_VOLUME_INFORMATION",
    L"IRP_MJ_DIRECTORY_CONTROL",
    L"IRP_MJ_FILE_SYSTEM_CONTROL",
    L"IRP_MJ_DEVICE_CONTROL",
    L"IRP_MJ_INTERNAL_DEVICE_CONTROL",
    L"IRP_MJ_SHUTDOWN",
    L"IRP_MJ_LOCK_CONTROL",
    L"IRP_MJ_CLEANUP",
    L"IRP_MJ_CREATE_MAILSLOT",
    L"IRP_MJ_QUERY_SECURITY",
    L"IRP_MJ_SET_SECURITY",
    L"IRP_MJ_POWER",
    L"IRP_MJ_SYSTEM_CONTROL",
    L"IRP_MJ_DEVICE_CHANGE",
    L"IRP_MJ_QUERY_QUOTA",
    L"IRP_MJ_SET_QUOTA",
    L"IRP_MJ_PNP"
};


PWCHAR FastIoNameList[FASTIO_MAX_OPERATION] =
{
    L"CHECK_IF_POSSIBLE",
    L"READ",
    L"WRITE",
    L"QUERY_BASIC_INFO",
    L"QUERY_STANDARD_INFO",
    L"LOCK",
    L"UNLOCK_SINGLE",
    L"UNLOCK_ALL",
    L"UNLOCK_ALL_BY_KEY",
    L"DEVICE_CONTROL",
    L"DETACH_DEVICE",
    L"QUERY_NETWORK_OPEN_INFO",
    L"MDL_READ",
    L"MDL_READ_COMPLETE",
    L"MDL_WRITE",
    L"MDL_WRITE_COMPLETE",
    L"READ_COMPRESSED",
    L"WRITE_COMPRESSED",
    L"MDL_READ_COMPLETE_COMPRESSED",
    L"PREPARE_MDL_WRITE",
    L"MDL_WRITE_COMPLETE_COMPRESSED",
    L"QUERY_OPEN_STRING",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\latency\filter\latency.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    latency.c

Abstract:

    This filter is written as a test filter that can be
    placed anywhere in the filter stack to pend operations
    and add latency.

    It has two mode:
    	* attach on demand
    	* attach to all volumes in system

    Once it is attached, the amount of latency added to operations
    can be controlled through the user mode program.
    
Author:

    Molly Brown (mollybro)  

Environment:

    Kernel mode

--*/

#include <latKernel.h>
#include <latency.h>

//
// Global storage for this file system filter driver.
//

LATENCY_GLOBALS Globals;
KSPIN_LOCK GlobalsLock;

//
//  list of known device types
//

const PCHAR DeviceTypeNames[] = {
    "",
    "BEEP",
    "CD_ROM",
    "CD_ROM_FILE_SYSTEM",
    "CONTROLLER",
    "DATALINK",
    "DFS",
    "DISK",
    "DISK_FILE_SYSTEM",
    "FILE_SYSTEM",
    "INPORT_PORT",
    "KEYBOARD",
    "MAILSLOT",
    "MIDI_IN",
    "MIDI_OUT",
    "MOUSE",
    "MULTI_UNC_PROVIDER",
    "NAMED_PIPE",
    "NETWORK",
    "NETWORK_BROWSER",
    "NETWORK_FILE_SYSTEM",
    "NULL",
    "PARALLEL_PORT",
    "PHYSICAL_NETCARD",
    "PRINTER",
    "SCANNER",
    "SERIAL_MOUSE_PORT",
    "SERIAL_PORT",
    "SCREEN",
    "SOUND",
    "STREAMS",
    "TAPE",
    "TAPE_FILE_SYSTEM",
    "TRANSPORT",
    "UNKNOWN",
    "VIDEO",
    "VIRTUAL_DISK",
    "WAVE_IN",
    "WAVE_OUT",
    "8042_PORT",
    "NETWORK_REDIRECTOR",
    "BATTERY",
    "BUS_EXTENDER",
    "MODEM",
    "VDM",
    "MASS_STORAGE",
    "SMB",
    "KS",
    "CHANGER",
    "SMARTCARD",
    "ACPI",
    "DVD",
    "FULLSCREEN_VIDEO",
    "DFS_FILE_SYSTEM",
    "DFS_VOLUME",
    "SERENUM",
    "TERMSRV",
    "KSEC"
};

//
//  We need this because the compiler doesn't like doing sizeof an externed
//  array in the other file that needs it (fspylib.c)
//

ULONG SizeOfDeviceTypeNames = sizeof( DeviceTypeNames );

//
//  Since functions in drivers are non-pagable by default, these pragmas 
//  allow the driver writer to tell the system what functions can be paged.
//
//  Use the PAGED_CODE() macro at the beginning of these functions'
//  implementations while debugging to ensure that these routines are
//  never called at IRQL > APC_LEVEL (therefore the routine cannot
//  be paged).
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, LatFsControl)
#pragma alloc_text(PAGE, LatCommonDeviceIoControl)
#endif

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
)
/*++

Routine Description:

    This is the initialization routine for the general purpose file system
    filter driver.  This routine creates the device object that represents 
    this driver in the system and registers it for watching all file systems 
    that register or unregister themselves as active file systems.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/
{
    UNICODE_STRING nameString;
    NTSTATUS status;
    PFAST_IO_DISPATCH fastIoDispatch;
    ULONG i;
    UNICODE_STRING linkString;
    
    //////////////////////////////////////////////////////////////////////
    //                                                                  //
    //  General setup for all filter drivers.  This sets up the filter  //
    //  driver's DeviceObject and registers the callback routines for   //
    //  the filter driver.                                              //
    //                                                                  //
    //////////////////////////////////////////////////////////////////////

#if DBG
    DbgBreakPoint();
#endif

	//
	//  Initialize our Globals structure.
	//

	KeInitializeSpinLock( &GlobalsLock );

#if DBG
	Globals.DebugLevel = DEBUG_ERROR | DEBUG_DISPLAY_ATTACHMENT_NAMES;
#else
	Globals.DebugLevel = 0;
#endif

	Globals.AttachMode = LATENCY_ATTACH_ALL_VOLUMES;
	Globals.DriverObject = DriverObject;
	
	ExInitializeFastMutex( &(Globals.DeviceExtensionListLock) );
	
    //
    // Create the device object that will represent the Latency device.
    //

    RtlInitUnicodeString( &nameString, LATENCY_FULLDEVICE_NAME );
    
    //
    // Create the "control" device object.  Note that this device object does
    // not have a device extension (set to NULL).  Most of the fast IO routines
    // check for this condition to determine if the fast IO is directed at the
    // control device.
    //

    status = IoCreateDevice( DriverObject,
                             0,
                             &nameString,
                             FILE_DEVICE_DISK_FILE_SYSTEM,
                             0,
                             FALSE,
                             &(Globals.ControlDeviceObject));

    if (!NT_SUCCESS( status )) {

        LAT_DBG_PRINT1( DEBUG_ERROR,
                        "LATENCY (DriverEntry): Error creating Latency device, error: %x\n",
                        status );

        return status;

    } else {

        RtlInitUnicodeString( &linkString, LATENCY_DOSDEVICE_NAME );
        status = IoCreateSymbolicLink( &linkString, &nameString );

        if (!NT_SUCCESS(status)) {

            LAT_DBG_PRINT0( DEBUG_ERROR,
                            "LATENCY (DriverEntry): IoCreateSymbolicLink failed\n" );
            IoDeleteDevice(Globals.ControlDeviceObject);
            return status;
        }
    }

    //
    // Initialize the driver object with this device driver's entry points.
    //

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {

        DriverObject->MajorFunction[i] = LatDispatch;
    }

    //
    // Allocate fast I/O data structure and fill it in.  This structure
    // is used to register the callbacks for Latency in the fast I/O
    // data paths.
    //

    fastIoDispatch = ExAllocatePool( NonPagedPool, sizeof( FAST_IO_DISPATCH ) );

    if (!fastIoDispatch) {

        IoDeleteDevice( Globals.ControlDeviceObject );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( fastIoDispatch, sizeof( FAST_IO_DISPATCH ) );
    fastIoDispatch->SizeOfFastIoDispatch = sizeof( FAST_IO_DISPATCH );
    fastIoDispatch->FastIoCheckIfPossible = LatFastIoCheckIfPossible;
    fastIoDispatch->FastIoRead = LatFastIoRead;
    fastIoDispatch->FastIoWrite = LatFastIoWrite;
    fastIoDispatch->FastIoQueryBasicInfo = LatFastIoQueryBasicInfo;
    fastIoDispatch->FastIoQueryStandardInfo = LatFastIoQueryStandardInfo;
    fastIoDispatch->FastIoLock = LatFastIoLock;
    fastIoDispatch->FastIoUnlockSingle = LatFastIoUnlockSingle;
    fastIoDispatch->FastIoUnlockAll = LatFastIoUnlockAll;
    fastIoDispatch->FastIoUnlockAllByKey = LatFastIoUnlockAllByKey;
    fastIoDispatch->FastIoDeviceControl = LatFastIoDeviceControl;
    fastIoDispatch->FastIoDetachDevice = LatFastIoDetachDevice;
    fastIoDispatch->FastIoQueryNetworkOpenInfo = LatFastIoQueryNetworkOpenInfo;
    fastIoDispatch->MdlRead = LatFastIoMdlRead;
    fastIoDispatch->MdlReadComplete = LatFastIoMdlReadComplete;
    fastIoDispatch->PrepareMdlWrite = LatFastIoPrepareMdlWrite;
    fastIoDispatch->MdlWriteComplete = LatFastIoMdlWriteComplete;
    fastIoDispatch->FastIoReadCompressed = LatFastIoReadCompressed;
    fastIoDispatch->FastIoWriteCompressed = LatFastIoWriteCompressed;
    fastIoDispatch->MdlReadCompleteCompressed = LatFastIoMdlReadCompleteCompressed;
    fastIoDispatch->MdlWriteCompleteCompressed = LatFastIoMdlWriteCompleteCompressed;
    fastIoDispatch->FastIoQueryOpen = LatFastIoQueryOpen;

    DriverObject->FastIoDispatch = fastIoDispatch;

	//
	//  This filter doesn't care about any of the FsFilter operations.  Therefore
	//  this filter doesn't need to register with 
	//  FsRtlRegisterFileSystemFilterCallbacks.
    //

    //
    //  Read the custom parameters for Latency Filter from the registry
    //
    LatReadDriverParameters( RegistryPath );

    //
    //  If we are supposed to attach to all devices, register a callback
    //  with IoRegisterFsRegistrationChange.
    //

    if (Globals.AttachMode == LATENCY_ATTACH_ALL_VOLUMES) {
    
        status = IoRegisterFsRegistrationChange( DriverObject, LatFsNotification );
        
        if (!NT_SUCCESS( status )) {

            LAT_DBG_PRINT1( DEBUG_ERROR,
                            "LATENCY (DriverEntry): Error registering FS change notification, status=%08x\n", 
                            status );
            ExFreePool( fastIoDispatch );
            IoDeleteDevice( Globals.ControlDeviceObject );
            return status;
        }
    }

    //
    //  Clear the initializing flag on the control device object since we
    //  have now successfully initialized everything.
    //

    ClearFlag( Globals.ControlDeviceObject->Flags, DO_DEVICE_INITIALIZING );

    return STATUS_SUCCESS;
}

NTSTATUS
LatDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
)
/*++

Routine Description:

    This function completes all requests on the Globals.ControlDeviceObject 
    and passes all other requests on to the SpyPassThrough function.

Arguments:

    DeviceObject - Pointer to device object Latency Filter attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    If this is a request on the gControlDeviceObject, STATUS_SUCCESS 
    will be returned unless the device is already attached.  In that case,
    STATUS_DEVICE_ALREADY_ATTACHED is returned.

    If this is a request on a device other than the gControlDeviceObject,
    the function will return the value of SpyPassThrough().

--*/
{
    ULONG status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack;
    
    if (DeviceObject == Globals.ControlDeviceObject) {

        //
        //  A request is being made on our device object, gControlDeviceObject.
        //

        Irp->IoStatus.Information = 0;
    
        irpStack = IoGetCurrentIrpStackLocation( Irp );
       
        switch (irpStack->MajorFunction) {
        case IRP_MJ_CREATE:
        
            status = STATUS_SUCCESS;
            Irp->IoStatus.Information = FILE_OPENED;
        	break;
        	
        case IRP_MJ_DEVICE_CONTROL:

            //
            //  This is a private device control irp for our control device.
            //  Pass the parameter information along to the common routine
            //  use to service these requests.
            //
            
            status = LatCommonDeviceIoControl( irpStack->Parameters.DeviceIoControl.Type3InputBuffer,
                                               irpStack->Parameters.DeviceIoControl.InputBufferLength,
                                               Irp->UserBuffer,
                                               irpStack->Parameters.DeviceIoControl.OutputBufferLength,
                                               irpStack->Parameters.DeviceIoControl.IoControlCode,
                                               &Irp->IoStatus,
                                               irpStack->DeviceObject );
            break;

        case IRP_MJ_CLEANUP:
        
            //
            //  This is the cleanup that we will see when all references to a handle
            //  opened to Latency's control device object are cleaned up.  We don't
            //  have to do anything here since we wait until the actual IRP_MJ_CLOSE
            //  to clean up the name cache.  Just complete the IRP successfully.
            //

            status = STATUS_SUCCESS;
            break;
                
		case IRP_MJ_CLOSE:

			status = STATUS_SUCCESS;
			break;
			
        default:

            status = STATUS_INVALID_DEVICE_REQUEST;
        }

        Irp->IoStatus.Status = status;

        //
        //  We have completed all processing for this IRP, so tell the 
        //  I/O Manager.  This IRP will not be passed any further down
        //  the stack since no drivers below Latency care about this 
        //  I/O operation that was directed to the Latency Filter.
        //

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;
    }

    return LatPassThrough( DeviceObject, Irp );
}

NTSTATUS
LatPassThrough (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
)
/*++

Routine Description:

    This routine is the main dispatch routine for the general purpose file
    system driver.  It simply passes requests onto the next driver in the
    stack, which is presumably a disk file system, while logging any
    relevant information if logging is turned on for this DeviceObject.

Arguments:

    DeviceObject - Pointer to device object Latency attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

Note:

	This routine passes the I/O request through to the next driver
	and sets up to pend the operation if we are pending the given
	operation.
	
    To remain in the stack, we have to copy the caller's parameters to the
    next stack location.  Note that we do not want to copy the caller's I/O
    completion routine into the next stack location, or the caller's routine
    will get invoked twice.  This is why we NULL out the Completion routine.
    If we are logging this device, we set our own Completion routine.
    
--*/
{
	PLATENCY_DEVICE_EXTENSION devExt;
	
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );

    //
    //  See if we should pend this IRP
    //
    
	if (LatShouldPendThisIo( devExt, Irp )) {

		//
		//  Pend this operation 
		//
		
		IoCompleteRequest( Irp, STATUS_PENDING );

		//
		//  Queue to a worker thread to sleep and
		//  continue later.
		//

		IoCopyCurrentIrpStackLocationToNext( Irp );
		IoSetCompletionRoutine( Irp,
								LatAddLatencyCompletion,
								NULL,
								TRUE,
								TRUE,
								TRUE );
								
	} else {

		//
		//  We are not pending this operation so get out
		//  of the stack.
		//

		IoSkipCurrentIrpStackLocation( Irp );
	}

    devExt = DeviceObject->DeviceExtension;
    
	return IoCallDriver( devExt->AttachedToDeviceObject, Irp );
}

NTSTATUS
LatFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
)
/*++

Routine Description:

    This routine is the handler for all Fs Controls that are directed to 
    devices that LatFilter cares about.  LatFilter itself does not support
    any FS Controls.

    It is through this path that the filter is notified of mounts, dismounts
    and new file systems loading.

Arguments:

    DeviceObject - Pointer to device object Latency attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

Note:

	This routine passes the I/O request through to the next driver
	and sets up to pend the operation if we are pending the given
	operation.
	
    To remain in the stack, we have to copy the caller's parameters to the
    next stack location.  Note that we do not want to copy the caller's I/O
    completion routine into the next stack location, or the caller's routine
    will get invoked twice.  This is why we NULL out the Completion routine.
    If we are logging this device, we set our own Completion routine.
    
--*/
{
    PLATENCY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    PDEVICE_OBJECT newLatencyDeviceObject;
    PLATENCY_DEVICE_EXTENSION newDevExt;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );
    NTSTATUS status;

    PAGED_CODE();

    //
    //  If this is for our control device object, fail the operation
    //

    if (Globals.ControlDeviceObject == DeviceObject) {

        //
        //  If this device object is our control device object rather than 
        //  a mounted volume device object, then this is an invalid request.
        //

        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  Begin by determining the minor function code for this file system control
    //  function.
    //

    switch (irpSp->MinorFunction) {

    case IRP_MN_MOUNT_VOLUME:

        //
        //  This is a mount request.  Create a device object that can be
        //  attached to the file system's volume device object if this request
        //  is successful.  We allocate this memory now since we can not return
        //  an error in the completion routine.
        //

        status = IoCreateDevice( Globals.DriverObject,
                                 sizeof( LATENCY_DEVICE_EXTENSION ),
                                 (PUNICODE_STRING) NULL,
                                 DeviceObject->DeviceType,
                                 0,
                                 FALSE,
                                 &newLatencyDeviceObject );

        if (NT_SUCCESS( status )) {

            //
            //  We need to save the RealDevice object pointed to by the vpb
            //  parameter because this vpb may be changed by the underlying
            //  file system.  Both FAT and CDFS may change the VPB address if
            //  the volume being mounted is one they recognize from a previous
            //  mount.
            //

            newDevExt = newLatencyDeviceObject->DeviceExtension;
            LatResetDeviceExtension( newDevExt );
            newDevExt->DiskDeviceObject = irpSp->Parameters.MountVolume.Vpb->RealDevice;

            //
            //  Get a new IRP stack location and set our mount completion
            //  routine.  Pass along the address of the device object we just
            //  created as its context.
            //

            IoCopyCurrentIrpStackLocationToNext( Irp );

            IoSetCompletionRoutine( Irp,
                                    LatMountCompletion,
                                    newLatencyDeviceObject,
                                    TRUE,
                                    TRUE,
                                    TRUE );

        } else {

            LAT_DBG_PRINT1( DEBUG_ERROR,
                            "LATENCY (LatFsControl): Error creating volume device object, status=%08x\n", 
                            status );

            //
            //  Something went wrong so this volume cannot be filtered.  Simply
            //  allow the system to continue working normally, if possible.
            //

            IoSkipCurrentIrpStackLocation( Irp );
        }

        status = IoCallDriver( DeviceObject, Irp );

        break;

    case IRP_MN_LOAD_FILE_SYSTEM:

        //
        //  This is a "load file system" request being sent to a file system
        //  recognizer device object.  This IRP_MN code is only sent to 
        //  file system recognizers.
        //

        LAT_DBG_PRINT2( DEBUG_DISPLAY_ATTACHMENT_NAMES,
                        "LATENCY (LatFsControl): Loading File System, Detaching from \"%.*S\"\n",
                        devExt->DeviceNames.Length / sizeof( WCHAR ),
                        devExt->DeviceNames.Buffer );

        //
        //  Set a completion routine so we can delete the device object when
        //  the detach is complete.
        //

        IoCopyCurrentIrpStackLocationToNext( Irp );

        IoSetCompletionRoutine(
            Irp,
            LatLoadFsCompletion,
            DeviceObject,
            TRUE,
            TRUE,
            TRUE );

        //
        //  Detach from the recognizer device.
        //

        IoDetachDevice( devExt->AttachedToDeviceObject );

        status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );

    default:

        //
        //  Simply treat this as the pass through case and call
        //  the common routine to do this.
        //

        status = LatPassThrough( DeviceObject, Irp );
    }

    return status;
}

VOID
LatFsNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FsActive
    )
/*++

Routine Description:

    This routine is invoked whenever a file system has either registered or
    unregistered itself as an active file system.

    For the former case, this routine creates a device object and attaches it
    to the specified file system's device object.  This allows this driver
    to filter all requests to that file system.

    For the latter case, this file system's device object is located,
    detached, and deleted.  This removes this file system as a filter for
    the specified file system.

Arguments:

    DeviceObject - Pointer to the file system's device object.

    FsActive - Boolean indicating whether the file system has registered
        (TRUE) or unregistered (FALSE) itself as an active file system.

Return Value:

    None.

--*/
{
    UNICODE_STRING name;
    WCHAR nameBuffer[DEVICE_NAMES_SZ];

    PAGED_CODE();

    RtlInitEmptyUnicodeString( &name, nameBuffer, sizeof( nameBuffer ) );

    //
    //  Display the names of all the file system we are notified of
    //

    if (FlagOn( Globals.DebugLevel, DEBUG_DISPLAY_ATTACHMENT_NAMES )) {

        LatGetBaseDeviceObjectName( DeviceObject, &name );
        DbgPrint( "LATENCY (LatFsNotification): %s   \"%.*S\" (%s)\n",
                  (FsActive) ? "Activating file system  " : "Deactivating file system",
                  name.Length / sizeof( WCHAR ),
                  name.Buffer,
                  GET_DEVICE_TYPE_NAME(DeviceObject->DeviceType));
    }

    //
    //  See if we want to ATTACH or DETACH from the given file system.
    //

    if (FsActive) {

        LatAttachToFileSystemDevice( DeviceObject, &name );

    } else {

        LatDetachFromFileSystemDevice( DeviceObject );
    }
}

NTSTATUS
LatAddLatencyCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is invoked for the completion of a mount request.  If the
    mount was successful, then this file system attaches its device object to
    the file system's volume device object.  Otherwise, the interim device
    object is deleted.

Arguments:

    DeviceObject - Pointer to this driver's device object that was attached to
            the file system device object

    Irp - Pointer to the IRP that was just completed.

    Context - Pointer to the device object allocated during the down path so
            we wouldn't have to deal with errors here.

Return Value:

    The return value is always STATUS_SUCCESS.

--*/
{
    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );
    UNREFERENCED_PARAMETER( Context );
    return STATUS_SUCCESS;
}

NTSTATUS
LatMountCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is invoked for the completion of a mount request.  If the
    mount was successful, then this file system attaches its device object to
    the file system's volume device object.  Otherwise, the interim device
    object is deleted.

Arguments:

    DeviceObject - Pointer to this driver's device object that was attached to
            the file system device object

    Irp - Pointer to the IRP that was just completed.

    Context - Pointer to the device object allocated during the down path so
            we wouldn't have to deal with errors here.

Return Value:

    The return value is always STATUS_SUCCESS.

--*/

{
    PDEVICE_OBJECT latencyDeviceObject = (PDEVICE_OBJECT) Context;
    PLATENCY_DEVICE_EXTENSION devExt = latencyDeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );
    PVPB diskDeviceVpb;
    NTSTATUS status;

    UNREFERENCED_PARAMETER( DeviceObject );
    ASSERT(IS_MY_DEVICE_OBJECT( latencyDeviceObject ));

    //
    //  We can not use the VPB parameter in the IRP stack because the base file
    //  system might be using a different vpb (it will do this when a volume is
    //  detected which has been previously mounted and still has cached state).  
    //  Get the VPB from the "real" device object in the IRP stack.
    //

    diskDeviceVpb = devExt->DiskDeviceObject->Vpb;

    //
    //  Determine whether or not the request was successful and act accordingly.
    //  Also  see if we are already attached to the given device object.  This
    //  can occur when the underlying filesystem detects a volume it has cached
    //  state for.
    //

    if (NT_SUCCESS( Irp->IoStatus.Status ) && 
        !LatIsAttachedToDevice( diskDeviceVpb->DeviceObject, NULL )) {

        //
        //  The FileSystem has successfully completed the mount, which means
        //  it has created the DeviceObject to which we want to attach.  The
        //  Irp parameters contains the Vpb which allows us to get to the
        //  following two things:
        //      1. The device object created by the file system to represent
        //         the volume it just mounted.
        //      2. The device object of the StorageDeviceObject which we
        //         can use to get the name of this volume.  We wukk pass
        //         this into SpyAttachToMountedDevice so that it can
        //         use it at needed.
        //

        status = LatAttachToMountedDevice( diskDeviceVpb->DeviceObject, 
                                           latencyDeviceObject,
                                           devExt->DiskDeviceObject );

        //
        //  Since we are in the completion path, we can't fail this attachment.
        //
        
        ASSERT( NT_SUCCESS( status ) );

        //
        //  We complete initialization of this device object, so now clear
        //  the initializing flag.
        //

        ClearFlag( latencyDeviceObject->Flags, DO_DEVICE_INITIALIZING );

    } else {

        //
        //  Display what mount failed.  Setup the buffers.
        //

        if (FlagOn( Globals.DebugLevel, DEBUG_DISPLAY_ATTACHMENT_NAMES )) {

            RtlInitEmptyUnicodeString( &devExt->DeviceNames, 
                                       devExt->DeviceNamesBuffer, 
                                       sizeof( devExt->DeviceNamesBuffer ) );
            LatGetObjectName( diskDeviceVpb->RealDevice, &devExt->DeviceNames );
            
            if (!NT_SUCCESS( Irp->IoStatus.Status )) {

                LAT_DBG_PRINT3( DEBUG_ERROR,
                				"LATENCY (LatMountCompletion): Mount volume failure for   \"%.*S\", status=%08x\n",
                                devExt->DeviceNames.Length / sizeof( WCHAR ),
                                devExt->DeviceNames.Buffer,
                                Irp->IoStatus.Status );

            } else {

                LAT_DBG_PRINT2( DEBUG_ERROR,
                				"LATENCY (LatMountCompletion): Mount volume failure for   \"%.*S\", already attached\n",
	                            devExt->DeviceNames.Length / sizeof( WCHAR ),
      		                    devExt->DeviceNames.Buffer );
            }
        }

        //
        //  The mount request failed.  Cleanup and delete the device
        //  object we created
        //

        IoDeleteDevice( latencyDeviceObject );
    }

    //
    //  If pending was returned, propagate it to the caller.
    //

    if (Irp->PendingReturned) {

        IoMarkIrpPending( Irp );
    }

    return STATUS_SUCCESS;
}

NTSTATUS
LatLoadFsCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is invoked upon completion of an FSCTL function to load a
    file system driver (as the result of a file system recognizer seeing
    that an on-disk structure belonged to it).  A device object has already
    been created by this driver (DeviceObject) so that it can be attached to
    the newly loaded file system.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet representing the file system
          driver load request.

    Context - Context parameter for this driver, unused.

Return Value:

    The function value for this routine is always success.

--*/

{
    PLATENCY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;

    UNREFERENCED_PARAMETER( Context );
    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  Display the name if requested
    //

    LAT_DBG_PRINT3( DEBUG_DISPLAY_ATTACHMENT_NAMES,
                    "LATENCY (LatLoadFsCompletion): Detaching from recognizer  \"%.*S\", status=%08x\n",
                    devExt->DeviceNames.Length / sizeof( WCHAR ),
                    devExt->DeviceNames.Buffer,
                    Irp->IoStatus.Status );

    //
    //  Check status of the operation
    //

    if (!NT_SUCCESS( Irp->IoStatus.Status )) {

        //
        //  The load was not successful.  Simply reattach to the recognizer
        //  driver in case it ever figures out how to get the driver loaded
        //  on a subsequent call.
        //

        IoAttachDeviceToDeviceStack( DeviceObject, 
                                     devExt->AttachedToDeviceObject );

    } else {

        //
        //  The load was successful, delete the Device object attached to the
        //  recognizer.
        //

        IoDeleteDevice( DeviceObject );
    }

    //
    //  If pending was returned, then propagate it to the caller.
    //

    if (Irp->PendingReturned) {

        IoMarkIrpPending( Irp );
    }

    return STATUS_SUCCESS;
}


NTSTATUS
LatCommonDeviceIoControl (
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine does the common processing of interpreting the Device IO Control
    request.

Arguments:

    FileObject - The file object related to this operation.
    
    InputBuffer - The buffer containing the input parameters for this control
        operation.
        
    InputBufferLength - The length in bytes of InputBuffer.
    
    OutputBuffer - The buffer to receive any output from this control operation.
    
    OutputBufferLength - The length in bytes of OutputBuffer.
    
    IoControlCode - The control code specifying what control operation this is.
    
    IoStatus - Receives the status of this operation.
    
    DeviceObject - Pointer to device object Latency attached to the file system
        filter stack for the volume receiving this I/O request.
        
Return Value:

    None.
    
--*/
{
    PWSTR deviceName = NULL;
    LATENCYVER latencyVer;
    PLATENCY_SET_CLEAR setClear;
    PLATENCY_DEVICE_EXTENSION devExt;

    PAGED_CODE();

    ASSERT( IoStatus != NULL );
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );

    devExt = DeviceObject->DeviceExtension;
    
    IoStatus->Status = STATUS_SUCCESS;
    IoStatus->Information = 0;

    try {

        switch (IoControlCode) {
        case LATENCY_Reset:

            LatResetDeviceExtension( devExt );
            IoStatus->Status = STATUS_SUCCESS;
            break;

        //
        //      Request to start logging on a device
        //                                      

        case LATENCY_EnableLatency:

            if (InputBuffer == NULL || InputBufferLength <= 0) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }
            
            //
            // Copy the device name and add a null to ensure that it is null terminated
            //

            deviceName =  ExAllocatePool( NonPagedPool, InputBufferLength + sizeof(WCHAR) );

            if (NULL == deviceName) {

                IoStatus->Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            
            RtlCopyMemory( deviceName, InputBuffer, InputBufferLength );
            deviceName[InputBufferLength / sizeof(WCHAR) - 1] = UNICODE_NULL;

            IoStatus->Status = LatEnable( DeviceObject, deviceName );
            break;  

        //
        //      Detach from a specified device
        //  

        case LATENCY_DisableLatency:

            if (InputBuffer == NULL || InputBufferLength <= 0) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }
            
            //
            // Copy the device name and add a null to ensure that it is null terminated
            //

            deviceName =  ExAllocatePool( NonPagedPool, InputBufferLength + sizeof(WCHAR) );

            if (NULL == deviceName) {

                IoStatus->Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            
            RtlCopyMemory( deviceName, InputBuffer, InputBufferLength );
            deviceName[InputBufferLength / sizeof(WCHAR) - 1] = UNICODE_NULL;

            IoStatus->Status = LatDisable( deviceName );
            break;  

        //
        //      List all the devices that we are currently
        //      monitoring
        //

        case LATENCY_ListDevices:

            if (OutputBuffer == NULL || OutputBufferLength <= 0) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }


/* ISSUE-2000-09-21-mollybro 

    TODO : Implement LatGetAttachList.
    
*/

              IoStatus->Status = STATUS_SUCCESS;
//            IoStatus->Status = LatGetAttachList( OutputBuffer,
//                                                 OutputBufferLength,
//                                                 &IoStatus->Information);
            break;

        //
        //      Return version of the Latency filter driver
        //                                      

        case LATENCY_GetVer:

            if ((OutputBufferLength < sizeof(LATENCYVER)) || 
                (OutputBuffer == NULL)) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;                    
            }
            
            latencyVer.Major = LATENCY_MAJ_VERSION;
            latencyVer.Minor = LATENCY_MIN_VERSION;
            
            RtlCopyMemory(OutputBuffer, &latencyVer, sizeof(LATENCYVER));
            
            IoStatus->Information = sizeof (LATENCYVER);
            break;
        
        case LATENCY_SetLatency:

            if (InputBuffer == NULL || 
                InputBufferLength <= sizeof( LATENCY_SET_CLEAR )) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }

            setClear = (PLATENCY_SET_CLEAR)InputBuffer;
            devExt->Operations[setClear->IrpCode].MillisecondDelay = setClear->Milliseconds;
            
            break;
            
        case LATENCY_ClearLatency:
        
        default:

            IoStatus->Status = STATUS_INVALID_PARAMETER;
            break;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred while attempting to access
        // one of the caller's parameters.  Simply return an appropriate
        // error status code.
        //

        IoStatus->Status = GetExceptionCode();

    }

    if (NULL != deviceName) {

        ExFreePool( deviceName );
    }

  return IoStatus->Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\latency\inc\latency.h ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    latency.h

Abstract:

    The header file containing information needed by both the 
    user mode and kernel mode of the latency filter driver.
    
Author:

    Molly Brown (mollybro)  

Environment:

    Kernel mode

--*/

#ifndef __LATENCY_H__
#define __LATENCY_H__

//
//  Enable these warnings in the code.
//

#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4101)   // Unreferenced local variable


#define LATENCY_Reset              (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x00, METHOD_BUFFERED, FILE_WRITE_ACCESS )
#define LATENCY_EnableLatency      (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x01, METHOD_BUFFERED, FILE_READ_ACCESS )
#define LATENCY_DisableLatency     (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x02, METHOD_BUFFERED, FILE_READ_ACCESS )
#define LATENCY_GetLog             (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x03, METHOD_BUFFERED, FILE_READ_ACCESS )
#define LATENCY_GetVer             (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x04, METHOD_BUFFERED, FILE_READ_ACCESS )
#define LATENCY_ListDevices        (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x05, METHOD_BUFFERED, FILE_READ_ACCESS )
#define LATENCY_SetLatency         (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x06, METHOD_BUFFERED, FILE_READ_ACCESS )
#define LATENCY_ClearLatency       (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x07, METHOD_BUFFERED, FILE_READ_ACCESS )

#define LATENCY_DRIVER_NAME     L"LATENCY.SYS"
#define LATENCY_DEVICE_NAME     L"LatencyFilter"
#define LATENCY_W32_DEVICE_NAME L"\\\\.\\LatencyFilter"
#define LATENCY_DOSDEVICE_NAME  L"\\DosDevices\\LatencyFilter"
#define LATENCY_FULLDEVICE_NAME L"\\Device\\LatencyFilter"
    
#define LATENCY_MAJ_VERSION 1
#define LATENCY_MIN_VERSION 0

typedef struct _LATENCYVER {
    USHORT Major;
    USHORT Minor;
} LATENCYVER, *PLATENCYVER;

typedef struct _LATENCY_ENABLE_DISABLE {

    UNICODE_STRING DeviceName;
    UCHAR DeviceNameBuffer[];

} LATENCY_ENABLE_DISABLE, *PLATENCY_ENABLE_DISABLE;

typedef struct _LATENCY_SET_CLEAR {

    UCHAR IrpCode;
    ULONG Milliseconds;
    UNICODE_STRING DeviceName;
    UCHAR DeviceNameBuffer[];

} LATENCY_SET_CLEAR, *PLATENCY_SET_CLEAR;

#define LATENCY_ATTACH_ALL_VOLUMES 1
#define LATENCY_ATTACH_ON_DEMAND   0

#endif /* __LATENCY_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\iotest\user\iotestusersup.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    ioTestUserSup.c

Abstract:

    
// @@BEGIN_DDKSPLIT
Author:

    George Jenkins (GeorgeJe)                       

// @@END_DDKSPLIT
Environment:

    User mode


// @@BEGIN_DDKSPLIT

Revision History:

    Molly Brown (MollyBro) 21-Apr-1999
        Broke out the logging code and added command mode functionality.

// @@END_DDKSPLIT
--*/

#include <windows.h>                
#include <stdlib.h>
#include <stdio.h>
#include <winioctl.h>
#include <string.h>
#include <crtdbg.h>
#include "ioTest.h"
#include "ioTestLog.h"
#include "ioTestLib.h"

#define NT_SUCCESS(Status) ((LONG)(Status) >= 0)

#define TEST_DIRECTORY_NAME L"\\ioTest"

#define READ_TEST_FILE_NAME TEST_DIRECTORY_NAME L"\\read.txt"
#define READ_TEST_DATA L"Hello world!"

EXPECTED_OPERATION gExpectedReadOperationsTop[] = { { TOP_FILTER, IRP_MJ_CREATE },
                                                    { BOTTOM_FILTER, IRP_MJ_CREATE },
                                                    { TOP_FILTER, IRP_MJ_READ },
                                                    { BOTTOM_FILTER, IRP_MJ_READ },
                                                    { TOP_FILTER, IRP_MJ_CLEANUP },
                                                    { BOTTOM_FILTER, IRP_MJ_CLEANUP },
                                                    { BOTTOM_FILTER, IRP_MJ_MAXIMUM_FUNCTION + 1 } };
EXPECTED_OPERATION gExpectedReadOperationsDirected[] = { { BOTTOM_FILTER, IRP_MJ_CREATE },
                                                         { BOTTOM_FILTER, IRP_MJ_READ },
                                                         { BOTTOM_FILTER, IRP_MJ_CLEANUP },
                                                         { BOTTOM_FILTER, IRP_MJ_MAXIMUM_FUNCTION + 1 } };

#define WRITE_TEST_FILE_NAME TEST_DIRECTORY_NAME L"\\write.txt"
#define WRITE_TEST_DATA L"Good morning!"

EXPECTED_OPERATION gExpectedWriteOperationsTop[] = { { TOP_FILTER, IRP_MJ_CREATE },
                                                     { BOTTOM_FILTER, IRP_MJ_CREATE },
                                                     { TOP_FILTER, IRP_MJ_WRITE },
                                                     { BOTTOM_FILTER, IRP_MJ_WRITE },
                                                     { TOP_FILTER, IRP_MJ_CLEANUP },
                                                     { BOTTOM_FILTER, IRP_MJ_CLEANUP },
                                                     { BOTTOM_FILTER, IRP_MJ_MAXIMUM_FUNCTION + 1 } };
EXPECTED_OPERATION gExpectedWriteOperationsDirected[] = { { BOTTOM_FILTER, IRP_MJ_CREATE },
                                                          { BOTTOM_FILTER, IRP_MJ_WRITE },
                                                          { BOTTOM_FILTER, IRP_MJ_CLEANUP },
                                                          { BOTTOM_FILTER, IRP_MJ_MAXIMUM_FUNCTION + 1 } };

#define RENAME_SOURCE_FILE_NAME TEST_DIRECTORY_NAME L"\\renameSource.txt"
#define RENAME_TARGET_FILE_NAME TEST_DIRECTORY_NAME L"\\renameTarget.txt"

EXPECTED_OPERATION gExpectedRenameOperationsTop[] = { { TOP_FILTER, IRP_MJ_CREATE },
                                                      { BOTTOM_FILTER, IRP_MJ_CREATE },
                                                      { TOP_FILTER, IRP_MJ_SET_INFORMATION },
                                                      { BOTTOM_FILTER, IRP_MJ_SET_INFORMATION },
                                                      { TOP_FILTER, IRP_MJ_CLEANUP },
                                                      { BOTTOM_FILTER, IRP_MJ_CLEANUP },
                                                      { BOTTOM_FILTER, IRP_MJ_MAXIMUM_FUNCTION + 1 } };
EXPECTED_OPERATION gExpectedRenameOperationsDirected[] = { { BOTTOM_FILTER, IRP_MJ_CREATE },
                                                           { BOTTOM_FILTER, IRP_MJ_SET_INFORMATION },
                                                           { BOTTOM_FILTER, IRP_MJ_CLEANUP },
                                                           { BOTTOM_FILTER, IRP_MJ_MAXIMUM_FUNCTION + 1 } };

#define SHARE_FILE_NAME TEST_DIRECTORY_NAME L"\\share.txt"

EXPECTED_OPERATION gExpectedShareOperationsTop[] = { { TOP_FILTER, IRP_MJ_CREATE },
                                                     { BOTTOM_FILTER, IRP_MJ_CREATE },
                                                     { TOP_FILTER, IRP_MJ_CLEANUP },
                                                     { BOTTOM_FILTER, IRP_MJ_CLEANUP },
                                                     { BOTTOM_FILTER, IRP_MJ_MAXIMUM_FUNCTION + 1 } };
EXPECTED_OPERATION gExpectedShareOperationsDirected[] = { { BOTTOM_FILTER, IRP_MJ_CREATE },
                                                          { BOTTOM_FILTER, IRP_MJ_CLEANUP },
                                                          { BOTTOM_FILTER, IRP_MJ_MAXIMUM_FUNCTION + 1 } };
BOOL
CreateTestDirectory (
    PWCHAR DriveName,
    ULONG DriveNameLength
    )
{
    WCHAR testDirName[MAX_PATH];
    DWORD result;
    BOOL bResult;

    if (sizeof( TEST_DIRECTORY_NAME ) + DriveNameLength > MAX_PATH) {

        printf ("Can't create test directory -- name buffer too small\n");
        return FALSE;
    }

    wcscpy( testDirName, DriveName );
    wcscat( testDirName, TEST_DIRECTORY_NAME );

    bResult = CreateDirectory( testDirName,
                               NULL );

    if (!bResult) {

        result = GetLastError();
        if (result != ERROR_ALREADY_EXISTS) {

            DisplayError( result );
            return FALSE;
        }
    }

    return TRUE;
    
}

VOID
DumpTestResultBanner (
    PWCHAR TestName,
    BOOL Begin
    )
{
    if (Begin) {

        printf( "***BEGIN %S TEST RESULTS***\n", TestName );

    } else {

        printf( "***END %S TEST RESULTS***\n", TestName );
    }
}

VOID
DumpKernelResults (
    PIOTEST_STATUS TestStatus
    )
{
    printf( "Kernel verification: " );
    
    if (NT_SUCCESS( TestStatus->TestResult )) {

        printf( "\tTest PASSED\n" );
        
    } else {

        switch( TestStatus->Phase ) {
        case IoTestSetup:
            printf( "\tTest failed in SETUP phase with status 0x%08x\n",
                    TestStatus->TestResult );
            break;

        case IoTestAction:
            printf( "\tTest failed in ACTION phase with status 0x%08x\n",
                    TestStatus->TestResult );
            break;

        case IoTestValidation:
            printf( "\tTest failed in VALIDATION phase with status 0x%08x\n",
                    TestStatus->TestResult );
            break;

        case IoTestCleanup:
            printf( "\tTest failed in CLEANUP phase with status 0x%08x\n",
                    TestStatus->TestResult );
            break;

        case IoTestCompleted:
            printf( "\tTest failed in COMPLETED phase with status 0x%08x\n",
                    TestStatus->TestResult );
            break;

        default:
            printf( "\tTest failed in UNKNOWN phase with status 0x%08x\n",
                    TestStatus->TestResult );
            break;

        }
    }
}

VOID
ReadTest (
    PLOG_CONTEXT Context,
    PWCHAR DriveName,
    ULONG  DriveNameLength,
    BOOLEAN TopOfStack
    )
{
    HANDLE testFile = INVALID_HANDLE_VALUE;
    PIOTEST_READ_WRITE_PARAMETERS parms = NULL;
    DWORD parmsLength;
    IOTEST_STATUS testStatus;
    BOOL bResult;
    DWORD bytesReturned;
    DWORD result;

    bResult = CreateTestDirectory( DriveName, DriveNameLength );

    if (!bResult) {

        goto ReadTest_Cleanup;
    }

    //
    //  Setup parms
    //

    parmsLength = sizeof( IOTEST_READ_WRITE_PARAMETERS ) + sizeof( READ_TEST_DATA );
    parms = malloc (parmsLength);

    if (parms == NULL) {

        printf( "Insufficient resources to run READ test\n" );
        goto ReadTest_Cleanup;
    }

    CopyMemory( parms->DriveNameBuffer, DriveName, DriveNameLength );
    parms->DriveNameLength = DriveNameLength;

    if ((sizeof( READ_TEST_FILE_NAME ) + DriveNameLength) >
        MAX_PATH ) {

        //
        //  The READ test file name is longer than our FileNameBuffer,
        //  so return an error and quit.
        //

        printf( "READ Test file name is too long.\n" );
        goto ReadTest_Cleanup;
    }

    //
    //  We've got enough room, so build up the file name.
    //
    
    wcscpy( parms->FileNameBuffer, parms->DriveNameBuffer );
    wcscat( parms->FileNameBuffer, READ_TEST_FILE_NAME );
    parms->FileNameLength = wcslen( parms->FileNameBuffer ) * sizeof( WCHAR );

    parms->FileDataLength = sizeof( READ_TEST_DATA );
    CopyMemory( parms->FileData, READ_TEST_DATA, parms->FileDataLength );

    parms->Flags = 0;
    
    if (TopOfStack) {

        parms->Flags |= IO_TEST_TOP_OF_STACK;
    }

    //
    //  Create test file
    //

    testFile = CreateFile( parms->FileNameBuffer,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL );

    if (testFile == INVALID_HANDLE_VALUE) {

        result = GetLastError();
        printf ("Error opening READ test file.\n");
        DisplayError( result );
        goto ReadTest_Cleanup;
    }
    
    //
    //  Write data to test file
    //

    bResult = WriteFile( testFile,
                         READ_TEST_DATA,
                         sizeof( READ_TEST_DATA ),
                         &bytesReturned,
                         NULL );

    if (!bResult) {
        result = GetLastError();
        printf("ERROR writing data READ test file...\n");
        DisplayError( result );
        goto ReadTest_Cleanup;
    }

    CloseHandle( testFile );
    testFile = INVALID_HANDLE_VALUE;
        
    //
    //  Send message down to filter
    //
    
    bResult = DeviceIoControl( Context->Device,
                               IOTEST_ReadTest,
                               parms,
                               parmsLength,
                               &testStatus,
                               sizeof( testStatus ),
                               &bytesReturned,
                               NULL);
    
    if (!bResult) {
        result = GetLastError();
        printf("ERROR running READ test...\n");
        DisplayError( result );
        goto ReadTest_Cleanup;
    }

    //
    //  Print out the result of the kernel verification tests.
    //

    DumpTestResultBanner( L"READ", TRUE );
    
    DumpKernelResults( &testStatus );
    
    //
    //  Read and verify log
    //

    if (TopOfStack) {
        
        VerifyCurrentLogRecords( Context, 
                                 gExpectedReadOperationsTop );

    } else {

        VerifyCurrentLogRecords( Context, 
                                 gExpectedReadOperationsDirected );
    }    
    
    DumpTestResultBanner( L"READ", FALSE );
    
ReadTest_Cleanup:

    if (testFile != INVALID_HANDLE_VALUE) {

        CloseHandle( testFile );
    }

    if (parms != NULL) {

        free( parms );
    }

    return;
}

VOID
RenameTest (
    PLOG_CONTEXT Context,
    PWCHAR DriveName,
    ULONG  DriveNameLength,
    BOOLEAN TopOfStack
    )
{
    BOOL bResult;
    IOTEST_RENAME_PARAMETERS parms;
    IOTEST_STATUS testStatus;
    HANDLE sourceFile;
    HANDLE targetFile;
    DWORD bytesReturned;
    DWORD result;
    
    bResult = CreateTestDirectory( DriveName, DriveNameLength );

    if (!bResult) {

        goto RenameTest_Cleanup;
    }

    //
    //  Setup parameters
    //

    CopyMemory( &(parms.DriveNameBuffer), DriveName, DriveNameLength );
    parms.DriveNameLength = DriveNameLength;

    if ((sizeof( RENAME_SOURCE_FILE_NAME ) + DriveNameLength) >
        MAX_PATH ) {

        //
        //  The RENAME test source file name is longer than our 
        //  SourceFileNameBuffer, so return an error and quit.
        //

        printf( "RENAME Test source file name is too long.\n" );
        goto RenameTest_Cleanup;
    }

    //
    //  We've got enough room, so build up the source file name.
    //
    
    wcscpy( parms.SourceFileNameBuffer, parms.DriveNameBuffer );
    wcscat( parms.SourceFileNameBuffer, RENAME_SOURCE_FILE_NAME );
    parms.SourceFileNameLength = wcslen( parms.SourceFileNameBuffer ) * sizeof( WCHAR );
    
    if ((sizeof( RENAME_TARGET_FILE_NAME ) + DriveNameLength) >
        MAX_PATH ) {

        //
        //  The RENAME test target file name is longer than our 
        //  TargetFileNameBuffer, so return an error and quit.
        //

        printf( "RENAME Test target file name is too long.\n" );
        goto RenameTest_Cleanup;
    }

    //
    //  We've got enough room, so build up the source file name.
    //
    
    wcscpy( parms.TargetFileNameBuffer, parms.DriveNameBuffer );
    wcscat( parms.TargetFileNameBuffer, RENAME_TARGET_FILE_NAME );
    parms.TargetFileNameLength = wcslen( parms.TargetFileNameBuffer ) * sizeof( WCHAR );

    parms.Flags = 0;
    
    if (TopOfStack) {

        parms.Flags |= IO_TEST_TOP_OF_STACK;
    }

    //
    //  Setup source file
    //

    sourceFile = CreateFile( RENAME_SOURCE_FILE_NAME,
                             GENERIC_WRITE,
                             0,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL );

    if (sourceFile == INVALID_HANDLE_VALUE) {

        result = GetLastError();
        printf ("Error opening RENAME test source file.\n");
        DisplayError( result );
        goto RenameTest_Cleanup;
    }

    CloseHandle( sourceFile );
    sourceFile = INVALID_HANDLE_VALUE;

    //
    //  Make sure that the target file does NOT exist.
    //
    
    targetFile = CreateFile( RENAME_TARGET_FILE_NAME,
                             GENERIC_ALL,
                             0,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_DELETE_ON_CLOSE,
                             NULL );

    if (targetFile == INVALID_HANDLE_VALUE) {

        result = GetLastError();

        if (result != ERROR_ALREADY_EXISTS &&
            result != ERROR_FILE_NOT_FOUND) {
            
            printf ("Error opening RENAME test target file.\n");
            DisplayError( result );
            goto RenameTest_Cleanup;
        }
        
    } else {

        //
        //  The file does exist, so lets delete by closing the handle.
        //

        CloseHandle( targetFile );
        targetFile = INVALID_HANDLE_VALUE;
    }

    //
    //  Send message down to filter
    //
    
    bResult = DeviceIoControl( Context->Device,
                               IOTEST_RenameTest,
                               &parms,
                               sizeof( parms ),
                               &testStatus,
                               sizeof( testStatus ),
                               &bytesReturned,
                               NULL);
    
    if (!bResult) {
        result = GetLastError();
        printf("ERROR running RENAME test...\n");
        DisplayError( result );
        goto RenameTest_Cleanup;
    }

    //
    //  Display test results.
    //

    DumpTestResultBanner( L"RENAME", TRUE );

    DumpKernelResults( &testStatus );

    //
    //  Read and verify logs
    //
    
    if (TopOfStack) {
        
        VerifyCurrentLogRecords( Context, 
                                 gExpectedRenameOperationsTop );

    } else {

        VerifyCurrentLogRecords( Context, 
                                 gExpectedRenameOperationsDirected );
    }    
    
    //
    //  Verify that the sourceFile is no longer present.
    //

    sourceFile = CreateFile( RENAME_SOURCE_FILE_NAME,
                             GENERIC_ALL,
                             0,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_DELETE_ON_CLOSE,
                             NULL );

    if (sourceFile == INVALID_HANDLE_VALUE) {

        printf( "User test verification:\tPASSED - Source file no longer present.\n" );

    } else {
    
        printf( "User test verification:\tFAILED - Source test file still exists.\n" );
        CloseHandle( sourceFile );
    }

    //
    //  Verify that the targetFile is present
    //
    
    targetFile = CreateFile( RENAME_TARGET_FILE_NAME,
                             GENERIC_ALL,
                             0,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_DELETE_ON_CLOSE,
                             NULL );

    if (targetFile == INVALID_HANDLE_VALUE) {

        result = GetLastError();
        
        printf( "User test verification:\tFAILED - Unexpected error trying to open target file %d.\n",
                result );
        
    } else {
    
        printf( "User test verification:\tPASSED - Target test file exists.\n" );
        CloseHandle( targetFile );
        targetFile = INVALID_HANDLE_VALUE;
    }

    DumpTestResultBanner( L"RENAME", FALSE );
                             
RenameTest_Cleanup:

    if (sourceFile != INVALID_HANDLE_VALUE) {

        CloseHandle( sourceFile );
    }

    if (targetFile != INVALID_HANDLE_VALUE) {

        CloseHandle( targetFile );
    }

    return;
}

VOID
ShareTest (
    PLOG_CONTEXT Context,
    PWCHAR DriveName,
    ULONG  DriveNameLength,
    BOOLEAN TopOfStack
    )
{
    BOOL bResult;
    IOTEST_SHARE_PARAMETERS parms;
    IOTEST_STATUS testStatus;
    HANDLE file;
    DWORD bytesReturned;
    DWORD result;
    
    bResult = CreateTestDirectory( DriveName, DriveNameLength );

    if (!bResult) {

        goto ShareTest_Cleanup;
    }

    //
    //  Setup parameters
    //

    CopyMemory( &(parms.DriveNameBuffer), DriveName, DriveNameLength );
    parms.DriveNameLength = DriveNameLength;

    if ((sizeof( SHARE_FILE_NAME ) + DriveNameLength) >
        MAX_PATH ) {

        //
        //  The RENAME test source file name is longer than our 
        //  SourceFileNameBuffer, so return an error and quit.
        //

        printf( "SHARE Test file name is too long.\n" );
        goto ShareTest_Cleanup;
    }

    //
    //  We've got enough room, so build up the source file name.
    //
    
    wcscpy( parms.FileNameBuffer, parms.DriveNameBuffer );
    wcscat( parms.FileNameBuffer, SHARE_FILE_NAME );
    parms.FileNameLength = wcslen( parms.FileNameBuffer ) * sizeof( WCHAR );

    parms.Flags = 0;
    
    if (TopOfStack) {

        parms.Flags |= IO_TEST_TOP_OF_STACK;
    }
    
    //
    //  Setup source file
    //

    file = CreateFile( SHARE_FILE_NAME,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL );

    if (file == INVALID_HANDLE_VALUE) {

        result = GetLastError();
        printf ("Error opening SHARE test file.\n");
        DisplayError( result );
        goto ShareTest_Cleanup;
    }

    //
    //  Send message down to filter
    //
    
    bResult = DeviceIoControl( Context->Device,
                               IOTEST_ShareTest,
                               &parms,
                               sizeof( parms ),
                               &testStatus,
                               sizeof( testStatus ),
                               &bytesReturned,
                               NULL);
    
    if (!bResult) {
        result = GetLastError();
        printf("ERROR running SHARE test...\n");
        DisplayError( result );
        goto ShareTest_Cleanup;
    }

    //
    //  Display test results.
    //

    DumpTestResultBanner( L"SHARE", TRUE );

    DumpKernelResults( &testStatus );

    //
    //  Read and verify logs
    //
    
    if (TopOfStack) {
        
        VerifyCurrentLogRecords( Context, 
                                 gExpectedShareOperationsTop );

    } else {

        VerifyCurrentLogRecords( Context, 
                                 gExpectedShareOperationsDirected );
    }    
    
    DumpTestResultBanner( L"SHARE", FALSE );
                             
ShareTest_Cleanup:

    if (file != INVALID_HANDLE_VALUE) {

        CloseHandle( file );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\latency\filter\latlib.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    latLib.c

Abstract:

    This file contains all the support routines for the Latency Filter.
    
Author:

    Molly Brown (mollybro)  

Environment:

    Kernel mode

--*/

#include <latKernel.h>

////////////////////////////////////////////////////////////////////////
//                                                                    //
//         Helper routine for reading inital driver parameters        //
//         from registry.                                             //
//                                                                    //
////////////////////////////////////////////////////////////////////////

VOID
LatReadDriverParameters (
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine tries to read the Latency-specific parameters from
    the registry.  These values will be found in the registry location
    indicated by the RegistryPath passed in.

Arguments:

    RegistryPath - the path key which contains the values that are
        the Latency parameters

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER( RegistryPath );
/*
    OBJECT_ATTRIBUTES attributes;
    HANDLE driverRegKey;
    NTSTATUS status;
    ULONG bufferSize, resultLength;
    PVOID buffer = NULL;
    UNICODE_STRING valueName;
    PKEY_VALUE_PARTIAL_INFORMATION pValuePartialInfo;

    //
    //  All the global values are already set to default values.  Any
    //  values we read from the registry will override these defaults.
    //
    
    //
    //  Do the initial setup to start reading from the registry.
    //

    InitializeObjectAttributes( &attributes,
								RegistryPath,
								OBJ_CASE_INSENSITIVE,
								NULL,
								NULL);

    status = ZwOpenKey( &driverRegKey,
						KEY_READ,
						&attributes);

    if (!NT_SUCCESS(status)) {

        driverRegKey = NULL;
        goto SpyReadDriverParameters_Exit;
    }

    bufferSize = sizeof( KEY_VALUE_PARTIAL_INFORMATION ) + sizeof( ULONG );
    buffer = ExAllocatePool( NonPagedPool, bufferSize );

    if (NULL == buffer) {

        goto SpyReadDriverParameters_Exit;
    }

    //
    // Read the gMaxRecordsToAllocate from the registry
    //

    RtlInitUnicodeString(&valueName, MAX_RECORDS_TO_ALLOCATE);

    status = ZwQueryValueKey( driverRegKey,
							  &valueName,
							  KeyValuePartialInformation,
							  buffer,
							  bufferSize,
							  &resultLength);

    if (NT_SUCCESS(status)) {

        pValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
        ASSERT(pValuePartialInfo->Type == REG_DWORD);
        gMaxRecordsToAllocate = *((PLONG)&(pValuePartialInfo->Data));

    }

    //
    // Read the gMaxNamesToAllocate from the registry
    //

    RtlInitUnicodeString(&valueName, MAX_NAMES_TO_ALLOCATE);

    status = ZwQueryValueKey( driverRegKey,
							  &valueName,
							  KeyValuePartialInformation,
							  buffer,
							  bufferSize,
							  &resultLength);

    if (NT_SUCCESS(status)) {

        pValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
        ASSERT(pValuePartialInfo->Type == REG_DWORD);
        gMaxNamesToAllocate = *((PLONG)&(pValuePartialInfo->Data));

    }

    //
    // Read the initial debug setting from the registry
    //

    RtlInitUnicodeString(&valueName, DEBUG_LEVEL);

    status = ZwQueryValueKey( driverRegKey,
                              &valueName,
                              KeyValuePartialInformation,
                              buffer,
                              bufferSize,
                              &resultLength );

    if (NT_SUCCESS( status )) {

        pValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
        ASSERT( pValuePartialInfo->Type == REG_DWORD );
        gFileSpyDebugLevel = *((PULONG)&(pValuePartialInfo->Data));
        
    }
    
    //
    // Read the attachment mode setting from the registry
    //

    RtlInitUnicodeString(&valueName, ATTACH_MODE);

    status = ZwQueryValueKey( driverRegKey,
                              &valueName,
                              KeyValuePartialInformation,
                              buffer,
                              bufferSize,
                              &resultLength );

    if (NT_SUCCESS( status )) {

        pValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
        ASSERT( pValuePartialInfo->Type == REG_DWORD );
        gFileSpyAttachMode = *((PULONG)&(pValuePartialInfo->Data));
        
    }
    
    goto SpyReadDriverParameters_Exit;

SpyReadDriverParameters_Exit:

    if (NULL != buffer) {

        ExFreePool(buffer);
    }

    if (NULL != driverRegKey) {

        ZwClose(driverRegKey);
    }

    return;
*/
}

BOOLEAN
LatShouldPendThisIo (
    IN PLATENCY_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine checks to see if this operation should be pending.
    This decision is based on the operation state for this device,
    if this operation is allowed to be pended, and, if random failure is
    set, if this operation should fail based on random failure rate.

Argument:

    DeviceExtension - The latency device extension for this
        device object.

    Irp - The irp for this operation.

Return Value:

    TRUE if this operation should be pended, or FALSE otherwise.

--*/
{
    BOOLEAN returnValue = FALSE;
    ULONG operation
    PIO_STACK_LOCATION irpSp;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//         Common attachment and detachment routines                  //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
LatAttachToFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
    )
/*++

Routine Description:

    This will attach to the given file system device object.  We attach to
    these devices so we will know when new devices are mounted.

Arguments:

    DeviceObject - The device to attach to

    Name - An already initialized unicode string used to retrieve names.
        NOTE:  The only reason this parameter is passed in is to conserve         
        stack space.  In most cases, the caller to this function has already
        allocated a buffer to temporarily store the device name and there
        is no reason this function and the functions it calls can't share
        the same buffer.

Return Value:

    Status of the operation

--*/
{
    PDEVICE_OBJECT latencyDeviceObject;
    PDEVICE_OBJECT attachedToDevObj;
    PLATENCY_DEVICE_EXTENSION devExt;
    UNICODE_STRING fsrecName;
    NTSTATUS status;

    PAGED_CODE();

    //
    //  See if this is a file system we care about.  If not, return.
    //

    if (!IS_DESIRED_DEVICE_TYPE(DeviceObject->DeviceType)) {

        return STATUS_SUCCESS;
    }

    //
    //  See if this is Microsoft's file system recognizer device (see if the name of the
    //  driver is the FS_REC driver).  If so skip it.  We don't need to 
    //  attach to file system recognizer devices since we can just wait for the
    //  real file system driver to load.  Therefore, if we can identify them, we won't
    //  attach to them.
    //

    RtlInitUnicodeString( &fsrecName, L"\\FileSystem\\Fs_Rec" );
    LatGetObjectName( DeviceObject->DriverObject, Name );
    
    if (RtlCompareUnicodeString( Name, &fsrecName, TRUE ) == 0) {

        return STATUS_SUCCESS;
    }

    //
    //  Create a new device object we can attach with
    //

    status = IoCreateDevice( Globals.DriverObject,
                             sizeof( LATENCY_DEVICE_EXTENSION ),
                             (PUNICODE_STRING) NULL,
                             DeviceObject->DeviceType,
                             0,
                             FALSE,
                             &latencyDeviceObject );

    if (!NT_SUCCESS( status )) {

        LAT_DBG_PRINT0( DEBUG_ERROR,
                        "LATENCY (LatAttachToFileSystem): Could not create a Latency Filter device object to attach to the filesystem.\n" );
        return status;
    }

    //
    //  Do the attachment
    //

    attachedToDevObj = IoAttachDeviceToDeviceStack( latencyDeviceObject, DeviceObject );

    if (attachedToDevObj == NULL) {

        LAT_DBG_PRINT0( DEBUG_ERROR,
                        "LATENCY (LatAttachToFileSystem): Could not attach Latency Filter to the filesystem control device object.\n" );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorCleanupDevice;
    }

    //
    //  Finish initializing our device extension
    //

    devExt = latencyDeviceObject->DeviceExtension;
    devExt->AttachedToDeviceObject = attachedToDevObj;

    //
    //  Propagate flags from Device Object we attached to
    //

    if ( FlagOn( attachedToDevObj->Flags, DO_BUFFERED_IO )) {

        SetFlag( latencyDeviceObject->Flags, DO_BUFFERED_IO );
    }

    if ( FlagOn( attachedToDevObj->Flags, DO_DIRECT_IO )) {

        SetFlag( latencyDeviceObject->Flags, DO_DIRECT_IO );
    }

    //
    //  Since this is an attachment to a file system control device object
    //  we are not going to log anything, but properly initialize our
    //  extension.
    //

    LatResetDeviceExtension( devExt );
    devExt->Enabled= FALSE;
    devExt->IsVolumeDeviceObject = FALSE;

    RtlInitEmptyUnicodeString( &(devExt->DeviceNames),
                               devExt->DeviceNamesBuffer,
                               sizeof( devExt->DeviceNamesBuffer ) );
                               
    RtlInitEmptyUnicodeString( &(devExt->UserNames),
                               devExt->UserNamesBuffer,
                               sizeof( devExt->UserNamesBuffer ) );
                               
    ClearFlag( latencyDeviceObject->Flags, DO_DEVICE_INITIALIZING );

    //
    //  Display who we have attached to
    //

    if (FlagOn( Globals.DebugLevel, DEBUG_DISPLAY_ATTACHMENT_NAMES )) {

        LatCacheDeviceName( latencyDeviceObject );
        DbgPrint( "LATENCY (LatAttachToFileSystem): Attaching to file system   \"%.*S\" (%s)\n",
                  devExt->DeviceNames.Length / sizeof( WCHAR ),
                  devExt->DeviceNames.Buffer,
                  GET_DEVICE_TYPE_NAME(latencyDeviceObject->DeviceType) );
    }

    //
    //  Enumerate all the mounted devices that currently
    //  exist for this file system and attach to them.
    //

    status = LatEnumerateFileSystemVolumes( DeviceObject, Name );

    if (!NT_SUCCESS( status )) {

        LAT_DBG_PRINT3( DEBUG_ERROR,
                        "LATENCY (LatAttachToFileSystem): Error attaching to existing volumes for \"%.*S\", status=%08x\n",
                        devExt->DeviceNames.Length / sizeof( WCHAR ),
                        devExt->DeviceNames.Buffer,
                        status );

        goto ErrorCleanupAttachment;
    }

    return STATUS_SUCCESS;

    /////////////////////////////////////////////////////////////////////
    //                  Cleanup error handling
    /////////////////////////////////////////////////////////////////////

    ErrorCleanupAttachment:
        IoDetachDevice( latencyDeviceObject );

    ErrorCleanupDevice:
        IoDeleteDevice( latencyDeviceObject );

    return status;
}

VOID
LatDetachFromFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Given a base file system device object, this will scan up the attachment
    chain looking for our attached device object.  If found it will detach
    us from the chain.

Arguments:

    DeviceObject - The file system device to detach from.

Return Value:

--*/ 
{
    PDEVICE_OBJECT ourAttachedDevice;
    PLATENCY_DEVICE_EXTENSION devExt;

    PAGED_CODE();

    //
    //  We have to iterate through the device objects in the filter stack
    //  attached to DeviceObject.  If we are attached to this filesystem device
    //  object, We should be at the top of the stack, but there is no guarantee.
    //  If we are in the stack and not at the top, we can safely call IoDetachDevice
    //  at this time because the IO Manager will only really detach our device
    //  object from the stack at a safe time.
    //

    //
    //  Skip the base file system device object (since it can't be us)
    //

    ourAttachedDevice = DeviceObject->AttachedDevice;

    while (NULL != ourAttachedDevice) {

        if (IS_MY_DEVICE_OBJECT( ourAttachedDevice )) {

            devExt = ourAttachedDevice->DeviceExtension;

            //
            //  Display who we detached from
            //

            LAT_DBG_PRINT3( DEBUG_DISPLAY_ATTACHMENT_NAMES,
                            "LATENCY (LatDetachFromFileSystem): Detaching from file system \"%.*S\" (%s)\n",
                            devExt->DeviceNames.Length / sizeof( WCHAR ),
                            devExt->DeviceNames.Buffer,
                            GET_DEVICE_TYPE_NAME(ourAttachedDevice->DeviceType) );
                                
            //
            //  Detach us from the object just below us
            //  Cleanup and delete the object
            //

            IoDetachDevice( DeviceObject );
            IoDeleteDevice( ourAttachedDevice );

            return;
        }

        //
        //  Look at the next device up in the attachment chain
        //

        DeviceObject = ourAttachedDevice;
        ourAttachedDevice = ourAttachedDevice->AttachedDevice;
    }
}

NTSTATUS
LatEnumerateFileSystemVolumes (
    IN PDEVICE_OBJECT FSDeviceObject,
    IN PUNICODE_STRING Name
    ) 
/*++

Routine Description:

    Enumerate all the mounted devices that currently exist for the given file
    system and attach to them.  We do this because this filter could be loaded
    at any time and there might already be mounted volumes for this file system.

Arguments:

    FSDeviceObject - The device object for the file system we want to enumerate

    Name - An already initialized unicode string used to retrieve names

Return Value:

    The status of the operation

--*/
{
    PDEVICE_OBJECT latencyDeviceObject;
    PDEVICE_OBJECT *devList;
    PDEVICE_OBJECT diskDeviceObject;
    NTSTATUS status;
    ULONG numDevices;
    ULONG i;

    PAGED_CODE();

    //
    //  Find out how big of an array we need to allocate for the
    //  mounted device list.
    //

    status = IoEnumerateDeviceObjectList( FSDeviceObject->DriverObject,
                                          NULL,
                                          0,
                                          &numDevices);

    //
    //  We only need to get this list of there are devices.  If we
    //  don't get an error there are no devices so go on.
    //

    if (!NT_SUCCESS( status )) {

        ASSERT(STATUS_BUFFER_TOO_SMALL == status);

        //
        //  Allocate memory for the list of known devices
        //

        numDevices += 8;        //grab a few extra slots

        devList = ExAllocatePoolWithTag( NonPagedPool, 
                                         (numDevices * sizeof(PDEVICE_OBJECT)), 
                                         LATENCY_POOL_TAG );
        if (NULL == devList) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Now get the list of devices.  If we get an error again
        //  something is wrong, so just fail.
        //

        status = IoEnumerateDeviceObjectList(
                        FSDeviceObject->DriverObject,
                        devList,
                        (numDevices * sizeof(PDEVICE_OBJECT)),
                        &numDevices);

        if (!NT_SUCCESS( status ))  {

            ExFreePool( devList );
            return status;
        }

        //
        //  Walk the given list of devices and attach to them if we should.
        //

        for (i=0; i < numDevices; i++) {

            //
            //  Do not attach if:
            //      - This is the control device object (the one passed in)
            //      - We are already attached to it
            //

            if ((devList[i] != FSDeviceObject) && 
                !LatIsAttachedToDevice( devList[i], NULL )) {

                //
                //  See if this device has a name.  If so, then it must
                //  be a control device so don't attach to it.  This handles
                //  drivers with more then one control device.
                //

                LatGetBaseDeviceObjectName( devList[i], Name );

                if (Name->Length <= 0) {

                    //
                    //  Get the disk device object associated with this
                    //  file  system device object.  Only try to attach if we
                    //  have a disk device object.
                    //

                    status = IoGetDiskDeviceObject( devList[i], &diskDeviceObject );

                    if (NT_SUCCESS( status )) {

                        //
                        //  Allocate a new device object to attach with
                        //

                        status = IoCreateDevice( Globals.DriverObject,
                                                 sizeof( LATENCY_DEVICE_EXTENSION ),
                                                 (PUNICODE_STRING) NULL,
                                                 devList[i]->DeviceType,
                                                 0,
                                                 FALSE,
                                                 &latencyDeviceObject );

                        if (NT_SUCCESS( status )) {

                            //
                            //  Attach to this device object
                            //

                            status = LatAttachToMountedDevice( devList[i], 
                                                               latencyDeviceObject,
                                                               diskDeviceObject );

                            //
                            //  This should succeed.
                            //

                            ASSERT( NT_SUCCESS( status ) );

                            //
                            //  Finished all initialization of the new device
                            //  object,  so clear the initializing flag now.
                            //

                            ClearFlag( latencyDeviceObject->Flags, DO_DEVICE_INITIALIZING );
                            
                        } else {

                            LAT_DBG_PRINT0( DEBUG_ERROR,
                                            "LATENCY (LatEnumberateFileSystemVolumes): Cannot attach Latency device object to volume.\n" );
                        }
                        
                        //
                        //  Remove reference added by IoGetDiskDeviceObject.
                        //  We only need to hold this reference until we are
                        //  successfully attached to the current volume.  Once
                        //  we are successfully attached to devList[i], the
                        //  IO Manager will make sure that the underlying
                        //  diskDeviceObject will not go away until the file
                        //  system stack is torn down.
                        //

                        ObDereferenceObject( diskDeviceObject );
                    }
                }
            }

            //
            //  Dereference the object (reference added by 
            //  IoEnumerateDeviceObjectList)
            //

            ObDereferenceObject( devList[i] );
        }

        //
        //  We are going to ignore any errors received while mounting.  We
        //  simply won't be attached to those volumes if we get an error
        //

        status = STATUS_SUCCESS;

        //
        //  Free the memory we allocated for the list
        //

        ExFreePool( devList );
    }

    return status;
}

BOOLEAN
LatIsAttachedToDevice (
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL
    )
/*++

Routine Description:

    This walks down the attachment chain looking for a device object that
    belongs to this driver.  If one is found, the attached device object
    is returned in AttachedDeviceObject.

    Note:  If AttachedDeviceObject is returned with a non-NULL value,
      there is a reference on the AttachedDeviceObject that must
      be cleared by the caller.

Arguments:

    DeviceObject - The device chain we want to look through

    AttachedDeviceObject - Set to the deviceObject which Latency
        has previously attached to DeviceObject.

Return Value:

    TRUE if we are attached, FALSE if not

--*/
{
    PDEVICE_OBJECT currentDevObj;
    PDEVICE_OBJECT nextDevObj;

    currentDevObj = IoGetAttachedDeviceReference( DeviceObject );

    //
    //  CurrentDevObj has the top of the attachment chain.  Scan
    //  down the list to find our device object.

    do {
    
        if (IS_MY_DEVICE_OBJECT( currentDevObj )) {

            if (NULL != AttachedDeviceObject) {

                *AttachedDeviceObject = currentDevObj;
            }

            return TRUE;
        }

        //
        //  Get the next attached object.  This puts a reference on 
        //  the device object.
        //

        nextDevObj = IoGetLowerDeviceObject( currentDevObj );

        //
        //  Dereference our current device object, before
        //  moving to the next one.
        //

        ObDereferenceObject( currentDevObj );

        currentDevObj = nextDevObj;
        
    } while (NULL != currentDevObj);
    
    return FALSE;
}

NTSTATUS
LatAttachToMountedDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT LatencyDeviceObject,
    IN PDEVICE_OBJECT DiskDeviceObject
    )
/*++

Routine Description:

    This routine will attach the LatencyDeviceObject to the filter stack
    that DeviceObject is in.

    NOTE:  If there is an error in attaching, the caller is responsible
        for deleting the LatencyDeviceObject.
    
Arguments:

    DeviceObject - A device object in the stack to which we want to attach.

    LatencyDeviceObject - The latency device object that has been created
        to attach to this filter stack.

	DiskDeviceObject - The device object for the disk device of this
		stack.
        
Return Value:

    Returns STATUS_SUCCESS if the latency deviceObject could be attached,
    otherwise an appropriate error code is returned.
    
--*/
{
    PLATENCY_DEVICE_EXTENSION devext;
    NTSTATUS status = STATUS_SUCCESS;

    ASSERT( IS_MY_DEVICE_OBJECT( LatencyDeviceObject ) );
    ASSERT( !LatIsAttachedToDevice ( DeviceObject, NULL ) );
    
    devext = LatencyDeviceObject->DeviceExtension;

    devext->AttachedToDeviceObject = IoAttachDeviceToDeviceStack( LatencyDeviceObject,
                                                                  DeviceObject );

    if (devext->AttachedToDeviceObject == NULL ) {

        status = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        //
        //  Do all common initializing of the device extension
        //

        //
        //  We just want to attach to the device, but not actually
        //  start adding latency.
        //
        
        devext->Enabled = FALSE;

        RtlInitEmptyUnicodeString( &(devext->DeviceNames), 
                                   devext->DeviceNamesBuffer, 
                                   sizeof( devext->DeviceNamesBuffer ) );
        RtlInitEmptyUnicodeString( &(devext->UserNames),
                                   devext->UserNamesBuffer,
                                   sizeof( devext->UserNamesBuffer ) );

        //
        //  Store off the DiskDeviceObject.  We shouldn't need it
        //  later since we have already successfully attached to the
        //  filter stack, but it may be helpful for debugging.
        //  
        
        devext->DiskDeviceObject = DiskDeviceObject;                         

        //
        //  Try to get the device name so that we can store it in the
        //  device extension.
        //

        LatCacheDeviceName( LatencyDeviceObject );

        LAT_DBG_PRINT2( DEBUG_DISPLAY_ATTACHMENT_NAMES,
                        "LATENCY (LatAttachToMountedDevice): Attaching to volume     \"%.*S\"\n",
                        devext->DeviceNames.Length / sizeof( WCHAR ),
                        devext->DeviceNames.Buffer );

        //
        //  Set our deviceObject flags based on the 
        //  flags send in the next driver's device object.
        //
        
        if (FlagOn( DeviceObject->Flags, DO_BUFFERED_IO )) {

            SetFlag( LatencyDeviceObject->Flags, DO_BUFFERED_IO );
        }

        if (FlagOn( DeviceObject->Flags, DO_DIRECT_IO )) {

            SetFlag( LatencyDeviceObject->Flags, DO_DIRECT_IO );
        }

        //
        //  Add this device to our attachment list
        //

        devext->IsVolumeDeviceObject = TRUE;

        ExAcquireFastMutex( &Globals.DeviceExtensionListLock );
        InsertTailList( &Globals.DeviceExtensionList, devext->NextLatencyDeviceLink );
        ExReleaseFastMutex( &Globals.DeviceExtensionListLock );
    }

    return status;
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//               Device name tracking helper routines                 //
//                                                                    //
////////////////////////////////////////////////////////////////////////

VOID
LatGetObjectName (
    IN PVOID Object,
    IN OUT PUNICODE_STRING Name
    )
/*++

Routine Description:

    This routine will return the name of the given object.
    If a name can not be found an empty string will be returned.

Arguments:

    Object - The object whose name we want

    Name - A unicode string that is already initialized with a buffer

Return Value:

    None

--*/
{
    NTSTATUS status;
    CHAR nibuf[512];        //buffer that receives NAME information and name
    POBJECT_NAME_INFORMATION nameInfo = (POBJECT_NAME_INFORMATION)nibuf;
    ULONG retLength;

    status = ObQueryNameString( Object, nameInfo, sizeof(nibuf), &retLength);

    Name->Length = 0;
    if (NT_SUCCESS( status )) {

        RtlCopyUnicodeString( Name, &nameInfo->Name );
    }
}

VOID
LatGetBaseDeviceObjectName (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
    )
/*++

Routine Description:

    This locates the base device object in the given attachment chain and then
    returns the name of that object.

    If no name can be found, an empty string is returned.

Arguments:

    Object - The object whose name we want

    Name - A unicode string that is already initialized with a buffer

Return Value:

    None

--*/
{
    //
    //  Get the base file system device object
    //

    DeviceObject = IoGetDeviceAttachmentBaseRef( DeviceObject );

    //
    //  Get the name of that object
    //

    LatGetObjectName( DeviceObject, Name );

    //
    //  Remove the reference added by IoGetDeviceAttachmentBaseRef
    //

    ObDereferenceObject( DeviceObject );
}

VOID
LatCacheDeviceName (
    IN PDEVICE_OBJECT DeviceObject
    ) 
/*++

Routine Description:

    This routines tries to set a name into the device extension of the given
    device object. 
    
    It will try and get the name from:
        - The device object
        - The disk device object if there is one

Arguments:

    DeviceObject - The object we want a name for

Return Value:

    None

--*/
{
    PLATENCY_DEVICE_EXTENSION devExt;

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    devExt = DeviceObject->DeviceExtension;

    //
    //  Get the name of the given device object.
    //

    LatGetBaseDeviceObjectName( DeviceObject, &(devExt->DeviceNames) );

    //
    //  If we didn't get a name and there is a REAL device object, lookup
    //  that name.
    //

    if ((devExt->DeviceNames.Length <= 0) && (NULL != devExt->DiskDeviceObject)) {

        LatGetObjectName( devExt->DiskDeviceObject, &(devExt->DeviceNames) );
    }
}


////////////////////////////////////////////////////////////////////////
//                                                                    //
//           Helper routine for turning on/off logging on demand      //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
LatGetDeviceObjectFromName (
    IN PUNICODE_STRING DeviceName,
    OUT PDEVICE_OBJECT *DeviceObject
    )
/*++

Routine Description:

    This routine
    
Arguments:

    DeviceName - Name of device for which we want the deviceObject.
    DeviceObject - Set to the DeviceObject for this device name if
        we can successfully retrieve it.

    Note:  If the DeviceObject is returned, it is returned with a
        reference that must be cleared by the caller once the caller
        is finished with it.

Return Value:

    STATUS_SUCCESS if the deviceObject was retrieved from the
    name, and an error code otherwise.
    
--*/
{
    WCHAR nameBuf[DEVICE_NAMES_SZ];
    UNICODE_STRING volumeNameUnicodeString;
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK openStatus;
    PFILE_OBJECT volumeFileObject;
    HANDLE fileHandle;
    PDEVICE_OBJECT nextDeviceObject;

    RtlInitEmptyUnicodeString( &volumeNameUnicodeString, nameBuf, sizeof( nameBuf ) );
    RtlAppendUnicodeToString( &volumeNameUnicodeString, L"\\DosDevices\\" );
    RtlAppendUnicodeStringToString( &volumeNameUnicodeString, DeviceName );

    InitializeObjectAttributes( &objectAttributes,
								&volumeNameUnicodeString,
								OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
								NULL,
								NULL);

    //
	// open the file object for the given device
	//

    status = ZwCreateFile( &fileHandle,
						   SYNCHRONIZE|FILE_READ_DATA,
						   &objectAttributes,
						   &openStatus,
						   NULL,
						   0,
						   FILE_SHARE_READ|FILE_SHARE_WRITE,
						   FILE_OPEN,
						   FILE_SYNCHRONOUS_IO_NONALERT,
						   NULL,
						   0);

    if(!NT_SUCCESS( status )) {

        return status;
    }

	//
    // get a pointer to the volumes file object
	//

    status = ObReferenceObjectByHandle( fileHandle,
										FILE_READ_DATA,
										*IoFileObjectType,
										KernelMode,
										&volumeFileObject,
										NULL);

    if(!NT_SUCCESS( status )) {

        ZwClose( fileHandle );
        return status;
    }

	//
    // Get the device object we want to attach to (parent device object in chain)
	//

    nextDeviceObject = IoGetRelatedDeviceObject( volumeFileObject );
    
    if (nextDeviceObject == NULL) {

        ObDereferenceObject( volumeFileObject );
        ZwClose( fileHandle );

        return status;
    }

    ObDereferenceObject( volumeFileObject );
    ZwClose( fileHandle );

    ASSERT( NULL != DeviceObject );

    ObReferenceObject( nextDeviceObject );
    
    *DeviceObject = nextDeviceObject;

    return STATUS_SUCCESS;
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                    Start/stop logging routines                     //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
LatEnable (
    IN PDEVICE_OBJECT DeviceObject,
    IN PWSTR UserDeviceName
    )
/*++

Routine Description:

    This routine ensures that we are attached to the specified device
    then turns on logging for that device.
    
    Note:  Since all network drives through LAN Manager are represented by _
        one_ device object, we want to only attach to this device stack once
        and use only one device extension to represent all these drives.
        Since Latency does not do anything to filter I/O on the LAN Manager's
        device object to only log the I/O to the requested drive, the user
        will see all I/O to a network drive it he/she is attached to a
        network drive.

Arguments:

    DeviceObject - Device object for LATENCY driver

    UserDeviceName - Name of device for which logging should be started
    
Return Value:

    STATUS_SUCCESS if the logging has been successfully started, or
    an appropriate error code if the logging could not be started.
    
--*/
{
    UNICODE_STRING userDeviceName;
    NTSTATUS status;
    PLATENCY_DEVICE_EXTENSION devext;
    PDEVICE_OBJECT nextDeviceObject;
    PDEVICE_OBJECT latencyDeviceObject;
    PDEVICE_OBJECT diskDeviceObject;

    UNREFERENCED_PARAMETER( DeviceObject );
    
    //
    //  Check to see if we have previously attached to this device by
    //  opening this device name then looking through its list of attached
    //  devices.
    //

    RtlInitUnicodeString( &userDeviceName, UserDeviceName );

    status = LatGetDeviceObjectFromName( &userDeviceName, &nextDeviceObject );

    if (!NT_SUCCESS( status )) {

        //
        //  There was an error, so return the error code.
        //
        
        return status;
    }

    if (LatIsAttachedToDevice( nextDeviceObject, &latencyDeviceObject )) {

        //
        //  We are already attached, so just make sure that logging is turned on
        //  for this device.
        //

        ASSERT( NULL != latencyDeviceObject );

        devext = latencyDeviceObject->DeviceExtension;
        devext->Enabled = TRUE;

/* ISSUE-2000-09-21-mollybro 

    TODO: Straighten out this name issue.
*/

//        LatStoreUserName( devext, &userDeviceName );

        //
        //  Clear the reference that was returned from LatIsAttachedToDevice.
        //
        
        ObDereferenceObject( latencyDeviceObject );
        
    } else {

        //
        //  We are not already attached, so create a latency device object and
        //  attach it to this device object.
        //

        //
        //  Create a new device object so we can attach it in the filter stack
        //
        
        status = IoCreateDevice( Globals.DriverObject,
								 sizeof( LATENCY_DEVICE_EXTENSION ),
								 NULL,
								 nextDeviceObject->DeviceType,
								 0,
								 FALSE,
								 &latencyDeviceObject );

        if (!NT_SUCCESS( status )) {

            ObDereferenceObject( nextDeviceObject );
            return status;
        }

        //
        //  Get the disk device object associated with this
        //  file  system device object.  Only try to attach if we
        //  have a disk device object.  If the device does not
        //  have a disk device object, it is a control device object
        //  for a driver and we don't want to attach to those
        //  device objects.
        //

        status = IoGetDiskDeviceObject( nextDeviceObject, &diskDeviceObject );

        if (!NT_SUCCESS( status )) {

            LAT_DBG_PRINT2( DEBUG_ERROR,
                            "LATENCY (LatEnable): No disk device object exist for \"%.*S\"; cannot log this volume.\n",
                            userDeviceName.Length / sizeof( WCHAR ),
                            userDeviceName.Buffer );
            IoDeleteDevice( latencyDeviceObject );
            ObDereferenceObject( nextDeviceObject );
            return status;
        }
        
        //
        //  Call the routine to attach to a mounted device.
        //

        status = LatAttachToMountedDevice( nextDeviceObject,
                                           latencyDeviceObject,
                                           diskDeviceObject );

        //
        //  Clear the reference on diskDeviceObject that was
        //  added by IoGetDiskDeviceObject.
        //

        ObDereferenceObject( diskDeviceObject );

        if (!NT_SUCCESS( status )) {

            LAT_DBG_PRINT2( DEBUG_ERROR,
                            "LATENCY (LatEnable): Could not attach to \"%.*S\"; logging not started.\n",
                            userDeviceName.Length / sizeof( WCHAR ),
                            userDeviceName.Buffer );
            IoDeleteDevice( latencyDeviceObject );
            ObDereferenceObject( nextDeviceObject );
            return status;
        }

        //
        //  We successfully attached so do any more device extension 
        //  initialization we need.  Along this code path, we want to
        //  turn on logging and store our device name.
        // 

        devext = latencyDeviceObject->DeviceExtension;
        LatResetDeviceExtension( devext );
        devext->Enabled = TRUE;

        //
        //  We want to store the name that was used by the user-mode
        //  application to name this device.
        //

/* ISSUE-2000-09-21-mollybro 

    TODO: Fix user name thing.
*/

//        LatStoreUserName( devext, &userDeviceName );

        //
        //  We are done initializing this device object, so
        //  clear the DO_DEVICE_OBJECT_INITIALIZING flag.
        //

        ClearFlag( latencyDeviceObject->Flags, DO_DEVICE_INITIALIZING );
    }

    ObDereferenceObject( nextDeviceObject );
    return STATUS_SUCCESS;
}

NTSTATUS
LatDisable (
    IN PWSTR DeviceName
    )
/*++

Routine Description:

    This routine stop logging the specified device.  Since you can not
    physically detach from devices, this routine simply sets a flag saying
    to not log the device anymore.

    Note:  Since all network drives are represented by _one_ device object,
        and, therefore, one device extension, if the user detaches from one
        network drive, it has the affect of detaching from _all_ network
        devices.

Arguments:

    DeviceName - The name of the device to stop logging.

Return Value:
    NT Status code

--*/
{
    WCHAR nameBuf[DEVICE_NAMES_SZ];
    UNICODE_STRING volumeNameUnicodeString;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_OBJECT latencyDeviceObject;
    PLATENCY_DEVICE_EXTENSION devext;
    NTSTATUS status;
    
    RtlInitEmptyUnicodeString( &volumeNameUnicodeString, nameBuf, sizeof( nameBuf ) );
    RtlAppendUnicodeToString( &volumeNameUnicodeString, DeviceName );

    status = LatGetDeviceObjectFromName( &volumeNameUnicodeString, &deviceObject );

    if (!NT_SUCCESS( status )) {

        //
        //  We could not get the deviceObject from this DeviceName, so
        //  return the error code.
        //
        
        return status;
    }

    //
    //  Find Latency's device object from the device stack to which
    //  deviceObject is attached.
    //

    if (LatIsAttachedToDevice( deviceObject, &latencyDeviceObject )) {

        //
        //  Latency is attached and Latency's deviceObject was returned.
        //

        ASSERT( NULL != latencyDeviceObject );

        devext = latencyDeviceObject->DeviceExtension;

        devext->Enabled = FALSE;

        status = STATUS_SUCCESS;

    } else {

        status = STATUS_INVALID_PARAMETER;
    }    

    ObDereferenceObject( deviceObject );
    ObDereferenceObject( latencyDeviceObject );

    return status;
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//               Initialization routines for device extension         //
//                                                                    //
////////////////////////////////////////////////////////////////////////

VOID
LatResetDeviceExtension (
    PLATENCY_DEVICE_EXTENSION DeviceExtension
)
{
    ULONG i;

    ASSERT( NULL != DeviceExtension );
    
    DeviceExtension->Enabled = FALSE;
    
    for (i=0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
    
        DeviceExtension->Operations[i].PendOperation = FALSE;
        DeviceExtension->Operations[i].MillisecondDelay = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\sfilter\sfilter.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    sfilter.c

Abstract:

    This module contains the code that implements the general purpose sample
    file system filter driver.

    As of the Windows XP SP1 IFS Kit version of this sample and later, this
    sample can be built for each build environment released with the IFS Kit
    with no additional modifications.  To provide this capability, additional
    compile-time logic was added -- see the '#if WINVER' locations.  Comments
    tagged with the 'VERSION NOTE' header have also been added as appropriate to
    describe how the logic must change between versions.

    If this sample is built in the Windows XP environment or later, it will run
    on Windows 2000 or later.  This is done by dynamically loading the routines
    that are only available on Windows XP or later and making run-time decisions
    to determine what code to execute.  Comments tagged with 'MULTIVERISON NOTE'
    mark the locations where such logic has been added.

// @@BEGIN_DDKSPLIT
Author:

    Darryl E. Havens (darrylh) 26-Jan-1995

// @@END_DDKSPLIT
Environment:

    Kernel mode

// @@BEGIN_DDKSPLIT

Revision History:

    Neal Christiansen (nealch) 28-Jun-2000
        Added support so the filter can be loaded at anytime and properly
        enumerate and attach to all existing volumes.  Also did some
        simplifications of operations because of changes in past versions
        of NT that were not propagated into SFILTER

    Neal Christiansen (nealch) 20-Nov-2000
        Added a DriverUnload routine so that the driver can be unloaded.

    Neal Christiansen (nealch) 04-Jan-2001
        Moved the code to display the filename out of SrCreate into a
        separate routine.  This is so the filename buffer will not be
        on the create stack as it calls down through the code.

    Neal Christiansen (nealch) 27-Mar-2002
        We have done several updates to the code.  The latest change is
        that we no longer support the opening of the control device
        object.

    Molly Brown (mollybro)         21-May-2002
        Modify sample to make it support running on Windows 2000 or later if
        built in the latest build environment and allow it to be built in W2K 
        and later build environments.
// @@END_DDKSPLIT
--*/

#include "ntifs.h"
#include "ntdddisk.h"

//
//  Enable these warnings in the code.
//

#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4101)   // Unreferenced local variable

/////////////////////////////////////////////////////////////////////////////
//
//                   Macro and Structure Definitions
//
/////////////////////////////////////////////////////////////////////////////

//
//  VERSION NOTE:
//
//  The following useful macros are defined in NTIFS.H in Windows XP and later.
//  We will define them locally if we are building for the Windows 2000 
//  environment.
//

#if WINVER == 0x0500

//
//  These macros are used to test, set and clear flags respectively
//

#ifndef FlagOn
#define FlagOn(_F,_SF)        ((_F) & (_SF))
#endif

#ifndef BooleanFlagOn
#define BooleanFlagOn(F,SF)   ((BOOLEAN)(((F) & (SF)) != 0))
#endif

#ifndef SetFlag
#define SetFlag(_F,_SF)       ((_F) |= (_SF))
#endif

#ifndef ClearFlag
#define ClearFlag(_F,_SF)     ((_F) &= ~(_SF))
#endif


#define RtlInitEmptyUnicodeString(_ucStr,_buf,_bufSize) \
    ((_ucStr)->Buffer = (_buf), \
     (_ucStr)->Length = 0, \
     (_ucStr)->MaximumLength = (USHORT)(_bufSize))


#ifndef min
#define min(a,b) (((a) < (b)) ? (a) : (b))
#endif

#ifndef max
#define max(a,b) (((a) > (b)) ? (a) : (b))
#endif

//
//  We want ASSERT defined as an expression, which was fixed after Windows 2000
//

#ifdef ASSERT
#undef ASSERT
#if DBG
#define ASSERT( exp ) \
    ((!(exp)) ? \
        (RtlAssert( #exp, __FILE__, __LINE__, NULL ),FALSE) : \
        TRUE)
#else
#define ASSERT( exp ) ((void) 0)
#endif
#endif        

#define ExFreePoolWithTag( a, b ) ExFreePool( (a) )

#endif /* WINVER == 0x0500 */

#ifndef Add2Ptr
#define Add2Ptr(P,I) ((PVOID)((PUCHAR)(P) + (I)))
#endif

//
//  Buffer size for local names on the stack
//

#define MAX_DEVNAME_LENGTH 64

//
//  Device extension definition for our driver.  Note that the same extension
//  is used for the following types of device objects:
//      - File system device object we attach to
//      - Mounted volume device objects we attach to
//

typedef struct _SFILTER_DEVICE_EXTENSION {

    //
    //  Pointer to the file system device object we are attached to
    //

    PDEVICE_OBJECT AttachedToDeviceObject;

    //
    //  Pointer to the real (disk) device object that is associated with
    //  the file system device object we are attached to
    //

    PDEVICE_OBJECT StorageStackDeviceObject;

    //
    //  Name for this device.  If attached to a Volume Device Object it is the
    //  name of the physical disk drive.  If attached to a Control Device
    //  Object it is the name of the Control Device Object.
    //

    UNICODE_STRING DeviceName;

    //
    //  Buffer used to hold the above unicode strings
    //

    WCHAR DeviceNameBuffer[MAX_DEVNAME_LENGTH];

} SFILTER_DEVICE_EXTENSION, *PSFILTER_DEVICE_EXTENSION;

//
//  This structure contains the information we need to pass to the completion
//  processing for FSCTRLs.
//

typedef struct _FSCTRL_COMPLETION_CONTEXT {

    //
    //  The workitem that will be initialized with our context and 
    //  worker routine if this completion processing needs to be completed
    //  in a worker thread.
    //
    
    WORK_QUEUE_ITEM WorkItem;

    //
    //  The device object to which this device is currently directed.
    //
    
    PDEVICE_OBJECT DeviceObject;

    //
    //  The IRP for this FSCTRL operation.
    //
    
    PIRP Irp;

    //
    //  For mount operations, the new device object that we have allocated
    //  and partially initialized that we will attach to the mounted volume
    //  if the mount is successful.
    //
    
    PDEVICE_OBJECT NewDeviceObject;
    
} FSCTRL_COMPLETION_CONTEXT, *PFSCTRL_COMPLETION_CONTEXT;
        

//
//  Macro to test if this is my device object
//

#define IS_MY_DEVICE_OBJECT(_devObj) \
    (((_devObj) != NULL) && \
     ((_devObj)->DriverObject == gSFilterDriverObject) && \
      ((_devObj)->DeviceExtension != NULL))

//
//  Macro to test if this is my control device object
//

#define IS_MY_CONTROL_DEVICE_OBJECT(_devObj) \
    (((_devObj) == gSFilterControlDeviceObject) ? \
            (ASSERT(((_devObj)->DriverObject == gSFilterDriverObject) && \
                    ((_devObj)->DeviceExtension == NULL)), TRUE) : \
            FALSE)

//
//  Macro to test for device types we want to attach to
//

#define IS_DESIRED_DEVICE_TYPE(_type) \
    (((_type) == FILE_DEVICE_DISK_FILE_SYSTEM) || \
     ((_type) == FILE_DEVICE_CD_ROM_FILE_SYSTEM) || \
     ((_type) == FILE_DEVICE_NETWORK_FILE_SYSTEM))

//
//  Macro to test if FAST_IO_DISPATCH handling routine is valid
//

#define VALID_FAST_IO_DISPATCH_HANDLER(_FastIoDispatchPtr, _FieldName) \
    (((_FastIoDispatchPtr) != NULL) && \
     (((_FastIoDispatchPtr)->SizeOfFastIoDispatch) >= \
            (FIELD_OFFSET(FAST_IO_DISPATCH, _FieldName) + sizeof(void *))) && \
     ((_FastIoDispatchPtr)->_FieldName != NULL))


#if WINVER >= 0x0501
//
//  MULTIVERSION NOTE:
//
//  If built in the Windows XP environment or later, we will dynamically import
//  the function pointers for routines that were not supported on Windows 2000
//  so that we can build a driver that will run, with modified logic, on 
//  Windows 2000 or later.
//
//  Below are the prototypes for the function pointers that we need to 
//  dynamically import because not all OS versions support these routines.
//

typedef
NTSTATUS
(*PSF_REGISTER_FILE_SYSTEM_FILTER_CALLBACKS) (
    IN PDRIVER_OBJECT DriverObject,
    IN PFS_FILTER_CALLBACKS Callbacks
    );

typedef
NTSTATUS
(*PSF_ENUMERATE_DEVICE_OBJECT_LIST) (
    IN  PDRIVER_OBJECT DriverObject,
    IN  PDEVICE_OBJECT *DeviceObjectList,
    IN  ULONG DeviceObjectListSize,
    OUT PULONG ActualNumberDeviceObjects
    );

typedef
NTSTATUS
(*PSF_ATTACH_DEVICE_TO_DEVICE_STACK_SAFE) (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice,
    OUT PDEVICE_OBJECT *AttachedToDeviceObject
    );

typedef    
PDEVICE_OBJECT
(*PSF_GET_LOWER_DEVICE_OBJECT) (
    IN  PDEVICE_OBJECT  DeviceObject
    );

typedef
PDEVICE_OBJECT
(*PSF_GET_DEVICE_ATTACHMENT_BASE_REF) (
    IN PDEVICE_OBJECT DeviceObject
    );

typedef
NTSTATUS
(*PSF_GET_DISK_DEVICE_OBJECT) (
    IN  PDEVICE_OBJECT  FileSystemDeviceObject,
    OUT PDEVICE_OBJECT  *DiskDeviceObject
    );

typedef
PDEVICE_OBJECT
(*PSF_GET_ATTACHED_DEVICE_REFERENCE) (
    IN PDEVICE_OBJECT DeviceObject
    );

typedef
NTSTATUS
(*PSF_GET_VERSION) (
    IN OUT PRTL_OSVERSIONINFOW VersionInformation
    );

typedef struct _SF_DYNAMIC_FUNCTION_POINTERS {

    //
    //  The following routines should all be available on Windows XP (5.1) and
    //  later.
    //

    PSF_REGISTER_FILE_SYSTEM_FILTER_CALLBACKS RegisterFileSystemFilterCallbacks;
    PSF_ATTACH_DEVICE_TO_DEVICE_STACK_SAFE AttachDeviceToDeviceStackSafe;
    PSF_ENUMERATE_DEVICE_OBJECT_LIST EnumerateDeviceObjectList;
    PSF_GET_LOWER_DEVICE_OBJECT GetLowerDeviceObject;
    PSF_GET_DEVICE_ATTACHMENT_BASE_REF GetDeviceAttachmentBaseRef;
    PSF_GET_DISK_DEVICE_OBJECT GetDiskDeviceObject;
    PSF_GET_ATTACHED_DEVICE_REFERENCE GetAttachedDeviceReference;
    PSF_GET_VERSION GetVersion;

} SF_DYNAMIC_FUNCTION_POINTERS, *PSF_DYNAMIC_FUNCTION_POINTERS;

SF_DYNAMIC_FUNCTION_POINTERS gSfDynamicFunctions = {0};

//
//  MULTIVERSION NOTE: For this version of the driver, we need to know the
//  current OS version while we are running to make decisions regarding what
//  logic to use when the logic cannot be the same for all platforms.  We
//  will look up the OS version in DriverEntry and store the values
//  in these global variables.
//

ULONG gSfOsMajorVersion = 0;
ULONG gSfOsMinorVersion = 0;

//
//  Here is what the major and minor versions should be for the various OS versions:
//
//  OS Name                                 MajorVersion    MinorVersion
//  ---------------------------------------------------------------------
//  Windows 2000                             5                 0
//  Windows XP                               5                 1
//  Windows Server 2003                      5                 2
//

#define IS_WINDOWS2000() \
    ((gSfOsMajorVersion == 5) && (gSfOsMinorVersion == 0))

#define IS_WINDOWSXP() \
    ((gSfOsMajorVersion == 5) && (gSfOsMinorVersion == 1))

#define IS_WINDOWSXP_OR_LATER() \
    (((gSfOsMajorVersion == 5) && (gSfOsMinorVersion >= 1)) || \
     (gSfOsMajorVersion > 5))

#define IS_WINDOWSSRV2003_OR_LATER() \
    (((gSfOsMajorVersion == 5) && (gSfOsMinorVersion >= 2)) || \
     (gSfOsMajorVersion > 5))

#endif


//
//  TAG identifying memory SFilter allocates
//

#define SFLT_POOL_TAG   'tlFS'

//
//  This structure and these routines are used to retrieve the name of a file
//  object.  To prevent allocating memory every time we get a name this
//  structure contains a small buffer (which should handle 90+% of all names).
//  If we do overflow this buffer we will allocate a buffer big enough
//  for the name.
//

typedef struct _GET_NAME_CONTROL {

    PCHAR allocatedBuffer;
    CHAR smallBuffer[256];
    
} GET_NAME_CONTROL, *PGET_NAME_CONTROL;


PUNICODE_STRING
SfGetFileName(
    IN PFILE_OBJECT FileObject,
    IN NTSTATUS CreateStatus,
    IN OUT PGET_NAME_CONTROL NameControl
    );


VOID
SfGetFileNameCleanup(
    IN OUT PGET_NAME_CONTROL NameControl
    );


//
//  Macros for SFilter DbgPrint levels.
//

#define SF_LOG_PRINT( _dbgLevel, _string )                  \
    (FlagOn(SfDebug,(_dbgLevel)) ?                          \
        DbgPrint _string  :                                 \
        ((void)0))

//
//  Delay values for KeDelayExecutionThread()
//  (Values are negative to represent relative time)
//

#define DELAY_ONE_MICROSECOND   (-10)
#define DELAY_ONE_MILLISECOND   (DELAY_ONE_MICROSECOND*1000)
#define DELAY_ONE_SECOND        (DELAY_ONE_MILLISECOND*1000)


/////////////////////////////////////////////////////////////////////////////
//
//                      Global variables
//
/////////////////////////////////////////////////////////////////////////////

//
//  Holds pointer to the driver object for this driver
//

PDRIVER_OBJECT gSFilterDriverObject = NULL;

//
//  Holds pointer to the device object that represents this driver and is used
//  by external programs to access this driver.  This is also known as the
//  "control device object".
//

PDEVICE_OBJECT gSFilterControlDeviceObject = NULL;

//
//  This lock is used to synchronize our attaching to a given device object.
//  This lock fixes a race condition where we could accidently attach to the
//  same device object more then once.  This race condition only occurs if
//  a volume is being mounted at the same time as this filter is being loaded.
//  This problem will never occur if this filter is loaded at boot time before
//  any file systems are loaded.
//
//  This lock is used to atomically test if we are already attached to a given
//  device object and if not, do the attach.
//

FAST_MUTEX gSfilterAttachLock;

/////////////////////////////////////////////////////////////////////////////
//
//                      Debug Definitions
//
/////////////////////////////////////////////////////////////////////////////

//
//  DEBUG display flags
//

#define SFDEBUG_DISPLAY_ATTACHMENT_NAMES    0x00000001  //display names of device objects we attach to
#define SFDEBUG_DISPLAY_CREATE_NAMES        0x00000002  //get and display names during create
#define SFDEBUG_GET_CREATE_NAMES            0x00000004  //get name (don't display) during create
#define SFDEBUG_DO_CREATE_COMPLETION        0x00000008  //do create completion routine, don't get names
#define SFDEBUG_ATTACH_TO_FSRECOGNIZER      0x00000010  //do attach to FSRecognizer device objects
#define SFDEBUG_ATTACH_TO_SHADOW_COPIES     0x00000020  //do attach to ShadowCopy Volume device objects -- they are only around on Windows XP and later

ULONG SfDebug = 0;


//
//  Given a device type, return a valid name
//

#define GET_DEVICE_TYPE_NAME( _type ) \
            ((((_type) > 0) && ((_type) < (sizeof(DeviceTypeNames) / sizeof(PCHAR)))) ? \
                DeviceTypeNames[ (_type) ] : \
                "[Unknown]")

//
//  Known device type names
//

static const PCHAR DeviceTypeNames[] = {
    "",
    "BEEP",
    "CD_ROM",
    "CD_ROM_FILE_SYSTEM",
    "CONTROLLER",
    "DATALINK",
    "DFS",
    "DISK",
    "DISK_FILE_SYSTEM",
    "FILE_SYSTEM",
    "INPORT_PORT",
    "KEYBOARD",
    "MAILSLOT",
    "MIDI_IN",
    "MIDI_OUT",
    "MOUSE",
    "MULTI_UNC_PROVIDER",
    "NAMED_PIPE",
    "NETWORK",
    "NETWORK_BROWSER",
    "NETWORK_FILE_SYSTEM",
    "NULL",
    "PARALLEL_PORT",
    "PHYSICAL_NETCARD",
    "PRINTER",
    "SCANNER",
    "SERIAL_MOUSE_PORT",
    "SERIAL_PORT",
    "SCREEN",
    "SOUND",
    "STREAMS",
    "TAPE",
    "TAPE_FILE_SYSTEM",
    "TRANSPORT",
    "UNKNOWN",
    "VIDEO",
    "VIRTUAL_DISK",
    "WAVE_IN",
    "WAVE_OUT",
    "8042_PORT",
    "NETWORK_REDIRECTOR",
    "BATTERY",
    "BUS_EXTENDER",
    "MODEM",
    "VDM",
    "MASS_STORAGE",
    "SMB",
    "KS",
    "CHANGER",
    "SMARTCARD",
    "ACPI",
    "DVD",
    "FULLSCREEN_VIDEO",
    "DFS_FILE_SYSTEM",
    "DFS_VOLUME",
    "SERENUM",
    "TERMSRV",
    "KSEC"
};


/////////////////////////////////////////////////////////////////////////////
//
//                          Function Prototypes
//
/////////////////////////////////////////////////////////////////////////////

//
//  Define driver entry routine.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

#if DBG && WINVER >= 0x0501
VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );
#endif

//
//  Define the local routines used by this driver module.  This includes a
//  a sample of how to filter a create file operation, and then invoke an I/O
//  completion routine when the file has successfully been created/opened.
//

#if WINVER >= 0x0501
VOID
SfLoadDynamicFunctions (
    );

VOID
SfGetCurrentVersion (
    );
#endif

NTSTATUS
SfPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SfCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SfCreateCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
SfCleanupClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SfFsControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SfFsControlMountVolume (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SfFsControlMountVolumeCompleteWorker (
    IN PFSCTRL_COMPLETION_CONTEXT Context
    );

NTSTATUS
SfFsControlMountVolumeComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_OBJECT NewDeviceObject
    );

NTSTATUS
SfFsControlLoadFileSystem (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SfFsControlLoadFileSystemCompleteWorker (
    IN PFSCTRL_COMPLETION_CONTEXT Context
    );

NTSTATUS
SfFsControlLoadFileSystemComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SfFsControlCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

BOOLEAN
SfFastIoCheckIfPossible(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoRead(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoWrite(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoQueryBasicInfo(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoQueryStandardInfo(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoLock(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoUnlockSingle(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoUnlockAll(
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoUnlockAllByKey(
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoDeviceControl(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
SfFastIoDetachDevice(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
    );

BOOLEAN
SfFastIoQueryNetworkOpenInfo(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoMdlRead(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );


BOOLEAN
SfFastIoMdlReadComplete(
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoPrepareMdlWrite(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoMdlWriteComplete(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoReadCompressed(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoWriteCompressed(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoMdlReadCompleteCompressed(
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoMdlWriteCompleteCompressed(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SfFastIoQueryOpen(
    IN PIRP Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN PDEVICE_OBJECT DeviceObject
    );

#if WINVER >= 0x0501 /* See comment in DriverEntry */
NTSTATUS
SfPreFsFilterPassThrough (
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext
    );

VOID
SfPostFsFilterPassThrough (
    IN PFS_FILTER_CALLBACK_DATA Data,
    IN NTSTATUS OperationStatus,
    IN PVOID CompletionContext
    );
#endif

VOID
SfFsNotification(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FsActive
    );

NTSTATUS
SfAttachDeviceToDeviceStack (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice,
    IN OUT PDEVICE_OBJECT *AttachedToDeviceObject
    );

NTSTATUS
SfAttachToFileSystemDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING DeviceName
    );

VOID
SfDetachFromFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
SfAttachToMountedDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT SFilterDeviceObject
    );

VOID
SfCleanupMountedDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

#if WINVER >= 0x0501
NTSTATUS
SfEnumerateFileSystemVolumes(
    IN PDEVICE_OBJECT FSDeviceObject,
    IN PUNICODE_STRING FSName
    );
#endif

VOID
SfGetObjectName(
    IN PVOID Object,
    IN OUT PUNICODE_STRING Name
    );

VOID
SfGetBaseDeviceObjectName(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING DeviceName
    );

BOOLEAN
SfIsAttachedToDevice(
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL
    );

BOOLEAN
SfIsAttachedToDeviceW2K(
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL
    );

BOOLEAN
SfIsAttachedToDeviceWXPAndLater(
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL
    );

VOID
SfReadDriverParameters(
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
SfIsShadowCopyVolume (
    IN PDEVICE_OBJECT StorageStackDeviceObject,
    OUT PBOOLEAN IsShadowCopy
    );

/////////////////////////////////////////////////////////////////////////////
//
//  Assign text sections for each routine.
//
/////////////////////////////////////////////////////////////////////////////

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#if DBG && WINVER >= 0x0501
#pragma alloc_text(PAGE, DriverUnload)
#endif

#pragma alloc_text(PAGE, SfFsNotification)
#pragma alloc_text(PAGE, SfCreate)
#pragma alloc_text(PAGE, SfCleanupClose)
#pragma alloc_text(PAGE, SfFsControl)
#pragma alloc_text(PAGE, SfFsControlMountVolume)
#pragma alloc_text(PAGE, SfFsControlMountVolumeComplete)
#pragma alloc_text(PAGE, SfFsControlLoadFileSystem)
#pragma alloc_text(PAGE, SfFsControlLoadFileSystemComplete)
#pragma alloc_text(PAGE, SfFastIoCheckIfPossible)
#pragma alloc_text(PAGE, SfFastIoRead)
#pragma alloc_text(PAGE, SfFastIoWrite)
#pragma alloc_text(PAGE, SfFastIoQueryBasicInfo)
#pragma alloc_text(PAGE, SfFastIoQueryStandardInfo)
#pragma alloc_text(PAGE, SfFastIoLock)
#pragma alloc_text(PAGE, SfFastIoUnlockSingle)
#pragma alloc_text(PAGE, SfFastIoUnlockAll)
#pragma alloc_text(PAGE, SfFastIoUnlockAllByKey)
#pragma alloc_text(PAGE, SfFastIoDeviceControl)
#pragma alloc_text(PAGE, SfFastIoDetachDevice)
#pragma alloc_text(PAGE, SfFastIoQueryNetworkOpenInfo)
#pragma alloc_text(PAGE, SfFastIoMdlRead)
#pragma alloc_text(PAGE, SfFastIoPrepareMdlWrite)
#pragma alloc_text(PAGE, SfFastIoMdlWriteComplete)
#pragma alloc_text(PAGE, SfFastIoReadCompressed)
#pragma alloc_text(PAGE, SfFastIoWriteCompressed)
#pragma alloc_text(PAGE, SfFastIoQueryOpen)
#pragma alloc_text(PAGE, SfAttachDeviceToDeviceStack)
#pragma alloc_text(PAGE, SfAttachToFileSystemDevice)
#pragma alloc_text(PAGE, SfDetachFromFileSystemDevice)
#pragma alloc_text(PAGE, SfAttachToMountedDevice)
#pragma alloc_text(PAGE, SfIsAttachedToDevice)
#pragma alloc_text(PAGE, SfIsAttachedToDeviceW2K)
#pragma alloc_text(INIT, SfReadDriverParameters)
#pragma alloc_text(PAGE, SfIsShadowCopyVolume)

#if WINVER >= 0x0501
#pragma alloc_text(INIT, SfLoadDynamicFunctions)
#pragma alloc_text(INIT, SfGetCurrentVersion)
#pragma alloc_text(PAGE, SfEnumerateFileSystemVolumes)
#pragma alloc_text(PAGE, SfIsAttachedToDeviceWXPAndLater)
#endif

#endif


/////////////////////////////////////////////////////////////////////////////
//
//                      Functions
//
/////////////////////////////////////////////////////////////////////////////

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the SFILTER file system filter
    driver.  This routine creates the device object that represents this
    driver in the system and registers it for watching all file systems that
    register or unregister themselves as active file systems.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    PFAST_IO_DISPATCH fastIoDispatch;
    UNICODE_STRING nameString;
    NTSTATUS status;
    ULONG i;

#if WINVER >= 0x0501
    //
    //  Try to load the dynamic functions that may be available for our use.
    //

    SfLoadDynamicFunctions();

    //
    //  Now get the current OS version that we will use to determine what logic
    //  paths to take when this driver is built to run on various OS version.
    //

    SfGetCurrentVersion();
#endif

    //
    //  Get Registry values
    //

    SfReadDriverParameters( RegistryPath );

    //
    //  Save our Driver Object, set our UNLOAD routine
    //

    gSFilterDriverObject = DriverObject;

#if DBG && WINVER >= 0x0501

    //
    //  MULTIVERSION NOTE:
    //
    //  We can only support unload for testing environments if we can enumerate
    //  the outstanding device objects that our driver has.
    //
    
    //
    //  Unload is useful for development purposes. It is not recommended for
    //  production versions
    //

    if (NULL != gSfDynamicFunctions.EnumerateDeviceObjectList) {
        
        gSFilterDriverObject->DriverUnload = DriverUnload;
    }
#endif

    //
    //  Setup other global variables
    //

    ExInitializeFastMutex( &gSfilterAttachLock );

    //
    //  Create the Control Device Object (CDO).  This object represents this 
    //  driver.  Note that it does not have a device extension.
    //

    RtlInitUnicodeString( &nameString, L"\\FileSystem\\Filters\\SFilter" );

    status = IoCreateDevice( DriverObject,
                             0,                      //has no device extension
                             &nameString,
                             FILE_DEVICE_DISK_FILE_SYSTEM,
                             FILE_DEVICE_SECURE_OPEN,
                             FALSE,
                             &gSFilterControlDeviceObject );

    if (status == STATUS_OBJECT_PATH_NOT_FOUND) {

        //
        //  This must be a version of the OS that doesn't have the Filters
        //  path in its namespace.  This was added in Windows XP.
        //
        //  We will try just putting our control device object in the \FileSystem
        //  portion of the object name space.
        //

        RtlInitUnicodeString( &nameString, L"\\FileSystem\\SFilterCDO" );

        status = IoCreateDevice( DriverObject,
                                 0,                      //has no device extension
                                 &nameString,
                                 FILE_DEVICE_DISK_FILE_SYSTEM,
                                 FILE_DEVICE_SECURE_OPEN,
                                 FALSE,
                                 &gSFilterControlDeviceObject );

        if (!NT_SUCCESS( status )) {
           
            KdPrint(( "SFilter!DriverEntry: Error creating control device object \"%wZ\", status=%08x\n", &nameString, status ));
            return status;
        }
        
    } else if (!NT_SUCCESS( status )) {

        KdPrint(( "SFilter!DriverEntry: Error creating control device object \"%wZ\", status=%08x\n", &nameString, status ));
        return status;
    }

    //
    //  Initialize the driver object with this device driver's entry points.
    //

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {

        DriverObject->MajorFunction[i] = SfPassThrough;
    }

    //
    //  We will use SfCreate for all the create operations
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = SfCreate;
    DriverObject->MajorFunction[IRP_MJ_CREATE_NAMED_PIPE] = SfCreate;
    DriverObject->MajorFunction[IRP_MJ_CREATE_MAILSLOT] = SfCreate;
    
    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL] = SfFsControl;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = SfCleanupClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = SfCleanupClose;

    //
    //  Allocate fast I/O data structure and fill it in.
    //
    //  NOTE:  The following FastIo Routines are not supported:
    //      AcquireFileForNtCreateSection
    //      ReleaseFileForNtCreateSection
    //      AcquireForModWrite
    //      ReleaseForModWrite
    //      AcquireForCcFlush
    //      ReleaseForCcFlush
    //
    //  For historical reasons these FastIO's have never been sent to filters
    //  by the NT I/O system.  Instead, they are sent directly to the base 
    //  file system.  On Windows XP and later OS releases, you can use the new 
    //  system routine "FsRtlRegisterFileSystemFilterCallbacks" if you need to 
    //  intercept these callbacks (see below).
    //

    fastIoDispatch = ExAllocatePoolWithTag( NonPagedPool, sizeof( FAST_IO_DISPATCH ), SFLT_POOL_TAG );
    if (!fastIoDispatch) {

        IoDeleteDevice( gSFilterControlDeviceObject );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( fastIoDispatch, sizeof( FAST_IO_DISPATCH ) );

    fastIoDispatch->SizeOfFastIoDispatch = sizeof( FAST_IO_DISPATCH );
    fastIoDispatch->FastIoCheckIfPossible = SfFastIoCheckIfPossible;
    fastIoDispatch->FastIoRead = SfFastIoRead;
    fastIoDispatch->FastIoWrite = SfFastIoWrite;
    fastIoDispatch->FastIoQueryBasicInfo = SfFastIoQueryBasicInfo;
    fastIoDispatch->FastIoQueryStandardInfo = SfFastIoQueryStandardInfo;
    fastIoDispatch->FastIoLock = SfFastIoLock;
    fastIoDispatch->FastIoUnlockSingle = SfFastIoUnlockSingle;
    fastIoDispatch->FastIoUnlockAll = SfFastIoUnlockAll;
    fastIoDispatch->FastIoUnlockAllByKey = SfFastIoUnlockAllByKey;
    fastIoDispatch->FastIoDeviceControl = SfFastIoDeviceControl;
    fastIoDispatch->FastIoDetachDevice = SfFastIoDetachDevice;
    fastIoDispatch->FastIoQueryNetworkOpenInfo = SfFastIoQueryNetworkOpenInfo;
    fastIoDispatch->MdlRead = SfFastIoMdlRead;
    fastIoDispatch->MdlReadComplete = SfFastIoMdlReadComplete;
    fastIoDispatch->PrepareMdlWrite = SfFastIoPrepareMdlWrite;
    fastIoDispatch->MdlWriteComplete = SfFastIoMdlWriteComplete;
    fastIoDispatch->FastIoReadCompressed = SfFastIoReadCompressed;
    fastIoDispatch->FastIoWriteCompressed = SfFastIoWriteCompressed;
    fastIoDispatch->MdlReadCompleteCompressed = SfFastIoMdlReadCompleteCompressed;
    fastIoDispatch->MdlWriteCompleteCompressed = SfFastIoMdlWriteCompleteCompressed;
    fastIoDispatch->FastIoQueryOpen = SfFastIoQueryOpen;

    DriverObject->FastIoDispatch = fastIoDispatch;

//
//  VERSION NOTE:
//
//  There are 6 FastIO routines for which file system filters are bypassed as
//  the requests are passed directly to the base file system.  These 6 routines
//  are AcquireFileForNtCreateSection, ReleaseFileForNtCreateSection,
//  AcquireForModWrite, ReleaseForModWrite, AcquireForCcFlush, and 
//  ReleaseForCcFlush.
//
//  In Windows XP and later, the FsFilter callbacks were introduced to allow
//  filters to safely hook these operations.  See the IFS Kit documentation for
//  more details on how these new interfaces work.
//
//  MULTIVERSION NOTE:
//  
//  If built for Windows XP or later, this driver is built to run on 
//  multiple versions.  When this is the case, we will test
//  for the presence of FsFilter callbacks registration API.  If we have it,
//  then we will register for those callbacks, otherwise, we will not.
//

#if WINVER >= 0x0501

    {
        FS_FILTER_CALLBACKS fsFilterCallbacks;

        if (NULL != gSfDynamicFunctions.RegisterFileSystemFilterCallbacks) {

            //
            //  Setup the callbacks for the operations we receive through
            //  the FsFilter interface.
            //
            //  NOTE:  You only need to register for those routines you really need
            //         to handle.  SFilter is registering for all routines simply to
            //         give an example of how it is done.
            //

            fsFilterCallbacks.SizeOfFsFilterCallbacks = sizeof( FS_FILTER_CALLBACKS );
            fsFilterCallbacks.PreAcquireForSectionSynchronization = SfPreFsFilterPassThrough;
            fsFilterCallbacks.PostAcquireForSectionSynchronization = SfPostFsFilterPassThrough;
            fsFilterCallbacks.PreReleaseForSectionSynchronization = SfPreFsFilterPassThrough;
            fsFilterCallbacks.PostReleaseForSectionSynchronization = SfPostFsFilterPassThrough;
            fsFilterCallbacks.PreAcquireForCcFlush = SfPreFsFilterPassThrough;
            fsFilterCallbacks.PostAcquireForCcFlush = SfPostFsFilterPassThrough;
            fsFilterCallbacks.PreReleaseForCcFlush = SfPreFsFilterPassThrough;
            fsFilterCallbacks.PostReleaseForCcFlush = SfPostFsFilterPassThrough;
            fsFilterCallbacks.PreAcquireForModifiedPageWriter = SfPreFsFilterPassThrough;
            fsFilterCallbacks.PostAcquireForModifiedPageWriter = SfPostFsFilterPassThrough;
            fsFilterCallbacks.PreReleaseForModifiedPageWriter = SfPreFsFilterPassThrough;
            fsFilterCallbacks.PostReleaseForModifiedPageWriter = SfPostFsFilterPassThrough;

            status = (gSfDynamicFunctions.RegisterFileSystemFilterCallbacks)( DriverObject, 
                                                                             &fsFilterCallbacks );

            if (!NT_SUCCESS( status )) {
                
                DriverObject->FastIoDispatch = NULL;
                ExFreePool( fastIoDispatch );
                IoDeleteDevice( gSFilterControlDeviceObject );
                return status;
            }
        }
    }
#endif

    //
    //  The registered callback routine "SfFsNotification" will be called
    //  whenever a new file systems is loaded or when any file system is
    //  unloaded.
    //
    //  VERSION NOTE:
    //
    //  On Windows XP and later this will also enumerate all existing file
    //  systems (except the RAW file systems).  On Windows 2000 this does not
    //  enumerate the file systems that were loaded before this filter was
    //  loaded.
    //

    status = IoRegisterFsRegistrationChange( DriverObject, SfFsNotification );
    if (!NT_SUCCESS( status )) {

        KdPrint(( "SFilter!DriverEntry: Error registering FS change notification, status=%08x\n", status ));

        DriverObject->FastIoDispatch = NULL;
        ExFreePool( fastIoDispatch );
        IoDeleteDevice( gSFilterControlDeviceObject );
        return status;
    }

    //
    //  Attempt to attach to the appropriate RAW file system device objects
    //  since they are not enumerated by IoRegisterFsRegistrationChange.
    //

    {
        PDEVICE_OBJECT rawDeviceObject;
        PFILE_OBJECT fileObject;

        //
        //  Attach to RawDisk device
        //

        RtlInitUnicodeString( &nameString, L"\\Device\\RawDisk" );

        status = IoGetDeviceObjectPointer(
                    &nameString,
                    FILE_READ_ATTRIBUTES,
                    &fileObject,
                    &rawDeviceObject );

        if (NT_SUCCESS( status )) {

            SfFsNotification( rawDeviceObject, TRUE );
            ObDereferenceObject( fileObject );
        }

        //
        //  Attach to the RawCdRom device
        //

        RtlInitUnicodeString( &nameString, L"\\Device\\RawCdRom" );

        status = IoGetDeviceObjectPointer(
                    &nameString,
                    FILE_READ_ATTRIBUTES,
                    &fileObject,
                    &rawDeviceObject );

        if (NT_SUCCESS( status )) {

            SfFsNotification( rawDeviceObject, TRUE );
            ObDereferenceObject( fileObject );
        }
    }

    //
    //  Clear the initializing flag on the control device object since we
    //  have now successfully initialized everything.
    //

    ClearFlag( gSFilterControlDeviceObject->Flags, DO_DEVICE_INITIALIZING );

    return STATUS_SUCCESS;
}

#if DBG && WINVER >= 0x0501
VOID
DriverUnload (
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine is called when a driver can be unloaded.  This performs all of
    the necessary cleanup for unloading the driver from memory.  Note that an
    error can NOT be returned from this routine.
    
    When a request is made to unload a driver the IO System will cache that
    information and not actually call this routine until the following states
    have occurred:
    - All device objects which belong to this filter are at the top of their
      respective attachment chains.
    - All handle counts for all device objects which belong to this filter have
      gone to zero.

    WARNING: Microsoft does not officially support the unloading of File
             System Filter Drivers.  This is an example of how to unload
             your driver if you would like to use it during development.
             This should not be made available in production code.

Arguments:

    DriverObject - Driver object for this module

Return Value:

    None.

--*/

{
    PSFILTER_DEVICE_EXTENSION devExt;
    PFAST_IO_DISPATCH fastIoDispatch;
    NTSTATUS status;
    ULONG numDevices;
    ULONG i;
    LARGE_INTEGER interval;
#   define DEVOBJ_LIST_SIZE 64
    PDEVICE_OBJECT devList[DEVOBJ_LIST_SIZE];

    ASSERT(DriverObject == gSFilterDriverObject);

    //
    //  Log we are unloading
    //

    SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                  ("SFilter!DriverUnload:                        Unloading driver (%p)\n",
                   DriverObject) );

    //
    //  Don't get anymore file system change notifications
    //

    IoUnregisterFsRegistrationChange( DriverObject, SfFsNotification );

    //
    //  This is the loop that will go through all of the devices we are attached
    //  to and detach from them.  Since we don't know how many there are and
    //  we don't want to allocate memory (because we can't return an error)
    //  we will free them in chunks using a local array on the stack.
    //

    for (;;) {

        //
        //  Get what device objects we can for this driver.  Quit if there
        //  are not any more.  Note that this routine should always be
        //  defined since this routine is only compiled for Windows XP and
        //  later.
        //

        ASSERT( NULL != gSfDynamicFunctions.EnumerateDeviceObjectList );
        status = (gSfDynamicFunctions.EnumerateDeviceObjectList)(
                        DriverObject,
                        devList,
                        sizeof(devList),
                        &numDevices);

        if (numDevices <= 0)  {

            break;
        }

        numDevices = min( numDevices, DEVOBJ_LIST_SIZE );

        //
        //  First go through the list and detach each of the devices.
        //  Our control device object does not have a DeviceExtension and
        //  is not attached to anything so don't detach it.
        //

        for (i=0; i < numDevices; i++) {

            devExt = devList[i]->DeviceExtension;
            if (NULL != devExt) {

                IoDetachDevice( devExt->AttachedToDeviceObject );
            }
        }

        //
        //  The IO Manager does not currently add a reference count to a device
        //  object for each outstanding IRP.  This means there is no way to
        //  know if there are any outstanding IRPs on the given device.
        //  We are going to wait for a reasonable amount of time for pending
        //  irps to complete.  
        //
        //  WARNING: This does not work 100% of the time and the driver may be
        //           unloaded before all IRPs are completed.  This can easily
        //           occur under stress situations and if a long lived IRP is
        //           pending (like oplocks and directory change notifications).
        //           The system will fault when this Irp actually completes.
        //           This is a sample of how to do this during testing.  This
        //           is not recommended for production code.
        //

        interval.QuadPart = (5 * DELAY_ONE_SECOND);      //delay 5 seconds
        KeDelayExecutionThread( KernelMode, FALSE, &interval );

        //
        //  Now go back through the list and delete the device objects.
        //

        for (i=0; i < numDevices; i++) {

            //
            //  See if this is our control device object.  If not then cleanup
            //  the device extension.  If so then clear the global pointer
            //  that references it.
            //

            if (NULL != devList[i]->DeviceExtension) {

                SfCleanupMountedDevice( devList[i] );

            } else {

                ASSERT(devList[i] == gSFilterControlDeviceObject);
                gSFilterControlDeviceObject = NULL;
            }

            //
            //  Delete the device object, remove reference counts added by
            //  IoEnumerateDeviceObjectList.  Note that the delete does
            //  not actually occur until the reference count goes to zero.
            //

            IoDeleteDevice( devList[i] );
            ObDereferenceObject( devList[i] );
        }
    }

    //
    //  Free our FastIO table
    //

    fastIoDispatch = DriverObject->FastIoDispatch;
    DriverObject->FastIoDispatch = NULL;
    ExFreePool( fastIoDispatch );
}
#endif

#if WINVER >= 0x0501
VOID
SfLoadDynamicFunctions (
    )
/*++

Routine Description:

    This routine tries to load the function pointers for the routines that
    are not supported on all versions of the OS.  These function pointers are
    then stored in the global structure SpyDynamicFunctions.

    This support allows for one driver to be built that will run on all 
    versions of the OS Windows 2000 and greater.  Note that on Windows 2000, 
    the functionality may be limited.
    
Arguments:

    None.
    
Return Value:

    None.

--*/
{
    UNICODE_STRING functionName;

    RtlZeroMemory( &gSfDynamicFunctions, sizeof( gSfDynamicFunctions ) );

    //
    //  For each routine that we would want to use, lookup its address in the
    //  kernel or hal.  If it is not present, that field in our global
    //  SpyDynamicFunctions structure will be set to NULL.
    //

    RtlInitUnicodeString( &functionName, L"FsRtlRegisterFileSystemFilterCallbacks" );
    gSfDynamicFunctions.RegisterFileSystemFilterCallbacks = MmGetSystemRoutineAddress( &functionName );

    RtlInitUnicodeString( &functionName, L"IoAttachDeviceToDeviceStackSafe" );
    gSfDynamicFunctions.AttachDeviceToDeviceStackSafe = MmGetSystemRoutineAddress( &functionName );
    
    RtlInitUnicodeString( &functionName, L"IoEnumerateDeviceObjectList" );
    gSfDynamicFunctions.EnumerateDeviceObjectList = MmGetSystemRoutineAddress( &functionName );

    RtlInitUnicodeString( &functionName, L"IoGetLowerDeviceObject" );
    gSfDynamicFunctions.GetLowerDeviceObject = MmGetSystemRoutineAddress( &functionName );

    RtlInitUnicodeString( &functionName, L"IoGetDeviceAttachmentBaseRef" );
    gSfDynamicFunctions.GetDeviceAttachmentBaseRef = MmGetSystemRoutineAddress( &functionName );

    RtlInitUnicodeString( &functionName, L"IoGetDiskDeviceObject" );
    gSfDynamicFunctions.GetDiskDeviceObject = MmGetSystemRoutineAddress( &functionName );

    RtlInitUnicodeString( &functionName, L"IoGetAttachedDeviceReference" );
    gSfDynamicFunctions.GetAttachedDeviceReference = MmGetSystemRoutineAddress( &functionName );

    RtlInitUnicodeString( &functionName, L"RtlGetVersion" );
    gSfDynamicFunctions.GetVersion = MmGetSystemRoutineAddress( &functionName );
    
}

VOID
SfGetCurrentVersion (
    )
/*++

Routine Description:

    This routine reads the current OS version using the correct routine based
    on what routine is available.

Arguments:

    None.
    
Return Value:

    None.

--*/
{
    if (NULL != gSfDynamicFunctions.GetVersion) {

        RTL_OSVERSIONINFOW versionInfo;
        NTSTATUS status;

        //
        //  VERSION NOTE: RtlGetVersion does a bit more than we need, but
        //  we are using it if it is available to show how to use it.  It
        //  is available on Windows XP and later.  RtlGetVersion and
        //  RtlVerifyVersionInfo (both documented in the IFS Kit docs) allow
        //  you to make correct choices when you need to change logic based
        //  on the current OS executing your code.
        //

        versionInfo.dwOSVersionInfoSize = sizeof( RTL_OSVERSIONINFOW );

        status = (gSfDynamicFunctions.GetVersion)( &versionInfo );

        ASSERT( NT_SUCCESS( status ) );

        gSfOsMajorVersion = versionInfo.dwMajorVersion;
        gSfOsMinorVersion = versionInfo.dwMinorVersion;
        
    } else {

        PsGetVersion( &gSfOsMajorVersion,
                      &gSfOsMinorVersion,
                      NULL,
                      NULL );
    }
}
#endif

VOID
SfFsNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FsActive
    )

/*++

Routine Description:

    This routine is invoked whenever a file system has either registered or
    unregistered itself as an active file system.

    For the former case, this routine creates a device object and attaches it
    to the specified file system's device object.  This allows this driver
    to filter all requests to that file system.  Specifically we are looking
    for MOUNT requests so we can attach to newly mounted volumes.

    For the latter case, this file system's device object is located,
    detached, and deleted.  This removes this file system as a filter for
    the specified file system.

Arguments:

    DeviceObject - Pointer to the file system's device object.

    FsActive - Boolean indicating whether the file system has registered
        (TRUE) or unregistered (FALSE) itself as an active file system.

Return Value:

    None.

--*/

{
    UNICODE_STRING name;
    WCHAR nameBuffer[MAX_DEVNAME_LENGTH];

    PAGED_CODE();

    //
    //  Init local name buffer
    //

    RtlInitEmptyUnicodeString( &name, nameBuffer, sizeof(nameBuffer) );

    SfGetObjectName( DeviceObject, &name );

    //
    //  Display the names of all the file system we are notified of
    //

    SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                  ("SFilter!SfFsNotification:                    %s   %p \"%wZ\" (%s)\n",
                   (FsActive) ? "Activating file system  " : "Deactivating file system",
                   DeviceObject,
                   &name,
                   GET_DEVICE_TYPE_NAME(DeviceObject->DeviceType)) );

    //
    //  Handle attaching/detaching from the given file system.
    //

    if (FsActive) {

        SfAttachToFileSystemDevice( DeviceObject, &name );

    } else {

        SfDetachFromFileSystemDevice( DeviceObject );
    }
}


/////////////////////////////////////////////////////////////////////////////
//
//                  IRP Handling Routines
//
/////////////////////////////////////////////////////////////////////////////


NTSTATUS
SfPassThrough (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the main dispatch routine for the general purpose file
    system driver.  It simply passes requests onto the next driver in the
    stack, which is presumably a disk file system.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

Note:

    A note to file system filter implementers:  
        This routine actually "passes" through the request by taking this
        driver out of the IRP stack.  If the driver would like to pass the
        I/O request through, but then also see the result, then rather than
        taking itself out of the loop it could keep itself in by copying the
        caller's parameters to the next stack location and then set its own
        completion routine.  

        Hence, instead of calling:
    
            IoSkipCurrentIrpStackLocation( Irp );

        You could instead call:

            IoCopyCurrentIrpStackLocationToNext( Irp );
            IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE );


        This example actually NULLs out the caller's I/O completion routine, but
        this driver could set its own completion routine so that it would be
        notified when the request was completed (see SfCreate for an example of
        this).

--*/

{
    //
    //  Sfilter doesn't allow handles to its control device object to be created,
    //  therefore, no other operation should be able to come through.
    //
    
    ASSERT(!IS_MY_CONTROL_DEVICE_OBJECT( DeviceObject ));

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  Get this driver out of the driver stack and get to the next driver as
    //  quickly as possible.
    //

    IoSkipCurrentIrpStackLocation( Irp );
    
    //
    //  Call the appropriate file system driver with the request.
    //

    return IoCallDriver( ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject, Irp );
}


VOID
SfDisplayCreateFileName (
    IN PIRP Irp
    )

/*++

Routine Description:

    This function is called from SfCreate and will display the name of the
    file being created.  This is in a subroutine so that the local name buffer
    on the stack (in nameControl) is not on the stack when we call down to
    the file system for normal operations.

Arguments:

    Irp - Pointer to the I/O Request Packet that represents the operation.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION irpSp;
    PUNICODE_STRING name;
    GET_NAME_CONTROL nameControl;

    //
    //  Get current IRP stack
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Get the name of this file object
    //

    name = SfGetFileName( irpSp->FileObject, 
                          Irp->IoStatus.Status, 
                          &nameControl );

    //
    //  Display the name
    //

    if (irpSp->Parameters.Create.Options & FILE_OPEN_BY_FILE_ID) {

        SF_LOG_PRINT( SFDEBUG_DISPLAY_CREATE_NAMES,
                      ("SFilter!SfDisplayCreateFileName: Opened %08x:%08x %wZ (FID)\n", 
                       Irp->IoStatus.Status,
                       Irp->IoStatus.Information,
                       name) );

    } else {

        SF_LOG_PRINT( SFDEBUG_DISPLAY_CREATE_NAMES,
                      ("SFilter!SfDisplayCreateFileName: Opened %08x:%08x %wZ\n", 
                       Irp->IoStatus.Status,
                       Irp->IoStatus.Information,
                       name) );
    }

    //
    //  Cleanup from getting the name
    //

    SfGetFileNameCleanup( &nameControl );
}


NTSTATUS
SfCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function filters create/open operations.  It simply establishes an
    I/O completion routine to be invoked if the operation was successful.

Arguments:

    DeviceObject - Pointer to the target device object of the create/open.

    Irp - Pointer to the I/O Request Packet that represents the operation.

Return Value:

    The function value is the status of the call to the file system's entry
    point.

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    //
    //  If this is for our control device object, don't allow it to be opened.
    //

    if (IS_MY_CONTROL_DEVICE_OBJECT(DeviceObject)) {

        //
        //  Sfilter doesn't allow for any communication through its control
        //  device object, therefore it fails all requests to open a handle
        //  to its control device object.
        //
        //  See the FileSpy sample for an example of how to allow creates to 
        //  the filter's control device object and manage communication via
        //  that handle.
        //

        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  If debugging is enabled, do the processing required to see the packet
    //  upon its completion.  Otherwise, let the request go with no further
    //  processing.
    //

    if (!FlagOn( SfDebug, SFDEBUG_DO_CREATE_COMPLETION |
                          SFDEBUG_GET_CREATE_NAMES|
                          SFDEBUG_DISPLAY_CREATE_NAMES )) {

        //
        //  Don't put us on the stack then call the next driver
        //

        IoSkipCurrentIrpStackLocation( Irp );

        return IoCallDriver( ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject, Irp );

    } else {
    
        KEVENT waitEvent;

        //
        //  Initialize an event to wait for the completion routine to occur
        //

        KeInitializeEvent( &waitEvent, NotificationEvent, FALSE );

        //
        //  Copy the stack and set our Completion routine
        //

        IoCopyCurrentIrpStackLocationToNext( Irp );

        IoSetCompletionRoutine(
            Irp,
            SfCreateCompletion,
            &waitEvent,
            TRUE,
            TRUE,
            TRUE );

        //
        //  Call the next driver in the stack.
        //

        status = IoCallDriver( ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject, Irp );

        //
        //  Wait for the completion routine to be called
        //

	    if (STATUS_PENDING == status) {

            NTSTATUS localStatus = KeWaitForSingleObject(&waitEvent, Executive, KernelMode, FALSE, NULL);
		    ASSERT(STATUS_SUCCESS == localStatus);
	    }

        //
        //  Verify the IoCompleteRequest was called
        //

        ASSERT(KeReadStateEvent(&waitEvent) ||
               !NT_SUCCESS(Irp->IoStatus.Status));

        //
        //  Retrieve and display the filename if requested
        //

        if (FlagOn(SfDebug,
                   (SFDEBUG_GET_CREATE_NAMES|SFDEBUG_DISPLAY_CREATE_NAMES))) {

            SfDisplayCreateFileName( Irp );
        }

        //
        //  Save the status and continue processing the IRP
        //

        status = Irp->IoStatus.Status;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return status;
    }
}


NTSTATUS
SfCreateCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This function is the create/open completion routine for this filter
    file system driver.  If debugging is enabled, then this function prints
    the name of the file that was successfully opened/created by the file
    system as a result of the specified I/O request.

Arguments:

    DeviceObject - Pointer to the device on which the file was created.

    Irp - Pointer to the I/O Request Packet the represents the operation.

    Context - This driver's context parameter - unused;

Return Value:

    The function value is STATUS_SUCCESS.

--*/

{
    PKEVENT event = Context;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    KeSetEvent(event, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
SfCleanupClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked whenever a cleanup or a close request is to be
    processed.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

Note:

    See notes for SfPassThrough for this routine.


--*/

{
    PAGED_CODE();

    //
    //  Sfilter doesn't allow handles to its control device object to be created,
    //  therefore, no other operation should be able to come through.
    //
    
    ASSERT(!IS_MY_CONTROL_DEVICE_OBJECT( DeviceObject ));

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  Get this driver out of the driver stack and get to the next driver as
    //  quickly as possible.
    //

    IoSkipCurrentIrpStackLocation( Irp );

    //
    //  Now call the appropriate file system driver with the request.
    //

    return IoCallDriver( ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject, Irp );
}


NTSTATUS
SfFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked whenever an I/O Request Packet (IRP) w/a major
    function code of IRP_MJ_FILE_SYSTEM_CONTROL is encountered.  For most
    IRPs of this type, the packet is simply passed through.  However, for
    some requests, special processing is required.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    //
    //  Sfilter doesn't allow handles to its control device object to be created,
    //  therefore, no other operation should be able to come through.
    //
    
    ASSERT(!IS_MY_CONTROL_DEVICE_OBJECT( DeviceObject ));

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  Process the minor function code.
    //

    switch (irpSp->MinorFunction) {

        case IRP_MN_MOUNT_VOLUME:

            return SfFsControlMountVolume( DeviceObject, Irp );

        case IRP_MN_LOAD_FILE_SYSTEM:

            return SfFsControlLoadFileSystem( DeviceObject, Irp );

        case IRP_MN_USER_FS_REQUEST:
        {
            switch (irpSp->Parameters.FileSystemControl.FsControlCode) {

                case FSCTL_DISMOUNT_VOLUME:
                {
                    PSFILTER_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;

                    SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                                  ("SFilter!SfFsControl:                         Dismounting volume         %p \"%wZ\"\n",
                                   devExt->AttachedToDeviceObject,
                                   &devExt->DeviceName) );
                    break;
                }
            }
            break;
        }
    }        

    //
    //  Pass all other file system control requests through.
    //

    IoSkipCurrentIrpStackLocation( Irp );
    return IoCallDriver( ((PSFILTER_DEVICE_EXTENSION)DeviceObject->DeviceExtension)->AttachedToDeviceObject, Irp );
}


NTSTATUS
SfFsControlCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is invoked for the completion of an FsControl request.  It
    signals an event used to re-sync back to the dispatch routine.

Arguments:

    DeviceObject - Pointer to this driver's device object that was attached to
            the file system device object

    Irp - Pointer to the IRP that was just completed.

    Context - Pointer to the event to signal

--*/

{
    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));
    ASSERT(Context != NULL);

#if WINVER >= 0x0501
    if (IS_WINDOWSXP_OR_LATER()) {

        //
        //  On Windows XP or later, the context passed in will be an event
        //  to signal.
        //

        KeSetEvent((PKEVENT)Context, IO_NO_INCREMENT, FALSE);

    } else {
#endif
        //
        //  For Windows 2000, if we are not at passive level, we should 
        //  queue this work to a worker thread using the workitem that is in 
        //  Context.
        //

        if (KeGetCurrentIrql() > PASSIVE_LEVEL) {

            //
            //  We are not at passive level, but we need to be to do our work,
            //  so queue off to the worker thread.
            //
            
            ExQueueWorkItem( (PWORK_QUEUE_ITEM) Context,
                             DelayedWorkQueue );
            
        } else {

            PWORK_QUEUE_ITEM workItem = Context;

            //
            //  We are already at passive level, so we will just call our 
            //  worker routine directly.
            //

            (workItem->WorkerRoutine)(workItem->Parameter);
        }

#if WINVER >= 0x0501
    }
#endif

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
SfFsControlMountVolume (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This processes a MOUNT VOLUME request.

    NOTE:  The device object in the MountVolume parameters points
           to the top of the storage stack and should not be used.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The status of the operation.

--*/

{
    PSFILTER_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );
    PDEVICE_OBJECT newDeviceObject;
    PDEVICE_OBJECT storageStackDeviceObject;
    PSFILTER_DEVICE_EXTENSION newDevExt;
    NTSTATUS status;
    BOOLEAN isShadowCopyVolume;
    PFSCTRL_COMPLETION_CONTEXT completionContext;
    

    PAGED_CODE();

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));
    ASSERT(IS_DESIRED_DEVICE_TYPE(DeviceObject->DeviceType));

    //
    //  Get the real device object (also known as the storage stack device
    //  object or the disk device object) pointed to by the vpb parameter
    //  because this vpb may be changed by the underlying file system.
    //  Both FAT and CDFS may change the VPB address if the volume being
    //  mounted is one they recognize from a previous mount.
    //

    storageStackDeviceObject = irpSp->Parameters.MountVolume.Vpb->RealDevice;

    //
    //  Determine if this is a shadow copy volume.  If so don't attach to it.
    //  NOTE:  There is no reason sfilter shouldn't attach to these volumes,
    //         this is simply a sample of how to not attach if you don't want
    //         to
    //

    status = SfIsShadowCopyVolume ( storageStackDeviceObject, 
                                    &isShadowCopyVolume );

    if (NT_SUCCESS(status) && 
        isShadowCopyVolume &&
        !FlagOn(SfDebug,SFDEBUG_ATTACH_TO_SHADOW_COPIES)) {

        UNICODE_STRING shadowDeviceName;
        WCHAR shadowNameBuffer[MAX_DEVNAME_LENGTH];

        //
        //  Get the name for the debug display
        //

        RtlInitEmptyUnicodeString( &shadowDeviceName, 
                                   shadowNameBuffer, 
                                   sizeof(shadowNameBuffer) );

        SfGetObjectName( storageStackDeviceObject, 
                         &shadowDeviceName );

        SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                      ("SFilter!SfFsControlMountVolume               Not attaching to Volume    %p \"%wZ\", shadow copy volume\n", 
                       storageStackDeviceObject,
                       &shadowDeviceName) );

        //
        //  Go to the next driver
        //

        IoSkipCurrentIrpStackLocation( Irp );
        return IoCallDriver( devExt->AttachedToDeviceObject, Irp );
    }

    //
    //  This is a mount request.  Create a device object that can be
    //  attached to the file system's volume device object if this request
    //  is successful.  We allocate this memory now since we can not return
    //  an error in the completion routine.  
    //
    //  Since the device object we are going to attach to has not yet been
    //  created (it is created by the base file system) we are going to use
    //  the type of the file system control device object.  We are assuming
    //  that the file system control device object will have the same type
    //  as the volume device objects associated with it.
    //

    status = IoCreateDevice( gSFilterDriverObject,
                             sizeof( SFILTER_DEVICE_EXTENSION ),
                             NULL,
                             DeviceObject->DeviceType,
                             0,
                             FALSE,
                             &newDeviceObject );

    if (!NT_SUCCESS( status )) {

        //
        //  If we can not attach to the volume, then don't allow the volume
        //  to be mounted.
        //

        KdPrint(( "SFilter!SfFsControlMountVolume: Error creating volume device object, status=%08x\n", status ));

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return status;
    }

    //
    //  We need to save the RealDevice object pointed to by the vpb
    //  parameter because this vpb may be changed by the underlying
    //  file system.  Both FAT and CDFS may change the VPB address if
    //  the volume being mounted is one they recognize from a previous
    //  mount.
    //

    newDevExt = newDeviceObject->DeviceExtension;
    newDevExt->StorageStackDeviceObject = storageStackDeviceObject;

    //
    //  Get the name of this device
    //

    RtlInitEmptyUnicodeString( &newDevExt->DeviceName, 
                               newDevExt->DeviceNameBuffer, 
                               sizeof(newDevExt->DeviceNameBuffer) );

    SfGetObjectName( storageStackDeviceObject, 
                     &newDevExt->DeviceName );

    //
    //  VERSION NOTE:
    //
    //  On Windows 2000, we cannot simply synchronize back to the dispatch
    //  routine to do our post-mount processing.  We need to do this work at
    //  passive level, so we will queue that work to a worker thread from
    //  the completion routine.
    //
    //  For Windows XP and later, we can safely synchronize back to the dispatch
    //  routine.  The code below shows both methods.  Admittedly, the code
    //  would be simplified if you chose to only use one method or the other, 
    //  but you should be able to easily adapt this for your needs.
    //

#if WINVER >= 0x0501
    if (IS_WINDOWSXP_OR_LATER()) {

        KEVENT waitEvent;

        KeInitializeEvent( &waitEvent, 
                           NotificationEvent, 
                           FALSE );

        IoCopyCurrentIrpStackLocationToNext ( Irp );

        IoSetCompletionRoutine( Irp,
                                SfFsControlCompletion,
                                &waitEvent,     //context parameter
                                TRUE,
                                TRUE,
                                TRUE );

        status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );

        //
        //  Wait for the operation to complete
        //

    	if (STATUS_PENDING == status) {

    		status = KeWaitForSingleObject( &waitEvent,
    		                                Executive,
    		                                KernelMode,
    		                                FALSE,
    		                                NULL );
    	    ASSERT( STATUS_SUCCESS == status );
    	}

        //
        //  Verify the IoCompleteRequest was called
        //

        ASSERT(KeReadStateEvent(&waitEvent) ||
               !NT_SUCCESS(Irp->IoStatus.Status));

        status = SfFsControlMountVolumeComplete( DeviceObject,
                                                 Irp,
                                                 newDeviceObject );

    } else {
#endif    
        //
        //  Initialize our completion routine
        //
        
        completionContext = ExAllocatePoolWithTag( NonPagedPool, 
                                                   sizeof( FSCTRL_COMPLETION_CONTEXT ),
                                                   SFLT_POOL_TAG );

        if (completionContext == NULL) {

            //
            //  If we cannot allocate our completion context, we will just pass 
            //  through the operation.  If your filter must be present for data
            //  access to this volume, you should consider failing the operation
            //  if memory cannot be allocated here.
            //

            IoSkipCurrentIrpStackLocation( Irp );
            status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );

        } else {

            ExInitializeWorkItem( &completionContext->WorkItem, 
                                  SfFsControlMountVolumeCompleteWorker, 
                                  completionContext );

            completionContext->DeviceObject = DeviceObject;
            completionContext->Irp = Irp;
            completionContext->NewDeviceObject = newDeviceObject;

            IoCopyCurrentIrpStackLocationToNext( Irp );

            IoSetCompletionRoutine( Irp,
                                    SfFsControlCompletion,
                                    &completionContext->WorkItem, //context parameter
                                    TRUE,
                                    TRUE,
                                    TRUE );

            //
            //  Call the driver
            //

            status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );
        }
#if WINVER >= 0x0501        
    }
#endif

    return status;
}

VOID
SfFsControlMountVolumeCompleteWorker (
    IN PFSCTRL_COMPLETION_CONTEXT Context
    )
/*++

Routine Description:

    The worker thread routine that will call our common routine to do the
    post-MountVolume work.

Arguments:

    Context - The context passed to this worker thread.
    
Return Value:

    None.

--*/
{
    ASSERT( Context != NULL );

    SfFsControlMountVolumeComplete( Context->DeviceObject,
                                    Context->Irp,
                                    Context->NewDeviceObject );

    ExFreePoolWithTag( Context, SFLT_POOL_TAG );
}

NTSTATUS
SfFsControlMountVolumeComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_OBJECT NewDeviceObject
    )
/*++

Routine Description:

    This does the post-Mount work and must be done at PASSIVE_LEVEL.

Arguments:

    DeviceObject - The device object for this operation,

    Irp - The IRP for this operation that we will complete once we are finished
        with it.
    
Return Value:

    Returns the status of the mount operation.

--*/
{
    PVPB vpb;
    PSFILTER_DEVICE_EXTENSION newDevExt;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT attachedDeviceObject;
    NTSTATUS status;

    PAGED_CODE();

    newDevExt = NewDeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );
    
    //
    //  Get the correct VPB from the real device object saved in our
    //  device extension.  We do this because the VPB in the IRP stack
    //  may not be the correct VPB when we get here.  The underlying
    //  file system may change VPBs if it detects a volume it has
    //  mounted previously.
    //

    vpb = newDevExt->StorageStackDeviceObject->Vpb;

    //
    //  Display a message when we detect that the VPB for the given
    //  device object has changed.
    //

    if (vpb != irpSp->Parameters.MountVolume.Vpb) {

        SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                      ("SFilter!SfFsControlMountVolume:              VPB in IRP stack changed   %p IRPVPB=%p VPB=%p\n",
                       vpb->DeviceObject,
                       irpSp->Parameters.MountVolume.Vpb,
                       vpb) );
    }

    //
    //  See if the mount was successful.
    //

    if (NT_SUCCESS( Irp->IoStatus.Status )) {

        //
        //  Acquire lock so we can atomically test if we area already attached
        //  and if not, then attach.  This prevents a double attach race
        //  condition.
        //

        ExAcquireFastMutex( &gSfilterAttachLock );

        //
        //  The mount succeeded.  If we are not already attached, attach to the
        //  device object.  Note: one reason we could already be attached is
        //  if the underlying file system revived a previous mount.
        //

        if (!SfIsAttachedToDevice( vpb->DeviceObject, &attachedDeviceObject )) {

            //
            //  Attach to the new mounted volume.  The file system device
            //  object that was just mounted is pointed to by the VPB.
            //

            status = SfAttachToMountedDevice( vpb->DeviceObject,
                                              NewDeviceObject );

            if (!NT_SUCCESS( status )) { 

                //
                //  The attachment failed, cleanup.  Since we are in the
                //  post-mount phase, we can not fail this operation.
                //  We simply won't be attached.  The only reason this should
                //  ever happen at this point is if somebody already started
                //  dismounting the volume therefore not attaching should
                //  not be a problem.
                //

                SfCleanupMountedDevice( NewDeviceObject );
                IoDeleteDevice( NewDeviceObject );
            }

            ASSERT( NULL == attachedDeviceObject );

        } else {

            //
            //  We were already attached, handle it
            //

            SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                          ("SFilter!SfFsControlMountVolume               Mount volume failure for   %p \"%wZ\", already attached\n", 
                           ((PSFILTER_DEVICE_EXTENSION)attachedDeviceObject->DeviceExtension)->AttachedToDeviceObject,
                           &newDevExt->DeviceName) );

            //
            //  Cleanup and delete the device object we created
            //

            SfCleanupMountedDevice( NewDeviceObject );
            IoDeleteDevice( NewDeviceObject );

            //
            //  Dereference the returned attached device object
            //

            ObDereferenceObject( attachedDeviceObject );
        }

        //
        //  Release the lock
        //

        ExReleaseFastMutex( &gSfilterAttachLock );

    } else {

        //
        //  The mount request failed, handle it.
        //

        SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                      ("SFilter!SfFsControlMountVolume:              Mount volume failure for   %p \"%wZ\", status=%08x\n", 
                       DeviceObject,
                       &newDevExt->DeviceName, 
                       Irp->IoStatus.Status) );

        //
        //  Cleanup and delete the device object we created
        //

        SfCleanupMountedDevice( NewDeviceObject );
        IoDeleteDevice( NewDeviceObject );
    }

    //
    //  Complete the request.  
    //  NOTE:  We must save the status before completing because after
    //         completing the IRP we can not longer access it (it might be
    //         freed).
    //

    status = Irp->IoStatus.Status;

    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}

NTSTATUS
SfFsControlLoadFileSystem (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked whenever an I/O Request Packet (IRP) w/a major
    function code of IRP_MJ_FILE_SYSTEM_CONTROL is encountered.  For most
    IRPs of this type, the packet is simply passed through.  However, for
    some requests, special processing is required.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    PSFILTER_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    NTSTATUS status;
    PFSCTRL_COMPLETION_CONTEXT completionContext;
        

    PAGED_CODE();

    //
    //  This is a "load file system" request being sent to a file system
    //  recognizer device object.  This IRP_MN code is only sent to 
    //  file system recognizers.
    //
    //  NOTE:  Since we no longer are attaching to the standard Microsoft file
    //         system recognizers we will normally never execute this code.
    //         However, there might be 3rd party file systems which have their
    //         own recognizer which may still trigger this IRP.
    //

    SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                  ("SFilter!SfFscontrolLoadFileSystem:           Loading File System, Detaching from \"%wZ\"\n", 
                   &devExt->DeviceName) );


    //
    //  VERSION NOTE:
    //
    //  On Windows 2000, we cannot simply synchronize back to the dispatch
    //  routine to do our post-load filesystem processing.  We need to do 
    //  this work at passive level, so we will queue that work to a worker 
    //  thread from the completion routine.
    //
    //  For Windows XP and later, we can safely synchronize back to the dispatch
    //  routine.  The code below shows both methods.  Admittedly, the code
    //  would be simplified if you chose to only use one method or the other, 
    //  but you should be able to easily adapt this for your needs.
    //

#if WINVER >= 0x0501
    if (IS_WINDOWSXP_OR_LATER()) {

        KEVENT waitEvent;
        
        KeInitializeEvent( &waitEvent, 
                           NotificationEvent, 
                           FALSE );

        IoCopyCurrentIrpStackLocationToNext( Irp );
        
        IoSetCompletionRoutine( Irp,
                                SfFsControlCompletion,
                                &waitEvent,     //context parameter
                                TRUE,
                                TRUE,
                                TRUE );

        status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );

        //
        //  Wait for the operation to complete
        //

    	if (STATUS_PENDING == status) {

    		status = KeWaitForSingleObject( &waitEvent,
    		                                Executive,
    		                                KernelMode,
    		                                FALSE,
    		                                NULL );
    	    ASSERT( STATUS_SUCCESS == status );
    	}

        //
        //  Verify the IoCompleteRequest was called
        //

        ASSERT(KeReadStateEvent(&waitEvent) ||
               !NT_SUCCESS(Irp->IoStatus.Status));

        status = SfFsControlLoadFileSystemComplete( DeviceObject,
                                                    Irp );

    } else {
#endif    
    
        //
        //  Set a completion routine so we can delete the device object when
        //  the load is complete.
        //

        completionContext = ExAllocatePoolWithTag( NonPagedPool, 
                                                   sizeof( FSCTRL_COMPLETION_CONTEXT ),
                                                   SFLT_POOL_TAG );

        if (completionContext == NULL) {

            //
            //  If we cannot allocate our completion context, we will just pass 
            //  through the operation.  If your filter must be present for data
            //  access to this volume, you should consider failing the operation
            //  if memory cannot be allocated here.
            //

            IoSkipCurrentIrpStackLocation( Irp );
            status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );

        } else {

            ExInitializeWorkItem( &completionContext->WorkItem,
                                  SfFsControlLoadFileSystemCompleteWorker,
                                  completionContext );
            completionContext->DeviceObject = DeviceObject;
            completionContext->Irp = Irp;
            completionContext->NewDeviceObject = NULL;
              
            IoCopyCurrentIrpStackLocationToNext( Irp );

            IoSetCompletionRoutine(
                Irp,
                SfFsControlCompletion,
                completionContext,
                TRUE,
                TRUE,
                TRUE );

            //
            //  Detach from the file system recognizer device object.
            //

            IoDetachDevice( devExt->AttachedToDeviceObject );

            //
            //  Call the driver
            //

            status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );
        }
#if WINVER >= 0x0501        
    }
#endif   
    
    return status;
}

VOID
SfFsControlLoadFileSystemCompleteWorker (
    IN PFSCTRL_COMPLETION_CONTEXT Context
    )
/*++

Routine Description:

    The worker thread routine that will call our common routine to do the
    post-LoadFileSystem work.

Arguments:

    Context - The context passed to this worker thread.
    
Return Value:

    None.

--*/
{
    ASSERT( NULL != Context );

    SfFsControlLoadFileSystemComplete( Context->DeviceObject,
                                       Context->Irp );

    ExFreePoolWithTag( Context, SFLT_POOL_TAG );
}

NTSTATUS
SfFsControlLoadFileSystemComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This does the post-LoadFileSystem work and must be done as PASSIVE_LEVEL.

Arguments:

    DeviceObject - The device object for this operation,

    Irp - The IRP for this operation that we will complete once we are finished
        with it.
    
Return Value:

    Returns the status of the load file system operation.

--*/
{
    PSFILTER_DEVICE_EXTENSION devExt;
    NTSTATUS status;

    PAGED_CODE();

    devExt = DeviceObject->DeviceExtension;
    
    //
    //  Display the name if requested
    //

    SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                  ("SFilter!SfFsControlLoadFileSystem:           Detaching from recognizer  %p \"%wZ\", status=%08x\n", 
                   DeviceObject,
                   &devExt->DeviceName,
                   Irp->IoStatus.Status) );

    //
    //  Check status of the operation
    //

    if (!NT_SUCCESS( Irp->IoStatus.Status ) && 
        (Irp->IoStatus.Status != STATUS_IMAGE_ALREADY_LOADED)) {

        //
        //  The load was not successful.  Simply reattach to the recognizer
        //  driver in case it ever figures out how to get the driver loaded
        //  on a subsequent call.  There is not a lot we can do if this
        //  reattach fails.
        //

        SfAttachDeviceToDeviceStack( DeviceObject, 
                                     devExt->AttachedToDeviceObject,
                                     &devExt->AttachedToDeviceObject );

        ASSERT(devExt->AttachedToDeviceObject != NULL);

    } else {

        //
        //  The load was successful, so cleanup this device and delete the 
        //  Device object
        //

        SfCleanupMountedDevice( DeviceObject );
        IoDeleteDevice( DeviceObject );
    }

    //
    //  Continue processing the operation
    //

    status = Irp->IoStatus.Status;

    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}

/////////////////////////////////////////////////////////////////////////////
//
//                      FastIO Handling routines
//
/////////////////////////////////////////////////////////////////////////////

BOOLEAN
SfFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for checking to see
    whether fast I/O is possible for this file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be operated on.

    FileOffset - Byte offset in the file for the operation.

    Length - Length of the operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    CheckForReadOperation - Indicates whether the caller is checking for a
        read (TRUE) or a write operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoCheckIfPossible )) {

            return (fastIoDispatch->FastIoCheckIfPossible)(
                        FileObject,
                        FileOffset,
                        Length,
                        Wait,
                        LockKey,
                        CheckForReadOperation,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading from a
    file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be read.

    FileOffset - Byte offset in the file of the read.

    Length - Length of the read operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer to receive the data read.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoRead )) {

            return (fastIoDispatch->FastIoRead)(
                        FileObject,
                        FileOffset,
                        Length,
                        Wait,
                        LockKey,
                        Buffer,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing to a
    file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be written.

    FileOffset - Byte offset in the file of the write operation.

    Length - Length of the write operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer that contains the data to be
        written.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();
    
    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoWrite )) {

            return (fastIoDispatch->FastIoWrite)(
                        FileObject,
                        FileOffset,
                        Length,
                        Wait,
                        LockKey,
                        Buffer,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying basic
    information about the file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryBasicInfo )) {

            return (fastIoDispatch->FastIoQueryBasicInfo)(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoQueryStandardInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying standard
    information about the file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryStandardInfo )) {

            return (fastIoDispatch->FastIoQueryStandardInfo)(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for locking a byte
    range within a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be locked.

    FileOffset - Starting byte offset from the base of the file to be locked.

    Length - Length of the byte range to be locked.

    ProcessId - ID of the process requesting the file lock.

    Key - Lock key to associate with the file lock.

    FailImmediately - Indicates whether or not the lock request is to fail
        if it cannot be immediately be granted.

    ExclusiveLock - Indicates whether the lock to be taken is exclusive (TRUE)
        or shared.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoLock )) {

            return (fastIoDispatch->FastIoLock)(
                        FileObject,
                        FileOffset,
                        Length,
                        ProcessId,
                        Key,
                        FailImmediately,
                        ExclusiveLock,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking a byte
    range within a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    FileOffset - Starting byte offset from the base of the file to be
        unlocked.

    Length - Length of the byte range to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the file lock.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockSingle )) {

            return (fastIoDispatch->FastIoUnlockSingle)(
                        FileObject,
                        FileOffset,
                        Length,
                        ProcessId,
                        Key,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;

        if (nextDeviceObject) {

            fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

            if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockAll )) {

                return (fastIoDispatch->FastIoUnlockAll)(
                            FileObject,
                            ProcessId,
                            IoStatus,
                            nextDeviceObject );
            }
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file based on a specified key.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the locks on the file to be released.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockAllByKey )) {

            return (fastIoDispatch->FastIoUnlockAllByKey)(
                        FileObject,
                        ProcessId,
                        Key,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoDeviceControl (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for device I/O control
    operations on a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object representing the device to be
        serviced.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    InputBuffer - Optional pointer to a buffer to be passed into the driver.

    InputBufferLength - Length of the optional InputBuffer, if one was
        specified.

    OutputBuffer - Optional pointer to a buffer to receive data from the
        driver.

    OutputBufferLength - Length of the optional OutputBuffer, if one was
        specified.

    IoControlCode - I/O control code indicating the operation to be performed
        on the device.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoDeviceControl )) {

            return (fastIoDispatch->FastIoDeviceControl)(
                        FileObject,
                        Wait,
                        InputBuffer,
                        InputBufferLength,
                        OutputBuffer,
                        OutputBufferLength,
                        IoControlCode,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


VOID
SfFastIoDetachDevice (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
    )

/*++

Routine Description:

    This routine is invoked on the fast path to detach from a device that
    is being deleted.  This occurs when this driver has attached to a file
    system volume device object, and then, for some reason, the file system
    decides to delete that device (it is being dismounted, it was dismounted
    at some point in the past and its last reference has just gone away, etc.)

Arguments:

    SourceDevice - Pointer to my device object, which is attached
        to the file system's volume device object.

    TargetDevice - Pointer to the file system's volume device object.

Return Value:

    None

--*/

{
    PSFILTER_DEVICE_EXTENSION devExt;

    PAGED_CODE();

    ASSERT(IS_MY_DEVICE_OBJECT( SourceDevice ));

    devExt = SourceDevice->DeviceExtension;

    //
    //  Display name information
    //

    SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                  ("SFilter!SfFastIoDetachDevice:                Detaching from volume      %p \"%wZ\"\n",
                   TargetDevice,
                   &devExt->DeviceName) );

    //
    //  Detach from the file system's volume device object.
    //

    SfCleanupMountedDevice( SourceDevice );
    IoDetachDevice( TargetDevice );
    IoDeleteDevice( SourceDevice );
}


BOOLEAN
SfFastIoQueryNetworkOpenInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying network
    information about a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller can handle the file system
        having to wait and tie up the current thread.

    Buffer - Pointer to a buffer to receive the network information about the
        file.

    IoStatus - Pointer to a variable to receive the final status of the query
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryNetworkOpenInfo )) {

            return (fastIoDispatch->FastIoQueryNetworkOpenInfo)(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoMdlRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading a file
    using MDLs as buffers.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that is to be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlRead )) {

            return (fastIoDispatch->MdlRead)(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        MdlChain,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoMdlReadComplete (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read operation.

    This function simply invokes the file system's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the MdlRead function is supported by the underlying file system, and
    therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL read upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlReadComplete )) {

            return (fastIoDispatch->MdlReadComplete)(
                        FileObject,
                        MdlChain,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoPrepareMdlWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for preparing for an
    MDL write operation.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, PrepareMdlWrite )) {

            return (fastIoDispatch->PrepareMdlWrite)(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        MdlChain,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoMdlWriteComplete (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL write operation.

    This function simply invokes the file system's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the PrepareMdlWrite function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not
    assumed by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL write upon.

    FileOffset - Supplies the file offset at which the write took place.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlWriteComplete )) {

            return (fastIoDispatch->MdlWriteComplete)(
                        FileObject,
                        FileOffset,
                        MdlChain,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


/*********************************************************************************
        UNIMPLEMENTED FAST IO ROUTINES
        
        The following four Fast IO routines are for compression on the wire
        which is not yet implemented in NT.  
        
        NOTE:  It is highly recommended that you include these routines (which
               do a pass-through call) so your filter will not need to be
               modified in the future when this functionality is implemented in
               the OS.
        
        FastIoReadCompressed, FastIoWriteCompressed, 
        FastIoMdlReadCompleteCompressed, FastIoMdlWriteCompleteCompressed
**********************************************************************************/


BOOLEAN
SfFastIoReadCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading compressed
    data from a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to a buffer to receive the compressed data read.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    CompressedDataInfo - A buffer to receive the description of the compressed
        data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoReadCompressed )) {

            return (fastIoDispatch->FastIoReadCompressed)(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        Buffer,
                        MdlChain,
                        IoStatus,
                        CompressedDataInfo,
                        CompressedDataInfoLength,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoWriteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing compressed
    data to a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to the buffer containing the data to be written.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    CompressedDataInfo - A buffer to containing the description of the
        compressed data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoWriteCompressed )) {

            return (fastIoDispatch->FastIoWriteCompressed)(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        Buffer,
                        MdlChain,
                        IoStatus,
                        CompressedDataInfo,
                        CompressedDataInfoLength,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoMdlReadCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read compressed operation.

    This function simply invokes the file system's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the read compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed read
        upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlReadCompleteCompressed )) {

            return (fastIoDispatch->MdlReadCompleteCompressed)(
                        FileObject,
                        MdlChain,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoMdlWriteCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing a
    write compressed operation.

    This function simply invokes the file system's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the write compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed write
        upon.

    FileOffset - Supplies the file offset at which the file write operation
        began.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlWriteCompleteCompressed )) {

            return (fastIoDispatch->MdlWriteCompleteCompressed)(
                        FileObject,
                        FileOffset,
                        MdlChain,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


BOOLEAN
SfFastIoQueryOpen (
    IN PIRP Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for opening a file
    and returning network information for it.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    Irp - Pointer to a create IRP that represents this open operation.  It is
        to be used by the file system for common open/create code, but not
        actually completed.

    NetworkInformation - A buffer to receive the information required by the
        network about the file being opened.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN result;

    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PSFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->AttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryOpen )) {

            PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );

            //
            //  Before calling the next filter, we must make sure their device
            //  object is in the current stack entry for the given IRP
            //

            irpSp->DeviceObject = nextDeviceObject;

            result = (fastIoDispatch->FastIoQueryOpen)(
                        Irp,
                        NetworkInformation,
                        nextDeviceObject );

            //
            //  Always restore the IRP back to our device object
            //

            irpSp->DeviceObject = DeviceObject;
            return result;
        }
    }
    return FALSE;
}

#if WINVER >= 0x0501 /* See comment in DriverEntry */
/////////////////////////////////////////////////////////////////////////////
//
//                  FSFilter callback handling routines
//
/////////////////////////////////////////////////////////////////////////////

NTSTATUS
SfPreFsFilterPassThrough(
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext
    )
/*++

Routine Description:

    This routine is the FS Filter pre-operation "pass through" routine.

Arguments:

    Data - The FS_FILTER_CALLBACK_DATA structure containing the information
        about this operation.
        
    CompletionContext - A context set by this operation that will be passed
        to the corresponding SfPostFsFilterOperation call.
        
Return Value:

    Returns STATUS_SUCCESS if the operation can continue or an appropriate
    error code if the operation should fail.

--*/
{
    UNREFERENCED_PARAMETER( Data );
    UNREFERENCED_PARAMETER( CompletionContext );

    ASSERT( IS_MY_DEVICE_OBJECT( Data->DeviceObject ) );

    return STATUS_SUCCESS;
}

VOID
SfPostFsFilterPassThrough (
    IN PFS_FILTER_CALLBACK_DATA Data,
    IN NTSTATUS OperationStatus,
    IN PVOID CompletionContext
    )
/*++

Routine Description:

    This routine is the FS Filter post-operation "pass through" routine.

Arguments:

    Data - The FS_FILTER_CALLBACK_DATA structure containing the information
        about this operation.
        
    OperationStatus - The status of this operation.        
    
    CompletionContext - A context that was set in the pre-operation 
        callback by this driver.
        
Return Value:

    None.
    
--*/
{
    UNREFERENCED_PARAMETER( Data );
    UNREFERENCED_PARAMETER( OperationStatus );
    UNREFERENCED_PARAMETER( CompletionContext );

    ASSERT( IS_MY_DEVICE_OBJECT( Data->DeviceObject ) );
}
#endif

/////////////////////////////////////////////////////////////////////////////
//
//                  Support routines
//
/////////////////////////////////////////////////////////////////////////////

NTSTATUS
SfAttachDeviceToDeviceStack (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice,
    IN OUT PDEVICE_OBJECT *AttachedToDeviceObject
    )
/*++

Routine Description:

    This routine attaches the SourceDevice to the TargetDevice's stack and
    returns the device object SourceDevice was directly attached to in 
    AttachedToDeviceObject.  Note that the SourceDevice does not necessarily
    get attached directly to TargetDevice.  The SourceDevice will get attached
    to the top of the stack of which TargetDevice is a member.

    VERSION NOTE:

    In Windows XP, a new API was introduced to close a rare timing window that 
    can cause IOs to start being sent to a device before its 
    AttachedToDeviceObject is set in its device extension.  This is possible
    if a filter is attaching to a device stack while the system is actively
    processing IOs.  The new API closes this timing window by setting the
    device extension field that holds the AttachedToDeviceObject while holding
    the IO Manager's lock that protects the device stack.

    A sufficient work around for earlier versions of the OS is to set the
    AttachedToDeviceObject to the device object that the SourceDevice is most
    likely to attach to.  While it is possible that another filter will attach
    in between the SourceDevice and TargetDevice, this will prevent the
    system from bug checking if the SourceDevice receives IOs before the 
    AttachedToDeviceObject is correctly set.

    For a driver built in the Windows 2000 build environment, we will always 
    use the work-around code to attach.  For a driver that is built in the 
    Windows XP or later build environments (therefore you are building a 
    multiversion driver), we will determine which method of attachment to use 
    based on which APIs are available.

Arguments:

    SourceDevice - The device object to be attached to the stack.

    TargetDevice - The device that we currently think is the top of the stack
        to which SourceDevice should be attached.

    AttachedToDeviceObject - This is set to the device object to which 
        SourceDevice is attached if the attach is successful.
        
Return Value:

    Return STATUS_SUCCESS if the device is successfully attached.  If 
    TargetDevice represents a stack to which devices can no longer be attached,
    STATUS_NO_SUCH_DEVICE is returned.

--*/
{

    PAGED_CODE();

#if WINVER >= 0x0501

    if (IS_WINDOWSXP_OR_LATER()) {

        ASSERT( NULL != gSfDynamicFunctions.AttachDeviceToDeviceStackSafe );
        return (gSfDynamicFunctions.AttachDeviceToDeviceStackSafe)( SourceDevice,
                                                                    TargetDevice,
                                                                    AttachedToDeviceObject );

    } else {

        ASSERT( NULL == gSfDynamicFunctions.AttachDeviceToDeviceStackSafe );
#endif

        *AttachedToDeviceObject = TargetDevice;
        *AttachedToDeviceObject = IoAttachDeviceToDeviceStack( SourceDevice,
                                                               TargetDevice );

        if (*AttachedToDeviceObject == NULL) {

            return STATUS_NO_SUCH_DEVICE;
        }

        return STATUS_SUCCESS;

#if WINVER >= 0x0501
    }
#endif
}
    
NTSTATUS
SfAttachToFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING DeviceName
    )
/*++

Routine Description:

    This will attach to the given file system device object.  We attach to
    these devices so we will know when new volumes are mounted.

Arguments:

    DeviceObject - The device to attach to

    Name - An already initialized unicode string used to retrieve names.
           This is passed in to reduce the number of strings buffers on
           the stack.

Return Value:

    Status of the operation

--*/
{
    PDEVICE_OBJECT newDeviceObject;
    PSFILTER_DEVICE_EXTENSION devExt;
    UNICODE_STRING fsrecName;
    NTSTATUS status;
    UNICODE_STRING fsName;
    WCHAR tempNameBuffer[MAX_DEVNAME_LENGTH];

    PAGED_CODE();

    //
    //  See if this is a file system type we care about.  If not, return.
    //

    if (!IS_DESIRED_DEVICE_TYPE(DeviceObject->DeviceType)) {

        return STATUS_SUCCESS;
    }

    //
    //  always init NAME buffer
    //

    RtlInitEmptyUnicodeString( &fsName,
                               tempNameBuffer,
                               sizeof(tempNameBuffer) );

    //
    //  See if we should attach to the standard file system recognizer device
    //  or not
    //

    if (!FlagOn(SfDebug,SFDEBUG_ATTACH_TO_FSRECOGNIZER)) {

        //
        //  See if this is one of the standard Microsoft file system recognizer
        //  devices (see if this device is in the FS_REC driver).  If so skip
        //  it.  We no longer attach to file system recognizer devices, we
        //  simply wait for the real file system driver to load.
        //

        RtlInitUnicodeString( &fsrecName, L"\\FileSystem\\Fs_Rec" );

        SfGetObjectName( DeviceObject->DriverObject, &fsName );

        if (RtlCompareUnicodeString( &fsName, &fsrecName, TRUE ) == 0) {

            return STATUS_SUCCESS;
        }
    }

    //
    //  We want to attach to this file system.  Create a new device object we
    //  can attach with.
    //

    status = IoCreateDevice( gSFilterDriverObject,
                             sizeof( SFILTER_DEVICE_EXTENSION ),
                             NULL,
                             DeviceObject->DeviceType,
                             0,
                             FALSE,
                             &newDeviceObject );

    if (!NT_SUCCESS( status )) {

        return status;
    }

    //
    //  Propagate flags from Device Object we are trying to attach to.
    //  Note that we do this before the actual attachment to make sure
    //  the flags are properly set once we are attached (since an IRP
    //  can come in immediately after attachment but before the flags would
    //  be set).
    //

    if ( FlagOn( DeviceObject->Flags, DO_BUFFERED_IO )) {

        SetFlag( newDeviceObject->Flags, DO_BUFFERED_IO );
    }

    if ( FlagOn( DeviceObject->Flags, DO_DIRECT_IO )) {

        SetFlag( newDeviceObject->Flags, DO_DIRECT_IO );
    }

    if ( FlagOn( DeviceObject->Characteristics, FILE_DEVICE_SECURE_OPEN ) ) {

        SetFlag( newDeviceObject->Characteristics, FILE_DEVICE_SECURE_OPEN );
    }

    //
    //  Do the attachment
    //

    devExt = newDeviceObject->DeviceExtension;

    status = SfAttachDeviceToDeviceStack( newDeviceObject, 
                                          DeviceObject, 
                                          &devExt->AttachedToDeviceObject );

    if (!NT_SUCCESS( status )) {

        goto ErrorCleanupDevice;
    }

    //
    //  Set the name
    //

    RtlInitEmptyUnicodeString( &devExt->DeviceName,
                               devExt->DeviceNameBuffer,
                               sizeof(devExt->DeviceNameBuffer) );

    RtlCopyUnicodeString( &devExt->DeviceName, DeviceName );        //Save Name

    //
    //  Mark we are done initializing
    //

    ClearFlag( newDeviceObject->Flags, DO_DEVICE_INITIALIZING );

    //
    //  Display who we have attached to
    //

    SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                  ("SFilter!SfAttachToFileSystemDevice:          Attaching to file system   %p \"%wZ\" (%s)\n",
                   DeviceObject,
                   &devExt->DeviceName,
                   GET_DEVICE_TYPE_NAME(newDeviceObject->DeviceType)) );

    //
    //  VERSION NOTE:
    //
    //  In Windows XP, the IO Manager provided APIs to safely enumerate all the
    //  device objects for a given driver.  This allows filters to attach to 
    //  all mounted volumes for a given file system at some time after the
    //  volume has been mounted.  There is no support for this functionality
    //  in Windows 2000.
    //
    //  MULTIVERSION NOTE:
    //
    //  If built for Windows XP or later, this driver is built to run on 
    //  multiple versions.  When this is the case, we will test
    //  for the presence of the new IO Manager routines that allow for volume 
    //  enumeration.  If they are not present, we will not enumerate the volumes
    //  when we attach to a new file system.
    //
    
#if WINVER >= 0x0501

    if (IS_WINDOWSXP_OR_LATER()) {

        ASSERT( NULL != gSfDynamicFunctions.EnumerateDeviceObjectList &&
                NULL != gSfDynamicFunctions.GetDiskDeviceObject &&
                NULL != gSfDynamicFunctions.GetDeviceAttachmentBaseRef &&
                NULL != gSfDynamicFunctions.GetLowerDeviceObject );

        //
        //  Enumerate all the mounted devices that currently
        //  exist for this file system and attach to them.
        //

        status = SfEnumerateFileSystemVolumes( DeviceObject, &fsName );

        if (!NT_SUCCESS( status )) {

            IoDetachDevice( devExt->AttachedToDeviceObject );
            goto ErrorCleanupDevice;
        }
    }
    
#endif

    return STATUS_SUCCESS;

    /////////////////////////////////////////////////////////////////////
    //                  Cleanup error handling
    /////////////////////////////////////////////////////////////////////

    ErrorCleanupDevice:
        SfCleanupMountedDevice( newDeviceObject );
        IoDeleteDevice( newDeviceObject );

    return status;
}


VOID
SfDetachFromFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Given a base file system device object, this will scan up the attachment
    chain looking for our attached device object.  If found it will detach
    us from the chain.

Arguments:

    DeviceObject - The file system device to detach from.

Return Value:

--*/ 
{
    PDEVICE_OBJECT ourAttachedDevice;
    PSFILTER_DEVICE_EXTENSION devExt;

    PAGED_CODE();

    //
    //  Skip the base file system device object (since it can't be us)
    //

    ourAttachedDevice = DeviceObject->AttachedDevice;

    while (NULL != ourAttachedDevice) {

        if (IS_MY_DEVICE_OBJECT( ourAttachedDevice )) {

            devExt = ourAttachedDevice->DeviceExtension;

            //
            //  Display who we detached from
            //

            SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                          ("SFilter!SfDetachFromFileSystemDevice:        Detaching from file system %p \"%wZ\" (%s)\n",
                           devExt->AttachedToDeviceObject,
                           &devExt->DeviceName,
                           GET_DEVICE_TYPE_NAME(ourAttachedDevice->DeviceType)) );

            //
            //  Detach us from the object just below us
            //  Cleanup and delete the object
            //

            SfCleanupMountedDevice( ourAttachedDevice );
            IoDetachDevice( DeviceObject );
            IoDeleteDevice( ourAttachedDevice );

            return;
        }

        //
        //  Look at the next device up in the attachment chain
        //

        DeviceObject = ourAttachedDevice;
        ourAttachedDevice = ourAttachedDevice->AttachedDevice;
    }
}

#if WINVER >= 0x0501
NTSTATUS
SfEnumerateFileSystemVolumes (
    IN PDEVICE_OBJECT FSDeviceObject,
    IN PUNICODE_STRING Name
    ) 
/*++

Routine Description:

    Enumerate all the mounted devices that currently exist for the given file
    system and attach to them.  We do this because this filter could be loaded
    at any time and there might already be mounted volumes for this file system.

Arguments:

    FSDeviceObject - The device object for the file system we want to enumerate

    Name - An already initialized unicode string used to retrieve names
           This is passed in to reduce the number of strings buffers on
           the stack.

Return Value:

    The status of the operation

--*/
{
    PDEVICE_OBJECT newDeviceObject;
    PSFILTER_DEVICE_EXTENSION newDevExt;
    PDEVICE_OBJECT *devList;
    PDEVICE_OBJECT storageStackDeviceObject;
    NTSTATUS status;
    ULONG numDevices;
    ULONG i;
    BOOLEAN isShadowCopyVolume;

    PAGED_CODE();

    //
    //  Find out how big of an array we need to allocate for the
    //  mounted device list.
    //

    status = (gSfDynamicFunctions.EnumerateDeviceObjectList)(
                    FSDeviceObject->DriverObject,
                    NULL,
                    0,
                    &numDevices);

    //
    //  We only need to get this list of there are devices.  If we
    //  don't get an error there are no devices so go on.
    //

    if (!NT_SUCCESS( status )) {

        ASSERT(STATUS_BUFFER_TOO_SMALL == status);

        //
        //  Allocate memory for the list of known devices
        //

        numDevices += 8;        //grab a few extra slots

        devList = ExAllocatePoolWithTag( NonPagedPool, 
                                         (numDevices * sizeof(PDEVICE_OBJECT)), 
                                         SFLT_POOL_TAG );
        if (NULL == devList) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Now get the list of devices.  If we get an error again
        //  something is wrong, so just fail.
        //

        ASSERT( NULL != gSfDynamicFunctions.EnumerateDeviceObjectList );
        status = (gSfDynamicFunctions.EnumerateDeviceObjectList)(
                        FSDeviceObject->DriverObject,
                        devList,
                        (numDevices * sizeof(PDEVICE_OBJECT)),
                        &numDevices);

        if (!NT_SUCCESS( status ))  {

            ExFreePool( devList );
            return status;
        }

        //
        //  Walk the given list of devices and attach to them if we should.
        //

        for (i=0; i < numDevices; i++) {

            //
            //  Initialize state so we can cleanup properly
            //

            storageStackDeviceObject = NULL;

            try {

                //
                //  Do not attach if:
                //      - This is the control device object (the one passed in)
                //      - The device type does not match
                //      - We are already attached to it.
                //

                if ((devList[i] == FSDeviceObject) ||
                    (devList[i]->DeviceType != FSDeviceObject->DeviceType) ||
                    SfIsAttachedToDevice( devList[i], NULL )) {

                    leave;
                }

                //
                //  See if this device has a name.  If so, then it must
                //  be a control device so don't attach to it.  This handles
                //  drivers with more then one control device (like FastFat).
                //

                SfGetBaseDeviceObjectName( devList[i], Name );

                if (Name->Length > 0) {

                    leave;
                }

                //
                //  Get the real (disk,storage stack) device object associated
                //  with this file system device object.  Only try to attach
                //  if we have a disk device object.
                //

                ASSERT( NULL != gSfDynamicFunctions.GetDiskDeviceObject );
                status = (gSfDynamicFunctions.GetDiskDeviceObject)( devList[i], 
                                                                   &storageStackDeviceObject );

                if (!NT_SUCCESS( status )) {

                    leave;
                }

                //
                //  Determine if this is a shadow copy volume.  If so don't
                //  attach to it.
                //  NOTE:  There is no reason sfilter shouldn't attach to these
                //         volumes, this is simply a sample of how to not
                //         attach if you don't want to
                //

                status = SfIsShadowCopyVolume ( storageStackDeviceObject, 
                                                &isShadowCopyVolume );

                if (NT_SUCCESS(status) &&
                    isShadowCopyVolume &&
                    !FlagOn(SfDebug,SFDEBUG_ATTACH_TO_SHADOW_COPIES)) {

                    UNICODE_STRING shadowDeviceName;
                    WCHAR shadowNameBuffer[MAX_DEVNAME_LENGTH];

                    //
                    //  Get the name for the debug display
                    //

                    RtlInitEmptyUnicodeString( &shadowDeviceName, 
                                               shadowNameBuffer, 
                                               sizeof(shadowNameBuffer) );

                    SfGetObjectName( storageStackDeviceObject, 
                                     &shadowDeviceName );

                    SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                                  ("SFilter!SfEnumerateFileSystemVolumes         Not attaching to Volume    %p \"%wZ\", shadow copy volume\n", 
                                   storageStackDeviceObject,
                                   &shadowDeviceName) );

                    leave;
                }

                //
                //  Allocate a new device object to attach with
                //

                status = IoCreateDevice( gSFilterDriverObject,
                                         sizeof( SFILTER_DEVICE_EXTENSION ),
                                         NULL,
                                         devList[i]->DeviceType,
                                         0,
                                         FALSE,
                                         &newDeviceObject );

                if (!NT_SUCCESS( status )) {

                    leave;
                }

                //
                //  Set disk device object
                //

                newDevExt = newDeviceObject->DeviceExtension;
                newDevExt->StorageStackDeviceObject = storageStackDeviceObject;
        
                //
                //  Set storage stack device name
                //

                RtlInitEmptyUnicodeString( &newDevExt->DeviceName,
                                           newDevExt->DeviceNameBuffer,
                                           sizeof(newDevExt->DeviceNameBuffer) );

                SfGetObjectName( storageStackDeviceObject, 
                                 &newDevExt->DeviceName );


                //
                //  We have done a lot of work since the last time
                //  we tested to see if we were already attached
                //  to this device object.  Test again, this time
                //  with a lock, and attach if we are not attached.
                //  The lock is used to atomically test if we are
                //  attached, and then do the attach.
                //

                ExAcquireFastMutex( &gSfilterAttachLock );

                if (!SfIsAttachedToDevice( devList[i], NULL )) {

                    //
                    //  Attach to volume.
                    //

                    status = SfAttachToMountedDevice( devList[i], 
                                                      newDeviceObject );
                    
                    if (!NT_SUCCESS( status )) { 

                        //
                        //  The attachment failed, cleanup.  Note that
                        //  we continue processing so we will cleanup
                        //  the reference counts and try to attach to
                        //  the rest of the volumes.
                        //
                        //  One of the reasons this could have failed
                        //  is because this volume is just being
                        //  mounted as we are attaching and the
                        //  DO_DEVICE_INITIALIZING flag has not yet
                        //  been cleared.  A filter could handle
                        //  this situation by pausing for a short
                        //  period of time and retrying the attachment a
                        //  limited number of times.
                        //

                        SfCleanupMountedDevice( newDeviceObject );
                        IoDeleteDevice( newDeviceObject );
                    }

                } else {

                    //
                    //  We were already attached, cleanup this
                    //  device object.
                    //

                    SfCleanupMountedDevice( newDeviceObject );
                    IoDeleteDevice( newDeviceObject );
                }

                //
                //  Release the lock
                //

                ExReleaseFastMutex( &gSfilterAttachLock );

            } finally {

                //
                //  Remove reference added by IoGetDiskDeviceObject.
                //  We only need to hold this reference until we are
                //  successfully attached to the current volume.  Once
                //  we are successfully attached to devList[i], the
                //  IO Manager will make sure that the underlying
                //  storageStackDeviceObject will not go away until
                //  the file system stack is torn down.
                //

                if (storageStackDeviceObject != NULL) {

                    ObDereferenceObject( storageStackDeviceObject );
                }

                //
                //  Dereference the object (reference added by 
                //  IoEnumerateDeviceObjectList)
                //

                ObDereferenceObject( devList[i] );
            }
        }

        //
        //  We are going to ignore any errors received while attaching.  We
        //  simply won't be attached to those volumes if we get an error
        //

        status = STATUS_SUCCESS;

        //
        //  Free the memory we allocated for the list
        //

        ExFreePool( devList );
    }

    return status;
}
#endif

NTSTATUS
SfAttachToMountedDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT SFilterDeviceObject
    )
/*++

Routine Description:

    This will attach to a DeviceObject that represents a mounted volume.

Arguments:

    DeviceObject - The device to attach to

    SFilterDeviceObject - Our device object we are going to attach

Return Value:

    Status of the operation

--*/
{        
    PSFILTER_DEVICE_EXTENSION newDevExt = SFilterDeviceObject->DeviceExtension;
    NTSTATUS status;
    ULONG i;

    PAGED_CODE();
    ASSERT(IS_MY_DEVICE_OBJECT( SFilterDeviceObject ));
#if WINVER >= 0x0501    
    ASSERT(!SfIsAttachedToDevice ( DeviceObject, NULL ));
#endif

    //
    //  Propagate flags from Device Object we are trying to attach to.
    //  Note that we do this before the actual attachment to make sure
    //  the flags are properly set once we are attached (since an IRP
    //  can come in immediately after attachment but before the flags would
    //  be set).
    //

    if (FlagOn( DeviceObject->Flags, DO_BUFFERED_IO )) {

        SetFlag( SFilterDeviceObject->Flags, DO_BUFFERED_IO );
    }

    if (FlagOn( DeviceObject->Flags, DO_DIRECT_IO )) {

        SetFlag( SFilterDeviceObject->Flags, DO_DIRECT_IO );
    }

    //
    //  It is possible for this attachment request to fail because this device
    //  object has not finished initializing.  This can occur if this filter
    //  loaded just as this volume was being mounted.
    //

    for (i=0; i < 8; i++) {
        LARGE_INTEGER interval;

        //
        //  Attach our device object to the given device object
        //  The only reason this can fail is if someone is trying to dismount
        //  this volume while we are attaching to it.
        //

        status = SfAttachDeviceToDeviceStack( SFilterDeviceObject, 
                                              DeviceObject,
                                              &newDevExt->AttachedToDeviceObject );
        if (NT_SUCCESS(status)) {

            //
            //  Finished all initialization of the new device object,  so clear the
            //  initializing flag now.  This allows other filters to now attach
            //  to our device object.
            //

            ClearFlag( SFilterDeviceObject->Flags, DO_DEVICE_INITIALIZING );

            //
            //  Display the name
            //

            SF_LOG_PRINT( SFDEBUG_DISPLAY_ATTACHMENT_NAMES,
                          ("SFilter!SfAttachToMountedDevice:             Attaching to volume        %p \"%wZ\"\n", 
                           newDevExt->AttachedToDeviceObject,
                           &newDevExt->DeviceName) );

            return STATUS_SUCCESS;
        }

        //
        //  Delay, giving the device object a chance to finish its
        //  initialization so we can try again
        //

        interval.QuadPart = (500 * DELAY_ONE_MILLISECOND);      //delay 1/2 second
        KeDelayExecutionThread( KernelMode, FALSE, &interval );
    }

    return status;
}

VOID
SfCleanupMountedDevice (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This cleans up any necessary data in the device extension to prepare for
    this memory to be freed.

Arguments:

    DeviceObject - The device we are cleaning up

Return Value:

    None

--*/
{        

    UNREFERENCED_PARAMETER( DeviceObject );
    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));
}


VOID
SfGetObjectName (
    IN PVOID Object,
    IN OUT PUNICODE_STRING Name
    )
/*++

Routine Description:

    This routine will return the name of the given object.
    If a name can not be found an empty string will be returned.

Arguments:

    Object - The object whose name we want

    Name - A unicode string that is already initialized with a buffer that
           receives the name of the object.

Return Value:

    None

--*/
{
    NTSTATUS status;
    CHAR nibuf[512];        //buffer that receives NAME information and name
    POBJECT_NAME_INFORMATION nameInfo = (POBJECT_NAME_INFORMATION)nibuf;
    ULONG retLength;

    status = ObQueryNameString( Object, nameInfo, sizeof(nibuf), &retLength);

    Name->Length = 0;
    if (NT_SUCCESS( status )) {

        RtlCopyUnicodeString( Name, &nameInfo->Name );
    }
}

//
//  VERSION NOTE:
//
//  This helper routine is only needed when enumerating all volumes in the
//  system, which is only supported on Windows XP and later.
//

#if WINVER >= 0x0501
VOID
SfGetBaseDeviceObjectName (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
    )
/*++

Routine Description:

    This locates the base device object in the given attachment chain and then
    returns the name of that object.

    If no name can be found, an empty string is returned.

Arguments:

    Object - The object whose name we want

    Name - A unicode string that is already initialized with a buffer that
           receives the name of the device object.

Return Value:

    None

--*/
{
    //
    //  Get the base file system device object
    //

    ASSERT( NULL != gSfDynamicFunctions.GetDeviceAttachmentBaseRef );
    DeviceObject = (gSfDynamicFunctions.GetDeviceAttachmentBaseRef)( DeviceObject );

    //
    //  Get the name of that object
    //

    SfGetObjectName( DeviceObject, Name );

    //
    //  Remove the reference added by IoGetDeviceAttachmentBaseRef
    //

    ObDereferenceObject( DeviceObject );
}
#endif

PUNICODE_STRING
SfGetFileName(
    IN PFILE_OBJECT FileObject,
    IN NTSTATUS CreateStatus,
    IN OUT PGET_NAME_CONTROL NameControl
    )
/*++

Routine Description:

    This routine will try and get the name of the given file object.  This
    is guaranteed to always return a printable string (though it may be NULL).
    This will allocate a buffer if it needs to.

Arguments:
    FileObject - the file object we want the name for

    CreateStatus - status of the create operation

    NameControl - control structure used for retrieving the name.  It keeps
        track if a buffer was allocated or if we are using the internal
        buffer.

Return Value:

    Pointer to the unicode string with the name

--*/
{
    POBJECT_NAME_INFORMATION nameInfo;
    NTSTATUS status;
    ULONG size;
    ULONG bufferSize;

    //
    //  Mark we have not allocated the buffer
    //

    NameControl->allocatedBuffer = NULL;

    //
    //  Use the small buffer in the structure (that will handle most cases)
    //  for the name
    //

    nameInfo = (POBJECT_NAME_INFORMATION)NameControl->smallBuffer;
    bufferSize = sizeof(NameControl->smallBuffer);

    //
    //  If the open succeeded, get the name of the file, if it
    //  failed, get the name of the device.
    //
        
    status = ObQueryNameString(
                  (NT_SUCCESS( CreateStatus ) ?
                    (PVOID)FileObject :
                    (PVOID)FileObject->DeviceObject),
                  nameInfo,
                  bufferSize,
                  &size );

    //
    //  See if the buffer was to small
    //

    if (status == STATUS_BUFFER_OVERFLOW) {

        //
        //  The buffer was too small, allocate one big enough
        //

        bufferSize = size + sizeof(WCHAR);

        NameControl->allocatedBuffer = ExAllocatePoolWithTag( 
                                            NonPagedPool,
                                            bufferSize,
                                            SFLT_POOL_TAG );

        if (NULL == NameControl->allocatedBuffer) {

            //
            //  Failed allocating a buffer, return an empty string for the name
            //

            RtlInitEmptyUnicodeString(
                (PUNICODE_STRING)&NameControl->smallBuffer,
                (PWCHAR)(NameControl->smallBuffer + sizeof(UNICODE_STRING)),
                (USHORT)(sizeof(NameControl->smallBuffer) - sizeof(UNICODE_STRING)) );

            return (PUNICODE_STRING)&NameControl->smallBuffer;
        }

        //
        //  Set the allocated buffer and get the name again
        //

        nameInfo = (POBJECT_NAME_INFORMATION)NameControl->allocatedBuffer;

        status = ObQueryNameString(
                      FileObject,
                      nameInfo,
                      bufferSize,
                      &size );
    }

    //
    //  If we got a name and an error opening the file then we
    //  just received the device name.  Grab the rest of the name
    //  from the FileObject (note that this can only be done if being called
    //  from Create).  This only happens if we got an error back from the
    //  create.
    //

    if (NT_SUCCESS( status ) && 
                    !NT_SUCCESS( CreateStatus )) {

        ULONG newSize;
        PCHAR newBuffer;
        POBJECT_NAME_INFORMATION newNameInfo;

        //
        //  Calculate the size of the buffer we will need to hold
        //  the combined names
        //

        newSize = size + FileObject->FileName.Length;

        //
        //  If there is a related file object add in the length
        //  of that plus space for a separator
        //

        if (NULL != FileObject->RelatedFileObject) {

            newSize += FileObject->RelatedFileObject->FileName.Length + 
                       sizeof(WCHAR);
        }

        //
        //  See if it will fit in the existing buffer
        //

        if (newSize > bufferSize) {

            //
            //  It does not fit, allocate a bigger buffer
            //

            newBuffer = ExAllocatePoolWithTag( 
                                    NonPagedPool,
                                    newSize,
                                    SFLT_POOL_TAG );

            if (NULL == newBuffer) {

                //
                //  Failed allocating a buffer, return an empty string for the name
                //

                RtlInitEmptyUnicodeString(
                    (PUNICODE_STRING)&NameControl->smallBuffer,
                    (PWCHAR)(NameControl->smallBuffer + sizeof(UNICODE_STRING)),
                    (USHORT)(sizeof(NameControl->smallBuffer) - sizeof(UNICODE_STRING)) );

                return (PUNICODE_STRING)&NameControl->smallBuffer;
            }

            //
            //  Now initialize the new buffer with the information
            //  from the old buffer.
            //

            newNameInfo = (POBJECT_NAME_INFORMATION)newBuffer;

            RtlInitEmptyUnicodeString(
                &newNameInfo->Name,
                (PWCHAR)(newBuffer + sizeof(OBJECT_NAME_INFORMATION)),
                (USHORT)(newSize - sizeof(OBJECT_NAME_INFORMATION)) );

            RtlCopyUnicodeString( &newNameInfo->Name, 
                                  &nameInfo->Name );

            //
            //  Free the old allocated buffer (if there is one)
            //  and save off the new allocated buffer address.  It
            //  would be very rare that we should have to free the
            //  old buffer because device names should always fit
            //  inside it.
            //

            if (NULL != NameControl->allocatedBuffer) {

                ExFreePool( NameControl->allocatedBuffer );
            }

            //
            //  Readjust our pointers
            //

            NameControl->allocatedBuffer = newBuffer;
            bufferSize = newSize;
            nameInfo = newNameInfo;

        } else {

            //
            //  The MaximumLength was set by ObQueryNameString to
            //  one char larger then the length.  Set it to the
            //  true size of the buffer (so we can append the names)
            //

            nameInfo->Name.MaximumLength = (USHORT)(bufferSize - 
                                  sizeof(OBJECT_NAME_INFORMATION));
        }

        //
        //  If there is a related file object, append that name
        //  first onto the device object along with a separator
        //  character
        //

        if (NULL != FileObject->RelatedFileObject) {

            RtlAppendUnicodeStringToString(
                    &nameInfo->Name,
                    &FileObject->RelatedFileObject->FileName );

            RtlAppendUnicodeToString( &nameInfo->Name, L"\\" );
        }

        //
        //  Append the name from the file object
        //

        RtlAppendUnicodeStringToString(
                &nameInfo->Name,
                &FileObject->FileName );

        ASSERT(nameInfo->Name.Length <= nameInfo->Name.MaximumLength);
    }

    //
    //  Return the name
    //

    return &nameInfo->Name;
}


VOID
SfGetFileNameCleanup(
    IN OUT PGET_NAME_CONTROL NameControl
    )
/*++

Routine Description:

    This will see if a buffer was allocated and will free it if it was

Arguments:

    NameControl - control structure used for retrieving the name.  It keeps
        track if a buffer was allocated or if we are using the internal
        buffer.

Return Value:

    None

--*/
{

    if (NULL != NameControl->allocatedBuffer) {

        ExFreePool( NameControl->allocatedBuffer);
        NameControl->allocatedBuffer = NULL;
    }
}

//
//  VERSION NOTE:
//  
//  In Windows 2000, the APIs to safely walk an arbitrary file system device 
//  stack were not supported.  If we can guarantee that a device stack won't 
//  be torn down during the walking of the device stack, we can walk from
//  the base file system's device object up to the top of the device stack
//  to see if we are attached.  We know the device stack will not go away if
//  we are in the process of processing a mount request OR we have a file object
//  open on this device.
//  
//  In Windows XP and later, the IO Manager provides APIs that will allow us to
//  walk through the chain safely using reference counts to protect the device 
//  object from going away while we are inspecting it.  This can be done at any
//  time.
//
//  MULTIVERSION NOTE:
//
//  If built for Windows XP or later, this driver is built to run on 
//  multiple versions.  When this is the case, we will test for the presence of
//  the new IO Manager routines that allow for a filter to safely walk the file
//  system device stack and use those APIs if they are present to determine if
//  we have already attached to this volume.  If these new IO Manager routines
//  are not present, we will assume that we are at the bottom of the file
//  system stack and walk up the stack looking for our device object.
//

BOOLEAN
SfIsAttachedToDevice (
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL
    )
{

    PAGED_CODE();

#if WINVER >= 0x0501
    if (IS_WINDOWSXP_OR_LATER()) {

        ASSERT( NULL != gSfDynamicFunctions.GetLowerDeviceObject &&
                NULL != gSfDynamicFunctions.GetDeviceAttachmentBaseRef );
        
        return SfIsAttachedToDeviceWXPAndLater( DeviceObject, AttachedDeviceObject );
    } else {
#endif

        return SfIsAttachedToDeviceW2K( DeviceObject, AttachedDeviceObject );

#if WINVER >= 0x0501
    }
#endif    
}

BOOLEAN
SfIsAttachedToDeviceW2K (
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL
    )
/*++

Routine Description:

    VERSION: Windows 2000

    This routine walks up the device stack from the DeviceObject passed in
    looking for a device object that belongs to our filter.

    Note:  If AttachedDeviceObject is returned with a non-NULL value,
           there is a reference on the AttachedDeviceObject that must
           be cleared by the caller.

Arguments:

    DeviceObject - The device chain we want to look through

    AttachedDeviceObject - Set to the deviceObject which FileSpy
            has previously attached to DeviceObject.

Return Value:

    TRUE if we are attached, FALSE if not

--*/
{
    PDEVICE_OBJECT currentDevice;

    PAGED_CODE();

    for (currentDevice = DeviceObject;
         currentDevice != NULL;
         currentDevice = currentDevice->AttachedDevice) {

        if (IS_MY_DEVICE_OBJECT( currentDevice )) {

            //
            //  We are attached.  If requested, return the found device object.
            //

            if (ARGUMENT_PRESENT(AttachedDeviceObject)) {

                ObReferenceObject( currentDevice );
                *AttachedDeviceObject = currentDevice;
            }

            return TRUE;
        }
    }

    //
    //  We did not find ourselves on the attachment chain.  Return a NULL
    //  device object pointer (if requested) and return we did not find
    //  ourselves.
    //
    
    if (ARGUMENT_PRESENT(AttachedDeviceObject)) {

        *AttachedDeviceObject = NULL;
    }

    return FALSE;
}

#if WINVER >= 0x0501
BOOLEAN
SfIsAttachedToDeviceWXPAndLater (
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL
    )
/*++

Routine Description:

    VERSION: Windows XP and later

    This walks down the attachment chain looking for a device object that
    belongs to this driver.  If one is found, the attached device object
    is returned in AttachedDeviceObject.

Arguments:

    DeviceObject - The device chain we want to look through

    AttachedDeviceObject - The Sfilter device attached to this device.

Return Value:

    TRUE if we are attached, FALSE if not

--*/
{
    PDEVICE_OBJECT currentDevObj;
    PDEVICE_OBJECT nextDevObj;

    PAGED_CODE();
    
    //
    //  Get the device object at the TOP of the attachment chain
    //

    ASSERT( NULL != gSfDynamicFunctions.GetAttachedDeviceReference );
    currentDevObj = (gSfDynamicFunctions.GetAttachedDeviceReference)( DeviceObject );

    //
    //  Scan down the list to find our device object.
    //

    do {
    
        if (IS_MY_DEVICE_OBJECT( currentDevObj )) {

            //
            //  We have found that we are already attached.  If we are
            //  returning the device object, leave it referenced else remove
            //  the reference.
            //

            if (ARGUMENT_PRESENT(AttachedDeviceObject)) {

                *AttachedDeviceObject = currentDevObj;

            } else {

                ObDereferenceObject( currentDevObj );
            }

            return TRUE;
        }

        //
        //  Get the next attached object.  This puts a reference on 
        //  the device object.
        //

        ASSERT( NULL != gSfDynamicFunctions.GetLowerDeviceObject );
        nextDevObj = (gSfDynamicFunctions.GetLowerDeviceObject)( currentDevObj );

        //
        //  Dereference our current device object, before
        //  moving to the next one.
        //

        ObDereferenceObject( currentDevObj );

        currentDevObj = nextDevObj;
        
    } while (NULL != currentDevObj);
    
    //
    //  We did not find ourselves on the attachment chain.  Return a NULL
    //  device object pointer (if requested) and return we did not find
    //  ourselves.
    //

    if (ARGUMENT_PRESENT(AttachedDeviceObject)) {

        *AttachedDeviceObject = NULL;
    }

    return FALSE;
}    
#endif

VOID
SfReadDriverParameters (
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine tries to read the sfilter-specific parameters from 
    the registry.  These values will be found in the registry location
    indicated by the RegistryPath passed in.

Arguments:

    RegistryPath - the path key passed to the driver during driver entry.
        
Return Value:

    None.

--*/
{
    OBJECT_ATTRIBUTES attributes;
    HANDLE driverRegKey;
    NTSTATUS status;
    ULONG resultLength;
    UNICODE_STRING valueName;
    UCHAR buffer[sizeof( KEY_VALUE_PARTIAL_INFORMATION ) + sizeof( LONG )];

    PAGED_CODE();

    //
    //  If this value is not the default value then somebody has already
    //  explicitly set it so don't override those settings.
    //

    if (0 == SfDebug) {

        //
        //  Open the desired registry key
        //

        InitializeObjectAttributes( &attributes,
                                    RegistryPath,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL );

        status = ZwOpenKey( &driverRegKey,
                            KEY_READ,
                            &attributes );

        if (!NT_SUCCESS( status )) {

            return;
        }

        //
        // Read the DebugDisplay value from the registry.
        //

        RtlInitUnicodeString( &valueName, L"DebugFlags" );
    
        status = ZwQueryValueKey( driverRegKey,
                                  &valueName,
                                  KeyValuePartialInformation,
                                  buffer,
                                  sizeof(buffer),
                                  &resultLength );

        if (NT_SUCCESS( status )) {

            SfDebug = *((PLONG) &(((PKEY_VALUE_PARTIAL_INFORMATION) buffer)->Data));
        } 

        //
        //  Close the registry entry
        //

        ZwClose(driverRegKey);
    }
}


NTSTATUS
SfIsShadowCopyVolume (
    IN PDEVICE_OBJECT StorageStackDeviceObject,
    OUT PBOOLEAN IsShadowCopy
    )
/*++

Routine Description:

    This routine will determine if the given volume is for a ShadowCopy volume
    or some other type of volume.

    VERSION NOTE:

    ShadowCopy volumes were introduced in Windows XP, therefore, if this
    driver is running on W2K, we know that this is not a shadow copy volume.

    Also note that in Windows XP, we need to test to see if the driver name
    of this device object is \Driver\VolSnap in addition to seeing if this
    device is read-only.  For Windows Server 2003, we can infer that
    this is a ShadowCopy by looking for a DeviceType == FILE_DEVICE_VIRTUAL_DISK
    and read-only volume.
    
Arguments:

    StorageStackDeviceObject - pointer to the disk device object
    IsShadowCopy - returns TRUE if this is a shadow copy, FALSE otherwise
        
Return Value:

    The status of the operation.  If this operation fails IsShadowCopy is
    always set to FALSE.

--*/
{

    PAGED_CODE();

    //
    //  Default to NOT a shadow copy volume
    //

    *IsShadowCopy = FALSE;

#if WINVER >= 0x0501
    if (IS_WINDOWS2000()) {
#endif        

        UNREFERENCED_PARAMETER( StorageStackDeviceObject );
        return STATUS_SUCCESS;

#if WINVER >= 0x0501        
    }

    if (IS_WINDOWSXP()) {

        UNICODE_STRING volSnapDriverName;
        WCHAR buffer[MAX_DEVNAME_LENGTH];
        PUNICODE_STRING storageDriverName;
        ULONG returnedLength;
        NTSTATUS status;

        //
        //  In Windows XP, all ShadowCopy devices were of type FILE_DISK_DEVICE.
        //  If this does not have a device type of FILE_DISK_DEVICE, then
        //  it is not a ShadowCopy volume.  Return now.
        //

        if (FILE_DEVICE_DISK != StorageStackDeviceObject->DeviceType) {

            return STATUS_SUCCESS;
        }

        //
        //  Unfortunately, looking for the FILE_DEVICE_DISK isn't enough.  We
        //  need to find out if the name of this driver is \Driver\VolSnap as
        //  well.
        //

        storageDriverName = (PUNICODE_STRING) buffer;
        RtlInitEmptyUnicodeString( storageDriverName, 
                                   Add2Ptr( storageDriverName, sizeof( UNICODE_STRING ) ),
                                   sizeof( buffer ) - sizeof( UNICODE_STRING ) );

        status = ObQueryNameString( StorageStackDeviceObject,
                                    (POBJECT_NAME_INFORMATION)storageDriverName,
                                    storageDriverName->MaximumLength,
                                    &returnedLength );

        if (!NT_SUCCESS( status )) {

            return status;
        }

        RtlInitUnicodeString( &volSnapDriverName, L"\\Driver\\VolSnap" );

        if (RtlEqualUnicodeString( storageDriverName, &volSnapDriverName, TRUE )) {

            //
            // This is a ShadowCopy volume, so set our return parameter to true.
            //

            *IsShadowCopy = TRUE;

        } else {

            //
            //  This is not a ShadowCopy volume, but IsShadowCopy is already 
            //  set to FALSE.  Fall through to return to the caller.
            //

            NOTHING;
        }

        return STATUS_SUCCESS;
        
    } else {

        PIRP irp;
        KEVENT event;
        IO_STATUS_BLOCK iosb;
        NTSTATUS status;

        //
        //  For Windows Server 2003 and later, it is sufficient to test for a
        //  device type fo FILE_DEVICE_VIRTUAL_DISK and that the device
        //  is read-only to identify a ShadowCopy.
        //

        //
        //  If this does not have a device type of FILE_DEVICE_VIRTUAL_DISK, then
        //  it is not a ShadowCopy volume.  Return now.
        //

        if (FILE_DEVICE_VIRTUAL_DISK != StorageStackDeviceObject->DeviceType) {

            return STATUS_SUCCESS;
        }

        //
        //  It has the correct device type, see if it is marked as read only.
        //
        //  NOTE:  You need to be careful which device types you do this operation
        //         on.  It is accurate for this type but for other device
        //         types it may return misleading information.  For example the
        //         current microsoft cdrom driver always returns CD media as
        //         readonly, even if the media may be writable.  On other types
        //         this state may change.
        //

        KeInitializeEvent( &event, NotificationEvent, FALSE );

        irp = IoBuildDeviceIoControlRequest( IOCTL_DISK_IS_WRITABLE,
                                             StorageStackDeviceObject,
                                             NULL,
                                             0,
                                             NULL,
                                             0,
                                             FALSE,
                                             &event,
                                             &iosb );

        //
        //  If we could not allocate an IRP, return an error
        //

        if (irp == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Call the storage stack and see if this is readonly
        //

        status = IoCallDriver( StorageStackDeviceObject, irp );

        if (status == STATUS_PENDING) {

            (VOID)KeWaitForSingleObject( &event,
                                         Executive,
                                         KernelMode,
                                         FALSE,
                                         NULL );

            status = iosb.Status;
        }

        //
        //  If the media is write protected then this is a shadow copy volume
        //

        if (STATUS_MEDIA_WRITE_PROTECTED == status) {

            *IsShadowCopy = TRUE;
            status = STATUS_SUCCESS;
        }

        //
        //  Return the status of the IOCTL.  IsShadowCopy is already set to FALSE
        //  which is what we want if STATUS_SUCCESS was returned or if an error
        //  was returned.
        //

        return status;
    }
#endif    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\latency\filter\latkernel.h ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    latKernel.h

Abstract:

    The header file containing information needed by the
    kernel mode of the latency filter driver.
    
Author:

    Molly Brown (mollybro)  

Environment:

    Kernel mode

--*/
#include <ntifs.h>
#include <stdlib.h>


#ifndef __LATKERNEL_H__
#define __LATKERNEL_H__

typedef struct _LATENCY_GLOBALS {

	ULONG DebugLevel;
	ULONG AttachMode;

	PDRIVER_OBJECT DriverObject;
	PDEVICE_OBJECT ControlDeviceObject;

	//
	//  The list of device extensions for the device objects
	//  we have attached to mounted volumes that we could
	//  be adding latency to.  
	//

	FAST_MUTEX DeviceExtensionListLock;
	LIST_ENTRY DeviceExtensionList;

	BOOLEAN FilterOn;

} LATENCY_GLOBALS, *PLATENCY_GLOBALS;

extern LATENCY_GLOBALS Globals;
extern KSPIN_LOCK GlobalsLock;

typedef struct _PENDING_STATUS {

	BOOLEAN PendOperation;
	BOOLEAN RandomFailure;
	ULONG FailureRate;
	ULONG MillisecondDelay;

} PENDING_STATUS, *PPENDING_STATUS;

typedef struct _OPERATION_NODE {

    //
    //  Array of PENDING_STATUS structures that describes
    //  the state for each operation at this level.
    //
    
    PENDING_STATUS Op[];

    //
    //  Pointer to a child operation node, if one exists,
    //  that allows finer grained control over the sub-operations
    //  
    
    struct _OPERATION_NODE *ChildOpNode;

} OPERATION_NODE, *POPERATION_NODE;
    
#define DEVICE_NAMES_SZ  100
#define USER_NAMES_SZ   64

typedef struct _LATENCY_DEVICE_EXTENSION {

    BOOLEAN Enabled;
    BOOLEAN IsVolumeDeviceObject;
    
	PDEVICE_OBJECT AttachedToDeviceObject;
	PDEVICE_OBJECT DiskDeviceObject;

	PLIST_ENTRY NextLatencyDeviceLink;

    UNICODE_STRING DeviceNames;              // receives name of device
    UNICODE_STRING UserNames;                // names that the user used to 
                                             //   start logging this device

	OPERATION_NODE IrpMajorOps[];            // The memory for the IrpMj code operation
	                                         //   nodes and any sub-operation node will be
	                                         //   allocated contiguously with the device
	                                         //   extension.	

    WCHAR DeviceNamesBuffer[DEVICE_NAMES_SZ];// holds actual device names
    WCHAR UserNamesBuffer[USER_NAMES_SZ];    // holds actual user names

    //
    //  Note: We keep these two forms of the name so that we can build
    //    a nicer looking name when we are printing out file names.
    //    We want just the "c:" type device name at the beginning
    //    of a file name, not "\device\hardiskVolume1".
    //
	
} LATENCY_DEVICE_EXTENSION, *PLATENCY_DEVICE_EXTENSION;

#define IS_MY_DEVICE_OBJECT( _devObj )                     \
    (((_devObj) != NULL) &&                                \
     ((_devObj)->DriverObject == Globals.DriverObject) &&  \
     ((_devObj)->DeviceExtension != NULL))

//
// Macro to test if we are logging for this device
// NOTE: We don't bother synchronizing to check the Globals.FilterOn since
//   we can tolerate a stale value here.  We just look at it here to avoid 
//   doing the logging work if we can.
//

#define SHOULD_PEND(pDeviceObject) \
    ((Globals.FilterOn) && \
     (((PLATENCY_DEVICE_EXTENSION)(pDeviceObject)->DeviceExtension)->Enabled))
     
//
//  Macro for validating the FastIo dispatch routines before calling
//  them in the FastIo pass through functions.
//

#define VALID_FAST_IO_DISPATCH_HANDLER(FastIoDispatchPtr, FieldName) \
    (((FastIoDispatchPtr) != NULL) && \
     (((FastIoDispatchPtr)->SizeOfFastIoDispatch) >= \
      (FIELD_OFFSET(FAST_IO_DISPATCH, FieldName) + sizeof(VOID *))) && \
     ((FastIoDispatchPtr)->FieldName != NULL))

//
//  list of known device types
//

extern const PCHAR DeviceTypeNames[];

//
//  We need this because the compiler doesn't like doing sizeof an externed
//  array in the other file that needs it (latlib.c)
//

extern ULONG SizeOfDeviceTypeNames;

#define GET_DEVICE_TYPE_NAME( _type ) \
            ((((_type) > 0) && ((_type) < (SizeOfDeviceTypeNames / sizeof(PCHAR)))) ? \
                DeviceTypeNames[ (_type) ] : \
                "[Unknown]")

//
//  Macro to test for device types we want to attach to
//

#define IS_DESIRED_DEVICE_TYPE(_type) \
    (((_type) == FILE_DEVICE_DISK_FILE_SYSTEM) || \
     ((_type) == FILE_DEVICE_CD_ROM_FILE_SYSTEM) || \
     ((_type) == FILE_DEVICE_NETWORK_FILE_SYSTEM))

//
//  Macros for Latency DbgPrint levels.
//

#if DBG
#define LAT_DBG_PRINT0( _dbgLevel, _string )          \
    {                                                     \
        if (FlagOn( Globals.DebugLevel, (_dbgLevel) )) {  \
            DbgPrint( (_string) );                        \
        }                                                 \
    }

#define LAT_DBG_PRINT1( _dbgLevel, _formatString, _parm1 )  \
    {                                                           \
        if (FlagOn( Globals.DebugLevel, (_dbgLevel) )) {        \
            DbgPrint( (_formatString), (_parm1) );              \
        }                                                       \
    }

#define LAT_DBG_PRINT2( _dbgLevel, _formatString, _parm1, _parm2 )  \
    {                                                                   \
        if (FlagOn( Globals.DebugLevel, (_dbgLevel) )) {                \
            DbgPrint( (_formatString), (_parm1), (_parm2) );            \
        }                                                               \
    }

#define LAT_DBG_PRINT3( _dbgLevel, _formatString, _parm1, _parm2, _parm3 )  \
    {                                                                           \
        if (FlagOn( Globals.DebugLevel, (_dbgLevel) )) {                        \
            DbgPrint( (_formatString), (_parm1), (_parm2), (_parm3) );          \
        }                                                                       \
    }

#else

#define LAT_DBG_PRINT0( _dbgLevel, _string )
#define LAT_DBG_PRINT1( _dbgLevel, _formatString, _parm1 ) 
#define LAT_DBG_PRINT2( _dbgLevel, _formatString, _parm1, _parm2 )
#define LAT_DBG_PRINT3( _dbgLevel, _formatString, _parm1, _parm2, _parm3 )

#endif

//
//  Debug flags
//
#define DEBUG_ERROR                       0x00000001
#define DEBUG_DISPLAY_ATTACHMENT_NAMES    0x00000020

//
//  Pool tags
//

#define LATENCY_POOL_TAG    'FtaL'

///////////////////////////////////////////////////////////////
//                                                           //
//  Prototypes for Latency.c                                 //
//                                                           //
///////////////////////////////////////////////////////////////

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
);

NTSTATUS
LatDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

NTSTATUS
LatPassThrough (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

NTSTATUS
LatFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

VOID
LatFsNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FsActive
);

NTSTATUS
LatAddLatencyCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
LatMountCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );
    
NTSTATUS
LatLoadFsCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
LatCommonDeviceIoControl (
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);


///////////////////////////////////////////////////////////////
//                                                           //
//  Prototypes for LatFastIo.c                               //
//                                                           //
///////////////////////////////////////////////////////////////

BOOLEAN
LatFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN        
LatFastIoWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoQueryStandardInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoDeviceControl (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

VOID
LatFastIoDetachDevice (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
);

BOOLEAN
LatFastIoQueryNetworkOpenInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoMdlRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoMdlReadComplete (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoPrepareMdlWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoMdlWriteComplete (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoReadCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoWriteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoMdlReadCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoMdlWriteCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoQueryOpen (
    IN PIRP Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN PDEVICE_OBJECT DeviceObject
);

///////////////////////////////////////////////////////////////
//                                                           //
//  Prototypes for LatLib.c                                  //
//                                                           //
///////////////////////////////////////////////////////////////

VOID
LatReadDriverParameters (
    IN PUNICODE_STRING RegistryPath
    );
    
NTSTATUS
LatAttachToFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
    );
    
VOID
LatDetachFromFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
LatEnumerateFileSystemVolumes (
    IN PDEVICE_OBJECT FSDeviceObject,
    IN PUNICODE_STRING Name
    );
    
BOOLEAN
LatIsAttachedToDevice (
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL
);

NTSTATUS
LatAttachToMountedDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT LatencyDeviceObject,
    IN PDEVICE_OBJECT DiskDeviceObject
);

VOID
LatGetObjectName (
    IN PVOID Object,
    IN OUT PUNICODE_STRING Name
);

VOID
LatGetBaseDeviceObjectName (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
);

VOID
LatCacheDeviceName (
    IN PDEVICE_OBJECT DeviceObject
);

NTSTATUS
LatGetDeviceObjectFromName (
    IN PUNICODE_STRING DeviceName,
    OUT PDEVICE_OBJECT *DeviceObject
);

NTSTATUS
LatEnable (
    IN PDEVICE_OBJECT DeviceObject,
    IN PWSTR UserDeviceName
);

NTSTATUS
LatDisable (
    IN PWSTR DeviceName
);

VOID
LatResetDeviceExtension (
    PLATENCY_DEVICE_EXTENSION DeviceExtension
);


/////////////////////////////////////////////////////////////////
//                                                             //
//  Arrays to track the number of operations and suboperations //
//  there are in the system.                                   //
//                                                             //
/////////////////////////////////////////////////////////////////

//
//  For each IRP_MJ code, there can be 0 or more IRP_MN codes.
//  For each IRP_MN code, there can be 0 or more FS|IO CTL codes.
//

typedef struct _COUNT_NODE {
    ULONG Count;
    struct _COUNT_NODE *ChildCount;
} COUNT_NODE, *PCOUNT_NODE;

COUNT_NODE ChildrenOfIrpMajorCodes [] = {
        { 0, NULL },    // IRP_MJ_CREATE                   0x00
        { 0, NULL },    // IRP_MJ_CREATE_NAMED_PIPE        0x01
        { 0, NULL },    // IRP_MJ_CLOSE                    0x02
        { 9, NULL },    // IRP_MJ_READ                     0x03
        { 9, NULL },    // IRP_MJ_WRITE                    0x04
        { 0, NULL },    // IRP_MJ_QUERY_INFORMATION        0x05
        { 0, NULL },    // IRP_MJ_SET_INFORMATION          0x06
        { 0, NULL },    // IRP_MJ_QUERY_EA                 0x07
        { 0, NULL },    // IRP_MJ_SET_EA                   0x08
        { 0, NULL },    // IRP_MJ_FLUSH_BUFFERS            0x09
        { 0, NULL },    // IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
        { 0, NULL },    // IRP_MJ_SET_VOLUME_INFORMATION   0x0b
        { 3, NULL },    // IRP_MJ_DIRECTORY_CONTROL        0x0c
        { 5,            // IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
            { 
            }
        { 2, NULL },    // IRP_MJ_DEVICE_CONTROL           0x0e
        { 0, NULL },    // IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
        { 0, NULL },    // IRP_MJ_SHUTDOWN                 0x10
        { 5, NULL },    // IRP_MJ_LOCK_CONTROL             0x11
        { 0, NULL },    // IRP_MJ_CLEANUP                  0x12
        { 0, NULL },    // IRP_MJ_CREATE_MAILSLOT          0x13
        { 0, NULL },    // IRP_MJ_QUERY_SECURITY           0x14
        { 0, NULL },    // IRP_MJ_SET_SECURITY             0x15
        { 4, NULL },    // IRP_MJ_POWER                    0x16
        { 12, NULL },   // IRP_MJ_SYSTEM_CONTROL           0x17
        { 0, NULL },    // IRP_MJ_DEVICE_CHANGE            0x18
        { 0, NULL },    // IRP_MJ_QUERY_QUOTA              0x19
        { 0, NULL },    // IRP_MJ_SET_QUOTA                0x1a
        { 24, NULL },   // IRP_MJ_PNP                      0x1b
        { 0, NULL },    // IRP_MJ_MAXIMUM_FUNCTION         0x1b
    
    };
    
#endif /* LATKERNEL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\latency\filter\latfastio.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    latFastIo.c

Abstract:

    This file contains all the Fast IO routines for the Latency Filter.
    
Author:

    Molly Brown (mollybro)  

Environment:

    Kernel mode

--*/

#include <latKernel.h>

#pragma alloc_text(PAGE, LatFastIoCheckIfPossible)
#pragma alloc_text(PAGE, LatFastIoRead)
#pragma alloc_text(PAGE, LatFastIoWrite)
#pragma alloc_text(PAGE, LatFastIoQueryBasicInfo)
#pragma alloc_text(PAGE, LatFastIoQueryStandardInfo)
#pragma alloc_text(PAGE, LatFastIoLock)
#pragma alloc_text(PAGE, LatFastIoUnlockSingle)
#pragma alloc_text(PAGE, LatFastIoUnlockAll)
#pragma alloc_text(PAGE, LatFastIoUnlockAllByKey)
#pragma alloc_text(PAGE, LatFastIoDeviceControl)
#pragma alloc_text(PAGE, LatFastIoDetachDevice)
#pragma alloc_text(PAGE, LatFastIoQueryNetworkOpenInfo)
#pragma alloc_text(PAGE, LatFastIoMdlRead)
#pragma alloc_text(PAGE, LatFastIoPrepareMdlWrite)
#pragma alloc_text(PAGE, LatFastIoMdlWriteComplete)
#pragma alloc_text(PAGE, LatFastIoReadCompressed)
#pragma alloc_text(PAGE, LatFastIoWriteCompressed)
#pragma alloc_text(PAGE, LatFastIoQueryOpen)

BOOLEAN
LatFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for checking to see
    whether fast I/O is possible for this file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be operated on.

    FileOffset - Byte offset in the file for the operation.

    Length - Length of the operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    CheckForReadOperation - Indicates whether the caller is checking for a
        read (TRUE) or a write operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.
    
--*/
{
    PDEVICE_OBJECT    deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN           returnValue = FALSE;
    
    PAGED_CODE();

    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        //
        //  We have a valid DeviceObject, so look at its FastIoDispatch
        //  table for the next driver's Fast IO routine.
        //

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoCheckIfPossible )) {

            returnValue = (fastIoDispatch->FastIoCheckIfPossible)( FileObject,
                                                                   FileOffset,
                                                                   Length,
                                                                   Wait,
                                                                   LockKey,
                                                                   CheckForReadOperation,
                                                                   IoStatus,
                                                                   deviceObject);
        }
    }

    return returnValue;
}

BOOLEAN
LatFastIoRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading from a
    file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be read.

    FileOffset - Byte offset in the file of the read.

    Length - Length of the read operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer to receive the data read.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoRead )) {

            returnValue = (fastIoDispatch->FastIoRead)( FileObject,
                                                        FileOffset,
                                                        Length,
                                                        Wait,
                                                        LockKey,
                                                        Buffer,
                                                        IoStatus,
                                                        deviceObject);
        }
    }

    return returnValue;
}

BOOLEAN
LatFastIoWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing to a
    file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be written.

    FileOffset - Byte offset in the file of the write operation.

    Length - Length of the write operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer that contains the data to be
        written.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoWrite )) {

            returnValue = (fastIoDispatch->FastIoWrite)( FileObject,
                                                         FileOffset,
                                                         Length,
                                                         Wait,
                                                         LockKey,
                                                         Buffer,
                                                         IoStatus,
                                                         deviceObject);
        }
    }

    return returnValue;
}
 
BOOLEAN
LatFastIoQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying basic
    information about the file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryBasicInfo )) {

            returnValue = (fastIoDispatch->FastIoQueryBasicInfo)( FileObject,
                                                                  Wait,
                                                                  Buffer,
                                                                  IoStatus,
                                                                  deviceObject);
        }
    }

    return returnValue;
}
 
BOOLEAN
LatFastIoQueryStandardInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying standard
    information about the file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;
    
    if (NULL != deviceObject) {
           
        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryStandardInfo )) {

            returnValue = (fastIoDispatch->FastIoQueryStandardInfo)( FileObject,
                                                                     Wait,
                                                                     Buffer,
                                                                     IoStatus,
                                                                     deviceObject );

        }
    }

    return returnValue;
}

BOOLEAN
LatFastIoLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    IN BOOLEAN FailImmediately,
    IN BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for locking a byte
    range within a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be locked.

    FileOffset - Starting byte offset from the base of the file to be locked.

    Length - Length of the byte range to be locked.

    ProcessId - ID of the process requesting the file lock.

    Key - Lock key to associate with the file lock.

    FailImmediately - Indicates whether or not the lock request is to fail
        if it cannot be immediately be granted.

    ExclusiveLock - Indicates whether the lock to be taken is exclusive (TRUE)
        or shared.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoLock )) {

            returnValue = (fastIoDispatch->FastIoLock)( FileObject,
                                                        FileOffset,
                                                        Length,
                                                        ProcessId,
                                                        Key,
                                                        FailImmediately,
                                                        ExclusiveLock,
                                                        IoStatus,
                                                        deviceObject);

        }
    }

    return returnValue;
}
 
BOOLEAN
LatFastIoUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking a byte
    range within a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    FileOffset - Starting byte offset from the base of the file to be
        unlocked.

    Length - Length of the byte range to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the file lock.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockSingle )) {

            returnValue = (fastIoDispatch->FastIoUnlockSingle)( FileObject,
                                                                FileOffset,
                                                                Length,
                                                                ProcessId,
                                                                Key,
                                                                IoStatus,
                                                                deviceObject);

        }
    }

    return returnValue;
}
 
BOOLEAN
LatFastIoUnlockAll (
    IN PFILE_OBJECT FileObject,
    IN PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockAll )) {

            returnValue = (fastIoDispatch->FastIoUnlockAll)( FileObject,
                                                             ProcessId,
                                                             IoStatus,
                                                             deviceObject);

        }
    }

    return returnValue;
}

BOOLEAN
LatFastIoUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    IN PVOID ProcessId,
    IN ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file based on a specified key.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the locks on the file to be released.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //
    
    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockAllByKey )) {

            returnValue = (fastIoDispatch->FastIoUnlockAllByKey)( FileObject,
                                                                  ProcessId,
                                                                  Key,
                                                                  IoStatus,
                                                                  deviceObject);
        }
    }

    return returnValue;
}

BOOLEAN
LatFastIoDeviceControl (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for device I/O 
    control operations on a file.
    
    If this I/O is directed to gControlDevice, then the parameters specify
    control commands to FileLat.  These commands are interpreted and handled
    appropriately.

    If this is I/O directed at another DriverObject, this function simply 
    invokes the next driver's corresponding routine, or returns FALSE if 
    the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object representing the device to be
        serviced.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    InputBuffer - Optional pointer to a buffer to be passed into the driver.

    InputBufferLength - Length of the optional InputBuffer, if one was
        specified.

    OutputBuffer - Optional pointer to a buffer to receive data from the
        driver.

    OutputBufferLength - Length of the optional OutputBuffer, if one was
        specified.

    IoControlCode - I/O control code indicating the operation to be performed
        on the device.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

Notes:

    This function does not check the validity of the input/output buffers because
    the ioctl's are implemented as METHOD_BUFFERED.  In this case, the I/O manager
    does the buffer validation checks for us.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //

    if (DeviceObject == Globals.ControlDeviceObject) {

        LatCommonDeviceIoControl( InputBuffer,
                                  InputBufferLength,
                                  OutputBuffer,
                                  OutputBufferLength,
                                  IoControlCode,
                                  IoStatus,
                                  DeviceObject );

        returnValue = TRUE;

    } else {

        ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );

        deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

        if (NULL != deviceObject) {

            fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

            if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoDeviceControl )) {

                returnValue = (fastIoDispatch->FastIoDeviceControl)( FileObject,
                                                                     Wait,
                                                                     InputBuffer,
                                                                     InputBufferLength,
                                                                     OutputBuffer,
                                                                     OutputBufferLength,
                                                                     IoControlCode,
                                                                     IoStatus,
                                                                     deviceObject);

            } else {

                IoStatus->Status = STATUS_SUCCESS;
            }
        }
    }

    return returnValue;
}


VOID
LatFastIoDetachDevice (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
)
/*++

Routine Description:

    This routine is invoked on the fast path to detach from a device that
    is being deleted.  This occurs when this driver has attached to a file
    system volume device object, and then, for some reason, the file system
    decides to delete that device (it is being dismounted, it was dismounted
    at some point in the past and its last reference has just gone away, etc.)

Arguments:

    SourceDevice - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

    TargetDevice - Pointer to the file system's volume device object.

Return Value:

    None.
    
--*/
{
    PLATENCY_DEVICE_EXTENSION devext;

    PAGED_CODE();

    ASSERT( IS_MY_DEVICE_OBJECT( SourceDevice ) );

    devext = SourceDevice->DeviceExtension;

    LAT_DBG_PRINT2( DEBUG_DISPLAY_ATTACHMENT_NAMES,
                    "LATENCY (LatFastIoDetachDevice): Detaching from volume      \"%.*S\"\n",
                    devext->DeviceNames.Length / sizeof( WCHAR ),
                    devext->DeviceNames.Buffer );

    //
    //  Remove this device extension from the list of devices we are attached
    //  to if this is a volume device object.
    //
    
    if (devext->IsVolumeDeviceObject) {

        ExAcquireFastMutex( &Globals.DeviceExtensionListLock );
        RemoveEntryList( devext->NextLatencyDeviceLink );
        ExReleaseFastMutex( &Globals.DeviceExtensionListLock );
    }

    //
    // Detach from the file system's volume device object.
    //

    IoDetachDevice( TargetDevice );
    IoDeleteDevice( SourceDevice );
}
 
BOOLEAN
LatFastIoQueryNetworkOpenInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying network
    information about a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller can handle the file system
        having to wait and tie up the current thread.

    Buffer - Pointer to a buffer to receive the network information about the
        file.

    IoStatus - Pointer to a variable to receive the final status of the query
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryNetworkOpenInfo )) {

            returnValue = (fastIoDispatch->FastIoQueryNetworkOpenInfo)( FileObject,
                                                                        Wait,
                                                                        Buffer,
                                                                        IoStatus,
                                                                        deviceObject);

        }
    }

    return returnValue;
}

BOOLEAN
LatFastIoMdlRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading a file
    using MDLs as buffers.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object that is to be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlRead )) {

            returnValue = (fastIoDispatch->MdlRead)( FileObject,
                                                     FileOffset,
                                                     Length,
                                                     LockKey,
                                                     MdlChain,
                                                     IoStatus,
                                                     deviceObject);
        }
    }

    return returnValue;
}
 
BOOLEAN
LatFastIoMdlReadComplete (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read operation.

    This function simply invokes the next driver's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the MdlRead function is supported by the underlying driver, and
    therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL read upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.
    
--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;
 
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlReadComplete )) {

            returnValue = (fastIoDispatch->MdlReadComplete)( FileObject,
                                                             MdlChain,
                                                             deviceObject);
        } 
    }

    return returnValue;
}
 
BOOLEAN
LatFastIoPrepareMdlWrite (
    IN  PFILE_OBJECT FileObject,
    IN  PLARGE_INTEGER FileOffset,
    IN  ULONG Length,
    IN  ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN  PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for preparing for an
    MDL write operation.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write 
        operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

// ISSUE-2000-04-26-mollybro Check if this will get an IRP if FALSE is returned 

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, PrepareMdlWrite )) {

            returnValue = (fastIoDispatch->PrepareMdlWrite)( FileObject,
                                                             FileOffset,
                                                             Length,
                                                             LockKey,
                                                             MdlChain,
                                                             IoStatus,
                                                             deviceObject);
        }
    }

    return returnValue;
}
 
BOOLEAN
LatFastIoMdlWriteComplete (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL write operation.

    This function simply invokes the next driver's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the PrepareMdlWrite function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not
    assumed by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL write upon.

    FileOffset - Supplies the file offset at which the write took place.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlWriteComplete )) {

            returnValue = (fastIoDispatch->MdlWriteComplete)( FileObject,
                                                              FileOffset,
                                                              MdlChain,
                                                              deviceObject);

        }
    }

    return returnValue;
}
 
BOOLEAN
LatFastIoReadCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading 
    compressed data from a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to a buffer to receive the compressed data read.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    CompressedDataInfo - A buffer to receive the description of the 
        compressed data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoReadCompressed )) {

            returnValue = (fastIoDispatch->FastIoReadCompressed)( FileObject,
                                                                  FileOffset,
                                                                  Length,
                                                                  LockKey,
                                                                  Buffer,
                                                                  MdlChain,
                                                                  IoStatus,
                                                                  CompressedDataInfo,
                                                                  CompressedDataInfoLength,
                                                                  deviceObject);
        }
    }

    return returnValue;
}
 
BOOLEAN
LatFastIoWriteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing 
    compressed data to a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write 
        operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to the buffer containing the data to be written.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    CompressedDataInfo - A buffer to containing the description of the
        compressed data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoWriteCompressed )) {

            returnValue = (fastIoDispatch->FastIoWriteCompressed)( FileObject,
                                                                   FileOffset,
                                                                   Length,
                                                                   LockKey,
                                                                   Buffer,
                                                                   MdlChain,
                                                                   IoStatus,
                                                                   CompressedDataInfo,
                                                                   CompressedDataInfoLength,
                                                                   deviceObject);
        }
    }

    return returnValue;
}
 
BOOLEAN
LatFastIoMdlReadCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read compressed operation.

    This function simply invokes the next driver's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the read compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not 
    assumed by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed read
        upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.
    
--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlReadCompleteCompressed )) {

            returnValue = (fastIoDispatch->MdlReadCompleteCompressed)( FileObject,
                                                                       MdlChain,
                                                                       deviceObject);

        }
    }

    return returnValue;
}
 
BOOLEAN
LatFastIoMdlWriteCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing a
    write compressed operation.

    This function simply invokes the next driver's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the write compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not 
    assumed by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed write
        upon.

    FileOffset - Supplies the file offset at which the file write operation
        began.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //
    
    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlWriteCompleteCompressed )) {

            returnValue = (fastIoDispatch->MdlWriteCompleteCompressed)( FileObject,
                                                                        FileOffset, 
                                                                        MdlChain,
                                                                        deviceObject);

        }
    }

    return returnValue;
}
 
BOOLEAN
LatFastIoQueryOpen (
    IN PIRP Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for opening a file
    and returning network information it.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    Irp - Pointer to a create IRP that represents this open operation.  It is
        to be used by the file system for common open/create code, but not
        actually completed.

    NetworkInformation - A buffer to receive the information required by the
        network about the file being opened.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN result = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryOpen )) {

            PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );

            irpSp->DeviceObject = deviceObject;

            result = (fastIoDispatch->FastIoQueryOpen)( Irp,
                                                        NetworkInformation,
                                                        deviceObject );
            if (!result) {

                irpSp->DeviceObject = DeviceObject;
            }
        }
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\cli\cliparse.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    cliparse.cpp

Abstract:

    Implements CLI parsing engine

Author:

    Ravisankar Pudipeddi   [ravisp]  3-March-2000

Revision History:

--*/

//
// Throughout this parse module, we return E_NOINTERFACE
// to indicate invalid command line syntax/parameters.
// This is to explicitly distinguish from E_INVALIDARG that may
// be returned by the CLI dll: we wish to distinguish a syntax error
// detected by the parser from a syntax error detected  by the CLI dll
// because in the latter case we do not print the usage for the interface.
// Whereas for errors detected by the parser, we *do* print the usage.
// This rule needs to be strictly adhered to
//

#include "stdafx.h"
#include "stdlib.h"
#include "cliparse.h"
#include "string.h"
#include "locale.h"
#include "winnlsp.h"

#pragma warning( disable : 4100 )

CComModule  _Module;
CComPtr<IWsbTrace> g_pTrace;  

#define MAX_ARGS        40
#define MAX_SWITCHES    20
// 
// List of all CLI keywords
// TBD: Sort them!
//
RSS_KEYWORD RssInterfaceStrings[] =  {
    {L"ADMIN",          L"AD",     ADMIN_IF},
    {L"VOLUME",         L"VL",     VOLUME_IF},
    {L"MEDIA",          L"MD",     MEDIA_IF},
    {L"FILE",           L"FL",     FILE_IF},
    {L"SHOW",           L"SH",     SHOW_IF},
    {L"SET",            L"ST",     SET_IF},
    {L"MANAGE",         L"MG",     MANAGE_IF},
    {L"UNMANAGE",       L"UM",     UNMANAGE_IF},
    {L"DELETE",         L"DL",     DELETE_IF},
    {L"JOB",            L"JB",     JOB_IF},
    {L"RECALL",         L"RC",     RECALL_IF},
    {L"SYNCHRONIZE",    L"SN",     SYNCHRONIZE_IF},
    {L"RECREATEMASTER", L"RM",     RECREATEMASTER_IF},
    {L"HELP",           L"/?",     HELP_IF},
//
// Duplicate entry for HELP to recognize -? also as a help
// interface
//
    {L"HELP",           L"-?",     HELP_IF},
    {NULL,              NULL,      UNKNOWN_IF}
};

//
// Rss option strings - listed here without the preceding
// '/' or '-' (or whatever that distinguishes a switch from
// an argument)
// TBD: Sort them!
//

RSS_SWITCH_DEFINITION RssSwitchStrings[] = {
    {L"RECALLLIMIT",    L"LM",        RECALLLIMIT_SW, RSS_ARG_DWORD},
    {L"MEDIACOPIES",    L"MC",        MEDIACOPIES_SW, RSS_ARG_DWORD},
    {L"SCHEDULE",       L"SC",        SCHEDULE_SW,    RSS_ARG_STRING},
    {L"CONCURRENCY",    L"CN",        CONCURRENCY_SW, RSS_ARG_DWORD},
    {L"ADMINEXEMPT",    L"AE",        ADMINEXEMPT_SW, RSS_ARG_DWORD},
    {L"GENERAL",        L"GN",        GENERAL_SW,     RSS_NO_ARG},
    {L"MANAGEABLES",    L"MS",        MANAGEABLES_SW, RSS_NO_ARG},
    {L"MANAGED",        L"MN",        MANAGED_SW,     RSS_NO_ARG},
    {L"MEDIA",          L"MD",        MEDIA_SW,       RSS_NO_ARG},
    {L"DFS",            L"DF",        DFS_SW,         RSS_ARG_DWORD},
    {L"SIZE",           L"SZ",        SIZE_SW,        RSS_ARG_DWORD},
    {L"ACCESS",         L"AC",        ACCESS_SW,      RSS_ARG_DWORD},
    {L"INCLUDE",        L"IN",        INCLUDE_SW,     RSS_ARG_STRING},
    {L"EXCLUDE",        L"EX",        EXCLUDE_SW,     RSS_ARG_STRING},
    {L"RECURSIVE",      L"RC",        RECURSIVE_SW,   RSS_NO_ARG},
    {L"QUICK",          L"QK",        QUICK_SW,       RSS_NO_ARG},
    {L"FULL",           L"FL",        FULL_SW,        RSS_NO_ARG},
    {L"RULE",           L"RL",        RULE_SW,        RSS_ARG_STRING},
    {L"STATISTICS",     L"ST",        STATISTICS_SW,  RSS_NO_ARG},
    {L"TYPE",           L"TY",        TYPE_SW,        RSS_ARG_STRING},
    {L"RUN",            L"RN",        RUN_SW,         RSS_NO_ARG},
    {L"CANCEL",         L"CX",        CANCEL_SW,      RSS_NO_ARG},
    {L"WAIT",           L"WT",        WAIT_SW,        RSS_NO_ARG},
    {L"COPYSET",        L"CS",        COPYSET_SW,     RSS_ARG_DWORD},
    {L"NAME",           L"NM",        NAME_SW,        RSS_ARG_STRING},
    {L"STATUS",         L"SS",        STATUS_SW,      RSS_NO_ARG},
    {L"CAPACITY",       L"CP",        CAPACITY_SW,    RSS_NO_ARG},
    {L"FREESPACE",      L"FS",        FREESPACE_SW,   RSS_NO_ARG},
    {L"VERSION",        L"VR",        VERSION_SW,     RSS_NO_ARG},
    {L"COPIES",         L"CP",        COPIES_SW,      RSS_NO_ARG},
    {L"HELP",           L"?",         HELP_SW,        RSS_NO_ARG},
    {NULL,              NULL,         UNKNOWN_SW, RSS_NO_ARG}
}; 

RSS_JOB_DEFINITION  RssJobTypeStrings[] = {
    {L"CREATEFREESPACE", L"F", CreateFreeSpace},
    {L"COPYFILES",       L"C", CopyFiles},
    {L"VALIDATE",        L"V", Validate},
    {NULL,               NULL,  InvalidJobType}
};

//
// Global  arrays of arguments and switches
// These will be used as 'known' entities by all
// the interface implementations instead of passing
// them around as parameters
//
LPWSTR       Args[MAX_ARGS];
RSS_SWITCHES Switches[MAX_SWITCHES];
DWORD        NumberOfArguments = 0;
DWORD        NumberOfSwitches = 0;

//
// Useful macros
//

#define CLIP_ARGS_REQUIRED()            {           \
        if (NumberOfArguments <= 0) {               \
            WsbThrow(E_NOINTERFACE);                 \
        }                                           \
}

#define CLIP_ARGS_NOT_REQUIRED()            {       \
        if (NumberOfArguments > 0) {                \
            WsbThrow(E_NOINTERFACE);                 \
        }                                           \
}

#define CLIP_SWITCHES_REQUIRED()            {       \
        if (NumberOfSwitches <= 0) {                \
            WsbThrow(E_NOINTERFACE);                 \
        }                                           \
}

#define CLIP_SWITCHES_NOT_REQUIRED()            {   \
        if (NumberOfSwitches > 0) {                 \
            WsbThrow(E_NOINTERFACE);                 \
        }                                           \
}

#define CLIP_TRANSLATE_HR_AND_RETURN(__HR)     {   \
    if (__HR == S_OK) {                            \
        return CLIP_ERROR_SUCCESS;                 \
    } else if ((__HR == E_NOINTERFACE) ||          \
               (__HR == E_INVALIDARG)) {           \
        return CLIP_ERROR_INVALID_PARAMETER;       \
    } else if (__HR == E_OUTOFMEMORY) {            \
        return CLIP_ERROR_INSUFFICIENT_MEMORY;     \
    } else  {                                      \
        return CLIP_ERROR_UNKNOWN;                 \
    }                                              \
} 

#define CLIP_GET_DWORD_ARG(__VAL, __STRING, __STOPSTRING) {      \
        __VAL = wcstol(__STRING, &(__STOPSTRING), 10);           \
        if (*(__STOPSTRING) != L'\0') {                          \
            WsbThrow(E_NOINTERFACE);                              \
        }                                                        \
}

#define CLIP_VALIDATE_DUPLICATE_DWORD_ARG(__ARG)         {       \
        if ((__ARG) !=  INVALID_DWORD_ARG)               {       \
            WsbThrow(E_NOINTERFACE);                              \
        }                                                        \
}

#define CLIP_VALIDATE_DUPLICATE_POINTER_ARG(__ARG)       {       \
        if ((__ARG) !=  INVALID_POINTER_ARG)               {     \
            WsbThrow(E_NOINTERFACE);                              \
        }                                                        \
}

//
// Local function prototypes
//

RSS_INTERFACE
ClipGetInterface(
                IN LPWSTR InterfaceString
                );

DWORD
ClipGetSwitchTypeIndex(
                      IN LPWSTR SwitchString
                      );

HSM_JOB_TYPE
ClipGetJobType(
              IN LPWSTR JobTypeString
              );

HRESULT          
ClipCompileSwitchesAndArgs(
                          IN LPWSTR CommandLine, 
                          IN RSS_INTERFACE Interface,
                          IN RSS_INTERFACE SubInterface
                          );

VOID
ClipCleanup(
           VOID
           );

HRESULT
ClipAdminShow(
             VOID
             );

HRESULT 
ClipAdminSet(
            VOID
            );

HRESULT 
ClipVolumeShow(
              VOID
              );

HRESULT
ClipVolumeUnmanage(
                  VOID
                  );

HRESULT
ClipVolumeSetManage(
                   IN BOOL Set
                   );

HRESULT 
ClipVolumeDelete(
                VOID
                );

HRESULT
ClipVolumeJob(
             VOID
             );

HRESULT 
ClipMediaShow(
             VOID
             );

HRESULT 
ClipMediaSynchronize(
                    VOID
                    );

HRESULT 
ClipMediaRecreateMaster(
                       VOID
                       );

HRESULT 
ClipMediaDelete(
               VOID
               );

HRESULT 
ClipFileRecall(
              VOID
              );

VOID
ClipHelp(
        IN RSS_INTERFACE Interface,
        IN RSS_INTERFACE SubInterface
        );

HRESULT
ClipParseTime(
             IN  LPWSTR        TimeString,
             OUT PSYSTEMTIME   ScheduledTime
             );

HRESULT
ClipParseSchedule(
                 IN  LPWSTR ScheduleString,
                 OUT PHSM_JOB_SCHEDULE Schedule
                 );
BOOL
ClipInitializeTrace(
                   VOID
                   );

VOID
ClipUninitializeTrace(
                     VOID
                     );


VOID
ClipHandleErrors(
                IN HRESULT RetCode,
                IN RSS_INTERFACE Interface,
                IN RSS_INTERFACE SubInterface
                );
//
// Function bodies start here
//

RSS_INTERFACE
ClipGetInterface(
                IN LPWSTR InterfaceString
                ) 
/*++
Routine Description:

    Maps the interface string that is supplied to an enum

Arguments
    
    InterfaceString - Pointer to the interface string
    TBD: implement a binary search

Return Value

    UNKNOWN_IF - if the interface string is not recognized
    An RSS_INTERFACE value if it is.

--*/
{
    DWORD i;
    RSS_INTERFACE ret = UNKNOWN_IF;

    WsbTraceIn(OLESTR("ClipHandleErrors"), OLESTR(""));

    for (i=0 ; TRUE ; i++) {
        if (RssInterfaceStrings[i].Long == NULL) {
            //
            // Reached end of table.
            // 
            break;

        } else if ((_wcsicmp(RssInterfaceStrings[i].Short, 
                             InterfaceString) == 0) ||
                   (_wcsicmp(RssInterfaceStrings[i].Long, 
                             InterfaceString) == 0)) {
            ret = RssInterfaceStrings[i].Interface;
            break;

        }
    }

    WsbTraceOut(OLESTR("ClipGetInterface"), OLESTR("Interface = <%ls>"), WsbLongAsString((LONG) ret));
    return ret;
}


DWORD
ClipGetSwitchTypeIndex(
                      IN LPWSTR SwitchString
                      )
/*++
Routine Description

    Maps the Switch to an entry in the global list of switches
    and returns the index

Arguments

    SwitchString  -  Pointer to switch string
    TBD: implement a binary search

Return Value

    -1  - If the switch is not recognized
    A positive value (index to the entry) if it is
--*/
{
    DWORD i;

    WsbTraceIn(OLESTR("ClipGetSwitchTypeIndex"), OLESTR(""));

    for (i = 0; TRUE; i++) {
        if (RssSwitchStrings[i].Long == NULL) {
            //
            // Reached end of table.
            // 
            i = -1;
            break;
        } else if ((_wcsicmp(RssSwitchStrings[i].Short,
                             SwitchString) == 0) ||
                   (_wcsicmp(RssSwitchStrings[i].Long,
                             SwitchString) == 0)) {

            break;
        }
    }

    WsbTraceOut(OLESTR("ClipGetSwitchTypeIndex"), OLESTR("index = <%ls>"), WsbLongAsString((LONG) i));
    return i;
}


HSM_JOB_TYPE
ClipGetJobType(
              IN LPWSTR JobTypeString
              )
/*++
Routine Description

    Maps the job string to an enum

Arguments

    JobTypeString  -  Pointer to JobType string
    TBD: implement a binary search

Return Value

    InvalidJobType  - If the job type is not recognized
    HSM_JOB_TYPE value if it is
--*/
{
    DWORD i;
    HSM_JOB_TYPE jobType = InvalidJobType;

    WsbTraceIn(OLESTR("ClipGetJobType"), OLESTR(""));

    for (i = 0; TRUE; i++) {
        if (RssJobTypeStrings[i].Long == NULL) {
            //
            // Reached end of table.
            // 
            break;
        }
        if ((_wcsicmp(RssJobTypeStrings[i].Short,
                      JobTypeString) == 0) ||
            (_wcsicmp(RssJobTypeStrings[i].Long,
                      JobTypeString) == 0)) {
            jobType = RssJobTypeStrings[i].JobType;
            break;
        }
    }

    WsbTraceOut(OLESTR("ClipGetJobType"), OLESTR("JobType = <%ls>"), WsbLongAsString((LONG) jobType));

    return jobType;
}   


HRESULT
ClipCompileSwitchesAndArgs(
                          IN LPWSTR CommandLine, 
                          IN RSS_INTERFACE Interface,
                          IN RSS_INTERFACE SubInterface
                          )
/*++

Routine Description

    Parses the passed in string and compiles all switches
    (a switch is identified by an appropriate delimiter preceding
    it, such as a '/') into a global switches array (along with
    the arguments to the switch) and the rest of the parameters
    into an Args array

Arguments

    CommandLine - String to be parsed

Return Value

    S_OK if success
--*/
{
    HRESULT hr = S_OK;
    WCHAR token[MAX_PATH+1];
    LPWSTR p = CommandLine, pToken = token, switchArg = NULL, switchString = NULL;
    int cToken = 0;
    RSS_SWITCH_TYPE switchType;
    DWORD index;
    BOOL  isSwitch, skipSpace;

    WsbTraceIn(OLESTR("ClipCompileSwitchesAndArgs"), OLESTR(""));

    try {
        if (p == NULL) {
            WsbThrow(S_OK);
        }

        while (*p != L'\0') {

            if (wcschr(SEPARATORS, *p) != NULL) {
                //
                // Skip white space
                //
                p++;
                continue;
            }
            if (wcschr(SWITCH_DELIMITERS, *p) != NULL) {
                isSwitch = TRUE;
                p++;
                if (*p == L'\0') {
                    //
                    // Badly formed - a SWITCH_DELIMITER with no switch
                    // 
                    WsbThrow(E_NOINTERFACE);
                }
            } else {
                isSwitch = FALSE;
            }
            //
            // Get the rest of the word
            //
            skipSpace = FALSE;
            while (*p != L'\0' && *p != L'\n') {
                //
                // We wish to consider stuff enclosed entirely in 
                // quotes as a single token. As a result
                // we won't consider white space to be a delimiter
                // for tokens when they are in quotes.
                //
                if (*p == QUOTE) {
                    if (skipSpace) {
                        //
                        // A quote was encountered previously.
                        // This signifies - hence -  the end of the token
                        //
                        p++;
                        break;
                    } else {
                        //
                        // Start of quoted string..don't treat whitespace
                        // as a delimiter anymore, only a quote will end the token 
                        //
                        skipSpace = TRUE;
                        p++;
                        continue;
                    }
                }

                if (!skipSpace && (wcschr(SEPARATORS, *p) != NULL)) {
                    //
                    // This is not quoted and white space was encountered..
                    //
                    break;
                }
                cToken++;
                if (cToken > MAX_PATH) {
                    // Token is too large
                    WsbThrow(E_NOINTERFACE);
                }
                *pToken++ = *p++;
            }

            *pToken = L'\0';

            if (isSwitch) {
                //
                // For a switch, we will have to further split it into
                // the switch part and the argument part
                // 
                switchString = wcstok(token, SWITCH_ARG_DELIMITERS);

                index = ClipGetSwitchTypeIndex(switchString);
                if (index == -1) {
                    //
                    // Invalid switch. Get out.
                    //
                    WsbThrow(E_NOINTERFACE);
                }
                switchType = RssSwitchStrings[index].SwitchType;

                switchArg = wcstok(NULL, L"");
                //
                // Validation -  badly formed commandline if either:
                // 1. An argument was supplied and the switch definition indicated
                // no argument was required
                //     OR
                // 2. This is a non-SHOW interface (by default show interface 
                // don't require arguments for options), and an argument was not 
                // supplied even though the switch definition indicated one is
                // required.
                //  
                // 3. This is a SHOW interface and an argument was supplied
                //
                if ( ((switchArg != NULL) &&
                      (RssSwitchStrings[index].ArgRequired == RSS_NO_ARG)) ||

                     ((SubInterface != SHOW_IF) && (switchArg == NULL) &&
                      (RssSwitchStrings[index].ArgRequired != RSS_NO_ARG)) ||
                     ((SubInterface == SHOW_IF) && (switchArg != NULL))) {
                    WsbThrow(E_NOINTERFACE);
                }

                Switches[NumberOfSwitches].SwitchType = switchType;        

                if (switchArg != NULL) {
                    Switches[NumberOfSwitches].Arg = new WCHAR [wcslen(switchArg)+1];

                    if (Switches[NumberOfSwitches].Arg == NULL) {
                        WsbThrow(E_OUTOFMEMORY);
                    }

                    wcscpy(Switches[NumberOfSwitches].Arg, switchArg);

                } else {
                    //
                    // No arg for this switch
                    //
                    Switches[NumberOfSwitches].Arg = NULL;
                }

                NumberOfSwitches++;
            } else {
                //
                // This is an argument..
                //
                Args[NumberOfArguments] = new WCHAR [wcslen(token)+1];

                if (Args[NumberOfArguments] == NULL) {
                    WsbThrow(E_OUTOFMEMORY);
                }

                wcscpy(Args[NumberOfArguments], 
                       token); 
                NumberOfArguments++;
            }
            pToken = token;
            cToken = 0;
        }
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("ClipCompileSwitchesAndArgs"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


VOID
ClipCleanup(VOID)
/*++

Routine Description

    Performs global cleanup for CLI parse module.
    Mainly - frees up all allocated arguments and switches

Arguments

    None

Return Value

    None
--*/
{
    DWORD i;

    WsbTraceIn(OLESTR("ClipCleanup"), OLESTR(""));

    for (i = 0; i < NumberOfArguments; i++) {
        delete [] Args[i];
    }
    for (i = 0; i < NumberOfSwitches; i++) {
        if (Switches[i].Arg != NULL) {
            delete [] Switches[i].Arg;
        }
    }

    WsbTraceOut(OLESTR("ClipCleanup"), OLESTR(""));
}


HRESULT
ClipAdminShow(VOID)
/*++

Routine Description

    Implements RSS ADMIN SHOW interface.
    Arguments are in global arrays:
        Args      - containing list of arguments
        Switches  - containing list of switches

Arguments
    
    None

Return Value

    S_OK              if everything's ok
    E_NOINTERFACE       if args/switches are bad
--*/
{
    DWORD i;
    HRESULT hr;
    BOOL recallLimit = FALSE; 
    BOOL adminExempt = FALSE;
    BOOL mediaCopies = FALSE;
    BOOL concurrency = FALSE;
    BOOL schedule = FALSE;
    BOOL general = FALSE;
    BOOL manageables = FALSE;
    BOOL managed = FALSE;
    BOOL media = FALSE;


    WsbTraceIn(OLESTR("ClipAdminShow"), OLESTR(""));
    try {
        //
        // No arguments needed for this interface
        //
        CLIP_ARGS_NOT_REQUIRED();

        if (NumberOfSwitches) {
            for (i = 0; i < NumberOfSwitches; i++) {
                switch (Switches[i].SwitchType) {
                case RECALLLIMIT_SW: {
                        recallLimit = TRUE;
                        break;
                    }
                case ADMINEXEMPT_SW: {
                        adminExempt = TRUE;
                        break;
                    }
                case MEDIACOPIES_SW: {
                        mediaCopies = TRUE;
                        break;
                    }
                case CONCURRENCY_SW: {
                        concurrency = TRUE;
                        break;
                    }
                case SCHEDULE_SW: {
                        schedule = TRUE;
                        break;
                    }
                case GENERAL_SW: {
                        general = TRUE;
                        break;
                    }
                case MANAGEABLES_SW: {
                        manageables = TRUE;   
                        break;
                    } 
                case MANAGED_SW: {
                        managed = TRUE;
                        break;
                    }
                case MEDIA_SW: {
                        media = TRUE;
                        break;
                    }
                default: {
                        // Unknown switch - get out
                        WsbThrow(E_NOINTERFACE);
                    }
                }
            }
            hr = AdminShow(recallLimit,
                           adminExempt,
                           mediaCopies,
                           concurrency,
                           schedule,
                           general,
                           manageables,
                           managed,
                           media);

        } else {
            hr = AdminShow(TRUE,
                           TRUE,
                           TRUE,
                           TRUE,
                           TRUE,
                           TRUE,
                           TRUE,
                           TRUE,
                           TRUE);
        }
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("ClipAdminShow"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return hr;
}


HRESULT 
ClipAdminSet(VOID)
/*++
Routine Description

    Implements RSS ADMIN SET interface.
    Arguments are in global arrays:
        Args      - containing list of arguments
        Switches  - containing list of switches

Arguments
    
    None

Return Value

    S_OK             if everything's ok
    E_NOINTERFACE     if arguments are invalid

--*/
{  
    DWORD             i;
    HRESULT           hr; 
    LPWSTR            stopString = NULL;
    DWORD             recallLimit = INVALID_DWORD_ARG;
    DWORD             adminExempt = INVALID_DWORD_ARG;
    DWORD             mediaCopies = INVALID_DWORD_ARG;
    DWORD             concurrency = INVALID_DWORD_ARG;
    PHSM_JOB_SCHEDULE schedule    = INVALID_POINTER_ARG;
    HSM_JOB_SCHEDULE  schedAllocated;

    WsbTraceIn(OLESTR("ClipAdminSet"), OLESTR(""));
    try {
        //
        // No arguments needed for this interface
        //
        CLIP_ARGS_NOT_REQUIRED();

        if (NumberOfSwitches) {
            for (i = 0; i < NumberOfSwitches; i++) {
                switch (Switches[i].SwitchType) {
                case RECALLLIMIT_SW: {
                        CLIP_VALIDATE_DUPLICATE_DWORD_ARG(recallLimit);
                        CLIP_GET_DWORD_ARG(recallLimit,
                                           Switches[i].Arg,
                                           stopString);
                        break;
                    }

                case ADMINEXEMPT_SW: {
                        CLIP_VALIDATE_DUPLICATE_DWORD_ARG(adminExempt);
                        CLIP_GET_DWORD_ARG(adminExempt,
                                           Switches[i].Arg,
                                           stopString);
                        break;
                    }

                case MEDIACOPIES_SW: {
                        CLIP_VALIDATE_DUPLICATE_DWORD_ARG(mediaCopies);
                        CLIP_GET_DWORD_ARG(mediaCopies,
                                           Switches[i].Arg,
                                           stopString);
                        break;
                    }

                case CONCURRENCY_SW: {
                        CLIP_VALIDATE_DUPLICATE_DWORD_ARG(concurrency);
                        CLIP_GET_DWORD_ARG(concurrency,
                                           Switches[i].Arg,
                                           stopString);
                        break;
                    }

                case SCHEDULE_SW: {
                        CLIP_VALIDATE_DUPLICATE_POINTER_ARG(schedule);
                        hr = ClipParseSchedule(Switches[i].Arg,
                                               &schedAllocated);
                        if (!SUCCEEDED(hr)) {
                            WsbThrow(E_NOINTERFACE);
                        } else {
                            //
                            // schedAllocated has the schedule
                            //
                            schedule = &schedAllocated;
                        }
                        break;
                    }

                default: {
                        // Unknown switch - get out
                        WsbThrow(E_NOINTERFACE);
                    }
                }
            }
        }
        hr = AdminSet(recallLimit,
                      adminExempt,
                      mediaCopies,
                      concurrency,
                      schedule);
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("ClipAdminSet"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return hr;
}



HRESULT 
ClipVolumeShow(VOID)
/*++

Routine Description

    Implements RSS VOLUME SHOW interface.
    Arguments are in global arrays:
        Args      - containing list of arguments
        Switches  - containing list of switches

Arguments
    
    None

Return Value

    S_OK             if everything's ok
    E_NOINTERFACE     if arguments are invalid

--*/
{
    DWORD i;
    HRESULT hr;
    LPWSTR stopString = NULL;
    BOOL   dfs = FALSE;
    BOOL   size = FALSE;
    BOOL   access = FALSE;
    BOOL   rules = FALSE;
    BOOL   statistics = FALSE;

    WsbTraceIn(OLESTR("ClipVolumeShow"), OLESTR(""));
    try {
        //
        // Atleast one arg. required for this interface
        //
        CLIP_ARGS_REQUIRED();

        if (NumberOfSwitches == 0) {
            dfs = size = access = rules = statistics = TRUE;
        } else {
            for (i = 0; i < NumberOfSwitches; i++) {
                switch (Switches[i].SwitchType) {
                case DFS_SW: {
                        dfs = TRUE;
                        break;
                    }
                case SIZE_SW: {
                        size = TRUE;
                        break;
                    }
                case ACCESS_SW: {
                        access = TRUE;
                        break;
                    }
                case RULE_SW: {
                        rules = TRUE;
                        break;
                    }
                case STATISTICS_SW: {
                        statistics = TRUE;
                        break;
                    }
                default: {
                        //
                        // Invalid option   
                        //
                        WsbThrow(E_NOINTERFACE);
                    }
                }
            }
        }
        hr = VolumeShow(Args,
                        NumberOfArguments,
                        dfs,
                        size,
                        access,
                        rules,
                        statistics);
    }WsbCatch(hr);


    WsbTraceOut(OLESTR("ClipVolumeShow"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return hr;                   
}


HRESULT
ClipVolumeUnmanage(VOID)
/*++
Routine Description

    Implements RSS VOLUME UNMANAGE interface.
    Arguments are in global arrays:
        Args      - containing list of arguments
        Switches  - containing list of switches

Arguments
    
    None

Return Value

    S_OK             if everything's ok
    E_NOINTERFACE     if arguments are invalid

--*/
{
    DWORD i = 0;
    HRESULT hr;


#define QUICK_UNMANAGE 0
#define FULL_UNMANAGE 1

    DWORD  fullOrQuick = INVALID_DWORD_ARG;

    WsbTraceIn(OLESTR("ClipVolumeUnmanage"), OLESTR(""));

    try {
        //
        // Atleast one arg. required for this interface
        //
        CLIP_ARGS_REQUIRED();

        if (NumberOfSwitches) {
            for (i = 0; i < NumberOfSwitches; i++) {
                switch (Switches[i].SwitchType) {
                case FULL_SW: {
                        CLIP_VALIDATE_DUPLICATE_DWORD_ARG(fullOrQuick);
                        fullOrQuick = FULL_UNMANAGE;
                        break;
                    }
                case QUICK_SW: {
                        CLIP_VALIDATE_DUPLICATE_DWORD_ARG(fullOrQuick);
                        fullOrQuick = QUICK_UNMANAGE;
                        break;
                    }
                default: {
                        //
                        // Invalid option
                        //
                        WsbThrow(E_NOINTERFACE);
                    }
                }
            }
        }
//
//  The default for UNMANAGE is quick. So if fullOrQuick is either 
//  QUICK_UNMANAGE  or INVALID_DWORD_ARG, we call unmanage of the quick 
//  variety
//
        hr = VolumeUnmanage(Args,
                            NumberOfArguments,
                            (fullOrQuick == FULL_UNMANAGE)? TRUE : FALSE);
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("ClipVolumeUnmanage"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;

}


HRESULT
ClipVolumeSetManage(IN BOOL Set)    
/*++
Routine Description

    Implements RSS VOLUME MANAGE & RSS VOLUME SET interfaces.
    Arguments are in global arrays:
        Args      - containing list of arguments
        Switches  - containing list of switches

Arguments
    
    None

Return Value

    CLIP_ERROR_SUCCESS              if everything's ok
    CLIP_ERROR_INVALID_PARAMETER    if args/switches are bad
    CLIP_ERROR_UNKNOWN              any other error

--*/
{
    DWORD i = 0;
    HRESULT hr;
    LPWSTR stopString = NULL;
    DWORD  dfs =  INVALID_DWORD_ARG;
    DWORD  size = INVALID_DWORD_ARG;
    DWORD  access = INVALID_DWORD_ARG;
    LPWSTR rulePath = INVALID_POINTER_ARG;
    LPWSTR ruleFileSpec = INVALID_POINTER_ARG;
    BOOL   include = FALSE;
    BOOL   recursive = FALSE;

    WsbTraceIn(OLESTR("ClipVolumeSetManage"), OLESTR(""));

    try {
        //
        // Atleast one arg. required for this interface
        //
        CLIP_ARGS_REQUIRED();

        if (NumberOfSwitches) {
            for (i = 0; i < NumberOfSwitches; i++) {
                switch (Switches[i].SwitchType) {
                case DFS_SW: {
                        CLIP_VALIDATE_DUPLICATE_DWORD_ARG(dfs);
                        CLIP_GET_DWORD_ARG(dfs, Switches[i].Arg, stopString);
                        break;
                    }

                case SIZE_SW: {
                        CLIP_VALIDATE_DUPLICATE_DWORD_ARG(size);
                        CLIP_GET_DWORD_ARG(size, Switches[i].Arg, stopString);
                        break;
                    }

                case ACCESS_SW: {
                        CLIP_VALIDATE_DUPLICATE_DWORD_ARG(access);
                        CLIP_GET_DWORD_ARG(access, Switches[i].Arg, stopString);
                        break;
                    }
                case INCLUDE_SW: {
                        include = TRUE;
                        //
                        // Deliberately fall down to the EXCLUDE case
                        // (break intentionally omitted)
                        // 
                    }
                case EXCLUDE_SW: {

                        CLIP_VALIDATE_DUPLICATE_POINTER_ARG(rulePath);

                        rulePath = wcstok(Switches[i].Arg, RULE_DELIMITERS);
                        ruleFileSpec = wcstok(NULL, L"");
                        if (ruleFileSpec == NULL) {
                            //
                            // Omission of this indicates all files
                            //
                            ruleFileSpec = CLI_ALL_STR;
                        }
                        break;
                    }
                case RECURSIVE_SW: {
                        recursive = TRUE;
                        break;
                    }
                default: {
                        WsbThrow(E_NOINTERFACE);
                    }
                }
            }
        }
        //
        // Validate the rule arguments
        //
        if ((rulePath == INVALID_POINTER_ARG) && recursive) {
            //
            // The recursive flag is valid only if a rule was specified
            //
            WsbThrow(E_NOINTERFACE);
        }

        if (Set) {
            hr = VolumeSet(Args,
                           NumberOfArguments,
                           dfs,
                           size,
                           access,
                           rulePath,
                           ruleFileSpec,
                           include,
                           recursive);
        } else {
            hr = VolumeManage(Args,
                              NumberOfArguments,
                              dfs,
                              size,
                              access,
                              rulePath,
                              ruleFileSpec,
                              include,
                              recursive);
        }
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("ClipVolumeSetManage"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}          


HRESULT 
ClipVolumeDelete(VOID)
/*++
Routine Description

    Implements RSS VOLUME DELETE interface.
    Arguments are in global arrays:
        Args      - containing list of arguments
        Switches  - containing list of switches

Arguments
    
    None

Return Value

    S_OK             if everything's ok
    E_NOINTERFACE     if arguments are invalid

--*/
{
    DWORD i;
    HRESULT hr;
    BOOL rule = FALSE;
    LPWSTR rulePath = INVALID_POINTER_ARG;
    LPWSTR ruleFileSpec = INVALID_POINTER_ARG;

    WsbTraceIn(OLESTR("ClipVolumeDelete"), OLESTR(""));

    try {
        //
        // Atleast one arg. required for this interface
        //
        CLIP_ARGS_REQUIRED();

        for (i = 0; i < NumberOfSwitches; i++) {
            switch (Switches[i].SwitchType) {
            case RULE_SW:  {
                    CLIP_VALIDATE_DUPLICATE_POINTER_ARG(rulePath);
                    rule = TRUE;
                    rulePath = wcstok(Switches[i].Arg, RULE_DELIMITERS);
                    ruleFileSpec = wcstok(NULL, L"");
                    if (ruleFileSpec == NULL) {
                        //
                        // Omission of this indicates all files
                        //
                        ruleFileSpec = CLI_ALL_STR;
                    }
                    break;
                }
            default: {
                    //
                    // Invalid option   
                    //
                    WsbThrow(E_NOINTERFACE);
                }
            }
        }
        //
        // Only deleting rules is supported now
        //
        if (rule) {
            hr = VolumeDeleteRule(Args,
                                  NumberOfArguments,
                                  rulePath,
                                  ruleFileSpec);
        } else {
            hr = E_NOINTERFACE;
        }
    }WsbCatch(hr);


    WsbTraceOut(OLESTR("ClipVolumeDelete"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}        


HRESULT
ClipVolumeJob(VOID)
/*++
Routine Description

    Implements RSS VOLUME JOB interface.
    Arguments are in global arrays:
        Args      - containing list of arguments
        Switches  - containing list of switches

Arguments
    
    None

Return Value

    S_OK             if everything's ok
    E_NOINTERFACE     if arguments are invalid
--*/
{
    DWORD i;
    HRESULT hr;
    HSM_JOB_TYPE jobType =  InvalidJobType;

#define CANCEL_JOB    0
#define RUN_JOB       1

    DWORD  runOrCancel    = INVALID_DWORD_ARG;
    BOOL  synchronous = FALSE;

    WsbTraceIn(OLESTR("ClipVolumeJob"), OLESTR(""));

    try {
        //
        // Atleast one arg. required for this interface
        //
        CLIP_ARGS_REQUIRED();

        for (i = 0; i < NumberOfSwitches; i++) {
            switch (Switches[i].SwitchType) {
            case RUN_SW: {
                    CLIP_VALIDATE_DUPLICATE_DWORD_ARG(runOrCancel);
                    runOrCancel = RUN_JOB;
                    break;
                }
            case CANCEL_SW: {
                    CLIP_VALIDATE_DUPLICATE_DWORD_ARG(runOrCancel);
                    runOrCancel = CANCEL_JOB;
                    break;
                }
            case WAIT_SW: {
                    synchronous = TRUE;
                    break;
                }
            case TYPE_SW: {
                    if (jobType != InvalidJobType) {
                        //
                        // Duplicate switch. Bail
                        //
                        WsbThrow(E_NOINTERFACE);
                    }
                    jobType = ClipGetJobType(Switches[i].Arg);
                    if (jobType == InvalidJobType) {
                        //
                        // Invalid job type supplied..
                        //
                        WsbThrow(E_NOINTERFACE);
                    }
                    break;
                }
            default: {
                    WsbThrow(E_NOINTERFACE);
                }
            }
        }

        //
        // More validation: 
        //  job type should be valid i.e., specified
        //        
        if (jobType == InvalidJobType) {
            WsbThrow(E_NOINTERFACE);
        }

//
//  Run is the default.. (i.e. TRUE). So if runOrCancel is either 
//  INVALID_DWORD_ARG or RUN_JOB, we pass TRUE
//
        hr =  VolumeJob(Args,
                        NumberOfArguments,
                        jobType,
                        (runOrCancel == CANCEL_JOB)? FALSE: TRUE,
                        synchronous);

    }WsbCatch(hr);

    WsbTraceOut(OLESTR("ClipVolumeJob"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return hr;
}        


HRESULT
ClipMediaShow(VOID)
/*++
Routine Description

    Implements RSS MEDIA SHOW interface.
    Arguments are in global arrays:
        Args      - containing list of arguments
        Switches  - containing list of switches

Arguments
    
    None

Return Value

    S_OK             if everything's ok
    E_NOINTERFACE     if arguments are invalid
--*/
{
    DWORD i;
    HRESULT hr;
    BOOL name = FALSE;
    BOOL status = FALSE;
    BOOL capacity = FALSE;
    BOOL freeSpace = FALSE;
    BOOL version = FALSE;
    BOOL copies = FALSE;

    WsbTraceIn(OLESTR("ClipMediaShow"), OLESTR(""));

    try {
        //
        // Atleast one arg. required for this interface
        //
        CLIP_ARGS_REQUIRED();

        if (NumberOfSwitches == 0) {
            name = status = capacity = freeSpace = version = copies = TRUE;
        } else {
            for (i = 0; i < NumberOfSwitches; i++) {
                switch (Switches[i].SwitchType) {
                case NAME_SW: {
                        name = TRUE;
                        break;
                    }
                case STATUS_SW: {
                        status = TRUE;
                        break;
                    }
                case CAPACITY_SW: {
                        capacity = TRUE;
                        break;
                    }
                case FREESPACE_SW: {
                        freeSpace = TRUE;
                        break;
                    }
                case VERSION_SW: {
                        version = TRUE;
                        break;
                    }
                case COPIES_SW: {
                        copies = TRUE;
                        break;
                    }
                default: {
                        //
                        // Invalid option   
                        //
                        WsbThrow(E_NOINTERFACE);
                    }
                }
            }
        }

        hr = MediaShow(Args,
                       NumberOfArguments,
                       name,
                       status,
                       capacity,
                       freeSpace,
                       version,
                       copies); 
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("ClipMediaShow"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return hr;

}


HRESULT
ClipMediaSynchronize(VOID)
/*++
Routine Description

    Implements RSS MEDIA SYNCHRONIZE interface.
    Arguments are in global arrays:
        Args      - containing list of arguments
        Switches  - containing list of switches

Arguments
    
    None

Return Value

    S_OK             if everything's ok
    E_NOINTERFACE     if arguments are invalid
--*/
{
    DWORD i;
    HRESULT hr;
    DWORD copySetNumber = INVALID_DWORD_ARG;
    BOOL  synchronous = FALSE;
    LPWSTR stopString = NULL;

    WsbTraceIn(OLESTR("ClipMediaSynchronize"), OLESTR(""));

    try {
        //
        // No arguments needed
        //
        CLIP_ARGS_NOT_REQUIRED();

        for (i = 0; i < NumberOfSwitches; i++) {
            switch (Switches[i].SwitchType) {
            case COPYSET_SW: {
                    CLIP_VALIDATE_DUPLICATE_DWORD_ARG(copySetNumber);
                    CLIP_GET_DWORD_ARG(copySetNumber, Switches[i].Arg, stopString);
                    break;
                }
            case WAIT_SW: {
                    synchronous = TRUE;
                    break;
                }
            default: {
                    //
                    // Invalid option   
                    //
                    WsbThrow(E_NOINTERFACE);
                }
            }
        }
        //
        // Need copy set number..
        //
        if (copySetNumber == INVALID_DWORD_ARG) {
            //
            // None was specified
            //
            WsbThrow(E_NOINTERFACE);
        }
        hr = MediaSynchronize(copySetNumber, synchronous);
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("ClipMediaRecreateMaster"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return hr;
}        


HRESULT
ClipMediaRecreateMaster(VOID)
/*++
Routine Description

    Implements RSS MEDIA RECREATEMASTER interface.
    Arguments are in global arrays:
        Args      - containing list of arguments
        Switches  - containing list of switches

Arguments
    
    None

Return Value

    S_OK             if everything's ok
    E_NOINTERFACE     if arguments are invalid

--*/
{

    DWORD i;
    HRESULT hr;
    DWORD copySetNumber = INVALID_DWORD_ARG;
    LPWSTR stopString = NULL;
    BOOL  synchronous = FALSE;

    WsbTraceIn(OLESTR("ClipMediaRecreateMaster"), OLESTR(""));

    try {

        //
        // Atleast one arg required
        //
        CLIP_ARGS_REQUIRED();

        if (NumberOfArguments > 1) {
            //
            // Only one argument supported...
            //
            WsbThrow(E_NOINTERFACE);
        }

        for (i = 0; i < NumberOfSwitches; i++) {
            switch (Switches[i].SwitchType) {
            case COPYSET_SW: {
                    CLIP_VALIDATE_DUPLICATE_DWORD_ARG(copySetNumber);
                    CLIP_GET_DWORD_ARG(copySetNumber, Switches[i].Arg, stopString);
                    break;
                }

            case WAIT_SW: {
                    synchronous = TRUE;
                    break;
                }

            default: {
                    //
                    // Invalid option   
                    //
                    WsbThrow(E_NOINTERFACE);
                }
            }
        }
        //
        // Need copy set number..
        //
        if (copySetNumber == INVALID_DWORD_ARG) {
            //
            // None was specified
            //
            WsbThrow(E_NOINTERFACE);
        }

        hr = MediaRecreateMaster(Args[0],
                                 copySetNumber,
                                 synchronous);
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("ClipRecreateMaster"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}        


HRESULT
ClipMediaDelete(VOID)
/*++
Routine Description

    Implements RSS MEDIA DELETE interface.
    Arguments are in global arrays:
        Args      - containing list of arguments
        Switches  - containing list of switches

Arguments
    
    None

Return Value

    S_OK             if everything's ok
    E_NOINTERFACE     if arguments are invalid

--*/
{
    DWORD i;
    HRESULT hr;
    DWORD copySetNumber = INVALID_DWORD_ARG;
    LPWSTR stopString = NULL;

    WsbTraceIn(OLESTR("ClipMediaDelete"), OLESTR(""));

    try {
        //
        // Atleast one arg required
        //
        CLIP_ARGS_REQUIRED();

        for (i = 0; i < NumberOfSwitches; i++) {
            switch (Switches[i].SwitchType) {
            case COPYSET_SW: {
                    CLIP_VALIDATE_DUPLICATE_DWORD_ARG(copySetNumber);
                    CLIP_GET_DWORD_ARG(copySetNumber, Switches[i].Arg, stopString);
                    break;
                }
            default: {
                    //
                    // Invalid option   
                    //
                    WsbThrow(E_NOINTERFACE);
                }
            }
        }
        //
        // Need copy set number..
        //
        if (copySetNumber == INVALID_DWORD_ARG) {
            //
            // None was specified
            //
            WsbThrow(E_NOINTERFACE);
        }
        hr = MediaDelete(Args,
                         NumberOfArguments,
                         copySetNumber);
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("ClipMediaDelete"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return hr;
}


HRESULT
ClipFileRecall(VOID)
/*++
Routine Description

    Implements RSS FILE RECALL interface.
    Arguments are in global arrays:
        Args      - containing list of arguments
        Switches  - containing list of switches

Arguments
    
    None

Return Value

    S_OK             if everything's ok
    E_NOINTERFACE     if arguments are invalid

--*/
{
    HRESULT hr;

    WsbTraceIn(OLESTR("ClipFileRecall"), OLESTR(""));

    try {
        //
        // Atleast one arg. required for this interface
        //
        CLIP_ARGS_REQUIRED();
        //
        // No switches supported
        //
        CLIP_SWITCHES_NOT_REQUIRED();

        hr = FileRecall(Args,
                        NumberOfArguments);

    }WsbCatch(hr);

    WsbTraceOut(OLESTR("ClipFileRecall"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


VOID
ClipHelp(
        IN RSS_INTERFACE Interface,
        IN RSS_INTERFACE SubInterface
        )
/*++
    
Routine Description

    Prints appropriate help message depending on the interface
    
Arguments

    Interface    - Specifies interface for which help has to be 
                   displayed
    SubInterface - Specifies sub-interface for which help has to be 
                   displayed

Return Value:
    
    NONE

--*/
{

#define BREAK_IF_NOT_UNKNOWN_IF(__INTERFACE) {      \
    if (((__INTERFACE) != UNKNOWN_IF) &&            \
        ((__INTERFACE) != HELP_IF)) {               \
            break;                                  \
     }                                              \
}


    WsbTraceIn(OLESTR("ClipHelp"), OLESTR(""));

    switch (Interface) {
    
    case HELP_IF:
    case UNKNOWN_IF: {
            WsbTraceAndPrint(CLI_MESSAGE_MAIN_HELP, NULL);
            BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
        }

    case ADMIN_IF: {
            switch (SubInterface) {
            case HELP_IF:
            case UNKNOWN_IF:
            case SHOW_IF: {
                    WsbTraceAndPrint(CLI_MESSAGE_ADMIN_SHOW_HELP, NULL);
                    BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
                }
            case SET_IF: {
                    WsbTraceAndPrint(CLI_MESSAGE_ADMIN_SET_HELP, NULL);
                    BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
                }
            }
            BREAK_IF_NOT_UNKNOWN_IF(Interface);
        }
    case VOLUME_IF: {
            switch (SubInterface) {
            case HELP_IF:
            case UNKNOWN_IF:
            case SHOW_IF: {
                    WsbTraceAndPrint(CLI_MESSAGE_VOLUME_SHOW_HELP, NULL);
                    BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
                }
            case SET_IF: {
                    WsbTraceAndPrint(CLI_MESSAGE_VOLUME_SET_HELP, NULL);
                    BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
                }
            case MANAGE_IF: {
                    WsbTraceAndPrint(CLI_MESSAGE_VOLUME_MANAGE_HELP, NULL);
                    BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
                }
            case UNMANAGE_IF: {
                    WsbTraceAndPrint(CLI_MESSAGE_VOLUME_UNMANAGE_HELP, NULL);
                    BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
                }
            case JOB_IF: {
                    WsbTraceAndPrint(CLI_MESSAGE_VOLUME_JOB_HELP, NULL);
                    BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
                }
            case DELETE_IF: {
                    WsbTraceAndPrint(CLI_MESSAGE_VOLUME_DELETE_HELP, NULL);
                    BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
                }
            }
            BREAK_IF_NOT_UNKNOWN_IF(Interface);
        }

    case MEDIA_IF: {
            switch (SubInterface) {
            case HELP_IF:
            case UNKNOWN_IF:
            case SHOW_IF: {
                    WsbTraceAndPrint(CLI_MESSAGE_MEDIA_SHOW_HELP, NULL);
                    BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
                }
            case DELETE_IF: {
                    WsbTraceAndPrint(CLI_MESSAGE_MEDIA_DELETE_HELP, NULL);
                    BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
                }
            case SYNCHRONIZE_IF: {
                    WsbTraceAndPrint(CLI_MESSAGE_MEDIA_SYNCHRONIZE_HELP, NULL);
                    BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
                }
            case RECREATEMASTER_IF: {
                    WsbTraceAndPrint(CLI_MESSAGE_MEDIA_RECREATEMASTER_HELP, NULL);
                    BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
                }
            }
            BREAK_IF_NOT_UNKNOWN_IF(Interface);
        }
    case FILE_IF: {
            switch (SubInterface) {
            case HELP_IF:
            case UNKNOWN_IF:
            case RECALL_IF: {
                    WsbTraceAndPrint(CLI_MESSAGE_FILE_RECALL_HELP, NULL);
                    BREAK_IF_NOT_UNKNOWN_IF(SubInterface);
                }
            }
            BREAK_IF_NOT_UNKNOWN_IF(Interface);
        }
    }
    WsbTraceOut(OLESTR("ClipHelp"), OLESTR(""));
}


HRESULT
ClipParseTime(
             IN  LPWSTR        TimeString,
             OUT PSYSTEMTIME   ScheduledTime)
/*++

Routine Description
    

    Parses the passed in TimeString as a 24 hour format 
    (hh:mm:ss) and sets hour/minute/sec/millisec in the passed
    in SYSTEMTIME structure
    
Arguments

    TimeString      - String in the format "hh:mm:ss"
    ScheduledTime   - Pointer to SYSTEMTIME structure. Time parsed from TimeString
                      (if ok) will be used to set hour/min/sec/millisec fields in this struc.


Return Value

    S_OK        - TimeString is valid and time was successfully parsed
    Any other   - Syntax error in TimeString


--*/
{
    LPWSTR stopString = NULL, hourString = NULL, minuteString = NULL, secondString = NULL;
    DWORD hour, minute, second = 0;
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("ClipParseTime"), OLESTR(""));

    try {
        hourString = wcstok(TimeString, HSM_SCHED_TIME_SEPARATORS);
        WsbAssert(hourString != NULL, E_NOINTERFACE);
        CLIP_GET_DWORD_ARG(hour, hourString, stopString);

        if (hour > 23) {
            WsbThrow(E_NOINTERFACE);
        }


        minuteString = wcstok(NULL, HSM_SCHED_TIME_SEPARATORS);
        WsbAssert(minuteString != NULL, E_NOINTERFACE);
        CLIP_GET_DWORD_ARG(minute, minuteString, stopString);

        if (minute > 59) {
            WsbThrow(E_NOINTERFACE);
        }

        secondString = wcstok(NULL, HSM_SCHED_TIME_SEPARATORS);
        if (secondString != NULL) {
            CLIP_GET_DWORD_ARG(second, secondString, stopString);
            if (second > 59) {
                WsbThrow(E_NOINTERFACE);
            }
        }

        ScheduledTime->wHour = (WORD) hour;
        ScheduledTime->wMinute = (WORD) minute;
        ScheduledTime->wSecond = (WORD) second;
        ScheduledTime->wMilliseconds = 0;

    }WsbCatch(hr);

    WsbTraceOut(OLESTR("ClipParseTime"), OLESTR(""));

    return hr;
}


HRESULT
ClipParseSchedule(
                 IN  LPWSTR ScheduleString,
                 OUT PHSM_JOB_SCHEDULE Schedule
                 )
/*++

Routine Description

    Parses the passed in schedule string, and constructs the canonical schedule
    form (of type HSM_JOB_SCHEDULE)
    
    Examples of schedule parameter:
     
    "At 21:03:00"
    "At Startup"
    "At Login"
    "At Idle"
    "Every 1 Week 1   21:03:00"
    "Every 2 Day      21:03:00"
    "Every 1 Month 2  21:03:00"
    
Arguments

    ScheduleString  - String specifying the schedule in user-readable syntax
    Schedule        - Pointer to canonical schedule form will be returned in this var.
    
Return Value

    S_OK            - Successful, Schedule contains a pointer to the constructed schedule.
    E_OUTOFMEMORY   - Lack of sufficient system resources 
    Any other error: incorrect schedule specification
--*/
{
    LPWSTR token;
    DWORD occurrence;
    HSM_JOB_FREQUENCY frequency;
    SYSTEMTIME scheduledTime;
    DWORD day;
    HRESULT hr = S_OK; 

    WsbTraceIn(OLESTR("ClipParseSchedule"), OLESTR(""));

    try {
        token = wcstok(ScheduleString, SEPARATORS);

        WsbAssert(token != NULL, E_NOINTERFACE);

        if (!_wcsicmp(token, HSM_SCHED_AT)) {

            token = wcstok(NULL, SEPARATORS);

            if (token == NULL) {
                //
                // Bad arguments
                //
                WsbThrow(E_NOINTERFACE);
            } else if (!_wcsicmp(token, HSM_SCHED_SYSTEMSTARTUP)) {
                //
                // Once at system startup
                //
                Schedule->Frequency = SystemStartup;
                WsbThrow(S_OK);
            } else if (!_wcsicmp(token, HSM_SCHED_LOGIN)) {
                //
                // Once at login time
                //
                Schedule->Frequency = Login;
                WsbThrow(S_OK);
            } else if (!_wcsicmp(token, HSM_SCHED_IDLE)) {
                //
                //  Whenever system's idle
                //
                Schedule->Frequency = WhenIdle;
                WsbThrow(S_OK);
            } else {

                GetSystemTime(&scheduledTime);
                //
                // Once at specified time.
                // Parse the time string and obtain it
                // TBD - Add provision to specify date as well as time
                //
                hr = ClipParseTime(token,
                                   &scheduledTime);
                WsbAssertHr(hr);

                Schedule->Frequency = Once;
                Schedule->Parameters.Once.Time = scheduledTime;
                WsbThrow(S_OK);
            }
        } else if (!_wcsicmp(token, HSM_SCHED_EVERY)) {
            LPWSTR stopString = NULL;

            //
            // Get the occurrence
            //
            token = wcstok(NULL, SEPARATORS);
            WsbAssert(token != NULL, E_NOINTERFACE);
            CLIP_GET_DWORD_ARG(occurrence, token, stopString);

            //
            // Get the qualifier: Daily/Weekly/Monthly
            //
            token = wcstok(NULL, SEPARATORS);
            WsbAssert(token != NULL, E_NOINTERFACE);
            if (!_wcsicmp(token, HSM_SCHED_DAILY)) {
                frequency = Daily;
            } else if (!_wcsicmp(token, HSM_SCHED_WEEKLY)) {
                frequency = Weekly;
            } else if (!_wcsicmp(token, HSM_SCHED_MONTHLY)) {
                frequency = Monthly;
            } else {
                //
                // Badly constructed argument
                //
                WsbThrow(E_NOINTERFACE);
            }
            //
            // Get current time
            //
            GetSystemTime(&scheduledTime);
            //
            // For weekly/monthly we also need to get the day of the week/month
            // Monday = 1, Sunday = 7 for weekly
            //
            if ((frequency == Weekly) || (frequency == Monthly)) {
                token = wcstok(NULL, SEPARATORS);
                WsbAssert(token != NULL, E_NOINTERFACE);

                CLIP_GET_DWORD_ARG(day, token, stopString);

                //
                // Validate & update the parameters
                //
                if (frequency == Weekly) {
                    if (day > 6) {
                        WsbThrow(E_NOINTERFACE);
                    }
                    scheduledTime.wDayOfWeek = (WORD) day;
                }
                if (frequency == Monthly) {
                    if ((day > 31) || (day < 1)) {
                        WsbThrow(E_NOINTERFACE);
                    }
                    scheduledTime.wDay = (WORD) day;
                }
            }
            //
            // Fetch the time
            //
            token = wcstok(NULL, SEPARATORS);
            WsbAssert(token != NULL, E_NOINTERFACE);
            hr = ClipParseTime(token,
                               &scheduledTime);

            WsbAssertHr(hr);

            Schedule->Frequency = frequency;
            Schedule->Parameters.Daily.Occurrence = occurrence;
            Schedule->Parameters.Daily.Time = scheduledTime;
        } else {
            WsbThrow(E_NOINTERFACE);
        }
    }WsbCatch(hr); 

    WsbTraceOut(OLESTR("ClipParseSchedule"), OLESTR(""));

    return hr;
}

   
BOOL
ClipInitializeTrace(
                   VOID
                   )
/*++

Routine Description
    
    Initializes the trace/printing mechanism for CLI

Arguments

    NONE

Return Value

    TRUE if successful, FALSE otherwise

--*/
{
    BOOL ret = TRUE;


    if (S_OK == CoCreateInstance(CLSID_CWsbTrace, 0, CLSCTX_SERVER, IID_IWsbTrace, (void **)&g_pTrace)) {
        CWsbStringPtr   tracePath;
        CWsbStringPtr   regPath;
        CWsbStringPtr   outString;

        // Registry path for CLI settings
        // If those expand beyond Trace settings, this path should go to a header file
        regPath = L"SOFTWARE\\Microsoft\\RemoteStorage\\CLI";

        // Check if tracing path already exists, if not - set it (this should happen only once)
        WsbAffirmHr(outString.Alloc(WSB_TRACE_BUFF_SIZE));
        if ( WsbGetRegistryValueString(NULL, regPath, L"WsbTraceFileName", outString, WSB_TRACE_BUFF_SIZE, 0) != S_OK) {
            // No trace settings yet
            WCHAR *systemPath;
            systemPath = _wgetenv(L"SystemRoot");
            WsbAffirmHr(tracePath.Printf( L"%ls\\System32\\RemoteStorage\\Trace\\RsCli.Trc", systemPath));

            // Set default settings in the Registry
            WsbEnsureRegistryKeyExists(0, regPath);
            WsbSetRegistryValueString(0, regPath, L"WsbTraceFileName", tracePath);

            // Make sure the trace directory exists.
            WsbAffirmHr(tracePath.Printf( L"%ls\\System32\\RemoteStorage", systemPath));
            CreateDirectory(tracePath, 0);
            WsbAffirmHr(tracePath.Printf( L"%ls\\System32\\RemoteStorage\\Trace", systemPath));
            CreateDirectory(tracePath, 0);
        }

        g_pTrace->SetRegistryEntry(regPath);
        g_pTrace->LoadFromRegistry();
    }

    return ret;    
}



VOID
ClipUninitializeTrace(
                     VOID
                     )
/*++

Routine Description
    
    Uninitializes the trace/print mechansim
    Paired with ClipInitializeTrace

Arguments

    NONE

Return Value

    NONE

--*/
{
    g_pTrace = 0;
}


VOID
ClipHandleErrors(
                IN HRESULT RetCode,
                IN RSS_INTERFACE Interface,
                IN RSS_INTERFACE SubInterface
                )
/*++

Routine Description

    Translates the main return value & displays any appropriate
    error messages and returns

Arguments

    RetCode      - Error to handle
    Interface    - RSS interface specified in the command
    SubInterface - RSS sub-interface specified in the command

Return Value

    None

--*/
{
    WsbTraceIn(OLESTR("ClipHandleErrors"), OLESTR(""));

    switch (RetCode) {
    case E_INVALIDARG:
    case S_OK:{
            //
            // Nothing to print
            //
            break;}

    case E_NOINTERFACE:{
            WsbTraceAndPrint(CLI_MESSAGE_VALUE_DISPLAY, WsbHrAsString(E_INVALIDARG));
            ClipHelp(Interface,
                     SubInterface);
            break;}
    default:{
            WsbTraceAndPrint(CLI_MESSAGE_VALUE_DISPLAY, WsbHrAsString(RetCode));
            break;}
    }

    WsbTraceOut(OLESTR("ClipHandleErrors"), OLESTR(""));
}              


extern "C" 
int  __cdecl 
wmain()
{
    LPWSTR commandLine, token;
    HRESULT hr = E_NOINTERFACE;
    RSS_INTERFACE intrface = HELP_IF, subInterface = UNKNOWN_IF;

    try {
        WsbAffirmHr(CoInitialize(NULL));

        //
        // Set to OEM page locale
        //
        _wsetlocale(LC_ALL, L".OCP");

        //
        // Set to console UI langauge
        //
        SetThreadUILanguage(0);

        ClipInitializeTrace();

        commandLine = GetCommandLine();
        //
        // Get argv[0] out of the way
        //
        token = wcstok(commandLine, SEPARATORS);

        //
        // Get the interface string
        //
        token = wcstok(NULL, SEPARATORS);

        if (token == NULL) {
            ClipHelp(HELP_IF,
                     UNKNOWN_IF);
            hr = S_OK;
            goto exit;
        }

        intrface = ClipGetInterface(token);

        if (intrface == UNKNOWN_IF) {
            hr = E_NOINTERFACE;
            intrface = HELP_IF;
            goto exit;
        }

        if (intrface == HELP_IF) {
            ClipHelp(HELP_IF,
                     UNKNOWN_IF);
            hr = S_OK;
            goto exit;
        }

        //
        // Get sub interface string
        //
        token = wcstok(NULL, SEPARATORS);

        if (token == NULL) {
            hr =  E_NOINTERFACE;
            goto exit;
        }
        subInterface = ClipGetInterface(token);

        if (subInterface == UNKNOWN_IF) {
            hr = E_NOINTERFACE;
            goto exit;
        }

        if (subInterface == HELP_IF) {
            ClipHelp(intrface,
                     UNKNOWN_IF);
            hr = S_OK;
            goto exit;
        }
        //
        // Now compile the switches & arguments into separate arrays
        // First, get the rest of line ..
        //
        token = wcstok(NULL, L"");
        hr = ClipCompileSwitchesAndArgs(token,
                                        intrface,
                                        subInterface);

        if (hr != S_OK) {
            goto exit;
        }

        switch (intrface) {
        
        case ADMIN_IF:{ 
                if (subInterface == SHOW_IF) {
                    hr = ClipAdminShow();
                } else if (subInterface == SET_IF) {
                    hr = ClipAdminSet();
                } else {
                    hr = E_NOINTERFACE;
                }
                break;
            } 

        case VOLUME_IF:{
                if (subInterface == MANAGE_IF) {
                    hr = ClipVolumeSetManage(FALSE);
                } else if (subInterface == UNMANAGE_IF) {
                    hr = ClipVolumeUnmanage();
                } else if (subInterface == SET_IF) {
                    hr = ClipVolumeSetManage(TRUE);
                } else if (subInterface == SHOW_IF) {
                    hr = ClipVolumeShow();
                } else if (subInterface == DELETE_IF) {
                    hr = ClipVolumeDelete();
                } else if (subInterface == JOB_IF) {
                    hr = ClipVolumeJob();
                } else {
                    hr = E_NOINTERFACE;
                }
                break;
            }

        case FILE_IF:{
                if (subInterface == RECALL_IF) {
                    hr = ClipFileRecall();
                } else {
                    hr = E_NOINTERFACE;
                }
                break;
            }

        case MEDIA_IF:{
                if (subInterface == SYNCHRONIZE_IF) {
                    hr = ClipMediaSynchronize();
                } else if (subInterface == RECREATEMASTER_IF) {
                    hr = ClipMediaRecreateMaster();
                } else if (subInterface == DELETE_IF) {
                    hr = ClipMediaDelete();
                } else if (subInterface == SHOW_IF) {
                    hr = ClipMediaShow();
                } else {
                    hr = E_NOINTERFACE;
                }
                break;
            }

        default:{
                hr = E_NOINTERFACE;
                break;
            }
        }

        exit:

        ClipHandleErrors(hr,
                         intrface,
                         subInterface);

        ClipCleanup();
        ClipUninitializeTrace();
        CoUninitialize();

    }WsbCatchAndDo(hr,
                   WsbTraceAndPrint(CLI_MESSAGE_GENERIC_ERROR, WsbHrAsString(hr));
                  );

    CLIP_TRANSLATE_HR_AND_RETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\cli\climedia.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    climedia.cpp

Abstract:

    Implements CLI MEDIA sub-interface

Author:

    Ran Kalach          [rankala]         3-March-2000

Revision History:

--*/

#include "stdafx.h"
#include "HsmConn.h"
#include "engine.h"

static GUID g_nullGuid = GUID_NULL;

// Internal utilities and classes for MEDIA interface
#define CMEDIA_INVALID_INDEX      (-1)

HRESULT IsMediaValid(IN IMediaInfo *pMediaInfo);
HRESULT ShowMediaParams(IN IMediaInfo *pMediaInfo, BOOL bName, IN BOOL bStatus, IN BOOL bCapacity,
                        IN BOOL bFreeSpace, IN BOOL Version, IN BOOL Copies);
HRESULT IsCopySetValid (IN IHsmServer *pHsm, IN DWORD dwCopySetNumber);

class CMediaEnum
{

// Constructors, destructors
public:
    CMediaEnum(IN LPWSTR *pMediaNames, IN DWORD dwNumberOfMedia);
    ~CMediaEnum();

// Public methods
public:
    HRESULT First(OUT IMediaInfo **ppMediaInfo);
    HRESULT Next(OUT IMediaInfo **ppMediaInfo);
    HRESULT ErrorMedia(OUT int *pIndex);

// Private data
protected:
    LPWSTR                  *m_pMediaNames;
    DWORD                   m_dwNumberOfMedia;

    // If * enumeration or not
    BOOL                    m_bAllMedias;

    // Data for the enumeration
    CComPtr<IWsbDb>         m_pDb;
    CComPtr<IWsbDbSession>  m_pDbSession;
    CComPtr<IMediaInfo>     m_pMediaInfo;

    // Used only when m_bAllMedias == FALSE
    int                     m_nCurrent;
    BOOL                    m_bInvalidMedia;
};

inline
HRESULT CMediaEnum::ErrorMedia(OUT int *pIndex)
{
    HRESULT     hr = S_FALSE;
    if (m_bInvalidMedia) {
        // There was an error with last media
        hr = S_OK;
    }

    *pIndex = m_nCurrent;

    return(hr);
}

//
// MEDIA inetrafce implementors
//

HRESULT
MediaSynchronize(
   IN DWORD  CopySetNumber,
   IN BOOL   Synchronous
)
/*++

Routine Description:

    Creates/updates the specified media copy set

Arguments:

    CopySetNumber   -   The copy set number to create/synchronize
    Synchronous     -   If TRUE, the function waits for the operation   
                        to complete before returning. If not, it returns
                        immediately after starting the job 
                        

Return Value:

    S_OK            - If the copy set was created/updated successfully

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("MediaSynchronize"), OLESTR(""));

    try {
        CComPtr<IHsmServer>     pHsm;

        // Get HSM server
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));

        // Verify that input parameters are valid
        WsbAffirmHr(ValidateLimitsArg(CopySetNumber, IDS_MEDIA_COPY_SET, HSMADMIN_MIN_COPY_SETS + 1, HSMADMIN_MAX_COPY_SETS));

        hr = IsCopySetValid(pHsm, CopySetNumber);
        if (S_FALSE == hr) {
            WsbTraceAndPrint(CLI_MESSAGE_IVALID_COPY_SET, NULL);
            WsbThrow(E_INVALIDARG);
        } else {
            WsbAffirmHr(hr);
        }

        // Synchronize copy set
        if (Synchronous) {
            // Call directly Engine method
            WsbAffirmHr(pHsm->SynchronizeMedia(g_nullGuid, (USHORT)CopySetNumber));
        } else {
            // Use RsLaunch
            // Note: Another possibility here would be using the CLI (rss.exex) itself
            // with synchronous flag on, but it's better to depend here on internal HSM 
            // interface (RsLaunch) and not an external one (RSS) that only the parser knows
            CWsbStringPtr       cmdLine;
            WCHAR               cmdParams[40];
            STARTUPINFO         startupInfo;
            PROCESS_INFORMATION exeInfo;

            // Startup info
            memset(&startupInfo, 0, sizeof(startupInfo));
            startupInfo.cb = sizeof( startupInfo );
            startupInfo.wShowWindow = SW_HIDE;
            startupInfo.dwFlags = STARTF_USESHOWWINDOW;

            // Create command line
            swprintf(cmdParams, OLESTR(" sync %lu"), CopySetNumber);
            WsbAffirmHr(cmdLine.Alloc(MAX_PATH + wcslen(WSB_FACILITY_LAUNCH_NAME) + wcslen(cmdParams) + 10));
            WsbAffirmStatus(GetSystemDirectory(cmdLine, MAX_PATH));
            WsbAffirmHr(cmdLine.Append(OLESTR("\\")));
            WsbAffirmHr(cmdLine.Append(WSB_FACILITY_LAUNCH_NAME));
            WsbAffirmHr(cmdLine.Append(cmdParams));

            // Run the RsLaunch process
            WsbAffirmStatus(CreateProcess(NULL, cmdLine, NULL, NULL, FALSE, NULL, NULL, NULL, 
                                            &startupInfo, &exeInfo));

            // Cleanup
            CloseHandle(exeInfo.hProcess);
            CloseHandle(exeInfo.hThread);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("MediaSynchronize"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
MediaRecreateMaster(
   IN LPWSTR MediaName,
   IN DWORD  CopySetNumber,
   IN BOOL   Synchronous
)
/*++

Routine Description:

    Recreate a master for the given meida out of the specified copy

Arguments:

    MediaName       -   Master media name of media to recreate
    CopySetNumber   -   The copy number to use for recreating the master
    Synchronous     -   If TRUE, the function waits for the operation   
                        to complete before returning. If not, it returns
                        immediately after starting the job 

Return Value:

    S_OK            - If the master is recreated successfully from the specified copy

--*/
{
    HRESULT                     hr = S_OK;
    
    WsbTraceIn(OLESTR("MediaRecreateMaster"), OLESTR(""));

    try {
        CComPtr<IHsmServer>     pHsm;
        GUID                    mediaId;

        // Get HSM server
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));

        // Verify that input parameters are valid
        if ((NULL == MediaName) || (NULL == *MediaName)) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_MEDIAS, NULL);
            WsbThrow(E_INVALIDARG);
        }

        WsbAffirmHr(ValidateLimitsArg(CopySetNumber, IDS_MEDIA_COPY_SET, HSMADMIN_MIN_COPY_SETS + 1, HSMADMIN_MAX_COPY_SETS));
        hr = IsCopySetValid(pHsm, CopySetNumber);
        if (S_FALSE == hr) {
            WsbTraceAndPrint(CLI_MESSAGE_IVALID_COPY_SET, NULL);
            WsbThrow(E_INVALIDARG);
        } else {
            WsbAffirmHr(hr);
        }

        // Find the media id according to the given display name
        hr = pHsm->FindMediaIdByDescription(MediaName, &mediaId);
        if ((WSB_E_NOTFOUND == hr) || (GUID_NULL == mediaId)) {
            // Given media name is invalid
            WsbTraceAndPrint(CLI_MESSAGE_INVALID_MEDIA, MediaName, NULL);
            WsbThrow(E_INVALIDARG);
        }
        WsbAffirmHr(hr);

        // Mark media for recreation
        WsbAffirmHr(pHsm->MarkMediaForRecreation(mediaId));

        if (Synchronous) {
            // Recreate the master
            WsbAffirmHr(pHsm->RecreateMaster(mediaId, (USHORT)CopySetNumber));

        } else {
            // Use RsLaunch
            // Note: Another possibility here would be using the CLI (rss.exex) itself
            // with synchronous flag on, but it's better to depend here on internal HSM 
            // interface (RsLaunch) and not an external one (RSS) that only the parser knows
            CWsbStringPtr       cmdLine;
            CWsbStringPtr       cmdParams;
            STARTUPINFO         startupInfo;
            PROCESS_INFORMATION exeInfo;
            CWsbStringPtr       stringId(mediaId);

            // Startup info
            memset(&startupInfo, 0, sizeof(startupInfo));
            startupInfo.cb = sizeof( startupInfo );
            startupInfo.wShowWindow = SW_HIDE;
            startupInfo.dwFlags = STARTF_USESHOWWINDOW;

            // Create command line
            WsbAffirmHr(cmdParams.Alloc(wcslen(stringId) + 40));
            swprintf(cmdParams, OLESTR(" recreate -i %ls -c %lu"), (WCHAR *)stringId, CopySetNumber);
            WsbAffirmHr(cmdLine.Alloc(MAX_PATH + wcslen(WSB_FACILITY_LAUNCH_NAME) + wcslen(cmdParams) + 10));
            WsbAffirmStatus(GetSystemDirectory(cmdLine, MAX_PATH));
            WsbAffirmHr(cmdLine.Append(OLESTR("\\")));
            WsbAffirmHr(cmdLine.Append(WSB_FACILITY_LAUNCH_NAME));
            WsbAffirmHr(cmdLine.Append(cmdParams));

            // Run the RsLaunch process
            WsbAffirmStatus(CreateProcess(NULL, cmdLine, NULL, NULL, FALSE, NULL, NULL, NULL, 
                                            &startupInfo, &exeInfo));

            // Cleanup
            CloseHandle(exeInfo.hProcess);
            CloseHandle(exeInfo.hThread);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("MediaRecreateMaster"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
MediaDelete(
   IN LPWSTR *MediaNames,
   IN DWORD  NumberOfMedia,
   IN DWORD  CopySetNumber
)
/*++

Routine Description:

    Deletes the specified copy for all given (master) medias

Arguments:

    MediaNames      -   The list of media to delete a copy for
    NumberOfMedia   -   Number of medias in the set
    CopySetNumber   -   Which copy to delete

Return Value:

    S_OK            - If the media copy is deleted successfully for all medias

Notes:

    1. MediaNames could point tp a "*" string for enumerating all medias. NumberOfMedia should be 1 then.
    2. If a certain copy doesn't exist for a certain media, we report but not abort.

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("MediaDelete"), OLESTR(""));

    try {
        CComPtr<IHsmServer>     pHsm;
        CComPtr<IRmsServer>     pRms;
        CComPtr<IMediaInfo>     pMediaInfo;
        GUID                    mediaSubsystemId;

        // Get HSM server
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));

        // Verify that input parameters are valid
        if ((NULL == MediaNames) || (0 == NumberOfMedia)) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_MEDIAS, NULL);
            WsbThrow(E_INVALIDARG);
        }

        WsbAffirmHr(ValidateLimitsArg(CopySetNumber, IDS_MEDIA_COPY_SET, HSMADMIN_MIN_COPY_SETS + 1, HSMADMIN_MAX_COPY_SETS));
        hr = IsCopySetValid(pHsm, CopySetNumber);
        if (S_FALSE == hr) {
            WsbTraceAndPrint(CLI_MESSAGE_IVALID_COPY_SET, NULL);
            WsbThrow(E_INVALIDARG);
        } else {
            WsbAffirmHr(hr);
        }

        // Get RMS server
        WsbAffirmHr(pHsm->GetHsmMediaMgr(&pRms));

        // Initialize an enumerator object
        CMediaEnum mediaEnum(MediaNames, NumberOfMedia);

        hr = mediaEnum.First(&pMediaInfo);
        if (WSB_E_NOTFOUND == hr) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_MEDIAS, NULL);
            WsbThrow(hr);
        } else if (S_OK != hr) {
            int index;
            if (S_OK == mediaEnum.ErrorMedia(&index)) {
                // Problem with a specific input media
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_MEDIA, MediaNames[index], NULL);
            }
            WsbThrow(hr);
        }

        while(S_OK == hr) {
            // Delete a copy
            WsbAffirmHr(pMediaInfo->GetCopyMediaSubsystemId((USHORT)CopySetNumber, &mediaSubsystemId));
            if (GUID_NULL == mediaSubsystemId) {
                // No such copy - report and continue
                int index;
                mediaEnum.ErrorMedia(&index);
                if (CMEDIA_INVALID_INDEX != index) {
                    // Input from user - report
                    WCHAR copyStr[6];
                    swprintf(copyStr, OLESTR("%u"), (USHORT)CopySetNumber);
                    WsbTraceAndPrint(CLI_MESSAGE_MEDIA_NO_COPY, copyStr, MediaNames[index], NULL);
                } 
            } else {
                // We don't expect to get here RMS_E_CARTRIDGE_NOT_FOUND 
                //  because this has already been tested by the enumerator
                WsbAffirmHr(pRms->RecycleCartridge(mediaSubsystemId, 0));

                // Delete from the table
                WsbAffirmHr(pMediaInfo->DeleteCopy((USHORT)CopySetNumber));
                WsbAffirmHr(pMediaInfo->Write());
            }

            pMediaInfo = 0;
            hr = mediaEnum.Next(&pMediaInfo);
        }
        
        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        } else {
            int index;
            if (S_OK == mediaEnum.ErrorMedia(&index)) {
                // Problem with a specific input media
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_MEDIA, MediaNames[index], NULL);
            }
            WsbThrow(hr);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("MediaDelete"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
MediaShow(
   IN LPWSTR *MediaNames,
   IN DWORD  NumberOfMedia,
   IN BOOL   Name,
   IN BOOL   Status,
   IN BOOL   Capacity,
   IN BOOL   FreeSpace,
   IN BOOL   Version,
   IN BOOL   Copies
)
/*++

Routine Description:

    Shows (prints to stdout) given media(s) parameters

Arguments:

    MediaNames      -   The list of media to show parameters for
    NumberOfMedia   -   Number of medias in the set
    Name            -   Media display name
    Status          -   HSM status of the media (i.e. - Healthy, Read-Only, etc.)
    Capacity,       -   Media capacity (in GB)
    FreeSpace       -   Amount of free space left on the media (in GB)
    Version         -   Last update date for that media
    Copies          -   Number of existing copies and the status of each copy

Return Value:

    S_OK            - If all the parameters could be retrieved for all medias

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("MediaShow"), OLESTR(""));

    try {
        CComPtr<IMediaInfo>     pMediaInfo;

        // Verify that input parameters are valid
        if ((NULL == MediaNames) || (0 == NumberOfMedia)) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_MEDIAS, NULL);
            WsbThrow(E_INVALIDARG);
        }

        // Initialize an enumerator object
        CMediaEnum mediaEnum(MediaNames, NumberOfMedia);

        hr = mediaEnum.First(&pMediaInfo);
        if (WSB_E_NOTFOUND == hr) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_MEDIAS, NULL);
            WsbThrow(hr);
        } else if (S_OK != hr) {
            int index;
            if (S_OK == mediaEnum.ErrorMedia(&index)) {
                // Problem with a specific input media
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_MEDIA, MediaNames[index], NULL);
            }
            WsbThrow(hr);
        }

        while(S_OK == hr) {
            // Show parameters
            WsbAffirmHr(ShowMediaParams(pMediaInfo, Name, Status, Capacity, 
                                        FreeSpace, Version, Copies));

            pMediaInfo = 0;
            hr = mediaEnum.Next(&pMediaInfo);
        }
        
        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        } else {
            int index;
            if (S_OK == mediaEnum.ErrorMedia(&index)) {
                // Problem with a specific input media
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_MEDIA, MediaNames[index], NULL);
            }
            WsbThrow(hr);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("MediaShow"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

//
// Enumerator class methods
//

CMediaEnum::CMediaEnum(IN LPWSTR *pMediaNames, IN DWORD dwNumberOfMedia)
/*++

Routine Description:

    Constructor

Arguments:

    pMediaNames         - Medias to enumerate
    dwNumberOfMedia     - Number of medias

Return Value:

    None

Notes:
    There are two kinds of enumerations:
    1) If * is specified, the base for the enumeration is the Engine media (DB) table
       In that case, there could be no error in the input media names themselves
    2) If a list of media names is given, the base for the enumeration is this list. This is
       less efficient that using the Engine media table, but it keeps the order of medias
       according to the input list. If a media name from the list is not valid, the invalid flag is set.

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CMediaEnum::CMediaEnum"), OLESTR(""));

    try {
        m_pMediaNames = pMediaNames; 
        m_dwNumberOfMedia = dwNumberOfMedia;

        m_nCurrent = CMEDIA_INVALID_INDEX;
        m_bInvalidMedia = FALSE;
        m_bAllMedias = FALSE;

        // Check mode of enumeration
        WsbAssert(dwNumberOfMedia > 0, E_INVALIDARG);
        if ((1 == dwNumberOfMedia) && (0 == wcscmp(m_pMediaNames[0], CLI_ALL_STR))) {
            // * enumeration
            m_bAllMedias = TRUE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaEnum::CMediaEnum"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
}

CMediaEnum::~CMediaEnum( )
/*++

Routine Description:

    Destructor - free DB resources

Arguments:

    None

Return Value:

    None

--*/
{
    WsbTraceIn(OLESTR("CMediaEnum::~CMediaEnum"), OLESTR(""));

    // Release the entity first
    if( m_pMediaInfo ) {
        m_pMediaInfo = 0;
    }

    // Close the DB
    if( m_pDb ) {
        m_pDb->Close(m_pDbSession);
    }

    // m_pDb & m_pDbSession are released when the object terminates

    WsbTraceOut(OLESTR("CMediaEnum::~CMediaEnum"), OLESTR(""));
}

HRESULT CMediaEnum::First(OUT IMediaInfo **ppMediaInfo)
/*++

Routine Description:

    Gets first media

Arguments:

    ppMediaInfo     - First media info record to get

Return Value:

    S_OK            - If first media is retrieved
    WSB_E_NOTFOUND  - If no more medias to enumerate
    E_INVALIDARG    - If media name given by the user is not found
                      (Only on a non * enumeration, m_bInvalidMedia is set)

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CMediaEnum::First"), OLESTR(""));

    try {
        // Open database and get a session for the enumeration (only once during the object life time)
        if (!m_pDb) {
            CComPtr<IHsmServer> pHsm;
            WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));

            WsbAffirmHr(pHsm->GetSegmentDb(&m_pDb));
            WsbAffirmHr(m_pDb->Open(&m_pDbSession));
            WsbAffirmHr(m_pDb->GetEntity(m_pDbSession, HSM_MEDIA_INFO_REC_TYPE, IID_IMediaInfo, (void**)&m_pMediaInfo));
        }

        // Enumerate
        if (m_bAllMedias) {
            // Get first media in the table
            WsbAffirmHr(m_pMediaInfo->First());

            // Validate media, if it's not valid, continue until we find a valid one
            // If no valid media is found, the loop terminates by throwing WSB_E_NOTFOUND by the Next method
            HRESULT hrValid = IsMediaValid(m_pMediaInfo);
            while (S_OK != hrValid) {
                WsbAffirmHr(m_pMediaInfo->Next());
                hrValid = IsMediaValid(m_pMediaInfo);
            }
        
            // Found a valid media
            *ppMediaInfo = m_pMediaInfo;
            (*ppMediaInfo)->AddRef();

        } else {
            CWsbStringPtr           mediaDescription;

            // Enumerate user collection and try to find it in the table
            m_nCurrent = 0;
            if (m_nCurrent >= (int)m_dwNumberOfMedia) {
                WsbThrow(WSB_E_NOTFOUND);
            }

            // Find it
            hr = m_pMediaInfo->First();
            while(S_OK == hr) {
                WsbAffirmHr(m_pMediaInfo->GetDescription(&mediaDescription, 0));
                if (_wcsicmp(m_pMediaNames[m_nCurrent], mediaDescription) == 0) {
                    // Fount it !!
                    *ppMediaInfo = m_pMediaInfo;
                    (*ppMediaInfo)->AddRef();

                    // Validate media
                    if (S_OK != IsMediaValid(m_pMediaInfo)) {
                        // Return an error indication
                        m_bInvalidMedia = TRUE;
                        hr = E_INVALIDARG;
                        WsbThrow(hr);
                    }

                    break;
                }

                mediaDescription.Free();
                hr = m_pMediaInfo->Next();
            }
         
            if (WSB_E_NOTFOUND == hr) {
                // Media given by user not found
                m_bInvalidMedia = TRUE;
                hr = E_INVALIDARG;
            }
            WsbAffirmHr(hr);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaEnum::First"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT CMediaEnum::Next(OUT IMediaInfo **ppMediaInfo)
/*++

Routine Description:

    Gets next media

Arguments:

    ppMediaInfo     - Next media info record to get

Return Value:

    S_OK            - If next media is retrieved
    WSB_E_NOTFOUND  - If no more medias to enumerate
    E_INVALIDARG    - If media name given by the user is not found
                      (Only on a non * enumeration, m_bInvalidMedia is set)

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CMediaEnum::Next"), OLESTR(""));

    try {
        // Enumerate
        if (m_bAllMedias) {
            // Get first media in the table
            WsbAffirmHr(m_pMediaInfo->Next());

            // Validate media, if it's not valid, continue until we find a valid one
            // If no valid media is found, the loop terminates by throwing WSB_E_NOTFOUND by the Next method
            HRESULT hrValid = IsMediaValid(m_pMediaInfo);
            while (S_OK != hrValid) {
                WsbAffirmHr(m_pMediaInfo->Next());
                hrValid = IsMediaValid(m_pMediaInfo);
            }
        
            // Found a valid media
            *ppMediaInfo = m_pMediaInfo;
            (*ppMediaInfo)->AddRef();

        } else {
            CWsbStringPtr           mediaDescription;

            // Enumerate user collection and try to find it in the table
            m_nCurrent++;
            if (m_nCurrent >= (int)m_dwNumberOfMedia) {
                WsbThrow(WSB_E_NOTFOUND);
            }

            // Find it
            hr = m_pMediaInfo->First();
            while(S_OK == hr) {
                WsbAffirmHr(m_pMediaInfo->GetDescription(&mediaDescription, 0));
                if (_wcsicmp(m_pMediaNames[m_nCurrent], mediaDescription) == 0) {
                    // Fount it !!
                    *ppMediaInfo = m_pMediaInfo;
                    (*ppMediaInfo)->AddRef();

                    // Validate media
                    if (S_OK != IsMediaValid(m_pMediaInfo)) {
                        // Return an error indication
                        m_bInvalidMedia = TRUE;
                        hr = E_INVALIDARG;
                        WsbThrow(hr);
                    }

                    break;
                }

                mediaDescription.Free();
                hr = m_pMediaInfo->Next();
            }
         
            if (WSB_E_NOTFOUND == hr) {
                // Media given by user not found
                m_bInvalidMedia = TRUE;
                hr = E_INVALIDARG;
            }
            WsbAffirmHr(hr);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaEnum::Next"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

//
// Internal utilities
//

HRESULT IsMediaValid(IN IMediaInfo *pMediaInfo)
/*++

Routine Description:

    Checks with RMS unit (i.e. with RSM...) if the media is valid.
    The media could be gone if it was deallocated by the user for example
    Note: Currently, this utility does not check if media is enabled, online, etc -
          it just verifies that the media is still known to RSM.

Arguments:

    pMediaInfo      - Media record for media to check

Return Value:

    S_OK            - If media found in RSM
    S_FALSE         - If media is not found in RSM

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("IsMediaValid"), OLESTR(""));

    try {
        CComPtr<IHsmServer>     pHsm;
        CComPtr<IRmsServer>     pRms;
        CComPtr<IRmsCartridge>  pRmsCart;
        GUID mediaSubsystemId;

        WsbAffirmHr(pMediaInfo->GetMediaSubsystemId(&mediaSubsystemId));
        WsbAffirm(GUID_NULL != mediaSubsystemId, S_FALSE);

        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));
        WsbAffirmHr(pHsm->GetHsmMediaMgr(&pRms));
        hr = pRms->FindCartridgeById(mediaSubsystemId, &pRmsCart);
        if (S_OK != hr) {
            // Media not found in RSM, don't care why
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("IsMediaValid"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT IsCopySetValid (IN IHsmServer *pHsm, IN DWORD dwCopySetNumber)
/*++

Routine Description:

    Checks with HSM (Engine) server that the speficied copy set number is within
    the configured copy set range.

Arguments:

    pHsm            - The HSM server to consult with
    dwCopySetNumber - The copy set number to check 

Return Value:

    S_OK            - If the copy set number is within range
    S_FALSE         - If the copy set number is out of range

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("IsCopySetValid"), OLESTR(""));

    try {
        CComPtr<IHsmStoragePool> pStoragePool;
        CComPtr<IWsbIndexedCollection> pCollection;
        ULONG count;
        USHORT numCopies;

        // Get the storage pools collection.  There should only be one member.
        WsbAffirmHr(pHsm->GetStoragePools(&pCollection));
        WsbAffirmHr(pCollection->GetEntries(&count));
        WsbAffirm(1 == count, E_FAIL);
        WsbAffirmHr(pCollection->At(0, IID_IHsmStoragePool, (void **)&pStoragePool));

        // Get and check number of configured copy sets
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));
        WsbAffirmHr(pStoragePool->GetNumMediaCopies(&numCopies));
        if ((USHORT)dwCopySetNumber > numCopies) {
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("IsCopySetValid"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT ShowMediaParams(IN IMediaInfo *pMediaInfo, BOOL bName, IN BOOL bStatus, IN BOOL bCapacity,
                        IN BOOL bFreeSpace, IN BOOL bVersion, IN BOOL bCopies)
/*++

Routine Description:

    Shows (prints to stdout) media parameters

Arguments:

    pMediaInfo      -   Media record
    bName           -   Media display name
    bStatus         -   HSM status of the media (i.e. - Healthy, Read-Only, etc.)
    bCapacity,      -   Media capacity (in GB)
    bFreeSpace      -   Amount of free space left on the media (in GB)
    bVersion        -   Last update date for that media
    bCopies         -   Number of existing copies and the status of each copy

Return Value:

    S_OK            - If all the parameters could be displayed for the input media

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("ShowMediaParams"), OLESTR(""));

    try {
        CWsbStringPtr       param;
        CWsbStringPtr       data;
        WCHAR               longData[100];

        CWsbStringPtr       mediaDescription;
        GUID                mediaSubsystemId;
        LONGLONG            lCapacity, lFreeSpace;
        FILETIME            ftVersion;
        BOOL                bReadOnly, bRecreate;
        SHORT               nNextDataSet;
        HRESULT             hrLast;

        CWsbStringPtr       unusedName;
        GUID                unusedGuid1;
        GUID                unusedGuid2;
        HSM_JOB_MEDIA_TYPE  unusedType;
        LONGLONG            unusedLL1;

        // Get parameters - it is better to get them all at once even if we don't have to display everything
        WsbAffirmHr(pMediaInfo->GetMediaInfo(&unusedGuid1, &mediaSubsystemId, &unusedGuid2, 
                        &lFreeSpace, &lCapacity, &hrLast, &nNextDataSet, &mediaDescription, 0,
                        &unusedType, &unusedName, 0, &bReadOnly, &ftVersion, &unusedLL1, &bRecreate));

        WsbTraceAndPrint(CLI_MESSAGE_MEDIA_PARAMS, (WCHAR *)mediaDescription, NULL);

        // TEMPORARY: For showing most of these parameters, UI utilities and strings are duplicated
        //            To avoid that, general media utilities should be moved from rsadutil.cpp to Wsb unit
        //            and relevant strings should be moved from HsmAdmin DLL to RsCommon DLL


        // Name
        if (bName) {
            CComPtr<IHsmServer>     pHsm;
            CComPtr<IRmsServer>     pRms;
            CComPtr<IRmsCartridge>  pRmsCart;
            CWsbBstrPtr             rsmName;

                // Get RSM name
            WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));
            WsbAffirmHr(pHsm->GetHsmMediaMgr(&pRms));
            WsbAffirmHr(pRms->FindCartridgeById(mediaSubsystemId, &pRmsCart));
            WsbAffirmHr(pRmsCart->GetName(&rsmName));
            if (wcscmp(rsmName, OLESTR("")) == 0 ) {
                rsmName.Free();
                WsbAffirmHr(rsmName.LoadFromRsc(g_hInstance, IDS_CAR_NAME_UNKNOWN));
            }

            // Print
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_MEDIA_RSM_NAME));
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, (WCHAR *)(BSTR)rsmName, NULL);
        }

        // Status
        if (bStatus) {
            SHORT   nLastGoodNextDataSet;
            ULONG   resId;

            // Get more relevant status info
            WsbAffirmHr(pMediaInfo->GetLKGMasterNextRemoteDataSet(&nLastGoodNextDataSet));

            // Compute status 
            if (bRecreate) {
                resId = IDS_CAR_STATUS_RECREATE;
            } else if (nNextDataSet < nLastGoodNextDataSet) {
                resId = IDS_CAR_STATUS_ERROR_INCOMPLETE;
            } else if (SUCCEEDED(hrLast) || (RMS_E_CARTRIDGE_DISABLED == hrLast)) {
                resId = (bReadOnly ? IDS_CAR_STATUS_READONLY : IDS_CAR_STATUS_NORMAL);
            } else if (RMS_E_CARTRIDGE_NOT_FOUND == hrLast) {
                resId = IDS_CAR_STATUS_ERROR_MISSING;
            } else {
                resId = (bReadOnly ? IDS_CAR_STATUS_ERROR_RO : IDS_CAR_STATUS_ERROR_RW);
            }

            // Print
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_MEDIA_STATUS));
            WsbAffirmHr(data.LoadFromRsc(g_hInstance, resId));
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, (WCHAR *)data, NULL);
        }

        // Capacity
        if (bCapacity) {
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_MEDIA_CAPACITY));
            WsbAffirmHr(ShortSizeFormat64(lCapacity, longData));
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, longData, NULL);
        }
        
        // Free Space
        if (bFreeSpace) {
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_MEDIA_FREE_SPACE));
            WsbAffirmHr(ShortSizeFormat64(lFreeSpace, longData));
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, longData, NULL);
        }

        // Version
        if (bVersion) {
            data.Free();
            WsbAffirmHr(FormatFileTime(ftVersion, &data));
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_MEDIA_VERSION));
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, (WCHAR *)data, NULL);
        }

        // Media copies information
        if (bCopies) {
            GUID        copySubsystemId;
            HRESULT     copyLastHr;
            SHORT       copyNextRemoteDataSet, lastGoodNextDataSet;
            ULONG       resId;

            WsbTraceAndPrint(CLI_MESSAGE_MEDIA_COPIES_LIST, NULL);
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_MEDIA_COPY));

            WsbAffirmHr(pMediaInfo->GetLKGMasterNextRemoteDataSet(&lastGoodNextDataSet));

            for (USHORT copyNo=1; copyNo<=HSMADMIN_MAX_COPY_SETS; copyNo++) {
                // Get copy status information
                WsbAffirmHr(pMediaInfo->GetCopyMediaSubsystemId(copyNo, &copySubsystemId));
                WsbAffirmHr(pMediaInfo->GetCopyLastError(copyNo, &copyLastHr));
                WsbAffirmHr(pMediaInfo->GetCopyNextRemoteDataSet(copyNo, &copyNextRemoteDataSet));

                // Compute status
                switch(copyLastHr) {
                    case RMS_E_CANCELLED:
                    case RMS_E_REQUEST_REFUSED:
                    case RMS_E_WRITE_PROTECT:
                    case RMS_E_MEDIA_OFFLINE:
                    case RMS_E_TIMEOUT:
                    case RMS_E_SCRATCH_NOT_FOUND:
                    case RMS_E_CARTRIDGE_UNAVAILABLE:
                    case RMS_E_CARTRIDGE_DISABLED:
                        copyLastHr = S_OK;
                        break;

                }

                if (copySubsystemId == GUID_NULL) {
                    resId = IDS_CAR_COPYSET_NONE;
                } else if (RMS_E_CARTRIDGE_NOT_FOUND == copyLastHr) {
                    resId = IDS_CAR_COPYSET_MISSING;
                } else if (FAILED(copyLastHr)) {
                    resId = IDS_CAR_COPYSET_ERROR;
                } else if (copyNextRemoteDataSet < lastGoodNextDataSet) {
                    resId = IDS_CAR_COPYSET_OUTSYNC;
                } else {
                    resId = IDS_CAR_COPYSET_INSYNC;
                }

                // Print
                swprintf(longData, param, (int)copyNo);
                WsbAffirmHr(data.LoadFromRsc(g_hInstance, resId));
                WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, longData, (WCHAR *)data, NULL);
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("ShowMediaParams"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\cli\cli.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    cli.cpp

Abstract:

    DLL main for Cli

Author:

    Ran Kalach          [rankala]         3-March-2000

Revision History:

--*/

// cli.cpp : Implementation of DLL standard exports.

// Note: Currently, this DLL does not expose any COM objects.
//      

#include "stdafx.h"

CComModule  _Module;
HINSTANCE   g_hInstance;
/*** CComPtr<IWsbTrace> g_pTrace;   ***/

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
		g_hInstance = hInstance;
        DisableThreadLibraryCalls(hInstance);

/***        // Initialize trace mechanizm
        if (S_OK == CoCreateInstance(CLSID_CWsbTrace, 0, CLSCTX_SERVER, IID_IWsbTrace, (void **)&g_pTrace)) {
            CWsbStringPtr   tracePath;
            CWsbStringPtr   regPath;
            CWsbStringPtr   outString;

            // Registry path for CLI settings
            // If those expand beyond Trace settings, this path should go to a header file
            regPath = L"SOFTWARE\\Microsoft\\RemoteStorage\\CLI";
        
            // Check if tracing path already exists, if not - set it (this should happen only once)
            WsbAffirmHr(outString.Alloc(WSB_TRACE_BUFF_SIZE));
            if( WsbGetRegistryValueString(NULL, regPath, L"WsbTraceFileName", outString, WSB_TRACE_BUFF_SIZE, 0) != S_OK) {
                // No trace settings yet
                WCHAR *systemPath;
                systemPath = _wgetenv(L"SystemRoot");
                WsbAffirmHr(tracePath.Printf( L"%ls\\System32\\RemoteStorage\\Trace\\RsCli.Trc", systemPath));

                // Set default settings in the Registry
                WsbEnsureRegistryKeyExists(0, regPath);
                WsbSetRegistryValueString(0, regPath, L"WsbTraceFileName", tracePath);

                // Make sure the trace directory exists.
                WsbAffirmHr(tracePath.Printf( L"%ls\\System32\\RemoteStorage", systemPath));
                CreateDirectory(tracePath, 0);
                WsbAffirmHr(tracePath.Printf( L"%ls\\System32\\RemoteStorage\\Trace", systemPath));
                CreateDirectory(tracePath, 0);
            }
        
            g_pTrace->SetRegistryEntry(regPath);
            g_pTrace->LoadFromRegistry();
        }   ***/

    } else if (dwReason == DLL_PROCESS_DETACH) {
/***         g_pTrace = 0;  ***/
    }


    return TRUE;    // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\cli\clifile.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    clifile.cpp

Abstract:

    Implements CLI FILE sub-interface

Author:

    Ran Kalach          [rankala]         3-March-2000

Revision History:

--*/

#include "stdafx.h"
#include "rpdata.h"

HRESULT
FileRecall(
   IN LPWSTR *FileSpecs,
   IN DWORD NumberOfFileSpecs
)
/*++

Routine Description:

    Recalls all the files that match the given specification (path + wildcards)

Arguments:

    FileSpecs           - 
    NumberOfFileSpecs   - 

Return Value:

    S_OK            - If all the files are recalled successfully.

--*/
{
    HRESULT             hr = S_OK;
    HANDLE              hSearchHandle = INVALID_HANDLE_VALUE;
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    BOOL                bExistingFiles = FALSE;

    WsbTraceIn(OLESTR("FileRecall"), OLESTR(""));

    try {

        // Verify that input parameters are valid
        if (0 == NumberOfFileSpecs) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_FILES, NULL);
            WsbThrow(E_INVALIDARG);
        }

        // Enumerate over the file specifications
        for (ULONG i = 0; i < NumberOfFileSpecs; i++) {
            CWsbStringPtr   nameSpace;
            WCHAR*          pathEnd;
            WIN32_FIND_DATA findData;
            BOOL            bMoreFiles = TRUE;

            WsbAssert(NULL != FileSpecs[i], E_INVALIDARG);

            // Enumerate over files in each specification
            nameSpace = FileSpecs[i];
            WsbAffirmHr(nameSpace.Prepend(OLESTR("\\\\?\\")));
            pathEnd = wcsrchr(nameSpace, L'\\');
            WsbAssert(pathEnd != NULL, E_INVALIDARG);

            hSearchHandle = FindFirstFile((WCHAR *)nameSpace, &findData);
            if (INVALID_HANDLE_VALUE != hSearchHandle) {
                // Found at least one file that matches an input file specification
                bExistingFiles = TRUE;
            }

            while ((INVALID_HANDLE_VALUE != hSearchHandle) && bMoreFiles) {
                if ( findData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) {
                    // File may be managed by HSM:
                    CWsbStringPtr           fileName;
                    BYTE                    ReparseBuffer[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];
                    PREPARSE_DATA_BUFFER    pReparseBuffer;
                    DWORD                   outSize;
                    BOOL                    bRecall = FALSE;

                    // Create full name based on the path and the find-data 
                    *(pathEnd+1) = L'\0';
                    fileName = nameSpace;
                    *(pathEnd+1) = L'\\';
                    WsbAffirmHr(fileName.Append(findData.cFileName));

                    // Open the file
                    hFile = CreateFileW(fileName, GENERIC_READ, FILE_SHARE_READ, NULL,
                              OPEN_EXISTING, FILE_FLAG_OPEN_NO_RECALL | FILE_FLAG_OPEN_REPARSE_POINT, NULL);
                    if (INVALID_HANDLE_VALUE == hFile) {
                        // Report on an error
                        DWORD dwErr = GetLastError();            
                        hr = HRESULT_FROM_WIN32(dwErr);
                        WsbTraceAndPrint(CLI_MESSAGE_ERROR_FILE_RECALL, (WCHAR *)fileName, WsbHrAsString(hr), NULL);
                        WsbThrow(hr);
                    }

                    // Get reparse data and check if the file is offline (if not, just ignore it and continue)
                    if (0 == DeviceIoControl(hFile, FSCTL_GET_REPARSE_POINT, NULL, 0, 
                                ReparseBuffer, sizeof(ReparseBuffer), &outSize, NULL)) {    
                        // Report on an error
                        DWORD dwErr = GetLastError();            
                        hr = HRESULT_FROM_WIN32(dwErr);
                        WsbTraceAndPrint(CLI_MESSAGE_ERROR_FILE_RECALL, (WCHAR *)fileName, WsbHrAsString(hr), NULL);
                        WsbThrow(hr);
                    }
                    pReparseBuffer = (PREPARSE_DATA_BUFFER)ReparseBuffer;
                    if (IO_REPARSE_TAG_HSM == pReparseBuffer->ReparseTag) {
                        PRP_DATA    pHsmData = (PRP_DATA) &pReparseBuffer->GenericReparseBuffer.DataBuffer[0];
                        if( RP_FILE_IS_TRUNCATED( pHsmData->data.bitFlags ) ) {
                            // File is managed by HSM and truncated
                            bRecall = TRUE;
                        }
                    }

                    CloseHandle(hFile);
                    hFile = INVALID_HANDLE_VALUE;

                    // Recall the file if required
                    if (bRecall) {
                        // Open the file again for recall
                        hFile = CreateFileW(fileName, GENERIC_READ, FILE_SHARE_READ, NULL,
                              OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                        if (INVALID_HANDLE_VALUE == hFile) {
                            // Report on an error
                            DWORD dwErr = GetLastError();            
                            hr = HRESULT_FROM_WIN32(dwErr);
                            WsbTraceAndPrint(CLI_MESSAGE_ERROR_FILE_RECALL, (WCHAR *)fileName, WsbHrAsString(hr), NULL);
                            WsbThrow(hr);
                        }

                        // Recall the file
                        if (0 == DeviceIoControl(hFile, FSCTL_RECALL_FILE, NULL, 0, 
                                    NULL, 0, &outSize, NULL)) {
                            // Report on an error
                            // TEMPORARY: Should we abort or continue recalling other files?
                            DWORD dwErr = GetLastError();            
                            hr = HRESULT_FROM_WIN32(dwErr);
                            WsbTraceAndPrint(CLI_MESSAGE_ERROR_FILE_RECALL, (WCHAR *)fileName, WsbHrAsString(hr), NULL);
                            WsbThrow(hr);
                        }

                        CloseHandle(hFile);
                        hFile = INVALID_HANDLE_VALUE;
                    }
                }

                // Get next file
                bMoreFiles = FindNextFile(hSearchHandle, &findData);
            }

            // Prepare for next file specification
            nameSpace.Free();
            if (INVALID_HANDLE_VALUE != hSearchHandle) {
                FindClose(hSearchHandle);
                hSearchHandle = INVALID_HANDLE_VALUE;
            }
        }

        // Print warning message if no valid file was specified
        if (FALSE == bExistingFiles) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_FILES, NULL);
        }

    } WsbCatch(hr);

    // Ensure cleanup in case of an error
    if (INVALID_HANDLE_VALUE != hSearchHandle) {
        FindClose(hSearchHandle);
        hSearchHandle = INVALID_HANDLE_VALUE;
    }
    if (INVALID_HANDLE_VALUE != hFile) {
        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;
    }

    WsbTraceOut(OLESTR("FileRecall"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\cli\cliadmin.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    cliadmin.cpp

Abstract:

    Implements CLI ADMIN sub-interface

Author:

    Ran Kalach          [rankala]         3-March-2000

Revision History:

--*/

#include "stdafx.h"
#include "HsmConn.h"
#include "engine.h"
#include "rsstrdef.h"
#include "mstask.h"

static GUID g_nullGuid = GUID_NULL;

// Internal utilities and classes for VOLUME interface
HRESULT DisplayServiceStatus(void);
HRESULT IsHsmInitialized(IN IHsmServer *pHsm);

HRESULT
AdminSet(
   IN DWORD RecallLimit,
   IN DWORD AdminExempt,
   IN DWORD MediaCopies,
   IN DWORD Concurrency,
   IN PVOID Schedule
)
/*++

Routine Description:

    Sets Remote Storage general parameters

Arguments:

    RecallLimit     - The runaway recall limit to set
    AdminExempt     - Whether to set administrators exempt for the recall limit
    MediaCopies     - Number of media copy sets 
    Concurrency     - How many migrate jobs/recalls can be executed concurrently
    Schedule        - The schedule for the global migration ("Manage") job of all managed volumes 

Return Value:

    S_OK            - If all the parameters are set successfully

Notes:
    The scheduling implementation of HSM (in the Engine) allows only one scheduling
    for the global Manage job. The scheduling given here overrides any former scheduling.
    However, the user can add another scheduling to the same task using the Task Scheduler UI.
    Enabling that via HSM, requires changing the CHsmServer::CreateTaskEx implementation

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("AdminSet"), OLESTR(""));

    try {
        CWsbStringPtr   param;

        // Verify that input parameters are valid
        WsbAffirmHr(ValidateLimitsArg(RecallLimit, IDS_RECALL_LIMIT, HSMADMIN_MIN_RECALL_LIMIT, INVALID_DWORD_ARG));
        WsbAffirmHr(ValidateLimitsArg(MediaCopies, IDS_MEDIA_COPIES_PRM, HSMADMIN_MIN_COPY_SETS, HSMADMIN_MAX_COPY_SETS));
        WsbAffirmHr(ValidateLimitsArg(Concurrency, IDS_CONCURRENCY_PRM, HSMADMIN_MIN_CONCURRENT_TASKS, INVALID_DWORD_ARG));

        // Set parameters, if an error occurs we abort
        if ((INVALID_DWORD_ARG != RecallLimit) || (INVALID_DWORD_ARG != AdminExempt)) {
            // Need Fsa server and Fsa filter here
            CComPtr<IFsaServer> pFsa;
            CComPtr<IFsaFilter> pFsaFilter;

            WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_FSA, g_nullGuid, IID_IFsaServer, (void**)&pFsa));
            WsbAffirmHr(pFsa->GetFilter( &pFsaFilter));

            // Recall limit
            if (INVALID_DWORD_ARG != RecallLimit) {
                WsbAffirmHr(pFsaFilter->SetMaxRecalls(RecallLimit));
            }

            // Admin exempt
            if (INVALID_DWORD_ARG != AdminExempt) {
                BOOL bAdminExempt = (0 == AdminExempt) ? FALSE : TRUE;
                WsbAffirmHr(pFsaFilter->SetAdminExemption(bAdminExempt));
            }
        }

        if ( (INVALID_DWORD_ARG != MediaCopies) || (INVALID_DWORD_ARG != Concurrency) ||
             (INVALID_POINTER_ARG != Schedule) ) {
            // Need Hsm server
            CComPtr<IHsmServer> pHsm;

            WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));

            // Concurrency
            if (INVALID_DWORD_ARG != Concurrency) {
                WsbAffirmHr(pHsm->SetCopyFilesUserLimit(Concurrency));
            }

            // Media copies
            if (INVALID_DWORD_ARG != MediaCopies) {
                CComPtr<IHsmStoragePool> pStoragePool;
                CComPtr<IWsbIndexedCollection> pCollection;
                ULONG count;

                // Get the storage pools collection.  There should only be one member.
                WsbAffirmHr(pHsm->GetStoragePools(&pCollection));
                WsbAffirmHr(pCollection->GetEntries(&count));
                WsbAffirm(1 == count, E_FAIL);
                WsbAffirmHr(pCollection->At(0, IID_IHsmStoragePool, (void **)&pStoragePool));

                WsbAffirmHr(pStoragePool->SetNumMediaCopies((USHORT)MediaCopies));
            }

            // Scheduling
            if (INVALID_POINTER_ARG != Schedule) {
                CWsbStringPtr       taskName, taskComment;
                TASK_TRIGGER_TYPE   taskType;
                PHSM_JOB_SCHEDULE   pSchedule = (PHSM_JOB_SCHEDULE)Schedule;
                SYSTEMTIME          runTime;
                DWORD               runOccurrence;

                // Set default valuess
                GetSystemTime(&runTime);
                runOccurrence = 0;

                // Set input
                switch (pSchedule->Frequency) {
                    case Daily:
                        taskType = TASK_TIME_TRIGGER_DAILY;
                        runTime = pSchedule->Parameters.Daily.Time;
                        runOccurrence = pSchedule->Parameters.Daily.Occurrence;
                        break;

                    case Weekly:
                        taskType = TASK_TIME_TRIGGER_WEEKLY;
                        runTime = pSchedule->Parameters.Weekly.Time;
                        runOccurrence = pSchedule->Parameters.Weekly.Occurrence;
                        break;

                    case Monthly:
                        taskType = TASK_TIME_TRIGGER_MONTHLYDATE;
                        runTime = pSchedule->Parameters.Monthly.Time;
                        break;

                    case Once:
                        taskType = TASK_TIME_TRIGGER_ONCE;
                        runTime = pSchedule->Parameters.Once.Time;
                        break;

                    case WhenIdle:
                        taskType = TASK_EVENT_TRIGGER_ON_IDLE;
                        runOccurrence = pSchedule->Parameters.WhenIdle.Occurrence;
                        break;

                    case SystemStartup:
                        taskType = TASK_EVENT_TRIGGER_AT_SYSTEMSTART;
                        break;

                    case Login:
                        taskType = TASK_EVENT_TRIGGER_AT_LOGON;
                        break;

                    default:
                        WsbThrow(E_INVALIDARG);
                }
                
                // Create the task with the new scheduling
                // Note: Task parameters should not be localized - this is a parameter for RsLaunch.exe
                WsbAffirmHr(WsbGetResourceString(IDS_HSM_SCHED_TASK_TITLE, &taskName));
                WsbAffirmHr(WsbGetResourceString(IDS_HSM_SCHED_COMMENT, &taskComment));
                WsbAffirmHr(pHsm->CreateTaskEx(taskName, L"run manage", taskComment,
                                        taskType, runTime, runOccurrence, TRUE));
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("AdminSet"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

// Local structure for AdminShow
typedef struct _FSA_VOLUME_DATA {
    WCHAR   *Name;
    BOOL    Managed; 
} FSA_VOLUME_DATA, *PFSA_VOLUME_DATA;

#define DATA_ALLOC_SIZE     10

HRESULT
AdminShow(
   IN BOOL RecallLimit,
   IN BOOL AdminExempt,
   IN BOOL MediaCopies,
   IN BOOL Concurrency,
   IN BOOL Schedule,
   IN BOOL General,
   IN BOOL Manageables,
   IN BOOL Managed,
   IN BOOL Media
)
/*++

Routine Description:

    Shows (prints to stdout) Remote Storage general parameters

Arguments:

    RecallLimit     - The runaway recall limit
    AdminExempt     - Whether administrators are exempt from the recall limit
    MediaCopies     - Number of media copy sets 
    Concurrency     - How many migrate jobs/recalls can be executed concurrently
    Schedule        - The schedule for the global migration ("Manage") job of all managed volumes 
    General         - General information: version, status, number of volumes managed, 
                      number of tape cartridges used, data in remote storage
    Manageables     - List of volumes that may be managed by HSM
    Managed         - List of volumes that are managed by HSM
    Media           - List of medias that are allocated to HSM

Return Value:

    S_OK            - If all the required parameters are printed successfully

Notes:
    The schedule is printed in a form of a list (like the volume list), not like a single parameter. 
    The reason is that a user can specify several schedules for the global Manage job.

--*/
{
    HRESULT                 hr = S_OK;

    // Volume saved data
    PFSA_VOLUME_DATA        pVolumesData = NULL;
    ULONG                   volDataSize = 0;

    // Media save data
    BSTR*                   pMediasData = NULL;
    ULONG                   mediaDataSize = 0;
    CComPtr<IWsbDb>         pDb;
    CComPtr<IWsbDbSession>  pDbSession;

    WsbTraceIn(OLESTR("AdminShow"), OLESTR(""));

    try {
        CComPtr<IFsaServer> pFsa;
        CComPtr<IHsmServer> pHsm;
        CWsbStringPtr       param;
        CWsbStringPtr       data;
        WCHAR               longData[100];
        LPVOID              pTemp;

        // Volume data
        LONGLONG            dataInStorage = 0;
        ULONG               manageableCount = 0;
        ULONG               managedCount = 0;

        // Media data
        ULONG               mediaAllocated = 0;

        // Get required HSM servers
        if (RecallLimit || AdminExempt || Manageables || Managed || General) {
            // Need Fsa server
            hr = HsmConnectFromId(HSMCONN_TYPE_FSA, g_nullGuid, IID_IFsaServer, (void**)&pFsa);
            if (S_OK != hr) {
                // Just print status before aborting
                if (General) {
                    DisplayServiceStatus();
                }
            }
            WsbAffirmHr(hr);
        }
        if (MediaCopies || Concurrency || General || Media) {
            // Need Hsm (Engine) server
            hr = HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm);
            if (S_OK != hr) {
                // Just print status before aborting
                if (General) {
                    DisplayServiceStatus();
                }
            }
            WsbAffirmHr(hr);
        }

        //
        // Get basic information required according to the input settings
        //

        // Volumes data
        if (General || Manageables || Managed) {
            // Need to collect volumes information
            CComPtr<IWsbEnum> pEnum;
            CComPtr<IFsaResource> pResource;
            HRESULT hrEnum;
            BOOL    bManaged;

            LONGLONG    totalSpace  = 0;
            LONGLONG    freeSpace   = 0;
            LONGLONG    premigrated = 0;
            LONGLONG    truncated   = 0;
            LONGLONG    totalPremigrated = 0;
            LONGLONG    totalTruncated = 0;


            WsbAffirmHr(pFsa->EnumResources(&pEnum));
            hrEnum = pEnum->First(IID_IFsaResource, (void**)&pResource);
            WsbAffirm((S_OK == hrEnum) || (WSB_E_NOTFOUND == hrEnum), hrEnum);

            if (Manageables || Managed) {
                volDataSize = DATA_ALLOC_SIZE;
                pVolumesData = (PFSA_VOLUME_DATA)WsbAlloc(volDataSize * sizeof(FSA_VOLUME_DATA));
                WsbAffirm(0 != pVolumesData, E_OUTOFMEMORY);
            }

            while(S_OK == hrEnum) {
                // Don't count or display unavailable volumes
                if (S_OK != pResource->IsAvailable()) {
                    goto skip_volume;
                }

                bManaged = (pResource->IsManaged() == S_OK);

                if (Manageables) {
                    if (volDataSize == manageableCount) {
                        volDataSize += DATA_ALLOC_SIZE;
                        pTemp = WsbRealloc(pVolumesData, volDataSize * sizeof(FSA_VOLUME_DATA));
                        WsbAffirm(0 != pTemp, E_OUTOFMEMORY);
                        pVolumesData = (PFSA_VOLUME_DATA)pTemp;
                    }
                    pVolumesData[manageableCount].Name = NULL;
                    WsbAffirmHr(CliGetVolumeDisplayName(pResource, &(pVolumesData[manageableCount].Name)));
                    pVolumesData[manageableCount].Managed = bManaged;
                }

                manageableCount++;

                if(bManaged) {
                    if (General) {
                        WsbAffirmHr(pResource->GetSizes(&totalSpace, &freeSpace, &premigrated, &truncated));
                        totalPremigrated += premigrated;
                        totalTruncated += truncated;
                    }

                    if (Managed && (!Manageables)) {
                        // Collect data only for managed volumes
                        if (volDataSize == managedCount) {
                            volDataSize += DATA_ALLOC_SIZE;
                            pTemp = WsbRealloc(pVolumesData, volDataSize * sizeof(FSA_VOLUME_DATA));
                            WsbAffirm(0 != pTemp, E_OUTOFMEMORY);
                            pVolumesData = (PFSA_VOLUME_DATA)pTemp;
                        }

                        pVolumesData[managedCount].Name = NULL;
                        WsbAffirmHr(CliGetVolumeDisplayName(pResource, &(pVolumesData[managedCount].Name)));
                        pVolumesData[managedCount].Managed = TRUE;
                    }

                    managedCount++;
                }

skip_volume:
                // Prepare for next iteration
                pResource = 0;
                hrEnum = pEnum->Next( IID_IFsaResource, (void**)&pResource );
            }
            if (Manageables) {
                volDataSize = manageableCount;
            } else if (Managed) {
                volDataSize = managedCount;
            }

            if (General) {
                dataInStorage = totalPremigrated + totalTruncated;
            }
        }

        // Medias data
        if (General || Media) {
            CComPtr<IMediaInfo>     pMediaInfo;
            GUID                    mediaSubsystemId;
            CComPtr<IRmsServer>     pRms;
            CComPtr<IRmsCartridge>  pRmsCart;
            HRESULT                 hrFind;

            WsbAffirmHr(pHsm->GetHsmMediaMgr(&pRms));
            WsbAffirmHr(pHsm->GetSegmentDb(&pDb));
            WsbAffirmHr(pDb->Open(&pDbSession));
            WsbAffirmHr(pDb->GetEntity(pDbSession, HSM_MEDIA_INFO_REC_TYPE,  IID_IMediaInfo, (void**)&pMediaInfo));

            if (Media) {
                mediaDataSize = DATA_ALLOC_SIZE;
                pMediasData = (BSTR *)WsbAlloc(mediaDataSize * sizeof(BSTR));
                WsbAffirm(0 != mediaDataSize, E_OUTOFMEMORY);
            }

            for (hr = pMediaInfo->First(); S_OK == hr; hr = pMediaInfo->Next()) {
                WsbAffirmHr(pMediaInfo->GetMediaSubsystemId(&mediaSubsystemId));
                hrFind = pRms->FindCartridgeById(mediaSubsystemId, &pRmsCart);
                if (S_OK == hrFind) {  // Otherwise, the media is not valid anymore, it could have been deallocated
                    if (Media) {
                        if (mediaDataSize == mediaAllocated) {
                            mediaDataSize += DATA_ALLOC_SIZE;
                            pTemp = WsbRealloc(pMediasData, mediaDataSize * sizeof(BSTR));
                            WsbAffirm(0 != pTemp, E_OUTOFMEMORY);
                            pMediasData = (BSTR *)pTemp;
                        }

                        pMediasData[mediaAllocated] = NULL;
                        WsbAffirmHr(pRmsCart->GetName(&(pMediasData[mediaAllocated])));
                        if ( (NULL == pMediasData[mediaAllocated]) || 
                             (0 == wcscmp(pMediasData[mediaAllocated], OLESTR(""))) ) {
                            // Try decsription
                            if (NULL != pMediasData[mediaAllocated]) {
                                WsbFreeString(pMediasData[mediaAllocated]);
                            }

                            WsbAffirmHr(pRmsCart->GetDescription(&(pMediasData[mediaAllocated])));
                        }

                    }

                    mediaAllocated++;
                    pRmsCart = 0;
                }
            }
            if (Media) {
                mediaDataSize = mediaAllocated;
            }
            hr = S_OK;

            if(pDb) {
                pDb->Close(pDbSession);
                pDb = 0;
            }
        }

        //
        // Print parameters
        //

        // General parameters
        if (General) {
            WsbTraceAndPrint(CLI_MESSAGE_GENERAL_PARMS, NULL);

            // Status
            WsbAffirmHr(DisplayServiceStatus());

            // Manageable && Managed
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_NOF_MANAGEABLES));
            swprintf(longData, OLESTR("%lu"), manageableCount);
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, longData, NULL);
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_NOF_MANAGED));
            swprintf(longData, OLESTR("%lu"), managedCount);
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, longData, NULL);

            // Tapes
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_NOF_CARTRIDGES));
            swprintf(longData, OLESTR("%lu"), mediaAllocated);
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, longData, NULL);

            // Data in RS
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_REMOTE_DATA));
            WsbAffirmHr(ShortSizeFormat64(dataInStorage, longData));
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, longData, NULL);

            // Version
            {
                CComPtr<IWsbServer>     pWsbHsm;
                CWsbStringPtr           ntProductVersionHsm;
                ULONG                   ntProductBuildHsm;
                ULONG                   buildVersionHsm;

                WsbAffirmHr(pHsm->QueryInterface(IID_IWsbServer, (void **)&pWsbHsm));
                WsbAffirmHr(pWsbHsm->GetNtProductBuild(&ntProductBuildHsm));
                WsbAffirmHr(pWsbHsm->GetNtProductVersion(&ntProductVersionHsm, 0));
                WsbAffirmHr(pWsbHsm->GetBuildVersion(&buildVersionHsm));

                WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_HSM_VERSION));
                WsbAffirmHr(data.Realloc(wcslen(ntProductVersionHsm) + 30));
                swprintf(data, L"%ls.%d [%ls]", (WCHAR*)ntProductVersionHsm, ntProductBuildHsm, RsBuildVersionAsString(buildVersionHsm));
                WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, (WCHAR *)data, NULL);
            }
        }

        // Manageable volumes
        if (Manageables) {
            WsbTraceAndPrint(CLI_MESSAGE_MANAGEABLE_VOLS, NULL);

            for (ULONG i=0; i<volDataSize; i++) {
                if (pVolumesData[i].Name) {
                    WsbTraceAndPrint(CLI_MESSAGE_VALUE_DISPLAY, pVolumesData[i].Name, NULL);
                }
            }
        }

        // Managed volumes
        if (Managed) {
            WsbTraceAndPrint(CLI_MESSAGE_MANAGED_VOLS, NULL);

            for (ULONG i=0; i<volDataSize; i++) {
                if (pVolumesData[i].Name && pVolumesData[i].Managed) {
                    WsbTraceAndPrint(CLI_MESSAGE_VALUE_DISPLAY, pVolumesData[i].Name, NULL);
                }
            }
        }

        // Allocated Medias
        if (Media) {
            WsbTraceAndPrint(CLI_MESSAGE_MEDIAS, NULL);

            for (ULONG i=0; i<mediaDataSize; i++) {
                if (NULL != pMediasData[i]) {
                    WsbTraceAndPrint(CLI_MESSAGE_VALUE_DISPLAY, (WCHAR *)pMediasData[i], NULL);
                }
            }
        }

        // Schedule
        if (Schedule) {
            // Use Task Scheduler objects to get the data
            CComPtr<ISchedulingAgent>   pSchedAgent;
            CComPtr<ITask>              pTask;
            CWsbStringPtr               manageJobName;

            // Initialize scheduling agent
            WsbAffirmHr(CoCreateInstance(CLSID_CSchedulingAgent, 0, CLSCTX_SERVER, IID_ISchedulingAgent, (void **)&pSchedAgent));
            pSchedAgent->SetTargetComputer(NULL); // local machine

            // Get the relevant task
            WsbAffirmHr(WsbGetResourceString(IDS_HSM_SCHED_TASK_TITLE, &manageJobName));
            hr = pSchedAgent->Activate(manageJobName, IID_ITask, (IUnknown**)&pTask);
            if (E_INVALIDARG == hr) {
                // Print no scheduling message (Manage job is not found as a scheduled task)
                WsbTraceAndPrint(CLI_MESSAGE_NO_SCHEDULING, NULL);
                hr = S_OK;

            } else if (S_OK == hr) {
                // Get scheduling strings and print
                WORD wTriggerCount;
                WsbAffirmHr(pTask->GetTriggerCount(&wTriggerCount));
                if (wTriggerCount == 0) {
                    WsbTraceAndPrint(CLI_MESSAGE_NO_SCHEDULING, NULL);
                } else {
                    WsbTraceAndPrint(CLI_MESSAGE_SCHEDULING_LIST, NULL);
                }
                for (WORD triggerIndex = 0; triggerIndex < wTriggerCount; triggerIndex++) {
                    WCHAR *pTriggerString = NULL;
                    WsbAffirmHr(pTask->GetTriggerString(triggerIndex, &pTriggerString));

                    // Print
                    WsbTraceAndPrint(CLI_MESSAGE_VALUE_DISPLAY, pTriggerString, NULL);

                    CoTaskMemFree(pTriggerString);
                }

            } else {
                WsbAffirmHr(hr);
            }
        }

        // Limits and Media Copies
        if (RecallLimit || AdminExempt) {
            // Need Fsa filter here
            CComPtr<IFsaFilter> pFsaFilter;
            WsbAffirmHr(pFsa->GetFilter(&pFsaFilter));

            if (RecallLimit) {
                ULONG maxRecalls;
                WsbAffirmHr(pFsaFilter->GetMaxRecalls(&maxRecalls));
                WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_RECALL_LIMIT));
                swprintf(longData, OLESTR("%lu"), maxRecalls);
                WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, longData, NULL);
            }

            if (AdminExempt) {
                BOOL adminExempt;
                WsbAffirmHr(pFsaFilter->GetAdminExemption(&adminExempt));
                WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_ADMIN_EXEMPT));
                WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, WsbBoolAsString(adminExempt), NULL);
            }
        }

        if (Concurrency) {
            ULONG concurrentTasks;
            WsbAffirmHr(pHsm->GetCopyFilesUserLimit(&concurrentTasks));
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_CONCURRENCY));
            swprintf(longData, OLESTR("%lu"), concurrentTasks);
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, longData, NULL);
        }

        if (MediaCopies) {
            CComPtr<IHsmStoragePool> pStoragePool;
            CComPtr<IWsbIndexedCollection> pCollection;
            ULONG count;
            USHORT numCopies;

            // Get the storage pools collection.  There should only be one member.
            WsbAffirmHr(pHsm->GetStoragePools(&pCollection));
            WsbAffirmHr(pCollection->GetEntries(&count));
            WsbAffirm(1 == count, E_FAIL);
            WsbAffirmHr(pCollection->At(0, IID_IHsmStoragePool, (void **)&pStoragePool));
            WsbAffirmHr(pStoragePool->GetNumMediaCopies(&numCopies));

            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_MEDIA_COPIES));
            swprintf(longData, OLESTR("%ld"), (int)numCopies);
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, longData, NULL);
        }

    } WsbCatchAndDo(hr,
            if(pDb) {
                pDb->Close(pDbSession);
                pDb = 0;
            }
        );

    // Free stored data
    if (pVolumesData) {
        for (ULONG i=0; i<volDataSize; i++) {
            if (pVolumesData[i].Name) {
                WsbFree(pVolumesData[i].Name);
            }
        }
        WsbFree(pVolumesData);
        pVolumesData = NULL;
    }

    if (pMediasData) {
        for (ULONG i=0; i<mediaDataSize; i++) {
            if (NULL != pMediasData[i]) {
                WsbFreeString(pMediasData[i]);
            }
        }
        WsbFree(pMediasData);
        pMediasData = NULL;
    }

    WsbTraceOut(OLESTR("AdminShow"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

//
// Internal utilities
//
HRESULT DisplayServiceStatus(void)
/*++

Routine Description:

    Displays HSM service status. 

Arguments:

    None

Return Value:

    S_OK            - If status is retrieved and displayed succeessfully

Notes:
    The function handle cases such as the service not runnig, pending, not initialized, etc.

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("DisplayServiceStatus"), OLESTR(""));

    try {
        CWsbStringPtr   param, data;
        ULONG           statusId = INVALID_DWORD_ARG; 
        DWORD           serviceStatus;
        HRESULT         hrService;

        hrService = WsbGetServiceStatus(NULL, APPID_RemoteStorageEngine, &serviceStatus);
        if (S_OK != hrService) {
            // HSM service not registered at all
            WsbTrace(OLESTR("DisplayServiceStatus: Got hr = <%ls> from WsbGetServiceStatus\n"), WsbHrAsString(hrService));
            statusId = IDS_SERVICE_STATUS_NOT_REGISTERED;
        } else {
            if (SERVICE_RUNNING == serviceStatus) {
                CComPtr<IHsmServer> pHsm;
                HRESULT             hrSetup;

                WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));
                hrSetup = IsHsmInitialized(pHsm);
                if (S_FALSE == hrSetup) {
                    // HSM running but no initialized yet (Startup Wizard was not completed yet)
                    statusId = IDS_SERVICE_STATUS_NOT_SETUP;
                } else if (S_OK == hrSetup) {
                    // Service is running, life is good
                    statusId = IDS_SERVICE_STATUS_RUNNING;
                } else {
                    // Unexpected error
                    WsbAffirmHr(hrSetup);
                }
            } else {
                // Service is not running, set exact string according to status
                switch(serviceStatus) {
                    case SERVICE_STOPPED:
                        statusId = IDS_SERVICE_STATUS_STOPPED;
                        break;
                    case SERVICE_START_PENDING:
                        statusId = IDS_SERVICE_STATUS_START_PENDING;
                        break;
                    case SERVICE_STOP_PENDING:
                        statusId = IDS_SERVICE_STATUS_STOP_PENDING;
                        break;
                    case SERVICE_CONTINUE_PENDING:
                        statusId = IDS_SERVICE_STATUS_CONTINUE_PENDING;
                        break;
                    case SERVICE_PAUSE_PENDING:
                        statusId = IDS_SERVICE_STATUS_PAUSE_PENDING;
                        break;
                    case SERVICE_PAUSED:
                        statusId = IDS_SERVICE_STATUS_PAUSED;
                        break;
                    default:
                        WsbThrow(E_FAIL);
                }
            }
        }

        WsbAffirm(INVALID_DWORD_ARG != statusId, E_UNEXPECTED)
        WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_HSM_STATUS));
        WsbAffirmHr(data.LoadFromRsc(g_hInstance, statusId));
        WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, (WCHAR *)data, NULL);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("DisplayServiceStatus"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}

HRESULT IsHsmInitialized(IN IHsmServer *pHsm)
/*++

Routine Description:

    Check if HSM is initialized, i.e. if Startup wizard was completed successfully 

Arguments:

    pHsm            - The HSM server to check with

Return Value:

    S_OK            - HSM initialized
    S_FALSE         - HSM not initialized

--*/
{
    HRESULT                     hr = S_FALSE;

    WsbTraceIn(OLESTR("IsHsmInitialized"), OLESTR(""));

    try {
        GUID                            guid;
        CWsbBstrPtr                     poolName;
        CComPtr<IWsbIndexedCollection>  pCollection;
        ULONG                           count;
        CComPtr<IHsmStoragePool>        pPool;

        WsbAffirmHr(pHsm->GetStoragePools(&pCollection));
        WsbAffirmHr(pCollection->GetEntries(&count));
        WsbAffirm(1 == count, E_FAIL);
        WsbAffirmHr(pCollection->At(0, IID_IHsmStoragePool, (void **)&pPool));

        WsbAffirmHr(pPool->GetMediaSet(&guid, &poolName));
        if(! IsEqualGUID(guid, GUID_NULL)) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("IsHsmInitialized"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}

HRESULT AdminJob(IN BOOL Enable)
/*++

Routine Description:

    Enable/Disable HSM jobs

Arguments:

    None

Return Value:

    S_OK                        - Success
    HSM_E_DISABLE_RUNNING_JOBS  - Returned by Engine when trying to disbale jobs 
                                  while jobs are running
    Other                       - Other unexpected error

--*/
{
    HRESULT                     hr = S_FALSE;

    WsbTraceIn(OLESTR("AdminJob"), OLESTR(""));

    try {
        CComPtr<IHsmServer> pHsm;

        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));
        if (Enable) {
            hr = pHsm->EnableAllJobs();
        } else {
            hr = pHsm->DisableAllJobs();
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("AdminJob"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\cli\cliutils.h ===
/*++
Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    clutils.h

Abstract:

    This module defines internal utilities for CLI unit

Author:

    Ran Kalach (rankala)  3/8/00

--*/

#ifndef _CLIUTILS_
#define _CLIUTILS_

HRESULT ValidateLimitsArg(IN DWORD dwArgValue, IN DWORD dwArgId, IN DWORD dwMinLimit, IN DWORD dwMaxLimit);
HRESULT SaveServersPersistData(void);
HRESULT CliGetVolumeDisplayName(IN IUnknown *pResourceUnknown, OUT WCHAR **ppDisplayName);
HRESULT ShortSizeFormat64(__int64 dw64, LPTSTR szBuf);
HRESULT FormatFileTime(IN FILETIME ft, OUT WCHAR **ppTimeString);
LPTSTR AddCommas(DWORD dw, LPTSTR pszResult, int nResLen);

#endif // _CLIUTILS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\cli\cliparse.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    cliparse.h

Abstract:

    Definitions for CLI parse module

Author:

    Ravisankar Pudipeddi   [ravisp]  21-March-2000

Revision History:

--*/
#ifndef _CLIPARSE_H_
#define _CLIPARSE_H_
//
// Return codes from main()
//
#define     CLIP_ERROR_SUCCESS              0
#define     CLIP_ERROR_INVALID_PARAMETER    1

#define     CLIP_ERROR_INSUFFICIENT_MEMORY  2
#define     CLIP_ERROR_UNKNOWN              0xFF

//
// Token separators on command line
//
#define SEPARATORS              L" \t\n"
//
// Delimiter which distinguishes a switch
//
#define SWITCH_DELIMITERS       L"/-"
//
// Argument separator for a switch
//
#define SWITCH_ARG_DELIMITERS    L":"

//
// Argument separator for a rule spec (distinguishes
// path from file spec)
//
#define RULE_DELIMITERS          L":"

//
// Quotes to delimit tokens with embedded whitespace
//
#define QUOTE                    L'\"'

//
// Rss command line interfaces
//
typedef enum _RSS_INTERFACE {
    UNKNOWN_IF = 0,
    ADMIN_IF,
    VOLUME_IF,
    FILE_IF,
    MEDIA_IF,
    HELP_IF,
    SHOW_IF,
    SET_IF,
    MANAGE_IF,
    UNMANAGE_IF,
    DELETE_IF,
    JOB_IF,
    RECALL_IF,
    SYNCHRONIZE_IF,
    RECREATEMASTER_IF
} RSS_INTERFACE, *PRSS_INTERFACE;

//
// All switches supported by the CLI
//
typedef enum _RSS_SWITCH_TYPE {
    UNKNOWN_SW = 0,
    RECALLLIMIT_SW,
    MEDIACOPIES_SW,
    SCHEDULE_SW,
    CONCURRENCY_SW,
    ADMINEXEMPT_SW,
    GENERAL_SW,
    MANAGEABLES_SW,
    MANAGED_SW,
    MEDIA_SW,
    DFS_SW,
    SIZE_SW,
    ACCESS_SW,
    INCLUDE_SW,
    EXCLUDE_SW,
    RECURSIVE_SW,
    QUICK_SW,
    FULL_SW,
    RULE_SW,
    STATISTICS_SW,
    TYPE_SW,
    RUN_SW,
    CANCEL_SW,
    WAIT_SW,
    COPYSET_SW,
    NAME_SW,
    STATUS_SW,
    CAPACITY_SW,
    FREESPACE_SW,
    VERSION_SW,
    COPIES_SW,
    HELP_SW
} RSS_SWITCH_TYPE, *PRSS_SWITCH_TYPE;

//
// Switches structure: compiled by parsing command line
//
typedef struct _RSS_SWITCHES {
    RSS_SWITCH_TYPE SwitchType;
    LPWSTR          Arg;
} RSS_SWITCHES, *PRSS_SWITCHES;



typedef struct _RSS_KEYWORD {
    //
    // Long version of the keyword
    //
    LPWSTR        Long;
    //
    // Short version of the keyword
    //
    LPWSTR        Short;
    RSS_INTERFACE  Interface;
} RSS_KEYWORD, *PRSS_KEYWORD;

//
// Switches are described in this structure
// First, some defines for RSS_SWITCH_DEFINITION structure 
//
#define RSS_NO_ARG              0
#define RSS_ARG_DWORD           1
#define RSS_ARG_STRING          2
typedef struct _RSS_SWITCH_DEFINITION {
    //
    // Long version of the keyword
    //
    LPWSTR          Long;
    //
    // Short version of the keyword
    //
    LPWSTR          Short;
    RSS_SWITCH_TYPE SwitchType;
    DWORD           ArgRequired;
} RSS_SWITCH_DEFINITION, *PRSS_SWITCH_DEFINITION;

//
// Job type definition
//
typedef struct _RSS_JOB_DEFINITION {
    //
    // Long version of the keyword
    //
    LPWSTR          Long;
    //
    // Short version of the keyword
    //
    LPWSTR          Short;
    HSM_JOB_TYPE    JobType;
} RSS_JOB_DEFINITION, *PRSS_JOB_DEFINITION;



#define HSM_SCHED_AT               L"At"
#define HSM_SCHED_EVERY            L"Every"
#define HSM_SCHED_SYSTEMSTARTUP    L"Startup"
#define HSM_SCHED_LOGIN            L"Login"
#define HSM_SCHED_IDLE             L"Idle"
#define HSM_SCHED_DAILY            L"Day"
#define HSM_SCHED_WEEKLY           L"Week"
#define HSM_SCHED_MONTHLY          L"Month"
#define HSM_SCHED_TIME_SEPARATORS  L":"

#endif // _CLIPARSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\cluster\rsclustr\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\cli\cliutils.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    cliutils.cpp

Abstract:

    Implements internal CLI unit utilities

Author:

    Ran Kalach          [rankala]         8-March-2000

Revision History:

--*/

#include "stdafx.h"
#include "HsmConn.h"

static GUID g_nullGuid = GUID_NULL;

HRESULT
ValidateLimitsArg(
   IN DWORD dwArgValue,
   IN DWORD dwArgId,
   IN DWORD dwMinLimit,
   IN DWORD dwMaxLimit
)
/*++

Routine Description:

    Validates the argument and print error message if necessary

Arguments:

    dwArgValue      - The value to check
    dwArgId         - Id for resource string of the arg
    dwMinLimit      - The Min limit to compare, INVALID_DWORD_ARG for Max compare
    dwMaxLimit      - The Max limit to compare, INVALID_DWORD_ARG for Min compare

Return Value:

    S_OK            - The argument is OK (or not in use)
    E_INVALIDARG    - The argument is not in the limit range

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("ValidateOneLimitArg"), OLESTR(""));

    try {
        CWsbStringPtr   param;
        WCHAR           strLongParm1[30];
        WCHAR           strLongParm2[30];
        WCHAR           strLongParm3[30];

        if (INVALID_DWORD_ARG != dwArgValue) {
            if ((INVALID_DWORD_ARG != dwMinLimit) && (INVALID_DWORD_ARG != dwMaxLimit)) {
                // Min-Max test
                if ((dwArgValue < dwMinLimit) || (dwArgValue > dwMaxLimit)) {
                    WsbAffirmHr(param.LoadFromRsc(g_hInstance, dwArgId));
                    swprintf(strLongParm1, OLESTR("%lu"), dwArgValue);
                    swprintf(strLongParm2, OLESTR("%lu"), dwMinLimit);
                    swprintf(strLongParm3, OLESTR("%lu"), dwMaxLimit);
                    WsbTraceAndPrint(CLI_MESSAGE_INVALID_ARG3, (WCHAR *)param, 
                            strLongParm1, strLongParm2, strLongParm3, NULL);
                    WsbThrow(E_INVALIDARG);
                }
            } else if (INVALID_DWORD_ARG != dwMinLimit) {
                // Min test
                if (dwArgValue < dwMinLimit) {
                    WsbAffirmHr(param.LoadFromRsc(g_hInstance, dwArgId));
                    swprintf(strLongParm1, OLESTR("%lu"), dwArgValue);
                    swprintf(strLongParm2, OLESTR("%lu"), dwMinLimit);
                    WsbTraceAndPrint(CLI_MESSAGE_INVALID_ARG1, (WCHAR *)param, 
                            strLongParm1, strLongParm2, NULL);
                    WsbThrow(E_INVALIDARG);
                }
            } else if (INVALID_DWORD_ARG != dwMaxLimit) {
                // Max test
                if (dwArgValue > dwMaxLimit) {
                    WsbAffirmHr(param.LoadFromRsc(g_hInstance, dwArgId));
                    swprintf(strLongParm1, OLESTR("%lu"), dwArgValue);
                    swprintf(strLongParm2, OLESTR("%lu"), dwMaxLimit);
                    WsbTraceAndPrint(CLI_MESSAGE_INVALID_ARG2, (WCHAR *)param, 
                            strLongParm1, strLongParm2, NULL);
                    WsbThrow(E_INVALIDARG);
                }
             }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("ValidateOneLimitArg"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}

HRESULT SaveServersPersistData(
    void
)
/*++

Routine Description:

    Save persistent data for HSM servers

Arguments:

    None

Return Value:

    S_OK            - The persistent data is saved successfully for all HSM servers

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("SaveServersPersistData"), OLESTR(""));

    try {
        CComPtr<IHsmServer>             pHsm;
        CComPtr<IFsaServer>             pFsa;
        CComPtr<IWsbServer>             pWsbServer;

        // Engine
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));
        WsbAffirmHr(pHsm->SavePersistData());

        // Fsa
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_FSA, g_nullGuid, IID_IFsaServer, (void**)&pFsa));
        WsbAffirmHr(pFsa->QueryInterface(IID_IWsbServer, (void**)&pWsbServer));
        WsbAffirmHr(pWsbServer->SaveAll());

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("SaveServersPersistData"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}

/* converts numbers into sort formats
 *      532     -> 523 bytes
 *      1340    -> 1.3KB
 *      23506   -> 23.5KB
 *              -> 2.4MB
 *              -> 5.2GB
 */

// NOTE: This code is cloned from MS source /shell/shelldll/util.c (and from \hsm\gui\inc\rsutil.cpp)

#define HIDWORD(_qw)    (DWORD)((_qw)>>32)
#define LODWORD(_qw)    (DWORD)(_qw)
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

const int pwOrders[] = {IDS_BYTES, IDS_ORDERKB, IDS_ORDERMB,
                          IDS_ORDERGB, IDS_ORDERTB, IDS_ORDERPB, IDS_ORDEREB};

HRESULT ShortSizeFormat64(__int64 dw64, LPTSTR szBuf)
{
    int i;
    UINT wInt, wLen, wDec;
    TCHAR szTemp[10], szOrder[20], szFormat[5];

    if (dw64 < 1000) {
        wsprintf(szTemp, TEXT("%d"), LODWORD(dw64));
        i = 0;
        goto AddOrder;
    }

    for (i = 1; i<ARRAYSIZE(pwOrders)-1 && dw64 >= 1000L * 1024L; dw64 >>= 10, i++);
        /* do nothing */

    wInt = LODWORD(dw64 >> 10);
    AddCommas(wInt, szTemp, 10);
    wLen = lstrlen(szTemp);
    if (wLen < 3)
    {
        wDec = LODWORD(dw64 - (__int64)wInt * 1024L) * 1000 / 1024;
        // At this point, wDec should be between 0 and 1000
        // we want get the top one (or two) digits.
        wDec /= 10;
        if (wLen == 2)
            wDec /= 10;

        // Note that we need to set the format before getting the
        // intl char.
        lstrcpy(szFormat, TEXT("%02d"));

        szFormat[2] = (TCHAR)( TEXT('0') + 3 - wLen );
        GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL,
                szTemp+wLen, ARRAYSIZE(szTemp)-wLen);
        wLen = lstrlen(szTemp);
        wLen += wsprintf(szTemp+wLen, szFormat, wDec);
    }

AddOrder:
    LoadString(g_hInstance, pwOrders[i], szOrder, ARRAYSIZE(szOrder));
    wsprintf(szBuf, szOrder, (LPTSTR)szTemp);

    return S_OK;
}

/*
 * takes a DWORD add commas etc to it and puts the result in the buffer
 */

// NOTE: This code is cloned from MS source /shell/shelldll/util.c (and from \hsm\gui\inc\rsutil.cpp)

LPTSTR AddCommas(DWORD dw, LPTSTR pszResult, int nResLen)
{
    TCHAR  szTemp[20];  // more than enough for a DWORD
    TCHAR  szSep[5];
    NUMBERFMT nfmt;

    nfmt.NumDigits=0;
    nfmt.LeadingZero=0;
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szSep, ARRAYSIZE(szSep));
    nfmt.Grouping = _tcstol(szSep, NULL, 10);
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, ARRAYSIZE(szSep));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder= 0;

    wsprintf(szTemp, TEXT("%lu"), dw);

    if (GetNumberFormat(LOCALE_USER_DEFAULT, 0, szTemp, &nfmt, pszResult, nResLen) == 0)
        lstrcpy(pszResult, szTemp);

    return pszResult;
}

HRESULT 
FormatFileTime(
    IN FILETIME ft, 
    OUT WCHAR **ppTimeString
)
/*++

Routine Description:

    Fotmat a time given in GMT (system) time to a string

Arguments:

    ft              - The input time in FILETIME format
    ppTimeString    - Output buffer. Caller is expected to free using WsbFree in case of success

Return Value:

    S_OK            - If the time is formatted successfully

--*/
{
    HRESULT                     hr = S_OK;
    WCHAR*                      pTime = NULL;

    WsbTraceIn(OLESTR("FormatFileTime"), OLESTR(""));

    try {
        FILETIME        ftLocal;
        SYSTEMTIME      stLocal;

        WsbAffirm(0 != ppTimeString, E_INVALIDARG);
        *ppTimeString = NULL;

        // Translate to local time in SYSTEMTIME format
        WsbAffirmStatus(FileTimeToLocalFileTime(&ft, &ftLocal));
        WsbAffirmStatus(FileTimeToSystemTime(&ftLocal, &stLocal));

        // Find required buffer
        int nChars1 = GetDateFormat(LOCALE_SYSTEM_DEFAULT, 0, &stLocal, NULL, NULL, 0);
        int nChars2 = GetTimeFormat(LOCALE_SYSTEM_DEFAULT, 0, &stLocal, NULL, NULL, 0);
        pTime = (WCHAR *)WsbAlloc((nChars1+nChars2+1) * sizeof(WCHAR));
        WsbAffirm(0 != pTime, E_OUTOFMEMORY);

        // Create time string
        WsbAffirmStatus(GetDateFormat(LOCALE_SYSTEM_DEFAULT, 0, &stLocal, NULL, pTime, nChars1));
        pTime[nChars1-1] = L' ';
        WsbAffirmStatus(GetTimeFormat(LOCALE_SYSTEM_DEFAULT, 0, &stLocal, NULL, &(pTime[nChars1]), nChars2));

        *ppTimeString = pTime;
        
    } WsbCatchAndDo(hr,
        // Free in case of an error
        if (pTime) {
            WsbFree(pTime);
            pTime = NULL;
        }
    );

    WsbTraceOut(OLESTR("FormatFileTime"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}

HRESULT 
CliGetVolumeDisplayName(
    IN IUnknown *pResourceUnknown, 
    OUT WCHAR **ppDisplayName
)
/*++

Routine Description:

    Produce a display name for a volume

Arguments:

    pResourceUnknown    - The input Fsa Resource object
    ppDisplayName       - Output buffer. Caller is expected to free using WsbFree in case of success

Return Value:

    S_OK            - If the name is retrieved successfully

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CliGetVolumeDisplayName"), OLESTR(""));

    try {
        CComPtr<IFsaResource>   pResource;

        // Check and initialize parameters
        WsbAffirm(0 != ppDisplayName, E_INVALIDARG);
        *ppDisplayName = NULL;
        WsbAffirmHr(pResourceUnknown->QueryInterface(IID_IFsaResource, (void **)&pResource));

        // Prefer user friendly name
        //  If not exists, use label
        //  If no label, use constant
        CWsbStringPtr userName;
        WsbAffirmHr(pResource->GetUserFriendlyName(&userName, 0));

        if (userName.IsEqual(L"")) {
            userName.Free();
            WsbAffirmHr(pResource->GetName(&userName, 0));
            if (userName.IsEqual(L"")) {
                userName.Free();
                WsbAffirmHr(userName.LoadFromRsc(g_hInstance, IDS_UNLABELED_VOLUME));
            }
        } 

        *ppDisplayName = (WCHAR *)WsbAlloc((wcslen(userName) + 1) * sizeof(WCHAR));
        WsbAffirm(0 != *ppDisplayName, E_OUTOFMEMORY);
        wcscpy(*ppDisplayName, userName);
        
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CliGetVolumeDisplayName"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\cli\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\cli\clivol.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    clivol.cpp

Abstract:

    Implements CLI VOLUME sub-interface

Author:

    Ran Kalach          [rankala]         3-March-2000

Revision History:

--*/

#include "stdafx.h"
#include "HsmConn.h"
#include "fsa.h"
#include "job.h"

static GUID g_nullGuid = GUID_NULL;

// Internal utilities and classes for VOLUME interface
HRESULT SetResourceParams(IN IFsaResource *pResource, IN DWORD dwDfs, IN DWORD dwSize, IN DWORD dwAccess,
                          IN LPWSTR pRulePath, IN LPWSTR pRuleFileSpec, IN BOOL bInclude, IN BOOL bRecursive,
                          IN BOOL bSetDefaults);
HRESULT ShowResourceParams(IN IFsaResource *pResource, IN BOOL bDfs, IN BOOL bSize,
                           IN BOOL bAccess, IN BOOL bRules, IN BOOL bStatistics);
HRESULT FindAndDeleteRule(IN IFsaResource *pResource, IN LPWSTR pRulePath, IN LPWSTR pRuleFileSpec, IN BOOL bDelete);
HRESULT StartJob(IN IFsaResource *pResource, IN HSM_JOB_TYPE Job, IN BOOL bWait);
HRESULT CancelJob(IN IFsaResource *pResource, IN HSM_JOB_TYPE Job);
HRESULT QuickUnmanage(IN IFsaResource *pResource);
HRESULT CreateJobName(IN HSM_JOB_TYPE Job, IN IFsaResource *pResource, OUT WCHAR **pJobName);

#define CVOL_INVALID_INDEX      (-1)

class CVolumeEnum
{

// Constructors
public:
    CVolumeEnum(IN LPWSTR *pVolumes, IN DWORD dwNumberOfVolumes, IN BOOL bSkipUnavailable = TRUE);

// Public methods
public:
    HRESULT First(OUT IFsaResource **ppResource);
    HRESULT Next(OUT IFsaResource **ppResource);
    HRESULT ErrorVolume(OUT int *pIndex);

// Private data
protected:
    LPWSTR              *m_pVolumes;
    DWORD               m_dwNumberOfVolumes;

    // If * enumeration or not
    BOOL                m_bAllVols;

    CComPtr<IWsbEnum>   m_pEnumResources;

    // Used only when m_bAllVols == FALSE
    int                 m_nCurrent;
    BOOL                m_bInvalidVol;

    // Used only when m_bAllVols == TRUE
    BOOL                m_bSkipUnavailable;
};

inline
HRESULT CVolumeEnum::ErrorVolume(OUT int *pIndex)
{
    HRESULT     hr = S_FALSE;
    if (m_bInvalidVol) {
        // There was an error with last volume
        hr = S_OK;
    }

    *pIndex = m_nCurrent;

    return(hr);
}

//
// VOLUME inetrafce implementors
//

HRESULT
VolumeManage(
   IN LPWSTR *Volumes,
   IN DWORD  NumberOfVolumes,
   IN DWORD  Dfs,
   IN DWORD  Size,
   IN DWORD  Access,
   IN LPWSTR RulePath,
   IN LPWSTR RuleFileSpec,
   IN BOOL   Include,
   IN BOOL   Recursive
)
/*++

Routine Description:

    Sets volume(s) to be managed by HSM

Arguments:

    Volumes         - List of volumes to manage
    NumberOfVolumes - List size
    Dfs             - Desired free space
    Size            - Minimal size to manage
    Access          - Minimal not-accessed time (in days)
    RulePath        - Path for the rule
    RuleFileSpec    - File specification for the rule
    Include         - Is this an include or exclude rule
    Recursive       - Is the rule recursive or not

Return Value:

    S_OK            - If all the volumes are added to the managed list

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("VolumeManage"), OLESTR(""));

    try {
        CComPtr<IFsaResource> pResource;
        CWsbStringPtr   param;

        CComPtr<IHsmServer>             pHsm;
        CComPtr<IWsbCreateLocalObject>  pCreateObj;
        CComPtr<IWsbIndexedCollection>  pMRCollection;

        // Verify that input parameters are valid
        if (0 == NumberOfVolumes) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_VOLUMES, NULL);
            WsbThrow(E_INVALIDARG);
        }

        WsbAffirmHr(ValidateLimitsArg(Dfs, IDS_DFS, HSMADMIN_MIN_FREESPACE, HSMADMIN_MAX_FREESPACE));
        WsbAffirmHr(ValidateLimitsArg(Size, IDS_MIN_SIZE, HSMADMIN_MIN_MINSIZE, HSMADMIN_MAX_MINSIZE));
        WsbAffirmHr(ValidateLimitsArg(Access, IDS_NOT_ACCESSED, HSMADMIN_MIN_INACTIVITY, HSMADMIN_MAX_INACTIVITY));

        if (INVALID_POINTER_ARG != RuleFileSpec) {
            // Must have a rule path then
            if (INVALID_POINTER_ARG == RulePath) {
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_RULE, NULL);
                WsbThrow(E_INVALIDARG);
            }
        }

        // Get necessary objects
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));
        WsbAffirmHr(pHsm->QueryInterface(IID_IWsbCreateLocalObject, (void**) &pCreateObj));
        WsbAffirmHr(pHsm->GetManagedResources(&pMRCollection));

        // Initialize an enumerator object
        CVolumeEnum volEnum(Volumes, NumberOfVolumes);

        hr = volEnum.First(&pResource);
        if (WSB_E_NOTFOUND == hr) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_VOLUMES, NULL);
            WsbThrow(hr);
        } else if (S_OK != hr) {
            int index;
            if (S_OK == volEnum.ErrorVolume(&index)) {
                // Problem with a specific input volume
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
            }
            WsbThrow(hr);
        }

        while(S_OK == hr) {
            CComPtr<IHsmManagedResource>    pManagedResource;
            CComPtr<IHsmManagedResource>    pFoundResource;

            // Find out if the volume is the Engine's managed resources list, if not - add it
            WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmManagedResource, IID_IHsmManagedResource, (void**) &pManagedResource));
            WsbAffirmHr(pManagedResource->InitFromFsaResource(pResource));
            hr = pMRCollection->Find(pManagedResource, IID_IHsmManagedResource, (void**) &pFoundResource);
            if (WSB_E_NOTFOUND == hr) {
                // Add it
                WsbAffirmHr(pMRCollection->Add(pManagedResource));
            } else {
                // Verify no other error
                WsbAffirmHr(hr);

                // No other error: notify the user that parameters will still be set for the already managed volume
                CWsbStringPtr volName;
                WsbAffirmHr(CliGetVolumeDisplayName(pResource, &volName));
                WsbTraceAndPrint(CLI_MESSAGE_ONLY_SET, (WCHAR *)volName, NULL);
            }

            // Set the parameters (whether it was managed before or not)
            WsbAffirmHr(SetResourceParams(pResource, Dfs, Size, Access, RulePath, 
                            RuleFileSpec, Include, Recursive, TRUE));

            pManagedResource = 0;
            pFoundResource = 0;
            pResource = 0;
            hr = volEnum.Next(&pResource);
        }
        
        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        } else {
            int index;
            if (S_OK == volEnum.ErrorVolume(&index)) {
                // Problem with a specific input volume
                WsbAssert(CVOL_INVALID_INDEX != index, E_UNEXPECTED);
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
            }
            WsbThrow(hr);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("VolumeManage"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
VolumeUnmanage(
   IN LPWSTR *Volumes,
   IN DWORD  NumberOfVolumes,
   IN BOOL   Full
)
/*++

Routine Description:

    Unmanage volume(s)

Arguments:

    Volumes         - List of volumes to manage
    NumberOfVolumes - List size
    Full            - If TRUE, run unmanage job which recalls all the files back
                    - If FALSE, just remove volume from the managed volumes list.
  
Return Value:

    S_OK            - If all the volumes are unmanaged successfully

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("VolumeUnmanage"), OLESTR(""));

    try {
        CComPtr<IFsaResource> pResource;

        // Verify that input parameters are valid
        if (0 == NumberOfVolumes) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_VOLUMES, NULL);
            WsbThrow(E_INVALIDARG);
        }

        // Initialize an enumerator object
        // Eumerate also unavailable volumes
        CVolumeEnum volEnum(Volumes, NumberOfVolumes, FALSE);

        hr = volEnum.First(&pResource);
        if (WSB_E_NOTFOUND == hr) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_VOLUMES, NULL);
            WsbThrow(hr);
        } else if (S_OK != hr) {
            int index;
            if (S_OK == volEnum.ErrorVolume(&index)) {
                // Problem with a specific input volume
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
            }
            WsbThrow(hr);
        }

        while(S_OK == hr) {
            if (pResource->IsManaged() == S_OK) {
                BOOL bForceQuick = FALSE;

                // If it is an unavailable volume, must set a quick unmanage
                if (S_OK != pResource->IsAvailable()) {
                    bForceQuick = TRUE;
                }

                // Unmanage the volume 
                if (Full && (! bForceQuick)) {
                    WsbAffirmHr(StartJob(pResource, Unmanage, FALSE));
                } else {
                    WsbAffirmHr(QuickUnmanage(pResource));
                }
            } else {
                int index;
                volEnum.ErrorVolume(&index);
                if (CVOL_INVALID_INDEX != index) {
                    // invalid input from user
                    WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
                    WsbThrow(E_INVALIDARG);
                } else {
                    // just skip the volume...
                }
            }

            pResource = 0;
            hr = volEnum.Next(&pResource);
        }
        
        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        } else {
            int index;
            if (S_OK == volEnum.ErrorVolume(&index)) {
                // Problem with a specific input volume
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
            }
            WsbThrow(hr);
        }
    
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("VolumeUnmanage"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
VolumeSet(
   IN LPWSTR *Volumes,
   IN DWORD  NumberOfVolumes,
   IN DWORD  Dfs,
   IN DWORD  Size,
   IN DWORD  Access,
   IN LPWSTR RulePath,
   IN LPWSTR RuleFileSpec,
   IN BOOL   Include,
   IN BOOL   Recursive
)
/*++

Routine Description:

    Sets parameters for volume(s) which are already managed by HSM

Arguments:

    Volumes         - List of volumes to manage
    NumberOfVolumes - List size
    Dfs             - Desired free space
    Size            - Minimal size to manage
    Access          - Minimal not-accessed time (in days)
    RulePath        - Path for the rule
    RuleFileSpec    - File specification for the rule
    Include         - Is this an include or exclude rule
    Recursive       - Is the rule recursive or not

Return Value:

    S_OK            - If all the parameters are set for all the volumes

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("VolumeSet"), OLESTR(""));

    try {
        CComPtr<IFsaResource> pResource;
        CWsbStringPtr   param;

        // Verify that input parameters are valid
        if (0 == NumberOfVolumes) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_VOLUMES, NULL);
            WsbThrow(E_INVALIDARG);
        }

        WsbAffirmHr(ValidateLimitsArg(Dfs, IDS_DFS, HSMADMIN_MIN_FREESPACE, HSMADMIN_MAX_FREESPACE));
        WsbAffirmHr(ValidateLimitsArg(Size, IDS_MIN_SIZE, HSMADMIN_MIN_MINSIZE, HSMADMIN_MAX_MINSIZE));
        WsbAffirmHr(ValidateLimitsArg(Access, IDS_NOT_ACCESSED, HSMADMIN_MIN_INACTIVITY, HSMADMIN_MAX_INACTIVITY));

        if (INVALID_POINTER_ARG != RuleFileSpec) {
            // Must have a rule path then
            if (INVALID_POINTER_ARG == RulePath) {
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_RULE, NULL);
                WsbThrow(E_INVALIDARG);
            }
        }

        // Initialize an enumerator object
        CVolumeEnum volEnum(Volumes, NumberOfVolumes);

        hr = volEnum.First(&pResource);
        if (WSB_E_NOTFOUND == hr) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_VOLUMES, NULL);
            WsbThrow(hr);
        } else if (S_OK != hr) {
            int index;
            if (S_OK == volEnum.ErrorVolume(&index)) {
                // Problem with a specific input volume
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
            }
            WsbThrow(hr);
        }

        while(S_OK == hr) {
            // Set the parameters (only if the volume is managed)
            if (pResource->IsManaged() == S_OK) {
                WsbAffirmHr(SetResourceParams(pResource, Dfs, Size, Access, RulePath, 
                                RuleFileSpec, Include, Recursive, FALSE));
            } else {
                int index;
                volEnum.ErrorVolume(&index);
                if (CVOL_INVALID_INDEX != index) {
                    // invalid input from user
                    WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
                    WsbThrow(E_INVALIDARG);
                } else {
                    // just skip the volume...
                }
            }

            pResource = 0;
            hr = volEnum.Next(&pResource);
        }
        
        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        } else {
            int index;
            if (S_OK == volEnum.ErrorVolume(&index)) {
                // Problem with a specific input volume
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
            }
            WsbThrow(hr);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("VolumeSet"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
      
HRESULT
VolumeShow(
   IN LPWSTR *Volumes,
   IN DWORD  NumberOfVolumes,
   IN BOOL   Dfs, 
   IN BOOL   Size,
   IN BOOL   Access,
   IN BOOL   Rules,
   IN BOOL   Statistics
)
/*++

Routine Description:

    Shows (prints) parameters for the given volume(s)

Arguments:

    Volumes         - 
    NumberOfVolumes - 
    Dfs             -
    Size            -
    Access          -
    Rules           -
    Statistics      -

Return Value:

    S_OK            - If all the parameters could be retrieved for all volumes

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("VolumeShow"), OLESTR(""));

    try {
        CComPtr<IFsaResource> pResource;
        // Initialize an enumerator object
        CVolumeEnum volEnum(Volumes, NumberOfVolumes);

        hr = volEnum.First(&pResource);
        if (WSB_E_NOTFOUND == hr) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_VOLUMES, NULL);
            WsbThrow(hr);
        } else if (S_OK != hr) {
            int index;
            if (S_OK == volEnum.ErrorVolume(&index)) {
                // Problem with a specific input volume
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
            }
            WsbThrow(hr);
        }

        while(S_OK == hr) {
            // Show the parameters (only if the volume is managed)
            if (pResource->IsManaged() == S_OK) {
                // Show volume settings
                WsbAffirmHr(ShowResourceParams(pResource, Dfs, Size, Access, Rules, Statistics));
            } else {
                int index;
                volEnum.ErrorVolume(&index);
                if (CVOL_INVALID_INDEX != index) {
                    // invalid input from user
                    WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
                    WsbThrow(E_INVALIDARG);
                } else {
                    // just skip the volume...
                }
            }

            pResource = 0;
            hr = volEnum.Next(&pResource);
        }
        
        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        } else {
            int index;
            if (S_OK == volEnum.ErrorVolume(&index)) {
                // Problem with a specific input volume
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
            }
            WsbThrow(hr);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("VolumeShow"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
          
HRESULT
VolumeDeleteRule(
   IN LPWSTR *Volumes,
   IN DWORD  NumberOfVolumes,
   IN LPWSTR RulePath,
   IN LPWSTR RuleFileSpec
)
/*++

Routine Description:

    Deletes a specific rule from all of the given volumes

Arguments:

    Volumes         - 
    NumberOfVolumes - 
    RulePath        -
    RuleFileSpec    -

Return Value:

    S_OK            - If the rule is found and deleted successfully for all volumes

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("VolumeDeleteRule"), OLESTR(""));

    try {
        CComPtr<IFsaResource> pResource;

        // Verify that input parameters are valid
        if (0 == NumberOfVolumes) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_VOLUMES, NULL);
            WsbThrow(E_INVALIDARG);
        }

        if (INVALID_POINTER_ARG != RuleFileSpec) {
            // Must have a rule path then
            if (INVALID_POINTER_ARG == RulePath) {
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_RULE, NULL);
                WsbThrow(E_INVALIDARG);
            }
        }

        // Initialize an enumerator object
        CVolumeEnum volEnum(Volumes, NumberOfVolumes);

        hr = volEnum.First(&pResource);
        if (WSB_E_NOTFOUND == hr) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_VOLUMES, NULL);
            WsbThrow(hr);
        } else if (S_OK != hr) {
            int index;
            if (S_OK == volEnum.ErrorVolume(&index)) {
                // Problem with a specific input volume
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
            }
            WsbThrow(hr);
        }

        while(S_OK == hr) {
            // Delete rules only if the volume is managed
            if (pResource->IsManaged() == S_OK) {
                // Delete the rule
                hr = FindAndDeleteRule(pResource, RulePath, RuleFileSpec, TRUE);
                if (WSB_E_NOTFOUND == hr) {
                    CWsbStringPtr volName;
                    WsbAffirmHr(CliGetVolumeDisplayName(pResource, &volName));
                    WsbTraceAndPrint(CLI_MESSAGE_RULE_NOT_FOUND, RulePath, RuleFileSpec, (WCHAR *)volName, NULL);
                }
                WsbAffirmHr(hr);
            } else {
                int index;
                volEnum.ErrorVolume(&index);
                if (CVOL_INVALID_INDEX != index) {
                    // invalid input from user
                    WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
                    WsbThrow(E_INVALIDARG);
                } else {
                    // just skip the volume...
                }
            }

            pResource = 0;
            hr = volEnum.Next(&pResource);
        }
        
        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        } else {
            int index;
            if (S_OK == volEnum.ErrorVolume(&index)) {
                // Problem with a specific input volume
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
            }
            WsbThrow(hr);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("VolumeDeleteRule"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
          
HRESULT
VolumeJob(
   IN LPWSTR *Volumes,
   IN DWORD  NumberOfVolumes,
   IN HSM_JOB_TYPE Job,
   IN BOOL  RunOrCancel,
   IN BOOL  Synchronous
)
/*++

Routine Description:

    Runs the specified job on the given volume(s)

Arguments:

    Volumes         - 
    NumberOfVolumes - 
    Job             -
    RunOrCancel     -
    Synchronous     -

Return Value:

    S_OK            - If the job is started successfully for all volumes

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("VolumeJob"), OLESTR(""));

    try {
        CComPtr<IFsaResource> pResource;

        // Verify that input parameters are valid
        if (0 == NumberOfVolumes) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_VOLUMES, NULL);
            WsbThrow(E_INVALIDARG);
        }
        if ((! RunOrCancel) && Synchronous) {
            // Wait is available only with Run
            WsbTraceAndPrint(CLI_MESSAGE_WAIT_FOR_CANCEL, NULL);
            WsbThrow(E_INVALIDARG);
        }

        // Initialize an enumerator object
        CVolumeEnum volEnum(Volumes, NumberOfVolumes);

        hr = volEnum.First(&pResource);
        if (WSB_E_NOTFOUND == hr) {
            WsbTraceAndPrint(CLI_MESSAGE_NO_VOLUMES, NULL);
            WsbThrow(hr);
        } else if (S_OK != hr) {
            int index;
            if (S_OK == volEnum.ErrorVolume(&index)) {
                // Problem with a specific input volume
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
            }
            WsbThrow(hr);
        }

        while(S_OK == hr) {
            if (pResource->IsManaged() == S_OK) {
                // Run or Cancel a job 
                if (RunOrCancel) {
                    WsbAffirmHr(StartJob(pResource, Job, Synchronous));
                } else {
                    WsbAffirmHr(CancelJob(pResource, Job));
                }
            } else {
                int index;
                volEnum.ErrorVolume(&index);
                if (CVOL_INVALID_INDEX != index) {
                    // invalid input from user
                    WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
                    WsbThrow(E_INVALIDARG);
                } else {
                    // just skip the volume...
                }
            }

            pResource = 0;
            hr = volEnum.Next(&pResource);
        }
        
        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        } else {
            int index;
            if (S_OK == volEnum.ErrorVolume(&index)) {
                // Problem with a specific input volume
                WsbTraceAndPrint(CLI_MESSAGE_INVALID_VOLUME, Volumes[index], NULL);
            }
            WsbThrow(hr);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("VolumeJob"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

//
// Internal utilities
//
HRESULT SetResourceParams(IN IFsaResource *pResource, IN DWORD dwDfs, IN DWORD dwSize, IN DWORD dwAccess,
                          IN LPWSTR pRulePath, IN LPWSTR pRuleFileSpec, IN BOOL bInclude, IN BOOL bRecursive,
                          IN BOOL bSetDefaults)
/*++

Routine Description:

    Sets parameters for a specific volume

Arguments:

    pResourse       - A resource object to set parameters for
    ... (see above)

Return Value:

    S_OK            - If all the parameters are set succeessfully for the volume

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("SetResourceParams"), OLESTR(""));

    try {
        // DFS
        if (INVALID_DWORD_ARG != dwDfs) {
            WsbAffirmHr(pResource->SetHsmLevel((ULONG)(dwDfs * FSA_HSMLEVEL_1)));
        } else if (bSetDefaults) {
            dwDfs = HSMADMIN_DEFAULT_FREESPACE;
            WsbAffirmHr(pResource->SetHsmLevel((ULONG)(dwDfs * FSA_HSMLEVEL_1)));
        }

        // Min size
        if (INVALID_DWORD_ARG != dwSize) {
            WsbAffirmHr(pResource->SetManageableItemLogicalSize(dwSize * 1024));
        } else if (bSetDefaults) {
            dwSize = HSMADMIN_DEFAULT_MINSIZE;
            WsbAffirmHr(pResource->SetManageableItemLogicalSize(dwSize * 1024));
        }

        // Not Accessed
        if (INVALID_DWORD_ARG != dwAccess) {
            FILETIME ftAccess = WsbLLtoFT(((LONGLONG)dwAccess) * WSB_FT_TICKS_PER_DAY);
            WsbAffirmHr(pResource->SetManageableItemAccessTime(TRUE, ftAccess));
        } else if (bSetDefaults) {
            FILETIME ftAccess = WsbLLtoFT(((LONGLONG)HSMADMIN_DEFAULT_INACTIVITY) * WSB_FT_TICKS_PER_DAY);
            WsbAffirmHr(pResource->SetManageableItemAccessTime(TRUE, ftAccess));
        }

        // Rules
        if (INVALID_POINTER_ARG != pRulePath) {
            // Verify that Rule does not exist
            hr = FindAndDeleteRule(pResource, pRulePath, pRuleFileSpec, FALSE);
            if (S_OK == hr) {
                // Rule is already there - print a warning message and ignore it
                CWsbStringPtr volName;
                WsbAffirmHr(CliGetVolumeDisplayName(pResource, &volName));
                WsbTraceAndPrint(CLI_MESSAGE_RULE_ALREADY_EXIST, pRulePath, pRuleFileSpec, (WCHAR *)volName, NULL);
                pRulePath = INVALID_POINTER_ARG;
            }
            else if (WSB_E_NOTFOUND == hr) {
                // Rule is not there yet
                hr = S_OK;
            } else {
                // unexpected error - abort
                WsbAffirmHr(hr);
            }
        }

        if (INVALID_POINTER_ARG != pRulePath) {
            CComPtr<IFsaServer>             pFsa;
            CComPtr<IWsbCreateLocalObject>  pCreateObj;
            CComPtr<IWsbCollection>         pDefaultRules;
            CComPtr<IWsbIndexedCollection>  pRulesIndexedCollection;
            CComPtr<IHsmRule>               pRule;
            CComPtr<IWsbCollection>         pCriteriaCollection;
            CComPtr<IHsmCriteria>           pCriteria;

            // Get Fsa server for creating objects in Fsa scope
            WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_FSA, g_nullGuid, IID_IFsaServer, (void**)&pFsa));
            WsbAffirmHr(pFsa->QueryInterface(IID_IWsbCreateLocalObject, (void **)&pCreateObj));

            // get rules collection as an indexed collection
            WsbAffirmHr(pResource->GetDefaultRules(&pDefaultRules));
            WsbAffirmHr(pDefaultRules->QueryInterface (IID_IWsbIndexedCollection, (void **) &pRulesIndexedCollection));

            // Create a rule and set parameters
            WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmRule, IID_IHsmRule, (void**) &pRule));
            WsbAffirmHr(pRule->SetPath(pRulePath));
            if (INVALID_POINTER_ARG != pRuleFileSpec) {
                WsbAffirmHr(pRule->SetName(pRuleFileSpec));
            } else {
                WsbAffirmHr(pRule->SetName(OLESTR("*")));
            }
            WsbAffirmHr(pRule->SetIsInclude(bInclude));
            WsbAffirmHr(pRule->SetIsUsedInSubDirs(bRecursive));
            WsbAffirmHr(pRule->SetIsUserDefined(TRUE));

            // Set the criteria appropriately, depending on whether it is an include or exclude rule.
            WsbAssertHr(pRule->Criteria(&pCriteriaCollection));
    
            if (bInclude) {
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmCritManageable, IID_IHsmCriteria, (void**) &pCriteria));
            } else {
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmCritAlways, IID_IHsmCriteria, (void**) &pCriteria));
            }

            WsbAssertHr(pCriteria->SetIsNegated(FALSE));
            WsbAssertHr(pCriteriaCollection->Add(pCriteria));

            // Now that the rule has been set up properly, add it to the default rules collection.
            WsbAffirmHr(pRulesIndexedCollection->Append(pRule));            
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("SetResourceParams"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}

HRESULT ShowResourceParams(IN IFsaResource *pResource, IN BOOL bDfs, IN BOOL bSize,
                           IN BOOL bAccess, IN BOOL bRules, IN BOOL bStatistics)
/*++

Routine Description:

    Get and display parameters for a specific volume

Arguments:

    pResourse       - A resource object to get parameters for
    ... (see above)

Return Value:

    S_OK            - If all the parameters are retrieved succeessfully for the volume

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("ShowResourceParams"), OLESTR(""));

    try {
        CWsbStringPtr    volName;
        CWsbStringPtr    param, param2;
        WCHAR           longData[100];

        WsbAffirmHr(CliGetVolumeDisplayName(pResource, &volName));
        WsbTraceAndPrint(CLI_MESSAGE_VOLUME_PARAMS, (WCHAR *)volName, NULL);

        // Dfs
        if (bDfs) {
            ULONG       hsmLevel;

            WsbAffirmHr(pResource->GetHsmLevel(&hsmLevel));
            hsmLevel = hsmLevel / FSA_HSMLEVEL_1;
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_DFS));
            WsbAffirmHr(param2.LoadFromRsc(g_hInstance, IDS_PERCENT_SUFFIX));
            swprintf(longData, OLESTR("%lu"), hsmLevel);
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY2, (WCHAR *)param, longData, (WCHAR *)param2, NULL);
        }

        // Min size
        if (bSize) {
            LONGLONG    fileSize;
            ULONG       fileSizeKb;

            WsbAffirmHr(pResource->GetManageableItemLogicalSize(&fileSize));
            fileSizeKb = (ULONG)(fileSize / 1024);  // Show KBytes
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_MIN_SIZE));
            WsbAffirmHr(param2.LoadFromRsc(g_hInstance, IDS_KB_SUFFIX));
            swprintf(longData, OLESTR("%lu"), fileSizeKb);
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY2, (WCHAR *)param, longData, (WCHAR *)param2, NULL);
        }

        // Not accessed
        if (bAccess) {
            FILETIME    accessTime;
            ULONG       accessTimeDays;
            BOOL        dummy;

            WsbAffirmHr(pResource->GetManageableItemAccessTime(&dummy, &accessTime));
            accessTimeDays = (ULONG)(WsbFTtoLL(accessTime) / WSB_FT_TICKS_PER_DAY);
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_NOT_ACCESSED));
            WsbAffirmHr(param2.LoadFromRsc(g_hInstance, IDS_DAYS_SUFFIX));
            swprintf(longData, OLESTR("%lu"), accessTimeDays);
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY2, (WCHAR *)param, longData, (WCHAR *)param2, NULL);
        }

        //Statistics
        if (bStatistics) {
            LONGLONG    total;
            LONGLONG    free;
            LONGLONG    premigrated;
            LONGLONG    truncated;
            LONGLONG    hsmData;
            LONGLONG    notHsmData;

            WCHAR       pctData[10];
            int         freePct;
            int         premigratedPct;
            int         notHsmDataPct;

            // Get and calculate sizes
            WsbAffirmHr(pResource->GetSizes(&total, &free, &premigrated, &truncated));
            hsmData = premigrated + truncated;
            notHsmData = max((total - free - premigrated ), 0);
            freePct = (int)((free * 100) / total);
            premigratedPct = (int)((premigrated * 100) / total);
            notHsmDataPct = (int)((notHsmData * 100) / total);

            // Print statistics
            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_VOL_CAPACITY));
            WsbAffirmHr(ShortSizeFormat64(total, longData));
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, longData, NULL);

            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_VOL_FREE_SPACE));
            WsbAffirmHr(ShortSizeFormat64(free, longData));
            swprintf(pctData, OLESTR(" (%d%%%%)"), freePct);
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY2, (WCHAR *)param, longData, pctData, NULL);

            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_VOL_NOT_RSS_DATA));
            WsbAffirmHr(ShortSizeFormat64(notHsmData, longData));
            swprintf(pctData, OLESTR(" (%d%%%%)"), notHsmDataPct);
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY2, (WCHAR *)param, longData, pctData, NULL);

            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_VOL_CACHED_DATA));
            WsbAffirmHr(ShortSizeFormat64(premigrated, longData));
            swprintf(pctData, OLESTR(" (%d%%%%)"), premigratedPct);
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY2, (WCHAR *)param, longData, pctData, NULL);

            WsbAffirmHr(param.LoadFromRsc(g_hInstance, IDS_VOL_RSS_DATA));
            WsbAffirmHr(ShortSizeFormat64(hsmData, longData));
            WsbTraceAndPrint(CLI_MESSAGE_PARAM_DISPLAY, (WCHAR *)param, longData, NULL);
        }

        // Rules
        if (bRules) {
            CComPtr<IWsbCollection>         pDefaultRules;
            CComPtr<IWsbIndexedCollection>  pRulesIndexedCollection;
            CComPtr<IHsmRule>               pHsmRule;
            CWsbStringPtr                    rulePath;
            CWsbStringPtr                    ruleFileSpec;
            BOOL                            include;
            CWsbStringPtr                    includeStr;
            BOOL                            recursive;
            CWsbStringPtr                    recursiveStr;
            ULONG                           count;

            WsbTraceAndPrint(CLI_MESSAGE_RULES_LIST, NULL);

            // Get the rules collection
            WsbAffirmHr(pResource->GetDefaultRules(&pDefaultRules));
            WsbAffirmHr(pDefaultRules->QueryInterface(IID_IWsbIndexedCollection, (void **)&pRulesIndexedCollection));

            // Itterate through the indexed collection
            WsbAffirmHr(pRulesIndexedCollection->GetEntries(&count));
            for (int i = 0; i < (int) count; i++) {
                // Get rule and rule parameters
                WsbAffirmHr(pRulesIndexedCollection->At(i, IID_IHsmRule, (void**) &pHsmRule));
                WsbAffirmHr(pHsmRule->GetPath(&rulePath, 0));
                WsbAffirmHr(pHsmRule->GetName(&ruleFileSpec, 0));
                include = (S_OK == pHsmRule->IsInclude()) ? TRUE : FALSE;
                recursive = (S_OK == pHsmRule->IsUsedInSubDirs()) ? TRUE : FALSE;

                // Print rule
                if (include) {
                    WsbAffirmHr(includeStr.LoadFromRsc(g_hInstance, IDS_INCLUDE_RULE));
                } else {
                    WsbAffirmHr(includeStr.LoadFromRsc(g_hInstance, IDS_EXCLUDE_RULE));
                }
                if (recursive) {
                    WsbAffirmHr(recursiveStr.LoadFromRsc(g_hInstance, IDS_RECURSIVE_RULE));
                } else {
                    WsbAffirmHr(recursiveStr.LoadFromRsc(g_hInstance, IDS_NON_RECURSIVE_RULE));
                }
                WsbTraceAndPrint(CLI_MESSAGE_RULE_SPEC, (WCHAR *)rulePath, (WCHAR *)ruleFileSpec,
                                    (WCHAR *)includeStr, (WCHAR *)recursiveStr, NULL);

                // Free resources before next iteration
                pHsmRule = 0;
                rulePath.Free();
                ruleFileSpec.Free();
                includeStr.Free();
                recursiveStr.Free();
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("ShowResourceParams"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}

HRESULT FindAndDeleteRule(IN IFsaResource *pResource, IN LPWSTR pRulePath, IN LPWSTR pRuleFileSpec, IN BOOL bDelete)
/*++

Routine Description:

    Deletes a rule that match the given path & file specification from a specific volume
    If more than one exists, the first one found is deleted

Arguments:

    bDelete         - A flag of whether to delete or just find the rule
    pResourse       - A resource object to delete rule from
    ... (see above)

Return Value:

    S_OK            - If the rule is found and deleted (deleted only if bDelete is TRUE)
    WSB_E_NOTFOUND  - If the rule could not be found

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("DeleteRule"), OLESTR(""));

    try {
        CComPtr<IWsbCollection>         pDefaultRules;
        CComPtr<IWsbIndexedCollection>  pRulesIndexedCollection;
        CComPtr<IHsmRule>               pHsmRule;
        ULONG                           count;
        SHORT                           dummy;

        // Get the default rules collection
        WsbAffirmHr(pResource->GetDefaultRules(&pDefaultRules));
        WsbAffirmHr(pDefaultRules->QueryInterface(IID_IWsbIndexedCollection, (void **) &pRulesIndexedCollection));
        
        // Itterate through the indexed collection
        hr = WSB_E_NOTFOUND;
        WsbAffirmHr(pRulesIndexedCollection->GetEntries(&count));
        for (int i = 0; i < (int)count; i++) {
            WsbAffirmHr(pRulesIndexedCollection->At(i, IID_IHsmRule, (void**)&pHsmRule));
                        
            if (pHsmRule->CompareToPathAndName(pRulePath, pRuleFileSpec, &dummy) == S_OK) {
                if (bDelete) {
                    pHsmRule = 0;
                    WsbAffirmHr(pRulesIndexedCollection->RemoveAt(i, IID_IHsmRule, (void**) &pHsmRule));
                }
                hr = S_OK;
                break;
            }

            // Release before continuing loop
            pHsmRule = 0;
        }

        // If we got to the end of the for loop without a match, hr stays WSB_E_NOTFOUND

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("DeleteRule"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}

HRESULT QuickUnmanage(IN IFsaResource *pResource)
/*++

Routine Description:

    Remove a volume from the set of managed volumes

Arguments:

    pResourse       - A resource object to unmanage

Return Value:

    S_OK            - If the volume is removed from the list of managed volumes successfully

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("QuickUnmanage"), OLESTR(""));

    try {
        CComPtr<IHsmServer>             pHsm;
        CComPtr<IWsbCreateLocalObject>  pCreateObj;
        CComPtr<IHsmManagedResource>    pManagedResource;
        CComPtr<IWsbIndexedCollection>  pMRCollection;

        // Get Hsm (Engine) server
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));
        WsbAffirmHr(pHsm->QueryInterface(IID_IWsbCreateLocalObject, (void**) &pCreateObj));

        // Create an object to remove
        WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmManagedResource, IID_IHsmManagedResource, (void**) &pManagedResource));
        WsbAffirmHr(pManagedResource->InitFromFsaResource(pResource));

        // Remove from the collection
        WsbAffirmHr(pHsm->GetManagedResources(&pMRCollection));
        WsbAffirmHr(pMRCollection->RemoveAndRelease(pManagedResource));

        // TEMPORARY: Should we call now SaveServersPersistData to flush changes into
        //  servers persistency files ?! What about Manage, Set, ... ?

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("QuickUnmanage"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}

HRESULT StartJob(IN IFsaResource *pResource, IN HSM_JOB_TYPE Job, IN BOOL bWait)
/*++

Routine Description:

    Start a job of the specified type

Arguments:

    pResourse       - A resource object to start a job on
    Job             - The job type
    bWait           - If TRUE, wait until the job is done
                      If FALSE, return immediately after starting the job

Return Value:

    S_OK            - If the job is started successfully

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("StartJob"), OLESTR(""));

    try {
        CComPtr<IHsmServer>             pHsm;
        CComPtr<IHsmJob>                pJob;
        CWsbStringPtr                   jobName;
        HSM_JOB_DEF_TYPE                jobType;

        // Set job type
        switch (Job) {
            case CopyFiles:
                jobType = HSM_JOB_DEF_TYPE_MANAGE;
                break;
            case CreateFreeSpace:
                jobType = HSM_JOB_DEF_TYPE_TRUNCATE;
                break;
            case Validate:
                jobType = HSM_JOB_DEF_TYPE_VALIDATE;
                break;
            case Unmanage:
                jobType = HSM_JOB_DEF_TYPE_FULL_UNMANAGE;
                break;
            default:
                WsbThrow(E_INVALIDARG);
        }

        // Create job name
        // TEMPORARY: Should the job name and job object match those that are created by the GUI ?!
        //            If so, RsCreateJobName (rsadutil.cpp) + all the resource strings that it uses,
        //            should be moved from HsmAdmin DLL to RsCommon DLL
        WsbAffirmHr(CreateJobName(Job, pResource, &jobName));

        // If job exists - use it, otherwize, craete and add an appropriate job object
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));
        hr = pHsm->FindJobByName(jobName, &pJob);
        if (S_OK == hr) {
            // Job already exists

        } else if (WSB_E_NOTFOUND == hr) {
            // No such job yet
            CComPtr<IWsbCreateLocalObject>  pCreateObj;
            CComPtr<IWsbIndexedCollection>  pJobs;
            CComPtr<IWsbIndexedCollection>  pCollection;
            CComPtr<IHsmStoragePool>        pStoragePool;
            GUID                            poolId;
            ULONG                           count;

            hr = S_OK;
            pJob = 0;

            // Create and add the job
            WsbAffirmHr(pHsm->QueryInterface(IID_IWsbCreateLocalObject, (void**) &pCreateObj));
            WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmJob, IID_IHsmJob, (void**) &pJob));

            WsbAffirmHr(pHsm->GetStoragePools(&pCollection));
            WsbAffirmHr(pCollection->GetEntries(&count));
            WsbAffirm(1 == count, E_FAIL);
            WsbAffirmHr(pCollection->At(0, IID_IHsmStoragePool, (void **)&pStoragePool));
            WsbAffirmHr(pStoragePool->GetId(&poolId));

            WsbAffirmHr(pJob->InitAs(jobName, NULL, jobType, poolId, pHsm, TRUE, pResource));
            WsbAffirmHr(pHsm->GetJobs(&pJobs));
            WsbAffirmHr(pJobs->Add(pJob));

        } else {
            // Other error - abort
            WsbThrow(hr);
        }

        // Start the job
        WsbAffirmHr(pJob->Start());

        // Wait if required
        if (bWait) {
            WsbAffirmHr(pJob->WaitUntilDone());
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("StartJob"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}

HRESULT CancelJob(IN IFsaResource *pResource, IN HSM_JOB_TYPE Job)
/*++

Routine Description:

    Cancel a job on the volume

Arguments:

    pResourse       - A resource object to cancel a job for
    Job             - The job type

Return Value:

    S_OK            - If the job is canceled

Notes:
    
    1) The function just issue the cancellation, it does not wait for it to finish
    2) If the job is not found or not started, it is not considered as an error

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CancelJob"), OLESTR(""));

    try {
        CComPtr<IHsmServer>             pHsm;
        CComPtr<IHsmJob>                pJob;
        CWsbStringPtr                   jobName;
        HSM_JOB_DEF_TYPE                jobType;

        // Set job type
        switch (Job) {
            case CopyFiles:
                jobType = HSM_JOB_DEF_TYPE_MANAGE;
                break;
            case CreateFreeSpace:
                jobType = HSM_JOB_DEF_TYPE_TRUNCATE;
                break;
            case Validate:
                jobType = HSM_JOB_DEF_TYPE_VALIDATE;
                break;
            case Unmanage:
                jobType = HSM_JOB_DEF_TYPE_FULL_UNMANAGE;
                break;
            default:
                WsbThrow(E_INVALIDARG);
        }

        // Create job name
        WsbAffirmHr(CreateJobName(Job, pResource, &jobName));

        // If job exists, try to cancel it
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, g_nullGuid, IID_IHsmServer, (void**)&pHsm));
        hr = pHsm->FindJobByName(jobName, &pJob);
        if (S_OK == hr) {
            // Cancel (we don't care if it's actually running or not)
            WsbAffirmHr(pJob->Cancel(HSM_JOB_PHASE_ALL));

        } else if (WSB_E_NOTFOUND == hr) {
            // No such job, for sure it is not running...
            hr = S_OK;

        } else {
            // Other error - abort
            WsbThrow(hr);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CancelJob"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}

HRESULT
CreateJobName(IN HSM_JOB_TYPE Job, IN IFsaResource *pResource, OUT WCHAR **ppJobName)
/*++

Routine Description:

    Create a job name based on its type and the volume properties

Arguments:

    Job             - The job type
    pResource       - Fsa resource that the job is created for
    ppJobName       - The job name

Return Value:

    S_OK            - The job name is created successfully

Notes:

    This utility uses similar algorithm to RsCreateJobName (rsadutil.cpp).
    Howevere, since RsCreateJobName uses internal HsmAdmin resource strings, the final
    name might be different than the GUI name, especially in a localaized system.
    Therefore, I use here different strings for CLI jobs to ensure consistent behavior.

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CreateJobName"), OLESTR(""));

    try {
        CWsbStringPtr    jobPrefix;
        CWsbStringPtr    jobTypeString;
        CWsbStringPtr    volumeName;
        CWsbStringPtr    volumeString;

        // Type string
        switch (Job) {
            case CopyFiles:
                WsbAffirmHr(jobTypeString.LoadFromRsc(g_hInstance, IDS_JOB_MANAGE));
                break;
            case CreateFreeSpace:
                WsbAffirmHr(jobTypeString.LoadFromRsc(g_hInstance, IDS_JOB_TRUNCATE));
                break;
            case Validate:
                WsbAffirmHr(jobTypeString.LoadFromRsc(g_hInstance, IDS_JOB_VALIDATE));
                break;
            case Unmanage:
                WsbAffirmHr(jobTypeString.LoadFromRsc(g_hInstance, IDS_JOB_FULL_UNMANAGE));
                break;
            default:
                WsbThrow(E_INVALIDARG);
        }

        WsbAffirmHr(pResource->GetUserFriendlyName(&volumeName, 0));

        // For now, ignore the user-name if it's not a drive letter
        size_t nameLen = wcslen(volumeName);
        if ((nameLen != 3) || (volumeName[1] != L':')) {
            volumeName = L"";
        }

        if (volumeName.IsEqual(L"")) {
            // No drive letter - use the volume name and serial number instead
            ULONG           serial;
            CWsbStringPtr   name;

            WsbAffirmHr(pResource->GetName(&name, 0 ));
            WsbAffirmHr(pResource->GetSerial(&serial));

            if (name == L"" ) {
                // No name, no drive letter - just have serial number
                WsbAffirmHr(volumeString.Alloc(40));
                swprintf(volumeString, L"%8.8lx", serial);
            } else {
                // Use name and serial
                WsbAffirmHr(volumeString.Alloc(40 + wcslen(name)));
                swprintf(volumeString, L"%ls-%8.8lx", (WCHAR *)name, serial);
            }

        } else {
            // Use drive letter
            WsbAffirmHr(volumeString.Alloc(1));
            volumeString[0] = volumeName[0];
            volumeString[1] = L'\0';
        }

        // Create job name
        WsbAffirmHr(jobPrefix.LoadFromRsc(g_hInstance, IDS_JOB_NAME_PREFIX));
        int allocLen = wcslen(jobPrefix) + wcslen(jobTypeString) + wcslen(volumeString) + 40;
        WCHAR* tmpString = (WCHAR*)WsbRealloc(*ppJobName, allocLen * sizeof(WCHAR));
        WsbAffirm(0 != tmpString, E_OUTOFMEMORY);
        *ppJobName = tmpString;
        swprintf(*ppJobName, jobPrefix, (WCHAR *)jobTypeString, (WCHAR *)volumeString);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CreateJobName"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}

//
// Enumerator class methods
//

CVolumeEnum::CVolumeEnum(IN LPWSTR *pVolumes, IN DWORD dwNumberOfVolumes, IN BOOL bSkipUnavailable)
/*++

Routine Description:

    Constructor

Arguments:

    pVolumes            - Volumes to enumerate
    dwNumberOfVolumes   - Number of volumes

Return Value:

    None

Notes:
    There are two kinds of enumerations:
    1) If * is specified, the base for the enumeration is the FSA resource collection
       In that case, there could be no error in the input volumes themselves
    2) If a list of volumes is given, the base for the enumeration is this list. This is
       less efficient that using the FSA collection, but it keeps the order of volumes
       according to the input list. If a volume from the list is not valid, the invalid flag is set.

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CVolumeEnum::CVolumeEnum"), OLESTR(""));

    try {
        m_pVolumes = pVolumes; 
        m_dwNumberOfVolumes = dwNumberOfVolumes;

        m_nCurrent = CVOL_INVALID_INDEX;
        m_bInvalidVol = FALSE;
        m_bAllVols = FALSE;
        m_bSkipUnavailable = bSkipUnavailable;

        // Check mode of enumeration
        WsbAssert(m_dwNumberOfVolumes > 0, E_INVALIDARG);
        if ((1 == m_dwNumberOfVolumes) && (0 == wcscmp(m_pVolumes[0], CLI_ALL_STR))) {
            // * enumeration
            m_bAllVols = TRUE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CVolumeEnum::CVolumeEnum"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
}

HRESULT CVolumeEnum::First(OUT IFsaResource **ppResource)
/*++

Routine Description:

    Gets first volume

Arguments:

    ppResourse      - First resource to get

Return Value:

    S_OK            - If first volume is retrieved
    WSB_E_NOTFOUND  - If no more volumes to enumerate
    E_INVALIDARG    - If volume given by the user is not found
                      (Only on a non * enumeration, m_bInvalidVol is set)

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CVolumeEnum::First"), OLESTR(""));

    try {
        // Get FSA resources collection (only once during the object life time)
        if (!m_pEnumResources) {
            CComPtr<IFsaServer> pFsa;
            WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_FSA, g_nullGuid, IID_IFsaServer, (void**)&pFsa));

            WsbAffirmHr(pFsa->EnumResources(&m_pEnumResources));
        }

        if (m_bAllVols) {
            if (m_bSkipUnavailable) {
                // Get first volume, skip unavailable resources
                CComPtr<IFsaResource>   pFindResource;

                hr = m_pEnumResources->First(IID_IFsaResource, (void**)&pFindResource);
                while (S_OK == hr) {
                    if (S_OK == pFindResource->IsAvailable()) {
                        // Found one
                        *ppResource = pFindResource;
                        (*ppResource)->AddRef();
                        break;

                    } else {
                        // Skip it
                        pFindResource = 0;
                    }
                    hr = m_pEnumResources->Next(IID_IFsaResource, (void**)&pFindResource);
                }
                WsbAffirmHr(hr);

            } else {
                // Get first volume
                hr = m_pEnumResources->First(IID_IFsaResource, (void**)ppResource);
                WsbAffirmHr(hr);
            }

        } else {
            CWsbStringPtr           volName;
            CWsbStringPtr           findName;
            CComPtr<IFsaResource>   pFindResource;

            // Enumerate user collection and try to find it in FSA
            m_nCurrent = 0;
            if (m_nCurrent >= (int)m_dwNumberOfVolumes) {
                WsbThrow(WSB_E_NOTFOUND);
            }

            // Validate current name and add trailing backslash if missing
            volName = m_pVolumes[m_nCurrent];
            WsbAssert (NULL != (WCHAR *)volName, E_UNEXPECTED);
            int len = wcslen(volName);
            WsbAssert (0 != len, E_UNEXPECTED);
            if (volName[len-1] != L'\\') {
                volName.Append(OLESTR("\\"));
            }

            // Find it
            hr = m_pEnumResources->First(IID_IFsaResource, (void**)&pFindResource);
            while(S_OK == hr) {
                WsbAffirmHr(pFindResource->GetUserFriendlyName(&findName, 0));
                if (_wcsicmp(volName, findName) == 0) {
                    // Fount it !!
                    *ppResource = pFindResource;
                    (*ppResource)->AddRef();
                    break;
                }

                findName.Free();
                pFindResource = 0;
                hr = m_pEnumResources->Next(IID_IFsaResource, (void**)&pFindResource);
            }
         
            if (WSB_E_NOTFOUND == hr) {
                // Volume given by user not found
                m_bInvalidVol = TRUE;
                hr = E_INVALIDARG;
            }
            WsbAffirmHr(hr);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CVolumeEnum::First"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT CVolumeEnum::Next(OUT IFsaResource **ppResource)
/*++

Routine Description:

    Gets next volume

Arguments:

    ppResourse      - Next resource to get

Return Value:

    S_OK            - If next volume is retrieved
    WSB_E_NOTFOUND  - If no more volumes to enumerate
    E_INVALIDARG    - If volume given by the user is not found
                      (Only on a non * enumeration, m_bInvalidVol is set)

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CVolumeEnum::Next"), OLESTR(""));

    try {
        if (m_bAllVols) {
            if (m_bSkipUnavailable) {
                // Get next volume, skip unavailable resources
                CComPtr<IFsaResource>   pFindResource;

                hr = m_pEnumResources->Next(IID_IFsaResource, (void**)&pFindResource);
                while (S_OK == hr) {
                    if (S_OK == pFindResource->IsAvailable()) {
                        // Found one
                        *ppResource = pFindResource;
                        (*ppResource)->AddRef();
                        break;

                    } else {
                        // Skip it
                        pFindResource = 0;
                    }

                    hr = m_pEnumResources->Next(IID_IFsaResource, (void**)&pFindResource);
                }
                WsbAffirmHr(hr);

            } else {
                // Get next volume
                hr = m_pEnumResources->Next(IID_IFsaResource, (void**)ppResource);
                WsbAffirmHr(hr);
            }

        } else {
            CWsbStringPtr           volName;
            CWsbStringPtr           findName;
            CComPtr<IFsaResource>   pFindResource;

            // Enumerate user collection and try to find it in FSA
            m_nCurrent++;
            if (m_nCurrent >= (int)m_dwNumberOfVolumes) {
                WsbThrow(WSB_E_NOTFOUND);
            }

            // Validate current name and add trailing backslash if missing
            volName = m_pVolumes[m_nCurrent];
            WsbAssert (NULL != (WCHAR *)volName, E_UNEXPECTED);
            int len = wcslen(volName);
            WsbAssert (0 != len, E_UNEXPECTED);
            if (volName[len-1] != L'\\') {
                volName.Append(OLESTR("\\"));
            }

            // Find it
            hr = m_pEnumResources->First(IID_IFsaResource, (void**)&pFindResource);
            while(S_OK == hr) {
                WsbAffirmHr(pFindResource->GetUserFriendlyName(&findName, 0));
                if (_wcsicmp(volName, findName) == 0) {
                    // Fount it !!
                    *ppResource = pFindResource;
                    (*ppResource)->AddRef();
                    break;
                }

                findName.Free();
                pFindResource = 0;
                hr = m_pEnumResources->Next( IID_IFsaResource, (void**)&pFindResource );
            }
         
            if (WSB_E_NOTFOUND == hr) {
                // Volume given by user not found
                m_bInvalidVol = TRUE;
                hr = E_INVALIDARG;
            }
            WsbAffirmHr(hr);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CVolumeEnum::Next"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\cli\exe\makefile.inc ===
clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\cli\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cli.rc
//
#define IDS_PRODUCT_NAME                103
#define IDC_CURSOR1                     201

#define IDS_RECALL_LIMIT                1024
#define IDS_ADMIN_EXEMPT                1025
#define IDS_CONCURRENCY                 1026
#define IDS_MEDIA_COPIES                1027
#define IDS_HSM_VERSION                 1028
#define IDS_HSM_STATUS                  1029
#define IDS_NOF_CARTRIDGES              1030
#define IDS_NOF_MANAGEABLES             1031
#define IDS_NOF_MANAGED                 1032
#define IDS_REMOTE_DATA                 1033
#define IDS_BYTES_STR                   1034
#define IDS_CONCURRENCY_PRM             1035
#define IDS_MEDIA_COPIES_PRM            1036

#define IDS_DFS                         1056
#define IDS_MIN_SIZE                    1057
#define IDS_NOT_ACCESSED                1058
#define IDS_VOL_FREE_SPACE              1059
#define IDS_VOL_RSS_DATA                1060
#define IDS_VOL_CACHED_DATA             1061
#define IDS_VOL_NOT_RSS_DATA            1062
#define IDS_INCLUDE_RULE                1063
#define IDS_EXCLUDE_RULE                1064
#define IDS_RECURSIVE_RULE              1065
#define IDS_NON_RECURSIVE_RULE          1066
#define IDS_KB_SUFFIX                   1067
#define IDS_DAYS_SUFFIX                 1068
#define IDS_PERCENT_SUFFIX              1069
#define IDS_VOL_CAPACITY                1070
#define IDS_UNLABELED_VOLUME            1071

#define IDS_JOB_MANAGE                  1088
#define IDS_JOB_TRUNCATE                1089
#define IDS_JOB_VALIDATE                1090
#define IDS_JOB_FULL_UNMANAGE           1091
#define IDS_JOB_NAME_PREFIX             1082

#define IDS_CAR_STATUS_NORMAL           1104       
#define IDS_CAR_STATUS_READONLY         1105
#define IDS_CAR_STATUS_RECREATE         1106
#define IDS_CAR_STATUS_ERROR_RO         1107
#define IDS_CAR_STATUS_ERROR_RW         1108
#define IDS_CAR_STATUS_ERROR_INCOMPLETE 1109
#define IDS_CAR_STATUS_ERROR_MISSING    1110

#define IDS_MEDIA_COPY_SET              1120
#define IDS_MEDIA_STATUS                1121
#define IDS_MEDIA_CAPACITY              1122
#define IDS_MEDIA_FREE_SPACE            1123
#define IDS_MEDIA_RSM_NAME              1124
#define IDS_CAR_NAME_UNKNOWN            1125
#define IDS_MEDIA_VERSION               1126
#define IDS_MEDIA_COPY                  1127

#define IDS_BYTES                       1136
#define IDS_ORDERKB                     1137
#define IDS_ORDERMB                     1138
#define IDS_ORDERGB                     1139
#define IDS_ORDERTB                     1140
#define IDS_ORDERPB                     1141
#define IDS_ORDEREB                     1142

#define IDS_CAR_COPYSET_NONE            1152
#define IDS_CAR_COPYSET_INSYNC          1153
#define IDS_CAR_COPYSET_OUTSYNC         1154
#define IDS_CAR_COPYSET_ERROR           1155
#define IDS_CAR_COPYSET_MISSING         1156

#define IDS_SERVICE_STATUS_RUNNING          1178
#define IDS_SERVICE_STATUS_STOPPED          1179
#define IDS_SERVICE_STATUS_START_PENDING    1180
#define IDS_SERVICE_STATUS_STOP_PENDING     1181
#define IDS_SERVICE_STATUS_CONTINUE_PENDING 1182
#define IDS_SERVICE_STATUS_PAUSE_PENDING    1183
#define IDS_SERVICE_STATUS_PAUSED           1184
#define IDS_SERVICE_STATUS_NOT_SETUP        1185
#define IDS_SERVICE_STATUS_NOT_REGISTERED   1186



// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\cli\dll\makefile.inc ===
clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\cli\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
#ifndef _STDAFX_H
#define _STDAFX_H
//
// These NT header files must be included before any Win32 stuff or you
// get lots of compiler errors
//
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#define WSB_TRACE_IS        WSB_TRACE_BIT_UI // TEMPORARY: should be replaced with WSB_TRACE_BIT_CLI + required support in Wsb Trace
#include <wsb.h>
#include "cli.h"
#include "climsg.h"
#include "rslimits.h"
#include "resource.h"
#include "cliutils.h"

extern HINSTANCE    g_hInstance;

#endif // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\hsmeng\hsmcln.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmcln.cpp

Abstract:

    This component is an provides helper functions to access to the 
    collections maintained by the HSM engine.

Author:

    Cat Brant   [cbrant]   09-Jan-1997

Revision History:

--*/


#include "stdafx.h"
#include "wsb.h"
#include "HsmEng.h"
#include "HsmServ.h"
#include "HsmConn.h"
#include "job.h"
#include "metalib.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG

//  Local functions
static HRESULT LoadCollection(IStream* pStream, IWsbIndexedCollection* pIWC);
static HRESULT StoreCollection(IStream* pStream, IWsbIndexedCollection* pIWC);


HRESULT 
CHsmServer::LoadJobs(
    IStream* pStream
    ) 
/*++

Routine Description:

    Loads the persistent data for Jobs

Arguments:

    pStream  - Data stream.

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::LoadJobs"),OLESTR(""));

    try {
        WsbAffirmHr(LoadCollection(pStream, m_pJobs));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::LoadJobs"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CHsmServer::StoreJobs(
    IStream* pStream
    ) 
/*++

Routine Description:

  Saves the persistent data for Jobs.

Arguments:

    pStream  - Data stream.

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::StoreJobs"),OLESTR(""));
    //
    // Make sure we have a valid collection pointer
    //
    try {
        WsbAffirmHr(StoreCollection(pStream, m_pJobs));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::StoreJobs"),    OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CHsmServer::LoadJobDefs(
    IStream* pStream
    ) 
/*++

Routine Description:

    Loads the persistent data for Job Definitions

Arguments:

    pStream  - Data stream.

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::LoadJobDefs"),OLESTR(""));

    try {
        WsbAffirmHr(LoadCollection(pStream, m_pJobDefs));
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmServer::LoadJobDefs"),  OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CHsmServer::StoreJobDefs(
    IStream* pStream
    ) 
/*++

Routine Description:

  Saves the persistent data for Job Definitons

Arguments:

    pStream  - Data stream.

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::StoreJobDefs"),OLESTR(""));
    //
    try {
        WsbAffirmHr(StoreCollection(pStream, m_pJobDefs));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::StoreJobDefs"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CHsmServer::LoadPolicies(
    IStream* pStream
    ) 
/*++

Routine Description:

    Loads the persistent data for policies

Arguments:

    pStream  - Data stream.

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::LoadPolicies"),OLESTR(""));

    try {
        WsbAffirmHr(LoadCollection(pStream, m_pPolicies));
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmServer::LoadPolicies"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CHsmServer::StorePolicies(
    IStream* pStream
    ) 
/*++

Routine Description:

  Saves the persistent data for policies.

Arguments:

    pStream  - Data stream.

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::StorePolicies"),OLESTR(""));
    //
    // Make sure we have a valid collection pointer
    //
    try {
        WsbAffirmHr(StoreCollection(pStream, m_pPolicies));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::StorePolicies"),    OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CHsmServer::LoadManagedResources(
    IStream* pStream
    ) 
/*++

Routine Description:

    Loads the persistent data for managed resources

Arguments:

    pStream  - Data stream.

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::LoadManagedResources"),OLESTR(""));

    try {
        WsbAffirmHr(LoadCollection(pStream, m_pManagedResources));
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmServer::LoadManagedResources"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CHsmServer::StoreManagedResources(
    IStream* pStream
    ) 
/*++

Routine Description:

  Saves the persistent data for managed resources.

Arguments:

    pStream  - Data stream.

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::StoreManagedResources"),OLESTR(""));
    //
    // Make sure we have a valid collection pointer
    //
    try {
        WsbAffirmHr(StoreCollection(pStream, m_pManagedResources));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::StoreManagedResources"),    OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CHsmServer::LoadStoragePools(
    IStream* pStream
    ) 
/*++

Routine Description:

    Loads the persistent data for storage pools

Arguments:

    pStream  - Data stream.

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::LoadStoragePools"),OLESTR(""));

    try {
        WsbAffirmHr(LoadCollection(pStream, m_pStoragePools));
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmServer::LoadStoragePools"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CHsmServer::StoreStoragePools(
    IStream* pStream
    ) 
/*++

Routine Description:

  Saves the persistent data for managed resources.

Arguments:

    pStream  - Data stream.

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::StoreStoragePools"),OLESTR(""));
    //
    // Make sure we have a valid collection pointer
    //
    try {
        WsbAffirmHr(StoreCollection(pStream, m_pStoragePools));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::StoreStoragePools"),    OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CHsmServer::LoadSegmentInformation(
    void 
    ) 
/*++

Routine Description:

    Loads the persistent data for the segment information

Arguments:

    None

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    WsbTraceIn(OLESTR("CHsmServer::LoadSegmentInformation"),OLESTR(""));

    try {
        BOOL                CreateFlag = FALSE;
        CComPtr<ISegDb>     l_pSegmentDatabase;

        // Determine if we should try to create the DB or just open it.
        // If the persistence file was just created we're probably starting
        // for the first time so creating the DB is correct.  Also, if
        // the media count is still zero, then even if there was an old
        // DB that got deleted, it probably didn't have any useful information
        // in it anyway so creating a new one is OK.
        if (m_persistWasCreated || 0 == m_mediaCount) {
            CreateFlag = TRUE;
        }

        // Initialize the Engine database
        //
        WsbAffirmHr(CoCreateInstance( CLSID_CSegDb, 0, CLSCTX_SERVER, IID_ISegDb, (void **)&l_pSegmentDatabase ));
        WsbAffirmHr(GetIDbPath(&tmpString, 0));
        WsbAffirmHr(l_pSegmentDatabase->Initialize(tmpString, m_pDbSys, &CreateFlag));

        WsbAffirmHr(l_pSegmentDatabase->QueryInterface(IID_IWsbDb, (void**) &m_pSegmentDatabase));

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmServer::LoadSegmentInformation"),   OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CHsmServer::StoreSegmentInformation(
    void
    ) 
/*++

Routine Description:

  Saves the persistent data for the segment information.

Arguments:

  None

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT     hr = S_OK;
//  CWsbStringPtr   tmpString;

    WsbTraceIn(OLESTR("CHsmServer::StoreSegmentInformation"),OLESTR(""));
    //
    // Make sure we have a valid collection pointer
    //
    try {
        WsbAssert(m_pSegmentDatabase != 0, E_POINTER);
//  This should not be necessary for a real DB
//      WsbAffirmHr(m_pSegmentDatabase->Close());
//      WsbAffirmHr(m_pSegmentDatabase->Open());
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::StoreSegmentInformation"),  OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CHsmServer::StoreSegmentInformationFinal(
    void
    ) 
/*++

Routine Description:

  Saves the segment information

Arguments:

  None

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT     hr = S_OK;
    CWsbStringPtr   tmpString;

    WsbTraceIn(OLESTR("CHsmServer::StoreSegmentInformationFinal"),OLESTR(""));

    try {
        WsbAssert(m_pSegmentDatabase.p != 0, E_POINTER);
//  This should not be necessary for a real DB
//      WsbAffirmHr(m_pSegmentDatabase->Close());
        m_pSegmentDatabase = 0;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::StoreSegmentInformationFinal"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CHsmServer::LoadMessages(
    IStream* pStream
    ) 
/*++

Routine Description:

    Loads the persistent data for messages

Arguments:

    pStream  - Data stream.

Return Value:
  
    S_OK:  The collection was loaded OK.

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::LoadMessages"),OLESTR(""));

    try {
        WsbAffirmHr(LoadCollection(pStream, m_pMessages));
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmServer::LoadMessages"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CHsmServer::StoreMessages(
    IStream* pStream
    ) 
/*++

Routine Description:

  Saves the persistent data for messages.

Arguments:

    pStream  - Data stream.

Return Value:
  
    S_OK:  The collection was saved OK.

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::StoreMessages"),OLESTR(""));
    //
    // Make sure we have a valid collection pointer
    //
    try {
        WsbAffirmHr(StoreCollection(pStream, m_pMessages));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::StoreMessages"),    OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

//  LoadCollection - load a collection from the given stream
static HRESULT LoadCollection(IStream* pStream, IWsbIndexedCollection* pIWC)
{
    HRESULT     hr = S_OK;

    try {
        CComPtr<IPersistStream> pIStream;
        
        WsbAffirm(0 != pStream, E_POINTER);
        WsbAffirm(0 != pIWC, E_POINTER);
        
        //  Load the ordered collection from the persistent file
        WsbAffirmHr(pIWC->QueryInterface(IID_IPersistStream, (void**)&pIStream));
        WsbAffirmHr(pIStream->Load(pStream));
    } WsbCatch(hr);

    return(hr);
}

//  StoreCollection - store a collection to the given stream
static HRESULT StoreCollection(IStream* pStream, IWsbIndexedCollection* pIWC)
{
    HRESULT     hr = S_OK;

    try {
        CComPtr<IPersistStream> pIStream;
        
        // Get the IPersistStream interface for the collection
        WsbAffirm(0 != pStream, E_POINTER);
        WsbAffirm(0 != pIWC, E_POINTER);
        WsbAffirmHr(pIWC->QueryInterface(IID_IPersistStream, (void**)&pIStream));
        
        //  Store the ordered collection to the persistent file
        WsbAffirmHr(pIStream->Save(pStream, TRUE));
    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\hsmeng\hsmdeflt.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.


Module Name:

    hsmdeflt.cpp

Abstract:

    This component is an provides functions to access the HSM
    default settings.  These settings are maintained in the 
    NT system registry.

Author:

    Cat Brant   [cbrant]   13-Jan-1997

Revision History:

--*/


#include "stdafx.h"
#include "wsb.h"
#include "HsmEng.h"
#include "HsmServ.h"
#include "HsmConn.h"
#include "job.h"
#include "engine.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG

enum HSM_PARM_SETTING_VISIBILITY  {
     HSM_PARM_PERSISTANT =  1,    // Always seen in the registry 
     HSM_PARM_INVISIBLE  =  2     // Only written if different from the default 
};


HRESULT 
CHsmServer::CreateDefaultJobs(
    void
    ) 
/*++

Routine Description:

    Creates the default jobs and adds them to the engine's data base.

Arguments:

    None

Return Value:
  
    S_OK:  

--*/
{
    
    HRESULT                     hr = S_OK;
    CComPtr<IHsmJob>            pJob;
    CComPtr<IHsmStoragePool>    pStoragePool;
    GUID                        storagePoolId;

    WsbTraceIn(OLESTR("CHsmServer::CreateDefaultJobs"),OLESTR(""));

    try {

        // Currently the only default job is the manage job.
        if (FindJobByName(HSM_DEFAULT_MANAGE_JOB_NAME, &pJob) == WSB_E_NOTFOUND) {

            // The manage job needs a storage pool, so make sure that one exists.
            hr = m_pStoragePools->First(IID_IHsmStoragePool, (void**) &pStoragePool);

            if (hr == WSB_E_NOTFOUND) {
                WsbAffirmHr(CoCreateInstance(CLSID_CHsmStoragePool, 0, CLSCTX_ALL, IID_IHsmStoragePool, (void**) &pStoragePool));
                WsbAffirmHr(pStoragePool->SetMediaSet(GUID_NULL, OLESTR("Default")));
                WsbAssertHr(m_pStoragePools->Add(pStoragePool));
                //
                // Since we added one, save the data
                //
                WsbAffirmHr(SavePersistData());
                hr = S_OK;
            }
            
            WsbAffirmHr(hr);
            WsbAssertHr(pStoragePool->GetId(&storagePoolId));

            // Create a new job, configure it as a default manage job, and add it
            // to the job collection.
            WsbAffirmHr(CoCreateInstance(CLSID_CHsmJob, 0, CLSCTX_ALL, IID_IHsmJob, (void**) &pJob));
            WsbAffirmHr(pJob->InitAs(HSM_DEFAULT_MANAGE_JOB_NAME, 0, HSM_JOB_DEF_TYPE_MANAGE, storagePoolId, (IHsmServer*) this, FALSE, 0));
            WsbAffirmHr(m_pJobs->Add(pJob));
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::CreateDefaultJobs"),    OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CHsmServer::GetSavedTraceSettings(
    LONGLONG* pTraceSettings,
    BOOLEAN *pTraceOn
    ) 
/*++

Routine Description:

    Loads the settings for the HSM engine trace

Arguments:

    None

Return Value:
  
    S_OK:  The value was obtained

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::GetSavedTraceSettings"),OLESTR(""));

    try {
        DWORD   sizeGot;
        OLECHAR dataString[100];
        OLECHAR *stopString;
        //
        // Get the values
        //
        WsbAffirmHr(WsbGetRegistryValueString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_TRACE_SETTINGS,
                                            dataString, 100, &sizeGot));
        *pTraceSettings  = wcstoul( dataString,  &stopString, 10 );
        
        WsbAffirmHr(WsbGetRegistryValueString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_TRACE_ON,
                                            dataString, 100, &sizeGot));
        *pTraceOn  = (BOOLEAN) wcstoul( dataString,  &stopString, 10 );
        
        
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::GetSavedTraceSettings"),    OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CHsmServer::SetSavedTraceSettings(
    LONGLONG traceSettings,
    BOOLEAN traceOn
    ) 
/*++

Routine Description:

    Saves the settings for trace in the NT registry.

Arguments:

    None

Return Value:
  
    S_OK:  The value was obtained

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::SetSavedTraceSettings"),OLESTR(""));

    try {
        OLECHAR dataString[64];
        //
        // Save the Saved value
        //
        swprintf(dataString, OLESTR("%l64x"), traceSettings);
        WsbAffirmHr(WsbSetRegistryValueString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_TRACE_SETTINGS, 
                                            dataString));
        swprintf(dataString, OLESTR("%d"), traceOn);
        WsbAffirmHr(WsbSetRegistryValueString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_TRACE_ON, 
                                            dataString));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::SetSavedTraceSettings"),    OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\cluster\rsclustr\rsclustr.c ===
/*++

Copyright (c) 1999 Microsoft Corp.

Module Name:

    clusres.c

Abstract:

    Resource DLL for Remote Storage Server

Author:

   Ravisankar Pudipeddi (ravisp) 1 Sept 1999

Revision History:

--*/

#pragma comment(lib, "clusapi.lib")
#pragma comment(lib, "resutils.lib")

#define UNICODE 1

#include <windows.h>
#include <resapi.h>
#include <stdio.h>
#include "userenv.h"
#include "winsvc.h"
#include "aclapi.h"


#define LOG_CURRENT_MODULE LOG_MODULE_RSCLUSTER

#define SERVICES_ROOT L"SYSTEM\\CurrentControlSet\\Services\\"

#define DBG_PRINT printf

#pragma warning( disable : 4115 )  // named type definition in parentheses
#pragma warning( disable : 4201 )  // nonstandard extension used : nameless struct/union
#pragma warning( disable : 4214 )  // nonstandard extension used : bit field types other than int



#pragma warning( default : 4214 )  // nonstandard extension used : bit field types other than int
#pragma warning( default : 4201 )  // nonstandard extension used : nameless struct/union
#pragma warning( default : 4115 )  // named type definition in parentheses



//
// Type and constant definitions.
//

#define RSCLUSTER_RESNAME  L"Remote Storage Server"
#define RSCLUSTER_SVCNAME  TEXT("Remote_Storage_Server")

// Handle to service controller,  set by the first create resource call.

SC_HANDLE g_ScHandle = NULL;

typedef struct _RSCLUSTER_RESOURCE {
	RESID			ResId; // for validation
    HRESOURCE       hResource;
    SC_HANDLE       ServiceHandle;
    RESOURCE_HANDLE ResourceHandle;
    HKEY            ResourceKey;
    HKEY            ParametersKey;
    LPWSTR          ResourceName;
    CLUS_WORKER     PendingThread;
    BOOL            Online;
    CLUS_WORKER     OnlineThread;
    CLUSTER_RESOURCE_STATE  State;
    DWORD           dwServicePid;
    HANDLE          hSem;
} RSCLUSTER_RESOURCE, *PRSCLUSTER_RESOURCE;


//
// Global data.
//

// Event Logging routine.

PLOG_EVENT_ROUTINE g_LogEvent = NULL;

// Resource Status routine for pending Online and Offline calls.

PSET_RESOURCE_STATUS_ROUTINE g_SetResourceStatus = NULL;

// Forward reference to our RESAPI function table.

extern CLRES_FUNCTION_TABLE g_RSClusterFunctionTable;

//
// RSCluster resource read-write private properties.
//
RESUTIL_PROPERTY_ITEM
RSClusterResourcePrivateProperties[] = {
    { 0 }
};


//
// Function prototypes.
//

DWORD
WINAPI
Startup(
    IN LPCWSTR ResourceType,
    IN DWORD MinVersionSupported,
    IN DWORD MaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
    IN PLOG_EVENT_ROUTINE LogEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    );

RESID
WINAPI
RSClusterOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    );

VOID
WINAPI
RSClusterClose(
    IN RESID ResourceId
    );

DWORD
WINAPI
RSClusterOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE EventHandle
    );

DWORD
WINAPI
RSClusterOnlineThread(
    PCLUS_WORKER WorkerPtr,
    IN PRSCLUSTER_RESOURCE ResourceEntry
    );

DWORD
WINAPI
RSClusterOffline(
    IN RESID ResourceId
    );

DWORD
RSClusterOfflineThread(
    PCLUS_WORKER pWorker,
    IN PRSCLUSTER_RESOURCE ResourceEntry
    );


VOID
WINAPI
RSClusterTerminate(
    IN RESID ResourceId
    );

DWORD
RSClusterDoTerminate(
    IN PRSCLUSTER_RESOURCE ResourceEntry
    );

BOOL
WINAPI
RSClusterLooksAlive(
    IN RESID ResourceId
    );

BOOL
WINAPI
RSClusterIsAlive(
    IN RESID ResourceId
    );

BOOL
RSClusterCheckIsAlive(
    IN PRSCLUSTER_RESOURCE ResourceEntry
    );

DWORD
WINAPI
RSClusterResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );


BOOLEAN
WINAPI
DllMain(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )

/*++

Routine Description:

    Main DLL entry point.

Arguments:

    DllHandle - DLL instance handle.

    Reason - Reason for being called.

    Reserved - Reserved argument.

Return Value:

    TRUE - Success.

    FALSE - Failure.

--*/

{
    switch( Reason ) {

    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls( DllHandle );
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return(TRUE);

} // DllMain



DWORD
WINAPI
Startup(
    IN LPCWSTR ResourceType,
    IN DWORD MinVersionSupported,
    IN DWORD MaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
    IN PLOG_EVENT_ROUTINE LogEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    )

/*++

Routine Description:

    Startup the resource DLL. This routine verifies that at least one
    currently supported version of the resource DLL is between
    MinVersionSupported and MaxVersionSupported. If not, then the resource
    DLL should return ERROR_REVISION_MISMATCH.

    If more than one version of the resource DLL interface is supported by
    the resource DLL, then the highest version (up to MaxVersionSupported)
    should be returned as the resource DLL's interface. If the returned
    version is not within range, then startup fails.

    The ResourceType is passed in so that if the resource DLL supports more
    than one ResourceType, it can pass back the correct function table
    associated with the ResourceType.

Arguments:

    ResourceType - The type of resource requesting a function table.

    MinVersionSupported - The minimum resource DLL interface version 
        supported by the cluster software.

    MaxVersionSupported - The maximum resource DLL interface version
        supported by the cluster software.

    SetResourceStatus - Pointer to a routine that the resource DLL should 
        call to update the state of a resource after the Online or Offline 
        routine returns a status of ERROR_IO_PENDING.

    LogEvent - Pointer to a routine that handles the reporting of events 
        from the resource DLL. 

    FunctionTable - Returns a pointer to the function table defined for the
        version of the resource DLL interface returned by the resource DLL.

Return Value:

    ERROR_SUCCESS - The operation was successful.

    ERROR_MOD_NOT_FOUND - The resource type is unknown by this DLL.

    ERROR_REVISION_MISMATCH - The version of the cluster service doesn't
        match the versrion of the DLL.

    Win32 error code - The operation failed.

--*/

{
    if ( (MinVersionSupported > CLRES_VERSION_V1_00) ||
         (MaxVersionSupported < CLRES_VERSION_V1_00) ) {
        return(ERROR_REVISION_MISMATCH);
    }

    if ( lstrcmpiW( ResourceType, RSCLUSTER_RESNAME ) != 0 ) {
        return(ERROR_MOD_NOT_FOUND);
    }
    if ( !g_LogEvent ) {
        g_LogEvent = LogEvent;
        g_SetResourceStatus = SetResourceStatus;
    }

    *FunctionTable = &g_RSClusterFunctionTable;

    return(ERROR_SUCCESS);

} // Startup


RESID
WINAPI
RSClusterOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Open routine for RSCluster resources.

    Open the specified resource (create an instance of the resource). 
    Allocate all structures necessary to bring the specified resource 
    online.

Arguments:

    ResourceName - Supplies the name of the resource to open.

    ResourceKey - Supplies handle to the resource's cluster configuration 
        database key.

    ResourceHandle - A handle that is passed back to the resource monitor 
        when the SetResourceStatus or LogEvent method is called. See the 
        description of the SetResourceStatus and LogEvent methods on the
        RSClusterStatup routine. This handle should never be closed or used
        for any purpose other than passing it as an argument back to the
        Resource Monitor in the SetResourceStatus or LogEvent callback.

Return Value:

    RESID of created resource.

    NULL on failure.

--*/

{
    DWORD               status;
    DWORD               disposition;
    RESID               resid = 0;
    HKEY                parametersKey = NULL;

// how many do I need actually??
    HKEY    resKey = NULL;
    PRSCLUSTER_RESOURCE resourceEntry = NULL;
    HCLUSTER hCluster;

    // Semaphore security
    PSID pSystemSID = NULL;
    PSID pAdminSID = NULL;
    PACL pACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
#define     CLUSTER_SEMAPHORE_NUM_ACE      2
    EXPLICIT_ACCESS ea[CLUSTER_SEMAPHORE_NUM_ACE];
    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
    SECURITY_ATTRIBUTES sa;


    //
    // Open the Parameters registry key for this resource.
    //

    status = ClusterRegCreateKey( ResourceKey,
                                  L"Parameters",
                                  0,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &parametersKey,
                                  &disposition );

    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open Parameters key. Error: %1!u!.\n",
            status );
        goto exit;
    }


    status = ClusterRegOpenKey( ResourceKey,
                                L"",
                                KEY_READ,
                                &resKey);
    if (status != ERROR_SUCCESS) {
        (g_LogEvent)(ResourceHandle,
                     LOG_ERROR,
                     L"Unable to open resource key. Error: %1!u!.\n",
                     status );
        goto error_exit;
    }

    if ( g_ScHandle == NULL ) {

        g_ScHandle = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS);

        if ( g_ScHandle == NULL ) {
            status = GetLastError();
            (g_LogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"Failed to open service control manager, error %1!u!.\n",
                status);
            goto error_exit;
        }
    }


	resourceEntry = LocalAlloc( LMEM_FIXED, sizeof(RSCLUSTER_RESOURCE) );


    if ( resourceEntry == NULL ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to allocate resource entry structure. Error: %1!u!.\n",
            status );
        goto exit;
    }

	ZeroMemory( resourceEntry, sizeof(RSCLUSTER_RESOURCE) );
	
    resourceEntry->ResId = (RESID)resourceEntry; // for validation
    resourceEntry->ResourceHandle = ResourceHandle;
    resourceEntry->ParametersKey = parametersKey;
    resourceEntry->State = ClusterResourceOffline;

	resourceEntry->ResourceKey = resKey;
	resourceEntry->hSem= NULL;

    resourceEntry->ResourceName = LocalAlloc( LMEM_FIXED, (lstrlenW( ResourceName ) + 1) * sizeof(WCHAR) );
    if ( resourceEntry->ResourceName == NULL ) {
        goto exit;
    }
    lstrcpyW( resourceEntry->ResourceName, ResourceName );

    //
    // Create SD that allows access only to local-system and admin
    //
    memset(ea, 0, sizeof(EXPLICIT_ACCESS) * CLUSTER_SEMAPHORE_NUM_ACE);

    if (! AllocateAndInitializeSid( &SIDAuthNT, 2,
                         SECURITY_BUILTIN_DOMAIN_RID,
                         DOMAIN_ALIAS_RID_ADMINS,
                         0, 0, 0, 0, 0, 0,
                         &pAdminSID) ) {
        status = GetLastError();
        goto error_exit;
    }
    ea[0].grfAccessPermissions = FILE_ALL_ACCESS;
    ea[0].grfAccessMode = SET_ACCESS;
    ea[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea[0].Trustee.pMultipleTrustee = NULL;
    ea[0].Trustee.MultipleTrusteeOperation  = NO_MULTIPLE_TRUSTEE;
    ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ea[0].Trustee.ptstrName  = (LPTSTR) pAdminSID;

    if (! AllocateAndInitializeSid( &SIDAuthNT, 1,
                         SECURITY_LOCAL_SYSTEM_RID,
                         0, 0, 0, 0, 0, 0, 0,
                         &pSystemSID) ) {
        status = GetLastError();
        goto error_exit;
    }
    ea[1].grfAccessPermissions = FILE_ALL_ACCESS;
    ea[1].grfAccessMode = SET_ACCESS;
    ea[1].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea[1].Trustee.pMultipleTrustee = NULL;
    ea[1].Trustee.MultipleTrusteeOperation  = NO_MULTIPLE_TRUSTEE;
    ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[1].Trustee.TrusteeType = TRUSTEE_IS_USER;
    ea[1].Trustee.ptstrName  = (LPTSTR) pSystemSID;

    if ((status = SetEntriesInAcl(CLUSTER_SEMAPHORE_NUM_ACE, ea, NULL, &pACL)) != ERROR_SUCCESS) {
        goto error_exit;
    }

    pSD = (PSECURITY_DESCRIPTOR)LocalAlloc( LMEM_FIXED, SECURITY_DESCRIPTOR_MIN_LENGTH); 
    if (! pSD) {
        status = ERROR_OUTOFMEMORY;
        goto error_exit;
    }
    if (! InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION)) {
        status = GetLastError();
        goto error_exit;
    }

    if (! SetSecurityDescriptorDacl(
                        pSD, 
                        TRUE,     // fDaclPresent flag   
                        pACL, 
                        FALSE   // not a default DACL 
                        ) )   {
        status = GetLastError();
        goto error_exit;
    }

    sa.nLength = sizeof (SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = pSD;
    sa.bInheritHandle = FALSE;

    resourceEntry->hSem=CreateSemaphore(&sa,0,1,L"RemoteStorageServer"); 
    status=GetLastError();
    if(resourceEntry->hSem)
    {
        if(status==ERROR_ALREADY_EXISTS)
        {
            (g_LogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"Remote Storage is controlled by another resource. Error: %2!u!.\n",status );
            CloseHandle(resourceEntry->hSem);
            resourceEntry->hSem = NULL;
            goto error_exit;
        }  
    }
    else
    {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to create semaphore for Remote Storage Server Service  . Error: %2!u!.\n",status );
        goto error_exit;
    }    
    
    status = ERROR_SUCCESS;

    hCluster = OpenCluster(NULL);
    if (hCluster == NULL) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to open cluster, error %1!u!.",
            status );
        goto error_exit;
    }

    resourceEntry->hResource = OpenClusterResource(hCluster, ResourceName);
    status = GetLastError();
    CloseCluster(hCluster);
    if ( resourceEntry->hResource == NULL ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to open resource, error %1!u!.", status );
        goto error_exit;
    }

    resid = (RESID)resourceEntry;

error_exit:
exit:

    if ( resid == 0 ) {
        if ( parametersKey != NULL ) {
            ClusterRegCloseKey( parametersKey );
        }
        if ( resourceEntry != NULL ) {
            LocalFree( resourceEntry->ResourceName );
            LocalFree( resourceEntry );
        }
    }

    if (pAdminSID) {
        FreeSid(pAdminSID);
    }
    if (pSystemSID) {
        FreeSid(pSystemSID);
    }
    if (pACL) {
        LocalFree(pACL);
    }
    if (pSD) {
        LocalFree(pSD);
    }

    if ( status != ERROR_SUCCESS ) {
        SetLastError( status );
    }

    return(resid);

} // RSClusterOpen



VOID
WINAPI
RSClusterClose(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Close routine for RSCluster resources.

    Close the specified resource and deallocate all structures, etc.,
    allocated in the Open call. If the resource is not in the offline state,
    then the resource should be taken offline (by calling Terminate) before
    the close operation is performed.

Arguments:

    ResourceId - Supplies the RESID of the resource to close.

Return Value:

    None.

--*/

{
	
	PRSCLUSTER_RESOURCE resourceEntry;

    resourceEntry = (PRSCLUSTER_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "RSCluster: Close request for a nonexistent resource id %p\n",
                   ResourceId );
        return;
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Close resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return;
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Close request.\n" );
#endif


    if ( resourceEntry->ParametersKey ) {
        ClusterRegCloseKey( resourceEntry->ParametersKey );
    }


    RSClusterTerminate( ResourceId );
    ClusterRegCloseKey( resourceEntry->ParametersKey );
    ClusterRegCloseKey( resourceEntry->ResourceKey );
    CloseClusterResource( resourceEntry->hResource );
    CloseHandle(resourceEntry->hSem);


    LocalFree( resourceEntry->ResourceName );
    LocalFree( resourceEntry );

} // RSClusterClose



DWORD
WINAPI
RSClusterOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for RSCluster resources.

    Bring the specified resource online (available for use). The resource
    DLL should attempt to arbitrate for the resource if it is present on a
    shared medium, like a shared SCSI bus.

Arguments:

    ResourceId - Supplies the resource id for the resource to be brought 
        online (available for use).

    EventHandle - Returns a signalable handle that is signaled when the 
        resource DLL detects a failure on the resource. This argument is 
        NULL on input, and the resource DLL returns NULL if asynchronous 
        notification of failures is not supported, otherwise this must be 
        the address of a handle that is signaled on resource failures.

Return Value:

    ERROR_SUCCESS - The operation was successful, and the resource is now 
        online.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_RESOURCE_NOT_AVAILABLE - If the resource was arbitrated with some 
        other systems and one of the other systems won the arbitration.

    ERROR_IO_PENDING - The request is pending, a thread has been activated 
        to process the online request. The thread that is processing the 
        online request will periodically report status by calling the 
        SetResourceStatus callback method, until the resource is placed into 
        the ClusterResourceOnline state (or the resource monitor decides to 
        timeout the online request and Terminate the resource. This pending 
        timeout value is settable and has a default value of 3 minutes.).

    Win32 error code - The operation failed.

--*/

{

    DWORD               status;
    PRSCLUSTER_RESOURCE resourceEntry;

    resourceEntry = (PRSCLUSTER_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "RSCluster: Online request for a nonexistent resource id %p.\n",
                   ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online service sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Online request.\n" );
#endif

    resourceEntry->State = ClusterResourceOffline;
    ClusWorkerTerminate( &resourceEntry->OnlineThread );
    status = ClusWorkerCreate( &resourceEntry->OnlineThread,
                               (PWORKER_START_ROUTINE)RSClusterOnlineThread,
                               resourceEntry );
    if ( status != ERROR_SUCCESS ) {
        resourceEntry->State = ClusterResourceFailed;
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online: Unable to start thread, status %1!u!.\n",
            status
            );
    } else {
        status = ERROR_IO_PENDING;
    }

    return(status);

} // RSClusterOnline



DWORD
WINAPI
RSClusterOnlineThread(
    PCLUS_WORKER WorkerPtr,
    IN PRSCLUSTER_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Worker function which brings a resource from the resource table online.
    This function is executed in a separate thread.

Arguments:

    WorkerPtr - Supplies the worker structure

    ResourceEntry - A pointer to the RSCLUSTER_RESOURCE block for this resource.

Returns:

    ERROR_SUCCESS - The operation completed successfully.
    
    Win32 error code - The operation failed.

--*/

{

    SERVICE_STATUS_PROCESS      ServiceStatus;
    LPWSTR *                    serviceArgArray = NULL;
    DWORD                       serviceArgCount = 0;
    DWORD                       valueSize;
    LPVOID                      Environment = NULL;
    WCHAR *                     p;
    LPSERVICE_FAILURE_ACTIONS   pSvcFailureActions = NULL;
    DWORD                       cbBytesNeeded, i;
    LPQUERY_SERVICE_CONFIG      lpquerysvcconfig=NULL;
    HANDLE                      processToken = NULL;




    RESOURCE_STATUS     resourceStatus;
    DWORD               status = ERROR_SUCCESS;

    ResUtilInitializeResourceStatus( &resourceStatus );

    resourceStatus.ResourceState = ClusterResourceFailed;
    // resourceStatus.WaitHint = 0;
    resourceStatus.CheckPoint = 1;

    ResourceEntry->dwServicePid = 0;


    ResourceEntry->ServiceHandle = OpenService( g_ScHandle,
                                                RSCLUSTER_SVCNAME,
                                                SERVICE_ALL_ACCESS );

    if ( ResourceEntry->ServiceHandle == NULL ) {
        status = GetLastError();

        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Failed to open service, error = %1!u!.\n",
            status );
        goto error_exit;
    }

    valueSize = sizeof(QUERY_SERVICE_CONFIG);
AllocSvcConfig:
    lpquerysvcconfig=(LPQUERY_SERVICE_CONFIG)LocalAlloc(LMEM_FIXED, valueSize);
    if(lpquerysvcconfig==NULL){
        status = GetLastError();
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Remote Storage Server: Failed to allocate memory for query_service_config, error = %1!u!.\n",
            status );
        goto error_exit;
    }

    if (!QueryServiceConfig(ResourceEntry->ServiceHandle,
                            lpquerysvcconfig,
                            valueSize,
                            &cbBytesNeeded))
    {
        status=GetLastError();
        if (status != ERROR_INSUFFICIENT_BUFFER){
            (g_LogEvent)(ResourceEntry->ResourceHandle,
                         LOG_ERROR,
                         L"Remote Storage Server: Failed to query service configuration, error= %1!u!.\n",
                         status );
            goto error_exit;
        }

        status=ERROR_SUCCESS; 
        LocalFree(lpquerysvcconfig);
        lpquerysvcconfig=NULL;
        valueSize = cbBytesNeeded;
        goto AllocSvcConfig;
    }

    if (lpquerysvcconfig->dwStartType == SERVICE_DISABLED)
    {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
           LOG_ERROR,
           L"Remote Storage Server: the service is DISABLED\n");    
        status=ERROR_SERVICE_DISABLED;
        goto error_exit;
    }

    ChangeServiceConfig( ResourceEntry->ServiceHandle,
                         SERVICE_NO_CHANGE,
                         SERVICE_DEMAND_START, // Manual start
                         SERVICE_NO_CHANGE,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL );

    if (!(QueryServiceConfig2(ResourceEntry->ServiceHandle, SERVICE_CONFIG_FAILURE_ACTIONS,
        (LPBYTE)&valueSize, sizeof(DWORD), &cbBytesNeeded)))
    {
        status = GetLastError();
        if (status != ERROR_INSUFFICIENT_BUFFER)
        {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Remote Storage Server: Failed to query service configuration for size, error= %1!u!.\n",
                status );
            goto error_exit;
        }
        else
            status = ERROR_SUCCESS;
    }

    pSvcFailureActions = (LPSERVICE_FAILURE_ACTIONS)LocalAlloc(LMEM_FIXED, cbBytesNeeded);

    if ( pSvcFailureActions == NULL ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Remote Storage Server: Failed to allocate memory, error = %1!u!.\n",
            status );
        goto error_exit;
    }

    if (!(QueryServiceConfig2(ResourceEntry->ServiceHandle, SERVICE_CONFIG_FAILURE_ACTIONS,
        (LPBYTE)pSvcFailureActions, cbBytesNeeded, &cbBytesNeeded)))
    {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Remote Storage Server: Failed to query service configuration, error = %1!u!.\n",
            status );
        goto error_exit;
    }

    for (i=0; i<pSvcFailureActions->cActions;i++)
    {
        if (pSvcFailureActions->lpsaActions[i].Type == SC_ACTION_RESTART)
            pSvcFailureActions->lpsaActions[i].Type = SC_ACTION_NONE;
    }

    ChangeServiceConfig2(ResourceEntry->ServiceHandle,
                         SERVICE_CONFIG_FAILURE_ACTIONS,
                         pSvcFailureActions);

    if ( 0 ) 
    {
        Environment = ResUtilGetEnvironmentWithNetName( ResourceEntry->hResource );
    }
    else        
    {
        BOOL success;

        OpenProcessToken( GetCurrentProcess(), MAXIMUM_ALLOWED, &processToken );

        success = CreateEnvironmentBlock(&Environment, processToken, FALSE );
        if ( processToken != NULL ) {
            CloseHandle( processToken );
        }

        if ( !success ) {
            status = GetLastError();
            goto error_exit;
        }
    }

    if (Environment != NULL) {
        HKEY ServicesKey;
        HKEY hKey;

        p = (WCHAR *)Environment;
        while (*p) {
            while (*p++) {
            }
        }
        valueSize = (DWORD)((PUCHAR)p - (PUCHAR)Environment) + 
                    sizeof(WCHAR);

        status = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                                SERVICES_ROOT,
                                0,
                                KEY_READ,
                                &ServicesKey );
        if (status != ERROR_SUCCESS) {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Failed to open services key, error = %1!u!.\n",
                status );
            goto error_exit;
        }

        status = RegOpenKeyExW( ServicesKey,
                                RSCLUSTER_SVCNAME,
                                0,
                                KEY_READ | KEY_WRITE,
                                &hKey );
        RegCloseKey(ServicesKey);
        if (status != ERROR_SUCCESS) {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Failed to open service key, error = %1!u!.\n",
                status );
            goto error_exit;
        }

        status = RegSetValueExW( hKey,
                                 L"Environment",
                                 0,
                                 REG_MULTI_SZ,
                                 Environment,
                                 valueSize );
        RegCloseKey(hKey);
        if (status != ERROR_SUCCESS) {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Failed to set service environment value, error = %1!u!.\n",
                status );
            goto error_exit;
        }
    }

    if ( !StartServiceW( ResourceEntry->ServiceHandle,
                         serviceArgCount,
                         serviceArgArray ) )
    {
        status = GetLastError();

        if (status != ERROR_SERVICE_ALREADY_RUNNING) {

            (g_LogEvent)(ResourceEntry->ResourceHandle,
                         LOG_ERROR,
                         L"Failed to start service. Error: %1!u!.\n",
                         status );
            status = ERROR_SERVICE_NEVER_STARTED;
            goto error_exit;
        }
		
		// add code to stop the service that is running 
		// and start the service again..

    }

    while (!ClusWorkerCheckTerminate(WorkerPtr))  {


		if (!QueryServiceStatusEx(
				ResourceEntry->ServiceHandle,
                SC_STATUS_PROCESS_INFO, (LPBYTE)&ServiceStatus, 
                sizeof(SERVICE_STATUS_PROCESS), &cbBytesNeeded ) )
        {
            status = GetLastError();

            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Query Service Status failed %1!u!.\n",
                status );

            goto error_exit;
        }

        if ( ServiceStatus.dwCurrentState != SERVICE_START_PENDING ) {
            break;
        }

        Sleep(250);
    }

    if (ClusWorkerCheckTerminate(WorkerPtr))  {
        goto error_exit;
    }

    if ( ServiceStatus.dwCurrentState != SERVICE_RUNNING ) {


        (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Failed to start service. Error: %1!u!.\n",
                ERROR_SERVICE_NEVER_STARTED );

        status = ERROR_SERVICE_NEVER_STARTED;
        goto error_exit;
    }

    resourceStatus.ResourceState = ClusterResourceOnline;
    if (!(ServiceStatus.dwServiceFlags & SERVICE_RUNS_IN_SYSTEM_PROCESS)) {
        ResourceEntry->dwServicePid = ServiceStatus.dwProcessId;
    }

    (g_LogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Service is now on line.\n" );

error_exit:
    (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                           &resourceStatus );

    if ( resourceStatus.ResourceState == ClusterResourceOnline ) {
        ResourceEntry->Online = TRUE;
    } else {
        ResourceEntry->Online = FALSE;
    }
	
	// more setting here to ensure no problems
	ResourceEntry->State = resourceStatus.ResourceState;


    //cleanup
    if (pSvcFailureActions) 
        LocalFree(pSvcFailureActions);
    if (lpquerysvcconfig)
        LocalFree(lpquerysvcconfig);
    LocalFree( serviceArgArray );
    if (Environment != NULL) {
        DestroyEnvironmentBlock(Environment);
    }

    return(status);


} // RSClusterOnlineThread



DWORD
WINAPI
RSClusterOffline(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Offline routine for RSCluster resources.

    Take the specified resource offline gracefully (unavailable for use).  
    Wait for any cleanup operations to complete before returning.

Arguments:

    ResourceId - Supplies the resource id for the resource to be shutdown 
        gracefully.

Return Value:

    ERROR_SUCCESS - The request completed successfully and the resource is 
        offline.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_IO_PENDING - The request is still pending, a thread has been 
        activated to process the offline request. The thread that is 
        processing the offline will periodically report status by calling 
        the SetResourceStatus callback method, until the resource is placed 
        into the ClusterResourceOffline state (or the resource monitor decides 
        to timeout the offline request and Terminate the resource).
    
    Win32 error code - Will cause the resource monitor to log an event and 
        call the Terminate routine.

--*/

{

	// extra code here
	DWORD status;
	PRSCLUSTER_RESOURCE resourceEntry;


    resourceEntry = (PRSCLUSTER_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "RSCluster: Offline request for a nonexistent resource id %p\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Offline resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Offline request.\n" );
#endif


	
	ClusWorkerTerminate( &resourceEntry->PendingThread );
    status = ClusWorkerCreate( &resourceEntry->PendingThread,
                               (PWORKER_START_ROUTINE)RSClusterOfflineThread,
                               resourceEntry );

    if ( status == ERROR_SUCCESS ) {
        status = ERROR_IO_PENDING;
    }

    return(status);



} // RSClusterOffline


DWORD
RSClusterOfflineThread(
    PCLUS_WORKER pWorker,
    IN PRSCLUSTER_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Brings remote storage service resource offline

Arguments:

    Worker - Supplies the worker structure

    Context - A pointer to the DiskInfo block for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/
{
    RESOURCE_STATUS resourceStatus;
    DWORD           retryTick = 300;      // 300 msec at a time
    DWORD           status = ERROR_SUCCESS;
    BOOL            didStop = FALSE;
    SERVICE_STATUS  ServiceStatus;

    ResUtilInitializeResourceStatus( &resourceStatus );
    resourceStatus.ResourceState = ClusterResourceFailed;
    //resourceStatus.WaitHint = 0;
    resourceStatus.CheckPoint = 1;

    if ( ResourceEntry->ServiceHandle == NULL )
    {
        resourceStatus.ResourceState = ClusterResourceOffline;
        goto FnExit;
    }

    while (!ClusWorkerCheckTerminate(pWorker)) {


        status = (ControlService(
                        ResourceEntry->ServiceHandle,
                        (didStop
                         ? SERVICE_CONTROL_INTERROGATE
                         : SERVICE_CONTROL_STOP),
                        &ServiceStatus )
                  ? NO_ERROR
                  : GetLastError());

        if (status == NO_ERROR) {

            didStop = TRUE;

            if (ServiceStatus.dwCurrentState == SERVICE_STOPPED) {

                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Service stopped.\n" );

                //set the status                                    
                ResourceEntry->Online = FALSE;
                resourceStatus.ResourceState = ClusterResourceOffline;
                CloseServiceHandle( ResourceEntry->ServiceHandle );
                ResourceEntry->ServiceHandle = NULL;
                ResourceEntry->dwServicePid = 0;
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Service is now offline.\n" );
                break;
            }
        }

        if (status == ERROR_EXCEPTION_IN_SERVICE ||
            status == ERROR_PROCESS_ABORTED ||
            status == ERROR_SERVICE_NOT_ACTIVE) {

            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Service died or not active any more; status = %1!u!.\n",
                status);
                
            ResourceEntry->Online = FALSE;
            resourceStatus.ResourceState = ClusterResourceOffline;
            CloseServiceHandle( ResourceEntry->ServiceHandle );
            ResourceEntry->ServiceHandle = NULL;
            ResourceEntry->dwServicePid = 0;
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Service is now offline.\n" );
            break;

        }

        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"Offline: retrying...\n" );

        Sleep(retryTick);
    }


FnExit:
    (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                           &resourceStatus );

    return(status);

} // RSClusterOfflineThread






VOID
WINAPI
RSClusterTerminate(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Terminate routine for RSCluster resources.

    Take the specified resource offline immediately (the resource is
    unavailable for use).

Arguments:

    ResourceId - Supplies the resource id for the resource to be brought 
        offline.

Return Value:

    None.

--*/

{
// extra code here

    PRSCLUSTER_RESOURCE resourceEntry;

    resourceEntry = (PRSCLUSTER_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "RSCluster: Terminate request for a nonexistent resource id %p\n",
            ResourceId );
        return;
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Terminate resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return;
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Terminate request.\n" );
#endif

    RSClusterDoTerminate( resourceEntry );
    resourceEntry->State = ClusterResourceOffline;

} // RSClusterTerminate



DWORD
RSClusterDoTerminate(
    IN PRSCLUSTER_RESOURCE resourceEntry
    )

/*++

Routine Description:

    Do the actual Terminate work for RSCluster resources.

Arguments:

    ResourceEntry - Supplies resource entry for resource to be terminated

Return Value:

    ERROR_SUCCESS - The request completed successfully and the resource is 
        offline.

    Win32 error code - Will cause the resource monitor to log an event and 
        call the Terminate routine.

--*/

{
    DWORD       status = ERROR_SUCCESS;
	SERVICE_STATUS ServiceStatus;
    ClusWorkerTerminate( &resourceEntry->OnlineThread );


    ClusWorkerTerminate( &resourceEntry->PendingThread );

    if ( resourceEntry->ServiceHandle != NULL ) 
    {
        DWORD   dwRetryCount= 100;
        BOOL    didStop = FALSE;
        DWORD   dwRetryTick = 300;      // 300 msec at a time
        DWORD   dwStatus;  

            
        while (dwRetryCount--)
        {

            (g_LogEvent)(
                resourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"RSClusterTerminate : calling SCM\n" );

            dwStatus = (ControlService(
                            resourceEntry->ServiceHandle,
                            (didStop
                             ? SERVICE_CONTROL_INTERROGATE
                             : SERVICE_CONTROL_STOP),
                            &ServiceStatus )
                      ? NO_ERROR
                      : GetLastError());

            if (dwStatus == NO_ERROR) 
            {
                didStop = TRUE;
                if (ServiceStatus.dwCurrentState == SERVICE_STOPPED)
                {

                    (g_LogEvent)(
                        resourceEntry->ResourceHandle,
                        LOG_INFORMATION,
                        L"Service stopped.\n" );

                    //set the status                                    
                    resourceEntry->Online = FALSE;
                    resourceEntry->dwServicePid = 0;
                    break;
                }
            }

            if (dwStatus == ERROR_EXCEPTION_IN_SERVICE ||
                dwStatus == ERROR_PROCESS_ABORTED ||
                dwStatus == ERROR_SERVICE_NOT_ACTIVE) 
            {
                (g_LogEvent)(
                    resourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Service died; status = %1!u!.\n",
                    dwStatus);
                
                //set the status                                    
                resourceEntry->Online = FALSE;
                resourceEntry->dwServicePid = 0;
                break;
            }

            (g_LogEvent)(
                resourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"RSClusterTerminate: retrying...\n" );

            Sleep(dwRetryTick);

        }

        
		if (resourceEntry->dwServicePid)
        {
            HANDLE hSvcProcess = NULL;
            
            hSvcProcess = OpenProcess(PROCESS_TERMINATE, 
                FALSE, resourceEntry->dwServicePid);
            if (hSvcProcess)
            {
                (g_LogEvent)(
                    resourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"RSClusterTerminate: terminating processid=%1!u!\n",
                    resourceEntry->dwServicePid);
                TerminateProcess(hSvcProcess, 0);
                CloseHandle(hSvcProcess);
            }
        }                
        CloseServiceHandle( resourceEntry->ServiceHandle );
        resourceEntry->ServiceHandle = NULL;
        resourceEntry->dwServicePid = 0;
    }        
    resourceEntry->Online = FALSE;

// // 
	resourceEntry->State = ClusterResourceOffline;
/* 
    if ( status == ERROR_SUCCESS ) {
        ResourceEntry->State = ClusterResourceOffline;
    }

	return(status);
*/
    return(ERROR_SUCCESS);

} // RSClusterDoTerminate



BOOL
WINAPI
RSClusterLooksAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    LooksAlive routine for RSCluster resources.

    Perform a quick check to determine if the specified resource is probably
    online (available for use).  This call should not block for more than
    300 ms, preferably less than 50 ms.

Arguments:

    ResourceId - Supplies the resource id for the resource to polled.

Return Value:

    TRUE - The specified resource is probably online and available for use.

    FALSE - The specified resource is not functioning normally.

--*/

{
    PRSCLUSTER_RESOURCE  resourceEntry;

    resourceEntry = (PRSCLUSTER_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT("RSCluster: LooksAlive request for a nonexistent resource id %p\n",
            ResourceId );
        return(FALSE);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"LooksAlive sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(FALSE);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"LooksAlive request.\n" );
#endif

    //
    return(RSClusterCheckIsAlive( resourceEntry ));

} // RSClusterLooksAlive



BOOL
WINAPI
RSClusterIsAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    IsAlive routine for RSCluster resources.

    Perform a thorough check to determine if the specified resource is online
    (available for use). This call should not block for more than 400 ms,
    preferably less than 100 ms.

Arguments:

    ResourceId - Supplies the resource id for the resource to polled.

Return Value:

    TRUE - The specified resource is online and functioning normally.

    FALSE - The specified resource is not functioning normally.

--*/

{
    PRSCLUSTER_RESOURCE  resourceEntry;

    resourceEntry = (PRSCLUSTER_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT("RSCluster: IsAlive request for a nonexistent resource id %p\n",
            ResourceId );
        return(FALSE);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"IsAlive sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(FALSE);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"IsAlive request.\n" );
#endif

    return(RSClusterCheckIsAlive( resourceEntry ));

} // RSClusterIsAlive



BOOL
RSClusterCheckIsAlive(
    IN PRSCLUSTER_RESOURCE resourceEntry
    )

/*++

Routine Description:

    Check to see if the resource is alive for RSCluster resources.

Arguments:

    ResourceEntry - Supplies the resource entry for the resource to polled.

Return Value:

    TRUE - The specified resource is online and functioning normally.

    FALSE - The specified resource is not functioning normally.

--*/

{

	SERVICE_STATUS ServiceStatus;
	DWORD status = TRUE;

    if ( !QueryServiceStatus( resourceEntry->ServiceHandle,
                              &ServiceStatus ) ) {

         (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Query Service Status failed %1!u!.\n",
            GetLastError() );
         return(FALSE);
    }



    if ( (ServiceStatus.dwCurrentState != SERVICE_RUNNING) &&
         (ServiceStatus.dwCurrentState != SERVICE_START_PENDING) ) {
        status = FALSE;
    }

    if (!status) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Failed the IsAlive test. Current State is %1!u!.\n",
            ServiceStatus.dwCurrentState );
    }

    return(status);

} // RSClusterCheckIsAlive



DWORD
WINAPI
RSClusterResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for RSCluster resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    PRSCLUSTER_RESOURCE  resourceEntry;

    resourceEntry = (PRSCLUSTER_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT("RSCluster: ResourceControl request for a nonexistent resource id %p\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"ResourceControl sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // RSClusterResourceControl


//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE( g_RSClusterFunctionTable,     // Name
                         CLRES_VERSION_V1_00,         // Version
                         RSCluster,                    // Prefix
                         NULL,                        // Arbitrate
                         NULL,                        // Release
                         RSClusterResourceControl,     // ResControl
                         NULL);                       // ResTypeControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\hsmeng\hsmmgdrc.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmmgdrc.cpp

Abstract:

    Implementation of CHsmManagedResourceCollection

Author:

    Cat Brant   [cbrant]   24-Jan-1997

Revision History:

--*/

#include "stdafx.h"

#include "resource.h"
#include "wsb.h"
#include "HsmEng.h"
#include "hsmserv.h"
#include "hsmmgdrc.h"
#include "fsa.h"
#include "hsmconn.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG



HRESULT
CHsmManagedResourceCollection::Add(
    IUnknown* pCollectable
    )

/*++

Implements:

  IWsbCollection::Add

--*/
{
    HRESULT     hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmManagedResourceCollection::Add"), OLESTR(""));
    try {
        CComPtr<IHsmManagedResource> pHsmResource;
        CComPtr<IUnknown> pResourceUnknown;
        CComPtr<IFsaResource> pFsaResource;
        CComPtr<IHsmServer> pHsmServer;
        
        GUID     hsmId;
        ULONG    level;

        // 
        // Contact the FSA Resource to tell it
        // that it is managed.
        //
        WsbAffirmHr(pCollectable->QueryInterface(IID_IHsmManagedResource, 
                (void**)&pHsmResource));
        WsbAffirmHr(pHsmResource->GetFsaResource(&pResourceUnknown));
        WsbAffirmHr(pResourceUnknown->QueryInterface(IID_IFsaResource, 
                (void**)&pFsaResource));
        WsbAffirmHr(pFsaResource->GetHsmLevel(&level));        

        // this may have to change if HsmConn starts using the service id (second parameter)
        WsbAssertHr(HsmConnectFromId(HSMCONN_TYPE_HSM, GUID_NULL, IID_IHsmServer, (void**) &pHsmServer));

        WsbAffirmHr(pHsmServer->GetID(&hsmId));
        WsbAffirmHr(pFsaResource->ManagedBy(hsmId, level, FALSE));
        
        // 
        // If FSA added OK add it to the engine
        //
        WsbAffirmHr(m_icoll->Add(pCollectable));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResourceCollection::Add"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmManagedResourceCollection::DeleteAllAndRelease(
    void
    )

/*++

Implements:

  IWsbCollection::DeleteAllAndRelease().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmManagedResourceCollection::DeleteAllAndRelease"), OLESTR(""));

    Lock();
    try {

        //  Release the resources without unmanaging them
        if (m_coll) {
            WsbAffirmHr(m_coll->RemoveAllAndRelease());
        }

    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CHsmManagedResourceCollection::DeleteAllAndRelease"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmManagedResourceCollection::Remove(
    IUnknown* pCollectable,
    REFIID riid, 
    void** ppElement
    )

/*++

Implements:

  IWsbCollection::Remove

--*/
{
    HRESULT     hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmManagedResourceCollection::Remove"), OLESTR(""));
    try {
        CComPtr<IHsmManagedResource> pHsmResource;
        CComPtr<IUnknown> pResourceUnknown;
        CComPtr<IFsaResource> pFsaResource;
        CComPtr<IHsmServer> pHsmServer;
        
        GUID     hsmId;
        ULONG    level;

        // Contact the FSA Resource to tell it that it is no longer 
        // managed.
        //
        WsbAffirmHr(pCollectable->QueryInterface(IID_IHsmManagedResource, 
                (void**)&pHsmResource));
        WsbAffirmHr(pHsmResource->GetFsaResource(&pResourceUnknown));
        WsbAffirmHr(pResourceUnknown->QueryInterface(IID_IFsaResource, 
                (void**)&pFsaResource));
        WsbAffirmHr(pFsaResource->GetHsmLevel(&level));        
        
        // this may have to change if HsmConn starts using the service id (second parameter)
        WsbAssertHr(HsmConnectFromId(HSMCONN_TYPE_HSM, GUID_NULL, IID_IHsmServer, (void**) &pHsmServer));

        WsbAffirmHr(pHsmServer->GetID(&hsmId));
        
        //
        // We don't care if the resource complains that we
        // don't have it.  Just tell the resource and
        // then delete it from our collection
        //
        (void)pFsaResource->ManagedBy(hsmId, level, TRUE);
        
        WsbAffirmHr(m_icoll->Remove(pCollectable, riid, ppElement));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResourceCollection::Remove"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CHsmManagedResourceCollection::RemoveAndRelease(
    IN IUnknown* pCollectable
    )

/*++

Implements:

  IHsmManagedResourceCollection::RemoveAndRelease().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmManagedResourceCollection::RemoveAndRelease"), OLESTR(""));

    try {
        WsbAssert(0 != pCollectable, E_POINTER);
        WsbAffirmHr(Remove(pCollectable,  IID_IWsbCollectable, NULL));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResourceCollection::RemoveAndRelease"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmManagedResourceCollection::RemoveAllAndRelease(
    void
    )

/*++

Implements:

  IWsbCollection::RemoveAllAndRelease().

--*/
{
    CComPtr<IWsbCollectable>    pCollectable;
    CComPtr<IWsbEnum>           pEnum;
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmManagedResourceCollection::RemoveAllAndRelease"), OLESTR(""));

    Lock();
    try {

        // Get an enumerator
        WsbAffirmHr(Enum(&pEnum));

        // Start at the end of the list, and keep removing from the
        // back. For some types of collections, this may not be the most
        // efficient way to remove all the elements.
        for (hr = pEnum->Last(IID_IWsbCollectable, (void**) &pCollectable);
             SUCCEEDED(hr);
             hr = pEnum->Last(IID_IWsbCollectable, (void**) &pCollectable)) {

            hr = RemoveAndRelease(pCollectable);
            pCollectable = 0;
        }

        // We should have emptied the list.
        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
        }

    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CHsmManagedResourceCollection::RemoveAllAndRelease"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmManagedResourceCollection::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmManagedResourceCollection::FinalConstruct"), OLESTR(""));
    try {
        WsbAffirmHr(CWsbPersistStream::FinalConstruct());
        WsbAssertHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, CLSCTX_ALL, 
                IID_IWsbIndexedCollection, (void**) &m_icoll));
        WsbAssertHr(m_icoll->QueryInterface(IID_IWsbCollection, 
                (void**)&m_coll));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResourceCollection::FinalConstruct"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


void CHsmManagedResourceCollection::FinalRelease(
    )
{
    WsbTraceIn(OLESTR("CHsmManagedResourceCollection::FinalRelease"), OLESTR(""));

    // Force a release of the resources
    if (m_coll) {
        m_coll->RemoveAllAndRelease();
    }

    // Let the parent class do his thing.   
    CWsbPersistStream::FinalRelease();

    WsbTraceOut(OLESTR("CHsmManagedResourceCollection::FinalRelease"), OLESTR(""));
}


HRESULT
CHsmManagedResourceCollection::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmManagedResourceCollection::GetClassID"), OLESTR(""));

    try {
        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmManagedResourceCollection;
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmManagedResourceCollection::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmManagedResourceCollection::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CHsmManagedResourceCollection::GetSizeMax"), OLESTR(""));

    try {
        CComPtr<IPersistStream> pPStream;

        WsbAffirmHr(m_icoll->QueryInterface(IID_IPersistStream,
                (void**)&pPStream));
        WsbAffirmHr(pPStream->GetSizeMax(pSize));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResourceCollection::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmManagedResourceCollection::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmManagedResourceCollection::Load"), OLESTR(""));

    try {
        CComPtr<IPersistStream> pPStream;

        WsbAffirmHr(m_icoll->QueryInterface(IID_IPersistStream,
                (void**)&pPStream));
        WsbAffirmHr(pPStream->Load(pStream));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResourceCollection::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmManagedResourceCollection::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                     hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmManagedResourceCollection::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        CComPtr<IPersistStream> pPStream;

        WsbAffirmHr(m_icoll->QueryInterface(IID_IPersistStream,
                (void**)&pPStream));
        WsbAffirmHr(pPStream->Save(pStream, clearDirty));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResourceCollection::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmManagedResourceCollection::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    *passed = 0;
    *failed = 0;

    HRESULT                 hr = S_OK;

#if defined(_DEBUG)
    WsbTraceIn(OLESTR("CHsmManagedResourceCollection::Test"), OLESTR(""));

    try {
        ULONG entries;
        CComPtr<IWsbLong> pLong1;
        CComPtr<IWsbLong> pLong2;
        CComPtr<IWsbLong> pLong3;
        CComPtr<IWsbLong> pLong4;

        hr = S_OK;

        // Check that collection is empty
        try {
            WsbAssertHr(GetEntries(&entries));
            WsbAssert(entries == 0, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }

        //  Add some elements to the collection
        WsbAssertHr(CoCreateInstance(CLSID_CWsbLong, NULL, CLSCTX_ALL, 
                IID_IWsbLong, (void**) &pLong1));
        WsbAssertHr(CoCreateInstance(CLSID_CWsbLong, NULL, CLSCTX_ALL, 
                IID_IWsbLong, (void**) &pLong2));
        WsbAssertHr(CoCreateInstance(CLSID_CWsbLong, NULL, CLSCTX_ALL, 
                IID_IWsbLong, (void**) &pLong3));
        WsbAssertHr(CoCreateInstance(CLSID_CWsbLong, NULL, CLSCTX_ALL, 
                IID_IWsbLong, (void**) &pLong4));
        WsbAssertHr(pLong1->SetLong(57));
        WsbAssertHr(pLong2->SetLong(-48));
        WsbAssertHr(pLong3->SetLong(23));
        WsbAssertHr(pLong4->SetLong(187));

        try {
            WsbAssertHr(Add(pLong1));
            WsbAssertHr(Add(pLong2));
            WsbAssertHr(Add(pLong3));
            WsbAssertHr(Add(pLong4));
            WsbAssertHr(GetEntries(&entries));
            WsbAssert(entries == 4, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }

        // Check the order
/*      try {
            ULONG             fetched;
            int               i;
            CComPtr<IWsbEnum> pEnum;
            CComPtr<IWsbLong> pLong[5];
            LONG              value[4];

            WsbAssertHr(Enum(&pEnum));
            WsbAssertHr(pEnum->First(5, IID_IWsbLong, (void**)&pLong, 
                    &fetched));
            WsbAssert(fetched == 4, E_FAIL);
            for (i = 0; i < 4; i++) {
                WsbAssertHr(pLong[i]->GetLong(&value[i]));
            }
            for (i = 0; i < 3; i++) {
                WsbAssert(value[i] < value[i+1], E_FAIL);
            }
        } WsbCatch(hr);
*/        

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }

        // Save/load
        try {
            CComPtr<IPersistFile>       pFile;
            CComPtr<IWsbCollection>     pSorted2;

            WsbAssertHr(((IUnknown*)(IWsbPersistStream*)this)->QueryInterface(IID_IPersistFile, 
                    (void**) &pFile));
            WsbAssertHr(pFile->Save(OLESTR("c:\\WsbTests\\WsbSorted.tst"), TRUE));
            pFile = 0;

            WsbAssertHr(CoCreateInstance(CLSID_CHsmManagedResourceCollection, NULL, 
                    CLSCTX_ALL, IID_IPersistFile, (void**) &pFile));
            WsbAssertHr(pFile->Load(OLESTR("c:\\WsbTests\\WsbSorted.tst"), 0));
            WsbAssertHr(pFile->QueryInterface(IID_IWsbCollection, 
                    (void**) &pSorted2));

            WsbAssertHr(pSorted2->GetEntries(&entries));
            WsbAssert(entries == 4, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }
    } WsbCatch(hr);


    // Tally up the results
    if (*failed) {
        hr = S_FALSE;
    } else {
        hr = S_OK;
    }

    WsbTraceOut(OLESTR("CHsmManagedResourceCollection::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
#endif  // _DEBUG

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\hsmeng\hsmmgdrs.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    HsmMgdRs.cpp

Abstract:

    This component is an object representation of the HSM managed resource. It
    is both a persistable and collectable.

Author:

    Cat Brant   [cbrant]   13-Jan-1997

Revision History:

--*/


#include "stdafx.h"
#include "Wsb.h"
#include "HsmEng.h"
#include "HsmServ.h"
#include "HsmConn.h"
#include "HsmMgdRs.h"
#include "Fsa.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG

HRESULT 
CHsmManagedResource::FinalConstruct(
    void
    ) 
/*++

Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbObject::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbTrace(OLESTR("CHsmManagedResource::FinalConstruct: this = %p\n"),
                static_cast<void*>(this));
        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_ResourceId = GUID_NULL;
    } WsbCatch(hr);

    return(hr);
}


void CHsmManagedResource::FinalRelease(
    )
{
    WsbTrace(OLESTR("CHsmManagedResource::FinalRelease: this = %p\n"),
            static_cast<void*>(this));
    // Let the parent class do his thing.   
    CWsbObject::FinalRelease();
}


HRESULT 
CHsmManagedResource::GetResourceId(
    OUT GUID *pResourceId
    ) 
/*++

Routine Description:

  See IHsmManagedResource::GetResourceId

Arguments:

  See IHsmManagedResource::GetResourceId

Return Value:
  
    See IHsmManagedResource::GetResourceId

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmManagedResource::GetResourceId"),OLESTR(""));

    try {
        //Make sure we can provide data memebers
        WsbAssert(0 != pResourceId, E_POINTER);

        //Provide the data members
        *pResourceId = m_ResourceId;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResource::GetResourceId"),
        OLESTR("hr = <%ls>, ResourceId = <%ls>>"),WsbHrAsString(hr), WsbPtrToGuidAsString(pResourceId));

    return(hr);
}

HRESULT 
CHsmManagedResource::InitFromFsaResource( 
    IN  IUnknown  *pFsaResource 
    )
/*++

Routine Description:

  See IHsmManagedResource::InitFromFsaResource

Arguments:

  See IHsmManagedResource::InitFromFsaResource

Return Value:
  
    See IHsmManagedResource::InitFromFsaResource

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmManagedResource::InitFromFsaResource"),OLESTR(""));

    try {
        CComPtr<IFsaResource>       l_pFsaResource;
        
        //Make sure we can provide data memebers
        WsbAssert(pFsaResource != 0, E_POINTER);

        //Provide the data members
        WsbAffirmHr(pFsaResource->QueryInterface(IID_IFsaResource, (void**) &l_pFsaResource));
        WsbAffirmHr(l_pFsaResource->GetIdentifier(&m_ResourceId));
        m_pFsaResourceInterface = pFsaResource;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResource::InitFromFsaResource"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CHsmManagedResource::GetFsaResource(     
    OUT IUnknown  **ppFsa 
    )
        
/*++

Routine Description:

  See IHsmManagedResource::GetFsaResource

Arguments:

  See IHsmManagedResource::GetFsaResource

Return Value:
  
    See IHsmManagedResource::GetFsaResource

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmManagedResource::GetFsaResource"),OLESTR(""));

    try {
        CComPtr<IUnknown>       l_pFsaResource;
        
        WsbAssert( 0 != ppFsa, E_POINTER);
        //
        // Using the GUID for this managed resource, get the COM
        // IFsaResource interface
        //
        WsbAffirmHr(HsmConnectFromId (HSMCONN_TYPE_RESOURCE, m_ResourceId, IID_IUnknown, (void **)ppFsa) );

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmManagedResource::GetFsaResource"),  OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CHsmManagedResource::SetResourceId
(
    IN GUID ResourceId
    )
 /*++

Routine Description:

  See IHsmManagedResource::Set().

Arguments:

  See IHsmManagedResource::Set().

Return Value:

    S_OK        - Success.

--*/
{
    WsbTraceIn(OLESTR("CHsmManagedResource::SetResourceId"), 
        OLESTR("ResourceId = <%ls>"), 
        WsbGuidAsString(ResourceId));

    m_isDirty = TRUE;
    m_ResourceId = ResourceId;

    WsbTraceOut(OLESTR("CHsmManagedResource::SetResourceId"), OLESTR("hr = <%ls>"),
        WsbHrAsString(S_OK));
    return(S_OK);
}

HRESULT 
CHsmManagedResource::GetClassID (
    OUT LPCLSID pClsId
    ) 
/*++

Routine Description:

  See IPerist::GetClassID()

Arguments:

  See IPerist::GetClassID()

Return Value:

    See IPerist::GetClassID()

--*/

{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmManagedResource::GetClassID"), OLESTR(""));


    try {
        WsbAssert(0 != pClsId, E_POINTER);
        *pClsId = CLSID_CHsmManagedResource;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResource::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsId));
    return(hr);
}

HRESULT 
CHsmManagedResource::GetSizeMax (
    OUT ULARGE_INTEGER* pcbSize
    ) 
/*++

Routine Description:

  See IPersistStream::GetSizeMax().

Arguments:

  See IPersistStream::GetSizeMax().

Return Value:

  See IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmManagedResource::GetSizeMax"), OLESTR(""));

    try {
        
        WsbAssert(0 != pcbSize, E_POINTER);

        pcbSize->QuadPart = WsbPersistSizeOf(GUID);
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResource::GetSizeMax"), 
        OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), 
        WsbPtrToUliAsString(pcbSize));

    return(hr);
}

HRESULT 
CHsmManagedResource::Load (
    IN IStream* pStream
    ) 
/*++

Routine Description:

  See IPersistStream::Load().

Arguments:

  See IPersistStream::Load().

Return Value:

  See IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes;

    WsbTraceIn(OLESTR("CHsmManagedResource::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(pStream->Read((void*) &m_ResourceId, sizeof(GUID), &ulBytes));
        WsbAffirm(ulBytes == sizeof(GUID), E_FAIL);

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmManagedResource::Load"), 
        OLESTR("hr = <%ls>,  GUID = <%ls>"), 
        WsbHrAsString(hr), 
        WsbGuidAsString(m_ResourceId));
    return(hr);
}

HRESULT 
CHsmManagedResource::Save (
    IN IStream* pStream, 
    IN BOOL clearDirty
    ) 
/*++

Routine Description:

  See IPersistStream::Save().

Arguments:

  See IPersistStream::Save().

Return Value:

  See IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes;

    WsbTraceIn(OLESTR("CHsmManagedResource::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(pStream->Write((void*) &m_ResourceId, sizeof(GUID), &ulBytes));
        WsbAffirm(ulBytes == sizeof(GUID), E_FAIL);


        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResource::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CHsmManagedResource::Test (
    OUT USHORT *pTestsPassed, 
    OUT USHORT *pTestsFailed 
    ) 
/*++

Routine Description:

  See IWsbTestable::Test().

Arguments:

  See IWsbTestable::Test().

Return Value:

  See IWsbTestable::Test().

--*/
{
#if 0
    HRESULT                 hr = S_OK;
    CComPtr<IHsmManagedResource>        pHsmManagedResource1;
    CComPtr<IHsmManagedResource>        pHsmManagedResource2;
    SHORT                   result;
    GUID                    l_ResourceId;

    WsbTraceIn(OLESTR("CHsmManagedResource::Test"), OLESTR(""));

    *pTestsPassed = *pTestsFailed = 0;
    try {
        // Get the pHsmManagedResource interface.
        WsbAffirmHr(((IUnknown*)(IHsmManagedResource*) this)->QueryInterface(IID_IHsmManagedResource,
                    (void**) &pHsmManagedResource1));


        try {
            // Set the HsmManagedResource to a value, and see if it is returned.
            WsbAffirmHr(pHsmManagedResource1->SetResourceId(CLSID_CHsmManagedResource));

            WsbAffirmHr(pHsmManagedResource1->GetResourceId(&l_ResourceId));

            WsbAffirm((l_ResourceId == CLSID_CHsmManagedResource), E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
            //Create another instance and test the comparisson methods:
            WsbAffirmHr(CoCreateInstance(CLSID_CHsmManagedResource, NULL, CLSCTX_ALL, IID_IHsmManagedResource, (void**) &pHsmManagedResource2));

            // Check the default values.
            WsbAffirmHr(pHsmManagedResource2->GetResourceId(&l_ResourceId));
            WsbAffirm((l_ResourceId == GUID_NULL), E_FAIL);
        }  WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
            // IsEqual()
            WsbAffirmHr(pHsmManagedResource1->SetResourceId(CLSID_CWsbBool));
            WsbAffirmHr(pHsmManagedResource2->SetResourceId(CLSID_CWsbBool));

            WsbAffirmHr(pHsmManagedResource1->IsEqual(pHsmManagedResource2));
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
            WsbAffirmHr(pHsmManagedResource1->SetResourceId(CLSID_CWsbBool));
            WsbAffirmHr(pHsmManagedResource2->SetResourceId(CLSID_CWsbLong));

            WsbAffirm((pHsmManagedResource1->IsEqual(pHsmManagedResource2) == S_FALSE), E_FAIL);
        }  WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
             // CompareTo()
             WsbAffirmHr(pHsmManagedResource1->SetResourceId(CLSID_CWsbBool));
             WsbAffirmHr(pHsmManagedResource2->SetResourceId(CLSID_CWsbBool));

             WsbAffirm((pHsmManagedResource1->CompareTo(pHsmManagedResource2, &result) == S_OK) && (result != 0), E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
            WsbAffirmHr(pHsmManagedResource1->SetResourceId(CLSID_CWsbBool));
            WsbAffirmHr(pHsmManagedResource2->SetResourceId(CLSID_CWsbLong));

            WsbAffirm(((pHsmManagedResource1->CompareTo(pHsmManagedResource2, &result) == S_FALSE) && (result > 0)), E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
             WsbAffirmHr(pHsmManagedResource1->SetResourceId(CLSID_CWsbBool));
             WsbAffirmHr(pHsmManagedResource2->SetResourceId(CLSID_CWsbBool));

             WsbAffirm((pHsmManagedResource1->CompareTo(pHsmManagedResource2, &result) == S_OK), E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        try {
        // Try out the persistence stuff.
            CComPtr<IPersistFile>       pFile1;
            CComPtr<IPersistFile>       pFile2;

            WsbAffirmHr(pHsmManagedResource1->QueryInterface(IID_IPersistFile, (void**) &pFile1));
            WsbAffirmHr(pHsmManagedResource2->QueryInterface(IID_IPersistFile, (void**) &pFile2));

            LPOLESTR    szTmp = NULL;
            // The item should be dirty.
            try {
                WsbAffirmHr(pHsmManagedResource2->SetResourceId(CLSID_CWsbLong));
                WsbAffirmHr(pFile2->IsDirty());
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*pTestsPassed)++;
            } else {
                (*pTestsFailed)++;
            }

            hr = S_OK;
            try {
                // Save the item, and remember.
                WsbAffirmHr(pFile2->Save(OLESTR("c:\\WsbTests\\mngdRes.tst"), TRUE));
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*pTestsPassed)++;
            } else {
                (*pTestsFailed)++;
            }

            hr = S_OK;
            try {
                // It shouldn't be dirty.
                WsbAffirm((pFile2->IsDirty() == S_FALSE), E_FAIL);

            } WsbCatch(hr);

            if (hr == S_OK) {
                (*pTestsPassed)++;
            } else {
                (*pTestsFailed)++;
            }

            hr = S_OK;
            try {
                // Try reading it in to another object.
                WsbAffirmHr(pHsmManagedResource1->SetResourceId(CLSID_CWsbLong));
                WsbAffirmHr(pFile1->Load(OLESTR("c:\\WsbTests\\mngdRes.tst"), 0));

                WsbAffirmHr(pHsmManagedResource1->CompareToIHsmManagedResource(pHsmManagedResource2, &result));
            }WsbCatch(hr);

            if (hr == S_OK) {
                (*pTestsPassed)++;
            } else {
                (*pTestsFailed)++;
            }
        } WsbCatch(hr);
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResource::Test"),    OLESTR("hr = <%ls>"),WsbHrAsString(hr));
#else
    UNREFERENCED_PARAMETER(pTestsPassed);
    UNREFERENCED_PARAMETER(pTestsFailed);
#endif
    return(S_OK);
}


HRESULT CHsmManagedResource::CompareTo (
    IN IUnknown* pCollectable, 
    OUT short* pResult
    ) 
/*++

Routine Description:

        1  : object > value
        0  : object = value
        -1 : object < value
    In addition, the return code is S_OK if the object = value and
    S_FALSE otherwise.

Arguments:


Return Value:

    S_OK        - object = value

    S_FALSE     - object != value

--*/

{
    HRESULT                      hr = S_OK;
    CComPtr<IHsmManagedResource> pHsmManagedResource;

    WsbTraceIn(OLESTR("CHsmManagedResource::CompareTo"), OLESTR(""));


    // Did they give us a valid item to compare to?
    try {
        WsbAssert(pCollectable != NULL, E_POINTER);

        // We need the IWsbLong interface to get the value of the object.
        WsbAffirmHr(pCollectable->QueryInterface(IID_IHsmManagedResource, (void**) &pHsmManagedResource));
        hr = pHsmManagedResource->CompareToIHsmManagedResource(this, pResult);
        } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResource::CompareTo"), OLESTR("hr = <%ls>, pResult = <%d>"), WsbHrAsString(hr), pResult);

    return(hr);
}

HRESULT CHsmManagedResource::CompareToIHsmManagedResource (
    IN IHsmManagedResource* pHsmManagedResource, 
    OUT short* pResult
    )
{
    HRESULT                 hr = S_OK;
    GUID                    l_ResourceId;
    BOOL                    areGuidsEqual;


    WsbTraceIn(OLESTR("CHsmManagedResource::CompareToIHsmManagedResource"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(pHsmManagedResource != NULL, E_POINTER);

        WsbAffirmHr(((IHsmManagedResource *)pHsmManagedResource)->GetResourceId(&l_ResourceId));

        // Make sure the GUID matches.  Then see if the SegStartLoc is in the range of this entry
        areGuidsEqual = IsEqualGUID(m_ResourceId, l_ResourceId);
        WsbAffirm( (areGuidsEqual == TRUE), S_FALSE); 

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmManagedResource::CompareToIHsmManagedResource"), OLESTR("hr = <%ls>, pResult = <%d>"), WsbHrAsString(hr), pResult);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\hsmeng\hsmmgdrs.h ===
/////////////////////////////////////////////////////////////////////////////
// HsmMgdRs.h : Declaration of the CHsmServer
/////////////////////////////////////////////////////////////////////////////

#include "resource.h"
#include "wsb.h"

/////////////////////////////////////////////////////////////////////////////


class CHsmManagedResource : 
    public CWsbObject,
    public IHsmManagedResource,
    public CComCoClass<CHsmManagedResource,&CLSID_CHsmManagedResource>
{

public:
    CHsmManagedResource( ) {}
BEGIN_COM_MAP( CHsmManagedResource )
    COM_INTERFACE_ENTRY( IHsmManagedResource )
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY2(IWsbCollectable, IHsmManagedResource)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP( )


DECLARE_REGISTRY_RESOURCEID( IDR_CHsmManagedResource )

//CComObjectRoot
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pTestsPassed, USHORT* pTestsFailed);

// IHsmManagedResource
public:
    STDMETHOD( GetResourceId )( GUID  *pResourceId );
    STDMETHOD( SetResourceId )( GUID  resourceId );
    STDMETHOD( InitFromFsaResource )( IUnknown  *pFsa );
    STDMETHOD( GetFsaResource )( IUnknown  **ppFsa );
    STDMETHOD( CompareToIHsmManagedResource )( IHsmManagedResource* pHsmManagedResource, short* psResult );


// Internal Helper functions

private:
    GUID                            m_ResourceId;
    GUID                            m_HsmId;
    CComPtr<IUnknown>               m_pFsaResourceInterface;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\hsmeng\hsmeng.cpp ===
/*++

 

Module Name:

    hsmeng.cpp

Abstract:

    DLL main for Engine

Author:

    Ran Kalach          [rankala]         28-July-1999

Revision History:

--*/

// hsmeng.cpp : Implementation of DLL Exports.

// Note: Currently, Engine proxy/stub is compiled into a different DLL.
//      Below is relevant information if it is decided to merge the two DLLs.
// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for ...int.idl by adding the following 
//      files to the Outputs.
//          ...
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f ...ps.mk in the project directory.

#include "stdafx.h"
#include "initguid.h"

#include "HsmServ.h"
#include "HsmMgdRs.h"
#include "HsmMgdRc.h"
#include "HsmStgPl.h"
#include "mountmed.h"
#include "task.h"
#include "metalib.h"

#include <stdio.h>

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

#define WSB_TRACE_IS WSB_TRACE_BIT_HSMENG

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_HsmServer, CHsmServer)
    OBJECT_ENTRY(CLSID_CHsmUpgradeRmsDb, CHsmUpgradeRmsDb)
    OBJECT_ENTRY(CLSID_CHsmManagedResource, CHsmManagedResource)
    OBJECT_ENTRY(CLSID_CHsmManagedResourceCollection, CHsmManagedResourceCollection)
    OBJECT_ENTRY(CLSID_CHsmStoragePool, CHsmStoragePool)
    OBJECT_ENTRY(CLSID_CMountingMedia, CMountingMedia)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hr;

#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif

    // registers object, typelib and all interfaces in typelib
    hr = CoInitialize( 0 );

    if (SUCCEEDED(hr)) {
        hr = _Module.RegisterServer( FALSE );
        CoUninitialize( );
    }
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif

    hr = CoInitialize( 0 );

    if (SUCCEEDED(hr)) {
        _Module.UnregisterServer();
        CoUninitialize( );
        hr = S_OK;
    }

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\hsmeng\hsmmgdrc.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.


Module Name:

    Wsbcltn.h

Abstract:

    These classes provide support for collections (lists) of "collectable"
    objects.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"
#include "Wsbpstbl.h"

#ifndef _HSMMGDRC_
#define _HSMMGDRC_
/*++

Class Name:
    
    CHsmManagedResourceCollection 

Class Description:

    A sorted collection of objects.

--*/

class CHsmManagedResourceCollection : 
    public CWsbPersistStream,
    public IWsbIndexedCollection,
    public IHsmManagedResourceCollection,
    public IWsbTestable,
    public CComCoClass<CHsmManagedResourceCollection,&CLSID_CHsmManagedResourceCollection>
{
public:
    CHsmManagedResourceCollection() {}
BEGIN_COM_MAP(CHsmManagedResourceCollection)
    COM_INTERFACE_ENTRY2(IWsbCollection, IWsbIndexedCollection)
    COM_INTERFACE_ENTRY(IWsbIndexedCollection)
    COM_INTERFACE_ENTRY(IHsmManagedResourceCollection)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmManagedResourceCollection)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IWsbCollection
public:
    STDMETHOD(Add)(IUnknown* pCollectable);
    STDMETHOD(Contains)(IUnknown* pCollectable) {
        return(m_coll->Contains(pCollectable)); }
    STDMETHOD(Enum)(IWsbEnum** ppEnum) {
        return(m_coll->Enum(ppEnum)); }
    STDMETHOD(EnumUnknown)(IEnumUnknown** ppEnum) {
        return(m_coll->EnumUnknown(ppEnum)); }
    STDMETHOD(Find)(IUnknown* pCollectable, REFIID riid, void** ppElement) {
        return(m_coll->Find(pCollectable, riid, ppElement)); }
    STDMETHOD(GetEntries)(ULONG* pEntries) {
        return(m_coll->GetEntries(pEntries)); }
    STDMETHOD(IsEmpty)(void) {
        return(m_coll->IsEmpty()); }
    STDMETHOD(IsLocked)(void) {
        return(m_coll->IsLocked()); }
    STDMETHOD(Lock)(void) {
        return(m_coll->Lock()); }
    STDMETHOD(OccurencesOf)(IUnknown* pCollectable, ULONG* occurences) {
        return(m_coll->OccurencesOf(pCollectable, occurences)); }
    STDMETHOD(Remove)(IUnknown* pCollectable, REFIID riid, void** ppElement);
    STDMETHOD(RemoveAndRelease)(IUnknown* pCollectable); 
    STDMETHOD(RemoveAllAndRelease)(void);
    STDMETHOD(Unlock)(void) {
        return(m_coll->Unlock()); }

// IWsbIndexedCollection
    STDMETHOD(AddAt)(IUnknown* pCollectable, ULONG /*index*/) {
        return(Add(pCollectable)); }
    STDMETHOD(Append)(IUnknown* pCollectable) {
        return(Add(pCollectable)); }
    STDMETHOD(At)(ULONG index, REFIID riid, void** ppElement) {
        return(m_icoll->At(index, riid, ppElement)); }
    STDMETHOD(Copy)(ULONG start, ULONG stop, REFIID riid, void** rgElement, 
            ULONG* pElementsFetched) {
        return(m_icoll->Copy(start, stop, riid, rgElement,pElementsFetched)); }
    STDMETHOD(CopyIfMatches)(ULONG start, ULONG stop, IUnknown* pCollectable, 
            ULONG element, REFIID riid, void** rgElement, ULONG* pElementsFetched, 
            ULONG* pStoppedAt) {
        return(m_icoll->CopyIfMatches(start, stop, pCollectable, element,
                riid, rgElement, pElementsFetched, pStoppedAt)); }
    STDMETHOD(First)(REFIID riid, void** ppElement) {
        return(m_icoll->First(riid, ppElement)); }
    STDMETHOD(Index)(IUnknown* pCollectable, ULONG* index) {
        return(m_icoll->Index(pCollectable, index)); }
    STDMETHOD(Last)(REFIID riid, void** ppElement) {
        return(m_icoll->Last(riid, ppElement)); }
    STDMETHOD(Prepend)(IUnknown* pCollectable) {
        return(Add(pCollectable)); }
    STDMETHOD(RemoveAt)(ULONG index, REFIID riid, void** ppElement) {
        return(m_icoll->RemoveAt(index, riid, ppElement)); }

// IHsmManagedResourceCollection
    STDMETHOD(DeleteAllAndRelease)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pclsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT *failed);

// Data
protected:
    CComPtr<IWsbCollection>        m_coll;
    CComPtr<IWsbIndexedCollection> m_icoll;
};

#endif // _HSMMGDRC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\hsmeng\hsmserv.h ===
/*++

Copyright (c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    HsmServ.h

Abstract:

    This header file defines the CHsmServer object, which acts as the 'entry point'
    for the HSM Engine.

Author:

    Cat Brant       [cbrant]    24-Jan-1997

Revision History:

    Chris Timmes    [chris.timmes] 11-Sep-1997  - Renamed FindStoragePoolById()
                                                  to FindHsmStoragePoolByMediaSetId()
                                                  and added FindHsmStoragePoolById()

    Chris Timmes    [chris.timmes] 22-Sep-1997  - Added FindMediaIdByDisplayName()
                                                  and RecreateMaster() methods to
                                                  IHsmServer

    Chris Timmes    [chris.timmes] 21-Oct-1997  - Added MarkMediaForRecreation()
                                                  method to IHsmServer

    Chris Timmes    [chris.timmes] 18-Nov-1997  - Added CreateTask() method to IHsmServer

--*/

#ifndef _HSMSERV_H
#define _HSMSERV_H

#include <rswriter.h>


#define ENG_DB_DIRECTORY    OLESTR("EngDb")


class CHsmServer : 
    public CWsbPersistable,
    public IHsmServer,
    public IWsbServer,
    public IWsbCreateLocalObject,
    public CComCoClass<CHsmServer,&CLSID_HsmServer>
{

public:
    CHsmServer( ) {}
BEGIN_COM_MAP( CHsmServer )
    COM_INTERFACE_ENTRY( IHsmServer )
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IPersistFile)
    COM_INTERFACE_ENTRY(IWsbPersistable)
    COM_INTERFACE_ENTRY( IWsbCreateLocalObject )
    COM_INTERFACE_ENTRY( IWsbServer )
END_COM_MAP( )

DECLARE_NOT_AGGREGATABLE( CHsmServer) 

DECLARE_REGISTRY_RESOURCEID( IDR_HsmServer )
DECLARE_PROTECT_FINAL_CONSTRUCT()


// CComObjectRoot
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease( void );

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbServer
public:
    STDMETHOD( GetId )( GUID* pId );
    STDMETHOD( GetRegistryName )( OLECHAR **pRegistryName, ULONG bufferSize );
    STDMETHOD( SetId )( GUID  id );
    STDMETHOD( GetBuildVersion )( ULONG *pBuildVersion );
    STDMETHOD( GetNtProductVersion )( OLECHAR **pNtProductVersion, ULONG bufferSize );
    STDMETHOD( GetNtProductBuild )( ULONG *pNtProductBuild );
    STDMETHOD( GetDatabaseVersion )( ULONG *pDatabaseVersion );
    STDMETHOD( SaveAll )( void );
    STDMETHOD( Unload )( void );
    STDMETHOD( CheckAccess )( WSB_ACCESS_TYPE AccessType );
    STDMETHOD( GetTrace )( OUT IWsbTrace ** ppTrace );
    STDMETHOD( SetTrace )( IN IWsbTrace *pTrace );
    STDMETHOD( DestroyObject )( void );

// IHsmServer
public:
    STDMETHOD( Init )( void );

    STDMETHOD( GetID )( GUID  *phid );
    STDMETHOD( GetDbPath )( OLECHAR** pPath, ULONG bufferSize );
    STDMETHOD( GetIDbPath )( OLECHAR** pPath, ULONG bufferSize );
    STDMETHOD( GetDbPathAndName )( OLECHAR** pPath, ULONG bufferSize );
    STDMETHOD( GetName )( OLECHAR **ppName );

    STDMETHOD( GetHsmExtVerHi )( SHORT *pExtVerHi );
    STDMETHOD( GetHsmExtVerLo )( SHORT *pExtVerLo );
    STDMETHOD( GetHsmExtRev )( SHORT *pExtRev );

    STDMETHOD( GetAutosave )( ULONG* pMilliseconds );
    STDMETHOD( SetAutosave )( ULONG milliseconds );

    STDMETHOD( GetCopyFilesLimit )( ULONG* pLimit );
    STDMETHOD( GetCopyFilesUserLimit )( ULONG* pLimit );
    STDMETHOD( SetCopyFilesUserLimit )( ULONG limit );

    STDMETHOD( GetManagedResources )( IWsbIndexedCollection  **ppCollection);
    STDMETHOD( FindHsmStoragePoolById )( GUID StoragePoolId, 
                                            IHsmStoragePool** ppStoragePool );
    STDMETHOD( FindHsmStoragePoolByMediaSetId )( GUID RmsMediaSetId, 
                                            IHsmStoragePool** ppStoragePool );
    STDMETHOD( FindMediaIdByDescription )( IN OLECHAR* description, 
                                            OUT GUID* pMediaId );
    STDMETHOD( FindStoragePoolByName )(OLECHAR* name, IHsmStoragePool** ppStoragePool );
    STDMETHOD( GetStoragePools )( IWsbIndexedCollection  **ppCollection);
    STDMETHOD( GetOnlineInformation )( IWsbIndexedCollection  **ppCollection);
    STDMETHOD( GetMessages )( IWsbIndexedCollection  **ppCollection);
    STDMETHOD( GetUsrToNotify )( IWsbIndexedCollection  **ppCollection);
    STDMETHOD( GetJobs )( IWsbIndexedCollection  **ppCollection);
    STDMETHOD( FindJobByName )(OLECHAR* name, IHsmJob** ppJob );
    STDMETHOD( GetJobDefs )( IWsbIndexedCollection  **ppCollection);
    STDMETHOD( GetPolicies )( IWsbIndexedCollection  **ppCollection);
    STDMETHOD( GetActions )( IWsbIndexedCollection  **ppCollection);
    STDMETHOD( GetCriteria )( IWsbIndexedCollection  **ppCollection);
    STDMETHOD( GetMediaRecs )( IWsbIndexedCollection  **ppCollection);
    STDMETHOD( GetMountingMedias ) ( IWsbIndexedCollection  **ppCollection);

    STDMETHOD( LockMountingMedias )( void );
    STDMETHOD( UnlockMountingMedias )( void );

    STDMETHOD( GetNextMedia )( LONG *pNextMedia );
    STDMETHOD( GetSegmentDb )( IWsbDb  **ppDb);
    STDMETHOD( BackupSegmentDb )( void );
    STDMETHOD( GetHsmFsaTskMgr )( IHsmFsaTskMgr  **ppHsmFsaTskMgr);
    STDMETHOD( SaveMetaData )( void  );
    STDMETHOD( SavePersistData )( void  );
    STDMETHOD( CloseOutDb )( void );
    STDMETHOD( CancelAllJobs )( void );
    STDMETHOD( AreJobsEnabled )( void );
    STDMETHOD( EnableAllJobs )( void );
    STDMETHOD( DisableAllJobs )( void );
    STDMETHOD( RestartSuspendedJobs )( void );
    
    STDMETHOD( CreateTask )( IN const OLECHAR * jobName, IN const OLECHAR * jobParameters, 
                             IN const OLECHAR * jobComments, 
                             IN const TASK_TRIGGER_TYPE jobTriggerType, 
                             IN const WORD jobStartHour, IN const WORD jobStartMinute, 
                             IN const BOOL scheduledJob );

    STDMETHOD( CreateTaskEx )( IN const OLECHAR * jobName, IN const OLECHAR * jobParameters, 
                               IN const OLECHAR * jobComments, 
                               IN const TASK_TRIGGER_TYPE jobTriggerType, 
                               IN const SYSTEMTIME runTime,
                               IN const DWORD runOccurrence,
                               IN const BOOL scheduledJob );

    STDMETHOD( CancelCopyMedia )( void );
    STDMETHOD( MarkMediaForRecreation )( IN REFGUID masterMediaId );
    STDMETHOD( RecreateMaster )( IN REFGUID masterMediaId, USHORT copySet );
    STDMETHOD( SynchronizeMedia )( GUID poolId, USHORT copySet );
    STDMETHOD( GetHsmMediaMgr )( IRmsServer  **ppHsmMediaMgr);

    STDMETHOD( ResetSegmentValidMark )( void );
    STDMETHOD( ResetMediaValidBytes )( void );

    STDMETHOD( GetSegmentPosition )( IN REFGUID bagId, 
                                     IN LONGLONG fileStart,
                                     IN LONGLONG fileSize, 
                                     OUT GUID* pPosMedia,
                                     OUT LONGLONG* pPosOfffset );

    STDMETHOD( UpdateMediaSizeLimit )(OUT DWORD* pdwNewLimit);
    
// IHsmSystemState
    STDMETHOD( ChangeSysState )( HSM_SYSTEM_STATE* pSysState );

// IWsbCreateLocalServer
    STDMETHOD( CreateInstance )( REFCLSID rclsid, REFIID riid, void **ppv );

// Internal Helper functions
    STDMETHOD( Autosave )(void);
    STDMETHOD( LoadJobs )( IStream* pStream  );
    STDMETHOD( StoreJobs )( IStream* pStream );
    STDMETHOD( LoadJobDefs )( IStream* pStream );
    STDMETHOD( StoreJobDefs )( IStream* pStream );
    STDMETHOD( LoadPolicies )( IStream* pStream  );
    STDMETHOD( StorePolicies )( IStream* pStream );
    STDMETHOD( LoadManagedResources )( IStream* pStream  );
    STDMETHOD( StoreManagedResources )( IStream* pStream );
    STDMETHOD( LoadStoragePools )( IStream* pStream  );
    STDMETHOD( StoreStoragePools )( IStream* pStream );
    STDMETHOD( LoadSegmentInformation )( void  );
    STDMETHOD( StoreSegmentInformation )( void );
    STDMETHOD( StoreSegmentInformationFinal )( void );
    STDMETHOD( LoadMessages )( IStream* pStream  );
    STDMETHOD( StoreMessages )( IStream* pStream );
    STDMETHOD( LoadPersistData )( void  );
    STDMETHOD( NotifyAllJobs )(HSM_JOB_STATE jobState);
    STDMETHOD( CreateDefaultJobs )( void );
    STDMETHOD( GetSavedTraceSettings )( LONGLONG  *pTraceSettings, BOOLEAN *pTraceOn);
    STDMETHOD( SetSavedTraceSettings )( LONGLONG  traceSettings, BOOLEAN traceOn);
    STDMETHOD( CheckManagedResources )( void );
    STDMETHOD( InternalSavePersistData)( void );
    STDMETHOD( CancelMountingMedias ) (void);
    void StopAutosaveThread(void);
    void StopCheckManagedResourcesThread(void);

protected:
    ULONG                           m_autosaveInterval; // Autosave interval in 
                                                        // milliseconds; 0 turns it off
    HANDLE                          m_autosaveThread;
    HANDLE                          m_savingEvent;      // An event for synchronizing saving of persistent data
    HANDLE                          m_terminateEvent;   // An event for signaling termination to the autosave thread
    HANDLE                          m_CheckManagedResourcesThread;
    GUID                            m_hId;
    CWsbStringPtr                   m_name;
    CWsbStringPtr                   m_dir;
    BOOL                            m_initializationCompleted;
    BOOL                            m_persistWasCreated; // TRUE if persistence file was created

    ULONG                           m_traceSettings;
    BOOL                            m_traceOn;
    BOOL                            m_cancelCopyMedia;
    BOOL                            m_inCopyMedia;
    BOOL                            m_Suspended;
    BOOL                            m_JobsEnabled;     // Not persistent !!

    CWsbStringPtr                   m_dbPath;
    CComPtr<IHsmFsaTskMgr>          m_pHsmFsaTskMgr;
    CComPtr<IRmsServer>             m_pHsmMediaMgr;
    CRssJetWriter                   *m_pRssWriter;

    CComPtr<IWsbTrace>              m_pTrace;
    CComPtr<IWsbDbSys>              m_pDbSys;
    CComPtr<IWsbDb>                 m_pSegmentDatabase;
    CComPtr<IWsbIndexedCollection>  m_pJobs;
    CComPtr<IWsbIndexedCollection>  m_pJobDefs;
    CComPtr<IWsbIndexedCollection>  m_pPolicies;
    CComPtr<IWsbIndexedCollection>  m_pManagedResources;
    CComPtr<IWsbIndexedCollection>  m_pStoragePools;
    CComPtr<IWsbIndexedCollection>  m_pMessages;
    CComPtr<IWsbIndexedCollection>  m_pOnlineInformation;
    CComPtr<IWsbIndexedCollection>  m_pMountingMedias;

    LONG                            m_mediaCount;

    ULONG                           m_buildVersion;
    ULONG                           m_databaseVersion;

    ULONG                           m_copyfilesUserLimit;

    CRITICAL_SECTION                m_JobDisableLock;
    CRITICAL_SECTION                m_MountingMediasLock;
    BOOL                            m_bCritSecCreated;
};

class CHsmUpgradeRmsDb :
    public CWsbPersistable,
    public IHsmUpgradeRmsDb,
    public CComCoClass<CHsmUpgradeRmsDb,&CLSID_CHsmUpgradeRmsDb>
{
public:
    CHsmUpgradeRmsDb( ) {}
BEGIN_COM_MAP( CHsmUpgradeRmsDb )
    COM_INTERFACE_ENTRY( IHsmUpgradeRmsDb )
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IPersistFile)
    COM_INTERFACE_ENTRY(IWsbPersistable)
END_COM_MAP( )

DECLARE_REGISTRY_RESOURCEID( IDR_HsmUpgradeRmsDb )

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pclsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* /*pSize*/) {
            return(E_NOTIMPL); }
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IHsmUpgradeRmsDb
    STDMETHOD(Init)( IRmsServer *pHsmMediaMgr);

private:
    IRmsServer  *m_pServer;
};

#endif // _HSMSERV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\hsmeng\hsmserv.cpp ===
/*++

Copyright (c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmServ.cpp

Abstract:

    This component provides the functions to access the HSM
    IHsmServer interfaces.

Author:

    Cat Brant   [cbrant]   24-Jan-1997

Revision History:

    Chris Timmes    [ctimmes]   11-Sep-1997

    - renamed COM method FindStoragePoolById() to FindHSMStoragePoolByMediaSetId()
      to better reflect its purpose.  Also created new COM method 
      FindHsmStoragePoolById().  Action required since the Engine maintains 2
      sets of (original/master) secondary storage media set ids (GUIDs).  First, 
      the Engine maintains its own 'media set' id, called a Storage Pool id, which
      is only maintained by the Engine.  Second, the Engine also maintains the NT 
      Media Services (NTMS) id, called the Media Set id, which comes from NTMS and 
      is passed to the Engine by RMS (the Remote Storage Subsystem).  (Note that the
      concept of a Storage Pool encompasses more info than that of a Media Set.)
      These 2 lookup functions allow for lookup by either id.

    Chris Timmes    [ctimmes]   22-Sep-1997

    - added new COM methods FindMediaIdByDisplayName() and RecreateMaster().  Changes
      made to enable Copy Set usage.  Code written to be both Sakkara and Phoenix
      compatible.

    Chris Timmes    [ctimmes]   21-Oct-1997  
    
    - added new COM method MarkMediaForRecreation().  Change made to allow 
      RecreateMaster() to be invokable directly from RsLaunch (without going through
      the UI).  

    Chris Timmes    [ctimmes]   18-Nov-1997  
    
    - added new COM method CreateTask().  Change made to move NT Task Scheduler task
      creation code from the UI to the Engine.  Change required to allow Remote
      Storage system to run under LocalSystem account.  CreateTask() is a generic
      method callable by anyone wanting to create any supported type of Remote Storage
      task in Task Scheduler.

--*/

#include "stdafx.h"
#include "HsmServ.h"
#include "HsmConn.h"
#include "metalib.h"
#include "task.h"
#include "wsbdb.h"
#include "rsbuild.h"
#include "wsb.h"
#include "ntverp.h"                 // for GetNtProductVersion() and GetNtProductBuild()
#include "Rms.h"
#include "rsevents.h"
#include "HsmEng.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG

#define HSM_PERSIST_FILE           "\\RsEng.col"
#define RMS_WIN2K_PERSIST_FILE     "\\RsSub.col"

#define DEFAULT_COPYFILES_USER_LIMIT         10

BOOL g_HsmSaveInProcess  = FALSE;


/////////////////////////////////////////////////////////////////////////////
//


//  Non-member function initially called for autosave thread
static DWORD HsmengStartAutosave(
    void* pVoid
    )
{
    return(((CHsmServer*) pVoid)->Autosave());
}

//  Non-member function run in a separate thread to call CheckManagedResources
static DWORD HsmengStartCheckManagedResources(
    void* pVoid
    )
{
    DWORD result;

    result = ((CHsmServer*) pVoid)->CheckManagedResources();
    return(result);
}


HRESULT
CHsmServer::Autosave(
    void
    )

/*++

Routine Description:

  Implements an autosave loop.

Arguments:

  None.
  
Return Value:

  Doesn't matter.


--*/
{

    HRESULT         hr = S_OK;
    ULONG           l_autosaveInterval = m_autosaveInterval;
    BOOL            exitLoop = FALSE;

    WsbTraceIn(OLESTR("CHsmServer::Autosave"), OLESTR(""));

    try {


        while (m_autosaveInterval && (! exitLoop)) {

            // Wait for termination event, if timeout occurs, check if we can perform Autosave
            switch (WaitForSingleObject(m_terminateEvent, l_autosaveInterval)) {
                case WAIT_OBJECT_0:
                    // Need to terminate
                    WsbTrace(OLESTR("CHsmServer::Autosave: signaled to terminate\n"));
                    exitLoop = TRUE;
                    break;

                case WAIT_TIMEOUT: 
                    // Check if backup need to be performed
                    WsbTrace(OLESTR("CHsmServer::Autosave: Autosave awakened\n"));

                    //  Don't do this if we're suspended
                    if (!m_Suspended) {
                        //  Save data
                        //  NOTE: Because this is a separate thread, there is the possibility
                        //  of a conflict if the main thread is changing some data at the same
                        //  time we're trying to save it.
                        //  If a save is already happening, just skip this one and
                        //  go back to sleep
                        hr = SaveAll();
    
                        //  If the save fails, increase the sleep time to avoid filling
                        //  the event log
                        if (!SUCCEEDED(hr)) {
                            if ((MAX_AUTOSAVE_INTERVAL / 2) < l_autosaveInterval) {
                                l_autosaveInterval = MAX_AUTOSAVE_INTERVAL;
                            } else {
                                l_autosaveInterval *= 2;
                            }
                        } else {
                            l_autosaveInterval = m_autosaveInterval;
                        }
                    }

                    break;  // end of timeout case

                case WAIT_FAILED:
                default:
                    WsbTrace(OLESTR("CHsmServer::Autosave: WaitForSingleObject returned error %lu\n"), GetLastError());
                    exitLoop = TRUE;
                    break;

            } // end of switch

        } // end of while

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::Autosave"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmServer::GetAutosave(
    OUT ULONG* pMilliseconds
    )

/*++

Implements:

  CHsmServer::GetAutosave().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::GetAutosave"), OLESTR(""));

    try {

        WsbAssert(0 != pMilliseconds, E_POINTER);
        *pMilliseconds = m_autosaveInterval;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::GetAutosave"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmServer::SetAutosave(
    IN ULONG milliseconds
    )

/*++

Implements:

  CHsmServer::SetAutosave().

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::SetAutosave"), OLESTR("milliseconds = <%ls>"), WsbPtrToUlongAsString( &milliseconds ) );

    try {
        // Don't do anything if interval isn't changing
        if (milliseconds != m_autosaveInterval) {
            // Close the current thread
            if (m_autosaveThread) {
                StopAutosaveThread();
            }
            m_autosaveInterval = milliseconds;

            // Start/restart the autosave thread
            if (m_autosaveInterval) {
                DWORD  threadId;

                WsbAffirm((m_autosaveThread = CreateThread(0, 0, HsmengStartAutosave, (void*) this, 0, &threadId)) 
                        != 0, HRESULT_FROM_WIN32(GetLastError()));
            }
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::SetAutosave"), OLESTR("hr = <%ls> m_runInterval = <%ls>"), WsbHrAsString(hr), WsbPtrToUlongAsString( &m_autosaveInterval ) );

    return(hr);
}


HRESULT CHsmServer::GetID(
    GUID  *phid
    )
{
    if( !phid )
        return E_INVALIDARG;

    *phid = m_hId;

    return S_OK;
}


HRESULT CHsmServer::GetId(
    GUID  *phid
    )
{
    return (GetID(phid));
}


HRESULT CHsmServer::SetId(
    GUID  id
    )
{

    m_hId = id;
    return S_OK;
}


HRESULT
CHsmServer::GetDbPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmServer::GetDbPath().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pPath, E_POINTER); 

        WsbAffirmHr(m_dbPath.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}

HRESULT
CHsmServer::GetDbPathAndName(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmServer::GetDbPathAndName().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pPath, E_POINTER); 

        tmpString = m_dbPath;
        WsbAffirmHr(tmpString.Append(HSM_PERSIST_FILE));
        WsbAffirmHr(tmpString.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmServer::GetIDbPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Routine Description:

  Returns the path (directory) for the Engine IDB files

Arguments:

  pPath      - address of pointer to buffer

  bufferSize - size of buffer (or zero)
  
Return Value:

  S_OK  - On success

--*/
{
    HRESULT         hr = S_OK;

    try {
        CWsbStringPtr temp;

        WsbAssert(0 != pPath, E_POINTER); 

        temp = m_dbPath;

        temp.Append(OLESTR("\\"));
        temp.Append(ENG_DB_DIRECTORY);

        WsbAffirmHr(temp.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT CHsmServer::GetName ( 
    OLECHAR **ppName 
    )  
{

    HRESULT hr = S_OK;
    
    try  {
        WsbAssert(0 != ppName,  E_POINTER);
        WsbAffirmHr(m_name.CopyTo(ppName));
    } WsbCatch( hr );
    
    return (hr);
}

HRESULT CHsmServer::GetRegistryName ( 
    OLECHAR **pName, 
    ULONG bufferSize
    )  
{

    HRESULT hr = S_OK;
    
    try  {
        CWsbStringPtr tmpString;
        
        WsbAssert(0 != pName,  E_POINTER);
        
        tmpString = HSM_ENGINE_REGISTRY_NAME;
        WsbAffirmHr(tmpString.CopyTo(pName, bufferSize));
        
    } WsbCatch( hr );
    
    return (hr);
}



HRESULT CHsmServer::GetHsmExtVerHi ( 
    SHORT * /*pExtVerHi*/
    )  
{
    return( E_NOTIMPL );
    
}

HRESULT CHsmServer::GetHsmExtVerLo ( 
    SHORT * /*pExtVerLo*/
    )  
{
    return( E_NOTIMPL );
    
}

HRESULT CHsmServer::GetHsmExtRev ( 
    SHORT * /*pExtRev*/
    )  
{
    return( E_NOTIMPL );
    
};


HRESULT CHsmServer::GetManagedResources(
    IWsbIndexedCollection  **ppCollection
    )
{
    HRESULT hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmServer::GetManagedResources"),OLESTR(""));

    //
    // If the resources have been loaded, return the pointer. Otherwise, 
    // fail.
    try {
        WsbAssert(0 != ppCollection, E_POINTER);
        *ppCollection = m_pManagedResources;
        WsbAffirm(m_pManagedResources != 0, E_FAIL);
        m_pManagedResources.p->AddRef();
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::GetManagedResources"),OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return (hr);
}


HRESULT CHsmServer::SaveMetaData( 
    void 
    )
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::SaveMetaData"), OLESTR(""));

    //
    // Force a save of all metadata
    //

    try {

        if (m_pSegmentDatabase != 0) {
            WsbAffirmHr(StoreSegmentInformation());
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::SaveMetaData"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}


HRESULT CHsmServer::LoadPersistData( 
    void 
    )
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::LoadPersistData"), OLESTR(""));

    //
    // Create persistent collections and attempt to load from file
    //

    try {
        CComPtr<IWsbServer>    pWsbServer;
        CWsbStringPtr          tmpString;

        //  Create the collections
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, 0, CLSCTX_SERVER, 
                IID_IWsbIndexedCollection, (void **)&m_pJobs ));
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, 0, CLSCTX_SERVER, 
                IID_IWsbIndexedCollection, (void **)&m_pJobDefs ));
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, 0, CLSCTX_SERVER, 
                IID_IWsbIndexedCollection, (void **)&m_pPolicies ));
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmManagedResourceCollection, 0, CLSCTX_SERVER, 
                IID_IWsbIndexedCollection, (void **)&m_pManagedResources ));
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, 0, CLSCTX_SERVER, 
                IID_IWsbIndexedCollection, (void **)&m_pStoragePools ));
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, 0, CLSCTX_SERVER, 
                IID_IWsbIndexedCollection, (void **)&m_pMessages ));

        // Try to read from the persistence file
        // Note: currently Engine doesn't verify the service id in the Registry
        //  If Engine would ever start without an Fsa in the HSM server process - 
        //  this should be changed
        WsbAffirmHr(((IUnknown*) (IHsmServer*) this)->QueryInterface(IID_IWsbServer, 
                (void**) &pWsbServer));
        WsbAffirmHr(WsbServiceSafeInitialize(pWsbServer, FALSE, TRUE, &m_persistWasCreated));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::LoadPersistData"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}


HRESULT CHsmServer::SavePersistData( 
    void 
    )
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::SavePersistData"), OLESTR(""));

    if (FALSE == g_HsmSaveInProcess)  {
        g_HsmSaveInProcess  = TRUE;
        
        //
        // Force a save of all non-meta persistent data
        //
        hr = InternalSavePersistData();
        g_HsmSaveInProcess = FALSE;
    } else  {
        WsbTrace( OLESTR("Save already occurring - so wait"));
        while (TRUE == g_HsmSaveInProcess)  {
            //
            // Sleep a half a second then see if flag
            // is cleared.  We want to wait until the
            // save is done before returning.
            //
            Sleep(500);
        }
    }

    WsbTraceOut(OLESTR("CHsmServer::SavePersistData"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}



HRESULT
CHsmServer::FindHsmStoragePoolById(
    IN GUID StoragePoolId,
    OUT IHsmStoragePool** ppStoragePool
    )

/*++

Implements:

  IHsmServer::FindHsmStoragePoolById().

Routine Description:

    This routine implements the COM method for looking up an HSM (Engine) 
    Storage Pool object by the HSM Storage Pool id (a GUID).  If found, a 
    COM interface pointer to that object is returned.

    After using the Engine's stored pointer to an indexed collection of valid 
    storage pools to obtain an iterator (enumerator) to the collection, the 
    code searches the collection.  For each record it obtains that Storage
    Pool's interface pointer, which it uses to get that pool's id.  Once
    it finds the record whose Storage Pool id matches the HSM pool id
    passed in, it returns the interface pointer .

    Note that with Sakkara there is only 1 storage pool, so a match should be
    found on the first (and only) record.  However, the code is written to
    allow for future enhancements where there may be more than 1 storage pool.
     
Arguments:

    StoragePoolId - The HSM id (GUID) - as opposed to the NTMS id - for the 
            Storage Pool whose interface pointer is to be returned by this method.

    ppStoragePool - a pointer to the Storage Pool Interface Pointer which will
            be returned by this method.

Return Value:

    S_OK - The call succeeded (the specified storage pool record was found and
            its interface pointer was returned to the caller.

    Any other value - The call failed.  Generally this should only happen if
            a matching storage pool record is not found in the storage pool
            indexed collection (this error will return HR = 81000001, 'search
            of a collection failed', aka WSB_E_NOTFOUND).
            
--*/

{
// since this code is currently only used by the CopyMedia routines,
// reset the Tracing bit
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_COPYMEDIA

    HRESULT                     hr = S_OK;
    GUID                        poolId = GUID_NULL;
    CComPtr<IWsbEnum>           pEnum;
    CComPtr<IHsmStoragePool>    pStoragePool;


    WsbTraceIn(OLESTR("CHsmServer::FindHsmStoragePoolById"), 
                    OLESTR("StoragePoolId = <%ls>"), WsbGuidAsString(StoragePoolId));

    try {

        // ensure the OUT parameter pointer is valid 
        WsbAssert(0 != ppStoragePool, E_POINTER);

        // null out the interface pointer so garbage is not returned
        *ppStoragePool = 0;

        // obtain an iterator (enumerator) to the indexed storage pool collection
        // from the engine's stored storage pool pointer.
        WsbAffirmHr(m_pStoragePools->Enum(&pEnum));

        // get the first record in the collection.  Get that storage pool's id (GUID).
        WsbAffirmHr(pEnum->First(IID_IHsmStoragePool, (void**) &pStoragePool));
        WsbAffirmHr(pStoragePool->GetId(&poolId));

        // if the ids (GUIDs) don't match, iterate through the collection until
        // a match is found.  Note that no match being found will cause an error
        // to be thrown when the Next() call is made after reaching the end of the 
        // collection.
        while (poolId != StoragePoolId) {
            pStoragePool.Release();
            WsbAffirmHr(pEnum->Next(IID_IHsmStoragePool, (void**) &pStoragePool));
            WsbAffirmHr(pStoragePool->GetId(&poolId));
        }

        // Match found: return requested interface pointer after increasing COM
        // ref count 
        *ppStoragePool = pStoragePool;
        if (pStoragePool != 0)  {
            (*ppStoragePool)->AddRef();
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::FindHsmStoragePoolById"), 
                                        OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);

// leaving CopyMedia code, so reset Tracing bit to the Hsm Engine
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG

}



HRESULT
CHsmServer::FindHsmStoragePoolByMediaSetId(
    IN GUID RmsMediaSetId,
    OUT IHsmStoragePool** ppStoragePool
    )

/*++

Implements:

  IHsmServer::FindHsmStoragePoolByMediaSetId().

Routine Description:

    This routine implements the COM method for looking up an HSM (Engine) 
    Storage Pool object by the remote media subsystem Media Set id (a GUID which 
    comes from NTMS in the case where tape is used as secondary storage).  If found, 
    a COM interface pointer to that object is returned.

    After using the Engine's stored pointer to an indexed collection of valid 
    storage pools to obtain an iterator (enumerator) to the collection, the 
    code searches the collection.  For each record it obtains that Storage
    Pool's interface pointer, which it uses to get that pool's media set id.  
    Once it finds the record whose Media Set (Storage Pool) id matches the media 
    set id passed in, it returns that record's interface pointer.

    Note that with Sakkara there is only 1 storage pool, so a match should be
    found on the first (and only) record.  However, the code is written to
    allow for future enhancements where there may be more than 1 storage pool.
     
Arguments:

    MediaSetId - The Remote Storage Subsystem id (GUID) - as opposed to the Engine's 
            local HSM id - for the Storage Pool (referred to by the subsystem as a 
            Media Set) whose interface pointer is to be returned by this method.

    ppStoragePool - a pointer to the Storage Pool Interface Pointer which will
            be returned by this method.

Return Value:

    S_OK - The call succeeded (the specified storage pool record was found and
            its interface pointer was returned to the caller).

    Any other value - The call failed.  Generally this should only happen if
            a matching storage pool record is not found in the storage pool
            indexed collection (this error will return HR = 81000001, 'search
            of a collection failed', aka WSB_E_NOTFOUND).
            
--*/

{
// since this code is currently only used by the CopyMedia routines,
// reset the Tracing bit
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_COPYMEDIA

    HRESULT                     hr = S_OK;
    GUID                        mediaSetId = GUID_NULL;
    CWsbBstrPtr                 mediaSetName;
    CComPtr<IWsbEnum>           pEnum;
    CComPtr<IHsmStoragePool>    pStoragePool;

    WsbTraceIn(OLESTR("CHsmServer::FindHsmStoragePoolByMediaSetId"), 
                    OLESTR("RmsMediaSetId = <%ls>"), WsbGuidAsString(RmsMediaSetId));

    try {

        // ensure OUT parameter is valid
        WsbAssert(0 != ppStoragePool, E_POINTER);

        // null out the returned interface pointer so garbage is not returned
        *ppStoragePool = 0;

        // obtain an iterator (enumerator) to the indexed storage pool collection
        WsbAffirmHr(m_pStoragePools->Enum(&pEnum));

        // Get first record in the collection and its Remote Storage Subsystem
        // Media Set GUID using its interface pointer.
        WsbAffirmHr(pEnum->First(IID_IHsmStoragePool, (void**) &pStoragePool));
        WsbAffirmHr(pStoragePool->GetMediaSet(&mediaSetId, &mediaSetName));

        // if the ids (GUIDs) don't match, iterate through the collection until
        // a match is found.  Note that no match being found will cause an error
        // to be thrown when the Next() call is made after reaching the end of the 
        // collection.
        while (mediaSetId != RmsMediaSetId) {
            pStoragePool.Release();
            WsbAffirmHr(pEnum->Next(IID_IHsmStoragePool, (void**) &pStoragePool));
            mediaSetName.Free();
            WsbAffirmHr(pStoragePool->GetMediaSet(&mediaSetId, &mediaSetName));
        }

        // Match found: return the requested interface pointer after increasing COM
        // ref count.
        *ppStoragePool = pStoragePool;
        if (pStoragePool != 0)  {
            (*ppStoragePool)->AddRef();
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::FindHsmStoragePoolByMediaSetId"), 
                                        OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);

// leaving CopyMedia code, so reset Tracing bit to the Hsm Engine
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG

}



HRESULT
CHsmServer::FindMediaIdByDescription(
    IN OLECHAR* description,
    OUT GUID* pMediaId
    )

/*++

Implements:

  IHsmServer::FindMediaIdByDescription().

Routine Description:

    This routine implements the COM method for looking up the secondary storage 
    master media's id (a GUID) by its description (display name).  Both the id and 
    description are fields stored in the Engine's MediaInfo database.  (The MediaInfo 
    database is actually a separate entity stored within the Engine's Segment database.)

    After opening the Engine's Segment database and getting the MediaInfo entity,
    the routine loops through the MediaInfo records to find the one whose Description 
    matches that passed into this method.  When it finds the matching record 
    it gets and returns that record's media id.  Any error conditions encountered
    result in the appropriate error HRESULT being thrown and returned to the caller.

Arguments:

    description - Originally called the media's 'name', then the 'display name', later 
            clarified to be the media's 'description', this is what is displayed in the 
            UI to identify the Remote Storage secondary storage (master) media.

    pMediaId - a pointer to the media's id (a GUID) for that media whose description 
            matches the one passed in as the first argument above.

Return Value:

    S_OK - The call succeeded (the specified media record was found and a pointer to
            its id was returned to the caller.

    E_POINTER - Returned if an invalid pointer was passed in as the 'pMediaId' argument.

    WSB_E_NOTFOUND - Value 81000001.  Returned if no media info record was found whose
            description matched the one passed in.

    Any other value - The call failed because one of the Remote Storage API calls 
            contained internally in this method failed.  The error value returned is
            specific to the API call which failed.
            
--*/

{
// since this code is currently only used by the CopyMedia routines,
// reset the Tracing bit from this source module's default setting
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_COPYMEDIA

    HRESULT                     hr = S_OK;
    CWsbStringPtr               mediaDescription;
    CComPtr<IWsbDbSession>      pDbSession;
    CComPtr<IMediaInfo>         pMediaInfo;

    WsbTraceIn( OLESTR("CHsmServer::FindMediaIdByDescription"), 
                    OLESTR("description = <%ls>"), description );

    try {

        // ensure OUT parameter is valid
        WsbAssert( pMediaId != 0, E_POINTER );

        // null out the returned value so garbage is not returned
        *pMediaId = GUID_NULL;

        // open Engine's Segment database 
        WsbAffirmHr(m_pSegmentDatabase->Open(&pDbSession));

        try {

            // get an interface pointer to the MediaInfo entity (records) in the
            // Segment database.
            WsbAffirmHr(m_pSegmentDatabase->GetEntity( pDbSession, HSM_MEDIA_INFO_REC_TYPE,
                                        IID_IMediaInfo, (void**) &pMediaInfo ));

            // Get the first media record and its description
            WsbAffirmHr( pMediaInfo->First() );
            WsbAffirmHr( pMediaInfo->GetDescription( &mediaDescription, 0 ) );

            // Iterate through all media records until a record is found with a matching   
            // description.  Since an architectural feature of HSM is that all 
            // descriptions (display names) are unique, even across storage pools, 
            // a match means we found the media record we want.  Note that no match 
            // being found will cause an error to be thrown when the Next() call is 
            // made after reaching the last media record.

            // check for description (display name) match (CASE INSENSITIVE)
            while ( _wcsicmp( description, mediaDescription ) != 0 ) {
                WsbAffirmHr( pMediaInfo->Next() );
                WsbAffirmHr( pMediaInfo->GetDescription( &mediaDescription, 0 ));
            }

            // We found the record we want.  Get that media's id for return
            WsbAffirmHr( pMediaInfo->GetId( pMediaId ));

        } WsbCatch (hr); // 'try' to get MediaInfo entity and main processing body

        // close the database
        WsbAffirmHr( m_pSegmentDatabase->Close( pDbSession ));

    } WsbCatch (hr); // 'try' to open the Segment database

    // Done.  Interface pointers used above are singly assigned smart pointers so 
    // don't explicitly Release() them.  They will do auto-garbage collection.
    
    WsbTraceOut(OLESTR("CHsmServer::FindMediaIdByDescription"), 
                        OLESTR("hr = <%ls>, media id = <%ls>"), 
                            WsbHrAsString(hr), WsbGuidAsString(*pMediaId));

    return(hr);

// leaving CopyMedia code, reset Tracing bit to Hsm Engine (default for this module)
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG

}



HRESULT
CHsmServer::FindStoragePoolByName(
    IN OLECHAR* name,
    OUT IHsmStoragePool** ppStoragePool
    )

/*++

Implements:

  IHsmServer::FindStoragePoolByName().

--*/
{
// since this code is currently only used by the CopyMedia routines,
// reset the Tracing bit
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_COPYMEDIA

    HRESULT                     hr = S_OK;
    GUID                        id;
    CWsbStringPtr               storagePoolName;
    CComPtr<IWsbCollection>     pCollection;
    CComPtr<IWsbEnum>           pEnum;
    CComPtr<IHsmStoragePool>    pStoragePool;

    WsbTraceIn(OLESTR("CHsmServer::FindStoragePoolByName"), OLESTR("name = <%ls>"), name);

    try {

        WsbAssert(0 != ppStoragePool, E_POINTER);

        *ppStoragePool = 0;

        WsbAffirmHr(m_pStoragePools->QueryInterface(IID_IWsbCollection, (void**) &pCollection));
        WsbAffirmHr(pCollection->Enum(&pEnum));

        WsbAffirmHr(pEnum->First(IID_IHsmStoragePool, (void**) &pStoragePool));
        WsbAffirmHr(pStoragePool->GetMediaSet(&id, &storagePoolName));

        while (_wcsicmp(name, storagePoolName) != 0) {
            pStoragePool = 0;
            WsbAffirmHr(pEnum->Next(IID_IHsmStoragePool, (void**) &pStoragePool));
            storagePoolName.Free();
            WsbAffirmHr(pStoragePool->GetMediaSet(&id, &storagePoolName));
        }

        *ppStoragePool = pStoragePool;
        if (pStoragePool != 0)  {
            (*ppStoragePool)->AddRef();
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::FindStoragePoolByName"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);

// leaving CopyMedia code, so reset Tracing bit to the Hsm Engine
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG

}



HRESULT CHsmServer::GetStoragePools(
    IWsbIndexedCollection  **ppCollection
    )
{
    HRESULT hr = S_OK;

    //
    // If the pools have been loaded, return the pointer. Otherwise, 
    // fail.
    try {
        WsbAssert(0 != ppCollection, E_POINTER);
        *ppCollection = m_pStoragePools;
        WsbAffirm(m_pStoragePools != 0, E_FAIL);
        m_pStoragePools.p->AddRef();
    } WsbCatch(hr);

    return (hr);
}


HRESULT CHsmServer::GetOnlineInformation(
    IWsbIndexedCollection  **ppCollection
    )
{
    HRESULT hr = S_OK;

    //
    // If the online information has been loaded, return it
    // Otherwise, fail.
    try {
        WsbAssert(0 != ppCollection, E_POINTER);
        *ppCollection = m_pOnlineInformation;
        WsbAffirm(m_pOnlineInformation != 0, E_FAIL);
        m_pOnlineInformation.p->AddRef();
    } WsbCatch(hr);

    return (hr);
}

HRESULT CHsmServer::GetMountingMedias(
    IWsbIndexedCollection  **ppCollection
    )
{
    HRESULT hr = S_OK;

    try {
        WsbAssert(0 != ppCollection, E_POINTER);
        *ppCollection = m_pMountingMedias;
        WsbAffirm(m_pMountingMedias != 0, E_FAIL);
        m_pMountingMedias.p->AddRef();
    } WsbCatch(hr);

    return (hr);
}



HRESULT CHsmServer::GetMessages(
    IWsbIndexedCollection  **ppCollection
    )
{
    HRESULT hr = S_OK;

    //
    // If messages have been loaded, return them.
    // Otherwise, fail.
    try {
        WsbAssert(0 != ppCollection, E_POINTER);
        *ppCollection = m_pMessages;
        WsbAffirm(m_pMessages != 0, E_FAIL);
        m_pMessages.p->AddRef();
    } WsbCatch(hr);

    return (hr);
}


HRESULT CHsmServer::GetUsrToNotify(
    IWsbIndexedCollection** /*ppCollection*/
    )
{
    return E_NOTIMPL;
}


HRESULT CHsmServer::GetJobs(
    IWsbIndexedCollection  **ppCollection
    )
{
    HRESULT hr = S_OK;

    //
    // If the jobs have been loaded, return the pointer. Otherwise, 
    // fail.
    try {
        WsbAssert(0 != ppCollection, E_POINTER);
        *ppCollection = m_pJobs;
        WsbAffirm(m_pJobs != 0, E_FAIL);
        m_pJobs.p->AddRef();
    } WsbCatch(hr);

    return (hr);
}

HRESULT
CHsmServer::FindJobByName(
    IN OLECHAR* name,
    OUT IHsmJob** ppJob
    )

/*++

Implements:

  IHsmServer::FindJobByName().

--*/
{
    HRESULT                     hr = S_OK;
    CWsbStringPtr               jobName;
    CComPtr<IWsbCollection>     pCollection;
    CComPtr<IWsbEnum>           pEnum;
    CComPtr<IHsmJob>            pJob;

    WsbTraceIn(OLESTR("CHsmServer::FindJobByName"), OLESTR("name = <%ls>"), name);

    try {

        WsbAssert(0 != ppJob, E_POINTER);

        *ppJob = 0;

        WsbAffirmHr(m_pJobs->QueryInterface(IID_IWsbCollection, (void**) &pCollection));
        WsbAffirmHr(pCollection->Enum(&pEnum));

        hr = pEnum->First(IID_IHsmJob, (void**) &pJob);
        while (S_OK == hr) {
            WsbAffirmHr(pJob->GetName(&jobName, 0));
            WsbTrace(OLESTR("CHsmServer::FindJobByName: name = <%ls>\n"), 
                    jobName);

            if (_wcsicmp(name, jobName) == 0) break;
            pJob = 0;
            hr = pEnum->Next(IID_IHsmJob, (void**) &pJob);
        }

        if (S_OK == hr) {
            *ppJob = pJob;
            if (pJob != 0)  {
                (*ppJob)->AddRef();
            }
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::FindJobByName"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT CHsmServer::GetJobDefs(
    IWsbIndexedCollection  **ppCollection
    )
{
    HRESULT hr = S_OK;

    //
    // If the job definitions have been loaded, return the pointer. Otherwise, 
    // fail.
    try {
        WsbAssert(0 != ppCollection, E_POINTER);
        *ppCollection = m_pJobDefs;
        WsbAffirm(m_pJobDefs != 0, E_FAIL);
        m_pJobDefs.p->AddRef();
    } WsbCatch(hr);

    return (hr);
}


HRESULT CHsmServer::GetMediaRecs(
    IWsbIndexedCollection  **ppCollection
    )
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::GetMediaRecs"), OLESTR(""));

    try {
        HRESULT                        hr2;
        CComPtr<IWsbIndexedCollection> pCol;
        CComPtr<IWsbDbSession>         pDbSes;
        CComPtr<IWsbDbEntity>          pRec;

        WsbAffirm(m_pSegmentDatabase != 0, E_FAIL);
        WsbAssert(0 != ppCollection, E_POINTER);
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, 0, CLSCTX_SERVER, 
                IID_IWsbIndexedCollection, (void **)&pCol ));

        WsbAffirmHr(m_pSegmentDatabase->Open(&pDbSes));
        WsbAffirmHr(m_pSegmentDatabase->GetEntity(pDbSes, HSM_MEDIA_INFO_REC_TYPE, 
                IID_IWsbDbEntity, (void**)&pRec));

        //  Loop over records in DB and copy to collection
        hr2 = pRec->First();
        while(S_OK == hr2) {
            CComPtr<IMediaInfo>      pCopy;
            CComPtr<IMediaInfo>      pOrig;
            GUID                     MediaId;
            GUID                     MediaSubsystemId; 
            GUID                     StoragePoolId; 
            LONGLONG                 FreeBytes; 
            LONGLONG                 Capacity; 
            HRESULT                  LastError; 
            short                    NextRemoteDataSet; 
            OLECHAR *                pDescription = NULL; 
            HSM_JOB_MEDIA_TYPE       Type;
            OLECHAR *                pName = NULL;
            BOOL                     ReadOnly;
            FILETIME                 Update;
            LONGLONG                 LogicalValidBytes;
            BOOL                     Recreate;

            //  Create a copy for the collection
            WsbAffirmHr(CoCreateInstance(CLSID_CMediaInfo, NULL, CLSCTX_ALL, 
                IID_IMediaInfo, (void**) &pCopy));

            //  Copy data
            WsbAffirmHr(pRec->QueryInterface(IID_IMediaInfo, (void**)&pOrig));
            WsbAffirmHr(pOrig->GetMediaInfo(&MediaId, &MediaSubsystemId, 
                    &StoragePoolId, &FreeBytes, &Capacity, &LastError, &NextRemoteDataSet, 
                    &pDescription, 0, &Type, &pName,  0, &ReadOnly, &Update, &LogicalValidBytes,
                    &Recreate));
            WsbTrace(OLESTR("CHsmServer::GetMediaRecs: after GetMediaInfo\n"));
            WsbAffirmHr(pCopy->SetMediaInfo(MediaId, MediaSubsystemId, 
                    StoragePoolId, FreeBytes, Capacity, LastError, NextRemoteDataSet, 
                    pDescription, Type, pName, ReadOnly, Update, LogicalValidBytes,
                    Recreate));
            WsbTrace(OLESTR("CHsmServer::GetMediaRecs: after SetMediaInfo\n"));
            if (pDescription) {
                WsbFree(pDescription);
                pDescription = NULL;
            }
            if (pName) {
                WsbFree(pName);
                pName = NULL;
            }

            WsbAffirmHr(pCol->Add(pCopy));

            hr2 = pRec->Next();
        }
        WsbAffirm(WSB_E_NOTFOUND == hr2, hr2);

        *ppCollection = pCol;
        pCol.p->AddRef();
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::GetMediaRecs"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return (hr);
}


HRESULT CHsmServer::GetPolicies(
    IWsbIndexedCollection  **ppCollection
    )
{
    HRESULT hr = S_OK;

    //
    // If the policies have been loaded, return the pointer. Otherwise, 
    // fail.
    try {
        WsbAssert(0 != ppCollection, E_POINTER);
        *ppCollection = m_pPolicies;
        WsbAffirm(m_pPolicies != 0, E_FAIL);
        m_pPolicies.p->AddRef();
    } WsbCatch(hr);

    return (hr);
}


HRESULT CHsmServer::GetActions(
    IWsbIndexedCollection** /*ppCollection*/
    )
{
    return E_NOTIMPL;
}


HRESULT CHsmServer::GetCriteria(
    IWsbIndexedCollection** /*ppCollection*/
    )
{
    return E_NOTIMPL;
}


HRESULT CHsmServer::GetSegmentDb(
    IWsbDb **ppDb
    )
{
    HRESULT hr = S_OK;

    //
    // If the segment table has been created, return the pointer. Otherwise, 
    // fail.
    try {
        WsbAssert(0 != ppDb, E_POINTER);
        WsbAffirm(m_pSegmentDatabase != 0, E_FAIL);
        *ppDb = m_pSegmentDatabase;
        m_pSegmentDatabase.p->AddRef();
    } WsbCatch(hr);

    return (hr);
}


HRESULT CHsmServer::GetHsmFsaTskMgr(
    IHsmFsaTskMgr  **ppHsmFsaTskMgr
    )
{
    HRESULT hr = S_OK;

    //
    // If the Task Manager has been created, return the pointer. Otherwise, 
    // fail.
    try {
        WsbAssert(0 != ppHsmFsaTskMgr, E_POINTER);
        *ppHsmFsaTskMgr = m_pHsmFsaTskMgr;
        WsbAffirm(m_pHsmFsaTskMgr != 0, E_FAIL);
        m_pHsmFsaTskMgr.p->AddRef();
    } WsbCatch(hr);

    return (hr);
}


HRESULT 
CHsmServer::CreateInstance ( 
    REFCLSID rclsid, 
    REFIID riid, 
    void **ppv 
    )
{
    HRESULT     hr = S_OK;
    
    hr = CoCreateInstance( rclsid, NULL, CLSCTX_SERVER, riid, ppv );

    return hr;
}


HRESULT CHsmServer::FinalConstruct(
    )
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::FinalConstruct"), OLESTR(""));

    //
    // Initialize member data
    //
    m_pRssWriter = NULL;
    m_savingEvent = NULL;
    m_terminateEvent = NULL;
    m_hId = GUID_NULL;
    m_initializationCompleted = FALSE;
    m_persistWasCreated = FALSE;
    m_mediaCount = 0;
    m_copyfilesUserLimit = DEFAULT_COPYFILES_USER_LIMIT;
    m_autosaveThread = 0;
    m_CheckManagedResourcesThread = 0;
    m_cancelCopyMedia = FALSE;
    m_inCopyMedia = FALSE;
    m_Suspended = FALSE;
    m_JobsEnabled = TRUE;


    try {
        m_bCritSecCreated = FALSE;
        WsbAffirmStatus(InitializeCriticalSectionAndSpinCount(&m_JobDisableLock, 1000));
        if (! InitializeCriticalSectionAndSpinCount(&m_MountingMediasLock, 1000)) {
            DWORD dwErr = GetLastError();               
            hr = HRESULT_FROM_WIN32(dwErr);    
            DeleteCriticalSection(&m_JobDisableLock);
            WsbAffirmHr(hr);             
        }
        m_bCritSecCreated = TRUE;

        WsbAffirmHr(CWsbPersistable::FinalConstruct( ));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::FinalConstruct"), OLESTR("hr = <%ls>\n"), WsbHrAsString(hr));
    return( hr );
}


void CHsmServer::FinalRelease(
    )
{
    WsbTraceIn(OLESTR("CHsmServer::FinalRelease"), OLESTR(""));

    if (TRUE == m_initializationCompleted)  {
        HSM_SYSTEM_STATE SysState;

        SysState.State = HSM_STATE_SHUTDOWN;
        ChangeSysState(&SysState);
    } else {
        WsbTrace(OLESTR("CHsmServer::FinalRelease not saving persistent information.\n"));
    }

    // Let the parent class do his thing.   
    CWsbPersistable::FinalRelease();

    if (m_bCritSecCreated) {
        DeleteCriticalSection(&m_JobDisableLock);
        DeleteCriticalSection(&m_MountingMediasLock);
    }

    // Free String members
    // Note: Member objects held in smart-pointers are freed when the 
    // smart-pointer destructor is being called (as part of this object destruction)
    m_name.Free();
    m_dir.Free();
    m_dbPath.Free();

    if (m_terminateEvent != NULL) {
        CloseHandle(m_terminateEvent);
        m_terminateEvent = NULL;
    }

    // Cleanup the writer
    if (m_pRssWriter != NULL) {
        m_pRssWriter->Terminate();
        delete m_pRssWriter;
        m_pRssWriter = NULL;
    }

    // Clean up database system
    if (m_pDbSys != NULL) {
        m_pDbSys->Terminate();
    }

    if (m_savingEvent != NULL) {
        CloseHandle(m_savingEvent);
        m_savingEvent = NULL;
    }

    WsbTraceOut(OLESTR("CHsmServer::FinalRelease"), OLESTR(""));
}


HRESULT
CHsmServer::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_HsmServer;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT CHsmServer::Init(
    void
    )
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::Init"),OLESTR(""));
    
    try  {
        CComPtr<IPersistFile>  pPersistFile;
        DWORD                  threadId;
        CWsbStringPtr          tmpString;
        LUID                   backupValue;
        HANDLE                 tokenHandle;
        TOKEN_PRIVILEGES       newState;
        DWORD                  lErr;
        HANDLE                 pHandle;

        // Get our Name
        WsbAffirmHr(WsbGetComputerName(m_name));

        // Set the build and database parameters
        WsbAffirmHr(WsbGetMetaDataPath(m_dbPath));
        m_databaseVersion = ENGINE_CURRENT_DB_VERSION;
        m_buildVersion = RS_BUILD_VERSION;

        // Set the autosave parameters.
        m_autosaveInterval = DEFAULT_AUTOSAVE_INTERVAL;
        m_autosaveThread = 0;
        
        // Enable the backup operator privilege.  This is required to insure that we 
        // have full access to all resources on the system.
        pHandle = GetCurrentProcess();
        WsbAffirmStatus(OpenProcessToken(pHandle, MAXIMUM_ALLOWED, &tokenHandle));

        // adjust backup token privileges
        WsbAffirmStatus(LookupPrivilegeValueW(NULL, L"SeBackupPrivilege", &backupValue));
        newState.PrivilegeCount = 1;
        newState.Privileges[0].Luid = backupValue;
        newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        WsbAffirmStatus(AdjustTokenPrivileges(tokenHandle, FALSE, &newState, (DWORD)0, NULL, NULL));

        // Note that AdjustTokenPrivileges may return success even if it did not assign all privileges.
        // We check last error here to insure everything was set.
        if ((lErr = GetLastError()) != ERROR_SUCCESS) {
            // Not backup user or some other error
            //
            // TODO: Should we fail here or just log something?
            WsbLogEvent( HSM_MESSAGE_SERVICE_UNABLE_TO_SET_BACKUP_PRIVILEGE, 0, NULL,
                         WsbHrAsString(HRESULT_FROM_WIN32(lErr)), NULL );
        }

        WsbAffirmStatus(LookupPrivilegeValueW(NULL, L"SeRestorePrivilege", &backupValue));
        newState.PrivilegeCount = 1;
        newState.Privileges[0].Luid = backupValue;
        newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        WsbAffirmStatus(AdjustTokenPrivileges(tokenHandle, FALSE, &newState, (DWORD)0, NULL, NULL));

        // Note that AdjustTokenPrivileges may return success even if it did not assign all privileges.
        // We check last error here to insure everything was set.
        if ((lErr = GetLastError()) != ERROR_SUCCESS) {
            // Not backup user or some other error
            //
            // TODO: Should we fail here or just log something?
            WsbLogEvent( HSM_MESSAGE_SERVICE_UNABLE_TO_SET_RESTORE_PRIVILEGE, 0, NULL,
                         WsbHrAsString(HRESULT_FROM_WIN32(lErr)), NULL );
        }
        CloseHandle(tokenHandle);

        // Create the Writer
        m_pRssWriter = new CRssJetWriter;
        WsbAffirm(NULL != m_pRssWriter, E_OUTOFMEMORY);

        // Open the event that synchronize saving of persistent data with snapshots
        // (Event should already exist - it is created in the CRssJetWriter constructor
        WsbAffirmHandle(m_savingEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, HSM_ENGINE_STATE_EVENT));

        //
        // Create one instance of the Media Server Interface 
        // (It must be created before the persistent data is loaded.
        //
        WsbTrace(OLESTR("Creating Rsm Server member.\n"));
        WsbAffirmHr(CoCreateInstance(CLSID_CRmsServer, NULL, CLSCTX_SERVER,
                                     IID_IRmsServer, (void**)&m_pHsmMediaMgr));

        //
        // Load the persistent information
        //
        WsbTrace(OLESTR("Loading Persistent Information.\n"));
        WsbAffirmHr(LoadPersistData());

        // Create mounting-medias collection - Note: this collection is not persistent!
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, 0, CLSCTX_SERVER, 
                            IID_IWsbIndexedCollection, (void **)&m_pMountingMedias));

        // Initialize the Media Server object
        WsbAffirmHr(m_pHsmMediaMgr->InitializeInAnotherThread());
        
        // Initialize the IDB system for this process
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbDbSys, NULL, CLSCTX_SERVER, 
                IID_IWsbDbSys, (void**) &m_pDbSys));
        WsbAffirmHr(GetIDbPath(&tmpString, 0));
        WsbAffirmHr(m_pDbSys->Init(tmpString, IDB_SYS_INIT_FLAG_FULL_LOGGING));

        // Start automatic backup of DBs
        WsbAffirmHr(m_pDbSys->Backup(NULL, IDB_BACKUP_FLAG_AUTO));
        
        // Initialize Rss Writer
        WsbAffirmHr(m_pRssWriter->Init());
        
        WsbTrace(OLESTR("Loading Segment Information.\n"));
        WsbAffirmHr(LoadSegmentInformation());

        WsbAffirmHr(CreateDefaultJobs());        
        WsbTrace(OLESTR("CreateDefaultJobs OK\n"));
        
        //
        // Create one instance of the Hsm Task Manager Interface and one instance
        // of the Hsm Fsa Task Manager Interface
        //
        WsbTrace(OLESTR("Creating Task Manager.\n"));
        WsbAffirmHr(CoCreateInstance( CLSID_CHsmTskMgr, 0, CLSCTX_SERVER, 
                                      IID_IHsmFsaTskMgr, (void **)&m_pHsmFsaTskMgr ));
        WsbAffirmHr(m_pHsmFsaTskMgr->Init((IUnknown*) (IHsmServer*) this));

        // 
        // Tell the world that we are here
        //
        // Currently, avoid publishing HSM in the AD - if this becomes necessary, 
        // remove the comments from the following code
        //
/***        WsbAffirmHr(HsmPublish (HSMCONN_TYPE_HSM, m_name, m_hId, m_name, CLSID_HsmServer ));
        WsbTrace(OLESTR("Published OK\n"));         ***/

        // Create termination event for auto-backup thread
        WsbAffirmHandle((m_terminateEvent = CreateEvent(NULL, FALSE, FALSE, NULL)));

        // If the autosave interval is non-zero, start the autosave thread
        if (m_autosaveInterval) {
            ULONG  interval = m_autosaveInterval;

            WsbAffirm(0 == m_autosaveThread, E_FAIL);
            m_autosaveInterval = 0;

            //  Trick SetAutosave into starting the thread
            WsbAffirmHr(SetAutosave(interval));
        }

        m_initializationCompleted = TRUE;

        //  Start a thread that will check on the managed resources. This is done
        //  as a separate thread because the Resource code can call back into this
        //  process and hang the FSA and the Engine since the Engine code hasn't
        //  gotten to it's message loop yet.
        WsbAssert(m_CheckManagedResourcesThread == 0, E_UNEXPECTED);
        WsbAffirm((m_CheckManagedResourcesThread = CreateThread(0, 0, HsmengStartCheckManagedResources, 
                (void*) this, 0, &threadId)) != 0, HRESULT_FROM_WIN32(GetLastError()));
        
    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmServer::Init"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return( hr );
}

HRESULT
CHsmServer::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::GetSizeMax"), OLESTR(""));

    try {
    
        WsbAssert(0 != pSize, E_POINTER);
        pSize->QuadPart = 2000000;
    
    } WsbCatch( hr );
    
    WsbTraceOut(OLESTR("CHsmServer::GetSizeMax"), OLESTR("hr = <%ls>, size = <%ls>"), 
        WsbHrAsString(hr), WsbPtrToUliAsString(pSize));
    
    return( hr );
}    

HRESULT
CHsmServer::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::Load"), OLESTR(""));

    try {
        
        WsbAssert(0 != pStream, E_POINTER);
        //
        // Make sure these are in the same order as Save
        //
        // Make sure this is the right version of the database to load
        //
        ULONG tmpDatabaseVersion;
        WsbAffirmHr(WsbLoadFromStream(pStream, &tmpDatabaseVersion));
        if (tmpDatabaseVersion == ENGINE_WIN2K_DB_VERSION) {
            // We are upgrading from an older version of the database
            WsbLogEvent( HSM_MESSAGE_DATABASE_VERSION_UPGRADE, 0, NULL, WsbQuickString(WsbPtrToUlongAsString(&m_databaseVersion)),
                         WsbQuickString(WsbPtrToUlongAsString(&tmpDatabaseVersion)), NULL );
        } else if (tmpDatabaseVersion != m_databaseVersion)  {
            //
            // The database version this server is expecting does not
            // match that of the saved database - so error out.
            WsbLogEvent( HSM_MESSAGE_DATABASE_VERSION_MISMATCH, 0, NULL, WsbQuickString(WsbPtrToUlongAsString(&m_databaseVersion)),
                         WsbQuickString(WsbPtrToUlongAsString(&tmpDatabaseVersion)), NULL );
            WsbThrow(HSM_E_DATABASE_VERSION_MISMATCH);
        }
        //
        // Now read in the build version but don't do anything with it.  It is in the
        // databases for dump programs to display
        //
        ULONG tmpBuildVersion;
        WsbAffirmHr(WsbLoadFromStream(pStream, &tmpBuildVersion));
        
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_hId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_autosaveInterval));
        if (tmpDatabaseVersion == ENGINE_WIN2K_DB_VERSION) {
            LONGLONG mediaCount;
            WsbAffirmHr(WsbLoadFromStream(pStream, &mediaCount));
            m_mediaCount = (LONG)mediaCount;
            m_copyfilesUserLimit = DEFAULT_COPYFILES_USER_LIMIT;
        } else {
            WsbAffirmHr(WsbLoadFromStream(pStream, &m_mediaCount));
            WsbAffirmHr(WsbLoadFromStream(pStream, &m_copyfilesUserLimit));
        }

        WsbTrace(OLESTR("Loading Jobs.\n"));
        WsbAffirmHr(LoadJobs(pStream));
        
        WsbTrace(OLESTR("Loading Job Definitions.\n"));
        WsbAffirmHr(LoadJobDefs(pStream));
        
        WsbTrace(OLESTR("Loading Policies.\n"));
        WsbAffirmHr(LoadPolicies(pStream));
        
        WsbTrace(OLESTR("Loading Managed Resources.\n"));
        WsbAffirmHr(LoadManagedResources(pStream));
        
        WsbTrace(OLESTR("Loading Storage Pools.\n"));
        WsbAffirmHr(LoadStoragePools(pStream));
        
        WsbTrace(OLESTR("Loading Messages.\n"));
        WsbAffirmHr(LoadMessages(pStream));

        WsbTrace(OLESTR("Loading Media Manager objects.\n"));
        if (tmpDatabaseVersion == ENGINE_WIN2K_DB_VERSION) {
            // Special procedure for upgrading a Win2K media manager data, which is located in a separate file
            CComPtr<IHsmUpgradeRmsDb> pUpgrade;
            CComPtr<IPersistFile>  pServerPersist;
            CWsbStringPtr   rmsDbName; 

            WsbAffirmHr(CoCreateInstance(CLSID_CHsmUpgradeRmsDb, NULL, CLSCTX_SERVER,
                                 IID_IHsmUpgradeRmsDb, (void**)&pUpgrade));
            WsbAffirmHr(pUpgrade->Init(m_pHsmMediaMgr));
            WsbAffirmHr(pUpgrade->QueryInterface(IID_IPersistFile, (void **)&pServerPersist));
            rmsDbName = m_dbPath;
            WsbAffirmHr(rmsDbName.Append(RMS_WIN2K_PERSIST_FILE));
            hr = WsbSafeLoad(rmsDbName, pServerPersist, FALSE);
            if (WSB_E_NOTFOUND == hr) {
                // In case of upgrade, the Rms database must be there
                hr = WSB_E_SERVICE_MISSING_DATABASES;
            }
            WsbAffirmHr(hr);
        } else {
            CComPtr<IPersistStream> pIStream;
            WsbAffirmHr(m_pHsmMediaMgr->QueryInterface(IID_IPersistStream, (void **)&pIStream));
            WsbAffirmHr(pIStream->Load(pStream));
        }

    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CHsmServer::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmServer::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        //  Make sure these are in the same order as Load
        
        WsbAffirmHr(WsbSaveToStream(pStream, m_databaseVersion));
        WsbAffirmHr(WsbSaveToStream(pStream, m_buildVersion));
        
        WsbAffirmHr(WsbSaveToStream(pStream, m_hId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_autosaveInterval));
        WsbAffirmHr(WsbSaveToStream(pStream, m_mediaCount));
        WsbAffirmHr(WsbSaveToStream(pStream, m_copyfilesUserLimit));

        WsbTrace(OLESTR("Storing Jobs.\n"));
        WsbAffirmHr(StoreJobs(pStream));
        
        WsbTrace(OLESTR("Storing Job Definitions.\n"));
        WsbAffirmHr(StoreJobDefs(pStream));
        
        WsbTrace(OLESTR("Storing Policies.\n"));
        WsbAffirmHr(StorePolicies(pStream));
        
        WsbTrace(OLESTR("Storing Managed Resources.\n"));
        WsbAffirmHr(StoreManagedResources(pStream));
        
        WsbTrace(OLESTR("Storing Storage Pools.\n"));
        WsbAffirmHr(StoreStoragePools(pStream));
        
        WsbTrace(OLESTR("Storing Messages.\n"));
        WsbAffirmHr(StoreMessages(pStream));

        WsbTrace(OLESTR("Storing Media Manager objects.\n"));
        CComPtr<IPersistStream> pIStream;
        WsbAffirmHr(m_pHsmMediaMgr->QueryInterface(IID_IPersistStream, (void **)&pIStream));
        WsbAffirmHr(pIStream->Save(pStream, clearDirty));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CHsmServer::SaveAll(
    void
    )

/*++

Implements:

  IwsbServer::SaveAll

Return Value:
    S_OK     - Success
    S_FALSE  - Already saving
    Other    - Error

--*/
{

    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::SaveAll"), OLESTR(""));

    try {
        WsbAffirm(!g_HsmSaveInProcess, S_FALSE);
        g_HsmSaveInProcess = TRUE;
        hr = InternalSavePersistData();
        g_HsmSaveInProcess = FALSE;

        // call Media Server SaveAll
        WsbAffirmHr(m_pHsmMediaMgr->SaveAll());
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::SaveAll"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}
        
        

HRESULT
CHsmServer::GetNextMedia(
    LONG *pNextMedia
    )

/*++

Implements:

  IHsmServer::GetNextMedia().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::GetNextMedia"), OLESTR(""));
    
    try {
        WsbAssert(0 != pNextMedia, E_POINTER);
        
        //  Always increment media count
        //  If prior scratch mount failed, the mounting component should save the id that
        //  it got on the first call
        //  NOTE:  One possible consequence is that if a job fails mounting scratch (one time 
        //  or more) and gives up, one increment has already done, hence skipping one number.
        *pNextMedia = InterlockedIncrement(&m_mediaCount);

        //
        // We want to make sure we never reuse this count so
        // save it now
        //
        WsbAffirmHr(SavePersistData());

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::GetNextMedia"), OLESTR("hr = <%ls>, nextMedia = <%ls>"), 
                        WsbHrAsString(hr), WsbPtrToLongAsString(pNextMedia));

    return(hr);
}



HRESULT 
CHsmServer::CreateTask(
    IN const OLECHAR *          jobName,
    IN const OLECHAR *          jobParameters,
    IN const OLECHAR *          jobComments,
    IN const TASK_TRIGGER_TYPE  jobTriggerType,
    IN const WORD               jobStartHour,
    IN const WORD               jobStartMinute,
    IN const BOOL               scheduledJob
    )

/*++

Implements:

  IHsmServer::CreateTask().

Routine Description:

    This routine implements the Engine's COM method for creating a task (aka job) in the 
    NT Task Scheduler.  If the task is to be run on a scheduled basis, that schedule
    will be set.  If the task is a disabled task (does not run on a scheduled basis), 
    it will be run at the end of this method.

    The method creates a Task Scheduler object, which is first used to delete any old
    task with the same name as the one about to be created, and then to create the new
    task (aka job).  The rest of the method deals with setting the various fields in 
    the NT Task Scheduler needed to run the job.  The logic is straight forward, except
    possibly for the code dealing with the Task Trigger.  
    
    The Task Trigger is a struct defined in the 'mstask.idl' file (nt\public\sdk\inc) 
    which is used to set the schedule for a scheduled task.  (Note it is not used for 
    a disabled, or non-scheduled, job, since that type of job only runs once (at the end 
    of this method).)  While a number of scheduling options are defined, this method 
    only supports 5 of the 8 defined.  See 'jobTriggerType' in the 'Arguments' section, 
    and 'E_INVALIDARG' in the 'Return Value' section below for a listing of which options 
    are, and are not, supported.  Also note that a filled-out Task Trigger structure can 
    not be passed to this method as an argument since a Task Trigger is non-marshallable 
    (by virtue of containing a simple union field).  (This is why 3 of the fields 
    contained within the Task Trigger struct are passed as args.)  

    Note that this method does not create a job object in the HSM Engine.  If a job
    needs to be created, it is the caller's responsibility to do so.

Arguments:

    jobName - The fully formatted task name as it will appear in the NT Task Scheduler UI.
                It is the caller's responsibility to build/format this string prior to
                calling this method.  Can not be NULL.

    jobParameters - The fully formatted parameter string for the program the task will
                invoke.  For Sakkara the invoked program is RsLaunch.  'jobParameters'
                is the string added to the RsLaunch command line which specifies the
                Remote Storage job to run (e.g., 'run manage').  Can not be NULL.

    jobComments - The fully formatted comments string as it will appear in the NT Task 
                Scheduler UI.  Can be null.

    jobTriggerType - The value which specifies to the Task Scheduler the frequency with
                which to run a scheduled task.  For scheduled tasks, used to build the
                Task Trigger structure.  (Not used for non-scheduled (one time only) 
                tasks.)  Supported values are 'TASK_TIME_TRIGGER_ONCE', 
                'TASK_TIME_TRIGGER_DAILY', 'TASK_TIME_TRIGGER_ON_IDLE', 
                'TASK_TIME_TRIGGER_AT_SYSTEMSTART', and 'TASK_TIME_TRIGGER_AT_LOGON'.
                See return value 'E_INVALIDARG' below for a list of non-supported options.

    jobStartHour - The value which specifies to the Task Scheduler the hour at which to
                start a scheduled task.  For scheduled tasks, used to build the Task 
                Trigger structure.  (Not used for non-scheduled (one time only) tasks.)

    jobStartMinute - The value which specifies to the Task Scheduler the minutes past 
                the hour at which to start a scheduled task.  For scheduled tasks, used 
                to build the Task Trigger structure.  (Not used for non-scheduled (one 
                time only) tasks.)

    scheduledJob - A Boolean which indicates whether or not the task to be created is to 
                run as a scheduled task, or as a one time only task.  One time only tasks 
                are run immediately at the end of this method.

Return Value:

    S_OK - The call succeeded (the specified task was created (and run, in the case of
                one time only tasks) in NT Task Scheduler).

    E_INVALIDARG - Either an invalid (not supported by this method) or non-existent 
                'jobTriggerType' value was passed into this method.  Non-supported values
                are 'TASK_TIME_TRIGGER_WEEKLY', 'TASK_TIME_TRIGGER_MONTHLYDATE', and
                'TASK_TIME_TRIGGER_MONTHLYDOW'.  Supported values are listed in argument
                'jobTriggerType' above.

    E_POINTER - Either the 'jobName' or 'jobParameters' argument was passed as NULL.

    Any other value - The call failed because one of the Remote Storage API calls 
                contained internally in this method failed.  The error value returned is
                specific to the API call which failed.
            
--*/

{
// The below 'define' statement is used to control conditional compilation of the code
// which sets the account info in NT Task Scheduler.  Once Task Scheduler is fixed to 
// not need a specific user name and password to run a task, simply remove or comment 
// out this statement.

    HRESULT hr = S_OK;
    CComPtr<ITaskScheduler>     pTaskScheduler;
    CComPtr<ITask>              pTask;
    CComPtr<IPersistFile>       pPersist;
    DWORD                       TaskFlags;


    WsbTraceIn(OLESTR("CHsmServer::CreateTask"), 
        OLESTR("jobName = <%ls>, jobParameters = <%ls>, jobComments = <%ls>, "
                L"jobTriggerType = <%d>, jobStartHour = <%d>, jobStartMinute = <%d>, "
                L"scheduledJob = <%ls>"), jobName, jobParameters, jobComments,
                jobTriggerType, jobStartHour, jobStartMinute, 
                WsbBoolAsString( scheduledJob ) );

    try {

        WsbAffirmPointer( jobName );
        WsbAffirmPointer( jobParameters );
        
        // Create a Task Scheduler object, which defaults to pointing to this computer's
        // NT Task Scheduler.
        WsbAffirmHr( CoCreateInstance( CLSID_CTaskScheduler, 0, CLSCTX_SERVER,
                        IID_ITaskScheduler, (void **) &pTaskScheduler ) );

        // Delete any old job with the same name from the scheduler, if it exists.
        // Ignore error.
        pTaskScheduler->Delete( jobName );

        // Create the new job in the scheduler
        WsbAffirmHr( pTaskScheduler->NewWorkItem( jobName, CLSID_CTask, IID_ITask, 
                                                (IUnknown**)&pTask ) );

        CWsbStringPtr appName;
        WsbAffirmHr(appName.LoadFromRsc(_Module.m_hInst, IDS_PRODUCT_NAME));

        // Set the Creator field for the task
        WsbAffirmHr( pTask->SetCreator( appName ) );

        // Branch on whether or not the task is to run by schedule
        if ( scheduledJob ) {

            CComPtr<ITaskTrigger>       pTrigger;
            WORD                        triggerNumber;
            TASK_TRIGGER                taskTrigger;
            SYSTEMTIME                  sysTime;

            // create Trigger scheduling object for the job 
            WsbAffirmHr( pTask->CreateTrigger( &triggerNumber, &pTrigger ) );
        
            // Zero out Task Trigger struct contents, then init its structure size field
            memset( &taskTrigger, 0, sizeof( taskTrigger ) );
            taskTrigger.cbTriggerSize = sizeof( taskTrigger );

            // Set up schedule for the job in the Task Trigger struct
            GetSystemTime( &sysTime );
            taskTrigger.wBeginYear   = sysTime.wYear;
            taskTrigger.wBeginMonth  = sysTime.wMonth;
            taskTrigger.wBeginDay    = sysTime.wDay;

            taskTrigger.wStartHour   = jobStartHour;
            taskTrigger.wStartMinute = jobStartMinute;

            taskTrigger.TriggerType  = jobTriggerType;

            // Finish setting schedule info based on case, reject non-supported cases
            switch ( jobTriggerType )
            {
            case TASK_TIME_TRIGGER_DAILY: 
                {
                taskTrigger.Type.Daily.DaysInterval = 1;
                }
                break;

            // these are supported cases that need no further set up
            case TASK_TIME_TRIGGER_ONCE: 
            case TASK_EVENT_TRIGGER_ON_IDLE: 
            case TASK_EVENT_TRIGGER_AT_SYSTEMSTART: 
            case TASK_EVENT_TRIGGER_AT_LOGON: 
                {
                }
                break;

            // non-supported cases
            case TASK_TIME_TRIGGER_WEEKLY: 
            case TASK_TIME_TRIGGER_MONTHLYDATE: 
            case TASK_TIME_TRIGGER_MONTHLYDOW: 
                {
                WsbTrace( 
                OLESTR("(CreateTask) Job Trigger Type passed <%d> is invalid (see mstask.idl)\n"),
                                                        jobTriggerType );
                WsbThrow( E_INVALIDARG );
                }
                break;

            default: 
                {
                WsbTrace( 
                OLESTR("(CreateTask) Nonexistent Job Trigger Type passed <%d> (see mstask.idl)\n"),
                                                        jobTriggerType );
                WsbThrow( E_INVALIDARG );
                }
            }

            // Set the job schedule
            WsbAffirmHr( pTrigger->SetTrigger( &taskTrigger ) );
        }

        // Note that for Disabled (non-scheduled) tasks, there is no need to 'SetFlags()'
        // on the task (pTask) to 'TASK_FLAG_DISABLED'.  In fact, this method will hang 
        // for an undetermined reason if you do issue that call.

        // Below steps finish creating an entry for NT Task Scheduler

        // Set the program that the Scheduler is to run (for Sakkara this is RsLaunch)
        WsbAffirmHr( pTask->SetApplicationName( WSB_FACILITY_LAUNCH_NAME ) );

        // Put the job name in as the task parameter - for Sakkara this is how RsLaunch
        // knows which job to run.
        WsbAffirmHr( pTask->SetParameters( jobParameters ) );

        // Set the comments field for the task
        WsbAffirmHr( pTask->SetComment( jobComments ) );

        // Set Task Scheduler account info by passing nulls
        WsbAffirmHr( pTask->SetAccountInformation( OLESTR(""), NULL ) );

        // Set the SYSTEM_REQUIRED flag to deal with standby/sleep mode
        WsbAffirmHr(pTask->GetTaskFlags(&TaskFlags));
        TaskFlags |= TASK_FLAG_SYSTEM_REQUIRED;
        WsbAffirmHr(pTask->SetTaskFlags(TaskFlags));

        // Save the scheduled task
        WsbAffirmHr( pTask->QueryInterface( IID_IPersistFile, (void**)&pPersist ) );
        WsbAffirmHr( pPersist->Save( 0, 0 ) );

        // If this is not a scheduled job, run it now
        if ( !scheduledJob ) {
            WsbAffirmHr( pTask->Run() );
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CHsmServer::CreateTask", L"hr = <%ls>", WsbHrAsString( hr ) );

    return( hr );
}


HRESULT 
CHsmServer::CreateTaskEx(
    IN const OLECHAR *          jobName,
    IN const OLECHAR *          jobParameters,
    IN const OLECHAR *          jobComments,
    IN const TASK_TRIGGER_TYPE  jobTriggerType,
    IN const SYSTEMTIME         runTime,
    IN const DWORD              runOccurrence,
    IN const BOOL               scheduledJob
    )

/*++

Implements:

  IHsmServer::CreateTaskEx().

Routine Description:

    This routine implements the Engine's COM method for creating a task (aka job) in the 
    NT Task Scheduler.  If the task is to be run on a scheduled basis, that schedule
    will be set.  If the task is a disabled task (does not run on a scheduled basis), 
    it will be run at the end of this method.

    The method creates a Task Scheduler object, which is first used to delete any old
    task with the same name as the one about to be created, and then to create the new
    task (aka job).  The rest of the method deals with setting the various fields in 
    the NT Task Scheduler needed to run the job.  The logic is straight forward, except
    possibly for the code dealing with the Task Trigger.  
    
    The Task Trigger is a struct defined in the 'mstask.idl' file (nt\public\sdk\inc) 
    which is used to set the schedule for a scheduled task.  (Note it is not used for 
    a disabled, or non-scheduled, job, since that type of job only runs once (at the end 
    of this method).)  While a number of scheduling options are defined, this method 
    only supports 5 of the 8 defined.  See 'jobTriggerType' in the 'Arguments' section, 
    and 'E_INVALIDARG' in the 'Return Value' section below for a listing of which options 
    are, and are not, supported.  Also note that a filled-out Task Trigger structure can 
    not be passed to this method as an argument since a Task Trigger is non-marshallable 
    (by virtue of containing a simple union field).  (This is why 3 of the fields 
    contained within the Task Trigger struct are passed as args.)  

    Note that this method does not create a job object in the HSM Engine.  If a job
    needs to be created, it is the caller's responsibility to do so.

Arguments:

    jobName - The fully formatted task name as it will appear in the NT Task Scheduler UI.
                It is the caller's responsibility to build/format this string prior to
                calling this method.  Can not be NULL.

    jobParameters - The fully formatted parameter string for the program the task will
                invoke.  For Sakkara the invoked program is RsLaunch.  'jobParameters'
                is the string added to the RsLaunch command line which specifies the
                Remote Storage job to run (e.g., 'run manage').  Can not be NULL.

    jobComments - The fully formatted comments string as it will appear in the NT Task 
                Scheduler UI.  Can be null.

    jobTriggerType - The value which specifies to the Task Scheduler the frequency with
                which to run a scheduled task.  For scheduled tasks, used to build the
                Task Trigger structure.  (Not used for non-scheduled (one time only) 
                tasks.)  Supported values are 'TASK_TIME_TRIGGER_ONCE', 
                'TASK_TIME_TRIGGER_DAILY', TASK_TIME_TRIGGER_WEEKLY ,
                TASK_TIME_TRIGGER_MONTHLYDATE, 'TASK_TIME_TRIGGER_ON_IDLE', 
                'TASK_TIME_TRIGGER_AT_SYSTEMSTART', and 'TASK_TIME_TRIGGER_AT_LOGON'.
                See return value 'E_INVALIDARG' below for a list of non-supported options.

    runTime      - Time when the job should be scheduled

    runOccurrence - Occurrence for the job should to be scheduled, relevant for several trigger types

    scheduledJob - A Boolean which indicates whether or not the task to be created is to 
                run as a scheduled task, or as a one time only task.  One time only tasks 
                are run immediately at the end of this method.

Return Value:

    S_OK - The call succeeded (the specified task was created (and run, in the case of
                one time only tasks) in NT Task Scheduler).

    E_INVALIDARG - Either an invalid (not supported by this method) or non-existent 
                'jobTriggerType' value was passed into this method.  Non-supported values
                are 'TASK_TIME_TRIGGER_WEEKLY', 'TASK_TIME_TRIGGER_MONTHLYDATE', and
                'TASK_TIME_TRIGGER_MONTHLYDOW'.  Supported values are listed in argument
                'jobTriggerType' above.

    E_POINTER - Either the 'jobName' or 'jobParameters' argument was passed as NULL.

    Any other value - The call failed because one of the Remote Storage API calls 
                contained internally in this method failed.  The error value returned is
                specific to the API call which failed.
            
--*/

{
// The below 'define' statement is used to control conditional compilation of the code
// which sets the account info in NT Task Scheduler.  Once Task Scheduler is fixed to 
// not need a specific user name and password to run a task, simply remove or comment 
// out this statement.

    HRESULT hr = S_OK;
    CComPtr<ITaskScheduler>     pTaskScheduler;
    CComPtr<ITask>              pTask;
    CComPtr<IPersistFile>       pPersist;
    DWORD                       TaskFlags;


    WsbTraceIn(OLESTR("CHsmServer::CreateTaskEx"), 
        OLESTR("jobName = <%ls>, jobParameters = <%ls>, jobComments = <%ls>, "
                L"jobTriggerType = <%d>, jobStartHour = <%d>, jobStartMinute = <%d>, "
                L"scheduledJob = <%ls>"), jobName, jobParameters, jobComments,
                jobTriggerType, runTime.wHour, runTime.wMinute, 
                WsbBoolAsString( scheduledJob ) );

    try {

        WsbAffirmPointer( jobName );
        WsbAffirmPointer( jobParameters );
        
        // Create a Task Scheduler object, which defaults to pointing to this computer's
        // NT Task Scheduler.
        WsbAffirmHr( CoCreateInstance( CLSID_CTaskScheduler, 0, CLSCTX_SERVER,
                        IID_ITaskScheduler, (void **) &pTaskScheduler ) );

        // Delete any old job with the same name from the scheduler, if it exists.
        // Ignore error.
        pTaskScheduler->Delete( jobName );

        // Create the new job in the scheduler
        WsbAffirmHr( pTaskScheduler->NewWorkItem( jobName, CLSID_CTask, IID_ITask, 
                                                (IUnknown**)&pTask ) );

        CWsbStringPtr appName;
        WsbAffirmHr(appName.LoadFromRsc(_Module.m_hInst, IDS_PRODUCT_NAME));

        // Set the Creator field for the task
        WsbAffirmHr( pTask->SetCreator( appName ) );

        // Branch on whether or not the task is to run by schedule
        if ( scheduledJob ) {

            CComPtr<ITaskTrigger>       pTrigger;
            WORD                        triggerNumber;
            TASK_TRIGGER                taskTrigger;

            // create Trigger scheduling object for the job 
            WsbAffirmHr( pTask->CreateTrigger( &triggerNumber, &pTrigger ) );
        
            // Zero out Task Trigger struct contents, then init its structure size field
            memset( &taskTrigger, 0, sizeof( taskTrigger ) );
            taskTrigger.cbTriggerSize = sizeof( taskTrigger );

            // Set up schedule for the job in the Task Trigger struct
            taskTrigger.wBeginYear   = runTime.wYear;
            taskTrigger.wBeginMonth  = runTime.wMonth;
            taskTrigger.wBeginDay    = runTime.wDay;

            taskTrigger.wStartHour   = runTime.wHour;
            taskTrigger.wStartMinute = runTime.wMinute;

            taskTrigger.TriggerType  = jobTriggerType;

            // Finish setting schedule info based on case, reject non-supported cases
            switch ( jobTriggerType )
            {
            case TASK_TIME_TRIGGER_DAILY: 
                {
                taskTrigger.Type.Daily.DaysInterval = (WORD)runOccurrence;
                }
                break;

            case TASK_TIME_TRIGGER_WEEKLY: 
                {
                taskTrigger.Type.Weekly.WeeksInterval = (WORD)runOccurrence;
                switch (runTime.wDayOfWeek) {
                case 0:
                    taskTrigger.Type.Weekly.rgfDaysOfTheWeek = TASK_SUNDAY;
                    break;
                case 1:
                    taskTrigger.Type.Weekly.rgfDaysOfTheWeek = TASK_MONDAY;
                    break;
                case 2:
                    taskTrigger.Type.Weekly.rgfDaysOfTheWeek = TASK_TUESDAY;
                    break;
                case 3:
                    taskTrigger.Type.Weekly.rgfDaysOfTheWeek = TASK_WEDNESDAY;
                    break;
                case 4:
                    taskTrigger.Type.Weekly.rgfDaysOfTheWeek = TASK_THURSDAY;
                    break;
                case 5:
                    taskTrigger.Type.Weekly.rgfDaysOfTheWeek = TASK_FRIDAY;
                    break;
                case 6:
                    taskTrigger.Type.Weekly.rgfDaysOfTheWeek = TASK_SATURDAY;
                    break;
                }
                }
                break;

            case TASK_TIME_TRIGGER_MONTHLYDATE: 
                {
                WsbAssert(runTime.wDay < 32, E_INVALIDARG);
                taskTrigger.Type.MonthlyDate.rgfDays = (1 << (runTime.wDay-1));
                taskTrigger.Type.MonthlyDate.rgfMonths = (TASK_JANUARY | TASK_FEBRUARY | TASK_MARCH |TASK_APRIL | 
                                                          TASK_MAY | TASK_JUNE |TASK_JULY | TASK_AUGUST |
                                                          TASK_SEPTEMBER | TASK_OCTOBER | TASK_NOVEMBER | TASK_DECEMBER);
                }
                break;

            case TASK_EVENT_TRIGGER_ON_IDLE: 
                {
                WORD wIdle, wTemp;
                WsbAffirmHr(pTask->GetIdleWait(&wIdle, &wTemp));
                wIdle = (WORD)runOccurrence;
                WsbAffirmHr(pTask->SetIdleWait(wIdle, wTemp));
                }

            // these are supported cases that need no further set up
            case TASK_TIME_TRIGGER_ONCE: 
            case TASK_EVENT_TRIGGER_AT_SYSTEMSTART: 
            case TASK_EVENT_TRIGGER_AT_LOGON: 
                {
                }
                break;

            // non-supported cases
            case TASK_TIME_TRIGGER_MONTHLYDOW: 
                {
                WsbTrace( 
                OLESTR("(CreateTaskEx) Job Trigger Type passed <%d> is invalid (see mstask.idl)\n"),
                                                        jobTriggerType );
                WsbThrow( E_INVALIDARG );
                }
                break;

            default: 
                {
                WsbTrace( 
                OLESTR("(CreateTaskEx) Nonexistent Job Trigger Type passed <%d> (see mstask.idl)\n"),
                                                        jobTriggerType );
                WsbThrow( E_INVALIDARG );
                }
            }

            // Set the job schedule
            WsbAffirmHr( pTrigger->SetTrigger( &taskTrigger ) );
        }

        // Note that for Disabled (non-scheduled) tasks, there is no need to 'SetFlags()'
        // on the task (pTask) to 'TASK_FLAG_DISABLED'.  In fact, this method will hang 
        // for an undetermined reason if you do issue that call.

        // Below steps finish creating an entry for NT Task Scheduler

        // Set the program that the Scheduler is to run (for Sakkara this is RsLaunch)
        WsbAffirmHr( pTask->SetApplicationName( WSB_FACILITY_LAUNCH_NAME ) );

        // Put the job name in as the task parameter - for Sakkara this is how RsLaunch
        // knows which job to run.
        WsbAffirmHr( pTask->SetParameters( jobParameters ) );

        // Set the comments field for the task
        WsbAffirmHr( pTask->SetComment( jobComments ) );

        // Set Task Scheduler account info by passing nulls
        WsbAffirmHr( pTask->SetAccountInformation( OLESTR(""), NULL ) );

        // Set the SYSTEM_REQUIRED flag to deal with standby/sleep mode
        WsbAffirmHr(pTask->GetTaskFlags(&TaskFlags));
        TaskFlags |= TASK_FLAG_SYSTEM_REQUIRED;
        WsbAffirmHr(pTask->SetTaskFlags(TaskFlags));

        // Save the scheduled task
        WsbAffirmHr( pTask->QueryInterface( IID_IPersistFile, (void**)&pPersist ) );
        WsbAffirmHr( pPersist->Save( 0, 0 ) );

        // If this is not a scheduled job, run it now
        if ( !scheduledJob ) {
            WsbAffirmHr( pTask->Run() );
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CHsmServer::CreateTaskEx", L"hr = <%ls>", WsbHrAsString( hr ) );

    return( hr );
}


HRESULT
CHsmServer::CancelCopyMedia(
    void
    )

/*++

Implements:

  IHsmServer::CancelCopyMedia().

Routine Description:

    Cancel any active media copy operations (synchronize copy or recreate master).

Arguments:

    None.

Return Value:

    S_OK    - The call succeeded.

    S_FALSE - No media copy operation is active.
            
--*/

{
// since this code is currently only used by the CopyMedia routines,
// reset the Tracing bit
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_COPYMEDIA

    HRESULT                         hr = S_OK;


    WsbTraceIn( OLESTR("CHsmServer::CancelCopyMedia"), 
            OLESTR("m_inCopyMedia = %ls, m_cancelCopyMedia = %ls"),
            WsbQuickString(WsbBoolAsString(m_inCopyMedia)), 
            WsbQuickString(WsbBoolAsString(m_cancelCopyMedia)));

    Lock();
    if (m_inCopyMedia) {
        m_cancelCopyMedia = TRUE;
    } else {
        hr = S_FALSE;
    }
    Unlock();
    
    WsbTraceOut(OLESTR("CHsmServer::CancelCopyMedia"), OLESTR("hr = <%ls>"),
            WsbHrAsString(hr));

    return(hr);

// leaving CopyMedia code, so reset Tracing bit to the Hsm Engine
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG

}


HRESULT
CHsmServer::MarkMediaForRecreation(
    IN REFGUID masterMediaId
    )

/*++

Implements:

  IHsmServer::MarkMediaForRecreation().

Routine Description:

    This routine implements the Engine's COM method for marking a master media for re-creation
    Should we mark such a media as Recall Only as well ?

Arguments:

    masterMediaId - The id (GUID) for the master media to be marked.

Return Value:

    S_OK - The call succeeded (the specified master media was marked).

    Any other value - The call failed because one of the Remote Storage API calls 
            contained internally in this method failed.  The error value returned is
            specific to the API call which failed.
            
--*/

{
// since this code is currently only used by the CopyMedia routines,
// reset the Tracing bit
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_COPYMEDIA

    HRESULT                         hr = S_OK;
    CComPtr<IMediaInfo>             pMediaInfo;
    CComPtr<IWsbDbSession>          pDbSession;


    WsbTraceIn( OLESTR("CHsmServer::MarkMediaForRecreation"), 
                        OLESTR("masterMediaId = <%ls>"), WsbGuidAsString(masterMediaId) );

    // no event logging since this method is presently for development use only
    
    try {

        // open the Engine's Segment database
        WsbAffirmHr( m_pSegmentDatabase->Open( &pDbSession ));

        try {

            // get an interface pointer to the MediaInfo records (entity) in the
            // Segment database
            WsbAffirmHr( m_pSegmentDatabase->GetEntity( pDbSession, 
                                        HSM_MEDIA_INFO_REC_TYPE, IID_IMediaInfo, 
                                        (void**) &pMediaInfo ));

            // get the MediaInfo database record for the master media we will mark for 
            // re-creation
            WsbAffirmHr( pMediaInfo->SetId( masterMediaId ));
            WsbAffirmHr( pMediaInfo->FindEQ());

            // mark this media for re-creation and as read only
            WsbAffirmHr( pMediaInfo->SetRecreate( TRUE ) );
/***        WsbAffirmHr( pMediaInfo->RecreateMaster() ); TEMPORARY: Call this one instead for marking as Read Only as well  ***/

            // write updated record into the database
            WsbAffirmHr( pMediaInfo->Write());

        } WsbCatch(hr); // inner 'try' - get media info entity and process

        WsbAffirmHr( m_pSegmentDatabase->Close(pDbSession));

    } WsbCatch(hr); // 'try' to open the database

    // processing is done.  The singly-assigned smart interface pointers will auto-garbage
    // collect themselves.
    
    WsbTraceOut(OLESTR("CHsmServer::MarkMediaForRecreation"), OLESTR("hr = <%ls>"), 
                                                                WsbHrAsString(hr));

    return(hr);

// leaving CopyMedia code, so reset Tracing bit to the Hsm Engine
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG

}



HRESULT
CHsmServer::RecreateMaster(
    IN REFGUID masterMediaId,
    IN USHORT  copySet
    )

/*++

Implements:

  IHsmServer::RecreateMaster().

Routine Description:

    This routine implements the COM method for replacing (re-creating) a secondary
    storage original (master) media.  To replace the master, a duplicate is made of
    the copy specified.  The master record for that media in the Engine's 
    MediaInfo database is then updated to point to the 're-created' master (duplicated
    media).  For safety purposes all re-created masters are marked 'read only' if
    the copy was not up to date with the original master.  
    Because of the potential for data loss (if the most recent copy is not up to date 
    with the original master which is being re-created), the user (System Administrator) 
    is urged to run a Validate job against the appropriate volume (via the UI) after 
    re-creating any master.

    After opening the Segment database (a single database containing all Engine
    database tables), getting the MediaInfo (remote storage master media) records 
    (entity) and connecting to the RMS subsystem, the method gets the media record
    corresponding to the master to be re-created.  It then checks that the specified
    copy exists for that master.  After ensuring the copy exists,
    a 're-created master' is made by duplicating the that copy.  The 
    database info for the media record is then updated to point to the newly 're-created' 
    master media.  The method then cleans up (i.e., closes the database) and returns.

Arguments:

    masterMediaId - The id (GUID) for the master media which is to be re-created.

    copySet       - The copyset number of the copy to use or zero, which means use the
                    most recent copy.

Return Value:

    S_OK - The call succeeded (the specified master media was re-created from the
            specified copy media).

    HSM_E_RECREATE_FLAG_WRONGVALUE - Returned if the 'recreate' flag for the master
            media record whose id was passed in, indicating it is to be recreated,
            is not set properly.  (The UI is supposed to set it to TRUE prior to
            calling this method via RsLaunch.)

    HSM_E_NO_COPIES_CONFIGURED - Returned if no copies have been configured or created
            for the master which is to be recreated.  Without a valid copy we can not
            recreate a master secondary storage media.

    HSM_E_NO_COPIES_EXIST - Returned if copies have been configured but they either
            haven't been created yet, or had previously been created but the System
            Administrator deleted them via UI action.

    WSB_E_NOTFOUND - Value 81000001.  Returned if no storage pool record was found whose
            id matched the one contained in the media record.

    HSM_E_BUSY - Another media copy operation was already in progress.

    HSM_E_WORK_SKIPPED_CANCELLED - Operation was cancelled.

    Any other value - The call failed because one of the Remote Storage API calls 
            contained internally in this method failed.  The error value returned is
            specific to the API call which failed.
            
--*/

{
// since this code is currently only used by the CopyMedia routines,
// reset the Tracing bit
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_COPYMEDIA

    HRESULT                         hr = S_OK;
    HRESULT                         currentLastError      = S_OK;
    BOOL                            haveMasterMediaRecord = FALSE;
    BOOL                            recreateMaster        = FALSE;
    BOOL                            currentRecallOnly     = FALSE;
    BOOL                            newRecallOnly         = FALSE;
    SHORT                           currentNextRemoteDataSet = 0;
    SHORT                           copyNextRemoteDataSet    = 0;
    SHORT                           lastKnownGoodMasterNextRemoteDataSet = 0;
    USHORT                          maxSets        = 0;
    GUID                            poolId                  = GUID_NULL;
    GUID                            newMasterId             = GUID_NULL;
    GUID                            mediaSetId              = GUID_NULL;
    GUID                            currentMediaId          = GUID_NULL;
    GUID                            currentMediaSubsystemId = GUID_NULL;
    GUID                            lastKnownGoodMasterId   = GUID_NULL;
    GUID                            copyMediaSubsystemId    = GUID_NULL;
    LONGLONG                        newFreeBytes            = 0;
    LONGLONG                        currentFreeBytes        = 0;
    LONGLONG                        currentLogicalValidBytes = 0;
    LONGLONG                        newCapacity             = 0;
    LONGLONG                        currentCapacity         = 0;
    FILETIME                        copyUpdate;
    FILETIME                        currentUpdate;
    FILETIME                        lastKnownGoodMasterUpdate;
    CComPtr<IHsmStoragePool>        pPool;
    CComPtr<IMediaInfo>             pMediaInfo;
    CComPtr<IRmsCartridge>          pNewMasterMedia;
    CComPtr<IRmsCartridge>          pCopyMedia;
    CComPtr<IWsbDbSession>          pDbSession;
    CWsbStringPtr                   currentName;
    CWsbStringPtr                   currentDescription;
    CWsbStringPtr                   copyDescription;
    CWsbBstrPtr                     copyDescriptionAsBstr;
    CWsbBstrPtr                     mediaSetName;
    CWsbBstrPtr                     newName;
    HSM_JOB_MEDIA_TYPE              currentType;


    WsbTraceIn( OLESTR("CHsmServer::RecreateMaster"), OLESTR("masterMediaId = <%ls>"), 
                                                    WsbGuidAsString(masterMediaId) );

    // log 'information' message
    WsbLogEvent( HSM_MESSAGE_RECREATE_MASTER_START, 0, NULL, NULL );
    
    try {
        BOOL                okToContinue = TRUE;

        //  Make sure we're not already busy & haven't been cancelled
        Lock();
        if (m_inCopyMedia) {
            okToContinue = FALSE;
        } else {
            m_inCopyMedia = TRUE;
        }
        Unlock();
        WsbAffirm(okToContinue, HSM_E_BUSY);
        WsbAffirm(!m_cancelCopyMedia, HSM_E_WORK_SKIPPED_CANCELLED);

        // open the Engine's Segment database 
        WsbAffirmHr( m_pSegmentDatabase->Open( &pDbSession ));

        try {

            // get an interface pointer to the MediaInfo records (entity) in the
            // Segment database
            WsbAffirmHr( m_pSegmentDatabase->GetEntity( pDbSession, 
                                        HSM_MEDIA_INFO_REC_TYPE, IID_IMediaInfo, 
                                        (void**) &pMediaInfo ));

            // get the MediaInfo db record for the master media we want to re-create
            WsbAffirmHr( pMediaInfo->SetId( masterMediaId ));
            WsbAffirmHr( pMediaInfo->FindEQ());
            haveMasterMediaRecord = TRUE;

            // to check if this master has in fact been marked for re-creation, get
            // the re-created flag value
            WsbAffirmHr( pMediaInfo->GetRecreate( &recreateMaster ));

            // do not proceed if re-created flag is not set
            if ( recreateMaster == FALSE ) {
                // log 'error' message and exit
                WsbLogEvent( HSM_MESSAGE_RECREATE_MASTER_INVALID_FLAG_VALUE, 
                                        0, NULL, NULL );
                WsbThrow( HSM_E_RECREATE_FLAG_WRONGVALUE );
            } 

            // recreateMaster flag is TRUE, so proceed to re-create...
            // Get the storage pool the master to be re-created belongs to.  We'll
            // use this pool to determine number of copy sets configured for this
            // media, and to specify what storage pool the 'new' (re-created) master
            // is to belong to.
            WsbAffirmHr( pMediaInfo->GetStoragePoolId( &poolId ));

            // Get the storage pool object.
            hr = FindHsmStoragePoolById( poolId, &pPool );
            if (S_OK != hr) {
                // log the returned error and throw the error
                WsbLogEvent( HSM_MESSAGE_SEARCH_STGPOOL_BY_HSMID_ERROR,
                                        0, NULL, WsbHrAsString(hr), NULL );
                WsbThrow( hr );
            }

            // get the number of copy sets configured for this pool
            WsbAffirmHr( pPool->GetNumMediaCopies( &maxSets ));
            // if none have been configured by SysAdmin, error out
            WsbAffirm( maxSets > 0, HSM_E_NO_COPIES_CONFIGURED );

            // If the copySet number was specified, make sure it is valid
            WsbAffirm(((copySet == 0) || (copySet <= maxSets)), E_INVALIDARG);

            // If the copySet was not specified, determine
            // which copy belonging to this master is most recent, otherwise
            // get information about specified copy.

            if (copySet == 0) {
                USHORT    mostRecentCopy = 0;
                USHORT    mostDataSets = 0;
                FILETIME  mostRecentCopyUpdate = WsbLLtoFT(0);

                // set invalid value for validity testing (testing if any media
                // copies exist)
                mostRecentCopy = (USHORT)( maxSets + 1 );

                // loop through the configured copy sets
                for (copySet = 1; copySet <= maxSets; copySet++ ) {
                    //
                    // We use the NextDataSet count to determine most recent copy.
                    //
                    WsbAffirmHr(pMediaInfo->GetCopyNextRemoteDataSet(copySet, 
                                                                    &copyNextRemoteDataSet));

                    if (copyNextRemoteDataSet > mostDataSets)  {

                        //
                        // We need to make sure this copy is available.
                        //

                        WsbAffirmHr(pMediaInfo->GetCopyMediaSubsystemId(copySet, 
                                                                        &copyMediaSubsystemId));

                        try {

                            //
                            // Check the copy to make sure it exists and is enabled.
                            //
                            WsbAffirm(copyMediaSubsystemId != GUID_NULL, E_FAIL);
                            pCopyMedia = 0;
                            WsbAffirmHr(m_pHsmMediaMgr->FindCartridgeById(copyMediaSubsystemId, &pCopyMedia));

                            CComQIPtr<IRmsComObject, &IID_IRmsComObject> pCartCom = pCopyMedia;
                            WsbAffirmPointer(pCartCom);
                            if( S_OK == pCartCom->IsEnabled( ) ) {

                                //
                                // This copy is more recent, and available, so save info
                                //
                                WsbAffirmHr(pMediaInfo->GetCopyUpdate(copySet, &copyUpdate));

                                // set the NextRemoteDataSet to this copy's count
                                mostDataSets = copyNextRemoteDataSet;

                                // capture copy number, and update time
                                mostRecentCopy = copySet;
                                mostRecentCopyUpdate = copyUpdate;

                            }

                        } WsbCatchAndDo(hr,
                                hr = S_OK;
                            );

                    }
                } // end 'for' loop

                // Check to be sure there was a copy.  If not, error out.
                WsbAffirm( ((maxSets + 1) > mostRecentCopy), HSM_E_NO_COPIES_EXIST );

                copySet = mostRecentCopy;
                copyUpdate = mostRecentCopyUpdate;
            } else {
                WsbAffirmHr(pMediaInfo->GetCopyMediaSubsystemId(copySet, &copyMediaSubsystemId));
                WsbAffirm(copyMediaSubsystemId != GUID_NULL, HSM_E_NO_COPY_EXISTS);
                WsbAffirmHr(pMediaInfo->GetCopyUpdate(copySet, &copyUpdate));
            }

            WsbTrace(OLESTR("Source for re-creation:  copySet number = %d; version: %ls\n"),
                                copySet, WsbFiletimeAsString(FALSE, copyUpdate) );

            // Check to see if we are going to loose data because of re-creating 
            // the master.
            
            // !!! IMPORTANT NOTE - bmd !!!
            //
            // We need to handle the case where we are recreating multiple times
            // from out of sync copies.  The last known good master always holds the info
            // of the master in its last known good state.  We are looking at the update
            // timestamp which represent the version of the master or copy.  The dataset
            // number may be one more than what is store with the last known good master
            // because of the particular logic required to handle partial/incomplete data sets:
            // a) either the data set was written, but not committed, or b) the data set was started,
            // but data was actually written.


            CWsbStringPtr      name;
            CWsbStringPtr      description;

            GUID        unusedGuid1;
            GUID        unusedGuid2;  // NOTE: Use multiples so the trace in GetLastKnownGoodMasterInfo works
            LONGLONG    unusedLL1;
            LONGLONG    unusedLL2;    // NOTE: Use multiples so the trace in GetLastKnownGoodMasterInfo works
            BOOL        lastKnownGoodMasterRecallOnly;
            HRESULT     lastKnownGoodMasterLastError;
            HSM_JOB_MEDIA_TYPE unusedJMT;

            // Get date the original master was last updated, this is stored with
            // the last known good master.

            WsbAffirmHr(pMediaInfo->GetLastKnownGoodMasterInfo(
                &unusedGuid1, &lastKnownGoodMasterId, &unusedGuid2,
                &unusedLL1, &unusedLL2,
                &lastKnownGoodMasterLastError, &description, 0, &unusedJMT, &name, 0,
                &lastKnownGoodMasterRecallOnly,
                &lastKnownGoodMasterUpdate,
                &lastKnownGoodMasterNextRemoteDataSet));

            name.Free( );
            description.Free( );

            // If the original master is newer than the most 
            // recent copy...  (it should not be possible for the master
            //                  to be older than a copy!)
            if (CompareFileTime(&lastKnownGoodMasterUpdate, &copyUpdate) != 0)  {
                // ...we may lose data, so log it.
                WsbLogEvent( HSM_MESSAGE_RECREATE_MASTER_COPY_OLD, 0, NULL, NULL );
            }

            // Set up done.  Now get/build necessary parameters for the call
            // to actually duplicate the most recent copy onto scratch media.  
            // This copy will be the re-created master.
            WsbAffirmHr(pMediaInfo->GetCopyMediaSubsystemId(copySet, 
                                                            &copyMediaSubsystemId));

            // Get copy description from RSM database since we don't cache it in
            //  RSS database anymore (Windows Bugs 407340)
            pCopyMedia = 0;
            WsbAffirmHr(m_pHsmMediaMgr->FindCartridgeById(copyMediaSubsystemId, &pCopyMedia));
            WsbAffirmHr(pCopyMedia->GetDescription(&copyDescriptionAsBstr));

            // Something simple for now.
            copyDescriptionAsBstr.Prepend(OLESTR("RM-"));

            // get the media set the storage pool contains so we assign the
            // re-created master to the proper media set
            WsbAffirmHr( pPool->GetMediaSet( &mediaSetId, &mediaSetName ));

            // Parameters built.  Call HSM subsystem to copy the most recent copy 
            // onto scratch media
            WsbAffirm(!m_cancelCopyMedia, HSM_E_WORK_SKIPPED_CANCELLED);
            GUID firstSideId = GUID_NULL;
            WsbAffirmHrOk(m_pHsmMediaMgr->DuplicateCartridge(copyMediaSubsystemId, 
                                                        firstSideId, &newMasterId, mediaSetId, 
                                                        copyDescriptionAsBstr,
                                                        &newFreeBytes, &newCapacity,
                                                        RMS_DUPLICATE_RECYCLEONERROR));

            // now that a replacement master media has been created, prepare
            // to update the master media info in the database

            // first get an interface pointer to the new re-created master 
            WsbAffirmHr(m_pHsmMediaMgr->FindCartridgeById(newMasterId, &pNewMasterMedia));

            // Get re-created master's label name.  Note that if secondary
            // storage is tape, this 'name' is the tape's bar code.  For
            // other media (e.g., optical) this is a name.
            WsbAffirmHr(pNewMasterMedia->GetName(&newName));

            // Get Next Remote Data Set value from the copy.  Used by the Validate
            // job to determine what bags are on a master, it will be carried 
            // forward to the re-created master.
            WsbAffirmHr(pMediaInfo->GetCopyNextRemoteDataSet(copySet, 
                                                            &copyNextRemoteDataSet));

            // get current master media info since some fields will not change
            WsbAffirmHr(pMediaInfo->GetMediaInfo( &currentMediaId, 
                                                    &currentMediaSubsystemId,
                                                    &poolId, &currentFreeBytes,
                                                    &currentCapacity, 
                                                    &currentLastError,
                                                    &currentNextRemoteDataSet,
                                                    &currentDescription, 0, 
                                                    &currentType, &currentName, 0, 
                                                    &currentRecallOnly,
                                                    &currentUpdate,
                                                    &currentLogicalValidBytes,
                                                    &recreateMaster ));

            WsbTrace(OLESTR("Original Master next dataset, ver     = %d, %ls\n"), currentNextRemoteDataSet, WsbFiletimeAsString(FALSE, currentUpdate));
            WsbTrace(OLESTR("Copy next dataset, ver                = %d, %ls\n"), copyNextRemoteDataSet, WsbFiletimeAsString(FALSE, copyUpdate));
            WsbTrace(OLESTR("LastKnownGoodMaster next dataset, ver = %d, %ls\n"), lastKnownGoodMasterNextRemoteDataSet, WsbFiletimeAsString(FALSE, lastKnownGoodMasterUpdate));

            //
            // Initialize the state of the recreated master
            //
            newRecallOnly = lastKnownGoodMasterRecallOnly;

            BOOL inSync = (CompareFileTime(&lastKnownGoodMasterUpdate, &copyUpdate) == 0) &&
                (lastKnownGoodMasterNextRemoteDataSet == copyNextRemoteDataSet);

            if (!inSync) {

                // If the copy was not up to date, mark the new master as RecallOnly.
                // Also clear free bytes since we won't know this value

                newRecallOnly = TRUE;
                newFreeBytes = 0;

            } else {

                // This is an in-sync copy... check LastKnownGoodMaster RecallOnly and LastError to
                // determine how to mark the recreated master RecallOnly status. Since the current,
                // maybe recreated from an incomplete copy, we must use information about the
                // LastKnownGoodMaster to determine the new RecallOnly status.

                if (lastKnownGoodMasterRecallOnly) {

                    if (S_OK == lastKnownGoodMasterLastError) {

                        // If media is RecallOnly and there is no error (i.e. the media is full, or
                        // was marked RecallOnly via tool), we leave the media RecallOnly.

                        newRecallOnly = TRUE;

                    } else {

                        // If the original master was RecallOnly because of an error, reset
                        // the RecallOnly bit, since we should now have corrected the problem.

                        newRecallOnly = FALSE;

                    }

                }

            }

            // Reset master media info - use new values where needed and original
            // values where appropriate.  The copy's Next Remote
            // Data Set value allows the Validate job to handle managed files 
            // that are 'lost' by re-creating with an out of date copy.
            WsbAffirmHr(pMediaInfo->SetMediaInfo(currentMediaId, newMasterId,
                                                poolId,
                                                newFreeBytes,
                                                newCapacity, S_OK,
                                                copyNextRemoteDataSet,
                                                currentDescription, currentType,
                                                newName,
                                                newRecallOnly,
                                                copyUpdate,
                                                currentLogicalValidBytes, FALSE));

            if (inSync) {
                WsbAffirmHr(pMediaInfo->UpdateLastKnownGoodMaster());
            }

            // write the updated media record into the database
            WsbAffirmHr(pMediaInfo->Write());

            //
            // Now we need to determine what to do with the old media...
            //  Note that recycling old media is done only after a successful update in the DB
            //
            HRESULT hrRecycle;

            if (inSync) {

                // We recreated an in sync master.  The old LastKnownGoodMaster will be
                // overwritten with the new recreated master, so we can safely recycle
                // the LastKnownGoodMaster media.

                // If the cartridge cannot be found we assume it
                // was already deallocated through the media manager UI.
                hrRecycle = m_pHsmMediaMgr->RecycleCartridge( lastKnownGoodMasterId, 0 );
                WsbAffirm( S_OK == hrRecycle || RMS_E_CARTRIDGE_NOT_FOUND == hrRecycle, hrRecycle );

                // if the current media is not the same as the LastKnownGoodMaster, we
                // can recyle the current media, as well.  This happens when the
                // current media was recreated from an incomplete (out-of-sync) copy.
                if (lastKnownGoodMasterId != currentMediaSubsystemId) {

                    // If the cartridge cannot be found we assume it
                    // was already deallocated through the media manager UI.
                    hrRecycle = m_pHsmMediaMgr->RecycleCartridge( currentMediaSubsystemId, 0 );
                    WsbAffirm( S_OK == hrRecycle || RMS_E_CARTRIDGE_NOT_FOUND == hrRecycle, hrRecycle );
                }

            } else {

                // We recreated from an out-of-sync copy.  If the current media
                // and the LastKnownGoodMaster are different, we recycle the current
                // media, since this will be overwritten with the new recreated master.
                // This handles the case where we recreate from an out of sync copy
                // multiple times.

                if (lastKnownGoodMasterId != currentMediaSubsystemId) {

                    // If the cartridge cannot be found we assume it
                    // was already deallocated through the media manager UI.
                    hrRecycle = m_pHsmMediaMgr->RecycleCartridge( currentMediaSubsystemId, 0 );
                    WsbAffirm( S_OK == hrRecycle || RMS_E_CARTRIDGE_NOT_FOUND == hrRecycle, hrRecycle );
                }

            }

        } WsbCatch(hr); // inner 'try' - get media info entity and process

        // if any error was thrown after getting the master media record reset
        // the 'recreate master' state to off (FALSE) for safety and so it appears
        // correctly in the UI
        if (( haveMasterMediaRecord ) && ( hr != S_OK )) {
            WsbAffirmHr( pMediaInfo->SetRecreate( FALSE ) );
            WsbAffirmHr( pMediaInfo->Write() );
        }

        // close the database
        WsbAffirmHr( m_pSegmentDatabase->Close(pDbSession) );

    } WsbCatch(hr);

    // processing is done.  Singly-assigned smart interface pointers will 
    // auto-garbage collect themselves.
    
    if (S_OK == hr) {
        WsbLogEvent( HSM_MESSAGE_RECREATE_MASTER_END, 0, NULL, WsbHrAsString(hr), NULL );
    } else {
        WsbLogEvent( HSM_MESSAGE_RECREATE_MASTER_ERROR_END, 0, NULL, WsbHrAsString(hr), NULL );
    }

    //  Reset flags
    Lock();
    if (m_inCopyMedia && HSM_E_BUSY != hr) {
        m_inCopyMedia = FALSE;
        m_cancelCopyMedia = FALSE;
    }
    Unlock();
    
    WsbTraceOut(OLESTR("CHsmServer::RecreateMaster"), OLESTR("hr = <%ls>"), 
                                                                WsbHrAsString(hr));

    return(hr);

// leaving CopyMedia code, reset Tracing bit to the Hsm Engine
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG

}



HRESULT
CHsmServer::SynchronizeMedia(
    IN GUID poolId,
    IN USHORT copySet
    )

/*++

Implements:

  IHsmServer::SynchronizeMedia().

Routine Description:

    This routine implements the COM method for updating a specified Copy Set.
    All copy media in the Copy Set either out of date (aka not synchronized
    with the master) or non-existent (either hasn't been made or has been
    deleted by the SysAdmin) will be 'synchronized' by this method.  Out of 
    date media are copied (from the master) and the MediaInfo database is 
    updated to reflect the new info.

    After opening the Segment database (a single database containing all Engine
    database tables), getting the MediaInfo (secondary storage master media) records 
    (entity) and connecting to the RMS subsystem, the method enters its main loop.  
    The loop iterates through all MediaInfo records.  Those that belong to the specified 
    storage pool are processed.  First a check is made to ensure that the copy set
    requested to be updated is valid.  If valid, and if that copy set's media is out of 
    sync with the master (meaning it is outdated), the copy media is then duplicated 
    from the master.  (The copy media is actually 'updated', meaning only that
    portion of the master that was not previously written to the copy is copied.)  
    Finally, that master's specified Copy Set media record is updated in the database.  
    The loop then iterates to the next MediaInfo record.  After all MediaInfo 
    records have been processed the database is closed and the method returns.
    
Arguments:

    poolId - The id (GUID) for the Storage Pool whose copy set specified in the 
            following parameter is to synchronized (aka updated).  (Sakkara only
            has one storage pool.)

    copySet - the number of the copy set that is to be updated.  (Sakkara allows
            anywhere from 1 to 3 copy sets of secondary storage media, as configured
            by the System Administrator.)

Return Value:

    S_OK - The call succeeded (the specified copy set in the specified storage
            pool was updated).

    HSM_E_BUSY - Another media copy operation was already in progress.

    HSM_E_WORK_SKIPPED_CANCELLED - Operation was cancelled.

    Any other value - The call failed in either opening the Engine's Segment
            database, in getting the MediaInfo database entity, or in connecting
            to the RMS subsystem.
            
            NOTE that any error thrown during this routine's main loop will be
            logged to the Event Log, but will then be over-written to S_OK.  That 
            record is skipped and the next record in the loop is processed.  Due
            to this it is possible that an out of sync copy set media will not be
            updated.

--*/

{
// since this code is currently only used by the CopyMedia routines,
// reset the Tracing bit
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_COPYMEDIA

    HRESULT                         hr = S_OK;
    USHORT                          maxSets = 0;
    FILETIME                        mediaTime;
    GUID                            mediaId     = GUID_NULL;
    GUID                            mediaSetId  = GUID_NULL;
    GUID                            copyPoolId  = GUID_NULL;
    HRESULT                         hrDup = S_OK;
    BOOL                            atLeastOneCopyError = FALSE;
    SHORT                           masterNextRemoteDataSet;
    CComPtr<IHsmStoragePool>        pPool;
    CComPtr<IMediaInfo>             pMediaInfo;
    CComPtr<IRmsCartridge>          pCopyMedia;
    CComPtr<IWsbDbSession>          pDbSession;
    CWsbStringPtr                   mediaDescription;


    WsbTraceIn(OLESTR("CHsmServer::SynchronizeMedia"), 
                OLESTR("poolId = <%ls>, copySet = <%d>"), 
                WsbGuidAsString(poolId), copySet);

    // log 'information' message
    WsbLogEvent( HSM_MESSAGE_SYNCHRONIZE_MEDIA_START, 0, NULL, NULL );
    
    try {
        wchar_t             copySetAsString[20];
        BOOLEAN             done = FALSE;
        BOOLEAN             firstPass = TRUE;
        BOOL                okToContinue = TRUE;

        //  Make sure we're not already busy & haven't been cancelled
        Lock();
        if (m_inCopyMedia) {
            okToContinue = FALSE;
        } else {
            m_inCopyMedia = TRUE;
        }
        Unlock();
        WsbAffirm(okToContinue, HSM_E_BUSY);
        WsbAffirm(!m_cancelCopyMedia, HSM_E_WORK_SKIPPED_CANCELLED);

        // open the Engine's Segment database 
        WsbAffirmHr(m_pSegmentDatabase->Open(&pDbSession));

        // get interface pointer to the MediaInfo records (entity) in the
        // Segment database
        WsbAffirmHr(m_pSegmentDatabase->GetEntity(pDbSession, 
                                    HSM_MEDIA_INFO_REC_TYPE, IID_IMediaInfo, 
                                    (void**) &pMediaInfo));

        WsbAffirm(!m_cancelCopyMedia, HSM_E_WORK_SKIPPED_CANCELLED);

        // Convert copySet number to a sting for use later
        _itow( copySet, copySetAsString, 10 );

        // Main processing loop -- loop through all media at least once to
        // check for out-of-date copies.  Keep looping if any copies were
        // skipped because the mount request timed out.
        while (!done) {
            LONG        nTimedOut = 0;

            // Iterate through the (master secondary storage) media looking for 
            // duplicate (copy) media in this copy set that either haven't been made 
            // or haven't been synchronized since the last time the master was updated.  

            for (hr = pMediaInfo->First(); SUCCEEDED(hr); hr = pMediaInfo->Next()) {
                CWsbStringPtr   copyDescription;
                HRESULT         copyError = S_OK;
                GUID            copyMediaId = GUID_NULL;
                SHORT           copyNextRemoteDataSet = 0;
                CWsbStringPtr   copyName;
                FILETIME        copyTime = WsbLLtoFT(0);
                BOOL            gotCopyInfo = FALSE;
                BOOL            updateMediaInfo = FALSE;
                BOOLEAN         mountingScratch = FALSE;

                try {
                    WsbAffirm(!m_cancelCopyMedia, HSM_E_WORK_SKIPPED_CANCELLED);

                    // get the storage pool GUID of this master media (& its copies)
                    WsbAffirmHr(pMediaInfo->GetStoragePoolId(&copyPoolId));

                    // If the media is from the desired pool (or any pool) then check it.
                    // (Passing in a poolId of NULL has the effect of indicating the 
                    // SysAdmin wants copy set 'x' in all storage pools updated in one 
                    // operation.  Note that Sakkara currently uses this technique
                    // when the 'Update Copyset x' command is issued via the UI 
                    // (it launches RsLaunch with no pool id specified).)
                    if ((poolId == GUID_NULL) || (poolId == copyPoolId)) {

                        // Ensure the copy set requested for update is valid:

                        // Get the storage pool using the pool's HSM (not remote media 
                        // subsystem) id (GUID).
                        hr = FindHsmStoragePoolById(copyPoolId, &pPool);
                        if (S_OK != hr) {
                            // log and throw the returned error (this media will be
                            // skipped)
                            WsbLogEvent( HSM_MESSAGE_SEARCH_STGPOOL_BY_HSMID_ERROR,
                                            0, NULL, WsbHrAsString(hr), NULL );
                            WsbThrow( hr );
                        }

                        // get the number of copy sets configured for this pool
                        WsbAffirmHr(pPool->GetNumMediaCopies(&maxSets));

                        // ensure requested copy set is valid
                        WsbAffirm(copySet <= maxSets, E_INVALIDARG);
            
                        // to determine if the copy set media needs to be updated
                        // get the date the master media was last updated,
                        // and the last dataset written to the media...
                        //
                        // !!! IMPORTANT NOTE !!!
                        // This is the current time and data set count.  If a migrate
                        // is in progress this is NOT the final update time.
                        //
                        WsbAffirmHr(pMediaInfo->GetUpdate(&mediaTime));
                        WsbAffirmHr(pMediaInfo->GetNextRemoteDataSet(&masterNextRemoteDataSet));

                        // ...and get the date the copy media was last updated - 
                        // for efficiency get all copy media info in 1 call
                        // (copyMediaId is used later).
                        WsbAffirmHr(pMediaInfo->GetCopyInfo(copySet, &copyMediaId, 
                                                &copyDescription, 0, &copyName, 0, 
                                                &copyTime, &copyError, 
                                                &copyNextRemoteDataSet));
                        gotCopyInfo = TRUE;
                    
                        // If the copy media is out of date (copy's date last
                        // updated < master media's date last updated OR nextDataSet don't
                        // match), synchronize it.
                        //
                        // If this is not the first pass through the media records, we only
                        // want to retry copies that timed out.
                        if ((CompareFileTime( &copyTime, &mediaTime ) < 0 ||
                             copyNextRemoteDataSet != masterNextRemoteDataSet) &&
                                (firstPass ||
                                (RMS_E_TIMEOUT == copyError) ||
                                (RMS_E_SCRATCH_NOT_FOUND == copyError) ||
                                (RMS_E_CARTRIDGE_UNAVAILABLE == copyError))) {
                            CWsbBstrPtr      mediaDescriptionAsBstr;
                            CWsbBstrPtr      mediaSetName;
                            GUID             copySecondSideId = GUID_NULL;
                            DWORD            nofDrives = 0;

                            mountingScratch = FALSE;

                            // get media set id the storage pool contains so we assign
                            // the synchronized copy media to the proper media set
                            WsbAffirmHr(pPool->GetMediaSet( &mediaSetId, &mediaSetName ));

                            // since the duplication itself will be done by the remote
                            // media subsystem, get the subsystem GUID of the master 
                            WsbAffirmHr(pMediaInfo->GetMediaSubsystemId(&mediaId));

                            // build the description (display name) for the copy set 
                            // media as a BSTR (required format for duplicate call)
                            WsbAffirmHr(pMediaInfo->GetDescription(&mediaDescription, 0));

                            // check if we have at least 2 enabled drives for synchronizing the media
                            // if not - abort
                            WsbAffirmHr(m_pHsmMediaMgr->GetNofAvailableDrives(mediaSetId, &nofDrives));
                            WsbAffirm(nofDrives > 1, HSM_E_NO_TWO_DRIVES);

                            // If no media has been allocated for this copy, we need
                            // to construct a media description string
                            if (GUID_NULL == copyMediaId) {
                                mountingScratch = TRUE;

                                mediaDescriptionAsBstr = mediaDescription;
                                mediaDescriptionAsBstr.Append(" (Copy ");
                                mediaDescriptionAsBstr.Append(copySetAsString);
                                mediaDescriptionAsBstr.Append(")");
                                WsbTrace(OLESTR("CHsmServer::SynchronizeMedia: scratch desc = %ls\n"),
                                        mediaDescriptionAsBstr);

                                // In case of two-sided medias, we need to check whether the
                                //  original has a second side which has an existing copy
                                // If so, we want to allocate the second side of this existing copy
                                if (S_OK == m_pHsmMediaMgr->IsMultipleSidedMedia(mediaSetId)) {
                                    GUID    secondSideId;
                                    BOOL    bValid;

                                    // Get second side of original
                                    WsbAffirmHr(m_pHsmMediaMgr->CheckSecondSide(mediaId, &bValid, &secondSideId));
                                    if (bValid && (GUID_NULL != secondSideId)) {
                                        CComPtr<IMediaInfo> pSecondSideInfo;
                                        GUID                idFromDb;

                                        // Get second side record (if second side exists and allocated - it must be allocated by us!)
                                        //  Since the subsystem-id is not a key, we must traverse the table
                                        WsbAffirmHr(m_pSegmentDatabase->GetEntity(pDbSession, HSM_MEDIA_INFO_REC_TYPE, 
                                                        IID_IMediaInfo, (void**) &pSecondSideInfo));
                                        for (hr = pSecondSideInfo->First(); SUCCEEDED(hr); hr = pSecondSideInfo->Next()) {
                                            WsbAffirmHr(pSecondSideInfo->GetMediaSubsystemId(&idFromDb));
                                            if (idFromDb == secondSideId) {
                                                BOOL bCopyValid;
                                                GUID emptySideCopyId;

                                                // Just set second side copy for allocation as the other side of the existing copy cartridge
                                                WsbAffirmHr(pSecondSideInfo->GetCopyMediaSubsystemId(copySet, &copySecondSideId));

                                                if (GUID_NULL != copySecondSideId) {
                                                    // Need to check if the second side of the existing copy is available:
                                                    // After recreate-a-master, it might not be available so then
                                                    // we'll have to allocate a new media for the copy
                                                    WsbAffirmHr(m_pHsmMediaMgr->CheckSecondSide(copySecondSideId, &bCopyValid, &emptySideCopyId));
                                                    if ((! bCopyValid) || (GUID_NULL != emptySideCopyId)) {
                                                        // Second side of existing copy is not valid or not empty...
                                                        // Reset copy-media-id ==> will allocate a new media for the copy
                                                        copySecondSideId = GUID_NULL;
                                                    }
                                                }

                                                break;
                                            }
                                        }
                                    }
                                }
                            } else {
                                mediaDescriptionAsBstr = copyDescription;
                            }

                            // call remote media subsystem to copy the master 
                            // onto the copy set media indicated
                            WsbAffirm(!m_cancelCopyMedia, 
                                    HSM_E_WORK_SKIPPED_CANCELLED);

                            
                            // These two LONGLONGs are not used, but simply placeholders for the DuplicateCartridge
                            // function call (avoids passing null reference pointer errors).
                            LONGLONG FreeSpace = 0;
                            LONGLONG Capacity = 0;
                            hrDup = m_pHsmMediaMgr->DuplicateCartridge(mediaId, 
                                    copySecondSideId, &copyMediaId, mediaSetId, 
                                    mediaDescriptionAsBstr, &FreeSpace, &Capacity, 0);

                            WsbTrace(OLESTR("CHsmServer::SynchronizeMedia: DuplicateCartridge = <%ls>\n"),
                                    WsbHrAsString(hrDup));

                            // Make sure the status get saved in DB
                            copyError = hrDup;
                            updateMediaInfo = TRUE;

                            //
                            // We need to refresh the mediaTime and next data set.  This
                            // handles case were DuplicateCartridge was waiting on migrate to finish.
                            //
                            WsbAffirmHr(pMediaInfo->GetUpdate(&mediaTime));
                            WsbAffirmHr(pMediaInfo->GetNextRemoteDataSet(&masterNextRemoteDataSet));

                            // If we got a new piece of media, save the info about
                            // it in the DB.
                            // The DuplicateCartridge operation may fail after the media was
                            // allocated, so we need to record the copy media id in our databases
                            // no matter what.  If copyMediaId is still GUID_NULL we know the
                            // failure occurred while allocating the media and skip this step.
                            if (mountingScratch && copyMediaId != GUID_NULL) {
                                CWsbBstrPtr      mediaNameAsBstr;

                                // get the copy media
                                WsbAffirmHr(m_pHsmMediaMgr->FindCartridgeById(copyMediaId, 
                                        &pCopyMedia));

                                // Get the label name of the copy media that was just
                                // created. Note that if secondary storage is tape, 
                                // this 'name' is the tape's bar code.  For other media 
                                // (e.g., optical) this is a name.
                                copyName.Free();
                                WsbAffirmHr(pCopyMedia->GetName(&mediaNameAsBstr));
                                copyName = mediaNameAsBstr;

                                // Save the description string
                                copyDescription = mediaDescriptionAsBstr;
                            }

                            // If the duplication succeeded, update the MediaInfo
                            // data
                            if (S_OK == hrDup) {
                                copyTime = mediaTime;
                                copyNextRemoteDataSet = masterNextRemoteDataSet;

                            // If the duplication failed because of a mount timeout,
                            // count it and we'll try again on the next pass
                            } else if ((RMS_E_TIMEOUT == hrDup) ||
                                       (RMS_E_SCRATCH_NOT_FOUND == hrDup) ||
                                       (RMS_E_CARTRIDGE_UNAVAILABLE == hrDup)) {
                                nTimedOut++;
                            } else {
                                WsbThrow(hrDup);
                            }

                        } // end 'if copy set media is out of date'
                    } // end 'if poolId is valid'

                } WsbCatchAndDo(hr,  // 'try' in the for loop

                    //  If user cancelled, don't count it as an error, just exit
                    if (HSM_E_WORK_SKIPPED_CANCELLED == hr) {
                        WsbThrow(hr);
                    }

                    // If there are no 2 enabled drives, log a message but don't count it as a media error
                    if (HSM_E_NO_TWO_DRIVES == hr) {
                        WsbLogEvent(HSM_MESSAGE_SYNCHRONIZE_MEDIA_ABORT, 0, NULL, 
                                    copySetAsString, WsbHrAsString(hr), NULL);
                        WsbThrow(hr);
                    }

                    // If a piece of media fails during the 'for' loop log the error in
                    // the Event Log, then continue through loop to try the others.

                    atLeastOneCopyError = TRUE;

                    // Update the media info with the error
                    copyError = hr;
                    if (gotCopyInfo) {
                        updateMediaInfo = TRUE;
                    }

                    pMediaInfo->GetDescription( &mediaDescription, 0 );
                    WsbLogEvent( HSM_MESSAGE_SYNCHRONIZE_MEDIA_ERROR, 0, NULL, 
                                    copySetAsString, (OLECHAR*)mediaDescription, 
                                    WsbHrAsString( hr ), NULL );

                );

                // Update the MediaInfo record if anything changed
                if (updateMediaInfo) {

                    // It may have been a while since we got the the media info
                    // record and some of the data could have changed (e.g. if a
                    // synchronize media job on a different copy set completed) so
                    // we re-read the record before the update and we do it inside 
                    // a transaction to make sure it can't get changed while we're
                    // doing this
                    hr = S_OK;
                    WsbAffirmHr(pDbSession->TransactionBegin());
                    try {
                        // This FindEQ call will synchronize the data in our local
                        // MediaInfo record with what is in the DB
                        WsbAffirmHr(pMediaInfo->FindEQ());

                        // Update the copy media info - specifically the media id
                        // (if the copy media was just created), description,
                        // name (bar code for tape), date last updated (which
                        // is set to the master's date last updated) and the
                        // next remote dataset (conceptually same as next bag).
                        WsbAffirmHr(pMediaInfo->SetCopyInfo(copySet, copyMediaId, 
                                copyDescription, copyName, copyTime, copyError,
                                copyNextRemoteDataSet));
                        // write the changes into the database
                        WsbAffirmHr(pMediaInfo->Write());
                    } WsbCatch(hr);

                    if (S_OK == hr) {
                        WsbAffirmHr(pDbSession->TransactionEnd());
                    } else {
                        WsbAffirmHr(pDbSession->TransactionCancel());

                        atLeastOneCopyError = TRUE;

                        //
                        // If the copy info could not be updated in the database and this is a new copy, 
                        //  we need to recycle the copy, otherwise, the RSS database is inconsistent
                        //
                        if (mountingScratch && copyMediaId != GUID_NULL) {
                            HRESULT hrRecycle = m_pHsmMediaMgr->RecycleCartridge( copyMediaId, 0 );
                            WsbTraceAlways(OLESTR("CHsmServer::SynchronizeMedia: Recycling copy cartridge after DB_update failure, hrRecycle = <%ls>\n"), WsbHrAsString(hrRecycle));
                        }

                        //
                        // Log a message on the error
                        //
                        mediaDescription = L"";
                        pMediaInfo->GetDescription( &mediaDescription, 0 );
                        WsbLogEvent( HSM_MESSAGE_SYNCHRONIZE_MEDIA_ERROR, 0, NULL, 
                                        copySetAsString, (OLECHAR*)mediaDescription, 
                                        WsbHrAsString( hr ), NULL );

                        //
                        // Make sure we don't continue the job if an unexpected database-update error occurs
                        //
                        WsbThrow(hr);
                    }
                }

                // Release the interface pointers that will be reassigned during the 
                // next iteration of the 'for' loop.
                pPool = 0;
                pCopyMedia = 0;

            }   // end 'for' loop

            // We will fall out of the 'for' loop after processing all MediaInfo
            // records.  This is indicated by the Next() call returning WSB_E_NOTFOUND.
            // Since this is normal, reset hr to indicate so.
            if (WSB_E_NOTFOUND == hr) {
                hr = S_OK;
            }

            if (0 == nTimedOut) {
                done = TRUE;
            }
            firstPass = FALSE;

        }  // End of while loop

    } WsbCatch(hr);

    // Close the database (if it was opened)
    if (pDbSession) {
        m_pSegmentDatabase->Close(pDbSession);
    }

    // Report an error if any copy failed
    if (S_OK == hr && atLeastOneCopyError) {
        hr = HSM_E_MEDIA_COPY_FAILED;
    }
    
    WsbLogEvent( HSM_MESSAGE_SYNCHRONIZE_MEDIA_END, 0, NULL, WsbHrAsString(hr), NULL );

    //  Reset flags
    Lock();
    if (m_inCopyMedia && HSM_E_BUSY != hr) {
        m_inCopyMedia = FALSE;
        m_cancelCopyMedia = FALSE;
    }
    Unlock();
    
    WsbTraceOut(OLESTR("CHsmServer::SynchronizeMedia"), OLESTR("hr = <%ls>"), 
            WsbHrAsString(hr));

    return(hr);

// leaving CopyMedia code, reset Tracing bit to the Hsm Engine
#undef WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG

}


HRESULT
CHsmServer::CloseOutDb( void )

/*++

Implements:

  IHsmServer::CloseOutDb().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::CloseOutDb"), OLESTR(""));
    
    try {
        if (m_pDbSys != 0) {
            WsbAffirmHr(m_pDbSys->Backup(NULL, 0));
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::CloseOutDb"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmServer::BackupSegmentDb( void )

/*++

Implements:

  IHsmServer::BackupSegmentDb().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::BackupSegmentDb"), OLESTR(""));
    
    try {
        if (m_pDbSys != 0) {
            WsbAffirmHr(m_pDbSys->Backup(NULL, 0));
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::BackupSegmentDb"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmServer::ChangeSysState( 
    IN OUT HSM_SYSTEM_STATE* pSysState 
    )

/*++

Implements:

  IHsmSystemState::ChangeSysState().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::ChangeSysState"), OLESTR("State = %lx"),
        pSysState->State);
    
    try {

        if (pSysState->State & HSM_STATE_SUSPEND) {
            if (!m_Suspended) {
                m_Suspended = TRUE;

                //  Pause the jobs
                NotifyAllJobs(HSM_JOB_STATE_PAUSING);

                //  Save data
                SavePersistData();
                SaveMetaData();
            }
        } else if (pSysState->State & HSM_STATE_RESUME) {
            m_Suspended = FALSE;

            //  Resume the jobs
            NotifyAllJobs(HSM_JOB_STATE_RESUMING);
        } else if (pSysState->State & HSM_STATE_SHUTDOWN) {

            //  Close the CheckManagedResources thread (if it is still running)
            StopCheckManagedResourcesThread();

            //  Close the autosave thread
            StopAutosaveThread();

            // 
            // Since MediaCopy operations do not run as standard jobs,
            // the only way to cancel these is to suspend or shutdown RMS
            // directly.
            //
            try {
                CComPtr<IHsmSystemState>    pISysState;
                HSM_SYSTEM_STATE            SysState;

                WsbAffirmHr(m_pHsmMediaMgr->QueryInterface(IID_IHsmSystemState, (void**) &pISysState));
                WsbAffirmPointer(pISysState);

                SysState.State = HSM_STATE_SUSPEND;
                WsbAffirmHr(pISysState->ChangeSysState(&SysState));

                SysState.State = HSM_STATE_RESUME;
                WsbAffirmHr(pISysState->ChangeSysState(&SysState));

            } WsbCatch(hr);

            //  Cancel jobs
            CancelAllJobs();

            //  Save data
            SavePersistData();
            SaveMetaData();
        }

        //  Notify the task manager
        if (m_pHsmFsaTskMgr) {
            m_pHsmFsaTskMgr->ChangeSysState(pSysState);
        }

        // Notify the Media Server
        try {
            CComPtr<IHsmSystemState>    pISysState;

            WsbAffirmHr(m_pHsmMediaMgr->QueryInterface(IID_IHsmSystemState, (void**) &pISysState));
            WsbAffirmPointer(pISysState);

            WsbAffirmHr(pISysState->ChangeSysState(pSysState));

        } WsbCatch(hr);

        if (pSysState->State & HSM_STATE_SHUTDOWN) {
            CloseOutDb();

            //  Release collections
            if (m_pMountingMedias) {
                m_pMountingMedias->RemoveAllAndRelease();
            }
            //  Release collections
            if (m_pJobs) {
                m_pJobs->RemoveAllAndRelease();
            }
            if (m_pJobDefs) {
                m_pJobDefs->RemoveAllAndRelease();
            }
            if (m_pPolicies) {
                m_pPolicies->RemoveAllAndRelease();
            }
            if (m_pManagedResources) {
                ULONG                                  count;
                CComPtr<IHsmManagedResourceCollection> pIMRC;

                //  We can't use RemoveAllAndRelease because the Remove function for
                //  this non-standard collection tells the FSA to unmanage the resource.
                //  Then when the FSA shuts down, the list of managed resources is empty.
                //  The next time the FSA starts up, it loads an empty list of managed
                //  resources, which is wrong. The method DeleteAllAndRelesae avoids
                //  this problem.
                WsbAffirmHr(m_pManagedResources->QueryInterface(IID_IHsmManagedResourceCollection, 
                        (void**) &pIMRC));
                pIMRC->DeleteAllAndRelease();
                pIMRC = 0;
                WsbAffirmHr(m_pManagedResources->GetEntries(&count));
            }
            if (m_pStoragePools) {
                m_pStoragePools->RemoveAllAndRelease();
            }
            if (m_pMessages) {
                m_pMessages->RemoveAllAndRelease();
            }
            if (m_pOnlineInformation) {
                m_pOnlineInformation->RemoveAllAndRelease();
            }

            //  Dump object table info
            WSB_OBJECT_TRACE_TYPES;
            WSB_OBJECT_TRACE_POINTERS(WSB_OTP_STATISTICS | WSB_OTP_ALL);

            m_initializationCompleted = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::ChangeSysState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CHsmServer::Unload(
    void
    )

/*++

Implements:

  IwsbServer::Unload

Return Value:
    S_OK     - Success
    Other    - Error

--*/
{

    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::Unload"), OLESTR(""));

    try {

        //  We only need to release what may have gotten set/created by
        //  a failed Load attempt.
        if (m_pJobs) {
            m_pJobs->RemoveAllAndRelease();
        }
        if (m_pJobDefs) {
            m_pJobDefs->RemoveAllAndRelease();
        }
        if (m_pPolicies) {
            m_pPolicies->RemoveAllAndRelease();
        }
        if (m_pManagedResources) {
            CComPtr<IHsmManagedResourceCollection> pIMRC;

            //  We can't use RemoveAllAndRelease because the Remove function for
            //  this non-standard collection tells the FSA to unmanage the resource.
            //  Then when the FSA shuts down, the list of managed resources is empty.
            //  The next time the FSA starts up, it loads an empty list of managed
            //  resources, which is wrong. The method DeleteAllAndRelesae avoids
            //  this problem.
            WsbAffirmHr(m_pManagedResources->QueryInterface(IID_IHsmManagedResourceCollection, 
                    (void**) &pIMRC));
            pIMRC->DeleteAllAndRelease();
        }
        if (m_pStoragePools) {
            m_pStoragePools->RemoveAllAndRelease();
        }
        if (m_pMessages) {
            m_pMessages->RemoveAllAndRelease();
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::Unload"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

STDMETHODIMP
CHsmServer::DestroyObject(
    void
    )
/*++

Implements:

  IWsbServer::DestroyObject

Return Value:
    S_OK     - Success

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::DestroyObject"), OLESTR(""));

    CComObject<CHsmServer> *pEngDelete = (CComObject<CHsmServer> *)this;
    delete pEngDelete;

    WsbTraceOut(OLESTR("CHsmServer::DestroyObject"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmServer::CancelAllJobs( void )

/*++

Implements:

  IHsmServer::CancelAllJobs().

--*/
{
    HRESULT                     hr = S_OK;
    HRESULT                     hr2 = S_OK;
    BOOL                        foundRunningJob = FALSE;
    CComPtr<IWsbCollection>     pCollection;
    CComPtr<IWsbEnum>           pEnum;
    CComPtr<IHsmJob>            pJob;

    WsbTraceIn(OLESTR("CHsmServer::CancelAllJobs"), OLESTR(""));
    
    try {
        //
        // Set up for the loops
        //
        WsbAffirmHr(m_pJobs->QueryInterface(IID_IWsbCollection, (void**) &pCollection));
        WsbAffirmHr(pCollection->Enum(&pEnum));
        //
        // Loop through all jobs and cancel any currently running jobs
        //
        pJob = 0;
        for (hr = pEnum->First(IID_IHsmJob, (void**) &pJob);
            SUCCEEDED(hr);
            pJob = 0, hr = pEnum->Next(IID_IHsmJob, (void**) &pJob)) {
            try  {
                WsbAffirmHrOk(pJob->IsActive());
                foundRunningJob = TRUE;
                WsbAffirmHr(pJob->Cancel(HSM_JOB_PHASE_ALL));
            } WsbCatchAndDo(hr2, hr = S_OK;);
        }
        //
        // Clean up end of scan return
        //
        if (WSB_E_NOTFOUND == hr)  {
            hr = S_OK;
        }

        //
        // Cancel all mounting medias so all jobs can finish
        //
        CancelMountingMedias();
            
        //
        // Make sure all jobs are done
        //
        if (TRUE == foundRunningJob)  {
            pJob = 0;
            for (hr = pEnum->First(IID_IHsmJob, (void**) &pJob);
                SUCCEEDED(hr);
                pJob = 0, hr = pEnum->Next(IID_IHsmJob, (void**) &pJob)) {
                try  {
                    WsbAffirmHrOk(pJob->IsActive());
                    WsbAffirmHr(pJob->WaitUntilDone());
                } WsbCatchAndDo(hr2, hr = S_OK;);
            }
        }
        
        //
        // Clean up end of scan return
        //
        if (WSB_E_NOTFOUND == hr)  {
            hr = S_OK;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::CancelAllJobs"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmServer::CheckManagedResources( void )

/*++

Implements:

  IHsmServer::CheckManagedResources().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IWsbEnum>               pEnum;
    CComPtr<IHsmManagedResource>    pMngdRes;
    CComPtr<IUnknown>               pFsaResUnknown;
    CComPtr<IFsaResource>           pFsaRes;
    
    WsbTraceIn(OLESTR("CHsmServer::CheckManagedResources"), OLESTR(""));
    
    try {
        //
        // Get an enumerator for the managed resource collection
        //
        WsbAffirmHr(m_pManagedResources->Enum(&pEnum));
        
        //
        // Scan through all managed resources and start the validation
        // job for each
        //
        pMngdRes = 0;
        for (hr = pEnum->First(IID_IHsmManagedResource,(void **)&pMngdRes );
            SUCCEEDED(hr);
            pMngdRes = 0, hr = pEnum->Next(IID_IHsmManagedResource, (void **)&pMngdRes)) {

            try  {

                pFsaResUnknown = 0;
                pFsaRes = 0;
                WsbAffirmHr(pMngdRes->GetFsaResource((IUnknown **)&pFsaResUnknown));
                WsbAffirmHr(pFsaResUnknown->QueryInterface(IID_IFsaResource, (void**) &pFsaRes));
                
                if ((pFsaRes->IsActive() == S_OK) && (pFsaRes->IsAvailable() == S_OK)) {
                    WsbAffirmHr(pFsaRes->CheckForValidate(FALSE));
                }

            } WsbCatchAndDo(hr, hr = S_OK; );
        }
        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        }
        
    
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::CheckManagedResources"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmServer::GetBuildVersion( 
    ULONG *pBuildVersion
    )

/*++

Implements:

  IWsbServer::GetBuildVersion().

--*/
{
    HRESULT       hr = S_OK;
    WsbTraceIn(OLESTR("CHsmServer::GetBuildVersion"), OLESTR(""));
   
    try {
        WsbAssertPointer(pBuildVersion);

        *pBuildVersion = m_buildVersion;

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmServer::GetBuildVersion"), OLESTR("hr = <%ls>, Version = <%ls)"),
        WsbHrAsString(hr), RsBuildVersionAsString(m_buildVersion));
    return ( hr );
}

HRESULT
CHsmServer::GetDatabaseVersion( 
    ULONG *pDatabaseVersion
    )

/*++

Implements:

  IWsbServer::GetDatabaseVersion().

--*/
{
    HRESULT       hr = S_OK;
    WsbTraceIn(OLESTR("CHsmServer::GetDatabaseVersion"), OLESTR(""));
    
    *pDatabaseVersion = m_databaseVersion;
    
    WsbTraceOut(OLESTR("CHsmServer::GetDatabaseVersion"), OLESTR("hr = <%ls>, Version = <%ls)"),
        WsbHrAsString(hr), WsbPtrToUlongAsString(pDatabaseVersion));
    return ( hr );
}

HRESULT
CHsmServer::GetNtProductVersion ( 
    OLECHAR **pNtProductVersion, 
    ULONG bufferSize
    )  
/*++

Implements:

  IWsbServer::GetNtProductVersion().

--*/

{

    HRESULT hr = S_OK;
    
    try  {
        CWsbStringPtr tmpString;
        
        WsbAssert(0 != pNtProductVersion,  E_POINTER);
        
        tmpString = VER_PRODUCTVERSION_STRING;
        WsbAffirmHr(tmpString.CopyTo(pNtProductVersion, bufferSize));
        
    } WsbCatch( hr );
    
    return (hr);
}

HRESULT
CHsmServer::GetNtProductBuild( 
    ULONG *pNtProductBuild
    )

/*++

Implements:

  IWsbServer::GetNtProductBuild().

--*/
{
    HRESULT       hr = S_OK;
    WsbTraceIn(OLESTR("CHsmServer::GetNtProductBuild"), OLESTR(""));
   
    *pNtProductBuild = VER_PRODUCTBUILD;
    
    WsbTraceOut(OLESTR("CHsmServer::GetNtProductBuild"), OLESTR("hr = <%ls>, Version = <%ls)"),
        WsbHrAsString(hr), WsbLongAsString(VER_PRODUCTBUILD));
    return ( hr );
}

HRESULT
CHsmServer::CheckAccess(
    WSB_ACCESS_TYPE AccessType
    )
/*++

Implements:

  IWsbServer::CheckAccess().

--*/
{
    WsbTraceIn(OLESTR("CHsmServer::CheckAccess"), OLESTR(""));
    HRESULT hr = S_OK;
    
    try  {

        //
        // Do the impersonation
        //
        WsbAffirmHr( CoImpersonateClient() );

        hr = WsbCheckAccess( AccessType );
    
        CoRevertToSelf();
        
    } WsbCatchAndDo( hr,

        //
        // Handle case where there is no COM context to check against
        // in which case we are the service so any security is allowed.
        //
        if( ( hr == RPC_E_NO_CONTEXT ) || ( hr != RPC_E_CALL_COMPLETE ) ) {
        
            hr = S_OK;
        
        }                      

    );
    
    WsbTraceOut(OLESTR("CHsmServer::CheckAccess"), OLESTR("hr = <%ls>"), WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CHsmServer::GetTrace(
    OUT IWsbTrace ** ppTrace
    )
/*++

Implements:

  IWsbServer::GetTrace().

--*/
{
    WsbTraceIn(OLESTR("CHsmServer::GetTrace"), OLESTR("ppTrace = <0x%p>"), ppTrace);
    HRESULT hr = S_OK;
    
    try {

        WsbAffirmPointer(ppTrace);
        *ppTrace = 0;

        WsbAffirmPointer(m_pTrace);
        
        *ppTrace = m_pTrace;
        (*ppTrace)->AddRef();
        
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmServer::GetTrace"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CHsmServer::SetTrace(
    OUT IWsbTrace * pTrace
    )
/*++

Implements:

  IWsbServer::SetTrace().

--*/
{
    WsbTraceIn(OLESTR("CHsmServer::SetTrace"), OLESTR("pTrace = <0x%p>"), pTrace);
    HRESULT hr = S_OK;
    
    try {

        WsbAffirmPointer(pTrace);

        m_pTrace = pTrace;

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmServer::SetTrace"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmServer::NotifyAllJobs( HSM_JOB_STATE jobState )

/*++


Routine Description:

    Notify all jobs of a change in status.

Arguments:

    jobState - New job state.

Return Value:

    S_OK - Success
            
--*/

{
    HRESULT                     hr = S_OK;
    HRESULT                     hr2 = S_OK;
    CComPtr<IWsbCollection>     pCollection;
    CComPtr<IWsbEnum>           pEnum;
    CComPtr<IHsmJob>            pJob;

    WsbTraceIn(OLESTR("CHsmServer::NotifyAllJobs"), OLESTR(""));
    
    try {
        //
        // Set up for the loops
        //
        WsbAffirmHr(m_pJobs->QueryInterface(IID_IWsbCollection, 
                (void**) &pCollection));
        WsbAffirmHr(pCollection->Enum(&pEnum));
        //
        // Loop through all jobs and notify any currently running jobs
        //
        pJob = 0;
        for (hr = pEnum->First(IID_IHsmJob, (void**) &pJob);
            SUCCEEDED(hr);
            pJob = 0, hr = pEnum->Next(IID_IHsmJob, (void**) &pJob)) {
            try  {
                if (S_OK == pJob->IsActive()) {
                    if (HSM_JOB_STATE_PAUSING == jobState) {
                        WsbAffirmHr(pJob->Pause(HSM_JOB_PHASE_ALL));
                    } else {
                        WsbAffirmHr(pJob->Resume(HSM_JOB_PHASE_ALL));
                    }
                }
            } WsbCatchAndDo(hr2, hr = S_OK;);
        }
        //
        // Clean up end of scan return
        //
        if (WSB_E_NOTFOUND == hr)  {
            hr = S_OK;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::NotifyAllJobs"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

//
// Retrieves the Media Manager object
//
HRESULT CHsmServer::GetHsmMediaMgr(
    IRmsServer  **ppHsmMediaMgr
    )
{
    HRESULT hr = S_OK;

    // If the Media Manager has been created, return the pointer. Otherwise, fail.
    try {
        WsbAssert(0 != ppHsmMediaMgr, E_POINTER);
        *ppHsmMediaMgr = m_pHsmMediaMgr;
        WsbAffirm(m_pHsmMediaMgr != 0, E_FAIL);
        m_pHsmMediaMgr.p->AddRef();
    } WsbCatch(hr);

    return (hr);
}

HRESULT
CHsmServer::GetCopyFilesUserLimit(
    OUT ULONG* pLimit
    )

/*++

Implements:

  CHsmServer::GetCopyFilesUserLimit().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::GetCopyFilesUserLimit"), OLESTR(""));

    try {

        WsbAssert(0 != pLimit, E_POINTER);
        *pLimit = m_copyfilesUserLimit;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::GetCopyFilesUserLimit"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmServer::SetCopyFilesUserLimit(
    IN ULONG limit
    )

/*++

Implements:

  CHsmServer::SetCopyFilesUserLimit().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::SetCopyFilesUserLimit"), OLESTR(""));

    m_copyfilesUserLimit= limit;

    WsbTraceOut(OLESTR("CHsmServer::SetCopyFilesUserLimit"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmServer::GetCopyFilesLimit(
    OUT ULONG* pLimit
    )

/*++

Implements:

  CHsmServer::GetCopyFilesLimit().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::GetCopyFilesLimit"), OLESTR(""));

    try {
        CComPtr<IHsmStoragePool>    pStoragePool;
        ULONG                       count;
        GUID                        mediaSetId;
        CWsbBstrPtr                 dummy;
        DWORD                       dwNofDrives;

        WsbAssert(0 != pLimit, E_POINTER);

        // Get relevant media set - assume only one pool !!
        WsbAffirmHr(m_pStoragePools->GetEntries(&count));
        WsbAffirm(1 == count, E_FAIL);
        WsbAffirmHr(m_pStoragePools->At(0, IID_IHsmStoragePool, (void **)&pStoragePool));
        WsbAffirmHr(pStoragePool->GetMediaSet(&mediaSetId, &dummy));

        // Get number of available drives in the system
        WsbAffirmHr(m_pHsmMediaMgr->GetNofAvailableDrives(mediaSetId, &dwNofDrives));

        // Deteremine actual limit
        *pLimit = max(1, min(m_copyfilesUserLimit, dwNofDrives));
        WsbTrace(OLESTR("CHsmServer::GetCopyFilesLimit: Limit is %lu\n"), *pLimit);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::GetCopyFilesLimit"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmServer::AreJobsEnabled( void )

/*++

Implements:

  IHsmServer::AreJobsDisabled().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::AreJobsEnabled"), OLESTR(""));

    EnterCriticalSection(&m_JobDisableLock);

    hr = (m_JobsEnabled ? S_OK : S_FALSE);

    LeaveCriticalSection(&m_JobDisableLock);

    WsbTraceOut(OLESTR("CHsmServer::AreJobsEnabled"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmServer::EnableAllJobs( void )

/*++

Implements:

  IHsmServer::EnableAllJobs().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::EnableAllJobs"), OLESTR(""));

    EnterCriticalSection(&m_JobDisableLock);

    try {

        m_JobsEnabled = TRUE;
        WsbAffirmHr(RestartSuspendedJobs());

    } WsbCatch(hr);

    LeaveCriticalSection(&m_JobDisableLock);

    WsbTraceOut(OLESTR("CHsmServer::EnableAllJobs"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmServer::DisableAllJobs( void )

/*++

Implements:

  IHsmServer::DisableAllJobs().

Notes:

  The medthod tries to disable all jobs.
  If any job is active or starting, it fails with HSM_E_DISABLE_RUNNING_JOBS and calls 
  RestartSuspendedJobs to restart any job that alreay became suspended beacuse of this 
  unsuccessful disabling attempt.

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::DisableAllJobs"), OLESTR(""));

    EnterCriticalSection(&m_JobDisableLock);

    try {
        ULONG                          nJobs;

        m_JobsEnabled = FALSE;

        // Loop over jobs
        WsbAffirmHr(m_pJobs->GetEntries(&nJobs));
        for (ULONG i = 0; i < nJobs; i++) {
            CComPtr<IHsmJob>               pJob;
            HSM_JOB_STATE                  state;

            WsbAffirmHr(m_pJobs->At(i, IID_IHsmJob, (void**) &pJob));

            // Check if this job is suspended
            WsbAffirmHr(pJob->GetState(&state));
            if ((HSM_JOB_STATE_ACTIVE == state) || (HSM_JOB_STATE_STARTING == state)) {
                // Cannot disable jobs
                m_JobsEnabled = TRUE;
                hr = HSM_E_DISABLE_RUNNING_JOBS;
                RestartSuspendedJobs();
                break;
            }
        }

    } WsbCatch(hr);

    LeaveCriticalSection(&m_JobDisableLock);

    WsbTraceOut(OLESTR("CHsmServer::DisableAllJobs"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmServer::RestartSuspendedJobs(
    void
    )

/*++

Implements:

  IHsmServer::RestartSuspendedJobs().

--*/
{
    HRESULT                        hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::RestartSuspendedJobs"), OLESTR(""));
    try {
        ULONG                          nJobs;

        // Loop over jobs
        // Note: this algorithm is unfair because jobs at the end of the
        // list could "starve" because jobs at the beginning are more likely
        // to get started.  The assumption is that there should be very few
        // jobs waiting to run.  If this assumption proves to be false, some
        WsbAffirmHr(m_pJobs->GetEntries(&nJobs));
        // sort of priority scheme will be needed.
        for (ULONG i = 0; i < nJobs; i++) {
            CComPtr<IHsmJob>               pJob;
            HSM_JOB_STATE                  state;

            WsbAffirmHr(m_pJobs->At(i, IID_IHsmJob, (void**) &pJob));

            // Check if this job is suspended
            WsbAffirmHr(pJob->GetState(&state));
            if (HSM_JOB_STATE_SUSPENDED == state) {
                // This may fail, but we don't care
                pJob->Restart();
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::RestartSuspendedJobs"), OLESTR("hr = <%ls>"), 
            WsbHrAsString(hr));
    return(hr);
}

HRESULT
CHsmServer::LockMountingMedias( void )

/*++

Implements:

  IHsmServer::LockMountingMedias().

--*/
{
    HRESULT     hr = S_OK;

    EnterCriticalSection(&m_MountingMediasLock);

    return(hr);
}

HRESULT
CHsmServer::UnlockMountingMedias( void )

/*++

Implements:

  IHsmServer::UnlockMountingMedias().

--*/
{
    HRESULT     hr = S_OK;

    LeaveCriticalSection(&m_MountingMediasLock);

    return(hr);
}

HRESULT
CHsmServer::ResetSegmentValidMark( void )

/*++

Implements:

  IHsmServer::ResetSegmentValidMark().

--*/
{
    HRESULT                 hr = S_OK;

    BOOL                    bOpenDb = FALSE;
    CComPtr<IWsbDbSession>  pDbSession;

    WsbTraceIn(OLESTR("CHsmServer::ResetSegmentValidMark"), OLESTR(""));

    try {
        CComPtr<ISegRec>    pSegRec;
        USHORT              uSegFlags;

        // open Engine's Segment database 
        WsbAffirmHr(m_pSegmentDatabase->Open(&pDbSession));
        bOpenDb = TRUE;

        // Traverse segment records
        WsbAffirmHr(m_pSegmentDatabase->GetEntity(pDbSession, HSM_SEG_REC_TYPE, 
                IID_ISegRec, (void**)&pSegRec));

        for (hr = pSegRec->First(); S_OK == hr; hr = pSegRec->Next()) {
            WsbAffirmHr(pSegRec->GetSegmentFlags(&uSegFlags));
            if (uSegFlags & SEG_REC_MARKED_AS_VALID) {
                // Need to reset this bit
                uSegFlags &= ~SEG_REC_MARKED_AS_VALID;
                WsbAffirmHr(pSegRec->SetSegmentFlags(uSegFlags));
                WsbAffirmHr(pSegRec->Write());
            }
        }

        // If we fell out of the loop because we ran out of segments, reset the HRESULT
        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
        } else {
            WsbAffirmHr(hr);
        }

    } WsbCatch(hr);

    if (bOpenDb) {
        hr = m_pSegmentDatabase->Close(pDbSession);
    }

    WsbTraceOut(OLESTR("CHsmServer::ResetSegmentValidMark"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmServer::ResetMediaValidBytes( void )

/*++

Implements:

  IHsmServer::ResetMediaValidBytes().

--*/
{
    HRESULT                 hr = S_OK;

    BOOL                    bOpenDb = FALSE;
    CComPtr<IWsbDbSession>  pDbSession;

    WsbTraceIn(OLESTR("CHsmServer::ResetMediaValidBytes"), OLESTR(""));

    try {
        CComPtr<IMediaInfo>    pMediaInfo;

        // open Engine's Segment database 
        WsbAffirmHr(m_pSegmentDatabase->Open(&pDbSession));
        bOpenDb = TRUE;

        // Traverse segment records
        WsbAffirmHr(m_pSegmentDatabase->GetEntity(pDbSession, HSM_MEDIA_INFO_REC_TYPE,
                        IID_IMediaInfo, (void**)&pMediaInfo));

        for (hr = pMediaInfo->First(); S_OK == hr; hr = pMediaInfo->Next()) {
            WsbAffirmHr(pMediaInfo->SetLogicalValidBytes(0));
            WsbAffirmHr(pMediaInfo->Write());
        }

        // If we fell out of the loop because we ran out of segments, reset the HRESULT
        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
        } else {
            WsbAffirmHr(hr);
        }

    } WsbCatch(hr);

    if (bOpenDb) {
        hr = m_pSegmentDatabase->Close(pDbSession);
    }

    WsbTraceOut(OLESTR("CHsmServer::ResetMediaValidBytes"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmServer::GetSegmentPosition( 
    IN REFGUID bagId, 
    IN LONGLONG fileStart,
    IN LONGLONG fileSize, 
    OUT GUID* pPosMedia,
    OUT LONGLONG* pPosOffset)

/*++

Implements:

  IHsmServer::GetSegmentPosition().

--*/
{
    HRESULT                 hr = S_OK;

    BOOL                    bOpenDb = FALSE;
    CComPtr<IWsbDbSession>  pDbSession;
    CComPtr<ISegDb>         pSegDb;

    WsbTraceIn(OLESTR("CHsmServer::GetSegmentPosition"), OLESTR(""));

    try {
        CComPtr<ISegRec>    pSegRec;

        // open Engine's Segment database 
        WsbAffirmHr(m_pSegmentDatabase->Open(&pDbSession));
        bOpenDb = TRUE;

        // Find segemnt
        WsbAffirmHr(m_pSegmentDatabase->QueryInterface(IID_ISegDb, (void**) &pSegDb));
        WsbAffirmHr(pSegDb->SegFind(pDbSession, bagId, fileStart, fileSize, &pSegRec));

        // Extract output
        WsbAffirmHr(pSegRec->GetPrimPos(pPosMedia));
        WsbAffirmHr(pSegRec->GetSecPos(pPosOffset));

    } WsbCatch(hr);

    if (bOpenDb) {
        hr = m_pSegmentDatabase->Close(pDbSession);
    }

    WsbTraceOut(OLESTR("CHsmServer::GetSegmentPosition"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

void
CHsmServer::StopAutosaveThread(
    void
    )
/*++

Routine Description:

  Stop the Autosave thread:
    First try gracefully, using the termination event
    If doesn't work, just terminate the thread

Arguments:

  None.
  
Return Value:

  S_OK  - Success.

--*/
{

    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::StopAutosaveThread"), OLESTR(""));

    try {
        // Terminate the autosave thread
        if (m_autosaveThread) {
            // Signal thread to terminate
            SetEvent(m_terminateEvent);

            // Wait for the thread, if it doesn't terminate gracefully - kill it
            switch (WaitForSingleObject(m_autosaveThread, 20000)) {
                case WAIT_FAILED: {
                    WsbTrace(OLESTR("CHsmServer::StopAutosaveThread: WaitForSingleObject returned error %lu\n"), GetLastError());
                }
                // fall through...

                case WAIT_TIMEOUT: {
                    WsbTrace(OLESTR("CHsmServer::StopAutosaveThread: force terminating of autosave thread.\n"));

                    DWORD dwExitCode;
                    if (GetExitCodeThread( m_autosaveThread, &dwExitCode)) {
                        if (dwExitCode == STILL_ACTIVE) {   // thread still active
                            if (!TerminateThread (m_autosaveThread, 0)) {
                                WsbTrace(OLESTR("CHsmServer::StopAutosaveThread: TerminateThread returned error %lu\n"), GetLastError());
                            }
                        }
                    } else {
                        WsbTrace(OLESTR("CHsmServer::StopAutosaveThread: GetExitCodeThread returned error %lu\n"), GetLastError());
                    }

                    break;
                }

                default:
                    // Thread terminated gracefully
                    WsbTrace(OLESTR("CHsmServer::StopAutosaveThread: Autosave thread terminated gracefully\n"));
                    break;
            }

            // Best effort done for terminating auto-backup thread
            CloseHandle(m_autosaveThread);
            m_autosaveThread = 0;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::StopAutosaveThread"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
}

void
CHsmServer::StopCheckManagedResourcesThread(
    void
    )
/*++

Routine Description:

  Stop the CheckManagedResources thread:
    This thread should be running only for a short period of time during initialization,
    so wait for thread to finish gracefully, then if it is hung for some reason, just terminate the thread

Arguments:

  None.
  
Return Value:

  S_OK  - Success.

--*/
{

    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::StopCheckManagedResourcesThread"), OLESTR(""));

    try {
        // Wait for the CheckManagedResources thread if it is still running
        if (m_CheckManagedResourcesThread) {
            switch (WaitForSingleObject(m_CheckManagedResourcesThread, 20000)) {
                case WAIT_FAILED: {
                    WsbTrace(OLESTR("CHsmServer::StopCheckManagedResourcesThread: WaitForSingleObject returned error %lu\n"), GetLastError());
                }
                // fall through...

                case WAIT_TIMEOUT: {
                    WsbTrace(OLESTR("CHsmServer::StopCheckManagedResourcesThread: force terminating of CheckManagedResources thread.\n"));

                    DWORD dwExitCode;
                    if (GetExitCodeThread( m_CheckManagedResourcesThread, &dwExitCode)) {
                        if (dwExitCode == STILL_ACTIVE) {   // thread still active
                            if (!TerminateThread (m_CheckManagedResourcesThread, 0)) {
                                WsbTrace(OLESTR("CHsmServer::StopCheckManagedResourcesThread: TerminateThread returned error %lu\n"), GetLastError());
                            }
                        }
                    } else {
                        WsbTrace(OLESTR("CHsmServer::StopCheckManagedResourcesThread: GetExitCodeThread returned error %lu\n"), GetLastError());
                    }

                    break;
                }

                default:
                    // Thread terminated gracefully
                    WsbTrace(OLESTR("CHsmServer::StopCheckManagedResourcesThread: CheckManagedResources thread terminated gracefully\n"));
                    break;
            }

            // Best effort done for terminating auto-backup thread
            CloseHandle(m_CheckManagedResourcesThread);
            m_CheckManagedResourcesThread = 0;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::StopCheckManagedResourcesThread"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
}

HRESULT
CHsmServer::InternalSavePersistData(
    void
    )

/*++

Implements:

  CHsmServer::InternalSavePersistData().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::InternalSavePersistData"), OLESTR(""));

    try {
        DWORD   status, errWait;
        CComPtr<IPersistFile>  pPersistFile;
    
        // Synchronize saving of persistent data with snapshot signaling event
        status = WaitForSingleObject(m_savingEvent, EVENT_WAIT_TIMEOUT);
        
        // Save anyway, then report if the Wait function returned an unexpected error
        errWait = GetLastError();
        
        // Note: Don't throw exception here because even if saving fails, we still need 
        //  to set the saving event.
        hr = (((IUnknown*) (IHsmServer*) this)->QueryInterface(IID_IPersistFile, 
                (void**) &pPersistFile));
        if (SUCCEEDED(hr)) {
            hr = WsbSafeSave(pPersistFile);
        }

        // Check Wait status... Note that hr remains OK because the saving itself completed fine
        switch (status) {
            case WAIT_OBJECT_0: 
                // The expected case
                SetEvent(m_savingEvent);
                break;

            case WAIT_TIMEOUT: 
                // Don't log anything for now: This might happen if snapshot process takes 
                //  too long for some reason, but logging seems to just confuse the user -
                //  he really can not (and should not) do anything...
                WsbTraceAlways(OLESTR("CHsmServer::InternalSavePersistData: Wait for Single Object timed out after %lu ms\n"), EVENT_WAIT_TIMEOUT);
                break;

            case WAIT_FAILED:
                WsbTraceAlways(OLESTR("CHsmServer::InternalSavePersistData: Wait for Single Object returned error %lu\n"), errWait);
                break;

            default:
                WsbTraceAlways(OLESTR("CHsmServer::InternalSavePersistData: Wait for Single Object returned unexpected status %lu\n"), status);
                break;
        }         

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::InternalSavePersistData"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmServer::CancelMountingMedias( void )

/*++

Implements:

  CHsmServer::CancelMountingMedias().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IWsbEnum>           pEnum;
    CComPtr<IMountingMedia>     pMountingMedia;

    WsbTraceIn(OLESTR("CHsmServer::CancelMountingMedias"), OLESTR(""));
    
    try {

        WsbAffirmHr(m_pMountingMedias->Enum(&pEnum));

        // Loop through all mounting media and release waiting mounting clients
        for (hr = pEnum->First(IID_IMountingMedia, (void**) &pMountingMedia);
            SUCCEEDED(hr);
            hr = pEnum->Next(IID_IMountingMedia, (void**) &pMountingMedia)) {

            pMountingMedia->MountDone();
            pMountingMedia = 0;
        }

        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::CancelMountingMedias"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



//
// Methods of the class which uses to upgrade a Win2K rms to current rms
//
HRESULT
CHsmUpgradeRmsDb::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CHsmUpgradeRmsDb::FinalConstruct"), OLESTR("") );

    try {
        WsbAffirmHr(CWsbPersistable::FinalConstruct());

        m_pServer = NULL;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmUpgradeRmsDb::FinalConstruct"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

void
CHsmUpgradeRmsDb::FinalRelease(
    void
    )
/*++

Implements:

  CComObjectRoot::FinalRelease

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CHsmUpgradeRmsDb::FinalRelease"), OLESTR(""));

    CWsbPersistable::FinalRelease();

    WsbTraceOut(OLESTR("CHsmUpgradeRmsDb::FinalRelease"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));
}

HRESULT
CHsmUpgradeRmsDb::GetClassID(
    OUT CLSID* pClsid)
/*++

Implements:

    IPersist::GetClassId

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmUpgradeRmsDb::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        // Return Rms class id since this is what the old col file represents
        *pClsid = CLSID_CRmsServer;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmUpgradeRmsDb::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return hr;
}

HRESULT
CHsmUpgradeRmsDb::Save(
    IN IStream* /*pStream*/,
    IN BOOL /*clearDirty*/
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = E_NOTIMPL;

    WsbTraceIn(OLESTR("CHsmUpgradeRmsDb::Save"), OLESTR(""));
    
    // Not implemented - this class should be used only for load

    WsbTraceOut(OLESTR("CHsmUpgradeRmsDb::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmUpgradeRmsDb::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmUpgradeRmsDb::Load"), OLESTR(""));

    try {
        ULONG   buildVersion;
        ULONG   databaseVersion;
        ULONG   expectedVersion = RMS_WIN2K_DB_VERSION;
        
        WsbAssert(0 != pStream, E_POINTER);

        // Make sure this is the right version of the Rms database to load
        WsbAffirmHr(WsbLoadFromStream(pStream, &databaseVersion));
        if (databaseVersion != expectedVersion) {
            WsbLogEvent( RMS_MESSAGE_DATABASE_VERSION_MISMATCH, 0, NULL, WsbQuickString(WsbPtrToUlongAsString(&expectedVersion)),
                         WsbQuickString(WsbPtrToUlongAsString(&databaseVersion)), NULL );
            WsbThrow(RMS_E_DATABASE_VERSION_MISMATCH);
        }

        // Read in the build version but don't do anything with it.
        WsbAffirmHr(WsbLoadFromStream(pStream, &buildVersion));
        
        // Let Rms manager to this its load
        CComPtr<IPersistStream> pIStream;
        WsbAffirmHr(m_pServer->QueryInterface(IID_IPersistStream, (void **)&pIStream));
        WsbAffirmHr(pIStream->Load(pStream));

    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CHsmUpgradeRmsDb::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT CHsmUpgradeRmsDb::Init(
    IN IRmsServer *pHsmMediaMgr
    )
/*++

Implements:

  IHsmUpgradeRmsDb::Init().

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CHsmUpgradeRmsDb::Init"),OLESTR(""));

    try {
       WsbAssert(0 != pHsmMediaMgr, E_POINTER);

       m_pServer = pHsmMediaMgr;

    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CHsmUpgradeRmsDb::Init"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
CHsmServer::UpdateMediaSizeLimit(
    OUT DWORD* pdwNewLimit
    )

/*++

Implements:

  IHsmServer::UpdateMediaSizeLimit().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmServer::UpdateMediaSizeLimit"), OLESTR(""));

    try {
        LONGLONG                    llBytesCapacity = 0;   
        DWORD                       dwMBCapacity;

        CComPtr<IHsmStoragePool>    pStoragePool;
        ULONG                       count;
        GUID                        mediaSetId;
        CWsbBstrPtr                 dummy;

        WsbAssert(0 != pdwNewLimit, E_POINTER);

        // Get current value from the Registry
        if (WsbGetRegistryValueDWORD(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_MAX_FILE_TO_MIGRATE, pdwNewLimit) != S_OK) {
            *pdwNewLimit = 0;
        }
        WsbTrace(OLESTR("CHsmServer::UpdateMediaSizeLimit: Current limit is %lu\n"), *pdwNewLimit);

        // Get relevant media set - assume only one pool !!
        WsbAffirmHr(m_pStoragePools->GetEntries(&count));
        WsbAffirm(1 == count, E_FAIL);
        WsbAffirmHr(m_pStoragePools->At(0, IID_IHsmStoragePool, (void **)&pStoragePool));
        WsbAffirmHr(pStoragePool->GetMediaSet(&mediaSetId, &dummy));

        // Get currents media limit according to max media size
        WsbAffirmHr(m_pHsmMediaMgr->GetMaxMediaCapacity(mediaSetId, &llBytesCapacity));

        // Allow 95% of raw capacity
        llBytesCapacity = (llBytesCapacity * 95) / 100;
        dwMBCapacity = (DWORD)((llBytesCapacity / 1024) / 1024);


        // Deteremine if to update limit
        if (dwMBCapacity > *pdwNewLimit) {
            *pdwNewLimit = dwMBCapacity;
            WsbAffirmHr(WsbSetRegistryValueDWORD(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_MAX_FILE_TO_MIGRATE, *pdwNewLimit));
            WsbLogEvent(HSM_MESSAGE_NEW_MEDIA_LIMIT, 0, NULL, WsbPtrToUlongAsString(pdwNewLimit), NULL);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmServer::UpdateMediaSizeLimit"), OLESTR("hr = <%ls> , New limit = %lu MB"), WsbHrAsString(hr), *pdwNewLimit);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\hsmeng\hsmstgpl.h ===
/////////////////////////////////////////////////////////////////////////////
// HsmStgPl.h : Declaration of the CHsmStoragePool collectable
/////////////////////////////////////////////////////////////////////////////

#include "resource.h"
#include "wsb.h"

/////////////////////////////////////////////////////////////////////////////


class CHsmStoragePool : 
    public CWsbObject,
    public IHsmStoragePool,
    public CComCoClass<CHsmStoragePool,&CLSID_CHsmStoragePool>
{

public:
    CHsmStoragePool( ) {}
BEGIN_COM_MAP( CHsmStoragePool )
    COM_INTERFACE_ENTRY( IHsmStoragePool )
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY2(IWsbCollectable, IHsmStoragePool)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP( )


DECLARE_REGISTRY_RESOURCEID( IDR_CHsmStoragePool )

//CComObjectRoot
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pTestsPassed, USHORT* pTestsFailed);

// IHsmStoragePool
public:
    STDMETHOD( GetId )( GUID  *pId );
    STDMETHOD( SetId )( GUID  Id );
    STDMETHOD( GetMediaSet)( GUID *pMediaSetId, BSTR *pMediaSetName );
    STDMETHOD( SetMediaSet)( GUID mediaSetId, BSTR mediaSetName );
    STDMETHOD( GetNumOnlineMedia )( ULONG *pNumOnlineMedia );
    STDMETHOD( SetNumOnlineMedia )( ULONG numOnlineMedia );
    STDMETHOD( GetNumMediaCopies )( USHORT *pNumMediaCopies );
    STDMETHOD( SetNumMediaCopies )( USHORT numMediaCopies );
    STDMETHOD( GetManagementPolicy )( GUID *pManagementPolicyId );
    STDMETHOD( SetManagementPolicy )( GUID managementPolicyId );
    STDMETHOD( InitFromRmsMediaSet )( IUnknown  *pRmsMediaSet );
    STDMETHOD( GetRmsMediaSet )( IUnknown  **ppRmsMediaSet );

    STDMETHOD( CompareToIHsmStoragePool )( IHsmStoragePool* pHsmStoragePool, short* psResult );

    STDMETHOD( GetMediaSetType )( USHORT *pMediaType );

// Internal Helper functions

private:
    GUID                            m_Id;               //HSM engine storage pool ID
    GUID                            m_MediaSetId;       //HSM RMS/NTMS media pool ID
    GUID                            m_PolicyId;         //None for Sakkara
    ULONG                           m_NumOnlineMedia;   //None for Sakkara                      
    USHORT                          m_NumMediaCopies;   //Number of media copies
    CWsbBstrPtr                     m_MediaSetName;     //HSM RMS/NTMS media pool name
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\hsmeng\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\hsmeng\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by HsmEng.rc
//
#define IDS_HSMSERVER_DESC              1
#define IDR_HsmServer                   1
#define IDS_SERVICENAME                 100
#define IDR_HsmEng                      100
#define IDS_SERVICE_DISPLAYNAME         101
#define IDS_SERVICE_DESCRIPTION         102
#define IDS_PRODUCT_NAME                103
#define IDR_CHsmManagedResource         201
#define IDR_CHsmManagedResourceCollection 301
#define IDR_CHsmStoragePool             401
#define IDR_HsmUpgradeRmsDb             501
#define IDR_CMountingMedia              601

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        701
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         301
#define _APS_NEXT_SYMED_VALUE           301
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\hsmeng\mountmed.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 2000

Module Name:

    mountmed.cpp

Abstract:

    This component is an object representing a mounting media, i.e. a media in the process of mounting.

Author:

    Ran Kalach   [rankala]   28-Sep-2000

Revision History:

--*/

#include "stdafx.h"
#include "mountmed.h"

static USHORT iCountMount = 0;  // Count of existing objects

HRESULT
CMountingMedia::FinalConstruct(
    void
    )
/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMountingMedia::FinalConstruct"), OLESTR(""));

    m_mediaId = GUID_NULL;
    m_mountEvent = NULL;
    m_bReadOnly = FALSE;

    iCountMount++;

    WsbTraceOut(OLESTR("CMountingMedia::FinalConstruct"), OLESTR("hr = <%ls>, Count is <%d>"), WsbHrAsString(hr), (int)iCountMount);

    return(hr);
}

void
CMountingMedia::FinalRelease(
    void
    )
/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    WsbTraceIn(OLESTR("CMountingMedia::FinalRelease"), OLESTR(""));

    // Free event handle
    if (m_mountEvent != NULL) {
        // Set the event (just to be on the safe side - we expect the event to be signaled at this point)
        SetEvent(m_mountEvent);

        CloseHandle(m_mountEvent);
        m_mountEvent = NULL;
    }

    iCountMount--;

    WsbTraceOut(OLESTR("CMountingMedia::FinalRelease"), OLESTR("Count is <%d>"), (int)iCountMount);
}

HRESULT
CMountingMedia::Init(
    REFGUID mediaId,
    BOOL bReadOnly
    )
/*++

Implements:

  IMountingMedia::Init().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMountingMedia::Init"), OLESTR(""));

    try {
        m_mediaId = mediaId;
        m_bReadOnly = bReadOnly;

        WsbAffirmHandle(m_mountEvent= CreateEvent(NULL, TRUE, FALSE, NULL));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMountingMedia::Init"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CMountingMedia::GetMediaId(
    GUID *pMediaId
    )
/*++

Implements:

  IMountingMedia::GetMediaId().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMountingMedia::GetMediaId"), OLESTR(""));

    try {
        WsbAffirm(0 != pMediaId, E_POINTER);

        *pMediaId = m_mediaId;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMountingMedia::GetMediaId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CMountingMedia::SetMediaId(
    REFGUID mediaId
    )
/*++

Implements:

  IMountingMedia::SetMediaId().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMountingMedia::SetMediaId"), OLESTR(""));

    m_mediaId = mediaId;

    WsbTraceOut(OLESTR("CMountingMedia::SetMediaId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CMountingMedia::SetIsReadOnly(
    BOOL bReadOnly
    )
/*++

Implements:

  IMountingMedia::SetIsReadOnly().

--*/
{
    WsbTraceIn(OLESTR("CMountingMedia::SetIsReadOnly"), OLESTR("bReadOnly = %d"), bReadOnly);

    m_bReadOnly = bReadOnly;

    WsbTraceOut(OLESTR("CMountingMedia::SetIsReadOnly"), OLESTR(""));

    return(S_OK);
}

HRESULT
CMountingMedia::IsReadOnly(
    void    
    )
/*++

Implements:

  IMountingMedia::IsReadOnly().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMountingMedia::IsReadOnly"), OLESTR(""));

    hr = (m_bReadOnly ? S_OK : S_FALSE);

    WsbTraceOut(OLESTR("CMountingMedia::IsReadOnly"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}
                                
HRESULT
CMountingMedia::WaitForMount(
    DWORD dwTimeout
    )
/*++

Implements:

  IMountingMedia::WaitForMount().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMountingMedia::WaitForMount"), OLESTR(""));

    // Wait for the mount event for the given timeout
    switch (WaitForSingleObject(m_mountEvent, dwTimeout)) {
        case WAIT_OBJECT_0:
            WsbTrace(OLESTR("CMountingMedia::WaitForMount: signaled that media is mounted\n"));
            break;

        case WAIT_TIMEOUT: 
            WsbTrace(OLESTR("CMountingMedia::WaitForMount: WaitForSingleObject timed out after waiting for %lu ms\n"), dwTimeout);
            hr = E_FAIL;
            break;

        case WAIT_FAILED:
        default:
            DWORD dwErr = GetLastError();
            hr = HRESULT_FROM_WIN32(dwErr);
            WsbTrace(OLESTR("CMountingMedia::WaitForMount: WaitForSingleObject returned error %lu\n"), dwErr);
            break;
    }

    WsbTraceOut(OLESTR("CMountingMedia::WaitForMount"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CMountingMedia::MountDone(
    void
    )
/*++

Implements:

  IMountingMedia::MountDone().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMountingMedia::MountDone"), OLESTR(""));

    // Mount is done: set the mount event
    if (! SetEvent(m_mountEvent)) {
        DWORD dwErr = GetLastError();
        WsbTrace(OLESTR("CMountingMedia::MountDone: SetEvent returned error %lu\n"), dwErr);
        hr = HRESULT_FROM_WIN32(dwErr);
    }

    WsbTraceOut(OLESTR("CMountingMedia::MountDone"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CMountingMedia::IsEqual(
    IUnknown* pCollectable
    )
/*++

Implements:

  IWsbCollectable::IsEqual().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMountingMedia::IsEqual"), OLESTR(""));

    hr = CompareTo(pCollectable, NULL);

    WsbTraceOut(OLESTR("CMountingMedia::IsEqual"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CMountingMedia::CompareTo(
    IUnknown* pCollectable, 
    SHORT* pResult
    )
/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT                     hr = S_OK;
    SHORT                       result = 0;
    CComPtr<IMountingMedia>     pMountingMedia;
    GUID                        mediaId;

    WsbTraceIn(OLESTR("CMountingMedia::CompareTo"), OLESTR(""));

    try {
        // Did they give us a valid item to compare to?
        WsbAssert(0 != pCollectable, E_POINTER);
        WsbAffirmHr(pCollectable->QueryInterface(IID_IMountingMedia, (void**) &pMountingMedia));
        WsbAffirmHr(pMountingMedia->GetMediaId(&mediaId));

        // Compare
        if (IsEqualGUID(m_mediaId, mediaId)) {
            hr = S_OK;
            result = 0;
        } else {
            // Need to provide signed result...
            hr = S_FALSE;
            result = WsbSign(memcmp(&m_mediaId, &mediaId, sizeof(GUID)));
        }

        // If they asked for the relative value back, then return it to them.
        if (pResult != NULL) {
            *pResult = result;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMountingMedia::CompareTo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\hsmeng\makefile.inc ===
$(O)\HsmEng.res: HsmServ.rgs   \
                 HsmMgdRs.rgs  \
                 HsmMgdRc.rgs  \
                 HsmStgPl.rgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\hsmeng\hsmstgpl.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    HsmStgPl.cpp

Abstract:

    This component is an object representation of the HSM Storage Pool. It
    is both a persistable and collectable.

Author:

    Cat Brant   [cbrant]   09-Feb-1997

Revision History:

--*/


#include "stdafx.h"
#include "Wsb.h"
#include "HsmEng.h"
#include "HsmServ.h"
#include "HsmConn.h"
#include "HsmStgPl.h"
#include "Fsa.h"
#include "Rms.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMENG

HRESULT 
CHsmStoragePool::FinalConstruct(
    void
    ) 
/*++

Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbObject::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        
        m_MediaSetId = GUID_NULL;
        m_PolicyId = GUID_NULL;
        m_NumOnlineMedia = 0;
        m_NumMediaCopies = 0;
        m_MediaSetName = "  ";
        
        WsbAffirmHr(CoCreateGuid( &m_Id ));
        
    } WsbCatch(hr);

    return(hr);
}

HRESULT 
CHsmStoragePool::GetId(
    OUT GUID *pId
    ) 
/*++

Routine Description:

  See IHsmStoragePool::GetId

Arguments:

  See IHsmStoragePool::GetId

Return Value:
  
    See IHsmStoragePool::GetId

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmStoragePool::GetId"),OLESTR(""));

    try {
        //Make sure we can provide data memebers
        WsbAssert(0 != pId, E_POINTER);

        //Provide the data members
        *pId = m_Id;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmStoragePool::GetId"),
        OLESTR("hr = <%ls>, Id = <%ls>>"),WsbHrAsString(hr), WsbPtrToGuidAsString(pId));

    return(hr);
}

HRESULT 
CHsmStoragePool::SetId(
    GUID Id
    ) 
/*++

Routine Description:

  See IHsmStoragePool::SetId

Arguments:

  See IHsmStoragePool::SetId

Return Value:
  
    See IHsmStoragePool::SetId

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmStoragePool::SetId"),OLESTR("Id = <%ls>>"), WsbGuidAsString(Id));

    try {

        //Provide the data members
        m_Id = Id;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmStoragePool::SetId"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CHsmStoragePool::GetClassID (
    OUT LPCLSID pClsId
    ) 
/*++

Routine Description:

  See IPerist::GetClassID()

Arguments:

  See IPerist::GetClassID()

Return Value:

    See IPerist::GetClassID()

--*/

{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmStoragePool::GetClassID"), OLESTR(""));


    try {
        WsbAssert(0 != pClsId, E_POINTER);
        *pClsId = CLSID_CHsmStoragePool;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmStoragePool::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsId));
    return(hr);
}

HRESULT 
CHsmStoragePool::GetSizeMax (
    OUT ULARGE_INTEGER* pcbSize
    ) 
/*++

Routine Description:

  See IPersistStream::GetSizeMax().

Arguments:

  See IPersistStream::GetSizeMax().

Return Value:

  See IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmStoragePool::GetSizeMax"), OLESTR(""));

    try {
        ULONG nameLen;
        
        WsbAssert(0 != pcbSize, E_POINTER);
        
        nameLen = SysStringByteLen(m_MediaSetName);

        pcbSize->QuadPart = ((3 * WsbPersistSizeOf(GUID)) +  // m_id + m_MediaSetID + m_PolicyId
                             WsbPersistSizeOf(ULONG) +       // m_NumOnlineMedia
                             WsbPersistSizeOf(USHORT) +      // m_NumMediaCopies
                             nameLen);                       // m_MediaSetName
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmStoragePool::GetSizeMax"), 
        OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), 
        WsbPtrToUliAsString(pcbSize));

    return(hr);
}

HRESULT 
CHsmStoragePool::Load (
    IN IStream* pStream
    ) 
/*++

Routine Description:

  See IPersistStream::Load().

Arguments:

  See IPersistStream::Load().

Return Value:

  See IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmStoragePool::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);


        WsbAffirmHr(WsbLoadFromStream(pStream, &m_Id));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_MediaSetId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_PolicyId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_NumOnlineMedia));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_NumMediaCopies));
        m_MediaSetName.Free();
        WsbAffirmHr(WsbBstrFromStream(pStream, &m_MediaSetName));
        
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmStoragePool::Load"), 
        OLESTR("hr = <%ls>,  GUID = <%ls>"), 
        WsbHrAsString(hr), 
        WsbGuidAsString(m_Id));
    return(hr);
}

HRESULT 
CHsmStoragePool::Save (
    IN IStream* pStream, 
    IN BOOL clearDirty
    ) 
/*++

Routine Description:

  See IPersistStream::Save().

Arguments:

  See IPersistStream::Save().

Return Value:

  See IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmStoragePool::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbSaveToStream(pStream, m_Id));
        WsbAffirmHr(WsbSaveToStream(pStream, m_MediaSetId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_PolicyId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_NumOnlineMedia));
        WsbAffirmHr(WsbSaveToStream(pStream, m_NumMediaCopies));
        WsbAffirmHr(WsbBstrToStream(pStream, m_MediaSetName));
        
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmStoragePool::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CHsmStoragePool::Test (
    OUT USHORT *pTestsPassed, 
    OUT USHORT *pTestsFailed 
    ) 
/*++

Routine Description:

  See IWsbTestable::Test().

Arguments:

  See IWsbTestable::Test().

Return Value:

  See IWsbTestable::Test().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IHsmStoragePool>        pHsmStoragePool1;
    CComPtr<IHsmStoragePool>        pHsmStoragePool2;
    GUID                    l_Id;

    WsbTraceIn(OLESTR("CHsmStoragePool::Test"), OLESTR(""));

    *pTestsPassed = *pTestsFailed = 0;
    try {
        // Get the pHsmStoragePool interface.
        WsbAffirmHr(((IUnknown*)(IHsmStoragePool*) this)->QueryInterface(IID_IHsmStoragePool,
                    (void**) &pHsmStoragePool1));


        hr = S_OK;
        try {
            //Create another instance and test the comparisson methods:
            WsbAffirmHr(CoCreateInstance(CLSID_CHsmStoragePool, NULL, CLSCTX_ALL, IID_IHsmStoragePool, (void**) &pHsmStoragePool2));

            // Check the default values.
            WsbAffirmHr(pHsmStoragePool2->GetId(&l_Id));
            WsbAffirm((l_Id == GUID_NULL), E_FAIL);
        }  WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmStoragePool::Test"),    OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(S_OK);
}

HRESULT 
CHsmStoragePool::CompareTo (
    IN IUnknown* pCollectable, 
    OUT short* pResult
    ) 
/*++

Routine Description:

        1  : object > value
        0  : object = value
        -1 : object < value
    In addition, the return code is S_OK if the object = value and
    S_FALSE otherwise.

Arguments:


Return Value:

    S_OK        - object = value

    S_FALSE     - object != value

--*/

{
    HRESULT                  hr = S_OK;
    CComPtr<IHsmStoragePool> pHsmStoragePool;

    WsbTraceIn(OLESTR("CHsmStoragePool::CompareTo"), OLESTR(""));


    // Did they give us a valid item to compare to?
    try {
        WsbAssert(pCollectable != NULL, E_POINTER);

        // We need the IWsbLong interface to get the value of the object.
        WsbAffirmHr(pCollectable->QueryInterface(IID_IHsmStoragePool, (void**) &pHsmStoragePool));
        hr = pHsmStoragePool->CompareToIHsmStoragePool(this, pResult);
        } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmStoragePool::CompareTo"), OLESTR("hr = <%ls>, pResult = <%d>"), WsbHrAsString(hr), pResult);

    return(hr);
}

HRESULT 
CHsmStoragePool::CompareToIHsmStoragePool (
    IN IHsmStoragePool* pHsmStoragePool, 
    OUT short* pResult
    )
{
    HRESULT                 hr = S_OK;
    GUID                    l_Id;
    BOOL                    areGuidsEqual;


    WsbTraceIn(OLESTR("CHsmStoragePool::CompareToIHsmStoragePool"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(pHsmStoragePool != NULL, E_POINTER);

        WsbAffirmHr(((IHsmStoragePool *)pHsmStoragePool)->GetId(&l_Id));

        // Make sure the GUID matches.  Then see if the SegStartLoc is in the range of this entry
        areGuidsEqual = IsEqualGUID(m_Id, l_Id);
        WsbAffirm( (areGuidsEqual == TRUE), S_FALSE); 

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmStoragePool::CompareToIHsmStoragePool"), OLESTR("hr = <%ls>, pResult = <%d>"), WsbHrAsString(hr), pResult);

    return(hr);
}

HRESULT 
CHsmStoragePool::GetMediaSet( 
    GUID *pMediaSetId, 
    BSTR *pMediaSetName 
    )
/*++

Routine Description:

  See IHsmStoragePool::

Arguments:

  See IHsmStoragePool::

Return Value:

  See IHsmStoragePool::

--*/
{
    HRESULT                 hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmStoragePool::GetMediaSet"),OLESTR(""));
    
    try  {
        WsbAssert(0 != pMediaSetId, E_POINTER);
        WsbAssert(0 != pMediaSetName, E_POINTER);
        *pMediaSetName = WsbAllocString( m_MediaSetName );
        
        *pMediaSetId = m_MediaSetId;
    } WsbCatch( hr );
    
    WsbTraceOut(OLESTR("CHsmStoragePool::GetMediaSet"),
        OLESTR("hr = <%ls>, Id = <%ls>>"),WsbHrAsString(hr), WsbPtrToGuidAsString(pMediaSetId));
    return( hr );
}    
    

HRESULT 
CHsmStoragePool::SetMediaSet( 
    GUID mediaSetId, 
    BSTR mediaSetName 
    )
/*++

Routine Description:

  See IHsmStoragePool::

Arguments:

  See IHsmStoragePool::

Return Value:

  See IHsmStoragePool::

--*/
{
    HRESULT                 hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmStoragePool::SetMediaSet"),OLESTR(""));
    
    try  {
        m_MediaSetId = mediaSetId;
        m_MediaSetName = mediaSetName;
        
        m_isDirty = TRUE;
        
    } WsbCatch( hr );
    
    WsbTraceOut(OLESTR("CHsmStoragePool::SetMediaSet"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return( hr );
}    

HRESULT 
CHsmStoragePool::GetNumOnlineMedia( 
    ULONG *pNumOnlineMedia 
    )
/*++

Routine Description:

  See IHsmStoragePool::

Arguments:

  See IHsmStoragePool::

Return Value:

  See IHsmStoragePool::

--*/
{
    HRESULT                 hr = S_OK;
    WsbTraceIn(OLESTR("CHsmStoragePool::GetNumOnlineMedia"),OLESTR(""));
    
    try  {
        
        WsbAffirm(0 != pNumOnlineMedia, E_POINTER);
        *pNumOnlineMedia = m_NumOnlineMedia;
        
    } WsbCatch( hr );
    
    WsbTraceOut(OLESTR("CHsmStoragePool::GetNumOnlineMedia"),
        OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return( hr );
}    

HRESULT 
CHsmStoragePool::SetNumOnlineMedia( 
    ULONG numOnlineMedia 
    )
/*++

Routine Description:

  See IHsmStoragePool::

Arguments:

  See IHsmStoragePool::

Return Value:

  See IHsmStoragePool::

--*/
{
    HRESULT                 hr = S_OK;
    WsbTraceIn(OLESTR("CHsmStoragePool::SetNumOnlineMedia"),OLESTR(""));
    
    m_NumOnlineMedia = numOnlineMedia;
    m_isDirty = TRUE;
    
    WsbTraceOut(OLESTR("CHsmStoragePool::SetNumOnlineMedia"),
        OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return( hr );
}    

HRESULT 
CHsmStoragePool::GetNumMediaCopies( 
    USHORT *pNumMediaCopies 
    )
/*++

Routine Description:

  See IHsmStoragePool::

Arguments:

  See IHsmStoragePool::

Return Value:

  See IHsmStoragePool::

--*/
{
    HRESULT                 hr = S_OK;
    WsbTraceIn(OLESTR("CHsmStoragePool::GetNumMediaCopies"),OLESTR(""));
    
    try  {
        
        WsbAffirm(0 != pNumMediaCopies, E_POINTER);
        *pNumMediaCopies = m_NumMediaCopies;
        
    } WsbCatch( hr );
    
    WsbTraceOut(OLESTR("CHsmStoragePool::GetNumMediaCopies"),
        OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return( hr );
}    

HRESULT 
CHsmStoragePool::SetNumMediaCopies( 
    USHORT numMediaCopies 
    )
/*++

Routine Description:

  See IHsmStoragePool::

Arguments:

  See IHsmStoragePool::

Return Value:

  See IHsmStoragePool::

--*/
{
    HRESULT                 hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmStoragePool::SetNumMediaCopies"),OLESTR(""));

    m_NumMediaCopies = numMediaCopies;
    m_isDirty = TRUE;
    
    WsbTraceOut(OLESTR("CHsmStoragePool::SetNumMediaCopies"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );
}    

HRESULT 
CHsmStoragePool::GetManagementPolicy( 
    GUID *pManagementPolicyId 
    )
/*++

Routine Description:

  See IHsmStoragePool::

Arguments:

  See IHsmStoragePool::

Return Value:

  See IHsmStoragePool::

--*/
{
    HRESULT                 hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmStoragePool::GetManagementPolicy"),OLESTR(""));
    
    try  {
        
        WsbAffirm(0 != pManagementPolicyId, E_POINTER);
        *pManagementPolicyId = m_PolicyId;
        
    } WsbCatch( hr );
    
    WsbTraceOut(OLESTR("CHsmStoragePool::GetManagementPolicy"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return( hr );
}    

HRESULT 
CHsmStoragePool::SetManagementPolicy( 
    GUID managementPolicyId 
    )
/*++

Routine Description:

  See IHsmStoragePool::

Arguments:

  See IHsmStoragePool::

Return Value:

  See IHsmStoragePool::

--*/
{
    HRESULT                 hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmStoragePool::SetManagementPolicy"),OLESTR(""));

    m_PolicyId = managementPolicyId;
    m_isDirty = TRUE;
    
    WsbTraceOut(OLESTR("CHsmStoragePool::SetManagementPolicy"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return( hr );
}    

HRESULT 
CHsmStoragePool::GetRmsMediaSet (
    IUnknown **ppIRmsMediaSet
    )
/*++

Routine Description:

  See IHsmStoragePool::

Arguments:

  See IHsmStoragePool::

Return Value:

  See IHsmStoragePool::

--*/
{
    HRESULT                 hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmStoragePool::GetRmsMediaSet"),OLESTR(""));
    
    try  {
        WsbAffirm(0 != ppIRmsMediaSet, E_POINTER );
        hr = E_NOTIMPL;
        
    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmStoragePool::GetRmsMediaSet"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return( hr );
}    

#define     HSM_DEFAULT_MAXSIZE_OPTICAL     (1024)
#define     HSM_DEFAULT_MAXSIZE_TAPE        (1024*10)

HRESULT 
CHsmStoragePool::InitFromRmsMediaSet (
    IUnknown *pIRmsMediaSet
    )
/*++

Routine Description:                                                                

  See IHsmStoragePool::

Arguments:

  See IHsmStoragePool::

Return Value:

  See IHsmStoragePool::

--*/
{
    HRESULT                 hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmStoragePool::InitFromRmsMediaSet"),OLESTR(""));
    
    try  {
        WsbAffirm(0 != pIRmsMediaSet, E_POINTER );
        //
        // Get the real interface                                                                            
        //
        CComPtr<IRmsMediaSet>       l_pIRmsMediaSet;
        WsbAffirmHr(pIRmsMediaSet->QueryInterface(IID_IRmsMediaSet, (void **)&l_pIRmsMediaSet));
        WsbAffirmHr(l_pIRmsMediaSet->GetMediaSetId(&m_MediaSetId));
        m_MediaSetName.Free();
        WsbAffirmHr(l_pIRmsMediaSet->GetName(&m_MediaSetName));

        // Set in the Registry which media type is being used
        // Set in the Registry max-file-size-to-migrate (in MB)
        //  Note: This hack should be removed when HSM supports more than one media type on the same system
        LONG            mediaType;
        DWORD           dwType;
        DWORD           dwSize;
        WsbAffirmHr(l_pIRmsMediaSet->GetMediaSupported(&mediaType));
        switch (mediaType) {
        case RmsMediaOptical: 
        case RmsMediaFixed:
        case RmsMediaDVD:
            dwType = HSM_VALUE_TYPE_DIRECTACCESS;
            dwSize = HSM_DEFAULT_MAXSIZE_OPTICAL;
            break;
        case RmsMedia8mm:
        case RmsMedia4mm:
        case RmsMediaDLT:
        case RmsMediaTape:
            dwType = HSM_VALUE_TYPE_SEQUENTIAL;
            dwSize = HSM_DEFAULT_MAXSIZE_TAPE;
            break;
        default:
            // This is not expected, however, we set tape as default
            WsbTraceAlways(OLESTR("CHsmStoragePool::InitFromRmsMediaSet : Got an unexpected media type %ld !!!\n"), mediaType);
            dwType = HSM_VALUE_TYPE_SEQUENTIAL;
            dwSize = HSM_DEFAULT_MAXSIZE_TAPE;
            break;
        }

        WsbAffirmHr(WsbSetRegistryValueDWORD(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_MEDIA_TYPE, dwType));
        WsbAffirmHr(WsbSetRegistryValueDWORD(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_MAX_FILE_TO_MIGRATE, dwSize));

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmStoragePool::InitFromRmsMediaSet"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return( hr );
}    

HRESULT 
CHsmStoragePool::GetMediaSetType (
    USHORT *pMediaType
    )
/*++

Routine Description:                                                                

  Gets the media type of the corresponding media set

Arguments:

  pMediaType - media type, currently, the only options are direct-access or sequential

Return Value:

  S_OK for success

Notes:

  Future: Might consider keeping the media type instead of asking the media-set object again and again -
          Media type is not a dynamic propery. However, this reuires a change in the .col file structure.

--*/
{
    HRESULT                 hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmStoragePool::GetMediaSetType"),OLESTR(""));
    
    try  {
        WsbAffirm(0 != pMediaType, E_POINTER );

        // Get media-set object
        CComPtr<IHsmServer>         pHsmServer;
        CComPtr<IRmsServer>         pRmsServer;
        CComPtr<IRmsMediaSet>       pRmsMediaSet;

        WsbAssertHr(HsmConnectFromId(HSMCONN_TYPE_HSM, GUID_NULL, IID_IHsmServer, (void**) &pHsmServer));
        WsbAffirmHr(pHsmServer->GetHsmMediaMgr(&pRmsServer));
        WsbAffirmHr(pRmsServer->CreateObject(m_MediaSetId, CLSID_CRmsMediaSet, IID_IRmsMediaSet, RmsOpenExisting, (void **)&pRmsMediaSet));

        // Determine media type
        LONG            mediaType;
        WsbAffirmHr(pRmsMediaSet->GetMediaSupported(&mediaType));
        switch (mediaType) {
            case RmsMediaOptical: 
            case RmsMediaFixed:
            case RmsMediaDVD:
                *pMediaType = HSM_VALUE_TYPE_DIRECTACCESS;
                break;
            case RmsMedia8mm:
            case RmsMedia4mm:
            case RmsMediaDLT:
            case RmsMediaTape:
                *pMediaType = HSM_VALUE_TYPE_SEQUENTIAL;
                break;
            default:
                // This is not expected, however, we set tape as default
                WsbTraceAlways(OLESTR("CHsmStoragePool::GetMediaSetType : Got an unexpected media type %hu !!!\n"), *pMediaType);
                *pMediaType = HSM_VALUE_TYPE_SEQUENTIAL;
                break;
        }

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmStoragePool::GetMediaSetType"),OLESTR("Media-type = %hu hr = <%ls>"), *pMediaType, WsbHrAsString(hr));

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\hsmeng\mountmed.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 2000

Module Name:

    mountmed.h

Abstract:

    This component is an object representing a mounting media, i.e. a media in the process of mounting.

Author:

    Ran Kalach   [rankala]   28-Sep-2000

Revision History:

--*/

#ifndef _MOUNTMED_
#define _MOUNTMED_

#include "wsbcltbl.h"

/*++

Class Name:
    
    CMountingMedia

Class Description:

    An object representing a media in the process of mounting. 
    It is collectable but not persistable.

--*/
class CMountingMedia : 
    public CComObjectRoot,
    public IMountingMedia,
    public IWsbCollectable,
    public CComCoClass<CMountingMedia, &CLSID_CMountingMedia>
{
public:
    CMountingMedia() {}
BEGIN_COM_MAP(CMountingMedia)
    COM_INTERFACE_ENTRY(IMountingMedia)
    COM_INTERFACE_ENTRY(IWsbCollectable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CMountingMedia)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IN IUnknown* pCollectable, OUT SHORT* pResult);
    STDMETHOD(IsEqual)(IN IUnknown* pCollectable);

// IMountingMedia
public:
    STDMETHOD(Init)(IN REFGUID mediaId, IN BOOL bReadOnly);
    STDMETHOD(GetMediaId)(OUT GUID *pMediaId);
    STDMETHOD(SetMediaId)(IN REFGUID MediaId);
    STDMETHOD(WaitForMount)(IN DWORD dwTimeout);
    STDMETHOD(MountDone) (void);
    STDMETHOD(SetIsReadOnly)(IN BOOL bReadOnly);
    STDMETHOD(IsReadOnly)(void);

protected:
    GUID            m_mediaId;
    HANDLE          m_mountEvent;
    BOOL            m_bReadOnly;
};

#endif // _MOUNTMED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\hsmeng\rswriter.h ===
/*++
Copyright (C) Microsoft Corporation, 1996 - 2000

Module Name:

    rswriter.h

Abstract:

    This module defines the CRssJetWriter class.

Author:

    Ran Kalach (rankala)  4/4/00

--*/


#ifndef _RSWRITER_
#define _RSWRITER_


#include <jetwriter.h>
#include <rsevents.h>

/*++

Class Name:
    
    CRssJetWriter

Class Description:

    This class is HSM implementation to the Jet-Writer base class, which synchronize
    a jet user application with snapshots mechanizm

--*/

#define     WRITER_EVENTS_NUM       (SYNC_STATE_EVENTS_NUM+1)
#define     INTERNAL_EVENT_INDEX    0
#define     INTERNAL_WAIT_TIMEOUT   (10*1000)   // 10 seconds

class CRssJetWriter : public CVssJetWriter
{

// Constructors
public:
    CRssJetWriter();

// Destructor
public:
    virtual ~CRssJetWriter();

// Public methods
public:
    HRESULT Init();
    HRESULT Terminate();

// CVssJetWriter overloading
	virtual bool STDMETHODCALLTYPE OnFreezeBegin();
	virtual bool STDMETHODCALLTYPE OnThawEnd(IN bool fJetThawSucceeded);
	virtual void STDMETHODCALLTYPE OnAbortEnd();

// Private methods
protected:
    HRESULT InternalEnd(void);

// Member Data
protected:
    HRESULT                 m_hrInit;
    HANDLE                  m_syncHandles[WRITER_EVENTS_NUM];
    BOOL                    m_bTerminating;
};


#endif // _RSWRITER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\hsmeng\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
#ifndef _STDAFX_H
#define _STDAFX_H

//
// These NT header files must be included before any Win32 stuff or you
// get lots of compiler errors
//
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#define WSB_TRACE_IS WSB_TRACE_BIT_HSMENG

#include <wsb.h>
#include <Engine.h>
#include "engcommn.h"
#include "resource.h"
#include "esent.h"

#endif // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\inc\engcommn.h ===
/*++

Copyright (c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    EngCommn.h

Abstract:

    This header file defines some constants for the HSM Engine.

Author:

    Rohde Wakefield       [rohde]    31-Aug-1998

Revision History:

--*/

#ifndef _ENGCOMMN_H
#define _ENGCOMMN_H

//
// Registry strings
//
#define HSM_DEFAULT_RESOURCE_MANAGEMENT_LEVEL       OLESTR("Resource_Management_Level")
#define HSM_DEFAULT_INACT_DAYS                      OLESTR("Default_Inactivity_Days")
#define HSM_DEFAULT_RESULTS_DAYS                    OLESTR("Default_Results_Days")
#define HSM_DEFAULT_RESULTS_LEVEL                   OLESTR("Default_Results_Level")
#define HSM_MRU_ENABLED                             OLESTR("MRU_Enabled")
#define HSM_FULL_ACTION                             OLESTR("Full_Action")
#define HSM_STATUS                                  OLESTR("Status")
#define HSM_TRACE_SETTINGS                          OLESTR("SystemTraceSettings")
#define HSM_TRACE_ON                                OLESTR("SystemTraceOn")
#define HSM_FILES_BEFORE_COMMIT                     OLESTR("NumberOfFilesBeforeCommit")
#define HSM_MAX_BYTES_BEFORE_COMMIT                 OLESTR("MaximumNumberOfBytesBeforeCommit")
#define HSM_MIN_BYTES_BEFORE_COMMIT                 OLESTR("MinimumNumberOfBytesBeforeCommit")
#define HSM_MAX_BYTES_AT_END_OF_MEDIA               OLESTR("MaximumNumberOfBytesAtEndOfMedia")
#define HSM_MIN_BYTES_AT_END_OF_MEDIA               OLESTR("MinimumNumberOfBytesAtEndOfMedia")
#define HSM_MAX_PERCENT_AT_END_OF_MEDIA             OLESTR("MaximumPercentageAtEndOfMedia")
#define HSM_DONT_SAVE_DATABASES                     OLESTR("DoNotSaveCriticalDataToMedia")
#define HSM_QUEUE_ITEMS_TO_PAUSE                    OLESTR("QueueItemsToPause")
#define HSM_QUEUE_ITEMS_TO_RESUME                   OLESTR("QueueItemsToResume")
#define HSM_MEDIA_BASE_NAME                         OLESTR("MediaBaseName")
#define HSM_JOB_ABORT_CONSECUTIVE_ERRORS            OLESTR("JobAbortConsecutiveErrors")
#define HSM_JOB_ABORT_TOTAL_ERRORS                  OLESTR("JobAbortTotalErrors")
#define HSM_JOB_ABORT_SYS_DISK_SPACE                OLESTR("JobAbortSysDiskSpace")
#define HSM_MIN_BYTES_TO_MIGRATE                    OLESTR("MinimumNumberOfBytesToMigrate")
#define HSM_MIN_FILES_TO_MIGRATE                    OLESTR("MinimumFreeSpaceInF")
#define HSM_MIN_FREE_SPACE_IN_FULL_MEDIA            OLESTR("MinimumFreeSpaceInFullMedia")
#define HSM_MAX_FREE_SPACE_IN_FULL_MEDIA            OLESTR("MaximumFreeSpaceInFullMedia")

#define HSM_MEDIA_TYPE                              OLESTR("MediaType")
#define HSM_VALUE_TYPE_SEQUENTIAL                   0
#define HSM_VALUE_TYPE_DIRECTACCESS                 1

#define HSM_ENG_DIR_LEN                             256

#define HSM_ENGINE_REGISTRY_NAME                    OLESTR("Remote_Storage_Server")

#endif // _ENGCOMMN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\task\baghole.h ===
// BagHole.h : Declaration of the CBagHole


#include "resource.h"       // main symbols
#include "Wsb.h"            // Wsb Collectable Class
#include "wsbdb.h"


/////////////////////////////////////////////////////////////////////////////
// Task

class CBagHole : 
    public CWsbDbEntity,
    public IBagHole,
    public CComCoClass<CBagHole,&CLSID_CBagHole>
{
public:
    CBagHole() {}
BEGIN_COM_MAP(CBagHole)
    COM_INTERFACE_ENTRY(IBagHole)
    COM_INTERFACE_ENTRY2(IWsbDbEntity, CWsbDbEntity)
    COM_INTERFACE_ENTRY(IWsbDbEntityPriv)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY(CBagHole, _T("Task.BagHole.1"), _T("Task.BagHole"), IDS_BAGHOLE_DESC, THREADFLAGS_BOTH)

// IBagHole
public:
    STDMETHOD(FinalConstruct)(void);

// IWsbDbEntity
public:
    STDMETHOD(Print)(IStream* pStream);
    STDMETHOD(UpdateKey)(IWsbDbKey *pKey);
    WSB_FROM_CWSBDBENTITY;

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pTestsPassed, USHORT* pTestsFailed);
//*/
// IBagHole
public:
    STDMETHOD(GetBagHole)(GUID* pBagId, LONGLONG *pSegStartLoc, LONGLONG *pSegLen );
    STDMETHOD(SetBagHole)(GUID bagId, LONGLONG segStartLoc, LONGLONG SegLen );

private:
    GUID            m_BagId;
    LONGLONG        m_SegStartLoc;
    LONGLONG        m_SegLen;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\hsmeng\rswriter.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    rswriter.cpp

Abstract:

    Implements CRssJetWriter methods

Author:

    Ran Kalach          [rankala]         4/4/2000

Revision History:

--*/

#include "stdafx.h"
#include "rsevents.h"
#include "rswriter.h"

// Include these 2 files just for VSS_E_WRITERERROR_TIMEOUT definition
#include "vss.h"
#include "vswriter.h"   

#include "aclapi.h"

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

DEFINE_GUID(RSS_WRITER_GUID, 0xb959d2c3L, 0x18bb, 0x4607,  0xb0, 0xca, 
0x68,  0x8c, 0xd0, 0xd4, 0x1a, 0x50);       // {b959d2c3-18bb-4607-b0ca-688cd0d41a50}

#ifdef __cplusplus
}
#endif


#define     FILES_TO_EXCLUDE    OLESTR("%SystemRoot%\\System32\\RemoteStorage\\FsaDb\\*;%SystemRoot%\\System32\\RemoteStorage\\Trace\\*")
#define     FILES_TO_INCLUDE    OLESTR("")

CRssJetWriter::CRssJetWriter()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    None

Notes:
    We create the events in the constructor because these events might be required
    before the Init code could be done (Init must be called after Jet is initialized

--*/
{
    HRESULT                     hr = S_OK;

    PSID pSystemSID = NULL;
    PACL pACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
#define     WRITER_EVENTS_NUM_ACE      1
    EXPLICIT_ACCESS ea[WRITER_EVENTS_NUM_ACE];
    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
    SECURITY_ATTRIBUTES sa;

    WsbTraceIn(OLESTR("CRssJetWriter::CRssJetWriter"), OLESTR(""));

    m_bTerminating = FALSE;

    try {
        for (int index=0; index<WRITER_EVENTS_NUM; index++) {
            m_syncHandles[index] = NULL;
        }

        // Create the events
        // Note: Currently Engine and IDB sync events are created here, FSA event already should already exist
        // If initializtion order of RSS modles is changed - the CreateEent and OpenEvent calls for these
        // named events may need to switch. 
        // Method of interest for this matter (of init order) are CHsmServer::Init and CFsaServer::Init

        // Create an SD with ACL for local-system only
        memset(ea, 0, sizeof(EXPLICIT_ACCESS) * WRITER_EVENTS_NUM_ACE);


        WsbAssertStatus( AllocateAndInitializeSid( &SIDAuthNT, 1,
                             SECURITY_LOCAL_SYSTEM_RID,
                             0, 0, 0, 0, 0, 0, 0,
                             &pSystemSID) );
        ea[0].grfAccessPermissions = FILE_ALL_ACCESS;
        ea[0].grfAccessMode = SET_ACCESS;
        ea[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ea[0].Trustee.pMultipleTrustee = NULL;
        ea[0].Trustee.MultipleTrusteeOperation  = NO_MULTIPLE_TRUSTEE;
        ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[0].Trustee.TrusteeType = TRUSTEE_IS_USER;
        ea[0].Trustee.ptstrName  = (LPTSTR) pSystemSID;

        WsbAffirmNoError(SetEntriesInAcl(WRITER_EVENTS_NUM_ACE, ea, NULL, &pACL));

        pSD = (PSECURITY_DESCRIPTOR) WsbAlloc(SECURITY_DESCRIPTOR_MIN_LENGTH); 
        WsbAffirmPointer(pSD);
        WsbAffirmStatus(InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION));
 
        WsbAffirmStatus(SetSecurityDescriptorDacl(
                            pSD, 
                            TRUE,     // fDaclPresent flag   
                            pACL, 
                            FALSE));   // not a default DACL 

        sa.nLength = sizeof (SECURITY_ATTRIBUTES);
        sa.lpSecurityDescriptor = pSD;
        sa.bInheritHandle = FALSE;

        // Create teh actual events
        WsbAffirmHandle(m_syncHandles[INTERNAL_EVENT_INDEX] = CreateEvent(NULL, FALSE, TRUE, NULL));
        WsbAffirmHandle(m_syncHandles[1] = OpenEvent(EVENT_ALL_ACCESS, FALSE, HSM_FSA_STATE_EVENT));
        WsbAffirmHandle(m_syncHandles[2] = CreateEvent(&sa, FALSE, TRUE, HSM_ENGINE_STATE_EVENT));
        WsbAffirmHandle(m_syncHandles[3] = CreateEvent(&sa, FALSE, TRUE, HSM_IDB_STATE_EVENT));

    } WsbCatch(hr);

    m_hrInit = hr;

    if (pSystemSID) {
        FreeSid(pSystemSID);
    }
    if (pACL) {
        LocalFree(pACL);
    }
    if (pSD) {
        WsbFree(pSD);
    }

    WsbTraceOut(OLESTR("CRssJetWriter::CRssJetWriter"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
}

CRssJetWriter::~CRssJetWriter( )
/*++

Routine Description:

    Destructor - free resources

Arguments:

    None

Return Value:

    None

--*/
{
    WsbTraceIn(OLESTR("CRssJetWriter::~CRssJetWriter"), OLESTR(""));

    // Close event handles
    for (int index=0; index<WRITER_EVENTS_NUM; index++) {
        if (NULL != m_syncHandles[index]) {
            CloseHandle(m_syncHandles[index]);
            m_syncHandles[index] = NULL;
        }
    }

    WsbTraceOut(OLESTR("CRssJetWriter::~CRssJetWriter"), OLESTR(""));
}

HRESULT CRssJetWriter::Init(void)
/*++

Routine Description:

    Initialize Snapshot synchronization

Arguments:

    None

Return Value:

    S_OK            - Success

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CRssJetWriter::Init"), OLESTR(""));

    try {
        // Don't do anything if the basic initialization done in the constructor failed
        WsbAffirmHr(m_hrInit);

        GUID rssGuid = RSS_WRITER_GUID;
        WsbAffirmHr(Initialize(
                		rssGuid,
		                RSS_BACKUP_NAME,
                		TRUE,
                		FALSE,
		                FILES_TO_INCLUDE,
		                FILES_TO_EXCLUDE
		                ));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRssJetWriter::Init"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT CRssJetWriter::Terminate(void)
/*++

Routine Description:

    Terminate Snapshot synchronization

Arguments:

    None

Return Value:

    S_OK            - Success

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CRssJetWriter::Terminate"), OLESTR(""));

    try {
        DWORD   status, errWait;

        WsbAffirmHr(m_hrInit);

        // Avoid terminating in the middle of snapshot
        status = WaitForSingleObject(m_syncHandles[INTERNAL_EVENT_INDEX], INTERNAL_WAIT_TIMEOUT);
        errWait = GetLastError();

        // Whatever the status is - uninitialize underlying writer mechanizm
        m_bTerminating = TRUE;
        Uninitialize();

        // Check Wait status:
        if (status == WAIT_OBJECT_0) {
            // The expected case
            if (! SetEvent(m_syncHandles[INTERNAL_EVENT_INDEX])) {
                // Don't abort, just trace error
                WsbTraceAlways(OLESTR("CRssJetWriter::Terminate: SetEvent returned unexpected error %lu\n"), GetLastError());
            }
            WsbTrace(OLESTR("CRssJetWriter::Terminate: Terminating after a successful wait\n"));

        } else {
            // In case of failure we cannot trust Thaw/Abort to be called so we signal the evnets
            InternalEnd();

            switch (status) {
                case WAIT_TIMEOUT: 
                    WsbTraceAlways(OLESTR("CRssJetWriter::Terminate: Wait for Single Object timed out after %lu ms\n"), INTERNAL_WAIT_TIMEOUT);
                    hr = E_FAIL;
                    break;

                case WAIT_FAILED:
                    WsbTraceAlways(OLESTR("CRssJetWriter::Terminate: Wait for Single Object returned error %lu\n"), errWait);
                    hr = HRESULT_FROM_WIN32(errWait);
                    break;

                default:
                    WsbTraceAlways(OLESTR("CRssJetWriter::Terminate: Wait for Single Object returned unexpected status %lu\n"), status);
                    hr = E_UNEXPECTED;
                    break;
            }         
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRssJetWriter::Terminate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT CRssJetWriter::InternalEnd(void)
/*++

Routine Description:

    Set all events

Arguments:

    None

Return Value:

    S_OK            - Success

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CRssJetWriter::InternalEnd"), OLESTR(""));

    try {
        WsbAffirmHr(m_hrInit);

        // Set all events
        DWORD errSet;
        for (int index=0; index<WRITER_EVENTS_NUM; index++) {
            if (NULL != m_syncHandles[index]) {
                if (! SetEvent(m_syncHandles[index])) {
                    // Don't abort, just save error
                    errSet = GetLastError();
                    WsbTraceAlways(OLESTR("CRssJetWriter::InternalEnd: SetEvent returned error %lu for event number %d\n"), errSet, index);
                    hr  = HRESULT_FROM_WIN32(errSet);
                }
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRssJetWriter::InternalEnd"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

//
//  CVssJetWriter overloaded methods
//
bool STDMETHODCALLTYPE CRssJetWriter::OnFreezeBegin()
/*++

Routine Description:

    Handles Freeze Start event

Arguments:

    None

Return Value:

    TRUE            - Success, OK to freeze
    FALSE           - Failure, Don't freeze

--*/
{
    HRESULT                     hr = S_OK;
    bool                        bRet;

    WsbTraceIn(OLESTR("CRssJetWriter::OnFreezeBegin"), OLESTR(""));

    try {
        WsbAffirmHr(m_hrInit);

        // Just wait for all sync events
        DWORD status = WaitForMultipleObjects(WRITER_EVENTS_NUM, m_syncHandles, TRUE, EVENT_WAIT_TIMEOUT);

        // Comparing (status == WAIT_OBJECT_0) || (status > WAIT_OBJECT_0) intsead of (status >= WAIT_OBJECT_0) 
        //  to avoid error C4296 - "expression is always true"
        if ( ((status == WAIT_OBJECT_0) || (status > WAIT_OBJECT_0)) && 
             (status <= WAIT_OBJECT_0 + WRITER_EVENTS_NUM - 1) ) {
            // Freeze is ready to go...
            WsbTrace(OLESTR("CRssJetWriter::OnFreezeBegin: All events are nonsignaled, freeze is reday to go\n"));

            // If we are terminating, no Thaw/Abort will be called - therefore, set the events
            if (m_bTerminating) {
                InternalEnd();
            }

        } else {
            // Something wrong...            
            DWORD errWait = GetLastError();

            // Set all events in case of an error 
            InternalEnd();

            switch(status) {
                case WAIT_FAILED:
                    WsbTraceAlways(OLESTR("CRssJetWriter::OnFreezeBegin: Wait for Multiple Objects returned error %lu\n"), errWait);
                    WsbThrow(HRESULT_FROM_WIN32(errWait));
                    break;

                case WAIT_TIMEOUT:
                    // Timeout means that one of the sync components is taking too long
                    WsbTraceAlways(OLESTR("CRssJetWriter::OnFreezeBegin: Wait for Multiple Objects timed out after %lu ms\n"), EVENT_WAIT_TIMEOUT);
                    WsbThrow(VSS_E_WRITERERROR_TIMEOUT);
                    break;

                default:
                    WsbTraceAlways(OLESTR("CRssJetWriter::OnFreezeBegin: Wait for Multiple Objects returned unexpected status %lu\n"), status);
                    WsbThrow(E_UNEXPECTED);
                    break;
            }
        }

    } WsbCatch(hr);

    if (S_OK == hr) {
        bRet = CVssJetWriter::OnFreezeBegin();
    } else {
        bRet = false;
    }

    WsbTraceOut(OLESTR("CRssJetWriter::OnFreezeBegin"), OLESTR("hr = <%ls> , bRet = <%ls>"), WsbHrAsString(hr), WsbBoolAsString(bRet));

    return bRet;
}

bool STDMETHODCALLTYPE CRssJetWriter::OnThawEnd(IN bool fJetThawSucceeded)
/*++

Routine Description:

    Handles Thaw End event

Arguments:

    fJetThawSucceeded      - Ignored

Return Value:

    TRUE            - Success
    FALSE           - Failure

--*/
{
    bool                        bRet;

    WsbTraceIn(OLESTR("CRssJetWriter::OnThawEnd"), OLESTR(""));

    // Return value is determined by base class, ignore internal errors here
    bRet = CVssJetWriter::OnThawEnd(fJetThawSucceeded);

    // Release all waiting events
    InternalEnd();

    WsbTraceOut(OLESTR("CRssJetWriter::OnThawEnd"), OLESTR("bRet = <%ls>"), WsbBoolAsString(bRet));

    return bRet;
}

void STDMETHODCALLTYPE CRssJetWriter::OnAbortEnd()
/*++

Routine Description:

    Handles Abort End event

Arguments:

    None

Return Value:

    None

--*/
{
    WsbTraceIn(OLESTR("CRssJetWriter::OnAbortEnd"), OLESTR(""));

    // Call base class imp.
    CVssJetWriter::OnAbortEnd();

    // Release all waiting events
    InternalEnd();

    WsbTraceOut(OLESTR("CRssJetWriter::OnAbortEnd"), OLESTR(""));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\task\baginfo.h ===
// baginfo.h : Declaration of the CBagHole


#include "resource.h"       // main symbols
#include "Wsb.h"            // Wsb Collectable Class
#include "wsbdb.h"


/////////////////////////////////////////////////////////////////////////////
// Task

class CBagInfo : 
    public CWsbDbEntity,
    public IBagInfo,
    public CComCoClass<CBagInfo,&CLSID_CBagInfo>
{
public:
    CBagInfo() {}
BEGIN_COM_MAP(CBagInfo)
    COM_INTERFACE_ENTRY(IBagInfo)
    COM_INTERFACE_ENTRY2(IWsbDbEntity, CWsbDbEntity)
    COM_INTERFACE_ENTRY(IWsbDbEntityPriv)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
//  COM_INTERFACE_ENTRY(IWsbPersistable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY(CBagHole, _T("Task.BagInfo.1"), _T("Task.BagInfo"), IDS_BAGINFO_DESC, THREADFLAGS_BOTH)

// IBagHole
public:
    STDMETHOD(FinalConstruct)(void);

// IWsbDbEntity
public:
    STDMETHOD(Print)(IStream* pStream);
    STDMETHOD(UpdateKey)(IWsbDbKey *pKey);
    WSB_FROM_CWSBDBENTITY;

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);
    void FinalRelease(void);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pTestsPassed, USHORT* pTestsFailed);
//*/
// IBagHole
public:
    STDMETHOD(GetBagInfo)(HSM_BAG_STATUS *pStatus, GUID* pBagId, FILETIME *pBirthDate, LONGLONG *pLen, USHORT *pType, GUID *pVolId, LONGLONG *pDeletedBagAmount, SHORT *pRemoteDataSet);
    STDMETHOD(SetBagInfo)(HSM_BAG_STATUS status, GUID bagId, FILETIME birthDate, LONGLONG len, USHORT type, GUID volId, LONGLONG deletedBagAmount, SHORT remoteDataSet );

private:
    HSM_BAG_STATUS      m_BagStatus;
    GUID                m_BagId;
    FILETIME            m_BirthDate;
    LONGLONG            m_Len;
    USHORT              m_Type;
    GUID                m_VolId;
    LONGLONG            m_DeletedBagAmount; 
    SHORT               m_RemoteDataSet;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\task\baghole.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    BagHole.cpp

Abstract:

    This component is an object representation of the HSM Metadata bag hole record.

Author:

    Cat Brant   [cbrant]   26-Nov-1996

Revision History:

--*/


#include "stdafx.h"

#include "metaint.h"
#include "metalib.h"
#include "BagHole.h"

#undef  WSB_TRACE_IS        
#define WSB_TRACE_IS        WSB_TRACE_BIT_META

HRESULT 
CBagHole::GetBagHole(
    OUT GUID *pBagId, 
    OUT LONGLONG *pSegStartLoc, 
    OUT LONGLONG *pSegLen 
    ) 
/*++

Routine Description:

  See IBagHole::GetBagHole

Arguments:

  See IBagHole::GetBagHole

Return Value:
  
    See IBagHole::GetBagHole

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CBagHole::GetBagHole"),OLESTR(""));

    try {
        //Make sure we can provide data memebers
        WsbAssert(0 != pBagId, E_POINTER);
        WsbAssert(0 != pSegStartLoc, E_POINTER);
        WsbAssert(0 != pSegLen, E_POINTER);

        //Provide the data members
        *pBagId = m_BagId;
        *pSegStartLoc = m_SegStartLoc;
        *pSegLen = m_SegLen;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CBagHole::GetBagHole"), 
        OLESTR("BagId = <%ls>, SegStartLoc = <%ls>, SegLen = <%ls>"),
        WsbPtrToGuidAsString(pBagId), 
        WsbStringCopy(WsbPtrToLonglongAsString(pSegStartLoc)),
        WsbStringCopy(WsbPtrToLonglongAsString(pSegLen)));
    return(hr);

}


HRESULT 
CBagHole::FinalConstruct(
    void
    ) 
/*++

Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbDbEntity::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssertHr(CWsbDbEntity::FinalConstruct());

        m_BagId = GUID_NULL;
        m_SegStartLoc = 0;
        m_SegLen = 0;

    } WsbCatch(hr);

    return(hr);
}

HRESULT CBagHole::GetClassID
(
    OUT LPCLSID pclsid
    ) 
/*++

Routine Description:

  See IPerist::GetClassID()

Arguments:

  See IPerist::GetClassID()

Return Value:

    See IPerist::GetClassID()

--*/

{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CBagHole::GetClassID"), OLESTR(""));


    try {
        WsbAssert(0 != pclsid, E_POINTER);

        *pclsid = CLSID_CBagHole;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CBagHole::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pclsid));
    return(hr);
}

HRESULT CBagHole::GetSizeMax
(
    OUT ULARGE_INTEGER* pcbSize
    ) 
/*++

Routine Description:

  See IPersistStream::GetSizeMax().

Arguments:

  See IPersistStream::GetSizeMax().

Return Value:

  See IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CBagHole::GetSizeMax"), OLESTR(""));

    try {
        
        WsbAssert(0 != pcbSize, E_POINTER);

        pcbSize->QuadPart = WsbPersistSizeOf(GUID) + WsbPersistSizeOf(ULONG) +  WsbPersistSizeOf(ULONG);

        pcbSize->QuadPart = WsbPersistSizeOf(CBagHole); //???????
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CBagHole::GetSizeMax"), 
        OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), 
        WsbPtrToUliAsString(pcbSize));

    return(hr);
}

HRESULT CBagHole::Load
(
    IN IStream* pStream
    ) 
/*++

Routine Description:

  See IPersistStream::Load().

Arguments:

  See IPersistStream::Load().

Return Value:

  See IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CBagHole::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_BagId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_SegStartLoc));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_SegLen));
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CBagHole::Load"), 
        OLESTR("hr = <%ls>,  GUID = <%ls>, SegStartLoc = <%lu>, SegLen = <%lu>"), 
        WsbHrAsString(hr), WsbGuidAsString(m_BagId),m_SegStartLoc, m_SegLen);

    return(hr);
}


HRESULT CBagHole::Print
(
    IN IStream* pStream
    ) 
/*++

Implements:

  IWsbDbEntity::Print

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CBagHole::Print"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        CWsbStringPtr strGuid;
        WsbAffirmHr(WsbSafeGuidAsString(m_BagId, strGuid));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" BagId = %ls"), 
                (WCHAR *)strGuid));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", StartLoc = %ls"), 
                WsbLonglongAsString(m_SegStartLoc)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", SegLen = %ls"), 
                WsbLonglongAsString(m_SegLen)));
        WsbAffirmHr(CWsbDbEntity::Print(pStream));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CBagHole::Print"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT CBagHole::Save
(
    IN IStream* pStream, 
    IN BOOL clearDirty
    ) 
/*++

Routine Description:

  See IPersistStream::Save().

Arguments:

  See IPersistStream::Save().

Return Value:

  See IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CBagHole::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        WsbAffirmHr(WsbSaveToStream(pStream, m_BagId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_SegStartLoc));
        WsbAffirmHr(WsbSaveToStream(pStream, m_SegLen));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CBagHole::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CBagHole::SetBagHole
(
    IN GUID BagId, 
    IN LONGLONG SegStartLoc, 
    IN LONGLONG SegLen
    )
 /*++

Routine Description:

  See IBagHole::SetBagHole().

Arguments:

  See IBagHole::SetBagHole().

Return Value:

    S_OK        - Success.

--*/
{
    WsbTraceIn(OLESTR("CBagHole::SetBagHole"), 
        OLESTR("BagId = <%ls>, SegStartLoc = <%ls>, SegLen = <%ls>"), WsbGuidAsString(BagId), 
        WsbLonglongAsString(SegStartLoc), WsbLonglongAsString(SegLen));

    m_isDirty = TRUE;
    m_BagId = BagId;
    m_SegStartLoc = SegStartLoc;
    m_SegLen = SegLen;

    WsbTraceOut(OLESTR("CBagHole::SetBagHole"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(S_OK);
}


HRESULT 
CBagHole::Test
(
    OUT USHORT *pTestsPassed, 
    OUT USHORT *pTestsFailed 
    ) 
/*++

Routine Description:

  See IWsbTestable::Test().

Arguments:

  See IWsbTestable::Test().

Return Value:

  See IWsbTestable::Test().

--*/
{
#if 0
    HRESULT                 hr = S_OK;
    CComPtr<IBagHole>       pBagHole1;
    CComPtr<IBagHole>       pBagHole2;
    GUID                    l_BagId;
    LONGLONG                    l_SegStartLoc;
    LONGLONG                    l_SegLen;

    WsbTraceIn(OLESTR("CBagHole::Test"), OLESTR(""));

    *pTestsPassed = *pTestsFailed = 0;
    try {
        // Get the pBagHole interface.
        WsbAssertHr(((IUnknown*)(IBagHole*) this)->QueryInterface(IID_IBagHole,
                    (void**) &pBagHole1));


        try {
            // Set the BagHole to a value, and see if it is returned.
            WsbAssertHr(pBagHole1->SetBagHole(CLSID_CBagHole, 0, 6 ));

            WsbAssertHr(pBagHole1->GetBagHole(&l_BagId, &l_SegStartLoc, &l_SegLen));

            WsbAssert((l_BagId == CLSID_CBagHole) && (l_SegStartLoc == 0) &&
                      (l_SegLen == 6), E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

#ifdef OLD_CODE
        hr = S_OK;
        try {
            //Create another instance and test the comparisson methods:
            WsbAssertHr(CoCreateInstance(CLSID_CBagHole, NULL, CLSCTX_ALL, IID_IBagHole, (void**) &pBagHole2));

            // Check the default values.
            WsbAssertHr(pBagHole2->GetBagHole(&l_BagId, &l_SegStartLoc, &l_SegLen));
            WsbAssert(((l_BagId == GUID_NULL) && (l_SegStartLoc == 0) && (l_SegLen == 0)), E_FAIL);
        }  WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
            // IsEqual()
            WsbAssertHr(pBagHole1->SetBagHole(CLSID_CWsbBool, 1, 100));
            WsbAssertHr(pBagHole2->SetBagHole(CLSID_CWsbBool, 1, 100));

            WsbAssertHr(pBagHole1->IsEqual(pBagHole2));
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
            WsbAssertHr(pBagHole1->SetBagHole(CLSID_CWsbBool, 5, 6));
            WsbAssertHr(pBagHole2->SetBagHole(CLSID_CWsbLong, 0, 6));

            WsbAssert((pBagHole1->IsEqual(pBagHole2) == S_FALSE), E_FAIL);
        }  WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
             // CompareTo()
             WsbAssertHr(pBagHole1->SetBagHole(CLSID_CWsbBool, 1, 100));
             WsbAssertHr(pBagHole2->SetBagHole(CLSID_CWsbBool, 10, 6));

             WsbAssert((pBagHole1->CompareTo(pBagHole2, &result) == S_FALSE) && (result != 0), E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
            WsbAssertHr(pBagHole1->SetBagHole(CLSID_CWsbBool, 0, 6));
            WsbAssertHr(pBagHole2->SetBagHole(CLSID_CWsbLong, 0, 6));

            WsbAssert(((pBagHole1->CompareTo(pBagHole2, &result) == S_FALSE) && (result > 0)), E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
             WsbAssertHr(pBagHole1->SetBagHole(CLSID_CWsbBool, 0, 6));
             WsbAssertHr(pBagHole2->SetBagHole(CLSID_CWsbBool, 0, 6));

             WsbAssert((pBagHole1->CompareTo(pBagHole2, &result) == S_OK), E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        try {
        // Try out the persistence stuff.
            CComPtr<IPersistFile>       pFile1;
            CComPtr<IPersistFile>       pFile2;

            WsbAssertHr(pBagHole1->QueryInterface(IID_IPersistFile, (void**) &pFile1));
            WsbAssertHr(pBagHole2->QueryInterface(IID_IPersistFile, (void**) &pFile2));

            LPOLESTR    szTmp = NULL;
            // The item should be dirty.
            try {
                WsbAssertHr(pBagHole2->SetBagHole(CLSID_CWsbLong, 0, 6));
                WsbAssertHr(pFile2->IsDirty());
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*pTestsPassed)++;
            } else {
                (*pTestsFailed)++;
            }

            hr = S_OK;
            try {
                // Save the item, and remember.
                WsbAssertHr(pFile2->Save(OLESTR("c:\\WsbTests\\BagHole.tst"), TRUE));
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*pTestsPassed)++;
            } else {
                (*pTestsFailed)++;
            }

            hr = S_OK;
            try {
                // It shouldn't be dirty.
                WsbAssert((pFile2->IsDirty() == S_FALSE), E_FAIL);

            } WsbCatch(hr);

            if (hr == S_OK) {
                (*pTestsPassed)++;
            } else {
                (*pTestsFailed)++;
            }

            hr = S_OK;
            try {
                // Try reading it in to another object.
                WsbAssertHr(pBagHole1->SetBagHole(CLSID_CWsbLong, 0, 6));
                WsbAssertHr(pFile1->Load(OLESTR("c:\\WsbTests\\BagHole.tst"), 0));

                WsbAssertHr(pBagHole1->CompareToIBagHole(pBagHole2, &result));
            }WsbCatch(hr);

            if (hr == S_OK) {
                (*pTestsPassed)++;
            } else {
                (*pTestsFailed)++;
            }

        } WsbCatch(hr);
#endif
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CBagHole::Test"),   OLESTR("hr = <%ls>"),WsbHrAsString(hr));
#else
    UNREFERENCED_PARAMETER(pTestsPassed);
    UNREFERENCED_PARAMETER(pTestsFailed);
#endif
    return(S_OK);
}



HRESULT 
CBagHole::UpdateKey(
    IWsbDbKey *pKey
    ) 
/*++

Implements:

  IWsbDbEntity::UpdateKey

--*/
{ 
    HRESULT  hr = S_OK; 

    try {
        WsbAffirmHr(pKey->SetToGuid(m_BagId));
        WsbAffirmHr(pKey->AppendLonglong(m_SegStartLoc));
    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\task\baginfo.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    BagHole.cpp

Abstract:

    This component is an object representation of the HSM Metadata bag hole record.

Author:

    Cat Brant   [cbrant]   26-Nov-1996

Revision History:

--*/


#include "stdafx.h"

#include "metaint.h"
#include "metalib.h"
#include "BagInfo.h"

#undef  WSB_TRACE_IS     
#define WSB_TRACE_IS        WSB_TRACE_BIT_META

static USHORT iCount = 0;

HRESULT 
CBagInfo::GetBagInfo(
    HSM_BAG_STATUS *pStatus,
    GUID* pBagId, 
    FILETIME *pBirthDate, 
    LONGLONG *pLen, 
    USHORT *pType, 
    GUID *pVolId,
    LONGLONG *pDeletedBagAmount,
    SHORT *pRemoteDataSet
    ) 
/*++

Routine Description:

  See IBagInfo::GetBagInfo

Arguments:

  See IBagInfo::GetBagInfo

Return Value:
  
    See IBagInfo::GetBagInfo

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CBagInfo::GetBagInfo"),OLESTR(""));

    try {
        //Make sure we can provide data memebers
        WsbAssert(0 != pStatus, E_POINTER);
        WsbAssert(0 != pBagId, E_POINTER);
        WsbAssert(0 != pBirthDate, E_POINTER);
        WsbAssert(0 != pLen, E_POINTER);
        WsbAssert(0 != pType, E_POINTER);
        WsbAssert(0 != pVolId, E_POINTER);
        WsbAssert(0 != pDeletedBagAmount, E_POINTER);
        WsbAssert(0 != pRemoteDataSet, E_POINTER);

        //Provide the data members
        *pStatus = m_BagStatus;
        *pBagId = m_BagId;
        *pBirthDate = m_BirthDate;
        *pLen = m_Len;
        *pType = m_Type;
        *pVolId = m_VolId;
        *pDeletedBagAmount = m_DeletedBagAmount;
        *pRemoteDataSet = m_RemoteDataSet;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CBagInfo::GetBagInfo"), 
        OLESTR("hr = <%ls>, status = <%ls>, ID = <%ls>, Birthdate = <%ls>, length = <%ls>, type = <%ls>, volId = <%ls>, deletedAmount = <%ls>, remoteDataSet = <%ls>"), 
        WsbHrAsString(hr), WsbPtrToUshortAsString((USHORT *)pStatus), WsbPtrToGuidAsString(pBagId), WsbPtrToFiletimeAsString(FALSE, pBirthDate),
        WsbPtrToLonglongAsString(pLen), WsbPtrToUshortAsString(pType), WsbPtrToGuidAsString(pVolId), WsbPtrToLonglongAsString(pDeletedBagAmount),
        WsbPtrToShortAsString(pRemoteDataSet));
    
    return(hr);

}


HRESULT 
CBagInfo::FinalConstruct(
    void
    ) 
/*++

Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbDbEntity::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CBagInfo::FinalConstruct"),OLESTR(""));
    try {

        WsbAssertHr(CWsbDbEntity::FinalConstruct());

        m_BagStatus = HSM_BAG_STATUS_NONE;
        m_BagId = GUID_NULL;
        m_BirthDate = WsbLLtoFT(0);
        m_Len = 0;
        m_Type = 0;
        m_VolId = GUID_NULL;
        m_DeletedBagAmount = 0;
        m_RemoteDataSet = 0;

    } WsbCatch(hr);
    iCount++;
    WsbTraceOut(OLESTR("CBagInfo::FinalConstruct"),OLESTR("hr = <%ls>, Count is <%d>"), 
                WsbHrAsString(hr), iCount);

    return(hr);
}

void
CBagInfo::FinalRelease(
    void
    )

/*++

Implements:

  CBagInfo::FinalRelease().

--*/
{
    
    WsbTraceIn(OLESTR("CBagInfo::FinalRelease"), OLESTR(""));
    
    CWsbDbEntity::FinalRelease();
    iCount--;
    
    WsbTraceOut(OLESTR("CBagInfo::FinalRelease"), OLESTR("Count is <%d>"), iCount);
}

HRESULT CBagInfo::GetClassID
(
    OUT LPCLSID pclsid
    ) 
/*++

Routine Description:

  See IPerist::GetClassID()

Arguments:

  See IPerist::GetClassID()

Return Value:

    See IPerist::GetClassID()

--*/

{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CBagInfo::GetClassID"), OLESTR(""));


    try {
        WsbAssert(0 != pclsid, E_POINTER);

        *pclsid = CLSID_CBagInfo;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CBagInfo::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pclsid));
    return(hr);
}

HRESULT CBagInfo::GetSizeMax
(
    OUT ULARGE_INTEGER* pcbSize
    ) 
/*++

Routine Description:

  See IPersistStream::GetSizeMax().

Arguments:

  See IPersistStream::GetSizeMax().

Return Value:

  See IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CBagInfo::GetSizeMax"), OLESTR(""));

    try {
        
        WsbAssert(0 != pcbSize, E_POINTER);

        pcbSize->QuadPart = WsbPersistSizeOf(CBagInfo); //???????
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CBagInfo::GetSizeMax"), 
        OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), 
        WsbPtrToUliAsString(pcbSize));

    return(hr);
}

HRESULT CBagInfo::Load
(
    IN IStream* pStream
    ) 
/*++

Routine Description:

  See IPersistStream::Load().

Arguments:

  See IPersistStream::Load().

Return Value:

  See IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CBagInfo::Load"), OLESTR(""));

    try {
        USHORT  tmpUShort;
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbLoadFromStream(pStream, &tmpUShort));
        m_BagStatus = (HSM_BAG_STATUS)tmpUShort;
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_BagId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_BirthDate));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_Len));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_Type));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_VolId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_DeletedBagAmount));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_RemoteDataSet));

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CBagInfo::Load"), 
        OLESTR("hr = <%ls>, status = <%d>, ID = <%ls>, Birthdate = <%ls>, length = <%ls>, type = <%ls>, volId = <%d>, deletedAmount = <%ls>, remoteDataSet = <%d>"), 
        WsbHrAsString(hr), (USHORT)m_BagStatus, WsbGuidAsString(m_BagId), WsbFiletimeAsString(FALSE, m_BirthDate),
        WsbLonglongAsString(m_Len), m_Type, WsbGuidAsString(m_VolId), 
        WsbLonglongAsString(m_DeletedBagAmount), m_RemoteDataSet);
    
    return(hr);
}

HRESULT CBagInfo::Save
(
    IN IStream* pStream, 
    IN BOOL clearDirty
    ) 
/*++

Routine Description:

  See IPersistStream::Save().

Arguments:

  See IPersistStream::Save().

Return Value:

  See IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CBagInfo::Save"), 
        OLESTR("clearDirty = <%ls>, status = <%d>, ID = <%ls>, Birthdate = <%ls>, length = <%ls>, type = <%d>, volId = <%ls>, deletedAmount = <%ls>, RemoteDataSet = <%d>"), 
        WsbBoolAsString(clearDirty),
        (USHORT)m_BagStatus, WsbGuidAsString(m_BagId), WsbFiletimeAsString(FALSE, m_BirthDate),
        WsbLonglongAsString(m_Len), m_Type, WsbGuidAsString(m_VolId), 
        WsbLonglongAsString(m_DeletedBagAmount), m_RemoteDataSet);

    try {
        USHORT  tmpUShort;
        WsbAssert(0 != pStream, E_POINTER);

        tmpUShort = (USHORT)m_BagStatus;
        WsbAffirmHr(WsbSaveToStream(pStream, tmpUShort));
        WsbAffirmHr(WsbSaveToStream(pStream, m_BagId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_BirthDate));
        WsbAffirmHr(WsbSaveToStream(pStream, m_Len));
        WsbAffirmHr(WsbSaveToStream(pStream, m_Type));
        WsbAffirmHr(WsbSaveToStream(pStream, m_VolId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_DeletedBagAmount));
        WsbAffirmHr(WsbSaveToStream(pStream, m_RemoteDataSet));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CBagInfo::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CBagInfo::SetBagInfo(
    HSM_BAG_STATUS bagStatus,
    GUID bagId, 
    FILETIME birthDate, 
    LONGLONG len, 
    USHORT type, 
    GUID volId ,
    LONGLONG deletedBagAmount,
    SHORT remoteDataSet
    )
 /*++

Routine Description:

  See IBagInfo::SetBagInfo().

Arguments:

  See IBagInfo::SetBagInfo().

Return Value:

    S_OK        - Success.

--*/
{
    WsbTraceIn(OLESTR("CBagInfo::SetBagInfo"), 
                    OLESTR("status = <%d>, bagId = <%ls>, birthdate = <%ls>, length = <%ls>, type = %d, volId = <%ls>, deletedAmount = <%ls>, remoteDataSet = <%d>"), 
                    bagStatus,
                    WsbGuidAsString(bagId),
                    WsbFiletimeAsString(FALSE, birthDate),
                    WsbLonglongAsString(len),
                    type,
                    WsbGuidAsString(volId),
                    WsbLonglongAsString(deletedBagAmount),
                    remoteDataSet);

    m_isDirty = T