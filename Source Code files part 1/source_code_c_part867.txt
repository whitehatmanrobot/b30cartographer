RequestMsgHandleWrapper(pIoRequestPacket, status);

    goto Return;

}

#ifndef OS_WINCE
//---------------------------------------------------------------------------------------
//
//  W32SCard::State
//
//---------------------------------------------------------------------------------------
void
W32SCard::State(
    IN SCARDHANDLECALLSTRUCT    *pSCardHandleCall)
{
    DC_BEGIN_FN("W32SCard::State");

    RPC_STATUS              rpcStatus               = RPC_S_OK;
    NTSTATUS                status                  = STATUS_SUCCESS;
    char                    *pbEncodedBuffer        = NULL;
    unsigned long           cbEncodedBuffer         = 0;
    handle_t                hDec                    = 0;
    handle_t                hEnc                    = 0;
    SCARDCONTEXT            SCardContext;
    SCARDHANDLE             SCardHandle;
    State_Call              StateCall;
    State_Return            StateReturn;
    BOOL                    fFreeDecode             = FALSE;
    DWORD                   cbAtr                   = 0;
    BOOL                    fDoAllocationLocally    = FALSE;
    LPBYTE                  pbAtr                   = NULL;
    BOOL                    fFree                   = FALSE;
    PRDPDR_IOREQUEST_PACKET pIoRequestPacket        = pSCardHandleCall->pIoRequestPacket;
    PRDPDR_DEVICE_IOREQUEST pIoRequest              = &(pIoRequestPacket->IoRequest);

    memset(&StateReturn, 0, sizeof(StateReturn));
    StateReturn.ReturnCode = SCARD_S_SUCCESS;

    //
    // Decode input parameters
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) (pIoRequest + 1), // bytes are at end of struct
                        pIoRequest->Parameters.DeviceIoControl.InputBufferLength,
                        &hDec);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesDecodeBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    //
    // Decode input params
    //
    memset(&StateCall, 0, sizeof(StateCall));
    _TRY_status(State_Call_Decode(hDec, &StateCall))
    fFreeDecode = TRUE;

    if (sizeof(SCARDHANDLE) == StateCall.hCard.cbHandle)
    {
        SCardContext = *((SCARDCONTEXT *) StateCall.hCard.Context.pbContext);
        SCardHandle = *((SCARDHANDLE *) StateCall.hCard.pbHandle);
        cbAtr = StateCall.cbAtrLen;
    }
    else
    {
        TRC_ERR((TB, _T("Invalid handle sent from server.")));
        StateReturn.ReturnCode = SCARD_E_INVALID_PARAMETER;
    }

    if (StateReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        //
        // Allocate if not in SCARD_AUTOALLOCATE mode and not a size only call
        //
        fDoAllocationLocally =
                (!StateCall.fpbAtrIsNULL &&
                 (cbAtr != SCARD_AUTOALLOCATE));

        if (fDoAllocationLocally)
        {
            pbAtr = (LPBYTE) MIDL_user_allocate(cbAtr * sizeof(BYTE));
            if (pbAtr == NULL)
            {
                TRC_ERR((TB, _T("MIDL_user_allocate failed")));
                StateReturn.ReturnCode = SCARD_E_NO_MEMORY;
            }
        }
    }

    if (StateReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        //
        // Make the call
        //
        StateReturn.ReturnCode =
            pfnSCardState(
                    SCardHandle,
                    &StateReturn.dwState,
                    &StateReturn.dwProtocol,
                    (cbAtr == SCARD_AUTOALLOCATE) ? (LPBYTE) &pbAtr : pbAtr,
                    &cbAtr);
    }

    if (StateReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        StateReturn.cbAtrLen = cbAtr;

        //
        // If we are just returning the byte count then send back a junk buffer
        //
        if (pbAtr == NULL)
        {
            StateReturn.rgAtr = (BYTE *) MIDL_user_allocate(cbAtr);
            if (StateReturn.rgAtr == NULL)
            {
                status = STATUS_NO_MEMORY;
                goto ErrorReturn;
            }

            fFree = TRUE;
            memset(StateReturn.rgAtr, 0, cbAtr);
        }
        else
        {
            StateReturn.rgAtr = pbAtr;
        }
    }

    //
    // encode the return
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &hEnc);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesEncodeDynBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    _TRY_status(State_Return_Encode(hEnc, &StateReturn))

    //
    // Send return
    //
    AllocateAndChannelWriteReplyPacket(
                pIoRequestPacket,
                pbEncodedBuffer,
                cbEncodedBuffer);

Return:

    if (fFree)
    {
        MIDL_user_free(StateReturn.rgAtr);
    }

    if (pbAtr != NULL)
    {
        //
        // Check to see whether we allocated or SCard allcated for us
        //
        if (fDoAllocationLocally)
        {
            MIDL_user_free(pbAtr);
        }
        else
        {
            pfnSCardFreeMemory(SCardContext, pbAtr);
        }
    }

    if (fFreeDecode)
    {
        _TRY_2(State_Call_Free(hDec, &StateCall))
    }
    SafeMesHandleFree(&hDec);

    SafeMesHandleFree(&hEnc);

    MIDL_user_free(pbEncodedBuffer);

    MIDL_user_free(pSCardHandleCall);

    DC_END_FN();

    return;

ErrorReturn:

    DefaultIORequestMsgHandleWrapper(pIoRequestPacket, status);

    goto Return;
}
#endif

//---------------------------------------------------------------------------------------
//
//  W32SCard::Status
//
//---------------------------------------------------------------------------------------
void
W32SCard::Status(
    IN SCARDHANDLECALLSTRUCT    *pSCardHandleCall,
    IN DWORD                    dwCallType)
{
    DC_BEGIN_FN("W32SCard::Status");

    RPC_STATUS              rpcStatus               = RPC_S_OK;
    NTSTATUS                status                  = STATUS_SUCCESS;
    char                    *pbEncodedBuffer        = NULL;
    unsigned long           cbEncodedBuffer         = 0;
    handle_t                hDec                    = 0;
    handle_t                hEnc                    = 0;
    SCARDCONTEXT            SCardContext;
    SCARDHANDLE             SCardHandle;
    Status_Call             StatusCall;
    Status_Return           StatusReturn;
    BOOL                    fFreeDecode             = FALSE;
    DWORD                   cchReaderLen            = 0;
    BOOL                    fDoAllocationLocally    = FALSE;
    LPBYTE                  psz                     = NULL;
    BOOL                    fFree                   = FALSE;
    PRDPDR_IOREQUEST_PACKET pIoRequestPacket        = pSCardHandleCall->pIoRequestPacket;
    PRDPDR_DEVICE_IOREQUEST pIoRequest              = &(pIoRequestPacket->IoRequest);

    memset(&StatusReturn, 0, sizeof(StatusReturn));
    StatusReturn.ReturnCode = SCARD_S_SUCCESS;

    //
    // Decode input parameters
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) (pIoRequest + 1), // bytes are at end of struct
                        pIoRequest->Parameters.DeviceIoControl.InputBufferLength,
                        &hDec);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesDecodeBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    memset(&StatusCall, 0, sizeof(StatusCall));
    _TRY_status(Status_Call_Decode(hDec, &StatusCall))
    fFreeDecode = TRUE;

    if (sizeof(SCARDHANDLE) == StatusCall.hCard.cbHandle)
    {
        SCardContext = *((SCARDCONTEXT *) StatusCall.hCard.Context.pbContext);
        SCardHandle = *((SCARDHANDLE *) StatusCall.hCard.pbHandle);
        cchReaderLen = StatusCall.cchReaderLen;
    }
    else
    {
        TRC_ERR((TB, _T("Invalid handle sent from server.")));
        StatusReturn.ReturnCode = SCARD_E_INVALID_PARAMETER;
    }

    if (StatusReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        //
        // Allocate if not in SCARD_AUTOALLOCATE mode and not a size only call
        //
        fDoAllocationLocally =
                (!StatusCall.fmszReaderNamesIsNULL &&
                 (cchReaderLen != SCARD_AUTOALLOCATE));

#ifdef OS_WINCE
        if (!fDoAllocationLocally)
        {
            StatusReturn.cbAtrLen = ATR_SIZE;

            StatusReturn.ReturnCode =
                pfnSCardStatusW(
                    SCardHandle,
                    NULL,
                    &cchReaderLen,
                    &StatusReturn.dwState,
                    &StatusReturn.dwProtocol,
                    (LPBYTE) &StatusReturn.pbAtr,
                    &StatusReturn.cbAtrLen);

            if ((StatusReturn.ReturnCode == SCARD_S_SUCCESS) && (cchReaderLen > 0))
                fDoAllocationLocally = TRUE;
            else
            {
                TRC_ERR((TB, _T("SCardStatusW failed")));
                status = STATUS_UNSUCCESSFUL;
                goto ErrorReturn;
            }
        }
#endif
        if (fDoAllocationLocally)
        {
            DWORD dwCharSize = (dwCallType == SCARD_IOCTL_STATUSA) ?
                                    sizeof(char) : sizeof(WCHAR);

            psz = (LPBYTE) MIDL_user_allocate(cchReaderLen * dwCharSize);
            if (psz == NULL)
            {
                TRC_ERR((TB, _T("MIDL_user_allocate failed")));
                StatusReturn.ReturnCode = SCARD_E_NO_MEMORY;
            }
        }
    }

    if (StatusReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        //
        // Make the call
        //
        StatusReturn.cbAtrLen = ATR_SIZE;

        if (dwCallType == SCARD_IOCTL_STATUSA)
        {
            StatusReturn.ReturnCode =
                pfnSCardStatusA(
                    SCardHandle,
                    (cchReaderLen == SCARD_AUTOALLOCATE) ? (LPSTR) &psz : (LPSTR) psz,
                    &cchReaderLen,
                    &StatusReturn.dwState,
                    &StatusReturn.dwProtocol,
                    (LPBYTE) &StatusReturn.pbAtr,
                    &StatusReturn.cbAtrLen);

            if (StatusReturn.ReturnCode ==  SCARD_S_SUCCESS)
            {
                StatusReturn.cBytes = cchReaderLen * sizeof(char);
                StatusReturn.mszReaderNames = psz;
            }
        }
        else
        {
            StatusReturn.ReturnCode =
                pfnSCardStatusW(
                    SCardHandle,
                    (cchReaderLen == SCARD_AUTOALLOCATE) ? (LPWSTR) &psz : (LPWSTR) psz,
                    &cchReaderLen,
                    &StatusReturn.dwState,
                    &StatusReturn.dwProtocol,
                    (LPBYTE) &StatusReturn.pbAtr,
                    &StatusReturn.cbAtrLen);

            if (StatusReturn.ReturnCode ==  SCARD_S_SUCCESS)
            {
                StatusReturn.cBytes = cchReaderLen * sizeof(WCHAR);
                StatusReturn.mszReaderNames = psz;
            }
        }
    }

    if (StatusReturn.ReturnCode ==  SCARD_S_SUCCESS)
    {
        //
        // If we are just returning the byte count then send back a junk buffer
        //
        if (StatusReturn.mszReaderNames == NULL)
        {
            StatusReturn.mszReaderNames = (BYTE *) MIDL_user_allocate(StatusReturn.cBytes);
            if (StatusReturn.mszReaderNames == NULL)
            {
                status = STATUS_NO_MEMORY;
                goto ErrorReturn;
            }

            fFree = TRUE;
            memset(StatusReturn.mszReaderNames, 0, StatusReturn.cBytes);
        }
    }

    //
    // encode the return
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &hEnc);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesEncodeDynBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    _TRY_status(Status_Return_Encode(hEnc, &StatusReturn))

    //
    // Send return
    //
    AllocateAndChannelWriteReplyPacket(
                pIoRequestPacket,
                pbEncodedBuffer,
                cbEncodedBuffer);

Return:

    if (fFree)
    {
        MIDL_user_free(StatusReturn.mszReaderNames);
    }

    if (psz != NULL)
    {
        //
        // Check to see whether we allocated or SCard allcated for us
        //
        if (fDoAllocationLocally)
        {
            MIDL_user_free(psz);
        }
        else
        {
#ifndef OS_WINCE
            pfnSCardFreeMemory(SCardContext, psz);
#else
            TRC_ASSERT(FALSE, (TB, _T("Shouldnt get here")));
#endif
        }
    }

    if (fFreeDecode)
    {
        _TRY_2(Status_Call_Free(hDec, &StatusCall))
    }
    SafeMesHandleFree(&hDec);

    SafeMesHandleFree(&hEnc);

    MIDL_user_free(pbEncodedBuffer);

    MIDL_user_free(pSCardHandleCall);

    DC_END_FN();

    return;

ErrorReturn:

    DefaultIORequestMsgHandleWrapper(pIoRequestPacket, status);

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  W32SCard::Transmit
//
//---------------------------------------------------------------------------------------
void
W32SCard::Transmit(
    IN SCARDHANDLECALLSTRUCT    *pSCardHandleCall)
{
    DC_BEGIN_FN("W32SCard::Transmit");

    RPC_STATUS              rpcStatus               = RPC_S_OK;
    NTSTATUS                status                  = STATUS_SUCCESS;
    char                    *pbEncodedBuffer        = NULL;
    unsigned long           cbEncodedBuffer         = 0;
    handle_t                hDec                    = 0;
    handle_t                hEnc                    = 0;
    SCARDCONTEXT            SCardContext;
    SCARDHANDLE             SCardHandle;
    Transmit_Call           TransmitCall;
    Transmit_Return         TransmitReturn;
    BOOL                    fFreeDecode             = FALSE;
    BOOL                    fDoAllocationLocally    = FALSE;
    SCARD_IO_REQUEST        *pSendPci               = NULL;
    SCARD_IO_REQUEST        *pRecvPci               = NULL;
    SCardIO_Request         *pReturnRecvPci         = NULL;
    DWORD                   cbRecvLength;
    BYTE                    *pbRecvBuffer           = NULL;
    BOOL                    fFree                   = FALSE;
    PRDPDR_IOREQUEST_PACKET pIoRequestPacket        = pSCardHandleCall->pIoRequestPacket;
    PRDPDR_DEVICE_IOREQUEST pIoRequest              = &(pIoRequestPacket->IoRequest);

    memset(&TransmitReturn, 0, sizeof(TransmitReturn));
    TransmitReturn.ReturnCode = SCARD_S_SUCCESS;

    //
    // Decode input parameters
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) (pIoRequest + 1), // bytes are at end of struct
                        pIoRequest->Parameters.DeviceIoControl.InputBufferLength,
                        &hDec);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesDecodeBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    //
    // Decode and setup the input params
    //
    memset(&TransmitCall, 0, sizeof(TransmitCall));
    _TRY_status(Transmit_Call_Decode(hDec, &TransmitCall))
    fFreeDecode = TRUE;

    if (sizeof(SCARDHANDLE) == TransmitCall.hCard.cbHandle)
    {
        SCardContext = *((SCARDCONTEXT *) TransmitCall.hCard.Context.pbContext);
        SCardHandle = *((SCARDHANDLE *) TransmitCall.hCard.pbHandle);
        cbRecvLength = TransmitCall.cbRecvLength;
    }
    else
    {
        TRC_ERR((TB, _T("Invalid handle sent from server.")));
        TransmitReturn.ReturnCode = SCARD_E_INVALID_PARAMETER;
    }

    //
    // setup the pSendPci param of the call based on callers input
    //
    if (TransmitReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        pSendPci = (LPSCARD_IO_REQUEST)
                    MIDL_user_allocate( sizeof(SCARD_IO_REQUEST) +
                                        TransmitCall.ioSendPci.cbExtraBytes);
        if (pSendPci != NULL)
        {
            pSendPci->dwProtocol = TransmitCall.ioSendPci.dwProtocol;
            pSendPci->cbPciLength = sizeof(SCARD_IO_REQUEST) +
                                    TransmitCall.ioSendPci.cbExtraBytes;
            if (TransmitCall.ioSendPci.cbExtraBytes != 0)
            {
                memcpy(
                    ((LPBYTE) pSendPci) + sizeof(SCARD_IO_REQUEST),
                    TransmitCall.ioSendPci.pbExtraBytes,
                    TransmitCall.ioSendPci.cbExtraBytes);
            }
        }
        else
        {
            TRC_ERR((TB, _T("MIDL_user_allocate failed")));
            TransmitReturn.ReturnCode = SCARD_E_NO_MEMORY;
        }
    }

    //
    // setup the pRecvPci param of the call based on callers input
    //
    if (TransmitReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        if (TransmitCall.pioRecvPci != NULL)
        {
            pRecvPci = (LPSCARD_IO_REQUEST)
                    MIDL_user_allocate( sizeof(SCARD_IO_REQUEST) +
                                        TransmitCall.pioRecvPci->cbExtraBytes);
            if (pRecvPci != NULL)
            {
                pRecvPci->dwProtocol = TransmitCall.pioRecvPci->dwProtocol;
                pRecvPci->cbPciLength = sizeof(SCARD_IO_REQUEST) +
                                        TransmitCall.pioRecvPci->cbExtraBytes;
                if (TransmitCall.ioSendPci.cbExtraBytes != 0)
                {
                    memcpy(
                        ((LPBYTE) pRecvPci) + sizeof(SCARD_IO_REQUEST),
                        TransmitCall.pioRecvPci->pbExtraBytes,
                        TransmitCall.pioRecvPci->cbExtraBytes);
                }
            }
            else
            {
                TRC_ERR((TB, _T("MIDL_user_allocate failed")));
                TransmitReturn.ReturnCode = SCARD_E_NO_MEMORY;
            }
        }
    }

    //
    // Allocate if not in SCARD_AUTOALLOCATE mode and not a size only call
    //
    if (TransmitReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        fDoAllocationLocally =
                (!TransmitCall.fpbRecvBufferIsNULL &&
                 (cbRecvLength != SCARD_AUTOALLOCATE));

#ifdef OS_WINCE
        if (!fDoAllocationLocally)
        {
            TransmitReturn.ReturnCode =
                pfnSCardTransmit(
                        SCardHandle,
                        pSendPci,
                        TransmitCall.pbSendBuffer,
                        TransmitCall.cbSendLength,
                        pRecvPci,
                        NULL,
                        &cbRecvLength);

            if ((TransmitReturn.ReturnCode  == SCARD_S_SUCCESS) && (cbRecvLength > 0))
                fDoAllocationLocally = TRUE;
            else
            {
                TRC_ERR((TB, _T("SCardTransmit failed")));
                status = STATUS_UNSUCCESSFUL;
                goto ErrorReturn;
            }
        }
#endif
        if (fDoAllocationLocally)
        {
            pbRecvBuffer = (LPBYTE) MIDL_user_allocate(cbRecvLength * sizeof(BYTE));
            if (pbRecvBuffer == NULL)
            {
                TRC_ERR((TB, _T("MIDL_user_allocate failed")));
                TransmitReturn.ReturnCode = SCARD_E_NO_MEMORY;
            }
        }
    }

    //
    // Make the call
    //
    if (TransmitReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        TransmitReturn.ReturnCode =
            pfnSCardTransmit(
                    SCardHandle,
                    pSendPci,
                    TransmitCall.pbSendBuffer,
                    TransmitCall.cbSendLength,
                    pRecvPci,
                    (cbRecvLength == SCARD_AUTOALLOCATE) ?
                        (LPBYTE) &pbRecvBuffer : pbRecvBuffer,
                    &cbRecvLength);
    }

    //
    // copy over the output the return struct to be encoded
    //
    if (TransmitReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        if (pRecvPci != NULL)
        {
            //
            // Allocate space for struct plus the extra bytes at the end of it
            // if needed
            //
            pReturnRecvPci = (SCardIO_Request *)
                    MIDL_user_allocate(
                                sizeof(SCardIO_Request) +
                                pRecvPci->cbPciLength);

            if (pReturnRecvPci != NULL)
            {
                pReturnRecvPci->dwProtocol = pRecvPci->dwProtocol;
                pReturnRecvPci->cbExtraBytes = pRecvPci->cbPciLength -
                                                sizeof(SCARD_IO_REQUEST);
                if (pReturnRecvPci->cbExtraBytes != 0)
                {
                    //
                    // put bytes at end of struct since we allocated enough space for it
                    //
                    memcpy(
                        ((LPBYTE) pReturnRecvPci) + sizeof(SCardIO_Request),
                        ((LPBYTE) pRecvPci) + sizeof(SCARD_IO_REQUEST),
                        pReturnRecvPci->cbExtraBytes);
                }

                TransmitReturn.pioRecvPci = pReturnRecvPci;
            }
            else
            {
                TRC_ERR((TB, _T("MIDL_user_allocate failed")));
                TransmitReturn.ReturnCode = SCARD_E_NO_MEMORY;
            }
        }
        else
        {
            TransmitReturn.pioRecvPci = NULL;
        }

        TransmitReturn.cbRecvLength = cbRecvLength;
        TransmitReturn.pbRecvBuffer = pbRecvBuffer;
    }

    if (TransmitReturn.ReturnCode ==  SCARD_S_SUCCESS)
    {
        //
        // If we are just returning the byte count then send back a junk buffer
        //
        if (TransmitReturn.pbRecvBuffer == NULL)
        {
            TransmitReturn.pbRecvBuffer = (BYTE *) MIDL_user_allocate(TransmitReturn.cbRecvLength);
            if (TransmitReturn.pbRecvBuffer == NULL)
            {
                status = STATUS_NO_MEMORY;
                goto ErrorReturn;
            }

            fFree = TRUE;
            memset(TransmitReturn.pbRecvBuffer, 0, TransmitReturn.cbRecvLength);
        }
    }

    //
    // encode the return
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &hEnc);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesEncodeDynBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    _TRY_status(Transmit_Return_Encode(hEnc, &TransmitReturn))

    //
    // Send return
    //
    AllocateAndChannelWriteReplyPacket(
                pIoRequestPacket,
                pbEncodedBuffer,
                cbEncodedBuffer);

Return:

    if (fFree)
    {
        MIDL_user_free(TransmitReturn.pbRecvBuffer);
    }

    MIDL_user_free(pSendPci);
    MIDL_user_free(pRecvPci);
    MIDL_user_free(pReturnRecvPci);

    if (pbRecvBuffer != NULL)
    {
        //
        // Check to see whether we allocated or SCard allcated for us
        //
        if (fDoAllocationLocally)
        {
            MIDL_user_free(pbRecvBuffer);
        }
        else
        {
#ifndef OS_WINCE
            pfnSCardFreeMemory(SCardContext, pbRecvBuffer);
#else
            TRC_ASSERT(FALSE, (TB, _T("Shouldnt get here")));
#endif
        }
    }

    if (fFreeDecode)
    {
        _TRY_2(Transmit_Call_Free(hDec, &TransmitCall))
    }
    SafeMesHandleFree(&hDec);

    SafeMesHandleFree(&hEnc);

    MIDL_user_free(pbEncodedBuffer);

    MIDL_user_free(pSCardHandleCall);

    DC_END_FN();

    return;

ErrorReturn:

    DefaultIORequestMsgHandleWrapper(pIoRequestPacket, status);

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  W32SCard::Control
//
//---------------------------------------------------------------------------------------
void
W32SCard::Control(
    IN SCARDHANDLECALLSTRUCT    *pSCardHandleCall)
{
    DC_BEGIN_FN("W32SCard::Control");

    RPC_STATUS              rpcStatus               = RPC_S_OK;
    NTSTATUS                status                  = STATUS_SUCCESS;
    char                    *pbEncodedBuffer        = NULL;
    unsigned long           cbEncodedBuffer         = 0;
    handle_t                hDec                    = 0;
    handle_t                hEnc                    = 0;
    SCARDCONTEXT            SCardContext;
    SCARDHANDLE             SCardHandle;
    Control_Call            ControlCall;
    Control_Return          ControlReturn;
    BOOL                    fFreeDecode             = FALSE;
    BOOL                    fDoAllocationLocally    = FALSE;
    DWORD                   cbBytesReturned         = 0;
    LPVOID                  lpOutBuffer             = NULL;
    BOOL                    fFree                   = FALSE;
    PRDPDR_IOREQUEST_PACKET pIoRequestPacket        = pSCardHandleCall->pIoRequestPacket;
    PRDPDR_DEVICE_IOREQUEST pIoRequest              = &(pIoRequestPacket->IoRequest);

    memset(&ControlReturn, 0, sizeof(ControlReturn));
    ControlReturn.ReturnCode = SCARD_S_SUCCESS;

    //
    // Decode input parameters
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) (pIoRequest + 1), // bytes are at end of struct
                        pIoRequest->Parameters.DeviceIoControl.InputBufferLength,
                        &hDec);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesDecodeBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    //
    // Decode input params
    //
    memset(&ControlCall, 0, sizeof(ControlCall));
    _TRY_status(Control_Call_Decode(hDec, &ControlCall))
    fFreeDecode = TRUE;

    if (sizeof(SCARDHANDLE) == ControlCall.hCard.cbHandle)
    {
        SCardContext = *((SCARDCONTEXT *) ControlCall.hCard.Context.pbContext);
        SCardHandle = *((SCARDHANDLE *) ControlCall.hCard.pbHandle);
        cbBytesReturned = ControlCall.cbOutBufferSize;
    }
    else
    {
        TRC_ERR((TB, _T("Invalid handle sent from server.")));
        ControlReturn.ReturnCode = SCARD_E_INVALID_PARAMETER;
    }

    //
    // Allocate if not in SCARD_AUTOALLOCATE mode and not a size only call
    //
    if (ControlReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        fDoAllocationLocally =
                (!ControlCall.fpvOutBufferIsNULL &&
                 (cbBytesReturned != SCARD_AUTOALLOCATE));

#ifdef OS_WINCE
        if (!fDoAllocationLocally)
        {
            ControlReturn.ReturnCode =
                pfnSCardControl(
                        SCardHandle,
                        ControlCall.dwControlCode,
                        ControlCall.pvInBuffer,
                        ControlCall.cbInBufferSize,
                        NULL,
                        cbBytesReturned,
                        &cbBytesReturned);

            if ((ControlReturn.ReturnCode == SCARD_S_SUCCESS) && (cbBytesReturned > 0))
                fDoAllocationLocally = TRUE;
            else
            {
                TRC_ERR((TB, _T("SCardControl failed")));
                status = STATUS_UNSUCCESSFUL;
                goto ErrorReturn;
            }
        }
#endif
        if (fDoAllocationLocally)
        {
            lpOutBuffer = (LPVOID) MIDL_user_allocate(cbBytesReturned * sizeof(BYTE));
            if (lpOutBuffer == NULL)
            {
                TRC_ERR((TB, _T("MIDL_user_allocate failed")));
                ControlReturn.ReturnCode = SCARD_E_NO_MEMORY;
            }
        }
    }

    //
    // Make the call
    //
    if (ControlReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        ControlReturn.ReturnCode =
            pfnSCardControl(
                    SCardHandle,
                    ControlCall.dwControlCode,
                    ControlCall.pvInBuffer,
                    ControlCall.cbInBufferSize,
                    (cbBytesReturned == SCARD_AUTOALLOCATE) ? (LPVOID) &lpOutBuffer : lpOutBuffer,
                    cbBytesReturned,
                    &cbBytesReturned);
    }

    if (ControlReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        ControlReturn.cbOutBufferSize = cbBytesReturned;

        //
        // If we are just returning the byte count then send back a junk buffer
        //
        if (lpOutBuffer == NULL)
        {
            ControlReturn.pvOutBuffer = (BYTE *) MIDL_user_allocate(cbBytesReturned);
            if (ControlReturn.pvOutBuffer == NULL)
            {
                status = STATUS_NO_MEMORY;
                goto ErrorReturn;
            }

            fFree = TRUE;
            memset(ControlReturn.pvOutBuffer, 0, cbBytesReturned);
        }
        else
        {
            ControlReturn.pvOutBuffer = (LPBYTE) lpOutBuffer;
        }
    }

    //
    // encode the return
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &hEnc);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesEncodeDynBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    _TRY_status(Control_Return_Encode(hEnc, &ControlReturn))

    //
    // Send return
    //
    AllocateAndChannelWriteReplyPacket(
                pIoRequestPacket,
                pbEncodedBuffer,
                cbEncodedBuffer);

Return:

    if (fFree)
    {
        MIDL_user_free(ControlReturn.pvOutBuffer);
    }

    if (lpOutBuffer != NULL)
    {
        //
        // Check to see whether we allocated or SCard allcated for us
        //
        if (fDoAllocationLocally)
        {
            MIDL_user_free(lpOutBuffer);
        }
        else
        {
#ifndef OS_WINCE
            pfnSCardFreeMemory(SCardContext, lpOutBuffer);
#else
            TRC_ASSERT(FALSE, (TB, _T("Shouldnt get here")));
#endif
        }
    }

    if (fFreeDecode)
    {
        _TRY_2(Control_Call_Free(hDec, &ControlCall))
    }
    SafeMesHandleFree(&hDec);

    SafeMesHandleFree(&hEnc);

    MIDL_user_free(pbEncodedBuffer);

    MIDL_user_free(pSCardHandleCall);

    DC_END_FN();

    return;

ErrorReturn:

    DefaultIORequestMsgHandleWrapper(pIoRequestPacket, status);

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  W32SCard::GetAttrib
//
//---------------------------------------------------------------------------------------
void
W32SCard::GetAttrib(
    IN SCARDHANDLECALLSTRUCT    *pSCardHandleCall)
{
    DC_BEGIN_FN("W32SCard::GetAttrib");

    RPC_STATUS              rpcStatus               = RPC_S_OK;
    NTSTATUS                status                  = STATUS_SUCCESS;
    char                    *pbEncodedBuffer        = NULL;
    unsigned long           cbEncodedBuffer         = 0;
    handle_t                hDec                    = 0;
    handle_t                hEnc                    = 0;
    SCARDCONTEXT            SCardContext;
    SCARDHANDLE             SCardHandle;
    GetAttrib_Call          GetAttribCall;
    GetAttrib_Return        GetAttribReturn;
    BOOL                    fFreeDecode             = FALSE;
    DWORD                   cbAttrLen               = 0;
    BOOL                    fDoAllocationLocally    = FALSE;
    LPBYTE                  pbAttr                  = NULL;
    BOOL                    fFree                   = FALSE;
    PRDPDR_IOREQUEST_PACKET pIoRequestPacket        = pSCardHandleCall->pIoRequestPacket;
    PRDPDR_DEVICE_IOREQUEST pIoRequest              = &(pIoRequestPacket->IoRequest);

    memset(&GetAttribReturn, 0, sizeof(GetAttribReturn));
    GetAttribReturn.ReturnCode = SCARD_S_SUCCESS;

    //
    // Decode input parameters
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) (pIoRequest + 1), // bytes are at end of struct
                        pIoRequest->Parameters.DeviceIoControl.InputBufferLength,
                        &hDec);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesDecodeBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    memset(&GetAttribCall, 0, sizeof(GetAttribCall));
    _TRY_status(GetAttrib_Call_Decode(hDec, &GetAttribCall))
    fFreeDecode = TRUE;

    if (sizeof(SCARDHANDLE) == GetAttribCall.hCard.cbHandle)
    {
        SCardContext = *((SCARDCONTEXT *) GetAttribCall.hCard.Context.pbContext);
        SCardHandle = *((SCARDHANDLE *) GetAttribCall.hCard.pbHandle);
        cbAttrLen = GetAttribCall.cbAttrLen;
    }
    else
    {
        TRC_ERR((TB, _T("Invalid handle sent from server.")));
        GetAttribReturn.ReturnCode = SCARD_E_INVALID_PARAMETER;
    }

    if (GetAttribReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        //
        // Allocate if not in SCARD_AUTOALLOCATE mode and not a size only call
        //
        fDoAllocationLocally =
                (!GetAttribCall.fpbAttrIsNULL &&
                 (cbAttrLen != SCARD_AUTOALLOCATE));

#ifdef OS_WINCE
        if (!fDoAllocationLocally)
        {
            GetAttribReturn.ReturnCode =
                pfnSCardGetAttrib(
                        SCardHandle,
                        GetAttribCall.dwAttrId,
                        NULL,
                        &cbAttrLen);

            if ((GetAttribReturn.ReturnCode == SCARD_S_SUCCESS) && (cbAttrLen > 0))
                fDoAllocationLocally = TRUE;
            else
            {
                TRC_ERR((TB, _T("SCardGetAttrib failed")));
                status = STATUS_UNSUCCESSFUL;
                goto ErrorReturn;
            }
        }
#endif
        if (fDoAllocationLocally)
        {
            pbAttr = (LPBYTE) MIDL_user_allocate(cbAttrLen);
            if (pbAttr == NULL)
            {
                TRC_ERR((TB, _T("MIDL_user_allocate failed")));
                GetAttribReturn.ReturnCode = SCARD_E_NO_MEMORY;
            }
        }
    }

    //
    // Make the call
    //
    if (GetAttribReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        GetAttribReturn.ReturnCode =
            pfnSCardGetAttrib(
                    SCardHandle,
                    GetAttribCall.dwAttrId,
                    (cbAttrLen == SCARD_AUTOALLOCATE) ? (LPBYTE) &pbAttr : pbAttr,
                    &cbAttrLen);

        if (GetAttribReturn.ReturnCode == SCARD_S_SUCCESS)
        {
            GetAttribReturn.cbAttrLen = cbAttrLen;

            //
            // If we are just returning the byte count then send back a junk buffer
            //
            if (pbAttr ==  NULL)
            {
                GetAttribReturn.pbAttr = (BYTE *) MIDL_user_allocate(cbAttrLen);
                if (GetAttribReturn.pbAttr == NULL)
                {
                    status = STATUS_NO_MEMORY;
                    goto ErrorReturn;
                }

                fFree = TRUE;
                memset(GetAttribReturn.pbAttr, 0, cbAttrLen);
            }
            else
            {
                GetAttribReturn.pbAttr = pbAttr;
            }
        }
    }

    //
    // encode the return
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &hEnc);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesEncodeDynBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    _TRY_status(GetAttrib_Return_Encode(hEnc, &GetAttribReturn))

    //
    // Send return
    //
    AllocateAndChannelWriteReplyPacket(
                pIoRequestPacket,
                pbEncodedBuffer,
                cbEncodedBuffer);

Return:

    if (fFree)
    {
        MIDL_user_free(GetAttribReturn.pbAttr);
    }

    if (pbAttr != NULL)
    {
        //
        // Check to see whether we allocated or SCard allcated for us
        //
        if (fDoAllocationLocally)
        {
            MIDL_user_free(pbAttr);
        }
        else
        {
#ifndef OS_WINCE
            pfnSCardFreeMemory(SCardContext, pbAttr);
#else
            TRC_ASSERT(FALSE, (TB, _T("Shouldnt get here")));
#endif
        }
    }

    if (fFreeDecode)
    {
        _TRY_2(GetAttrib_Call_Free(hDec, &GetAttribCall))
    }
    SafeMesHandleFree(&hDec);

    SafeMesHandleFree(&hEnc);

    MIDL_user_free(pbEncodedBuffer);

    MIDL_user_free(pSCardHandleCall);

    DC_END_FN();

    return;

ErrorReturn:

    DefaultIORequestMsgHandleWrapper(pIoRequestPacket, status);

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  W32SCard::SetAttrib
//
//---------------------------------------------------------------------------------------
void
W32SCard::SetAttrib(
    IN SCARDHANDLECALLSTRUCT    *pSCardHandleCall)
{
    DC_BEGIN_FN("W32SCard::SetAttrib");

    LONG                    lReturn                 = SCARD_S_SUCCESS;
    RPC_STATUS              rpcStatus               = RPC_S_OK;
    NTSTATUS                status                  = STATUS_SUCCESS;
    handle_t                hDec                    = 0;
    SCARDCONTEXT            SCardContext;
    SCARDHANDLE             SCardHandle;
    SetAttrib_Call          SetAttribCall;
    BOOL                    fFreeDecode             = FALSE;
    PRDPDR_IOREQUEST_PACKET pIoRequestPacket        = pSCardHandleCall->pIoRequestPacket;
    PRDPDR_DEVICE_IOREQUEST pIoRequest              = &(pIoRequestPacket->IoRequest);

    //
    // Decode input parameters
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) (pIoRequest + 1), // bytes are at end of struct
                        pIoRequest->Parameters.DeviceIoControl.InputBufferLength,
                        &hDec);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesDecodeBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    memset(&SetAttribCall, 0, sizeof(SetAttribCall));
    _TRY_status(SetAttrib_Call_Decode(hDec, &SetAttribCall))
    fFreeDecode = TRUE;

    if (sizeof(SCARDHANDLE) == SetAttribCall.hCard.cbHandle)
    {
        SCardContext = *((SCARDCONTEXT *) SetAttribCall.hCard.Context.pbContext);
        SCardHandle = *((SCARDHANDLE *) SetAttribCall.hCard.pbHandle);
    }
    else
    {
        TRC_ERR((TB, _T("Invalid handle sent from server.")));
        lReturn = SCARD_E_INVALID_PARAMETER;
    }

    //
    // Make the call
    //
    if (lReturn == SCARD_S_SUCCESS)
    {
        lReturn =
            pfnSCardSetAttrib(
                    SCardHandle,
                    SetAttribCall.dwAttrId,
                    SetAttribCall.pbAttr,
                    SetAttribCall.cbAttrLen);
    }

    //
    // Send return
    //
    EncodeAndChannelWriteLongReturn(
                pIoRequestPacket,
                lReturn);

Return:

    if (fFreeDecode)
    {
        _TRY_2(SetAttrib_Call_Free(hDec, &SetAttribCall))
    }
    SafeMesHandleFree(&hDec);

    MIDL_user_free(pSCardHandleCall);

    DC_END_FN();

    return;

ErrorReturn:

    DefaultIORequestMsgHandleWrapper(pIoRequestPacket, status);

    goto Return;
}



#ifndef OS_WINCE
//---------------------------------------------------------------------------------------
//
//  W32SCard::AccessStartedEvent + supporting WaitForStartedEvent
//
//---------------------------------------------------------------------------------------
void
W32SCard::WaitForStartedEvent(
    BOOLEAN TimerOrWaitFired)
{
    DC_BEGIN_FN("W32SCard::WaitForStartedEvent");

    LONG    lReturn = SCARD_E_UNEXPECTED;
    DWORD   i;
    PVOID   pv;

    //
    // If TimerOrWaitFired is FALSE, that means the event was set...
    // otherwise it timed out.
    //
    if (!TimerOrWaitFired)
    {
        lReturn = SCARD_S_SUCCESS;
    }

    EnterCriticalSection(&_csWaitForStartedEvent);

    pv = InterlockedExchangePointer(&_hRegisterWaitForStartedEvent, NULL);
    if (pv != NULL)
    {
        pfnUnregisterWaitEx(pv, NULL);
    }

    //
    // Loop for each outstanding wait and send return
    //
    for (i=0; i<_dwIORequestListSize; i++)
    {
        if (_rgIORequestList[i] != NULL)
        {
            EncodeAndChannelWriteLongReturn(
                                _rgIORequestList[i],
                                lReturn);

            _rgIORequestList[i] = NULL;
        }
    }

    LeaveCriticalSection(&_csWaitForStartedEvent);

Return:

    DC_END_FN();
}

VOID CALLBACK
WaitForStartedEventCallback(
    PVOID lpParameter,
    BOOLEAN TimerOrWaitFired)
{
    W32SCard *pTHIS = (W32SCard *) lpParameter;
    pTHIS->WaitForStartedEvent(TimerOrWaitFired);
}

typedef HANDLE (WINAPI FN_SCARDACCESSSTARTEDEVENT)(VOID);
typedef FN_SCARDACCESSSTARTEDEVENT *PFN_SCARDACCESSSTARTEDEVENT;

void
W32SCard::GetStartedEvent()
{
    DC_BEGIN_FN("W32SCard::GetStartedEvent");

    HMODULE                     hMod                    = NULL;
    PFN_SCARDACCESSSTARTEDEVENT pSCardAccessStartedEvent= NULL;
    HANDLE                      hEvent                  = NULL;

    hMod = LoadLibraryA("winscard.dll");

    if (hMod == NULL)
    {
        goto Return;
    }

    pSCardAccessStartedEvent = (PFN_SCARDACCESSSTARTEDEVENT)
            GetProcAddress(hMod, "SCardAccessStartedEvent");

    if (pSCardAccessStartedEvent != NULL)
    {
        _hStartedEvent = pSCardAccessStartedEvent();
    }
    else
    {
        TRC_ERR((   TB,
                    _T("GetProcAddress(SCardAccessStartedEvent) failed - LastError: %lx."),
                    GetLastError()));
    }

    FreeLibrary(hMod);

Return:

    DC_END_FN();
}

typedef VOID (WINAPI FN_SCARDRELEASESTARTEDEVENT)(VOID);
typedef FN_SCARDRELEASESTARTEDEVENT *PFN_SCARDRELEASESTARTEDEVENT;

void
W32SCard::ReleaseStartedEvent()
{
    DC_BEGIN_FN("W32SCard::ReleaseStartedEvent");

    HMODULE                         hMod                        = NULL;
    PFN_SCARDRELEASESTARTEDEVENT    pSCardReleaseStartedEvent   = NULL;

    hMod = LoadLibraryA("winscard.dll");

    if (hMod == NULL)
    {
        goto Return;
    }

    pSCardReleaseStartedEvent = (PFN_SCARDRELEASESTARTEDEVENT)
            GetProcAddress(hMod, "SCardReleaseStartedEvent");

    if (pSCardReleaseStartedEvent != NULL)
    {
        pSCardReleaseStartedEvent();
    }
    else
    {
        TRC_ERR((   TB,
                    _T("GetProcAddress(SCardReleaseStartedEvent) failed - LastError: %lx."),
                    GetLastError()));
    }

    FreeLibrary(hMod);

Return:

    DC_END_FN();
}
#endif


void
W32SCard::AccessStartedEvent(
    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket)
{
    DC_BEGIN_FN("W32SCard::AccessStartedEvent");

    LONG    lReturn         = SCARD_S_SUCCESS;

    //
    // Make sure only one thread registers at a time
    //
    EnterCriticalSection(&_csWaitForStartedEvent);

#ifndef OS_WINCE

    //
    // First, make sure we can get the started event
    //
    if (_hStartedEvent == NULL)
    {
        GetStartedEvent();
    }

    if (_hStartedEvent == NULL)
    {
        //
        // Couldn't even get the event, so return error
        //
        lReturn = SCARD_E_NO_SERVICE;
        goto ImmediateReturn;
    }

    //
    // Now, check to see if the event is already signaled, if so,
    // then just return success, otherwise, register a wait callback
    // on the event so we don't block this thread
    //
    if (WaitForSingleObject(_hStartedEvent, 0) == WAIT_OBJECT_0)
    {
        //
        // It is signaled, so return success
        //
        lReturn = SCARD_S_SUCCESS;
        goto ImmediateReturn;
    }

    //
    // If the object is currently being destroyed, then don't create a new thread.
    //
    if (_fInDestructor)
    {
        goto ImmediateReturn;
    }

    //
    // Only allow one wait to be registered.  The single wait callback will
    // notify all waiting requests
    //
    if ((_hRegisterWaitForStartedEvent == NULL) && _fUseRegisterWaitFuncs)
    {
        if (!pfnRegisterWaitForSingleObject(
                &_hRegisterWaitForStartedEvent,
                _hStartedEvent,
                WaitForStartedEventCallback,
                this,
                INFINITE,
                WT_EXECUTEONLYONCE))
        {
            lReturn = SCARD_E_NO_SERVICE;
            goto ImmediateReturn;
        }
    }
    else if (!_fUseRegisterWaitFuncs)
    {
        lReturn = SCARD_E_UNEXPECTED;
        goto ImmediateReturn;
    }
#else
    lReturn = SCARD_S_SUCCESS;
    goto ImmediateReturn;
#endif

    //
    // Add this pIoRequestPacket to the list
    //
    if (!AddIORequestToList(pIoRequestPacket))
    {
        lReturn = SCARD_E_UNEXPECTED;
        goto ImmediateReturn;
    }

    //
    // return here and let the wait we just registered
    // make the EncodeAndChannelWriteLongReturn call,
    // which will send the return the calling server
    //
Return:

    LeaveCriticalSection(&_csWaitForStartedEvent);

    DC_END_FN();
    return;

ImmediateReturn:

    EncodeAndChannelWriteLongReturn(
                        pIoRequestPacket,
                        lReturn);

    goto Return;
}


HANDLE
W32SCard::StartFSFunc(
    IN W32DRDEV_ASYNCIO_PARAMS *params,
    OUT DWORD *status
)
/*++

Routine Description:

    Start a generic asynchronous File System IO operation.

Arguments:

    params  -   Context for the IO request.
    status  -   Return status for IO request in the form of a windows
                error code.

Return Value:

    Returns a handle to an object that will be signalled when the read
    completes, if it is not completed in this function.  Otherwise, NULL
    is returned.

--*/
{
#ifndef OS_WINCE
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    DrFile* pFile;
    ULONG irpMajor;
#endif

    DC_BEGIN_FN("W32SCard::StartFSFunc");

    *status = ERROR_SUCCESS;

    DC_END_FN();
    return NULL;
}


DWORD
W32SCard::AsyncNotifyChangeDir(
    IN W32DRDEV_ASYNCIO_PARAMS *params
)
/*++

Routine Description:

    Directory change notification Function

Arguments:

    params  -   Context for the IO request.

Return Value:

    Always returns 0.

--*/
{
    DC_BEGIN_FN("W32SCard::AsyncNotifyChangeDir");


    DC_END_FN();
    return ERROR_SUCCESS;
}


DWORD
W32SCard::AsyncDirCtrlFunc(
    IN W32DRDEV_ASYNCIO_PARAMS *params
)
/*++

Routine Description:

    Asynchrous Directory Control Function

Arguments:

    params  -   Context for the IO request.

Return Value:

    Always returns 0.

--*/
{
    DC_BEGIN_FN("W32SCard::AsyncDirCtrlFunc");

    DC_END_FN();
    return ERROR_SUCCESS;
}


BOOL
W32SCard::BindToSCardFunctions()
{
#ifndef OS_WINCE
    int     i;
#endif
    BOOL    fRet = TRUE;

    //
    // Load winscard dll if it exists
    //
    _hModWinscard = LoadLibraryA("winscard.dll");
    if (_hModWinscard != NULL)
    {
        //
        // get the function pointers
        //
#ifndef OS_WINCE
        pfnSCardEstablishContext = (PFN_SCardEstablishContext) GetProcAddress(_hModWinscard, "SCardEstablishContext");
        pfnSCardReleaseContext = (PFN_SCardReleaseContext) GetProcAddress(_hModWinscard, "SCardReleaseContext");
        pfnSCardIsValidContext = (PFN_SCardIsValidContext) GetProcAddress(_hModWinscard, "SCardIsValidContext");
        pfnSCardListReaderGroupsA = (PFN_SCardListReaderGroupsA) GetProcAddress(_hModWinscard, "SCardListReaderGroupsA");
        pfnSCardListReaderGroupsW = (PFN_SCardListReaderGroupsW) GetProcAddress(_hModWinscard, "SCardListReaderGroupsW");
        pfnSCardListReadersA = (PFN_SCardListReadersA) GetProcAddress(_hModWinscard, "SCardListReadersA");
        pfnSCardListReadersW = (PFN_SCardListReadersW) GetProcAddress(_hModWinscard, "SCardListReadersW");
        pfnSCardIntroduceReaderGroupA = (PFN_SCardIntroduceReaderGroupA) GetProcAddress(_hModWinscard, "SCardIntroduceReaderGroupA");
        pfnSCardIntroduceReaderGroupW = (PFN_SCardIntroduceReaderGroupW) GetProcAddress(_hModWinscard, "SCardIntroduceReaderGroupW");
        pfnSCardForgetReaderGroupA = (PFN_SCardForgetReaderGroupA) GetProcAddress(_hModWinscard, "SCardForgetReaderGroupA");
        pfnSCardForgetReaderGroupW = (PFN_SCardForgetReaderGroupW) GetProcAddress(_hModWinscard, "SCardForgetReaderGroupW");
        pfnSCardIntroduceReaderA = (PFN_SCardIntroduceReaderA) GetProcAddress(_hModWinscard, "SCardIntroduceReaderA");
        pfnSCardIntroduceReaderW = (PFN_SCardIntroduceReaderW) GetProcAddress(_hModWinscard, "SCardIntroduceReaderW");
        pfnSCardForgetReaderA = (PFN_SCardForgetReaderA) GetProcAddress(_hModWinscard, "SCardForgetReaderA");
        pfnSCardForgetReaderW = (PFN_SCardForgetReaderW) GetProcAddress(_hModWinscard, "SCardForgetReaderW");
        pfnSCardAddReaderToGroupA = (PFN_SCardAddReaderToGroupA) GetProcAddress(_hModWinscard, "SCardAddReaderToGroupA");
        pfnSCardAddReaderToGroupW = (PFN_SCardAddReaderToGroupW) GetProcAddress(_hModWinscard, "SCardAddReaderToGroupW");
        pfnSCardRemoveReaderFromGroupA = (PFN_SCardRemoveReaderFromGroupA) GetProcAddress(_hModWinscard, "SCardRemoveReaderFromGroupA");
        pfnSCardRemoveReaderFromGroupW = (PFN_SCardRemoveReaderFromGroupW) GetProcAddress(_hModWinscard, "SCardRemoveReaderFromGroupW");
        pfnSCardFreeMemory = (PFN_SCardFreeMemory) GetProcAddress(_hModWinscard, "SCardFreeMemory");
        pfnSCardLocateCardsA = (PFN_SCardLocateCardsA) GetProcAddress(_hModWinscard, "SCardLocateCardsA");
        pfnSCardLocateCardsW = (PFN_SCardLocateCardsW) GetProcAddress(_hModWinscard, "SCardLocateCardsW");
        pfnSCardLocateCardsByATRA = (PFN_SCardLocateCardsByATRA) GetProcAddress(_hModWinscard, "SCardLocateCardsByATRA");
        pfnSCardLocateCardsByATRW = (PFN_SCardLocateCardsByATRW) GetProcAddress(_hModWinscard, "SCardLocateCardsByATRW");
        pfnSCardGetStatusChangeA = (PFN_SCardGetStatusChangeA) GetProcAddress(_hModWinscard, "SCardGetStatusChangeA");
        pfnSCardGetStatusChangeW = (PFN_SCardGetStatusChangeW) GetProcAddress(_hModWinscard, "SCardGetStatusChangeW");
        pfnSCardCancel = (PFN_SCardCancel) GetProcAddress(_hModWinscard, "SCardCancel");
        pfnSCardConnectA = (PFN_SCardConnectA) GetProcAddress(_hModWinscard, "SCardConnectA");
        pfnSCardConnectW = (PFN_SCardConnectW) GetProcAddress(_hModWinscard, "SCardConnectW");
        pfnSCardReconnect = (PFN_SCardReconnect) GetProcAddress(_hModWinscard, "SCardReconnect");
        pfnSCardDisconnect = (PFN_SCardDisconnect) GetProcAddress(_hModWinscard, "SCardDisconnect");
        pfnSCardBeginTransaction = (PFN_SCardBeginTransaction) GetProcAddress(_hModWinscard, "SCardBeginTransaction");
        pfnSCardEndTransaction = (PFN_SCardEndTransaction) GetProcAddress(_hModWinscard, "SCardEndTransaction");
        pfnSCardState = (PFN_SCardState) GetProcAddress(_hModWinscard, "SCardState");
        pfnSCardStatusA = (PFN_SCardStatusA) GetProcAddress(_hModWinscard, "SCardStatusA");
        pfnSCardStatusW = (PFN_SCardStatusW) GetProcAddress(_hModWinscard, "SCardStatusW");
        pfnSCardTransmit = (PFN_SCardTransmit) GetProcAddress(_hModWinscard, "SCardTransmit");
        pfnSCardControl = (PFN_SCardControl) GetProcAddress(_hModWinscard, "SCardControl");
        pfnSCardGetAttrib = (PFN_SCardGetAttrib) GetProcAddress(_hModWinscard, "SCardGetAttrib");
        pfnSCardSetAttrib = (PFN_SCardSetAttrib) GetProcAddress(_hModWinscard, "SCardSetAttrib");

#else
        pfnSCardListReadersA = SCardListReadersA;
        pfnSCardLocateCardsA = SCardLocateCardsA;
        pfnSCardLocateCardsByATRA = SCardLocateCardsByATRA;
        pfnSCardGetStatusChangeA = SCardGetStatusChangeA;
        pfnSCardConnectA = SCardConnectA;
        pfnSCardStatusA  = SCardStatusA;
        pfnSCardIntroduceReaderA = SCardIntroduceReaderA;
        pfnSCardForgetReaderA = SCardForgetReaderA;

        pfnSCardListReaderGroupsA = SCardListReaderGroupsA;
        pfnSCardListReaderGroupsW = SCardListReaderGroupsW;
        pfnSCardIntroduceReaderGroupA = SCardIntroduceReaderGroupA;
        pfnSCardIntroduceReaderGroupW = SCardIntroduceReaderGroupW;
        pfnSCardForgetReaderGroupA = SCardForgetReaderGroupA;
        pfnSCardForgetReaderGroupW = SCardForgetReaderGroupW;
        pfnSCardAddReaderToGroupA = SCardAddReaderToGroupA;
        pfnSCardAddReaderToGroupW = SCardAddReaderToGroupW;
        pfnSCardRemoveReaderFromGroupA = SCardRemoveReaderFromGroupA;
        pfnSCardRemoveReaderFromGroupW = SCardRemoveReaderFromGroupW;

        pfnSCardConnectW = CESCardConnect;
        pfnSCardReconnect = CESCardReconnect;
        pfnSCardDisconnect = CESCardDisconnect;
        pfnSCardBeginTransaction = CESCardBeginTransaction;
        pfnSCardEndTransaction = CESCardEndTransaction;
        pfnSCardTransmit = CESCardTransmit;
        pfnSCardStatusW = CESCardStatus;
        pfnSCardControl = CESCardControl;
        pfnSCardGetAttrib = CESCardGetAttrib;
        pfnSCardSetAttrib = CESCardSetAttrib;

        gpfnSCardConnectW = (PFN_SCardConnectW) GetProcAddress(_hModWinscard, L"SCardConnectW");
        gpfnSCardReconnect = (PFN_SCardReconnect) GetProcAddress(_hModWinscard, L"SCardReconnect");
        gpfnSCardDisconnect = (PFN_SCardDisconnect) GetProcAddress(_hModWinscard, L"SCardDisconnect");
        gpfnSCardBeginTransaction = (PFN_SCardBeginTransaction) GetProcAddress(_hModWinscard, L"SCardBeginTransaction");
        gpfnSCardEndTransaction = (PFN_SCardEndTransaction) GetProcAddress(_hModWinscard, L"SCardEndTransaction");
        gpfnSCardTransmit = (PFN_SCardTransmit) GetProcAddress(_hModWinscard, L"SCardTransmit");
        gpfnSCardStatusW = (PFN_SCardStatusW) GetProcAddress(_hModWinscard, L"SCardStatusW");
        gpfnSCardControl = (PFN_SCardControl) GetProcAddress(_hModWinscard, L"SCardControl");
        gpfnSCardGetAttrib = (PFN_SCardGetAttrib) GetProcAddress(_hModWinscard, L"SCardGetAttrib");
        gpfnSCardSetAttrib = (PFN_SCardSetAttrib) GetProcAddress(_hModWinscard, L"SCardSetAttrib");

        pfnSCardEstablishContext = (PFN_SCardEstablishContext) GetProcAddress(_hModWinscard, L"SCardEstablishContext");
        pfnSCardReleaseContext = (PFN_SCardReleaseContext) GetProcAddress(_hModWinscard, L"SCardReleaseContext");
        pfnSCardIsValidContext = (PFN_SCardIsValidContext) GetProcAddress(_hModWinscard, L"SCardIsValidContext");
        pfnSCardListReadersW = (PFN_SCardListReadersW) GetProcAddress(_hModWinscard, L"SCardListReadersW");
        pfnSCardIntroduceReaderW = (PFN_SCardIntroduceReaderW) GetProcAddress(_hModWinscard, L"SCardIntroduceReaderW");
        pfnSCardForgetReaderW = (PFN_SCardForgetReaderW) GetProcAddress(_hModWinscard, L"SCardForgetReaderW");
        pfnSCardLocateCardsW = (PFN_SCardLocateCardsW) GetProcAddress(_hModWinscard, L"SCardLocateCardsW");
        pfnSCardLocateCardsByATRW = (PFN_SCardLocateCardsByATRW) GetProcAddress(_hModWinscard, L"SCardLocateCardsByATRW");
        pfnSCardGetStatusChangeW = (PFN_SCardGetStatusChangeW) GetProcAddress(_hModWinscard, L"SCardGetStatusChangeW");
        pfnSCardCancel = (PFN_SCardCancel) GetProcAddress(_hModWinscard, L"SCardCancel");

        gpfnSCardEstablishContext = pfnSCardEstablishContext;
        gpfnSCardReleaseContext = pfnSCardReleaseContext;

        gpfnSCardListReadersW = pfnSCardListReadersW;
        gpfnSCardIntroduceReaderW = pfnSCardIntroduceReaderW;
        gpfnSCardForgetReaderW = pfnSCardForgetReaderW;
        gpfnSCardLocateCardsW = pfnSCardLocateCardsW;
        gpfnSCardLocateCardsByATRW = pfnSCardLocateCardsByATRW;
        gpfnSCardGetStatusChangeW = pfnSCardGetStatusChangeW;
#endif

        //
        // Note, don't check the pfnSCardLocateCardsByATR* API's since they aren't required.
        //

        if ((pfnSCardEstablishContext == NULL) ||
            (pfnSCardReleaseContext == NULL) ||
            (pfnSCardIsValidContext == NULL) ||
#ifndef OS_WINCE
            (pfnSCardFreeMemory == NULL) ||
            (pfnSCardState == NULL) ||
#endif
            (pfnSCardListReaderGroupsA == NULL) ||
            (pfnSCardListReaderGroupsW == NULL) ||
            (pfnSCardListReadersA == NULL) ||
            (pfnSCardListReadersW == NULL) ||
            (pfnSCardIntroduceReaderGroupA == NULL) ||
            (pfnSCardIntroduceReaderGroupW == NULL) ||
            (pfnSCardForgetReaderGroupA == NULL) ||
            (pfnSCardForgetReaderGroupW == NULL) ||
            (pfnSCardIntroduceReaderA == NULL) ||
            (pfnSCardIntroduceReaderW == NULL) ||
            (pfnSCardForgetReaderA == NULL) ||
            (pfnSCardForgetReaderW == NULL) ||
            (pfnSCardAddReaderToGroupA == NULL) ||
            (pfnSCardAddReaderToGroupW == NULL) ||
            (pfnSCardRemoveReaderFromGroupA == NULL) ||
            (pfnSCardRemoveReaderFromGroupW == NULL) ||
            (pfnSCardLocateCardsA == NULL) ||
            (pfnSCardLocateCardsW == NULL) ||
            (pfnSCardGetStatusChangeA == NULL) ||
            (pfnSCardGetStatusChangeW == NULL) ||
            (pfnSCardCancel == NULL) ||
            (pfnSCardConnectA == NULL) ||
            (pfnSCardStatusA == NULL) ||
#ifndef OS_WINCE
            (pfnSCardConnectW == NULL) ||
            (pfnSCardReconnect == NULL) ||
            (pfnSCardDisconnect == NULL) ||
            (pfnSCardBeginTransaction == NULL) ||
            (pfnSCardEndTransaction == NULL) ||
            (pfnSCardTransmit == NULL) ||
            (pfnSCardStatusW == NULL) ||
            (pfnSCardControl == NULL) ||
            (pfnSCardGetAttrib == NULL) ||
            (pfnSCardSetAttrib == NULL))
#else
            (gpfnSCardConnectW == NULL) ||
            (gpfnSCardReconnect == NULL) ||
            (gpfnSCardDisconnect == NULL) ||
            (gpfnSCardBeginTransaction == NULL) ||
            (gpfnSCardEndTransaction == NULL) ||
            (gpfnSCardTransmit == NULL) ||
            (gpfnSCardStatusW == NULL) ||
            (gpfnSCardControl == NULL) ||
            (gpfnSCardGetAttrib == NULL) ||
            (gpfnSCardSetAttrib == NULL))
#endif
        {
            fRet = FALSE;
        }

#ifndef OS_WINCE
        _hModKernel32 = LoadLibraryA("kernel32.dll");

        if (_hModKernel32 != NULL)
        {
            pfnRegisterWaitForSingleObject = (PFN_RegisterWaitForSingleObject)
                    GetProcAddress(_hModKernel32, "RegisterWaitForSingleObject");

            pfnUnregisterWaitEx = (PFN_UnregisterWaitEx)
                    GetProcAddress(_hModKernel32, "UnregisterWaitEx");

            if ((pfnRegisterWaitForSingleObject != NULL) &&
                (pfnUnregisterWaitEx != NULL))
            {
                _fUseRegisterWaitFuncs = TRUE;
            }
        }
#endif
    }
    else
    {
        fRet = FALSE;
    }

    return (fRet);
}


//
// RPCRT4 stubs for dload failure
//
RPC_STATUS  RPC_ENTRY
DLoadStub_MesDecodeBufferHandleCreate(
    char            *   pBuffer,
    unsigned long       BufferSize,
    handle_t        *   pHandle )
{
    return (RPC_S_OUT_OF_MEMORY);
}

RPC_STATUS  RPC_ENTRY
DLoadStub_MesEncodeDynBufferHandleCreate(
    char            * * pBuffer,
    unsigned long   *   pEncodedSize,
    handle_t        *   pHandle )
{
    return (RPC_S_OUT_OF_MEMORY);
}

void  RPC_ENTRY
DLoadStub_NdrMesTypeEncode2(
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pPicklingInfo,
    const MIDL_STUB_DESC *          pStubDesc,
    PFORMAT_STRING                  pFormatString,
    const void           *          pObject )
{
    throw (RPC_S_OUT_OF_MEMORY);
    return;
}

void  RPC_ENTRY
DLoadStub_NdrMesTypeDecode2(
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pPicklingInfo,
    const MIDL_STUB_DESC *          pStubDesc,
    PFORMAT_STRING                  pFormatString,
    void                 *          pObject )
{
    throw (RPC_S_OUT_OF_MEMORY);
    return;
}

void RPC_ENTRY
DLoadStub_NdrMesTypeFree2(
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pPicklingInfo,
    const MIDL_STUB_DESC          * pStubDesc,
    PFORMAT_STRING                  pFormatString,
    void                 *          pObject )
{
    throw (RPC_S_OUT_OF_MEMORY);
    return;
}

RPC_STATUS  RPC_ENTRY
DLoadStub_MesHandleFree( handle_t  Handle )
{
    return (RPC_S_OUT_OF_MEMORY);
}

FARPROC WINAPI GetRPCRT4Stubs(LPCSTR szProcName)
{
    DC_BEGIN_FN("W32SCard::GetRPCRT4Stubs");

    if (0 == _stricmp(szProcName, "MesDecodeBufferHandleCreate"))
        return (FARPROC)DLoadStub_MesDecodeBufferHandleCreate;

    if (0 == _stricmp(szProcName, "MesEncodeDynBufferHandleCreate"))
        return (FARPROC)DLoadStub_MesEncodeDynBufferHandleCreate;

    if (0 == _stricmp(szProcName, "NdrMesTypeEncode2"))
        return (FARPROC)DLoadStub_NdrMesTypeEncode2;

    if (0 == _stricmp(szProcName, "NdrMesTypeDecode2"))
        return (FARPROC)DLoadStub_NdrMesTypeDecode2;

    if (0 == _stricmp(szProcName, "NdrMesTypeFree2"))
        return (FARPROC)DLoadStub_NdrMesTypeFree2;

    if (0 == _stricmp(szProcName, "MesHandleFree"))
        return (FARPROC)DLoadStub_MesHandleFree;

    TRC_ERR((   TB,
                _T("RPCRT4 stub =%s= is missing. Fix it NOW!"),
                szProcName));

    DC_END_FN();

    return (FARPROC) NULL;
}


//
// Dload error handler
//
FARPROC WINAPI DliHook(unsigned dliNotify, PDelayLoadInfo pdli)
{
    DC_BEGIN_FN("W32SCard::DliHook");

    FARPROC fp = 0;

    switch (dliNotify)
    {
        case dliFailLoadLib:
        {
            if (0 == _stricmp("rpcrt4.dll", pdli->szDll))
            {
                fp = (FARPROC) -1;
            }
        }
        break;

        case dliFailGetProc:
        {
            SetLastError(ERROR_PROC_NOT_FOUND);

            if (0 == _stricmp("rpcrt4.dll", pdli->szDll))
            {
                if (pdli->dlp.fImportByName)
                {
                    fp = GetRPCRT4Stubs(pdli->dlp.szProcName);
                }
                else
                {
                    TRC_ERR((   TB,
                                _T("RPCRT4 ordinal stub =%lx= is missing. Fix it NOW!"),
                                pdli->dlp.dwOrdinal));

                    fp = (FARPROC) NULL;
                }
            }
        }
        break;
    }

    DC_END_FN();

    return fp;
}

PfnDliHook __pfnDliFailureHook2 = DliHook;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\wceinc.h ===
#define INVALID_SET_FILE_POINTER ((DWORD)-1)
#define RESETDEV            7
#define FILE_CASE_PRESERVED_NAMES       0x00000002  // winnt
#define FILE_UNICODE_ON_DISK            0x00000004  // winnt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\win32\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1998 - 2000

Module Name:

    makefile.inc.

!ENDIF

$(O)\scredir.idl: $(DS_INC_PATH)\scredir.idl
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\w32utl.cpp ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    w32utl.cpp

Abstract:

    Win32-Specific Utilities for the RDP Client Device Redirector

Author:

    Tad Brockway

Revision History:

--*/

#include <precom.h>

#define TRC_FILE  "w32utl"

#include "w32utl.h"
#include "atrcapi.h"
#include "drdbg.h"

ULONG
RDPConvertToAnsi(
    LPWSTR lpwszUnicodeString,
    LPSTR lpszAnsiString,
    ULONG ulAnsiBufferLen
    )
/*++

Routine Description:

    Converts a Ansi string to Unicode.

Arguments:

    lpwszUnicodeString - pointer to a unicode string to convert.

    lpszAnsiString - pointer to a ansi string buffer.

    ulAnsiBufferLen - Ansi buffer length.

Return Value:

    Windows Error Code.

 --*/
{
    ULONG ulRetVal;
    ULONG ulUnicodeStrLen;
    int count;

    DC_BEGIN_FN("RDPConvertToAnsi");

    ulUnicodeStrLen = wcslen(lpwszUnicodeString);

    if( ulUnicodeStrLen != 0 ) {

        count =
            WideCharToMultiByte(
                CP_ACP,
                WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                lpwszUnicodeString,
                -1,
                lpszAnsiString,
                ulAnsiBufferLen,
                NULL,   // system default character.
                NULL);  // no notification of conversion failure.

        if (count == 0) {
            ulRetVal = GetLastError();
            TRC_ERR((TB, _T("RDPConvertToAnsi WideCharToMultiByte %ld."),ulRetVal));
        }
        else {
            ulRetVal = ERROR_SUCCESS;
        }
    }   
    else {
        if (ulAnsiBufferLen > 0) {
            ulRetVal = ERROR_SUCCESS;
            lpszAnsiString[0] = '\0';
        }
        else {
            ulRetVal = ERROR_INSUFFICIENT_BUFFER;
            ASSERT(FALSE);
        }
    }
    DC_END_FN();
    return ulRetVal;
}

ULONG
RDPConvertToUnicode(
    LPSTR lpszAnsiString,
    LPWSTR lpwszUnicodeString,
    ULONG ulUnicodeBufferLen
    )
/*++

Routine Description:

    Converts a Ansi string to Unicode.

Arguments:

    lpszAnsiString - pointer to a ansi string to convert.

    lpwszUnicodeString - pointer to a unicode buffer.

    ulUnicodeBufferLen - unicode buffer length.

Return Value:

    Windows Error Code.

 --*/
{
    ULONG ulRetVal;
    ULONG ulAnsiStrLen;
    int count;

    DC_BEGIN_FN("RDPConvertToUnicode");

    ulAnsiStrLen = strlen(lpszAnsiString);

    if( ulAnsiStrLen != 0 ) {

        //
        // Wide char string is terminated
        // by MultiByteToWideChar
        //

        count =
            MultiByteToWideChar(
                CP_ACP,
                MB_PRECOMPOSED,
                lpszAnsiString,
                -1,
                lpwszUnicodeString,
                ulUnicodeBufferLen);

        if (count == 0) {
            ulRetVal = GetLastError();
            TRC_ERR((TB, _T("RDPConvertToUnicode MultiByteToWideChar %ld."),ulRetVal));
        }
        else {
            ulRetVal = ERROR_SUCCESS;
        }

    }
    else {

        //
        // do nothing.
        //
        if (ulUnicodeBufferLen > 0) {
            ulRetVal = ERROR_SUCCESS;
            lpwszUnicodeString[0] = L'\0';
        }
        else {
            ulRetVal = ERROR_INSUFFICIENT_BUFFER;
            ASSERT(FALSE);
        }
    }

    DC_END_FN();
    return ulRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\w32utl.h ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    w32utl.h

Abstract:

    Win32-Specific Utilities for the RDP Client Device Redirector

Author:

    Tad Brockway

Revision History:

--*/

#ifndef __W32UTL_H__
#define __W32UTL_H__


//
//  Converts a Unicode string to Ansi
//
ULONG RDPConvertToAnsi(LPWSTR lpwszUnicodeString, LPSTR lpszAnsiString,
                       ULONG ulAnsiBufferLen);


//
//  Converts a Ansi string to Unicode.
//
ULONG RDPConvertToUnicode(LPSTR lpszAnsiString, 
                        LPWSTR lpwszUnicodeString,
                        ULONG ulUnicodeBufferLen);

//
//  Translate a Windows Error (winerror.h) code into a Windows NT
//  Status (ntstatus.h) code.
//
inline NTSTATUS TranslateWinError(DWORD error)
{
    //
    //  Would be faster if it were table-driven.
    //
    switch (error) {
    case ERROR_SUCCESS :
        return STATUS_SUCCESS;
    case ERROR_FILE_NOT_FOUND :
        return STATUS_NO_SUCH_FILE;
    case ERROR_INSUFFICIENT_BUFFER:
        return STATUS_INSUFFICIENT_RESOURCES;
    case ERROR_SERVICE_NO_THREAD:
        return STATUS_WAIT_0;
    case ERROR_OPEN_FAILED:
        return STATUS_OPEN_FAILED;
    case ERROR_NO_MORE_FILES:
        return STATUS_NO_MORE_FILES;
    case ERROR_FILE_EXISTS:
    case ERROR_ALREADY_EXISTS:
        return STATUS_OBJECT_NAME_COLLISION;
    case ERROR_INVALID_FUNCTION:
        return STATUS_INVALID_DEVICE_REQUEST;
    case ERROR_ACCESS_DENIED:
        return STATUS_ACCESS_DENIED;
    case ERROR_INVALID_PARAMETER:
        return STATUS_INVALID_PARAMETER;
    case ERROR_PATH_NOT_FOUND:
        return STATUS_OBJECT_PATH_NOT_FOUND;
    case ERROR_SHARING_VIOLATION:
        return STATUS_SHARING_VIOLATION;
    case ERROR_DISK_FULL:
        return STATUS_DISK_FULL;
    case ERROR_DIRECTORY:
        return STATUS_NOT_A_DIRECTORY;
    case ERROR_WRITE_PROTECT:
        return STATUS_MEDIA_WRITE_PROTECTED;
    case ERROR_PRIVILEGE_NOT_HELD:
        return STATUS_PRIVILEGE_NOT_HELD;
    case ERROR_NOT_READY:
        return STATUS_DEVICE_NOT_READY;
    case ERROR_UNRECOGNIZED_MEDIA:
        return STATUS_UNRECOGNIZED_MEDIA;
    case ERROR_UNRECOGNIZED_VOLUME:
        return STATUS_UNRECOGNIZED_VOLUME;
    default:
        return STATUS_UNSUCCESSFUL;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\setup\inc\dbg.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name :
    
    dbg.h

Abstract:

    TS client setup library debug logging

Author:

    JoyC 

Revision History:
--*/

#ifndef _TSCDBG_
#define _TSCDBG_

extern HANDLE g_hLogFile;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


////////////////////////////////////////////////////////
//      
//      Debugging
//
#undef ASSERT

#if DBG
_inline ULONG DbgPrint(TCHAR* Format, ...) {
    va_list arglist;
    TCHAR Buffer[1024];
    ULONG retval;

    //
    // Format the output into a buffer and then print it.
    //

    va_start(arglist, Format);
    retval = _vsntprintf(Buffer, sizeof(Buffer)/sizeof(Buffer[0]), Format, arglist);

    if (retval != -1) {
        OutputDebugString(Buffer);
        OutputDebugString(_T("\n"));
    }
    return retval;
}
#else
_inline ULONG DbgPrint(TCHAR* Format, ...) { return 0; }
#endif

_inline ULONG DbgLogToFile(LPTSTR Format, ...) {
    va_list argList;
    DWORD dwWritten, retval;
    TCHAR szLogString[1024];

    //
    //  Format the output into a buffer and then write to a logfile.
    //
    va_start(argList, Format);
    retval = _vsntprintf(
                szLogString,
                sizeof(szLogString)/sizeof(TCHAR) - 1,
                Format, argList
                );
    szLogString[sizeof(szLogString)/sizeof(TCHAR) - 1] = 0;

    if (retval != -1) {
        WriteFile(g_hLogFile, szLogString, _tcslen(szLogString) * sizeof(TCHAR),
                  &dwWritten, NULL); 
        WriteFile(g_hLogFile, _T("\r\n"), _tcslen(_T("\r\n")) * sizeof(TCHAR),
                  &dwWritten, NULL);
    }
    return retval;
}

VOID DbgBreakPoint(VOID);

/* Double braces are needed for this one, e.g.:
 *
 *     DBGMSG( ( "Error code %d", Error ) );
 *
 * This is because we can't use variable parameter lists in macros.
 * The statement gets pre-processed to a semi-colon in non-debug mode.
 *
 */
#define DBGMSG(MsgAndArgs) \
{ \
    if (g_hLogFile == INVALID_HANDLE_VALUE) { \
        DbgPrint MsgAndArgs; \
    } \
    else { \
        DbgLogToFile MsgAndArgs; \
    } \
}

#if DBG
#define ASSERT(expr)                      \
    if (!(expr)) {                           \
        DbgPrint( _T("Failed: %s\nLine %d, %s\n"), \
                                #expr,       \
                                __LINE__,    \
                                _T(__FILE__) );  \
        DebugBreak();                        \
    }
#else
#define ASSERT(exp)
#endif

#ifdef __cplusplus
}
#endif // __cplusplus


#endif // #ifndef _TSCDBG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\setup\inc\setuplib.h ===
//setuplib.h: ts client shared setup functions
//Copyright (c) 2000 Microsoft Corporation
//

#ifndef _setuplib_h_
#define _setuplib_h_

#include "dbg.h"

void DeleteTSCProgramFiles();
void DeleteTSCFromStartMenu(TCHAR *);
void DeleteTSCDesktopShortcuts(); 
void DeleteBitmapCacheFolder(TCHAR *szDstDir);
void DeleteTSCRegKeys();
HRESULT UninstallTSACMsi();

#endif // _setuplib_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\setup\msi\custom\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------
// Used by common.rc
//


#define IDS_MSG_TITLE                   3000
#define IDS_ERR_TCP                     3001
#define IDS_ERROR                       3002
#define IDS_WARNING                     3003
#define IDS_BLOCKONTHISPLAT             3004
#define IDS_PROGMAN_GROUP               3005
#define IDS_OLD_NAME                    3006
#define IDS_BLOCKCOMCTL32               3007
#define IDS_ACCESSORIES                 3008
#define IDS_COMMUNICATIONS              3009
#define IDS_RDC_SHORTCUT_FILE           3010
#define IDS_MSTSC_EXE_FILE              3011
#define IDS_RDC_DESCRIPTION             3012
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\setup\msi\custom\custom.h ===
//
// custom.h
// TS client MSI custom action
//
//

#include <windows.h>

#include <tchar.h>
#include <netcfgx.h>
#include <devguid.h>

#include <msi.h>
#include <msiquery.h>
#include "resource.h"
#include <shlobj.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

//
// uwrap has to come after the headers for ANY wrapped
// functions
//
#ifdef UNIWRAP
#include "uwrap.h"
#endif

//
// Custom actions.
//

#ifdef __cplusplus
extern "C" {
#endif

UINT __stdcall RDCSetupInit(MSIHANDLE hInstall);
UINT __stdcall RDCSetupPreInstall(MSIHANDLE hInstall);
UINT __stdcall RDCSetupPostInstall(MSIHANDLE hInstall);
UINT __stdcall RDCSetupCheckOsVer(MSIHANDLE hInstall);
UINT __stdcall RDCSetupCheckTcpIp(MSIHANDLE hInstall);
UINT __stdcall RDCSetupBackupRegistry(IN MSIHANDLE hInstall);
UINT __stdcall RDCSetupRestoreRegistry(IN MSIHANDLE hInstall);
UINT __stdcall RDCSetupResetShortCut(MSIHANDLE hInstall);

#ifdef __cplusplus
}
#endif


#define SIZECHAR(x) sizeof(x)/sizeof(TCHAR)



//
// Helper functions.
//

HRESULT CheckNt5TcpIpInstalled();
BOOL    IsProductInstalled(MSIHANDLE hInstall);
BOOL    CheckComctl32Version();
UINT    RDCSetupModifyDir(MSIHANDLE hInstall);
BOOL    RDCSetupRunMigration(MSIHANDLE hInstall);

#if DBG
    #define TRC_ERROR        _T("ERROR: ")
    #define TRC_INFO         _T("INFO: ")
    #define TRC_SYSTEM_ERROR _T("System Error: ")
    #define TRC_WARN         _T("WARNING: ")
    #define TRC_DEBUG TRC_DEBUG_FUNC
    void TRC_DBG_SYSTEM_ERROR();
    void TRC_DEBUG_FUNC(TCHAR *szErrorLevel, TCHAR *szStr, ...);
#else // DBG
    #define TRC_ERROR _T("")
    #define TRC_INFO _T("")
    #define TRC_SYSTEM_ERROR _T("")
    #define TRC_WARNING _T("")
    #define TRC_DEBUG
    #define TRC_DBG_SYSTEM_ERROR()
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\setup\msi\staticbins\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1998 - 1998

Module Name:

    makefile.inc.

!ENDIF

!IF 0
NOTE: It would be nice to just use a SOURCES MISCFILES
      to copy the files but unfortunately on checked build
      binplace would fail because setup.exe doesn't have debug
      symbols.
!ENDIF

SRC_STATIC_FILES = \
        setup.exe      \
        setup.ini      \
        instmsia.exe   \
        instmsiw.exe   \
        
static_files: $(SRC_STATIC_FILES)
#        if not exist $(_NTTREE) md $(_NTTREE)
        -for %i in ($**) do binplace -:DEST retail %i
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\setup\msi\custom\custom.cpp ===
//
// Module:    custom.cpp
//
// Purpose:   TsClient MSI custom action code
//
// Copyright(C) Microsoft Corporation 1999-2000
//
// Author: nadima
//
//

#include <custom.h>
#include <stdio.h>
#include <reglic.h>
#include "setuplib.h"

// Unicode wrapper

#include "wraputl.h"

#define TERMINAL_SERVER_CLIENT_REGKEY        _T("Software\\Microsoft\\Terminal Server Client")
#define TERMINAL_SERVER_CLIENT_BACKUP_REGKEY _T("Software\\Microsoft\\Terminal Server Client (Backup)")
#define LOGFILE_STR                          _T("MsiLogFile")

// MSI Folder Names

#define SYSTEM32_IDENTIFIER             _T("SystemFolder")
#define PROGRAMMENUFOLDER_INDENTIFIER	_T("ProgramMenuFolder")
#define ACCESSORIES_IDENTIFIER          _T("AccessoriesMenuFolder")
#define COMMUNICATIONS_IDENTIFIER       _T("CommunicationsMenuFolder")
#define INSTALLATION_IDENTIFIER         _T("INSTALLDIR")

// MSI Properties

#define ALLUSERS                        _T("ALLUSERS")

// Assumed max length of shortcut file name.

#define MAX_LNK_FILE_NAME_LEN			50    	

// ERROR_SUCCESS will let MSI continue with the default value.
// ERROR_INSTALL_FAILURE will block installation.

#define NONCRITICAL_ERROR_RETURN		ERROR_SUCCESS				

// Require comctl32.dll version 4.70 and above

#define MIN_COMCTL32_VERSION            MAKELONG(70,4)

HINSTANCE g_hInstance = (HINSTANCE) NULL;
HANDLE g_hLogFile = INVALID_HANDLE_VALUE;

#ifdef UNIWRAP
//It's ok to have a global unicode wrapper
//class. All it does is sets up the g_bRunningOnNT
//flag so it can be shared by multiple instances
//also it is only used from DllMain so there
//are no problems with re-entrancy
CUnicodeWrapper g_uwrp;
#endif

void    RestoreRegAcl(VOID);

//
// DllMain entry point
//
BOOL WINAPI DllMain(HANDLE hModule, DWORD  ul_reason_for_call,
                    LPVOID lpReserved)
{
    if (NULL == g_hInstance)
    {
        g_hInstance = (HINSTANCE)hModule;
    }

    switch (ul_reason_for_call)
    {
        case DLL_PROCESS_ATTACH:
            {
                //
                // Open the tsclient registry key to get the log file name
                //
                LONG status;
                HKEY hKey;
                TCHAR buffer[MAX_PATH];
                DWORD bufLen;
                memset(buffer, 0, sizeof(buffer));
                bufLen = sizeof(buffer); //size in bytes needed

                #ifdef UNIWRAP
                //UNICODE Wrapper intialization has to happen first,
                //before anything ELSE. Even DC_BEGIN_FN, which does tracing
                g_uwrp.InitializeWrappers();
                #endif

                status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      TERMINAL_SERVER_CLIENT_REGKEY,
                                      0, KEY_ALL_ACCESS, &hKey);
            
                if(ERROR_SUCCESS == status)
                {

                    //
                    // Query the tsclient optional logfile path
                    //
                    status = RegQueryValueEx(hKey, LOGFILE_STR,
                                    NULL, NULL, (BYTE *)buffer, &bufLen);
                    if(ERROR_SUCCESS == status)
                    {
                         g_hLogFile = CreateFile(buffer,
                                                 GENERIC_READ | GENERIC_WRITE,
                                                 0,
                                                 NULL,
                                                 OPEN_ALWAYS,
                                                 FILE_ATTRIBUTE_NORMAL,
                                                 NULL);
                         if(g_hLogFile != INVALID_HANDLE_VALUE)
                         {
                             //Always append to the end of the log file
                             SetFilePointer(g_hLogFile,
                                            0,
                                            0,
                                            FILE_END);
                         }
                         else
                         {
                             DBGMSG((_T("CreateFile for log file failed %d %d"),
                                     g_hLogFile, GetLastError()));
                         }
                    }
                    else
                    {
                        DBGMSG((_T("RegQueryValueEx for log file failed %d %d"),
                                status, GetLastError()));
                    }
                    RegCloseKey(hKey);
                }
                if(g_hLogFile != INVALID_HANDLE_VALUE)
                {
                    DBGMSG((_T("Log file opened by new process attach")));
                    DBGMSG((_T("-------------------------------------")));
                }
                DBGMSG((_T("custom.dll:Dllmain PROCESS_ATTACH")));
            }
            break;
        case DLL_THREAD_ATTACH:
            {
                DBGMSG((_T("custom.dll:Dllmain THREAD ATTACH")));
            }
            break;
        case DLL_THREAD_DETACH:
            {
            }
            break;
        case DLL_PROCESS_DETACH:
            {
                DBGMSG((_T("custom.dll:Dllmain THREAD DETACH. Closing log file")));
                CloseHandle(g_hLogFile);
                g_hLogFile = INVALID_HANDLE_VALUE;
            }
            break;
    }

    DBGMSG(((_T("In custom.dll DllMain. Reason: %d")), ul_reason_for_call));
    

    return TRUE;
}

//
// Check if should be silent to UI
//
// Returns TRUE if it is OK to display UI
BOOL AllowDisplayUI(MSIHANDLE hInstall)
{
    UINT status;
    TCHAR szResult[3];
    DWORD cchResult = 3;
    BOOL fAllowDisplayUI = FALSE;
    
    DBGMSG((_T("Entering: AllowDisplayUI")));

    status = MsiGetProperty(hInstall, _T("UILevel"), szResult, &cchResult);
    if (ERROR_SUCCESS == status)
    {
        DBGMSG((_T("AllowDisplayUI: MsiGetProperty for UILevel succeeded, got %s"),
                szResult));
        if (szResult[0] != TEXT('2'))
        {
            fAllowDisplayUI = TRUE;
        }
    }
    else
    {
        DBGMSG((_T("AllowDisplayUI: MsiGetProperty for UILevel FAILED, Status: 0x%x"),
                status));
    }

    DBGMSG((_T("Leaving: AllowDisplayUI ret:%d"), fAllowDisplayUI));
    return fAllowDisplayUI;
}

/**PROC+************************************************************/
/* Name:      RDCSetupInit                                         */
/*                                                                 */
/* Type:      Custom Action                                        */
/*                                                                 */
/* Purpose:   Do any initialization for the setup here.            */
/*                                                                 */
/* Returns:   Refer to MSI help.                                   */
/*                                                                 */
/* Params:    Refer to MSI help.                                   */
/*                                                                 */
/**PROC-************************************************************/

UINT __stdcall RDCSetupInit(MSIHANDLE hInstall)
{
    DBGMSG((_T("Entering: RDCSetupInit")));
    DBGMSG((_T("Leaving : RDCSetupInit")));
    return ERROR_SUCCESS;
}

/**PROC+************************************************************/
/* Name:      RDCSetupCheckOsVer                                   */
/*                                                                 */
/* Type:      Custom Action                                        */
/*                                                                 */
/* Purpose:   Block install on certain OS's                        */
/*                                                                 */
/* Returns:   Refer to MSI help.                                   */
/*                                                                 */
/* Params:    Refer to MSI help.                                   */
/*                                                                 */
/**PROC-************************************************************/
UINT __stdcall RDCSetupCheckOsVer(MSIHANDLE hInstall)
{
    DBGMSG((_T("Entering: RDCSetupCheckOsVer")));

    OSVERSIONINFO osVer;
    memset(&osVer, 0x0, sizeof(OSVERSIONINFO));
    osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(0 == GetVersionEx(&osVer))
    {
        return ERROR_SUCCESS;
    }
    else
    {
        DBGMSG((_T("RDCSetupCheckOsVer. OS version OK to install")));

        DBGMSG((_T("RDCSetupCheckOsVer - now check comctl32 version")));
        if(!CheckComctl32Version())
        {
            DBGMSG((_T("RDCSetupCheckOsVer. comctl32.dll check failed. Block on this os")));
            TCHAR szBlockOnPlatform[MAX_PATH];
            TCHAR szError[MAX_PATH];
            LoadString(g_hInstance, IDS_BLOCKCOMCTL32,
                       szBlockOnPlatform,SIZECHAR(szBlockOnPlatform));
            LoadString(g_hInstance, IDS_ERROR,
                       szError, SIZECHAR(szError));
            if (AllowDisplayUI(hInstall))
            {
                MessageBox(NULL, szBlockOnPlatform, szError, MB_OK|MB_ICONSTOP);
            }
            else
            {
                DBGMSG((_T("AllowDisplayUI returned False, not displaying msg box!")));
            }
            //Return an error to make msi abort the install.
            return ERROR_INVALID_FUNCTION;
        }
        else
        {
            DBGMSG((_T("RDCSetupCheckOsVer - passed all tests. OK")));
            return ERROR_SUCCESS;
        }
    }

    DBGMSG((_T("Leaving : RDCSetupCheckOsVer")));
}


/**PROC+************************************************************/
/* Name:      RDCSetupCheckTcpIp                                   */
/*                                                                 */
/* Type:      Custom Action                                        */
/*                                                                 */
/* Purpose:   Check if TCP/IP is installed in the machine.         */
/*                                                                 */
/* Returns:   Refer to MSI help.                                   */
/*                                                                 */
/* Params:    Refer to MSI help.                                   */
/*                                                                 */
/**PROC-************************************************************/

UINT __stdcall RDCSetupCheckTcpIp(MSIHANDLE hInstall)
{
    DWORD dwVersion, dwWindowsMajorVersion;
    DWORD dwWindowsMinorVersion, dwBuild;
    HKEY hKey = NULL;
    LONG lRet = 0;
    TCHAR lpTcpMsg[MAX_PATH] = _T(""), szError[MAX_PATH] = _T("");
    OSVERSIONINFO osVer;

    DBGMSG((_T("Entering: RDCSetupCheckTcpIp")));

    memset(&osVer, 0x0, sizeof(OSVERSIONINFO));
    osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(0 == GetVersionEx(&osVer))
    {
        return ERROR_SUCCESS;
    }

    //Now search the appropriate registry key.
    LoadString(g_hInstance, IDS_ERR_TCP, lpTcpMsg,SIZECHAR(lpTcpMsg));
    LoadString(g_hInstance, IDS_WARNING, szError, SIZECHAR(szError));
    if(VER_PLATFORM_WIN32_WINDOWS == osVer.dwPlatformId )
    {
        //
        // Win95 check for TCP/IP
        //
        lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            (_T("Enum\\Network\\MSTCP")),
                            0, KEY_READ, &hKey);
        if(ERROR_SUCCESS !=  lRet)
        {
            if(hKey)
            {
                RegCloseKey(hKey);
            }
            if (AllowDisplayUI(hInstall))
            {
                MessageBox(NULL, lpTcpMsg, szError, MB_OK|MB_ICONWARNING);
            }
            else
            {
                DBGMSG((_T("AllowDisplayUI returned false, not displaying TCP/IP warning")));
            }

            return ERROR_SUCCESS;
        }
    }
    else if((VER_PLATFORM_WIN32_NT == osVer.dwPlatformId) &&
            (osVer.dwMajorVersion <= 4))
    {
        //
        // NT4 and below check for TCP/IP
        //
        lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            (_T("SYSTEM\\CurrentControlSet\\Services\\Tcpip")),
                            0, KEY_READ, &hKey);
        if( ERROR_SUCCESS !=  lRet)
        {
            if(hKey)
            {
                RegCloseKey(hKey);
            }
            if (AllowDisplayUI(hInstall))
            {
                MessageBox(NULL, lpTcpMsg, szError, MB_OK|MB_ICONWARNING);
            }
            else
            {
                DBGMSG((_T("AllowDisplayUI returned false, not displaying TCP/IP warning")));
            }
            return ERROR_SUCCESS;
        }
    }
    else if((VER_PLATFORM_WIN32_NT == osVer.dwPlatformId) &&
            (osVer.dwMajorVersion >= 5))
    {
        //
        // NT5+ check for TCP/IP
        //
        HRESULT hr = CheckNt5TcpIpInstalled();

        if(S_FALSE == hr)
        {
            if (AllowDisplayUI(hInstall))
            {
                MessageBox(NULL, lpTcpMsg, szError, MB_OK|MB_ICONWARNING);
            }
            else
            {
                DBGMSG((_T("AllowDisplayUI returned false, not displaying TCP/IP warning")));
            }
            
            if(hKey)
            {
                RegCloseKey(hKey);
            }
            return ERROR_SUCCESS;
        }
    }

    if(hKey)
    {
        RegCloseKey(hKey);
    }

    DBGMSG((_T("Leaving: RDCSetupCheckTcpIp")));

    return ERROR_SUCCESS;
}

/**PROC+************************************************************/
/* Name:      CheckNt5TcpIpInstalled                               */
/*                                                                 */
/* Purpose:   Find if TCP/IP is installed and running.             */
/*            This function should be called only NT 5 or greater. */
/*                                                                 */
/* Returns:   S_OK if TCP/IP is installed and running              */
/*            S_FALSE if TCP/IP is not installed or running        */
/*            E_FAIL if a failure occurs.                          */
/*                                                                 */
/* Params:    None                                                 */
/*                                                                 */
/**PROC-************************************************************/
HRESULT CheckNt5TcpIpInstalled()
{
    INetCfg * pnetCfg = NULL;
    INetCfgClass * pNetCfgClass = NULL;
    INetCfgComponent * pNetCfgComponentprot = NULL;
    DWORD dwCharacteristics;
    ULONG count = 0;
    HRESULT hResult;
    WCHAR wsz [2*MAX_PATH] = L"";
    BOOL bInit = FALSE;
    DBGMSG((_T("Entering: CheckNt5TcpIpInstalled")));
    hResult = CoInitialize(NULL);
    if(FAILED(hResult))
    {
        DBGMSG( (_T("CoInitialize() failed.")));
        goto Cleanup;
    }
    else
    {
        bInit = TRUE;
    }

    hResult = CoCreateInstance(CLSID_CNetCfg, NULL, CLSCTX_SERVER,
                               IID_INetCfg, (LPVOID *)&pnetCfg);
    if((NULL == pnetCfg) || FAILED(hResult))
    {
        DBGMSG( (_T("CoCreateInstance() failed.")));
        goto Cleanup;
    }

    hResult = pnetCfg->Initialize(NULL);

    if(FAILED(hResult))
    {
        DBGMSG( (_T("pnetCfg->Initialize() failed.")));
        goto Cleanup;
    }

    hResult = pnetCfg->QueryNetCfgClass(&GUID_DEVCLASS_NETTRANS,
                                        IID_INetCfgClass,
                                        (void **)&pNetCfgClass);
    if(FAILED(hResult))
    {
        DBGMSG( (_T("QueryNetCfgClass() failed.")));
        goto Cleanup;
    }

#ifdef UNICODE
    lstrcpy(wsz, NETCFG_TRANS_CID_MS_TCPIP);
#else  //UNICODE
    if (0 == MultiByteToWideChar(CP_ACP, 0,
                                 (LPCSTR)NETCFG_TRANS_CID_MS_TCPIP,
                                 -1, wsz, sizeof(wsz)/sizeof(WCHAR)))
    {
        DBGMSG( (_T("MultiByteToWideChar() failed.")));
        hResult = E_FAIL;
        goto Cleanup;
    }
#endif //UNICODE

    hResult = pNetCfgClass->FindComponent(wsz,
                                          &pNetCfgComponentprot);

    if(hResult == S_FALSE)
    {
        DBGMSG( (_T("FindComponent() failed.")));
        goto Cleanup;
    }

Cleanup:

    if(bInit)
    {
        CoUninitialize();
    }

    if(pNetCfgComponentprot)
    {
        pNetCfgComponentprot->Release();
        pNetCfgComponentprot = NULL;
    }

    if(pNetCfgClass)
    {
        pNetCfgClass->Release();
        pNetCfgClass = NULL;
    }

    if(pnetCfg != NULL)
    {
        pnetCfg->Uninitialize();
        pnetCfg->Release();
        pnetCfg = NULL;
    }

    DBGMSG((_T("Leaving: IsTCPIPInstalled")));
    return hResult;
}

/**PROC+************************************************************/
/* Name:      RDCSetupPreInstall                                   */
/*                                                                 */
/* Type:      Custom Action                                        */
/*                                                                 */
/* Purpose:   Does cleanup work during install.                    */
/*                                                                 */
/* Returns:   Refer to MSI help.                                   */
/*                                                                 */
/* Params:    Refer to MSI help.                                   */
/*                                                                 */
/**PROC-************************************************************/

UINT __stdcall RDCSetupPreInstall(MSIHANDLE hInstall)
{
    BOOL fInstalling = FALSE;
    UINT retVal = 0;

    DBGMSG((_T("Entering: RDCSetupPreInstall")));

    //Figure out if we're installing or removing
    ASSERT(hInstall);

    DBGMSG((_T("RDCSetupPreInstall: Modifying dirs")));
    retVal = RDCSetupModifyDir(hInstall);
    DBGMSG((_T("RDCSetupPreInstall: Modifying dirs. DONE: %d"),
            retVal));

    //
    // This is pre-install if the product
    // is not installed then we are installing
    //
    fInstalling = !IsProductInstalled(hInstall);
    if(fInstalling)
    {
        DBGMSG((_T("RDCSetupPreInstall: We're installing")));
        TCHAR szProgmanPath[MAX_PATH];
        TCHAR szOldProgmanPath[MAX_PATH];
        DBGMSG((_T("RDCSetupPreInstall: Delete desktop shortcuts. START")));
        DeleteTSCDesktopShortcuts(); 
        DBGMSG((_T("RDCSetupPreInstall: Delete desktop shortcuts. DONE")));

        //Acme uninstall
        LoadString(g_hInstance, IDS_PROGMAN_GROUP, szProgmanPath,
                   sizeof(szProgmanPath) / sizeof(TCHAR));

        DBGMSG((_T("RDCSetupPreInstall: DeleteTSCFromStartMenu: %s. START"),
                szProgmanPath));
        DeleteTSCFromStartMenu(szProgmanPath);
        DBGMSG((_T("RDCSetupPreInstall: DeleteTSCFromStartMenu: %s. DONE"),
                szProgmanPath));
    
        LoadString(g_hInstance, IDS_OLD_NAME, szOldProgmanPath,
                   sizeof(szOldProgmanPath) / sizeof(TCHAR));
        DBGMSG((_T("RDCSetupPreInstall: DeleteTSCFromStartMenu: %s. START"),
                szOldProgmanPath));
        DeleteTSCFromStartMenu(szOldProgmanPath);
        DBGMSG((_T("RDCSetupPreInstall: DeleteTSCFromStartMenu: %s. DONE"),
                szOldProgmanPath));
        
        DBGMSG((_T("RDCSetupPreInstall: Uninstall ACME program files. START")));
        DeleteTSCProgramFiles();
        DBGMSG((_T("RDCSetupPreInstall: Uninstall ACME program files. DONE")));

        DBGMSG((_T("RDCSetupPreInstall: Uninstall TSCLIENT registry keys. START")));
        DeleteTSCRegKeys();
        DBGMSG((_T("RDCSetupPreInstall: Uninstall TSCLIENT registry keys. DONE")));
    }
    else
    {
        if(MsiGetMode(hInstall, MSIRUNMODE_MAINTENANCE))
        {
            DBGMSG((_T("MsiGetMode: MSIRUNMODE_MAINTENANCE returned TRUE.")));
            DBGMSG((_T("RDCSetupPreInstall: We're in maintenance mode")));
        }
        else
        {
            DBGMSG((_T("MsiGetMode: MSIRUNMODE_MAINTENANCE returned FALSE.")));
            DBGMSG((_T("RDCSetupPreInstall: We're not installing (removing)")));
        }
    }

    DBGMSG((_T("Leaving: RDCSetupPreInstall")));

    return ERROR_SUCCESS;
}


//
// Run migration 'mstsc /migrate'
//
// This will fail silenty if mstsc.exe is not present
//
BOOL RDCSetupRunMigration(MSIHANDLE hInstall)
{
    BOOL fRet = TRUE;
    PROCESS_INFORMATION pinfo;
    STARTUPINFO sinfo;
    TCHAR szMigratePathLaunch[MAX_PATH];
    TCHAR szInstallPath[MAX_PATH];
    TCHAR szMigrateCmdLine[] = _T("mstsc.exe /migrate");
    DWORD cchInstallPath = SIZECHAR(szInstallPath);
    UINT uiResult;
    HRESULT hr;


    // Get the path to the installation directory.

    uiResult = MsiGetTargetPath(
        hInstall, 
        INSTALLATION_IDENTIFIER, 
        szInstallPath,
        &cchInstallPath);
    
    if (uiResult != ERROR_SUCCESS) {
        DBGMSG((_T("Error: MsiGetTargetPath returned 0x%x."), uiResult));
        fRet = FALSE;
        goto Exit;
    }

    DBGMSG((_T("Path to installation directory is %s"), szInstallPath));

    // Concatenate the installation directory and the mstsc /migrate command
    // so that we can call CreateProcess.
    
    hr = StringCchPrintf(
    szMigratePathLaunch, 
    SIZECHAR(szMigratePathLaunch),
    _T("%s%s"),
    szInstallPath,
    _T("mstsc.exe"));

    if (FAILED(hr)) {
        DBGMSG((_T("Error: Failed to construct command line for CreateProcess. hr = 0x%x"), hr));
        goto Exit;
    }

    //
    //  Start registry and connection file migration
    //
	
    ZeroMemory(&sinfo, sizeof(sinfo));
    sinfo.cb = sizeof(sinfo);

    fRet = CreateProcess(szMigratePathLaunch,             // name of executable module
                        szMigrateCmdLine,                 // command line string
                        NULL,                             // SD
                        NULL,                             // SD
                        FALSE,                            // handle inheritance option
                        CREATE_NEW_PROCESS_GROUP,         // creation flags
                        NULL,                             // new environment block
                        NULL,                             // current directory name
                        &sinfo,                           // startup information
                        &pinfo);                          // process information
    if (fRet) {
        DBGMSG((_T("RDCSetupRunMigration: Started mstsc.exe /migrate")));
    }
    else {
        DBGMSG((_T("RDCSetupRunMigration: Failed to start mstsc.exe /migrate: %d"), GetLastError()));
    }

Exit:

    return fRet;
}

/**PROC+************************************************************/
/* Name:      RDCSetupPostInstall                                  */
/*                                                                 */
/* Type:      Custom Action                                        */
/*                                                                 */
/* Purpose:   Do work after MSI has completed                      */
/*            could be after an uninstall completes, get MSI prop  */
/*            to determine that                                    */
/*                                                                 */
/* Returns:   Refer to MSI help.                                   */
/*                                                                 */
/* Params:    Refer to MSI help.                                   */
/*                                                                 */
/**PROC-************************************************************/

UINT __stdcall RDCSetupPostInstall(MSIHANDLE hInstall)
{
    BOOL fInstalling = FALSE;
    DBGMSG((_T("Entering: RDCSetupPostInstall")));

    ASSERT(hInstall);
    //
    // This is post install if the product is installed
    // then we are 'installing' otherwise we were
    // removing.
    //
    fInstalling = IsProductInstalled(hInstall);

    if(fInstalling)
    {
        DBGMSG((_T("RDCSetupPostInstall: We're installing")));
        //Add the MsLicensingReg key and ACL it
        //This will only happen on NT (it's not needed on 9x)
        //and will not (cannot) work if you're not admin
        DBGMSG((_T("Setting up MSLicensing key...")));
        if(SetupMSLicensingKey())
        {
            DBGMSG((_T("Setting up MSLicensing key...SUCCEEDED")));
        }
        else
        {
            DBGMSG((_T("Setting up MSLicensing key...FAILED")));
        }


        //
        // Migrate user settings (will only run if MSTSC.EXE was successfully
        // installed).
        //
        if (RDCSetupRunMigration(hInstall))
        {
            DBGMSG((_T("RDCSetupRunMigration...SUCCEEDED")));
        }
        else
        {
            DBGMSG((_T("RDCSetupRunMigration...FAILED")));
        }
    }
    else
    {
        RestoreRegAcl();

        DBGMSG((_T("RDCSetupPostInstall: We're not installing (removing)")));
        //We're uninstalling
        //Delete the bitmap cache folder
    }


    DBGMSG((_T("Leaving: RDCSetupPostInstall")));
    return ERROR_SUCCESS;
}

//Return true if we're installing
//False if we're uninstalling
BOOL IsProductInstalled(MSIHANDLE hInstall)
{
    ASSERT(hInstall);
    TCHAR szProdCode[MAX_PATH];
    DWORD dwCharCount = sizeof(szProdCode)/sizeof(TCHAR);
    UINT status;
    status = MsiGetProperty(hInstall,
                            _T("ProductCode"),
                            szProdCode,
                            &dwCharCount);
    if(ERROR_SUCCESS == status)
    {
        DBGMSG((_T("MsiGetProperty returned product code %s"),
                szProdCode));
        INSTALLSTATE insState = MsiQueryProductState( szProdCode );
        DBGMSG((_T("MsiQueryProductState returned: %d"),
                (DWORD)insState));
        if(INSTALLSTATE_DEFAULT == insState)
        {
            DBGMSG((_T("Product installed. IsProductInstalled return TRUE")));
            return TRUE;
        }
        else
        {
            DBGMSG((_T("Product not installed. IsProductInstalled return FALSE")));
            return FALSE;
        }
    }
    else
    {
        DBGMSG((_T("MsiGetProperty for ProductCode failed: %d %d"),
                status, GetLastError()));
        return FALSE;
    }
}

//
// Check that comctl32.dll has a sufficiently
// high version number (4.70).
//
// Return - TRUE - version ok, allow install
//          FALSE - version bad (or fail) block install
//
BOOL CheckComctl32Version()
{
    DWORD dwFileVerInfoSize;
    PBYTE pVerInfo = NULL;
    VS_FIXEDFILEINFO* pFixedFileInfo = NULL;
    BOOL bRetVal = FALSE;
    UINT len = 0;
    DBGMSG((_T("Entering: CheckComctl32Version")));

    //
    // USE Ansi versions of GetFileVersionInfo calls
    // because we don't have unicode wrappers for them
    //
    dwFileVerInfoSize = GetFileVersionInfoSizeA("comctl32.dll",
                                                NULL);
    if(!dwFileVerInfoSize)
    {
        DBGMSG((_T("GetFileVersionInfoSize for comctl32.dll failed: %d %d"),
                dwFileVerInfoSize, GetLastError()));
    }

    pVerInfo = (PBYTE) LocalAlloc(LPTR, dwFileVerInfoSize);
    if(pVerInfo)
    {
        if(GetFileVersionInfoA("comctl32.dll",
                               NULL,
                               dwFileVerInfoSize,
                               (LPVOID)pVerInfo ))
        {
            DBGMSG((_T("GetFileVersionInfo: succeeded")));
            pFixedFileInfo = NULL;
            if(VerQueryValueA(pVerInfo,
                            "\\", //get root version info block
                            (LPVOID*)&pFixedFileInfo,
                            &len ) && len)
            {
                DBGMSG((_T("comctl32.dll filever is 0x%x-0x%x"),
                        pFixedFileInfo->dwFileVersionMS,
                        pFixedFileInfo->dwFileVersionLS));

                if(pFixedFileInfo->dwFileVersionMS >= MIN_COMCTL32_VERSION)
                {
                    DBGMSG((_T("Sufficently new comctl32.dll found. Allow install")))
                    bRetVal = TRUE;
                }
                else
                {
                    DBGMSG((_T("comctl32.dll too old block install")))
                    bRetVal = FALSE;
                }
            }
            else
            {
                DBGMSG((_T("VerQueryValue: failed len:%d gle:%d"),
                        len,
                        GetLastError()));
                bRetVal =  FALSE;
                goto BAIL_OUT;
            }
        }
        else
        {
            DBGMSG((_T("GetFileVersionInfo: failed %d"),
                    GetLastError()));
            bRetVal = FALSE;
            goto BAIL_OUT;
        }
    }
    else
    {
        DBGMSG((_T("LocalAlloc for %d bytes of ver info failed"),
                dwFileVerInfoSize));
        bRetVal = FALSE;
        goto BAIL_OUT;
    }

BAIL_OUT:

    DBGMSG((_T("Leaving: CheckComctl32Version")));
    if(pVerInfo)
    {
        LocalFree(pVerInfo);
        pVerInfo = NULL;
    }
    return bRetVal;    
}

UINT RDCSetupModifyDir(MSIHANDLE hInstall)
{
    UINT uReturn;
    int iAccessories;
    int iCommunications;
    TCHAR szAccessories[MAX_PATH];
    TCHAR szCommunications[MAX_PATH];
    TCHAR szProgram[MAX_PATH];
    TCHAR szFullAccessories[MAX_PATH];
    TCHAR szFullCommunications[MAX_PATH];
    OSVERSIONINFO osVer;
    DWORD dwSize;

    DBGMSG((_T("Entering: RDCSetupModifyDir")));

    //
    // OS Version
    //
    ZeroMemory( &osVer, sizeof( osVer ) );
    osVer.dwOSVersionInfoSize = sizeof( osVer );

    if (!GetVersionEx(&osVer))
    {
        DBGMSG( (TEXT("RDCSetupModifyDir: GetVersionEx failed.")) );
        return(NONCRITICAL_ERROR_RETURN);
    }

    if (osVer.dwMajorVersion >= 5)
    {
        DBGMSG((TEXT("RDCSetupModifyDir: Ver >= 5. No need to apply the altertnate path.")));
        return(ERROR_SUCCESS);
    }

    //
    // Get ProgramMenuFolder
    //
    dwSize = sizeof( szProgram ) / sizeof( TCHAR );
    uReturn = MsiGetProperty(hInstall,PROGRAMMENUFOLDER_INDENTIFIER,
                             szProgram,&dwSize);
    if ( ERROR_SUCCESS != uReturn )
    {
        DBGMSG((TEXT("RDCSetupModifyDir: MsiGetProperty failed. %d"),
                uReturn));
        return NONCRITICAL_ERROR_RETURN;
    }

    //
    // Load String
    //
    iAccessories = LoadString(g_hInstance, IDS_ACCESSORIES, szAccessories,
                              sizeof(szAccessories)/sizeof(TCHAR)-1);
    if (!iAccessories)
    {
        DBGMSG((TEXT("RDCSetupModifyDir: IDS_ACCESSORIES failed.")));
        return NONCRITICAL_ERROR_RETURN;
    }

    iCommunications = LoadString(g_hInstance, IDS_COMMUNICATIONS, szCommunications,
                                 sizeof(szCommunications)/sizeof(TCHAR)-1);
    if (!iCommunications)
    {
        DBGMSG((TEXT("RDCSetupModifyDir: IDS_COMMUNICATIONS failed.")));
        return NONCRITICAL_ERROR_RETURN;
    }

    //
    // Check Length
    //                                   
    if (MAX_PATH < lstrlen( szProgram ) +
        iAccessories + 1 + iCommunications + 1 + MAX_LNK_FILE_NAME_LEN + 1 )
    {
        DBGMSG((TEXT( "RDCSetupModifyDir: Too long path." )));
        return NONCRITICAL_ERROR_RETURN;
    }

    //
    // Make Full Path
    //
    memset(szFullAccessories, 0, sizeof(szFullAccessories));
    memset(szFullCommunications, 0, sizeof(szFullCommunications));
    //
    // Use lstrcat as that has unicode wrappers
    //
    lstrcat(szFullAccessories, szProgram);
    lstrcat(szFullAccessories, szAccessories);
    lstrcat(szFullAccessories, _T("\\"));

    lstrcat(szFullCommunications, szFullAccessories);
    lstrcat(szFullCommunications, szCommunications);
    lstrcat(szFullCommunications, _T("\\"));

    //
    // Set Directory
    //
    uReturn = MsiSetTargetPath(hInstall,
                               ACCESSORIES_IDENTIFIER,
                               szFullAccessories);
    if (ERROR_SUCCESS != uReturn)
    {
        DBGMSG ((TEXT("RDCSetupModifyDir: SetTargetPathACCESSORIES_IDENTIFIER failed.")));
        return NONCRITICAL_ERROR_RETURN;
    }

    uReturn = MsiSetTargetPath(hInstall,
                               COMMUNICATIONS_IDENTIFIER,
                               szFullCommunications);
    if (ERROR_SUCCESS != uReturn)
    {
        DBGMSG( (TEXT( "RDCSetupModifyDir: COMMUNICATIONS_IDENTIFIER failed.")));
        return NONCRITICAL_ERROR_RETURN;
    }

    DBGMSG((_T("Leaving: RDCSetupModifyDir")));
    return ERROR_SUCCESS;
}

//*****************************************************************************
//
// CopyRegistryValues
//
// Copies all the values from a registry key to the other.
//
//*****************************************************************************

HRESULT
__stdcall
CopyRegistryValues(
    IN HKEY hSourceKey, 
    IN HKEY hTargetKey
)
{
    DWORD dwStatus = 0, cValues, cchValueName, cbData, dwType;
    BYTE rgbData[MAX_PATH];
    TCHAR szValueName[MAX_PATH];
    LONG lResult = 0;
    HRESULT hr = E_FAIL;

    // Determine how many values are in the registry key.

    lResult = RegQueryInfoKey(
        hSourceKey, 
        NULL, 
        NULL, 
        NULL, 
        NULL,
        NULL, 
        NULL, 
        &cValues, 
        NULL, 
        NULL, 
        NULL, 
        NULL);

    if (lResult != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(lResult);
        DBGMSG((_T("RegQueryInfoKey failed getting the number of values in the source. hr = 0x%x"), hr));
        goto Exit;
    }
    
    // Loop through all of the values and copy them from the source key into
    // the target key.

    for (DWORD dwIndex = 0; dwIndex < cValues; dwIndex++) {
        cchValueName = SIZECHAR(szValueName);
        cbData = sizeof(rgbData);

        lResult = RegEnumValue(
            hSourceKey, 
            dwIndex, 
            szValueName, 
            &cchValueName,
            NULL, 
            &dwType, 
            rgbData, 
            &cbData);

        if (lResult != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(lResult);
            DBGMSG((_T("RegEnumValue failed while obtaining source value. hr = 0x%x"), hr));
            goto Exit;
        }

        lResult = RegSetValueEx(
            hTargetKey, 
            szValueName, 
            NULL, 
            dwType, 
            rgbData, 
            cbData);

        if (lResult != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(lResult);
            DBGMSG((_T("RegSetValueEx failed while copying value into target. hr = 0x%x"), hr));
            goto Exit;
        }
    }

    hr = S_OK;

Exit:

    return hr;
}

//*****************************************************************************
//
// CopyRegistryKey
//
// Copies the source registry key into the target registry key completely.
//
//*****************************************************************************

HRESULT
__stdcall
CopyRegistryKey(
    IN HKEY hRootKey,
    IN TCHAR *szSourceKey, 
    IN TCHAR *szTargetKey
)
{
    HKEY hSourceKey = NULL, hTargetKey = NULL;
    LONG lResult;
    DWORD cchSubSize = MAX_PATH, i = 0, dwDisposition  = 0;
    TCHAR szSubKey[MAX_PATH];
    HRESULT hr = E_FAIL;

    // Open the source key.

    lResult = RegOpenKeyEx(
        hRootKey, 
        szSourceKey, 
        0, 
        KEY_READ, 
        &hSourceKey);

    if(lResult != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(lResult);
        DBGMSG((_T("Unable to open source registry key. hr = 0x%x"), hr));
        goto Exit;
    }

    // Create or open the target registry key.

    lResult = RegCreateKeyEx(
        hRootKey, 
        szTargetKey, 
        0, 
        NULL, 
        REG_OPTION_NON_VOLATILE, 
        KEY_ALL_ACCESS, 
        NULL, 
        &hTargetKey, 
        &dwDisposition);

    if (lResult != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(lResult);
        DBGMSG((_T("Unable to create or open target registry key. hr = 0x%x"), hr));
        goto Exit;
    }

    // Copy the values in the source key to the target key.

    hr = CopyRegistryValues(hSourceKey, hTargetKey);
    if (FAILED(hr)) {
        DBGMSG((_T("Unable to copy registry values from source to target. hr = 0x%x"), hr));
        goto Exit;
    }

    // Loop through the source's subkeys and copy each of these into the 
    // target key.
    
    while (ERROR_SUCCESS == RegEnumKey(
            hSourceKey, 
            i++, 
            szSubKey, 
            cchSubSize)) {
        
        TCHAR szNewSubKey[MAX_PATH] = _T("");
        TCHAR szOldSubKey[MAX_PATH] = _T("");

        hr = StringCchPrintf(szOldSubKey, SIZECHAR(szOldSubKey), _T("%s\\%s"), szSourceKey, szSubKey);
        if (FAILED(hr)) {
            DBGMSG((_T("StringCchPrintf failed when constructing source registry key string. hr = 0x%x"), hr));
            goto Exit;
        }

        StringCchPrintf(szNewSubKey, SIZECHAR(szNewSubKey), _T("%s\\%s"), szTargetKey, szSubKey);
        if (FAILED(hr)) {
            DBGMSG((_T("StringCchPrintf failed when constructing target registry key string. hr = 0x%x"), hr));
            goto Exit;
        }

        hr = CopyRegistryKey(hRootKey, szOldSubKey, szNewSubKey);
        if (FAILED(hr)) {
            DBGMSG((_T("Failed to copy source subkey into target. hr = 0x%x"), hr));
            goto Exit;
        }
    }

    hr = S_OK;
    
Exit:

    if (hTargetKey) {
        RegCloseKey(hTargetKey);
    }

    if (hSourceKey) {
        RegCloseKey(hSourceKey);
    }

    return hr;
}

//*****************************************************************************
//
// DeleteRegistryKey
//
// Deletes the registry key completely, including all subkeys. This is a bit 
// tricky to do because Win9x and WinNT have different semantics for 
// RegDeleteKey. From MSDN:
//
// Windows 95/98/Me: RegDeleteKey deletes all subkeys and values. 
// Windows NT/2000/XP: The subkey to be deleted must not have subkeys. 
//
// This function implements deletion for Windows NT and above only.
//
//*****************************************************************************

HRESULT
__stdcall
DeleteRegistryKey(
    IN HKEY hRootKey, 
    IN LPTSTR pszDeleteKey
) 
{ 
    DWORD   dwResult, cchSubKeyLength;
    TCHAR   szSubKey[MAX_PATH]; 
    HKEY    hDeleteKey = NULL;
    HRESULT hr = E_FAIL;

   // Open the key to delete so we can remove the subkeys.

   dwResult = RegOpenKeyEx(
       hRootKey,
       pszDeleteKey,
       0, 
       KEY_READ, 
       &hDeleteKey);

   if (dwResult != ERROR_SUCCESS) {
       hr = HRESULT_FROM_WIN32(dwResult);
       DBGMSG((_T("Error while opening deletion key. hr = 0x%x"), hr));
       goto Exit;
   }

   // Enumerate through each of the subkeys and delete them in the process.
   
   while (dwResult == ERROR_SUCCESS) {
        
       cchSubKeyLength = SIZECHAR(szSubKey);
       dwResult = RegEnumKeyEx(
           hDeleteKey,
           0,       // Always index zero.
           szSubKey,
           &cchSubKeyLength,
           NULL,
           NULL,
           NULL,
           NULL);

        if (dwResult == ERROR_NO_MORE_ITEMS) {
            // All of the subkeys have been deleted. So, just delete the 
            // deletion key.

            RegCloseKey(hDeleteKey);
            hDeleteKey = NULL;
            
            dwResult = RegDeleteKey(hRootKey, pszDeleteKey);
            hr = HRESULT_FROM_WIN32(dwResult);

            goto Exit;

        } else if (dwResult == ERROR_SUCCESS) {
            // There are more subkeys to delete, so delete the current one
            // recursively.

            dwResult = DeleteRegistryKey(hDeleteKey, szSubKey);
        } else {
            // Some other error happened, so report a problem.

            hr = HRESULT_FROM_WIN32(dwResult);
            DBGMSG((_T("Error while enumerating subkeys. hr = 0x%x"), hr));
            goto Exit;
        }
    }

Exit:

    if (hDeleteKey) {
        RegCloseKey(hDeleteKey);
    }

    return hr;
}

//*****************************************************************************
//
// RDCSetupBackupRegistry
//
// Copies the data in the Terminal Server Client registry key to a backup 
// registry key so that this data can be restored when the client is removed
// at a later stage. This function is only necessary on Windows XP and above
// since they have built in clients which may rely on these registry keys, and
// because these clients take over after an uninstall, we have to make sure 
// that they will work properly.
//
//*****************************************************************************

UINT 
__stdcall 
RDCSetupBackupRegistry(
    IN MSIHANDLE hInstall
)
{
    UINT uiResult;
    TCHAR szAllUsers[MAX_PATH];
    DWORD cchAllUsers = SIZECHAR(szAllUsers);
    HKEY hRootKey = HKEY_LOCAL_MACHINE;
    HRESULT hr = E_FAIL;

    DBGMSG((_T("Entering: RDCSetupBackupRegistry")));
    
    // Determine whether we will be using HKLM or HKCU. If it is a per user 
    // install use HKCU, otherwise, use HKLM.

    uiResult = MsiGetProperty(
        hInstall,
        ALLUSERS,
        szAllUsers,
        &cchAllUsers);

    if (uiResult != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBGMSG((_T("Unable to get ALLUSERS property. hr = 0x%x."), hr));
        goto Exit;
    }

    DBGMSG((_T("ALLUSERS = %s."), szAllUsers));
    
    // If ALLUSERS[0] == NULL, then we are doing a per-user install.
    
    if (szAllUsers[0] == NULL) {
        hRootKey = HKEY_CURRENT_USER;
    }
    // Copy the source registry key into the backup key.

    hr = CopyRegistryKey(
        hRootKey,
        TERMINAL_SERVER_CLIENT_REGKEY,
        TERMINAL_SERVER_CLIENT_BACKUP_REGKEY);

    if (FAILED(hr)) {
        DBGMSG((_T("Unable to backup registry key. hr = 0x%x."), hr));
        goto Exit;
    }

    hr = S_OK;

Exit:

    DBGMSG((_T("Leaving: RDCSetupBackupRegistry")));
    
    return ERROR_SUCCESS;
}

//*****************************************************************************
//
// RDCSetupRestoreRegistry
//
// Copies the data in the Terminal Server Client backup registry key back to 
// the original key. Any data in the original key is deleted and the key is
// restored to exactly how it appeared when the backup was done.
//
//*****************************************************************************

UINT 
__stdcall 
RDCSetupRestoreRegistry(
    IN MSIHANDLE hInstall
)
{
    LONG lResult;
    UINT uiResult;
    TCHAR szAllUsers[MAX_PATH];
    DWORD cchAllUsers = SIZECHAR(szAllUsers);
    HKEY hRootKey = HKEY_LOCAL_MACHINE;
    HRESULT hr = E_FAIL;

    DBGMSG((_T("Entering: RDCSetupRestoreRegistry")));
    
    // Determine whether we will be using HKLM or HKCU. If it is a per user 
    // install use HKCU, otherwise, use HKLM.

    uiResult = MsiGetProperty(
        hInstall,
        ALLUSERS,
        szAllUsers,
        &cchAllUsers);

    if (uiResult != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBGMSG((_T("Unable to get ALLUSERS property. hr = 0x%x."), hr));
        goto Exit;
    }

    DBGMSG((_T("ALLUSERS = %s."), szAllUsers));

    // If ALLUSERS[0] == NULL, then we are doing a per-user uninstall.
    
    if (szAllUsers[0] == NULL) {
        hRootKey = HKEY_CURRENT_USER;
    }
    
    // Restore the registry key from the backup key.

    hr = CopyRegistryKey(
        hRootKey,
        TERMINAL_SERVER_CLIENT_BACKUP_REGKEY,
        TERMINAL_SERVER_CLIENT_REGKEY);

    if (FAILED(hr)) {
        DBGMSG((_T("Unable to restore registry key. hr = 0x%x."), hr));
        goto Exit;
    }

    // Delete the restore source as we don't need it anymore.

    hr = DeleteRegistryKey(
        hRootKey, 
        TERMINAL_SERVER_CLIENT_BACKUP_REGKEY);
    
    if (FAILED(hr)) {
        DBGMSG((_T("Failed to delete backup registry key. hr = 0x%x"), hr));
        goto Exit;
    }

    hr = S_OK;

Exit:

    DBGMSG((_T("Leaving: RDCSetupRestoreRegistry")));
    
    return ERROR_SUCCESS;
}

//*****************************************************************************
//
// CreateLinkFile
//
// Creates a shortcut named lpszLinkFile that points to the target lpszPath 
// and contains the description given by lpszDescription.
//
//*****************************************************************************

HRESULT
__stdcall 
CreateLinkFile(
    IN LPTSTR lpszLinkFile, 
    IN LPCTSTR lpszPath,
    IN LPCTSTR lpszDescription
) 
{ 
    IShellLink* psl; 
    HRESULT hr = E_FAIL; 

    // Get a pointer to the IShellLink interface.
    
    hr = CoCreateInstance(
        CLSID_ShellLink, 
        NULL, 
        CLSCTX_INPROC_SERVER, 
        IID_IShellLink, 
        (LPVOID*) &psl); 

    if (SUCCEEDED(hr)) { 
        IPersistFile* ppf; 
 
        // Get a pointer to the IPersistFile interface. 
        hr = psl->QueryInterface(IID_IPersistFile, (void**) &ppf); 

        if (SUCCEEDED(hr)) { 

            // Set the path to the link target. 
            hr = psl->SetPath(lpszPath);

            if (SUCCEEDED(hr)) { 

                hr = psl->SetDescription(lpszDescription);

                if (SUCCEEDED(hr)) {

#ifndef UNICODE
                    WCHAR wsz[MAX_PATH]; 
                    int cch;
         
                    // Ensure that the string is Unicode. 
                    cch = MultiByteToWideChar(
                        CP_ACP, 0, 
                        lpszLinkFile, 
                        -1, 
                        wsz, 
                        MAX_PATH); 
    
                    if (cch > 0) {
                        // Load the shortcut. 
                        hr = ppf->Save(wsz, FALSE); 
#else 
                        // Load the shortcut. 
                        hr = ppf->Save(lpszLinkFile, FALSE); 
#endif

#ifndef UNICODE
                    }
#endif
                }
            }

            // Release the pointer to the IPersistFile interface. 
            ppf->Release(); 
            ppf = NULL;
        }

        // Release the pointer to the IShellLink interface. 
        psl->Release();
        psl = NULL;
    }

    return hr; 
}

//*****************************************************************************
//
// RDCSetupResetShortCut
//
// Reset the Remote Desktop Connection shortcut in the Communications submenu
// of the Start menu to point to the original Remote Desktop client.
//
//*****************************************************************************

UINT 
__stdcall 
RDCSetupResetShortCut(
    IN MSIHANDLE hInstall
)
{
    TCHAR szCommunicationsPath[MAX_PATH], 
          szSystem32Path[MAX_PATH],
          szRdcShortCutTitle[MAX_PATH],
          szRdcShortCutPath[MAX_PATH],
          szMstscExecutableName[MAX_PATH],
          szMstscPath[MAX_PATH],
          szDescription[MAX_PATH];
    DWORD cchCommunicationsPath = SIZECHAR(szCommunicationsPath),
          cchSystem32Path = SIZECHAR(szSystem32Path);
    UINT  uiResult;
    INT   iResult;
    HRESULT hr = E_FAIL;
    
    DBGMSG((_T("Entering: RDCSetupResetShortCut")));

    // Get the path to the Remote Desktop Connection shortcut.
    
    uiResult = MsiGetTargetPath(
        hInstall, 
        COMMUNICATIONS_IDENTIFIER, 
        szCommunicationsPath,
        &cchCommunicationsPath);
    
    if (uiResult != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(uiResult);
        DBGMSG((_T("Error: MsiGetTargetPath returned hr = 0x%x."), hr));
        goto Exit;
    }

    // Get the full path to the Remote Desktop shortcut.

    iResult = LoadString(
        g_hInstance, 
        IDS_RDC_SHORTCUT_FILE, 
        szRdcShortCutTitle, 
        SIZECHAR(szRdcShortCutTitle));

    if (iResult == 0) {
        DBGMSG((_T("Error: Resource IDS_RDC_SHORTCUT_FILE not found.")));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    hr = StringCchPrintf(
        szRdcShortCutPath, 
        SIZECHAR(szRdcShortCutPath),
        _T("%s%s"),
        szCommunicationsPath,
        szRdcShortCutTitle);

    if (FAILED(hr)) {
        DBGMSG((_T("Error: Failed to construct the RDC shortcut path. hr = 0x%x"), hr));
        goto Exit;
    }

    DBGMSG((_T("Path to RDC shortcut is %s"), szRdcShortCutPath));

    // Get the path to the system32 directory.

    uiResult = MsiGetTargetPath(
        hInstall, 
        SYSTEM32_IDENTIFIER, 
        szSystem32Path,
        &cchSystem32Path);
    
    if (uiResult != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(uiResult);
        DBGMSG((_T("Error: MsiGetTargetPath returned hr = 0x%x."), hr));
        goto Exit;
    }

    // Get the full path to the mstsc executable.

    iResult = LoadString(
        g_hInstance, 
        IDS_MSTSC_EXE_FILE, 
        szMstscExecutableName, 
        SIZECHAR(szMstscExecutableName));

    if (iResult == 0) {
        DBGMSG((_T("Error: Resource IDS_MSTSC_EXE_FILE not found.")));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    hr = StringCchPrintf(
        szMstscPath, 
        SIZECHAR(szMstscPath),
        _T("%s%s"),
        szSystem32Path,
        szMstscExecutableName);

    if (FAILED(hr)) {
        DBGMSG((_T("Error: Failed to construct mstsc executable path. hr = 0x%x"), hr));
        goto Exit;
    }

    DBGMSG((_T("Path to mstsc executable is %s"), szMstscPath));

    // Get the description text for the shortcut.

    iResult = LoadString(
        g_hInstance, 
        IDS_RDC_DESCRIPTION, 
        szDescription, 
        SIZECHAR(szDescription));

    if (iResult == 0) {
        DBGMSG((_T("Error: Resource IDS_RDC_DESCRIPTION not found.")));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // Create a shortcut that points back to the old remote desktop client 
    // in system32.

    hr = CreateLinkFile(
        szRdcShortCutPath, 
        szMstscPath,
        szDescription);

    if (FAILED(hr)) {
        DBGMSG((_T("Error: Failed to set link file target. hr = 0x%x"), hr));
        goto Exit;
    }

    hr = S_OK;

Exit:

    DBGMSG((_T("Leaving: RDCSetupResetShortCut")));

    return ERROR_SUCCESS; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\setup\msi\tools\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1998 - 1998

Module Name:

    makefile.inc.

!ENDIF

!IF 0
NOTE: It would be nice to just use a SOURCES MISCFILES
      to copy the files but unfortunately on checked build
      binplace would fail because setup.exe doesn't have debug
      symbols.
!ENDIF

SRC_STATIC_FILES = \
        wistream.vbs   \
        wiexport.vbs   \
        wiimport.vbs   \
        wifilver.vbs   \
        media.idt      \
        tscmsigen.cmd  \
        msiquery.exe   \
        
static_files: $(SRC_STATIC_FILES)
#        if not exist $(_NTTREE) md $(_NTTREE)
        -for %i in ($**) do binplace -e -:DEST TSClient\win32\* %i
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\setup\setuplib\common.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name :
    
    acme.cpp

Abstract:

    remove acme installed client files and acme registry keys
    
Author:

    JoyC 

Revision History:
--*/

#include "stdafx.h"

#define INITGUID
#include "oleguid.h"
#include "shlguid.h"

#define DUCATI_REG_PREFIX _T("SOFTWARE\\Microsoft\\")
#define DUCATI_SUBKEY _T("Terminal Server Client")
#define DUCATI_RDPDRKEY _T("Default\\AddIns\\RDPDR")

#define BITMAP_CACHE_FOLDER _T("Cache\\")
#define BITMAP_CACHE_LOCATION  _T("BitmapPersistCacheLocation")
#define ADDIN_NAME _T("Name")

//
//  Get the target path from a link file
//                         
BOOL GetLinkFileTarget(LPTSTR lpszLinkFile, LPTSTR lpszPath) 
{ 
    IShellLink* psl; 
    TCHAR szPath[MAX_PATH]; 
    WIN32_FIND_DATA wfd; 
    HRESULT hres; 
    BOOL rc = FALSE;
    int cch;

    *lpszPath = 0; // assume failure 
 
    // Get a pointer to the IShellLink interface.
	 hres = CoCreateInstance(CLSID_ShellLink, NULL, 
            CLSCTX_INPROC_SERVER, IID_IShellLink, (LPVOID *) &psl); 

    if (SUCCEEDED(hres)) { 
        IPersistFile* ppf; 
 
        // Get a pointer to the IPersistFile interface. 
        hres = psl->QueryInterface(IID_IPersistFile, (void**)&ppf); 

        if (SUCCEEDED(hres)) { 
#ifndef UNICODE
            WCHAR wsz[MAX_PATH]; 
 
            // Ensure that the string is Unicode. 
            cch = MultiByteToWideChar(CP_ACP, 0, lpszLinkFile, -1, wsz, 
                                      MAX_PATH); 

            if (cch > 0) {
                // Load the shortcut. 
                hres = ppf->Load(wsz, STGM_READ); 
#else 
                // Load the shortcut. 
                hres = ppf->Load(lpszLinkFile, STGM_READ); 
#endif 

                if (SUCCEEDED(hres)) { 
	
                    // Get the path to the link target. 
                    hres = psl->GetPath(szPath, 
                            MAX_PATH, (WIN32_FIND_DATA *)&wfd, 
                            SLGP_SHORTPATH ); 
	
                    if (SUCCEEDED(hres)) {
                        lstrcpy(lpszPath, szPath); 
                        rc = TRUE;
                    }                                               
                }
	
#ifndef UNICODE
            } 
#endif
            // Release the pointer to the IPersistFile interface. 
            ppf->Release(); 
            ppf = NULL;
        }

        // Release the pointer to the IShellLink interface. 
        psl->Release();
        psl = NULL;
    }

    return rc; 
}

void DeleteProgramFiles(TCHAR * szProgramDirectory)
{
    unsigned len;
    HANDLE hFile;
    WIN32_FIND_DATA FindFileData;
  
    len = _tcslen(szProgramDirectory); 
    DBGMSG((_T("DeleteTSCFromStartMenu: TS Client: %s"), szProgramDirectory));

    //
    // Delete the folder
    //
    _tcscat(szProgramDirectory, _T("*.*"));
    hFile = FindFirstFile(szProgramDirectory, &FindFileData);

    if (hFile != INVALID_HANDLE_VALUE) {
        szProgramDirectory[len] = _T('\0');
        _tcscat(szProgramDirectory, FindFileData.cFileName);

        if (_tcscmp(FindFileData.cFileName, _T(".")) != 0 ||
                _tcscmp(FindFileData.cFileName, _T("..")) != 0) {
            DWORD dwFileAttributes;
                
            //
            // Remove the read only attribute for deleting
            //
            dwFileAttributes = GetFileAttributes(szProgramDirectory);
            dwFileAttributes &= ~(FILE_ATTRIBUTE_READONLY);
            SetFileAttributes(szProgramDirectory, dwFileAttributes);

            DBGMSG((_T("DeleteTSCFromStartMenu: delete: %s"), szProgramDirectory));
            DeleteFile(szProgramDirectory);
        }
        
        while(FindNextFile(hFile, &FindFileData)) {
            szProgramDirectory[len] = _T('\0');
            _tcscat(szProgramDirectory, FindFileData.cFileName);

            if (_tcscmp(FindFileData.cFileName, _T(".")) != 0 ||
                    _tcscmp(FindFileData.cFileName, _T("..")) != 0) {

                DWORD dwFileAttributes;

                //
                // Remove the read only attribute for deleting
                //
                dwFileAttributes = GetFileAttributes(szProgramDirectory);
                dwFileAttributes &= ~(FILE_ATTRIBUTE_READONLY);
                SetFileAttributes(szProgramDirectory, dwFileAttributes);
        
                DBGMSG((_T("DeleteTSCFromStartMenu: delete: %s"), szProgramDirectory));
                DeleteFile(szProgramDirectory);                                         
            }
        }

        FindClose(hFile);
    } 

    //
    // Delete the directory
    //
    szProgramDirectory[len - 1] = _T('\0'); 
    RemoveDirectory(szProgramDirectory);
}

//
//  Delete the Terminal Server client entry from the Startup Menu
//
void DeleteTSCFromStartMenu(TCHAR* szProgmanPath)
{
    TCHAR szBuf[MAX_PATH];
    LPITEMIDLIST ppidl = NULL;
    HINSTANCE hInstance = (HINSTANCE) NULL;
    HRESULT hres;
    
    DBGMSG((_T("DeleteTSCFromStartMenu")));
    
    //
    // Initialize the data
    //
    _tcscpy(szBuf, _T(""));

    //
    // Remove the tsclient folder under user's start menu folder.
    //
    hres = SHGetSpecialFolderLocation(NULL, CSIDL_PROGRAMS, &ppidl);

    if(SUCCEEDED(hres))
    {
        unsigned len;
        HANDLE hFile;
        WIN32_FIND_DATA FindFileData;

        if (SHGetPathFromIDList(ppidl, szBuf)) {

            //
            // Delete Terminal Services Client folder in start menu
            //
            _tcscat(szBuf, _T("\\"));
            _tcscat(szBuf, szProgmanPath);
            _tcscat(szBuf, _T("\\"));
            len = _tcslen(szBuf); 
            DBGMSG((_T("DeleteTSCFromStartMenu: TS Client: %s"), szBuf));

            //
            // Delete the folder
            //
            DeleteProgramFiles(szBuf);
        }
        else {
            DBGMSG((_T("DeleteTSCFromStartMenu: Failed to get program file path: gle: %d"),
                    GetLastError()));
        }

    }
    else {
        DBGMSG((_T("DeleteTSCFromStartMenu: Failed to get program file location: (hres: 0x%x) gle:%d"),
                hres, GetLastError()));
    }

    //
    // Now remove the folder under start menu folder under all users (if any)
    //
    memset(&szBuf, 0x0, sizeof(szBuf));
    hres = SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_PROGRAMS, &ppidl);            

    if(SUCCEEDED(hres))
    {
        unsigned len;

        SHGetPathFromIDList(ppidl, szBuf);
        len = _tcslen(szBuf);

        //
        // Delete Terminal Services Client in common start menu
        //
        _tcscat(szBuf, _T("\\"));
        _tcscat(szBuf, szProgmanPath);
        _tcscat(szBuf, _T("\\"));
        DBGMSG((_T("DeleteTSCFromStartMenu: TS Client: %s"), szBuf));

        //
        // Delete the folder
        //
        DeleteProgramFiles(szBuf);                
    }
    else {
        DBGMSG((_T("DeleteTSCFromStartMenu: Failed to get (common) program file location: hres=0x%x gle=%d"),
                hres,GetLastError()));
    }
}

//
//  Delete the Terminal Server client shortcuts from the desktop
//
void DeleteTSCDesktopShortcuts() 
{
    TCHAR szBuf[MAX_PATH];
    TCHAR szProgmanPath[MAX_PATH] = _T("");
    TCHAR szOldProgmanPath[MAX_PATH] = _T("");
    LPITEMIDLIST ppidl = NULL;
    SHFILEOPSTRUCT FileOp;
    HINSTANCE hInstance = (HINSTANCE) NULL;
    HRESULT hres, hInit;

    DBGMSG((_T("DeleteTSCDesktopShortcuts")));

	 hInit = CoInitialize(NULL);
    _tcscpy(szBuf, _T(""));

    //
    //  Find the desktop folder location
    //
    hres = SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOPDIRECTORY , &ppidl);

    if(SUCCEEDED(hres))
    {
        HANDLE hFile;
        WIN32_FIND_DATA FindFileData;
        unsigned len;
        TCHAR szTarget[MAX_PATH];

        SHGetPathFromIDList(ppidl, szBuf);
		  _tcscat(szBuf, _T("\\"));
        len = _tcslen(szBuf);

        DBGMSG((_T("DeleteTSCDesktopShortcuts: Desktop folder: %s"), szBuf));

        //
        // Enumerate each desktop file
        //
        _tcscat(szBuf, _T("*.lnk"));

        hFile = FindFirstFile(szBuf, &FindFileData);

        if (hFile != INVALID_HANDLE_VALUE) {
		      szBuf[len] = _T('\0');
            _tcscat(szBuf, FindFileData.cFileName);

            //
            // Get the target of the shortcut link
            //
            if (GetLinkFileTarget(szBuf, szTarget)) {

                //
                // If the target points to mstsc.exe, then deletes the link
                //
                if (_tcsstr(szTarget, _T("mstsc.exe")) != NULL ||
				            _tcsstr(szTarget, _T("MSTSC.EXE")) != NULL) {
                    DWORD dwFileAttributes;
                    
                    //
                    // Remove the read only attribute for deleting
                    //
                    dwFileAttributes = GetFileAttributes(szTarget);
                    dwFileAttributes &= ~(FILE_ATTRIBUTE_READONLY);
                    SetFileAttributes(szTarget, dwFileAttributes);

                    DBGMSG((_T("DeleteTSCDesktopShortcuts: delete shortcuts: %s"), szBuf));
                    DeleteFile(szBuf);
                }
            }

            while(FindNextFile(hFile, &FindFileData)) {
                szBuf[len] = _T('\0');
                _tcscat(szBuf, FindFileData.cFileName);

                // Get the target of the shortcut link
                if (GetLinkFileTarget(szBuf, szTarget)) {
    
                    // If the target points to mstsc.exe, then deletes the link
                    if (_tcsstr(szTarget, _T("mstsc.exe")) != NULL ||
						          _tcsstr(szTarget, _T("MSTSC.EXE")) != NULL) {
                        DWORD dwFileAttributes;

                        //
                        // Remove the read only attribute for deleting
                        //
                        dwFileAttributes = GetFileAttributes(szTarget);
                        dwFileAttributes &= ~(FILE_ATTRIBUTE_READONLY);
                        SetFileAttributes(szTarget, dwFileAttributes);
            
                        DBGMSG((_T("DeleteTSCDesktopShortcuts: delete shortcuts: %s"), szBuf));
                        DeleteFile(szBuf);                     
                    }
                }
            }

            FindClose(hFile);
        }
    }
    else {
        DBGMSG((_T("DeleteTSCDesktopShortcuts: Failed to find desktop location: %d"),
                GetLastError()));
    }
	
	 if (SUCCEEDED(hInit)) {
		  CoUninitialize();
    }
}

//
//  Delete the bitmap cache folder
//
void DeleteBitmapCacheFolder(TCHAR *szDstDir)
{
    TCHAR szCacheFolderName[2 * MAX_PATH] = _T("");
    TCHAR szRootPath[MAX_PATH] = _T("");
    DWORD lpcbData = MAX_PATH;
    SHFILEOPSTRUCT FileOp;

    DWORD dwSubSize = MAX_PATH;
    TCHAR szRegPath[MAX_PATH] = _T("");
    HKEY hKey = NULL;
    int nLen = 0;

    //
    // Delete the bitmap cache folder as specified in the registry.
    //
    _stprintf(szRegPath, _T("%s%s"), DUCATI_REG_PREFIX, DUCATI_SUBKEY);

    if (ERROR_SUCCESS  == RegOpenKeyEx(HKEY_CURRENT_USER, szRegPath, 0, KEY_READ, &hKey))
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, BITMAP_CACHE_LOCATION,
                NULL, NULL, (LPBYTE)szCacheFolderName, &lpcbData))
        {
            if (szCacheFolderName[0] != _T('\0'))
            {
                if (szCacheFolderName[lpcbData - 2] == _T('\\'))
                {
                    szCacheFolderName[lpcbData - 2] = _T('\0');
                }

                //
                // Delete the bitmap cache folder.
                //
                memset(&FileOp, 0x0, sizeof(FileOp));
                FileOp.wFunc = FO_DELETE;
                FileOp.pFrom = szCacheFolderName;
                FileOp.fFlags = FOF_NOCONFIRMATION | FOF_SILENT | FOF_NOERRORUI;
                SHFileOperation(&FileOp);
            }
        }
        RegCloseKey(hKey);
    }

    // Delete the default bitmap cache folder.

    if (szDstDir[0] == _T('\0'))
    {
        return ;
    }

    _stprintf(szCacheFolderName, _T("%s%s"), szDstDir, BITMAP_CACHE_FOLDER);

    if (szCacheFolderName[0] != '\0')
    {
        nLen = _tcslen(szCacheFolderName);

        if (szCacheFolderName[nLen - 1] == _T('\\'))
        {
            szCacheFolderName[nLen - 1] = _T('\0');
        }

        //
        //Delete the bitmap cache folder.
        //
        memset(&FileOp, 0x0, sizeof(FileOp));
        FileOp.wFunc = FO_DELETE;
        FileOp.pFrom = szCacheFolderName;
        FileOp.fFlags = FOF_NOCONFIRMATION | FOF_SILENT | FOF_NOERRORUI;
        SHFileOperation(&FileOp);
    }

    return ;
}

//
// Delete any registry key 
//
void DeleteTSCRegKeys()
{
    TCHAR szRegPath[MAX_PATH] = _T("");
    HKEY hKey = NULL;

    //
    // Delete the rdpdr dll VC Addin as specified in the registry.
    //
    _stprintf(szRegPath, _T("%s%s\\%s"), DUCATI_REG_PREFIX, DUCATI_SUBKEY, DUCATI_RDPDRKEY);

    if (ERROR_SUCCESS  == RegOpenKeyEx(HKEY_CURRENT_USER, szRegPath, 0, KEY_READ, &hKey))
    {
        DBGMSG((_T("DeleteTSCRegKeys: HKCU %s"), szRegPath));              
        RegDeleteValue(hKey, ADDIN_NAME);
        RegCloseKey(hKey);
        RegDeleteKey(HKEY_CURRENT_USER, szRegPath);
    }

    if (ERROR_SUCCESS  == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegPath, 0, KEY_READ, &hKey))
    {
        DBGMSG((_T("DeleteTSCRegKeys: HKLM %s"), szRegPath));              
        RegDeleteValue(hKey, ADDIN_NAME);
        RegCloseKey(hKey);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath);
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\setup\setuplib\msi.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name :
    
    msi.cpp

Abstract:

    remove TSAC MSI client
    
Author:

    nadima

Revision History:
--*/

#include "stdafx.h"
#include "msi.h"

#define TSAC_PRODUCT_CODE _T("{B6CAA8E1-4F33-4208-B25E-0376200202D0}")

//
// Uninstall the TSAC MSI files
//
HRESULT UninstallTSACMsi()
{
    UINT status;
    INSTALLUILEVEL prevUiLevel;

    DBGMSG((_T("UninstallTSACMsi ENTER")));

    //
    // Hide the UI
    //
    prevUiLevel = MsiSetInternalUI(INSTALLUILEVEL_NONE,
                                   NULL);

    //
    // Uninstall TSAC
    //
    status = MsiConfigureProduct(TSAC_PRODUCT_CODE,
                                 INSTALLLEVEL_MAXIMUM,
                                 INSTALLSTATE_ABSENT);

    DBGMSG((_T("MsiConfigureProduct to remove TSAC returned: %d"),
             status));

    //
    // Restore UI level
    //
    MsiSetInternalUI(prevUiLevel,
                    NULL);


    DBGMSG((_T("UninstallTSACMsi LEAVE")));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\setup\setuplib\acme.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name :
    
    acme.cpp

Abstract:

    remove acme installed client files and acme registry keys
    
Author:

    JoyC 

Revision History:
--*/

#include "stdafx.h"

#define ACME_REG_UNINSTALL_TS  _T("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Terminal Server Client")
#define UNINSTALL_REG_STR      _T("UninstallString")

//
//  List of TS client files installed
//
TCHAR* TSCFiles[] =
{
    _T("cconman.cnt"),
    _T("cconman.hlp"),
    _T("conman.exe"),
    _T("mscreate.dir"),
    _T("mstsc.cnt"),
    _T("mstsc.exe"),
    _T("mstsc.hlp"),
    _T("rdpdr.dll")
};

//
//  Delete all the installed TS client files
//
void DeleteTSCProgramFiles()
{
    DWORD status;
    HKEY  hKey = NULL;
    HMODULE hShellModule = NULL;
    SHFILEOPSTRUCT FileOp;
    DWORD bufLen = MAX_PATH;
    TCHAR buffer[MAX_PATH] = _T("");
    TCHAR szOldInstallPath[MAX_PATH] = _T("");
    TCHAR szOldInstallPathRoot[MAX_PATH] = _T("");
           
    typedef DWORD (*PFnSHDeleteKey)(HKEY, LPCTSTR);
    PFnSHDeleteKey pfn = NULL;
    
    DBGMSG((_T("DeleteTSCProgramFiles")));

    //
    // Open the tsclient uninstall key
    //
    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, ACME_REG_UNINSTALL_TS,
            0, KEY_ALL_ACCESS, &hKey);

    if(ERROR_SUCCESS == status)
    {
        DBGMSG((_T("DeleteTSCProgramFiles: Opened ACME TSC uninstall registry key")));

        //
        // Query the uninstall value
        //
        if(ERROR_SUCCESS == RegQueryValueEx(hKey, UNINSTALL_REG_STR,
                NULL, NULL, (BYTE *)buffer, &bufLen))
        {
            TCHAR fname[_MAX_FNAME] = _T("");
            TCHAR drive[_MAX_DRIVE] = _T(""), dir[_MAX_DIR] = _T("");
            TCHAR ext[_MAX_EXT] = _T("");
            TCHAR FileFullPath[MAX_PATH];
            DWORD len;

            //
            // Get the uninstall directory
            //
            _tcscpy(szOldInstallPath, (TCHAR*)buffer);
            _tsplitpath(szOldInstallPath, drive, dir, fname, ext);
            _stprintf(szOldInstallPathRoot, _T("%s%s"), drive, dir);

            if(_tcslen(szOldInstallPathRoot) > 1 &&
                   szOldInstallPathRoot[_tcslen(szOldInstallPathRoot) - 1] == _T('\\'))
            {
                szOldInstallPathRoot[_tcslen(szOldInstallPathRoot) - 1] = _T('\0');
            }
            
            DBGMSG((_T("DeleteTSCProgramFiles: uninstall directory: %s"),
                    szOldInstallPathRoot));

            //
            // Delete the old setup folder
            //
            memset(&FileOp, 0, sizeof(FileOp));
            FileOp.wFunc = FO_DELETE;
            FileOp.pFrom = szOldInstallPathRoot;
            FileOp.pTo = NULL;
            FileOp.fFlags = FOF_NOCONFIRMATION | FOF_SILENT | FOF_NOERRORUI;
            SHFileOperation(&FileOp);

            //
            //  Need to delete program files in the parent directory
            //
            _tcscpy(szOldInstallPath, szOldInstallPathRoot);
            _tsplitpath(szOldInstallPath, drive, dir, fname, ext);
            _stprintf(szOldInstallPathRoot, _T("%s%s"), drive, dir);
            
            if(szOldInstallPathRoot[_tcslen(szOldInstallPathRoot) - 1] == _T('\\'))
            {
                szOldInstallPathRoot[_tcslen(szOldInstallPathRoot) - 1] = _T('\0');
            }

            _tcscpy(FileFullPath, szOldInstallPathRoot);
            _tcscat(FileFullPath, _T("\\"));
            len = _tcslen(FileFullPath);

            DBGMSG((_T("DeleteTSCProgramFiles: TS client directory: %s"),
                    FileFullPath));

            for (int i = 0; i < sizeof(TSCFiles) / sizeof(TSCFiles[0]); i++) {
                DWORD dwFileAttributes;

                FileFullPath[len] = _T('\0');
                _tcscat(FileFullPath, TSCFiles[i]);

                //
                // Remove the read only attribute for deleting
                //
                dwFileAttributes = GetFileAttributes(FileFullPath);
                dwFileAttributes &= ~(FILE_ATTRIBUTE_READONLY);
                SetFileAttributes(FileFullPath, dwFileAttributes);
                DeleteFile(FileFullPath);
            }


            //
            //  Delete the directory if it's empty
            //
            FileFullPath[len] = _T('\0');
            RemoveDirectory(FileFullPath);
        }

        RegCloseKey(hKey);

        hShellModule = LoadLibrary (_T("shlwapi.dll"));
        if (hShellModule != NULL) {
	         pfn = (PFnSHDeleteKey)GetProcAddress(hShellModule, "SHDeleteKey");
            if (pfn != NULL) {
                (*pfn)(HKEY_LOCAL_MACHINE, ACME_REG_UNINSTALL_TS);        
            }
            else {
                RegDeleteKey(HKEY_LOCAL_MACHINE, ACME_REG_UNINSTALL_TS);            
            }

            FreeLibrary (hShellModule);
         	hShellModule = NULL;
	         pfn = NULL;
        }
        else {
            RegDeleteKey(HKEY_LOCAL_MACHINE, ACME_REG_UNINSTALL_TS);            
        }
    }
    else {
        DBGMSG((_T("DeleteTSCProgramFiles: Failed to open the ACME uninstall reg key: %d"), 
                   GetLastError()));
    }       
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\setup\setuplib\stdafx.h ===
//Copyright (c) 2000 Microsoft Corporation

#ifndef _stdafx_h_
#define _stdafx_h_

#include <windows.h>
#include <devguid.h>
#include <initguid.h>
#include <tchar.h>
#include <time.h>
#include <stdio.h>
#include <setupapi.h>
#include <shellapi.h>
#include <shlobj.h>
#include <regapi.h>
#include <malloc.h>
#include <shlwapi.h>


//
// uwrap has to come after the headers for ANY wrapped
// functions
//
#ifdef UNIWRAP
#include "uwrap.h"
#endif


#include "setuplib.h"

#endif // _stdafx_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\setup\tscupgrd\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       resource.h
//
//--------------------------------------------------------------------------
// Used by common.rc
//

#define IDS_PROGMAN_GROUP               3004
#define IDS_OLD_NAME                    3007
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\multihst\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MstsMhst.rc
//
#define IDS_PROJNAME                    100
#define IDR_MSTSCMHST                   102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\multihst\multihst.h ===
// MstscMhst.h : Declaration of the CMstscMhst

#ifndef __MSTSCMHST_H_
#define __MSTSCMHST_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include <vector>

//
// Header generated by IDL file
//
#include "multihost.h"

#define	NO_ACTIVE_CLIENT -1
#define MSTSC_CONTROL_GUID TEXT("{7cacbd7b-0d99-468f-ac33-22e495c0afe5}")


/////////////////////////////////////////////////////////////////////////////
// CMstscMhst
class ATL_NO_VTABLE CMstscMhst : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IMstscMhst, &IID_IMstscMhst, &LIBID_MSTSMHSTLib>,
	public CComControl<CMstscMhst>,
	public IPersistStreamInitImpl<CMstscMhst>,
	public IOleControlImpl<CMstscMhst>,
	public IOleObjectImpl<CMstscMhst>,
	public IOleInPlaceActiveObjectImpl<CMstscMhst>,
	public IViewObjectExImpl<CMstscMhst>,
	public IOleInPlaceObjectWindowlessImpl<CMstscMhst>,
	public IConnectionPointContainerImpl<CMstscMhst>,
	public IPersistStorageImpl<CMstscMhst>,
	public ISpecifyPropertyPagesImpl<CMstscMhst>,
	public IQuickActivateImpl<CMstscMhst>,
	public IDataObjectImpl<CMstscMhst>,
	public IObjectSafetyImpl<CMstscMhst, INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
	public IProvideClassInfo2Impl<&CLSID_MstscMhst, &DIID__IMstscMhstEvents, &LIBID_MSTSMHSTLib>,
	public IPropertyNotifySinkCP<CMstscMhst>,
	public CComCoClass<CMstscMhst, &CLSID_MstscMhst>
{
public:
	CMstscMhst()
	{
		m_bWindowOnly = TRUE;
		m_bAddRequestPending = FALSE;
		m_ActiveClientIndex = NO_ACTIVE_CLIENT;

		m_pActiveWindow = NULL;
	}

    ~CMstscMhst()
    {
        m_pActiveWindow = NULL;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_MSTSCMHST)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMstscMhst)
	COM_INTERFACE_ENTRY(IMstscMhst)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IQuickActivate)
	COM_INTERFACE_ENTRY(IPersistStorage)
	COM_INTERFACE_ENTRY(IDataObject)
	COM_INTERFACE_ENTRY(IObjectSafety)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
END_COM_MAP()

BEGIN_PROP_MAP(CMstscMhst)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_CONNECTION_POINT_MAP(CMstscMhst)
	CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP()

BEGIN_MSG_MAP(CMstscMhst)
	CHAIN_MSG_MAP(CComControl<CMstscMhst>)
	DEFAULT_REFLECTION_HANDLER()
	MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_DESTROY,OnDestroy)
	MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_SETFOCUS, OnGotFocus)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnLostFocus)
END_MSG_MAP()

// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// IMstscMhst
public:

	HRESULT OnDraw(ATL_DRAWINFO& di)
	{
		RECT& rc = *(RECT*)di.prcBounds;
		Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);
		return S_OK;
	}

	STDMETHOD(Add)(IMsRdpClient** ppMstsc);
	STDMETHOD(get_Item)(long Index, IMsRdpClient** ppMstsc);
	STDMETHOD(get_Count)(long* pCount);
	STDMETHOD(put_ActiveClientIndex)(long ClientIndex);
	STDMETHOD(get_ActiveClient)(IMsRdpClient** ppMstsc);
	STDMETHOD(put_ActiveClient)(IMsRdpClient* ppMstsc);
	STDMETHOD(RemoveIndex)(long ClientIndex);
	STDMETHOD(Remove)(IMsRdpClient* ppMstsc);

    //
    // Message handlers
    //
	LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnGotFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnLostFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);


protected:
    STDMETHOD(OnFrameWindowActivate)(BOOL fActivate );

	BOOL	SwitchCurrentActiveClient(CAxWindow* newHostWindow);
	HRESULT	DeleteAxContainerWnd(CAxWindow* pAxWnd);

	BOOL	m_bAddRequestPending;

	//Vector that stores the collection
	std::vector<CAxWindow*>	m_coll;

	CAxWindow*	m_pActiveWindow;
	//Index of the 'current' active client
	long	m_ActiveClientIndex;
};

#endif //__MSTSCMHST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\setup\tscupgrd\main.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name :
    
    acme.cpp

Abstract:

    remove acme installed client files and acme registry keys
    
Author:

    JoyC 

Revision History:
--*/

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include "setuplib.h"
#include "resource.h"

#define TERMINAL_SERVER_CLIENT_REGKEY  _T("Software\\Microsoft\\Terminal Server Client")
#define LOGFILE_STR      _T("LogFile")

HANDLE g_hLogFile = INVALID_HANDLE_VALUE;

int __cdecl main(int argc, char** argv)
{
    DWORD status;
    HKEY hKey;
    HINSTANCE hInstance = (HINSTANCE) NULL;
    TCHAR buffer[MAX_PATH];
    TCHAR szProgmanPath[MAX_PATH] = _T("");
    TCHAR szOldProgmanPath[MAX_PATH] = _T("");
    DWORD bufLen;
    TCHAR szMigratePathLaunch[MAX_PATH];

    //
    // Open the tsclient registry key to get the log file name
    //
    memset(buffer, 0, sizeof(buffer));
    bufLen = sizeof(buffer); //size in bytes needed
    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          TERMINAL_SERVER_CLIENT_REGKEY,
                          0, KEY_READ, &hKey);

    if(ERROR_SUCCESS == status)
    {

        //
        // Query the tsclient optional logfile path
        //
        status = RegQueryValueEx(hKey, LOGFILE_STR,
                        NULL, NULL, (BYTE *)buffer, &bufLen);
        if(ERROR_SUCCESS == status)
        {
             g_hLogFile = CreateFile(buffer,
                                     GENERIC_READ | GENERIC_WRITE,
                                     0,
                                     NULL,
                                     OPEN_ALWAYS,
                                     FILE_ATTRIBUTE_NORMAL,
                                     NULL);
             if(g_hLogFile != INVALID_HANDLE_VALUE)
             {
                 //Always append to the end of the log file
                 SetFilePointer(g_hLogFile,
                                0,
                                0,
                                FILE_END);
             }
             else
             {
                 DBGMSG((_T("CreateFile for log file failed %d %d"),
                         g_hLogFile, GetLastError()));
             }
        }
        else
        {
            DBGMSG((_T("RegQueryValueEx for log file failed %d %d"),
                    status, GetLastError()));
        }
        RegCloseKey(hKey);
    }

    if(g_hLogFile != INVALID_HANDLE_VALUE)
    {
        DBGMSG((_T("Log file opened by new process attach")));    
    }
    
    DeleteTSCDesktopShortcuts(); 

    LoadString(hInstance, IDS_PROGMAN_GROUP, szProgmanPath, sizeof(szProgmanPath) / sizeof(TCHAR));
    DeleteTSCFromStartMenu(szProgmanPath);
    
    LoadString(hInstance, IDS_OLD_NAME, szOldProgmanPath, sizeof(szOldProgmanPath) / sizeof(TCHAR));
    DeleteTSCFromStartMenu(szOldProgmanPath);

    DeleteTSCProgramFiles();    
        
    DeleteTSCRegKeys();
        
    UninstallTSACMsi();

    //
    //  Start registry and connection file migration
    //
    PROCESS_INFORMATION pinfo;
    STARTUPINFO sinfo;
	
    ZeroMemory(&sinfo, sizeof(sinfo));
    sinfo.cb = sizeof(sinfo);

    //
    // CreateProcess modifies buffer we pass it so it can't
    // be a static string
    //
    _tcscpy(szMigratePathLaunch, _T("mstsc.exe /migrate"));

    if (CreateProcess(NULL,                               // name of executable module
	                  szMigratePathLaunch,                // command line string
		                NULL,                             // SD
		                NULL,                             // SD
		                FALSE,                            // handle inheritance option
		                CREATE_NEW_PROCESS_GROUP,         // creation flags
		                NULL,                             // new environment block
		                NULL,                             // current directory name
		                &sinfo,                           // startup information
		                &pinfo                            // process information
                      )) {
        DBGMSG((_T("Started mstsc.exe /migrate")));
    }
    else {
        DBGMSG((_T("Failed to starte mstsc.exe /migrate: %d"), GetLastError()));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\multihst\mhstmod.cpp ===
// MstsMhst.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f MstsMhstps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "multihst.h"

#include "multihost_i.c"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_MstscMhst, CMstscMhst)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_MSTSMHSTLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\multihst\multihst.cpp ===
// MstscMhst.cpp : Implementation of CMstscMhst
// Multi host control for TS activeX control.
// contains multiple instances of the activeX control. Used by the MMC control
// Copyright(C) Microsoft Corporation 2000
// nadima


#include "stdafx.h"
#include "multihst.h"

//Pos/width of sessions that are not active
#define X_POS_DISABLED -10
#define Y_POS_DISABLED -10
#define X_WIDTH_DISABLED 5
#define Y_WIDTH_DISABLED 5


/////////////////////////////////////////////////////////////////////////////
// CMstscMhst


/*
 *Function Name:Add
 *
 *Parameters: (out) ppMstsc pointer to newly added TS control
 *
 *Description: Add's a new TS ActiveX control to the multihost
 *
 *Returns: HRESULT
 *
 */
STDMETHODIMP CMstscMhst::Add(IMsRdpClient** ppMstsc)
{
    if (::IsWindow(m_hWnd))
    {
        CAxWindow* pAxWnd = new CAxWindow();
        ATLASSERT(pAxWnd);
        if (!pAxWnd)
        {
            return E_OUTOFMEMORY;
        }

        RECT rc;
        GetClientRect(&rc);
        //
        // Window is created invisible and disabled...
        // Must be made with active client for it to become enabled and visible
        //
        if (!pAxWnd->Create( m_hWnd, rc, MSTSC_CONTROL_GUID,
                             WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN,
                             0))
        {
            delete pAxWnd;
            return E_FAIL;
        }

        CComPtr<IMsRdpClient> tsClientPtr;
        if (FAILED(pAxWnd->QueryControl( &tsClientPtr)))
        {
            delete pAxWnd;
            return E_FAIL;
        }

        //
        // Store the pointer to the control
        //
        m_coll.push_back( pAxWnd);

        //If no MSTSC windows are active then make this first
        //one the active window
        if (!m_pActiveWindow)
        {
            SwitchCurrentActiveClient( pAxWnd);
        }

        if (ppMstsc)
        {
            //
            // return the pointer, Detach does not decrement the ref count
            // so we still hold a reference to the control from the QueryControl
            // that is the +1 refcount needed to pass the pointer as an out
            // parameter.
            //
            *ppMstsc = (IMsRdpClient*)tsClientPtr.Detach();
        }

        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

/*
 *Function Name:get_Item
 *
 *Parameters:  (in)  Index (index of the item to return)
 *             (out) ppMstsc pointer to the TS control returned
 *
 *Description: returns the TS control at a particular index
 *
 *Returns: HRESULT
 *
 */

STDMETHODIMP CMstscMhst::get_Item(long Index, IMsRdpClient** ppMstsc)
{
    if (Index <0 || Index >= m_coll.size())
    {
        ATLASSERT(Index > 0 && Index < m_coll.size());
        return E_INVALIDARG;
    }

    if (!ppMstsc)
    {
        return E_INVALIDARG;
    }

    //Return the interface pointer associated
    //with the AxWindow container

    CAxWindow* pAxWnd = m_coll[Index];
    if (!pAxWnd)
    {
        return E_FAIL;
    }

    CComPtr<IMsRdpClient> tsClientPtr;
    if (FAILED(pAxWnd->QueryControl( &tsClientPtr)))
    {
        delete pAxWnd;
        return E_FAIL;
    }

    //
    // Return the pointer to the ts control. Detach does not
    // decrement the AddRef from QueryControl so the refcount is
    // correctly incremented by one for the out parameter
    //
    *ppMstsc = (IMsRdpClient*)tsClientPtr.Detach();

    return S_OK;
}

/*
 *Function Name:get_Count
 *
 *Parameters: (out) pCount
 *
 *Description: returns number of items in the collection
 *
 *Returns: HRESULT
 *
 */

STDMETHODIMP CMstscMhst::get_Count(long* pCount)
{
    if (!pCount)
    {
        return E_INVALIDARG;
    }

    *pCount = m_coll.size();
    return S_OK;
}


/*
 *Function Name:put_ActiveClientIndex
 *
 *Parameters: (in) ClientIndex
 *
 *Description: sets the active client by Index
 *
 *Returns: HRESULT
 *
 */

STDMETHODIMP CMstscMhst::put_ActiveClientIndex(long ClientIndex)
{
    if (ClientIndex < 0 || ClientIndex >= m_coll.size())
    {
        return E_INVALIDARG;
    }

    CAxWindow* pNewClientWnd  = m_coll[ClientIndex];
    if (!pNewClientWnd)
    {
        return E_FAIL;
    }

    if (SwitchCurrentActiveClient(pNewClientWnd))
    {
        m_ActiveClientIndex = ClientIndex;
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

/*
 *Function Name:get_ActiveClient
 *
 *Parameters: (out) ppMstsc pointer to active client
 *
 *Description: returns the ActiveClient
 *
 *Returns: HRESULT
 *
 */

STDMETHODIMP CMstscMhst::get_ActiveClient(IMsRdpClient** ppMstsc)
{
    if (!ppMstsc)
    {
        return E_INVALIDARG;
    }
    if (!m_pActiveWindow)
    {
        *ppMstsc = NULL;
        return S_OK;
    }

    CComPtr<IMsRdpClient> tsClientPtr;
    if (FAILED(m_pActiveWindow->QueryControl( &tsClientPtr)))
    {
        return E_FAIL;
    }

    //
    // Detach keeps the +1 ref from QueryControl
    // 
    *ppMstsc = (IMsRdpClient*)tsClientPtr.Detach();

    return S_OK;
}

/*
 *Function Name:put_ActiveClient
 *
 *Parameters: ppMstsc
 *
 *Description: sets the active client given a pointer to
 *             to the client instance
 *
 *Returns: HRESULT
 *
 */
STDMETHODIMP CMstscMhst::put_ActiveClient(IMsRdpClient* ppMstsc)
{
    CAxWindow* pAxWnd = NULL;

    //find AxWindow that hosts this client
    //in the collection
    std::vector<CAxWindow*>::iterator iter;
    for (iter = m_coll.begin(); iter != m_coll.end(); iter++)
    {
        CComPtr<IMsRdpClient> tsClientPtr;
        HRESULT hr = (*iter)->QueryControl( &tsClientPtr);
        if (FAILED(hr))
        {
            return hr;
        }
        if (tsClientPtr == ppMstsc)
        {
            pAxWnd = *iter;
            break;
        }
    }

    if (!pAxWnd)
    {
        //We were given a control reference that could not be found
        return E_INVALIDARG;
    }

    if (!SwitchCurrentActiveClient(pAxWnd))
    {
        return E_FAIL;
    }

    return S_OK;
}


/*
 *Function Name:SwitchCurrentActiveClient
 *
 *Parameters: (in) newHostWindow - AxWindow that will become
 *                 the active window
 *
 *Description: sets the active client given a pointer to
 *             to the client instance
 *
 *Returns: success flag
 *
 */
BOOL CMstscMhst::SwitchCurrentActiveClient(CAxWindow* newHostWindow)
{
    //Switch the current active client window
    if (!newHostWindow)
    {
        return FALSE;
    }

    m_pActiveWindow = newHostWindow;

    //
    // Make sure the window is sized properly
    //
    RECT rcClient;
    GetClientRect(&rcClient);
    m_pActiveWindow->MoveWindow(rcClient.left, rcClient.top, rcClient.right, rcClient.bottom);
    m_pActiveWindow->SetFocus();

    //
    // This window is made the active child window by brining
    // it to the top of the Z-order of child windows
    //
    newHostWindow->BringWindowToTop();

    return TRUE;
}

/*
 *Function Name:RemoveIndex
 *
 *Parameters: ClientIndex
 *
 *Description: removes a client by index
 *
 *Returns: HRESULT
 *
 */
STDMETHODIMP CMstscMhst::RemoveIndex(long ClientIndex)
{
    HRESULT hr;
    CComPtr<IMsRdpClient> tsClientPtr;
    hr = get_Item(ClientIndex, (IMsRdpClient**) (&tsClientPtr));

    if (FAILED(hr))
    {
        return hr;
    }

    //Pass in interface pointer without addref'ing
    hr = Remove( (IMsRdpClient*)tsClientPtr);

    return hr;
}

/*
 *Function Name:Remove
 *
 *Parameters: (in) ppMsts client to remove
 *
 *Description: removes a client from the collection
 *
 *Returns: HRESULT
 *
 */
STDMETHODIMP CMstscMhst::Remove(IMsRdpClient* ppMstsc)
{
    //Look for the ax window container and if found delete it
    //also, remove the entry from the collection

    //find AxWindow that hosts this client
    CAxWindow* pAxWnd = NULL;

    std::vector<CAxWindow*>::iterator iter;
    for (iter = m_coll.begin(); iter != m_coll.end(); iter++)
    {
        CComPtr<IMsRdpClient> tsClientPtr;
        HRESULT hr = (*iter)->QueryControl( &tsClientPtr);
        if (FAILED(hr))
        {
            return hr;
        }
        if (tsClientPtr == ppMstsc)
        {
            pAxWnd = *iter;
            break;
        }
    }

    if (!pAxWnd)
    {
        //We were given a control reference that could not be found
        return E_INVALIDARG;
    }

    m_coll.erase(iter);
    return DeleteAxContainerWnd(pAxWnd);
}

/*
 *Function Name:DeleteAxContainerWnd
 *
 *Parameters: (in) pAxWnd CAxWindow to delete
 *
 *Description: deletes an activeX container window
 *
 *Returns: HRESULT
 *
 */

HRESULT CMstscMhst::DeleteAxContainerWnd(CAxWindow* pAxWnd)
{
    if (!pAxWnd)
    {
        return E_FAIL;
    }

    if (m_pActiveWindow == pAxWnd)
    {
        m_pActiveWindow = NULL;
    }

    if (!pAxWnd->DestroyWindow())
    {
        return E_FAIL;
    }

    delete pAxWnd;
    return S_OK;
}

//
// OnCreate Handler
//
LRESULT CMstscMhst::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    ::SetWindowLong(m_hWnd, GWL_STYLE,
                    ::GetWindowLong(m_hWnd, GWL_STYLE) | WS_CLIPCHILDREN);

    if (!AtlAxWinInit())
    {
        return -1;
    }

    return 0;
}

/*
 *Function Name:OnDestroy
 *
 *Parameters: 
 *
 *Description: handler for WM_DESTROY
 *
 *Returns:
 *
 */
LRESULT CMstscMhst::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    m_pActiveWindow = NULL;

    if (!AtlAxWinTerm())
    {
        return -1;
    }

    //
    // Delete everything in the collection
    //
    std::vector<CAxWindow*>::iterator iter;
    for (iter = m_coll.begin(); iter != m_coll.end(); iter++)
    {
        //
        // This frees any remaining controls
        //
        DeleteAxContainerWnd(*iter);
    }

    //
    // Erase the CAxWindow items in the collection
    //
    m_coll.erase(m_coll.begin(), m_coll.end());

    return 0;
}


/**PROC+*********************************************************************/
/* Name:      OnFrameWindowActivate                                         */
/*                                                                          */
/* Purpose:  Override IOleInPlaceActiveObject::OnFrameWindowActivate        */
/*           to set the focus on the core container window when the control */
/*           gets activated                                                 */
/*                                                                          */
/**PROC-*********************************************************************/

STDMETHODIMP CMstscMhst::OnFrameWindowActivate(BOOL fActivate )
{
    if (fActivate && IsWindow() && m_pActiveWindow)
    {
        m_pActiveWindow->SetFocus();
    }

    return S_OK;
}


LRESULT CMstscMhst::OnGotFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    ATLTRACE("CMstscMhst::OnGotFocus");
    if (m_pActiveWindow)
    {
        m_pActiveWindow->SetFocus();
    }
    return 0;
}

LRESULT CMstscMhst::OnLostFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    ATLTRACE("CMstscMhst::OnLostFocus");
    return 0;
}



LRESULT CMstscMhst::OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    RECT rcClient;
    if (m_pActiveWindow)
    {
        GetClientRect(&rcClient);
        m_pActiveWindow->MoveWindow(rcClient.left, rcClient.top, rcClient.right, rcClient.bottom);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\snapin\browsedlg.h ===
#ifndef _BROWSEDLG_H_
#define _BROWSEDLG_H_

//
// Browse for servers dialog
//

//
// Include the browse for servers listbox
//
#include "browsesrv.h"

class CBrowseDlg
{
private:
    HWND m_hWnd;
	HINSTANCE m_hInst;

//private methods
private:
	TCHAR	m_szServer[MAX_PATH];

public:
    CBrowseDlg(HWND hWndOwner, HINSTANCE hInst);
    ~CBrowseDlg();
	INT_PTR	DoModal();

	static CBrowseDlg* m_pThis;

	static INT_PTR APIENTRY StaticDlgProc(HWND, UINT, WPARAM, LPARAM);
	INT_PTR DlgProc(HWND, UINT, WPARAM, LPARAM);

	LPTSTR	GetServer()	{return m_szServer;}

private:
    CBrowseServersCtl* _pBrowseSrvCtl;

    DCBOOL     _bLBPopulated;
    HANDLE     _hEvent;
};


#endif // _BROWSEDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\multihst\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(_STDAFX_H_)
#define _STDAFX_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>
#include <atlhost.h>

//File generated by MIDL compiler
#include  "mstsax.h"

#endif // !_STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\multihst\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\snapin\browsedlg.cpp ===
#include "stdafx.h"
#include "browsedlg.h"
#include "resource.h"

#include "wuiids.h"

CBrowseDlg* CBrowseDlg::m_pThis = NULL;
CBrowseDlg::CBrowseDlg(HWND hWndOwner, HINSTANCE hInst) : m_hWnd(hWndOwner), m_hInst(hInst)
{
	m_pThis = this;
    _pBrowseSrvCtl = NULL;
    _tcscpy( m_szServer, _T(""));
}

CBrowseDlg::~CBrowseDlg()
{
}

INT_PTR
CBrowseDlg::DoModal()
{
	INT_PTR retVal;

    //
    // Init owner draw servers list box
    //
    _pBrowseSrvCtl = new CBrowseServersCtl(m_hInst);
    ASSERT(_pBrowseSrvCtl);

    if(!_pBrowseSrvCtl)
    {
        return 0;
    }
    
    _pBrowseSrvCtl->AddRef();
    
	retVal = DialogBox( m_hInst,MAKEINTRESOURCE(IDD_DIALOGBROWSESERVERS), m_hWnd, StaticDlgProc);

    //Object self deletes when refcount reaches 0
    //done so object is still around if list box population thread is still running
    _pBrowseSrvCtl->Release();


	return retVal;
}

INT_PTR CALLBACK CBrowseDlg::StaticDlgProc(HWND hDlg,UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	//
	// need access to class variables so redirect to non-static version of callback
	//
	return m_pThis->DlgProc(hDlg,uMsg,wParam,lParam);
}

INT_PTR
CBrowseDlg::DlgProc(HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL rc = FALSE;
    static ServerListItem *plbi = NULL;
    static HANDLE hThread = NULL;
    static DCUINT DomainCount = 0;

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            //Set the parent dialog handle of the browse for servers listbox
            _pBrowseSrvCtl->SetDialogHandle( hwndDlg);
            _pBrowseSrvCtl->Init( hwndDlg );

            if(hwndDlg)
            {
                DWORD dwResult = 0, dwThreadId;
                LPVOID lpMsgBuf = NULL;
                _bLBPopulated = FALSE;                   	
                //create an event to signal the worker thread
                //auto reset and initial state is nonsignalled
                _hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
                
                if(!_hEvent)
                {
                    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL,
                        GetLastError(),
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (LPTSTR) & lpMsgBuf, 0, NULL);
                    
//                    TRC_ERR((TB, "CreateEvent returned %s", lpMsgBuf));
                }
                else
                {
                    //Set the event handle for notification
                    //the _BrowseSrvListBox will CloseHandle the event when it is done
                    _pBrowseSrvCtl->SetEventHandle(_hEvent);
                    /* Create a worker thread to do the browsing for servers */
                    hThread = CreateThread(NULL, 0, &CBrowseServersCtl::UIStaticPopListBoxThread,
                        _pBrowseSrvCtl, 0, &dwThreadId);
                }
                
                if(lpMsgBuf)
                {
                    LocalFree(lpMsgBuf);
                }
                
                if(NULL == hThread)
                {
                    /*Since the CreateThread failed, populate the list box directly*/
                    _pBrowseSrvCtl->LoadLibraries();
                    plbi = _pBrowseSrvCtl->PopulateListBox(hwndDlg, &DomainCount);
                }
                else
                {
                    //
                    // Add a reference to the list box object for the new thread
                    // so the object doesn't get deleted before the thread is done
                    // the Release() is in the function called on this new thread
                    //
                    _pBrowseSrvCtl->AddRef();
                    CloseHandle(hThread);
                }
            }

            rc = TRUE;
        }
        break;

        //message captured here to check if the populating of listbox is completed by the
        //worker thread
        case UI_LB_POPULATE_END:
        {
            _bLBPopulated = TRUE;
        }
        break;


        case WM_CLOSE:
        {
            EndDialog(hwndDlg, IDCANCEL);
        }
        break;

        case WM_NOTIFY:
        {
            if(UI_IDC_SERVERS_TREE == wParam &&
               _bLBPopulated)
            {
                LPNMHDR pnmh = (LPNMHDR) lParam;
                if(pnmh)
                {
                    if(pnmh->code == NM_DBLCLK)
                    {
                        //
                        // If the current selection is a server
                        // then we're done
                        //
                        if(_pBrowseSrvCtl->GetServer( m_szServer,
                                      sizeof(m_szServer)/sizeof(TCHAR)))
                        {
                            EndDialog( hwndDlg, IDOK );
                            rc = TRUE;
                        }
                        else
                        {
                            _tcscpy( m_szServer, _T(""));
                        }
                    }
                }

                return _pBrowseSrvCtl->OnNotify( hwndDlg, wParam, lParam );
            }
        }
        break;

        case WM_COMMAND:
        {
            switch(DC_GET_WM_COMMAND_ID(wParam))
            {
                case IDCANCEL:
                {
                    EndDialog(hwndDlg, IDCANCEL);
                    rc = TRUE;
                }
                break;
                
                case IDOK:
                {
                    if(_pBrowseSrvCtl->GetServer( m_szServer,
                                          sizeof(m_szServer)/sizeof(TCHAR) ))
                    {
                        EndDialog(hwndDlg, IDOK);
                    }
                    else
                    {
                        EndDialog(hwndDlg, IDCANCEL);

                    }

                    rc = TRUE;
                }
                break;
            }
        }
        break;

        case WM_DESTROY:
        {
            /* Since we are in WM_DESTROY signal to the worker thread to discontinue. */
            if(_hEvent)
            {
                SetEvent(_hEvent);
            }
            rc = FALSE;
        }
        break;
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\snapin\comp.h ===
// Comp.h : Declaration of the CComp
//          The View class
//
//          The view is per console

#ifndef __COMP_H_
#define __COMP_H_

#include <mmc.h>

class CConNode;
class CComp;
//
// Defered connection info
//
typedef struct tagTSSNAPIN_DEFER_CONNECT
{
    CComp*    pComponent;
    CConNode* pConnectionNode;
} TSSNAPIN_DEFER_CONNECT, *PTSSNAPIN_DEFER_CONNECT;


class ATL_NO_VTABLE CComp : 
        public CComObjectRootEx<CComSingleThreadModel>,
        public IExtendContextMenu,
        public IComponent,
        public IPersistStreamInit   
{
    public:
    DECLARE_NOT_AGGREGATABLE( CComp )

    BEGIN_COM_MAP( CComp )
        COM_INTERFACE_ENTRY( IComponent )
        COM_INTERFACE_ENTRY( IExtendContextMenu )
        COM_INTERFACE_ENTRY( IPersistStreamInit )
    END_COM_MAP()

    public:
    CComp();
    ~CComp();
    STDMETHOD( Initialize )( LPCONSOLE );
    STDMETHOD( Notify )( LPDATAOBJECT , MMC_NOTIFY_TYPE , LPARAM , LPARAM );
    STDMETHOD( Destroy )( MMC_COOKIE  );
    STDMETHOD( GetResultViewType )( MMC_COOKIE , LPOLESTR* , PLONG );
    STDMETHOD( QueryDataObject )( MMC_COOKIE , DATA_OBJECT_TYPES , LPDATAOBJECT* );
    STDMETHOD( GetDisplayInfo )( LPRESULTDATAITEM );
    STDMETHOD( CompareObjects )( LPDATAOBJECT , LPDATAOBJECT );
    
    HRESULT OnShow( LPDATAOBJECT , BOOL );
    HRESULT InsertItemsinResultPane( );
    HRESULT AddSettingsinResultPane( );
    HRESULT OnSelect( LPDATAOBJECT , BOOL , BOOL );
    HRESULT SetCompdata( CCompdata * );

    // IPersistStreamInit
    STDMETHOD(GetClassID)(CLSID *pClassID)
    {
        UNREFERENCED_PARAMETER(pClassID);
        ATLTRACENOTIMPL(_T("CCOMP::GetClassID"));
    }   

    STDMETHOD(IsDirty)()
    {
        //
        // The implementation is CCompdata::IsDirty will do all the work
        //
        return S_FALSE;
    }

    STDMETHOD(Load)(IStream *pStm)
    {
        UNREFERENCED_PARAMETER(pStm);
        ATLTRACE(_T("CCOMP::Load"));
        return S_OK;
    }

    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty)
    {
        UNREFERENCED_PARAMETER(pStm);
        UNREFERENCED_PARAMETER(fClearDirty);
        ATLTRACE(_T("CCOMP::Save"));
        return S_OK;
    }

    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize)
    {
        UNREFERENCED_PARAMETER(pcbSize);
        ATLTRACENOTIMPL(_T("CCOMP::GetSizeMax"));
    }

    STDMETHOD(InitNew)()
    {
        ATLTRACE(_T("CCOMP::InitNew\n"));
        return S_OK;
    }

    HRESULT ConnectWithNewSettings(IMsRdpClient* pTS, CConNode* pConNode);

    //IExtendContextMenu
    STDMETHOD( AddMenuItems )( LPDATAOBJECT , LPCONTEXTMENUCALLBACK , PLONG );
    STDMETHOD( Command )( LONG , LPDATAOBJECT );

private:
    BOOL OnAddImages( );
    BOOL OnHelp( LPDATAOBJECT );
    HWND    GetMMCMainWindow();
    BOOL GiveFocusToControl(IMsRdpClient* pTs);

    CCompdata *m_pCompdata;
    LPIMAGELIST m_pImageResult;
    IConsole  *m_pConsole;
    BOOL       m_bFlag;

    OLECHAR   m_wszConnectingStatus[MAX_PATH];
    OLECHAR   m_wszConnectedStatus[MAX_PATH];
    OLECHAR   m_wszDisconnectedStatus[MAX_PATH];

    LPCONSOLEVERB m_pConsoleVerb;
    LPDISPLAYHELP m_pDisplayHelp;

    //
    // Has autoconnection of first
    // selected node been triggered
    //
    BOOL        m_bTriggeredFirstAutoConnect;
};


#endif //__COMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\snapin\basenode.h ===
#ifndef _BASENODE_H
#define _BASENODE_H

#include<mmc.h>


static const GUID GUID_MainNode = { /* 94759c36-36ec-46bf-b63a-613013ed1162 */
    0x94759c36,
    0x36ec,
    0x46bf,
    {0xb6, 0x3a, 0x61, 0x30, 0x13, 0xed, 0x11, 0x62}
  };


enum nodeType
	{ MAIN_NODE = 1 , CONNECTION_NODE, UNDEF_NODE };

class  CBaseNode :
	public IDataObject
{
    ULONG m_cref;
	nodeType m_nNodeType;

public:


    CBaseNode( );

    virtual ~CBaseNode( ) { }

    STDMETHOD( QueryInterface )( REFIID , PVOID * );

    STDMETHOD_( ULONG , AddRef )(  );

    STDMETHOD_( ULONG , Release )( );

    // IDataObject

    STDMETHOD( GetData )( LPFORMATETC , LPSTGMEDIUM );

    STDMETHOD( GetDataHere )( LPFORMATETC , LPSTGMEDIUM );

    STDMETHOD( QueryGetData )( LPFORMATETC );

    STDMETHOD( GetCanonicalFormatEtc )( LPFORMATETC , LPFORMATETC );

    STDMETHOD( SetData )( LPFORMATETC , LPSTGMEDIUM , BOOL );

    STDMETHOD( EnumFormatEtc )( DWORD , LPENUMFORMATETC * );

    STDMETHOD( DAdvise )( LPFORMATETC , ULONG , LPADVISESINK , PULONG );

    STDMETHOD( DUnadvise )( DWORD );

    STDMETHOD( EnumDAdvise )( LPENUMSTATDATA * );

    // BaseNode methods are left to the derived object

	void SetNodeType( nodeType nNodeType )
	{
		m_nNodeType = nNodeType;
	}

	nodeType GetNodeType( void )
	{
		return m_nNodeType;
	}


    virtual BOOL AddMenuItems( LPCONTEXTMENUCALLBACK , PLONG ) { return FALSE; }

    virtual DWORD GetImageIdx( ){ return 0; }
};

#endif // _BASENODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\snapin\comp.cpp ===
//comp.cpp: ts mmc snapin implementaion of IComponent
//Copyright (c) 1999 - 2000 Microsoft Corporation
//nadima
//

#include "stdafx.h"
#include "tsmmc.h"
#include "compdata.h"
#include "comp.h"
#include "connode.h"
#include "property.h"

#define MSTSC_MULTI_HOST_CONTROL L"{85C67146-6932-427C-A6F2-43FDBADF2BFC}"
#define IMAGE_MACHINE   1
#define IMAGE_CONNECTED_MACHINE 2
#define IMAGE_MACHINES  3

CComp::CComp()
{
    m_pConsole = NULL;
    m_pCompdata = NULL;
    m_bFlag     = FALSE;
    m_pImageResult = NULL;
    m_pConsoleVerb = NULL;
    m_pDisplayHelp = NULL;
    m_bTriggeredFirstAutoConnect = FALSE;
}

//
// Destructor
//
CComp::~CComp()
{
}

STDMETHODIMP CComp::Initialize( LPCONSOLE pConsole)
{
    HRESULT hr;
    USES_CONVERSION;

    if (m_pConsole) {
        m_pConsole->Release();
    }
    m_pConsole = pConsole;
    m_pConsole->AddRef();

    if (FAILED((hr = m_pConsole->QueryResultImageList( &m_pImageResult ))))
    {
        return hr;
    }

    if ( FAILED((hr = m_pConsole->QueryConsoleVerb( &m_pConsoleVerb))))
    {
        return hr;
    }

    if( FAILED((hr = m_pConsole->QueryInterface( IID_IDisplayHelp, (LPVOID *)&m_pDisplayHelp))))
    {
        return hr;
    }

    //
    // Load connecting text
    //
    TCHAR sz[MAX_PATH];
    if(!LoadString(_Module.GetResourceInstance(),
              IDS_STATUS_CONNECTING,
              sz,
              SIZE_OF_BUFFER( m_wszConnectingStatus )))
    {
        return E_FAIL;
    }
    OLECHAR* wszConnecting = T2OLE(sz);
    if(wszConnecting)
    {
        wcsncpy(m_wszConnectingStatus, wszConnecting,
                SIZE_OF_BUFFER( m_wszConnectingStatus ));
    }
    else
    {
        return E_FAIL;
    }

    //
    // Load connected text
    //
    if(!LoadString(_Module.GetResourceInstance(),
              IDS_STATUS_CONNECTED,
              sz,
              SIZE_OF_BUFFER( m_wszConnectedStatus )))
    {
        return E_FAIL;
    }
    OLECHAR* wszConnected = T2OLE(sz);
    if(wszConnected)
    {
        wcsncpy(m_wszConnectedStatus, wszConnected,
                SIZE_OF_BUFFER( m_wszConnectedStatus ));
    }
    else
    {
        return E_FAIL;
    }

    //
    // Load disconnected text
    //
    if(!LoadString(_Module.GetResourceInstance(),
              IDS_STATUS_DISCONNECTED,
              sz,
              SIZE_OF_BUFFER( m_wszDisconnectedStatus )))
    {
        return E_FAIL;
    }

    OLECHAR* wszDiscon = T2OLE(sz);
    if(wszDiscon)
    {
        wcsncpy(m_wszDisconnectedStatus, wszDiscon,
                SIZE_OF_BUFFER( m_wszDisconnectedStatus ));
    }
    else
    {
        return E_FAIL;
    }

    return S_OK;
}

//--------------------------------------------------------------------------------------------------
STDMETHODIMP CComp::Notify( LPDATAOBJECT pDataObj , MMC_NOTIFY_TYPE event, LPARAM arg , LPARAM )
{
    switch ( event )
    {
    case MMCN_ACTIVATE:
        ODS( L"IComponent -- MMCN_ACTIVATE\n" );
        break;

    case MMCN_ADD_IMAGES:
        ODS( L"IComponent -- MMCN_ADD_IMAGES\n" );
        OnAddImages( );
        break;

    case MMCN_BTN_CLICK:
        ODS( L"IComponent -- MMCN_BTN_CLICK\n" );
        break;

    case MMCN_CLICK:
        ODS( L"IComponent -- MMCN_CLICK\n" );
        break;

    case MMCN_DBLCLICK:
        ODS( L"IComponent -- MMCN_DBLCLICK\n" );
        return S_FALSE;

    case MMCN_DELETE:
        ODS( L"IComponent -- MMCN_DELETE\n" );
        break;

    case MMCN_EXPAND:
        ODS( L"IComponent -- MMCN_EXPAND\n" );
        break;

    case MMCN_MINIMIZED:
        ODS( L"IComponent -- MMCN_MINIMIZED\n" );
        break;

    case MMCN_PROPERTY_CHANGE:
        ODS( L"IComponent -- MMCN_PROPERTY_CHANGE\n" );
        break;

    case MMCN_REMOVE_CHILDREN:
        ODS( L"IComponent -- MMCN_REMOVE_CHILDREN\n" );
        break;

    case MMCN_REFRESH:
        ODS( L"IComponent -- MMCN_REFRESH\n" );
        break;

    case MMCN_RENAME:
        ODS( L"IComponent -- MMCN_RENAME\n" );
        break;

    case MMCN_SELECT:
        ODS( L"IComponent -- MMCN_SELECT\n" );
        if(!IS_SPECIAL_DATAOBJECT(pDataObj))
        {
            OnSelect( pDataObj , ( BOOL )LOWORD( arg ) , ( BOOL )HIWORD( arg ) );
        }
        break;

    case MMCN_SHOW:
        OnShow( pDataObj , ( BOOL )arg );
        ODS( L"IComponent -- MMCN_SHOW\n" );
        break;

    case MMCN_VIEW_CHANGE:
        ODS( L"IComponent -- MMCN_VIEW_CHANGE\n" );
        break;

    case MMCN_CONTEXTHELP:
        ODS( L"IComponent -- MMCN_CONTEXTHELP\n" );
        OnHelp( pDataObj );
        break;

    case MMCN_SNAPINHELP:
        ODS( L"IComponent -- MMCN_SNAPINHELP\n" );
        break;
    
    default:
        ODS( L"CComp::Notify - event not registered\n" );
    }

    return S_OK;
}

//--------------------------------------------------------------------------------------------------
STDMETHODIMP CComp::Destroy( MMC_COOKIE  )
{
    if (m_pConsole) {
        m_pConsole->Release();
        m_pConsole = NULL;
    }

    if (m_pConsoleVerb) {
        m_pConsoleVerb->Release();
        m_pConsoleVerb = NULL;
    }

    if( m_pDisplayHelp != NULL ) {
        m_pDisplayHelp->Release();
        m_pDisplayHelp = NULL;
    }

    if (m_pImageResult) {
        m_pImageResult->Release();
        m_pImageResult = NULL;
    }

    return S_OK;
}


//--------------------------------------------------------------------------------------------------
STDMETHODIMP CComp::GetResultViewType(  MMC_COOKIE ck , LPOLESTR *ppOlestr , PLONG plView )
{
    //
    // For the connection nodes return the MSTSC activex multi-host client.
    // No view for the root node
    //
    CBaseNode* pNode = (CBaseNode*) ck;
    if (!ck || pNode->GetNodeType() == MAIN_NODE)
    {
        //
        // Root node
        //
        *plView = MMC_VIEW_OPTIONS_NONE;

        //
        // indicate a standard list view should be used.
        //
        return S_FALSE;
    }
    else
    {
        TCHAR tchGUID[] = MSTSC_MULTI_HOST_CONTROL;    
        *ppOlestr = ( LPOLESTR )CoTaskMemAlloc( sizeof( tchGUID ) + sizeof( TCHAR ) );
        ASSERT(*ppOlestr);
        if(!*ppOlestr)
        {
            return E_OUTOFMEMORY;
        }

        lstrcpy( ( LPTSTR )*ppOlestr , tchGUID );
        *plView = MMC_VIEW_OPTIONS_NOLISTVIEWS;
        return S_OK;
    }
}

//--------------------------------------------------------------------------------------------------
STDMETHODIMP CComp::QueryDataObject( MMC_COOKIE ck , DATA_OBJECT_TYPES dtype , LPDATAOBJECT *ppDataObject )
{
    if ( dtype == CCT_RESULT )
    {
        *ppDataObject = reinterpret_cast< LPDATAOBJECT >( ck );
        if ( *ppDataObject != NULL )
        {
            ( ( LPDATAOBJECT )*ppDataObject)->AddRef( );
        }
    }
    else if ( m_pCompdata != NULL )
    {
        return m_pCompdata->QueryDataObject( ck , dtype , ppDataObject );
    }

    return S_OK;
}

//--------------------------------------------------------------------------------------------------
STDMETHODIMP CComp::GetDisplayInfo( LPRESULTDATAITEM pItem )
{
    CBaseNode* pNode = (CBaseNode*) pItem->lParam;
    if ( pNode->GetNodeType() == CONNECTION_NODE )
    {
        CConNode* conNode = (CConNode*) pNode;
        if ( pItem->mask & RDI_STR )
        {
            pItem->str = conNode->GetDescription();
        }
        if (pItem->mask & RDI_IMAGE)
        {
            pItem->nImage = IMAGE_MACHINE;
        }
    }
    return S_OK;

}

//--------------------------------------------------------------------------
BOOL CComp::OnAddImages( )
{
    HRESULT hr;
    HICON hiconMachine  = LoadIcon( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( IDI_ICON_MACHINE ) );
    HICON hiconConnectedMachine = LoadIcon( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( IDI_ICON_CONNECTED_MACHINE ) );
    HICON hiconMachines = LoadIcon( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( IDI_ICON_MACHINES ) );

    ASSERT(m_pImageResult);
    if(!m_pImageResult)
    {
        return FALSE;
    }

    hr = m_pImageResult->ImageListSetIcon( ( PLONG_PTR  )hiconMachine , IMAGE_MACHINE );
    if (FAILED(hr))
    {
        return FALSE;
    }

    hr = m_pImageResult->ImageListSetIcon( ( PLONG_PTR )hiconConnectedMachine , IMAGE_CONNECTED_MACHINE );
    if (FAILED(hr))
    {
        return FALSE;
    }

    hr = m_pImageResult->ImageListSetIcon( ( PLONG_PTR )hiconMachines , IMAGE_MACHINES );
    if (FAILED(hr))
    {
        return FALSE;
    }

    return TRUE;
}

//----------------------------------------------------------------------            
BOOL CComp::OnHelp( LPDATAOBJECT pDo )
{
    TCHAR tchTopic[ 80 ];

    HRESULT hr = E_FAIL;

    if( pDo == NULL || m_pDisplayHelp == NULL )    
    {
        return hr;
    }

    if(LoadString(_Module.GetResourceInstance(),
                  IDS_TSCMMCHELPTOPIC,
                  tchTopic,
                  SIZE_OF_BUFFER( tchTopic )))
    {
        hr = m_pDisplayHelp->ShowTopic( tchTopic );
    }
    return ( SUCCEEDED( hr ) ? TRUE : FALSE );
}

//--------------------------------------------------------------------------------------------------
STDMETHODIMP CComp::CompareObjects( LPDATAOBJECT , LPDATAOBJECT )
{
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------------------------------
HRESULT CComp::InsertItemsinResultPane( )
{
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------------------------------
HRESULT CComp::AddSettingsinResultPane( )
{
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------------------------------
HRESULT CComp::OnSelect( LPDATAOBJECT pdo , BOOL bScope , BOOL bSelected )
{
    UNREFERENCED_PARAMETER(bScope);
    CBaseNode *pNode = static_cast< CBaseNode * >( pdo );
    if ( pNode == NULL )
    {
        return S_FALSE;
    }

    ASSERT(!IS_SPECIAL_DATAOBJECT(pdo));
    if(IS_SPECIAL_DATAOBJECT(pdo))
    {
        return E_FAIL;
    }

    if ( m_pConsoleVerb == NULL )
    {
        return E_UNEXPECTED;
    }
    
    // Item is being deselected and we're not interested currently
    if ( !bSelected )
    {
        return S_OK;
    }

    if ( pNode->GetNodeType() == CONNECTION_NODE)
    {
        //
        // Enable the delete verb for connection nodes
        //
        HRESULT hr;
        hr=m_pConsoleVerb->SetVerbState( MMC_VERB_DELETE , ENABLED , TRUE );
        if (FAILED(hr))
        {
            return hr;
        }

        hr=m_pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES , ENABLED , TRUE );
        if (FAILED(hr))
        {
            return hr;
        }

        hr=m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
        if (FAILED(hr))
        {
            return hr;
        }
    }

    return S_OK;
}


//--------------------------------------------------------------------------------------------------
HRESULT CComp::SetCompdata( CCompdata *pCompdata )
{
    m_pCompdata = pCompdata;

    return S_OK;
}


//
// Defered callback to async trigger a connection
// This works because the DeferredCallBackProc is called on MMC's main
// thread and MMC is APARTMENT threaded so we can make calls on MMC
// interfaces form this thread.
//
// This whole DeferredCallBack thing is a hack to fix #203217. Basically
// on autolaunch MMC loads the snapin and then maximizes the window which
// means we would connect at the wrong size (if option to match container
// size was chosen). This Deferred mechanism ensures MMC has the time
// to size the result pane correctly first.
//
//
//
// OnShow below sneaks a pointer to deferd connection info in idEvent
//
VOID CALLBACK DeferredCallBackProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
    PTSSNAPIN_DEFER_CONNECT pDeferredConnectInfo = NULL;
    IMsRdpClient* pTs = NULL;
    HRESULT hr  = E_FAIL;

    KillTimer( hwnd, idEvent);

    if(idEvent)
    {
        pDeferredConnectInfo = (PTSSNAPIN_DEFER_CONNECT) idEvent;
        if(pDeferredConnectInfo)
        {
            ASSERT(pDeferredConnectInfo->pComponent);
            ASSERT(pDeferredConnectInfo->pConnectionNode);

            DBGMSG(L"Triggering deferred connection on connode %p",
                pDeferredConnectInfo->pConnectionNode);

            pTs = pDeferredConnectInfo->pConnectionNode->GetTsClient();
            if(pTs)
            {
                hr = pDeferredConnectInfo->pComponent->ConnectWithNewSettings(
                        pTs, pDeferredConnectInfo->pConnectionNode);
            }

            //
            // Done with the defered connection info, free it
            //
            LocalFree( pDeferredConnectInfo );
            pDeferredConnectInfo = NULL;
        }
    }

    if(pTs)
    {
        pTs->Release();
        pTs = NULL;
    }

    DBGMSG(L"DeferredConnect status: 0x%x",hr);
}

//--------------------------------------------------------------------------
// Called when a node is selected. Manages activation of new TS client instances
// and once they are 'hot' switching back to a running instance if a node is
// reselected.
// 
//--------------------------------------------------------------------------
HRESULT CComp::OnShow( LPDATAOBJECT pDataobject , BOOL bSelect )
{
    HRESULT hr = S_FALSE;
    IUnknown* pUnk = NULL;
    IMstscMhst* pTsMultiHost = NULL;
    IMsRdpClient* pTS = NULL;
    PTSSNAPIN_DEFER_CONNECT pDeferredConnectInfo = NULL;
    HWND hwndMain = NULL;

    USES_CONVERSION;
    ODS(L"OnShow\n");

    if(!bSelect)
    {
        //
        // Don't need to do any processing for deselect
        //
        return S_OK;
    }

    //
    // Only do this for connection nodes
    //
    if (((CBaseNode*) pDataobject)->GetNodeType() == MAIN_NODE)
    {
        return S_FALSE;
    }

    CConNode* pConNode = (CConNode*) pDataobject;
    ASSERT(pConNode);
    if (!pConNode)
    {
        return S_FALSE;
    }

    if ( m_pConsole != NULL )
    {
        hr= m_pConsole->QueryResultView( ( LPUNKNOWN * )&pUnk );
        if(FAILED(hr))
        {
            goto FN_EXIT_POINT;
        }
        
        pTsMultiHost = pConNode->GetMultiHostCtl();
        if(NULL == pTsMultiHost)
        {
            hr = pUnk->QueryInterface( __uuidof(IMstscMhst), (LPVOID*) &pTsMultiHost);
            if(FAILED(hr))
            {
                goto FN_EXIT_POINT;
            }

            pConNode->SetMultiHostCtl( pTsMultiHost);
        }
        
        //We're done with the pUnk to the result view
        pUnk->Release();
        pUnk = NULL;

        ASSERT(NULL != pTsMultiHost);
        if(NULL == pTsMultiHost)
        {
            hr = E_FAIL;
            goto FN_EXIT_POINT;
        }

        //
        // If the con node is being selected then connect
        // or switch to already running instance
        //
        //
        // Connect
        //
        ODS(L"Connection node Selected...\n");

        pTS = pConNode->GetTsClient();
        if(NULL == pTS)
        {
            //Create new instance
            hr = pTsMultiHost->Add( &pTS);
            if(FAILED(hr))
            {
                goto FN_EXIT_POINT;
            }

            pConNode->SetTsClient( pTS);

            //
            // Initialize the disconnected message
            //
            hr = pTS->put_DisconnectedText(m_wszDisconnectedStatus);
            if(FAILED(hr))
            {
                goto FN_EXIT_POINT;
            }
        }

        ASSERT(NULL != pTS);
        if(NULL == pTS)
        {
            hr = E_FAIL;
            goto FN_EXIT_POINT;
        }

        hr = pTsMultiHost->put_ActiveClient( pTS);
        if(FAILED(hr))
        {
            goto FN_EXIT_POINT;
        }

        //
        //If this is the first time through and we are not connected
        //then connect
        //
        if(!pConNode->IsConnected() && !pConNode->IsConnInitialized())
        {
            if(m_bTriggeredFirstAutoConnect)
            {
                //
                // Just connect
                //
                hr = ConnectWithNewSettings( pTS, pConNode);
                if(FAILED(hr))
                {
                    goto FN_EXIT_POINT;
                }
            }
            else
            {
                // HACK!
                // Queue a defered connection
                // to work around MMC's annoying behaviour
                // of loading the snapin before it sizes itself
                // which means we connect at the wrong window
                // size.
                //
                m_bTriggeredFirstAutoConnect = TRUE;
                pDeferredConnectInfo = (PTSSNAPIN_DEFER_CONNECT)
                    LocalAlloc(LPTR, sizeof(TSSNAPIN_DEFER_CONNECT));
                if(pDeferredConnectInfo)
                {
                    pDeferredConnectInfo->pComponent = this;
                    pDeferredConnectInfo->pConnectionNode  = pConNode;
                    hwndMain = GetMMCMainWindow();
                    if(hwndMain)
                    {
                        //
                        // Note the delay is arbitrary the key thing
                        // is that timer messages are low priority so the
                        // MMC size messages should make it through first
                        //

                        //
                        // NOTE: THERE IS NO LEAK HERE
                        //       pDeferredConnectInfo is freed in the
                        //       DeferredCallBack
                        //
                        SetTimer( hwndMain,
                                  (UINT_PTR)(pDeferredConnectInfo),
                                  100, //100ms delay
                                  DeferredCallBackProc );
                    }
                    else
                    {
                        ODS(L"Unable to get MMC main window handle");
                        hr = E_FAIL;
                        if(pDeferredConnectInfo)
                        {
                            LocalFree(pDeferredConnectInfo);
                            pDeferredConnectInfo = NULL;
                        }
                        goto FN_EXIT_POINT;
                    }
                }
                else
                {
                    ODS(L"Alloc for TSSNAPIN_DEFER_CONNECT failed");
                    hr = E_OUTOFMEMORY;
                    goto FN_EXIT_POINT;
                }
            }
        }
        
        hr = S_OK;
    }

FN_EXIT_POINT:

    if(pTS)
    {
        pTS->Release();
        pTS = NULL;
    }

    if(pUnk)
    {
        pUnk->Release();
        pUnk = NULL;
    }
    
    if(pTsMultiHost)
    {
        pTsMultiHost->Release();
        pTsMultiHost = NULL;
    }
    
    return hr;
}

//
// Get the window handle to MMC's main window
//
HWND CComp::GetMMCMainWindow()
{
    HRESULT hr = E_FAIL;
    HWND hwnd = NULL;
    IConsole2* pConsole2;

    if(m_pConsole)
    {
        hr = m_pConsole->GetMainWindow( &hwnd );
        if(SUCCEEDED(hr))
        {
            return hwnd;
        }
        else
        {
            return NULL;
        }
    }
    else
    {
        return NULL;
    }
}

HRESULT CComp::ConnectWithNewSettings(IMsRdpClient* pTS, CConNode* pConNode)
{
    HRESULT hr = E_FAIL;
    IMsRdpClientSecuredSettings *pMstscSecured = NULL;
    IMsRdpClientAdvancedSettings *pAdvSettings = NULL;
    IMsTscNonScriptable *ptsns = NULL;
    IMsRdpClient2* pTsc2 = NULL;

    ASSERT(NULL != pTS);
    ASSERT(NULL != pConNode);
    if(NULL == pTS || !pConNode)
    {
        return E_POINTER;
    }

    //
    // Init con settings
    //
    if (FAILED(hr = pTS->put_Server( pConNode->GetServerName() ))) {
        DC_QUIT;
    }

    if (FAILED(hr = pTS->QueryInterface(IID_IMsRdpClient2, (void**)&pTsc2))) {

        //
        // NOT a fatal error it just means we can't use the newer features
        //
        DBGMSG( L"QueryInterface IID_IMsRdpClient2 failed: 0x%x\n", hr );
    }

    //
    // Setup the connection status string
    //
    TCHAR szConnectingStatus[MAX_PATH*2];
    _stprintf(szConnectingStatus, m_wszConnectingStatus, 
              pConNode->GetServerName());

    if(FAILED(hr = pTS->put_ConnectingText( szConnectingStatus))) {
        DC_QUIT;
    }

    if (FAILED(hr = pTS->put_FullScreenTitle( pConNode->GetServerName()))) {
        DC_QUIT;
    }

    //
    // Connected status text
    //
    if (pTsc2) {
        TCHAR szConnectedStatus[MAX_PATH*2];
        _stprintf(szConnectedStatus, m_wszConnectedStatus, 
                  pConNode->GetServerName());
        if (FAILED(hr = pTsc2->put_ConnectedStatusText(szConnectedStatus))) {
            DC_QUIT;
        }
    }

    if (pConNode->GetResType() != SCREEN_RES_FILL_MMC &&
        pConNode->GetDesktopWidth() && pConNode->GetDesktopHeight()) {

        if (FAILED(hr = pTS->put_DesktopWidth( pConNode->GetDesktopWidth()))) {
            DC_QUIT;
        }
        if (FAILED(hr = pTS->put_DesktopHeight( pConNode->GetDesktopHeight()))) {
            DC_QUIT;
        }

    }
    else if(pConNode->GetResType() == SCREEN_RES_FILL_MMC) {
        //
        // Need to fill the MMC result pane so tell the control
        // to size itself to the container by giving 0 width/height
        //
        if (FAILED(hr = pTS->put_DesktopWidth( 0))) {
            DC_QUIT;
        }
        if (FAILED(hr = pTS->put_DesktopHeight( 0))) {
            DC_QUIT;
        }
    }

    //
    // Program/Start directory
    //
    
    if(FAILED(hr = pTS->get_SecuredSettings2( &pMstscSecured))) {
        DC_QUIT;
    }

    if (FAILED(hr = pMstscSecured->put_StartProgram( pConNode->GetProgramPath() ))) {
        DC_QUIT;
    }

    if (FAILED(hr = pMstscSecured->put_WorkDir( pConNode->GetWorkDir() ))) {
        DC_QUIT;
    }
    pMstscSecured->Release();
    pMstscSecured = NULL;

    
    hr = pTS->get_AdvancedSettings2( &pAdvSettings);
    if(FAILED(hr)) {
        DC_QUIT;
    }

    if (FAILED(hr = pAdvSettings->put_RedirectDrives(
        BOOL_TO_VB(pConNode->GetRedirectDrives())))) {
        DC_QUIT;
    }

    if (FAILED(hr = pAdvSettings->put_RedirectPrinters(
        BOOL_TO_VB(TRUE)))) {
        DC_QUIT;
    }

    if (FAILED(hr = pAdvSettings->put_RedirectPorts(
        BOOL_TO_VB(TRUE)))) {
        DC_QUIT;
    }

    if (FAILED(hr = pAdvSettings->put_RedirectSmartCards(
        BOOL_TO_VB(TRUE)))) {
        DC_QUIT;
    }

    //
    // Container handled fullscreen
    //
    hr = pAdvSettings->put_ConnectToServerConsole(
        BOOL_TO_VB(pConNode->GetConnectToConsole()));
    if(FAILED(hr)) {
        DC_QUIT;
    }

    //
    // Don't allow the control to grab focus
    // the snapin will manage giving focus to a node when it switches
    // to it. This prevents problems where an obscured session steals
    // focus from another one.
    //
    hr = pAdvSettings->put_GrabFocusOnConnect( FALSE );
    if(FAILED(hr)) {
        DC_QUIT;
    }

    if (FAILED(hr = pTS->put_UserName( pConNode->GetUserName()))) {
        DC_QUIT;
    }

    if (FAILED(hr = pTS->put_Domain( pConNode->GetDomain()))) {
        DC_QUIT;
    }

    //
    // Set the password/salt
    //
    if ( pConNode->GetPasswordSpecified())
    {
        TCHAR szPass[CL_MAX_PASSWORD_LENGTH_BYTES/sizeof(TCHAR)];

        hr = pConNode->GetClearTextPass(szPass, sizeof(szPass));
        if (SUCCEEDED(hr)) {
            BSTR Pass = SysAllocString(szPass);
            if (Pass) {
                hr = pAdvSettings->put_ClearTextPassword(Pass);
                SecureZeroMemory(Pass, SysStringByteLen(Pass));
                SysFreeString(Pass);
            }
        }
        SecureZeroMemory(szPass, sizeof(szPass));
    }
    else {
        //Password is not specified, make sure logon
        //properties are reset
        hr = pTS->QueryInterface(IID_IMsTscNonScriptable, (void**)&ptsns);
        if(SUCCEEDED(hr)) {
            if (FAILED(hr = ptsns->ResetPassword())) {
                DC_QUIT;
            }
            ptsns->Release();
            ptsns = NULL;
        }
        else {
            DC_QUIT;
        }
    }

    pAdvSettings->Release();
    pAdvSettings = NULL;

    pConNode->SetConnectionInitialized(TRUE);

    //
    // Release any existing view and connect
    //
    pConNode->SetView(NULL);
    pConNode->SetView(this);

    hr = pTS->Connect( );
    if (FAILED(hr)) {
        DC_QUIT;
    }
    GiveFocusToControl(pTS);

    pConNode->SetConnected(TRUE);
    hr = S_OK;

DC_EXIT_POINT:
    if (pMstscSecured) {
        pMstscSecured->Release();
        pMstscSecured = NULL;
    }

    if (pAdvSettings) {
        pAdvSettings->Release();
        pAdvSettings = NULL;
    }

    if (ptsns) {
        ptsns->Release();
        ptsns = NULL;
    }

    if (pTsc2) {
        pTsc2->Release();
        pTsc2 = NULL;
    }

    return hr;
}

BOOL CComp::GiveFocusToControl(IMsRdpClient* pTs)
{
    IOleInPlaceActiveObject* poipa = NULL;
    HWND hwnd;
    HRESULT hr = E_FAIL;
    if(pTs)
    {
        hr = pTs->QueryInterface( IID_IOleInPlaceActiveObject,
                                  (void**)&poipa );
        if( SUCCEEDED(hr) )
        {
            hr = poipa->GetWindow( &hwnd );
            if( SUCCEEDED(hr) )
            {
                DBGMSG(L"Giving focus to control wnd: 0%p",
                       hwnd);
                SetFocus( hwnd );
            }
            else
            {
                ODS(L"poipa->GetWindow failed");
            }
            poipa->Release();
        }
    }
    return SUCCEEDED(hr);
}


//
// menu items
//
STDMETHODIMP CComp::AddMenuItems( LPDATAOBJECT pNode,
                                  LPCONTEXTMENUCALLBACK pCtxMenu,
                                  PLONG plInsertion)
{
    TCHAR tchBuffer1[ 128 ];
    TCHAR tchBuffer2[ 128 ];
    ATLASSERT( pNode != NULL );
    ATLASSERT( pCtxMenu != NULL );
    ATLASSERT( plInsertion != NULL );

    if (!pNode)
    {
        return E_FAIL;
    }

    if(IS_SPECIAL_DATAOBJECT(pNode))
    {
        return E_FAIL;
    }

    CBaseNode *pBaseNode = dynamic_cast< CBaseNode *>( pNode );
    if (!pBaseNode)
    {
        return E_FAIL;
    }

    if (pBaseNode->GetNodeType() == MAIN_NODE)
    {
        //
        // Check that insertion at the View is allowed
        //
        if (!(*plInsertion & CCM_INSERTIONALLOWED_VIEW))
        {
            return S_FALSE;
        }

        //
        // Add menu item to root node
        //
        CONTEXTMENUITEM ctxmi;
        if(!LoadString( _Module.GetResourceInstance( ) , IDS_CTXM_NEW_CONNECTION ,
                                  tchBuffer1 , SIZE_OF_BUFFER( tchBuffer1 )))
        {
            return E_OUTOFMEMORY;
        }
        ctxmi.strName = tchBuffer1;
        if(!LoadString( _Module.GetResourceInstance( ) , IDS_CTXM_STATUS_NEW_CONNECTION ,
                                  tchBuffer2 , SIZE_OF_BUFFER( tchBuffer2)))
        {
            return E_OUTOFMEMORY;
        }

        ctxmi.strStatusBarText = tchBuffer2;
        ctxmi.lCommandID = IDM_CREATECON;
        ctxmi.lInsertionPointID =  CCM_INSERTIONPOINTID_PRIMARY_TOP ;
        ctxmi.fFlags = 0;
        ctxmi.fSpecialFlags = 0;

        if (FAILED(pCtxMenu->AddItem( &ctxmi )))
        {
            return E_FAIL;
        }
    }
    else if(pBaseNode->GetNodeType() == CONNECTION_NODE)
    {
        IComponent* pOwningView = NULL;
        BOOL fBailOut = FALSE;

        //
        // Check that insertion at the view is allowed
        //
        if (!(*plInsertion & CCM_INSERTIONALLOWED_VIEW))
        {
            return S_FALSE;
        }

        //
        // Add 'Connect' menu item
        //
        CConNode* pConNode = (CConNode*) pBaseNode;
        ASSERT(pConNode);
        if(!pConNode)
        {
            return E_FAIL;
        }

        pOwningView = pConNode->GetView();

        //
        // A connected node 'belongs' to a view so don't allow
        // commands on other views to affect it
        //
        // A null pOwningView means an unowned connection
        //
        if (pOwningView && pOwningView != this)
        {
            fBailOut = TRUE;
        }

        if (pOwningView)
        {
            pOwningView->Release();
            pOwningView = NULL;
        }

        if (fBailOut)
        {
            return S_OK;
        }

        BOOL bIsTSCliConnected = CCompdata::IsTSClientConnected(pConNode);
        CONTEXTMENUITEM ctxmi;
        if(!LoadString( _Module.GetResourceInstance( ) , IDS_CTXM_CONNECT ,
                                  tchBuffer1 , SIZE_OF_BUFFER( tchBuffer1)))
        {
            return E_OUTOFMEMORY;
        }

        ctxmi.strName = tchBuffer1;
        if(!LoadString( _Module.GetResourceInstance( ) , IDS_CTXM_STATUS_CONNECT ,
                                  tchBuffer2 , SIZE_OF_BUFFER( tchBuffer2)))
        {
            return E_OUTOFMEMORY;
        }
        
        ctxmi.strStatusBarText = tchBuffer2;
        ctxmi.lCommandID = IDM_CONNECT;
        ctxmi.lInsertionPointID =  CCM_INSERTIONPOINTID_PRIMARY_TOP;
        ctxmi.fFlags = bIsTSCliConnected ? MF_GRAYED: MF_ENABLED;
        ctxmi.fSpecialFlags = 0;

        if (FAILED(pCtxMenu->AddItem( &ctxmi )))
        {
            return E_FAIL;
        }

        //
        // Add 'Disconnect' menu item
        //
        if(!LoadString( _Module.GetResourceInstance( ) , IDS_CTXM_DISCONNECT ,
                                  tchBuffer1 , SIZE_OF_BUFFER( tchBuffer1 ) ) )
        {
            return E_OUTOFMEMORY;
        }

        ctxmi.strName = tchBuffer1;
        if(!LoadString( _Module.GetResourceInstance( ) , IDS_CTXM_STATUS_DISCONNECT ,
                                  tchBuffer2 , SIZE_OF_BUFFER( tchBuffer2 )))
        {
            return E_OUTOFMEMORY;
        }
        
        ctxmi.strStatusBarText = tchBuffer2;
        ctxmi.lCommandID = IDM_DISCONNECT;
        ctxmi.lInsertionPointID =  CCM_INSERTIONPOINTID_PRIMARY_TOP;
        ctxmi.fFlags = !bIsTSCliConnected ? MF_GRAYED: MF_ENABLED;
        ctxmi.fSpecialFlags = 0;

        if (FAILED(pCtxMenu->AddItem( &ctxmi )))
        {
            return E_FAIL;
        }
    }
    return S_OK;
}


//----------------------------------------------------------------------------------------------------------
// Menu handler
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CComp::Command( LONG lCommand , LPDATAOBJECT pDo)
{
    //
    // Add a new connection...
    //
    CBaseNode *pNode = dynamic_cast< CBaseNode *>( pDo );
    HRESULT hr = S_OK;
    if (IDM_CREATECON == lCommand)
    {
        if ( m_pCompdata)
        {
            hr = m_pCompdata->AddNewConnection();
        }
        else
        {
            hr = E_FAIL;
        }
        
        return hr;
    }
    else if (IDM_CONNECT == lCommand)
    {
        //
        // Connect
        //
        if(!pNode)
        {
            return E_INVALIDARG;
        }
        else if(pNode->GetNodeType() != CONNECTION_NODE)
        {
            //
            // Can't receive a connect request for a node other
            // than a connection node
            //
            ASSERT(pNode->GetNodeType() == CONNECTION_NODE);
            return E_INVALIDARG;
        }

        CConNode* pConNode = (CConNode*) pNode;

        //
        // Select the scope node, that will call CComp::OnShow which will connect
        //

        ASSERT(m_pConsole);
        if(!m_pConsole)
        {
            return E_FAIL;
        }

        IMsRdpClient* pTS = pConNode->GetTsClient();
        if(NULL != pTS && pConNode->IsConnInitialized())
        {
            //
            // Only connect directly if the connection settings are initialized
            //

            //
            // Set view ownership
            //
            pConNode->SetView( this );
            HRESULT hr = pTS->Connect();
            if (FAILED(hr))
            {
                return hr;
            }
            pConNode->SetConnected(TRUE);
            pTS->Release();
        }
        
        //
        // Selecting the node if the con settings are not initialized
        // initializes them and connects
        //
        if(FAILED(m_pConsole->SelectScopeItem( pConNode->GetScopeID())))
        {
            return E_FAIL;
        }
        hr = S_OK;
    }
    else if (IDM_DISCONNECT == lCommand)
    {
        if(!pNode)
        {
            return E_INVALIDARG;
        }
        //
        // Disconnect
        //
        if(pNode->GetNodeType() != CONNECTION_NODE)
        {
            //
            // Can't receive a connect request for a node other
            // than a connection node
            //
            ASSERT(pNode->GetNodeType() == CONNECTION_NODE);
            return E_INVALIDARG;
        }
        
        CConNode* pConNode = (CConNode*) pNode;
        ASSERT(m_pConsole);
        if(!m_pConsole)
        {
            return E_FAIL;
        }
        
        IMsRdpClient* pTS = pConNode->GetTsClient();
        if(NULL != pTS)
        {
            HRESULT hr = pTS->Disconnect();
            if (FAILED(hr))
            {
                return hr;
            }
            pTS->Release();
        }
        pConNode->SetConnected(FALSE);
        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\snapin\basenode.cpp ===
#include "stdafx.h"
#include "tsmmc.h"
#include "basenode.h"
#include "resource.h"


extern const GUID GUID_ResultNode;

static UINT s_cfInternal;// = RegisterClipboardFormat( TEXT( "TSCC" ) );   
static UINT s_cfDisplayName;// = RegisterClipboardFormat( CCF_DISPLAY_NAME );
static UINT s_cfNodeType;// = RegisterClipboardFormat( CCF_NODETYPE );
static UINT s_cfSnapinClsid;// = RegisterClipboardFormat( CCF_SNAPIN_CLASSID );
static UINT s_cfSZNodeType;// = RegisterClipboardFormat( CCF_SZNODETYPE );
static UINT s_cfPreload;



//--------------------------------------------------------------------------
// ctor
//--------------------------------------------------------------------------
CBaseNode::CBaseNode( )
{
    // The ndmgr gets the dataobj via IComponent and then calls release
    // so dataobj should have an implicit addref

    m_cref = 1;
    if ( s_cfInternal == 0 )
    {
        s_cfInternal = RegisterClipboardFormat( TEXT( "TSC" ) );   
    }
    if ( s_cfDisplayName == 0 )
    {
        s_cfDisplayName = RegisterClipboardFormat( CCF_DISPLAY_NAME );
    }
    if ( s_cfNodeType == 0 )
    {
        s_cfNodeType = RegisterClipboardFormat( CCF_NODETYPE );
    }
    if ( s_cfSnapinClsid == 0 )
    {
        s_cfSnapinClsid = RegisterClipboardFormat( CCF_SNAPIN_CLASSID );
    }
    if ( s_cfSZNodeType == 0 )
    {
        s_cfSZNodeType = RegisterClipboardFormat( CCF_SZNODETYPE );
    }
    m_nNodeType = UNDEF_NODE;
}


//--------------------------------------------------------------------------
// Standard QI behavior
//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::QueryInterface( REFIID riid , PVOID *ppv )
{
    if ( riid == IID_IUnknown )
    {
        *ppv = ( LPUNKNOWN )this;
    }
    else if ( riid == IID_IDataObject )
    {
        *ppv = ( LPDATAOBJECT )this;
    }
    else
    {
        *ppv = NULL;

        return E_NOINTERFACE;
    }
    AddRef( );
    return S_OK;
}

//--------------------------------------------------------------------------
// Standard addref
//--------------------------------------------------------------------------
STDMETHODIMP_( ULONG )CBaseNode::AddRef(  )
{
    return InterlockedIncrement( ( LPLONG )&m_cref );
}

//--------------------------------------------------------------------------
// Same as addref no need for cs
//--------------------------------------------------------------------------
STDMETHODIMP_( ULONG )CBaseNode::Release( )
{
    if ( InterlockedDecrement( ( LPLONG )&m_cref ) == 0 )
    {
        ODS( L"CBaseNode -- Releasing Dataobj\n" );
        delete this;
        return 0;
    }
    return m_cref;
}


//--------------------------------------------------------------------------
// Trust me ndmgr will call this with a fury
//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::GetDataHere( LPFORMATETC pF , LPSTGMEDIUM pMedium)
{
    HRESULT hr = DV_E_FORMATETC;
    const CLIPFORMAT cf = pF->cfFormat;
    IStream *pStream = NULL;
    pMedium->pUnkForRelease = NULL;

    hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( SUCCEEDED( hr ) )
    {
        if (cf == s_cfDisplayName)
        {
            TCHAR szDispname[ 128 ];
            LoadString( _Module.GetResourceInstance( ) , IDS_ROOTNODE_TEXT , szDispname , SIZEOF_TCHARBUFFER( szDispname ) );
            // Include null terminator 
            hr = pStream->Write( szDispname , SIZEOF_TCHARBUFFER( szDispname )/* + sizeof( TCHAR )*/ , NULL );
        }
        else if (cf == s_cfInternal)
        {
            // The nodemgr will use this copy and pass it back to us in
            // functions such as ::Notify
            ODS( L"GetDataHere -- s_cfInternal used\n" );
            hr = pStream->Write( this , sizeof( CBaseNode ) , NULL );
        }
        else if (cf == s_cfNodeType)
        {
            const GUID *pGuid = NULL;
            if ( GetNodeType( ) == MAIN_NODE )
            {
                ODS( L"GetDataHere -- NodeType is MAIN_NODE\n" );
                pGuid = &GUID_MainNode;
            }
            else if ( GetNodeType( ) == CONNECTION_NODE )
            {
                ODS( L"GetDataHere -- NodeType is CONNECTION_NODE\n" );
                pGuid = &GUID_ResultNode;
            }
            else
            {
                ODS( L"GetDataHere -- NodeType is userdefined\n ");
                pGuid = &GUID_ResultNode;
            }
            hr = pStream->Write( ( PVOID )pGuid , sizeof( GUID ) , NULL );
        }
        else if ( cf == s_cfSZNodeType)
        {
            TCHAR szGUID[ 40 ];
            if ( GetNodeType( ) == MAIN_NODE )
            {
                StringFromGUID2( GUID_MainNode , szGUID , sizeof(szGUID)/sizeof(TCHAR));
            }
            else if ( GetNodeType( ) == CONNECTION_NODE )
            {
                StringFromGUID2( GUID_ResultNode , szGUID , sizeof(szGUID)/sizeof(TCHAR));
            }
            else
            {
                StringFromGUID2( GUID_ResultNode , szGUID , sizeof(szGUID)/sizeof(TCHAR));
            }

            // write nodetype in String format -- ok
            hr = pStream->Write( szGUID , sizeof( szGUID ) , NULL );
        }
        else if (cf == s_cfSnapinClsid)
        {
            // write out snapin's clsid
            hr = pStream->Write( &CLSID_Compdata , sizeof( CLSID ) , NULL );
        }
        else if (cf == s_cfPreload)
        {
            // We want to receive the preload notification
            BOOL bPreload = TRUE;
            hr = pStream->Write( (PVOID)&bPreload, sizeof(BOOL), NULL );
        }
        pStream->Release( );
    } // CreateStreamOnHGlobal
    return hr;
}

//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::GetData( LPFORMATETC , LPSTGMEDIUM )
{
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::QueryGetData( LPFORMATETC )
{
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::GetCanonicalFormatEtc( LPFORMATETC , LPFORMATETC )
{
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::SetData( LPFORMATETC , LPSTGMEDIUM , BOOL )
{
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::EnumFormatEtc( DWORD , LPENUMFORMATETC * )
{
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::DAdvise( LPFORMATETC , ULONG , LPADVISESINK , PULONG )
{
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::DUnadvise( DWORD )
{
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::EnumDAdvise( LPENUMSTATDATA * )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\snapin\defaults.h ===
//defaults.h: default settings

#ifndef _DEFAULTS_H_
#define _DEFAULTS_H_

#define DEFAULT_RES_WIDTH 800
#define DEFAULT_RES_HEIGHT 600

//Bounds on min/max client width/height
#define MIN_CLIENT_SIZE     200
#define MAX_CLIENT_WIDTH    1600
#define MAX_CLIENT_HEIGHT   1200


#endif //_DEFAULTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\snapin\property.cpp ===
/**MOD+**********************************************************************/
/* Module:    property.cpp                                                  */
/*                                                                          */
/* Purpose:   Class implementaion for the property sheet.                   */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1998                                  */
/*                                                                          */
/****************************************************************************/

#include "stdafx.h"
#include <property.h>
#include <prsht.h>

#include "defaults.h"
#include "validate.h"
#include "browsedlg.h"
#include "resource.h"
#include "shlwapi.h"

#define  MSG_BUF_SIZE 512

//
// Format message helpers
//
LPTSTR FormatMessageVAList(LPCTSTR pcszFormat, va_list *argList)

{
    LPTSTR  pszOutput;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                      pcszFormat,
                      0, 0,
                      reinterpret_cast<LPTSTR>(&pszOutput), 0,
                      argList) == 0)
    {
        pszOutput = NULL;
    }

    return(pszOutput);
}


LPTSTR FormatMessageVArgs(LPCTSTR pcszFormat, ...)

{
    LPTSTR      pszOutput;
    va_list     argList;

    va_start(argList, pcszFormat);
    pszOutput = FormatMessageVAList(pcszFormat, &argList);
    va_end(argList);
    return(pszOutput);
}


CProperty* CProperty::m_pthis = NULL;
CProperty::CProperty(HWND hwndOwner, HINSTANCE hInst)
{
    m_pthis = this;
    m_hWnd = hwndOwner;
    m_hInst = hInst;

    lstrcpy(m_szDescription, _T(""));
    lstrcpy(m_szServer, _T(""));
    lstrcpy(m_szUserName, _T(""));
    lstrcpy(m_szPassword, _T(""));
    lstrcpy(m_szDomain, _T(""));
    m_bChangePassword = FALSE;

    m_resType = SCREEN_RES_FROM_DROPDOWN;
    m_Width   = DEFAULT_RES_WIDTH;
    m_Height  = DEFAULT_RES_HEIGHT;

    m_bSavePassword =  FALSE;
    m_bConnectToConsole = FALSE;
    m_bRedirectDrives = TRUE;

    m_pDisplayHelp = NULL;

    m_bStartProgram = FALSE;
    lstrcpy(m_szProgramPath, _T(""));
    lstrcpy(m_szProgramStartIn, _T(""));
}

CProperty::~CProperty()
{
    if (m_pDisplayHelp) {
        m_pDisplayHelp->Release();
        m_pDisplayHelp = NULL;
    }
}

BOOL CProperty::CreateModalPropPage()
{
    // Fill the structures with info for the pages.
    PROPSHEETPAGE psp [3];
    PROPSHEETHEADER psh;

    psp[0].dwSize = sizeof (PROPSHEETPAGE);
    psp[0].dwFlags = PSP_USETITLE | PSP_HASHELP;
    psp[0].hInstance = m_hInst;
    psp[0].pszTemplate = MAKEINTRESOURCE (IDD_PROPPAGE1);
    psp[0].pszIcon = NULL;
    psp[0].pfnDlgProc = StaticPage1Proc;

    TCHAR szBuf1[MAX_PATH] = _T("");
    if (!LoadString(m_hInst, IDS_NETCON, szBuf1, MAX_PATH))
    {
        return FALSE;
    }

    psp[0].pszTitle = szBuf1;
    psp[0].lParam = 0;

    psp[1].dwSize = sizeof (PROPSHEETPAGE);
    psp[1].dwFlags = PSP_USETITLE | PSP_HASHELP;
    psp[1].hInstance = m_hInst;
    psp[1].pszTemplate = MAKEINTRESOURCE (IDD_PROPPAGE2);
    psp[1].pszIcon = NULL;
    psp[1].pfnDlgProc = StaticPage2Proc;

    TCHAR szBuf2[MAX_PATH] = _T("");
    if (!LoadString(m_hInst, IDS_CONNOPT, szBuf2, MAX_PATH))
    {
        return FALSE;
    }

    psp[1].pszTitle = szBuf2;
    psp[1].lParam = 0;

    psp[2].dwSize = sizeof (PROPSHEETPAGE);
    psp[2].dwFlags = PSP_USETITLE | PSP_HASHELP;
    psp[2].hInstance = m_hInst;
    psp[2].pszTemplate = MAKEINTRESOURCE (IDD_PROPPAGE3);
    psp[2].pszIcon = NULL;
    psp[2].pfnDlgProc = StaticPage3Proc;

    TCHAR szBuf3[MAX_PATH] = _T("");
    if (!LoadString(m_hInst, IDS_OTHERTAB, szBuf3, MAX_PATH))
    {
        return FALSE;
    }

    psp[2].pszTitle = szBuf3;
    psp[2].lParam = 0;

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    psh.hwndParent = m_hWnd;
    psh.hInstance = m_hInst;
    psh.nStartPage = 0;

    TCHAR   szProperties[MSG_BUF_SIZE];
    if (!LoadString(m_hInst, IDS_PROPERTIES_CAPTION, szProperties, MAX_PATH))
    {
        return FALSE;
    }

    //Splice in the node name: e.g 'MyServer' to make a caption like
    //'MyServer Properties'
    wsprintf(m_szCaption, szProperties, m_szDescription);  

    psh.pszCaption = m_szCaption;
    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

    return (BOOL)PropertySheet(&psh);
}

//
// Disable resolutions the system does not support
//
void CProperty::ProcessResolution(HWND hDlg)
{
    int x[] = {640, 800, 1024, 1280, 1600};
    int y[] = {480, 600, 768, 1024, 1200};

    int xRes = GetSystemMetrics(SM_CXSCREEN);
    int yRes = GetSystemMetrics(SM_CYSCREEN);

    TCHAR buf[32];
    HWND hwndListBox = GetDlgItem(hDlg, IDC_COMBO_RESOLUTIONS);
    LRESULT lr;

    for (int i = 0; i <= (NUM_RESOLUTIONS -1); i++)
    {
        if ( (xRes >= x[i]) && (yRes >= y[i]))
        {
            wsprintf(buf, L"%d x %d", x[i], y[i]);
            lr = SendMessage(hwndListBox, CB_ADDSTRING, 0,(LPARAM)(LPCTSTR) buf);
        }
    }
    return;
}

INT_PTR APIENTRY CProperty::StaticPage1Proc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    return m_pthis->Page1Proc( hDlg, message, wParam, lParam);
}
INT_PTR APIENTRY CProperty::StaticPage2Proc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    return m_pthis->Page2Proc( hDlg, message, wParam, lParam);
}
INT_PTR APIENTRY CProperty::StaticPage3Proc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    return m_pthis->Page3Proc( hDlg, message, wParam, lParam);
}

INT_PTR APIENTRY CProperty::Page1Proc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_INITDIALOG:
        {
            //Limit length of these edit boxes
            SendMessage(GetDlgItem(hDlg, IDC_DESCRIPTION), EM_LIMITTEXT, CL_MAX_DESC_LENGTH, 0);
            SendMessage(GetDlgItem(hDlg, IDC_SERVER), EM_LIMITTEXT, CL_MAX_DOMAIN_LENGTH, 0);

            SendMessage(GetDlgItem(hDlg, IDC_USERNAME), EM_LIMITTEXT, CL_MAX_USERNAME_LENGTH, 0);
            SendMessage(GetDlgItem(hDlg, IDC_PASSWORD), EM_LIMITTEXT, CL_MAX_PASSWORD_EDIT, 0);
            SendMessage(GetDlgItem(hDlg, IDC_DOMAIN), EM_LIMITTEXT, CL_MAX_DOMAIN_LENGTH, 0);

            //Save password settings
            SendMessage(GetDlgItem(hDlg, IDC_SAVE_PASSWORD), BM_SETCHECK,
                        m_bSavePassword ? (WPARAM)BST_CHECKED : (WPARAM)BST_UNCHECKED, 0);

            //Connect to console
            SendMessage(GetDlgItem(hDlg, IDC_CONNECT_TO_CONSOLE), BM_SETCHECK,
                        m_bConnectToConsole ? (WPARAM)BST_CHECKED : (WPARAM)BST_UNCHECKED, 0);

            //
            // Password edit box is disabled until the user
            // clicks on the change password button
            //
            EnableWindow(GetDlgItem(hDlg, IDC_PASSWORD), FALSE);

            //
            // Set from defaults
            //
            SetWindowText(GetDlgItem(hDlg, IDC_DESCRIPTION), m_szDescription);
            SetWindowText(GetDlgItem(hDlg, IDC_SERVER), m_szServer);

            SetWindowText(GetDlgItem(hDlg, IDC_USERNAME), m_szUserName);
            SetWindowText(GetDlgItem(hDlg, IDC_DOMAIN), m_szDomain);
            SetFocus(GetDlgItem(hDlg, IDC_SERVER));

            return TRUE;
        }
        break;
    case WM_COMMAND:
        {
            if (BN_CLICKED == HIWORD(wParam))
            {
                switch (LOWORD(wParam))
                {
                case IDC_BROWSE_SERVERS:
                    {
                        INT_PTR nResult = IDCANCEL;
                        CBrowseDlg dlg( hDlg, m_hInst);
                        nResult = dlg.DoModal();

                        if (-1 == nResult)
                        {
                            ODS(L"DialogBox failed newcondlg.cpp\n");
                        }
                        if (IDOK == nResult)
                        {
                            SetDlgItemText(hDlg, IDC_SERVER, dlg.GetServer());
                            //
                            // set connection name as well if necessary
                            //
                            TCHAR   szDesc[CL_MAX_DESC_LENGTH];
                            GetDlgItemText(hDlg, IDC_DESCRIPTION, szDesc, CL_MAX_DESC_LENGTH);
                            if (!lstrcmp(szDesc, L""))
                            {
                                SetDlgItemText(hDlg, IDC_DESCRIPTION, dlg.GetServer());
                            }
                        }
                        SetFocus(hDlg);
                    }
                    break;
                case IDC_CHANGEPASSWORD:
                    {
                        //
                        // Enable and reset the password edit field
                        //
                        EnableWindow(GetDlgItem(hDlg, IDC_PASSWORD), TRUE);
                        m_bChangePassword = TRUE;
                        SetDlgItemText(hDlg, IDC_PASSWORD, _T(""));
                    }
                    break;
                }
            }
            else if (EN_KILLFOCUS == HIWORD(wParam))
            {
                if (IDC_SERVER == LOWORD(wParam))
                {
                    //
                    // set connection name to server name if conn name is blank
                    //
                    TCHAR   szDesc[CL_MAX_DESC_LENGTH];
                    TCHAR   szServer[CL_MAX_DESC_LENGTH];

                    GetDlgItemText(hDlg, IDC_DESCRIPTION, szDesc, CL_MAX_DESC_LENGTH);

                    if (!lstrcmp(szDesc, L""))
                    {
                        GetDlgItemText(hDlg, IDC_SERVER, szServer, CL_MAX_DOMAIN_LENGTH);
                        SetDlgItemText(hDlg, IDC_DESCRIPTION, szServer);
                    }
                }
            }
            else if (EN_CHANGE == HIWORD(wParam))
            {
                if ((LOWORD(wParam) == IDC_USERNAME))
                {
                    //Handle UPN style user names
                    //by disabling the domain field if there
                    //is an @ in the username
                    TCHAR szUserName[CL_MAX_USERNAME_LENGTH];
                    BOOL fDisableDomain = FALSE;

                    GetDlgItemText( hDlg, IDC_USERNAME,
                                    szUserName, SIZEOF_TCHARBUFFER(szUserName));

                    if(!_tcsstr(szUserName, TEXT("@")))
                    {
                        fDisableDomain = TRUE;
                    }
                    EnableWindow(GetDlgItem(hDlg, IDC_DOMAIN),
                                 fDisableDomain);
                }
            }

            return TRUE;
            break; // WM_COMMAND
        }
        break;
    case WM_NOTIFY:
        {
            switch (((NMHDR FAR *)lParam)->code)
            {
            case PSN_APPLY:
            case PSN_KILLACTIVE:
                {
                    //
                    // Validate
                    //

                    if (!CValidate::Validate(hDlg, m_hInst))
                    {
                        //
                        // Prevent page from losing activation
                        //
                        return TRUE;
                    }

                    //Retrieve the data to be stored.
                    GetDlgItemText(hDlg, IDC_DESCRIPTION, m_szDescription, MAX_PATH);
                    GetDlgItemText(hDlg, IDC_SERVER, m_szServer, MAX_PATH);
                    if (!lstrcmp( m_szDescription, L""))
                    {
                        //if no description is specified. Default to the server name
                        lstrcpy(m_szDescription, m_szServer);
                    }

                    //
                    // Get user/pass/domain
                    //
                    GetDlgItemText(hDlg, IDC_USERNAME, m_szUserName, CL_MAX_USERNAME_LENGTH - 1);
                    GetDlgItemText(hDlg, IDC_PASSWORD, m_szPassword,
                                   CL_MAX_PASSWORD_LENGTH_BYTES * sizeof(TCHAR) - 1);
                    GetDlgItemText(hDlg, IDC_DOMAIN,   m_szDomain, CL_MAX_DOMAIN_LENGTH - 1);

                    if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_SAVE_PASSWORD))
                    {
                        m_bSavePassword = TRUE;
                    }
                    else
                    {
                        m_bSavePassword = FALSE;
                    }

                    m_bConnectToConsole = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_CONNECT_TO_CONSOLE));
                    return FALSE;
                }
                break;
            case PSN_HELP:
                {
                    DisplayHelp();
                }
                break; //PSN_HELP
            }
        }
        break;
    }
    return FALSE;
}

INT_PTR APIENTRY CProperty::Page2Proc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{    
    static PROPSHEETPAGE *ps;
    int x[] = {640, 800, 1024, 1280, 1600};
    int y[] = {480, 600, 768, 1024, 1200};

    switch (message)
    {
    case WM_INITDIALOG: 
        {
            //Get the machine resolution and disable options higher than that.
            ProcessResolution(hDlg);
            CheckRadioButton( hDlg, IDC_RADIO_CHOOSE_SIZE,IDC_COMBO_RESOLUTIONS,
                              IDC_RADIO_CHOOSE_SIZE + m_resType -1);

            if (SCREEN_RES_FROM_DROPDOWN==m_resType)
            {

                for (int i=0;i<NUM_RESOLUTIONS-1;i++)
                    if (m_Width == x[i])
                        break;
                SendDlgItemMessage(hDlg, IDC_COMBO_RESOLUTIONS, CB_SETCURSEL, (WPARAM)i,(LPARAM) 0);
                SendMessage(hDlg, WM_COMMAND, MAKELONG(IDC_RADIO_CHOOSE_SIZE,BN_CLICKED), 0L);
            }
            else if (SCREEN_RES_CUSTOM == m_resType)
            {
                SendDlgItemMessage(hDlg, IDC_COMBO_RESOLUTIONS, CB_SETCURSEL, (WPARAM)0,(LPARAM) 0);
                SetDlgItemInt(hDlg, IDC_EDIT_WIDTH, m_Width, FALSE);
                SetDlgItemInt(hDlg, IDC_EDIT_HEIGHT, m_Height, FALSE);
                SendMessage(hDlg, WM_COMMAND, MAKELONG(IDC_RADIO_CUSTOM_SIZE,BN_CLICKED), 0L);
            }
            else if (SCREEN_RES_FILL_MMC == m_resType)
            {
                SendDlgItemMessage(hDlg, IDC_COMBO_RESOLUTIONS, CB_SETCURSEL, (WPARAM)0,(LPARAM) 0);
                SendMessage(hDlg, WM_COMMAND, MAKELONG(IDC_RADIO_SIZE_FILL_MMC,BN_CLICKED), 0L);
            }

            return TRUE;
            break; //WM_INITDIALOG
        }
    case WM_NOTIFY:
        {
            switch (((NMHDR FAR *)lParam)->code)
            {
            case PSN_APPLY:
            case PSN_KILLACTIVE:
                {
                    if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RADIO_CHOOSE_SIZE))
                    {
                        m_resType = SCREEN_RES_FROM_DROPDOWN;
                        LRESULT i = SendDlgItemMessage(hDlg, IDC_COMBO_RESOLUTIONS,
                                                   CB_GETCURSEL, 0L, 0L);
                        if (CB_ERR != i)
                        {
                            m_Width = x[i];
                            m_Height = y[i];
                        }
                        return FALSE;
                    }
                    else if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RADIO_CUSTOM_SIZE))
                    {
                        BOOL bSuccess = FALSE;
                        int num;

                        m_resType = SCREEN_RES_CUSTOM;
                        num = GetDlgItemInt(hDlg, IDC_EDIT_WIDTH, &bSuccess, FALSE);
                        if (!bSuccess || num < MIN_CLIENT_SIZE || num > MAX_CLIENT_WIDTH)
                        {
                            goto INVALID_DESKTOP_SIZE;
                        }


                        //
                        // Client has restriction that width has to be multiple of 4
                        //
                        if (num % 4)
                        {
                            TCHAR szErrorBuf[MSG_BUF_SIZE];
                            TCHAR szTitle[MAX_PATH];
                            if (!LoadString(m_hInst, IDS_MAINWINDOWTITLE, szTitle, sizeof(szTitle)/sizeof(TCHAR)))
                            {
                                return FALSE;
                            }

                            if (!LoadString(m_hInst, IDS_WIDTH_NOT_VALID, szErrorBuf, sizeof(szErrorBuf)/sizeof(TCHAR)))
                            {
                                return FALSE;
                            }
                            MessageBox(hDlg, szErrorBuf, szTitle, MB_OK|MB_ICONSTOP);
                            //
                            // prevent the page from losing focus
                            //
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
                            return TRUE;
                        }

                        m_Width = num;

                        num = GetDlgItemInt(hDlg, IDC_EDIT_HEIGHT, &bSuccess, FALSE);
                        if (!bSuccess || num < MIN_CLIENT_SIZE || num > MAX_CLIENT_HEIGHT)
                        {
                            goto INVALID_DESKTOP_SIZE;
                        }

                        m_Height = num;
                        return FALSE;

INVALID_DESKTOP_SIZE:
                        TCHAR szErrorBuf[MSG_BUF_SIZE];
                        LPTSTR szFormattedErrorBuf = NULL;
                        TCHAR szTitle[MAX_PATH];
                        if (!LoadString(m_hInst, IDS_MAINWINDOWTITLE, szTitle, sizeof(szTitle)/sizeof(TCHAR)))
                        {
                            return FALSE;
                        }

                        if (!LoadString(m_hInst, IDS_INVALID_WIDTH_HEIGHT, szErrorBuf, sizeof(szErrorBuf)/sizeof(TCHAR)))
                        {
                            return FALSE;
                        }
                        int res[] = {
                            MIN_CLIENT_SIZE,
                            MIN_CLIENT_SIZE,
                            MAX_CLIENT_WIDTH,
                            MAX_CLIENT_HEIGHT};

                        szFormattedErrorBuf = FormatMessageVArgs(szErrorBuf,
                                                                 MIN_CLIENT_SIZE,
                                                                 MIN_CLIENT_SIZE,
                                                                 MAX_CLIENT_WIDTH,
                                                                 MAX_CLIENT_HEIGHT);
                        if (szFormattedErrorBuf)
                        {
                            MessageBox(hDlg, szFormattedErrorBuf, szTitle, MB_OK|MB_ICONSTOP);
                            LocalFree(szFormattedErrorBuf);
                            szFormattedErrorBuf = NULL;
                        }
                        
                        //
                        // prevent the page from losing focus
                        //
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
                        return TRUE;
                    }
                    else
                    {
                        m_resType = SCREEN_RES_FILL_MMC;
                        m_Width = 0;
                        m_Height = 0;
                        return FALSE;
                    }
                }
                break;
            case PSN_HELP:
                {
                    DisplayHelp();
                }
                break;
            }
            break; // WM_NOTIFY
        }

    case WM_COMMAND:
        {
            if (BN_CLICKED == HIWORD(wParam))
            {
                if (IDC_RADIO_CHOOSE_SIZE == (int) LOWORD(wParam))
                {
                    if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RADIO_CHOOSE_SIZE))
                    {
                        EnableWindow(GetDlgItem(hDlg, IDC_COMBO_RESOLUTIONS), TRUE);
                        SetFocus(GetDlgItem(hDlg, IDC_COMBO_RESOLUTIONS));

                        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_WIDTH), FALSE);
                        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_HEIGHT), FALSE);

                        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_WIDTH), FALSE);
                        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_HEIGHT), FALSE);
                    }
                }
                else if (IDC_RADIO_CUSTOM_SIZE == (int) LOWORD(wParam))
                {
                    if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RADIO_CUSTOM_SIZE))
                    {
                        EnableWindow(GetDlgItem(hDlg, IDC_COMBO_RESOLUTIONS), FALSE);
                        SetFocus(GetDlgItem(hDlg, IDC_EDIT_WIDTH));

                        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_WIDTH), TRUE);
                        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_HEIGHT), TRUE);

                        //
                        // Initialize defaults for widht/height
                        //

                        BOOL bSuccess = FALSE;
                        GetDlgItemInt(hDlg, IDC_EDIT_WIDTH, &bSuccess, FALSE);
                        if (!bSuccess)
                        {
                            SetDlgItemInt(hDlg, IDC_EDIT_WIDTH, DEFAULT_RES_WIDTH ,FALSE);
                        }

                        bSuccess = FALSE;
                        GetDlgItemInt(hDlg, IDC_EDIT_HEIGHT, &bSuccess, FALSE);
                        if (!bSuccess)
                        {
                            SetDlgItemInt(hDlg, IDC_EDIT_HEIGHT, DEFAULT_RES_HEIGHT ,FALSE);
                        }

                        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_WIDTH), TRUE);
                        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_HEIGHT), TRUE);
                    }
                }
                else if (IDC_RADIO_SIZE_FILL_MMC == (int) LOWORD(wParam))
                {
                    if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RADIO_SIZE_FILL_MMC))
                    {
                        EnableWindow(GetDlgItem(hDlg, IDC_COMBO_RESOLUTIONS), FALSE);

                        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_WIDTH), FALSE);
                        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_HEIGHT), FALSE);

                        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_WIDTH), FALSE);
                        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_HEIGHT), FALSE);
                    }
                }


            }

            break; //WM_COMMAND
        }

    }
    return FALSE;
}

INT_PTR APIENTRY CProperty::Page3Proc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static PROPSHEETPAGE *ps;

    switch (message)
    {
    case WM_INITDIALOG:
        {
            SendMessage(GetDlgItem(hDlg, IDC_APP), EM_LIMITTEXT, MAX_PATH, 0);
            SendMessage(GetDlgItem(hDlg, IDC_WORKDIR), EM_LIMITTEXT, MAX_PATH, 0);

            SetDlgItemText(hDlg, IDC_APP, m_szProgramPath);
            SetDlgItemText(hDlg, IDC_WORKDIR, m_szProgramStartIn);

            EnableWindow(GetDlgItem(hDlg, IDC_APP), m_bStartProgram);
            EnableWindow(GetDlgItem(hDlg, IDC_WORKDIR), m_bStartProgram);
            EnableWindow(GetDlgItem(hDlg, IDC_SPECIFY_APP_TEXT), m_bStartProgram);
            EnableWindow(GetDlgItem(hDlg, IDC_WORKDIR_STATIC), m_bStartProgram);
            SendMessage(GetDlgItem(hDlg, IDC_SPECIFY_APP), BM_SETCHECK,
                        m_bStartProgram ? 
                        (WPARAM)BST_CHECKED : (WPARAM)BST_UNCHECKED, 0);

            
            SendMessage(GetDlgItem(hDlg, IDC_REDIRECT_DRIVES), BM_SETCHECK,
                        m_bRedirectDrives ? 
                        (WPARAM)BST_CHECKED : (WPARAM)BST_UNCHECKED, 0);
            return TRUE;
            break; //WM_INITDIALOG
        }
    case WM_HELP:
        {
            //PopContextHelp(lParam);
            return TRUE;
            break;
        }
    case WM_COMMAND:
        {
            if (BN_CLICKED == HIWORD(wParam))
            {
                if (IDC_SPECIFY_APP == (int) LOWORD(wParam))
                {
                    BOOL fChecked = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_SPECIFY_APP));
                    EnableWindow(GetDlgItem(hDlg, IDC_APP), fChecked);
                    EnableWindow(GetDlgItem(hDlg, IDC_WORKDIR), fChecked);
                    EnableWindow(GetDlgItem(hDlg, IDC_SPECIFY_APP_TEXT), fChecked);
                    EnableWindow(GetDlgItem(hDlg, IDC_WORKDIR_STATIC), fChecked);

                    if (fChecked)
                    {
                        SetFocus(GetDlgItem(hDlg, IDC_APP));
                        SendMessage(GetDlgItem(hDlg, IDC_APP), 
                                    EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                    }
                    else
                    {
                        SetDlgItemText(hDlg, IDC_APP, TEXT(""));
                        SetDlgItemText(hDlg, IDC_WORKDIR, TEXT(""));
                    }
                }
            }
            break; //WM_COMMAND
        }

    case WM_NOTIFY:
        {
            switch (((NMHDR FAR *)lParam)->code)
            {
            case PSN_KILLACTIVE:
                {
                    if (BST_CHECKED != IsDlgButtonChecked(hDlg, IDC_SPECIFY_APP))
                    {
                        lstrcpy(m_szProgramPath, _T(""));
                        lstrcpy(m_szProgramStartIn, _T(""));
                        m_bStartProgram = FALSE;
                    }
                    else
                    {
                        GetDlgItemText(hDlg, IDC_APP, m_szProgramPath, MAX_PATH - 1);
                        GetDlgItemText(hDlg, IDC_WORKDIR, m_szProgramStartIn, MAX_PATH - 1);
                        m_bStartProgram = TRUE;
                    }

                    m_bRedirectDrives = (BST_CHECKED ==
                                         IsDlgButtonChecked(hDlg, IDC_REDIRECT_DRIVES));

                }
                break; //PSN_KILLACTIVE
            case PSN_HELP:
                {
                    DisplayHelp();
                }
                break; //PSN_HELP
            }
        }
        break; //WM_NOTIFY
    } // switch(message)
    return FALSE;
}

void CProperty::SetDisplayHelp(LPDISPLAYHELP lpHelp)
{
    if (lpHelp)
    {
        if (m_pDisplayHelp) {
            m_pDisplayHelp->Release();
            m_pDisplayHelp = NULL;
        }

        m_pDisplayHelp = lpHelp;
        lpHelp->AddRef();
    }
}

HRESULT CProperty::DisplayHelp()
{
    TCHAR tchTopic[ 80 ];
    HRESULT hr = E_FAIL;

    if ( m_pDisplayHelp == NULL )
    {
        return hr;
    }

    if (LoadString(_Module.GetResourceInstance(),
                   IDS_TSCMMCHELP_PROPS,
                   tchTopic,
                   SIZE_OF_BUFFER( tchTopic )))
    {
        hr = m_pDisplayHelp->ShowTopic( tchTopic );
    }
    return( SUCCEEDED( hr ) ? TRUE : FALSE );
}

BOOL CProperty::GetPasswordSpecified()
{
    BOOL fPasswordSpecified = FALSE;

    if (_tcslen(m_szPassword) != 0)
    {
        fPasswordSpecified = TRUE;
    }

    return fPasswordSpecified;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\snapin\connode.h ===
//connode.h: connection node
#ifndef _connode_h_
#define _connode_h_

#include <wincrypt.h>
#include "basenode.h"


//
// Version number for the persistance info that is written for each connode
// this is important for forward compatability.. New versions should bump
// this count up and handle downward compatability cases.
//
#define CONNODE_PERSIST_INFO_VERSION                8

// Important version numbers for backwards compatability
#define CONNODE_PERSIST_INFO_VERSION_DOTNET_BETA3   7
#define CONNODE_PERSIST_INFO_VERSION_WHISTLER_BETA1 6
#define CONNODE_PERSIST_INFO_VERSION_TSAC_RTM       5
#define CONNODE_PERSIST_INFO_VERSION_TSAC_BETA      3


//
// Screen resolution settings
//

#define SCREEN_RES_FROM_DROPDOWN 1
#define SCREEN_RES_CUSTOM        2
#define SCREEN_RES_FILL_MMC      3

#define NUM_RESOLUTIONS 5

class CConNode : public CBaseNode
{
public:
    CConNode();
    ~CConNode();
    
    BOOL	SetServerName( LPTSTR szServerName);
    LPTSTR	GetServerName()	{return m_szServer;}
    
    BOOL	SetDescription( LPTSTR szDescription);
    LPTSTR	GetDescription()	{return m_szDescription;}
    
    BOOL	SetUserName( LPTSTR szUserName);
    LPTSTR	GetUserName()	{return m_szUserName;}
    
    BOOL    GetPasswordSpecified()  {return m_fPasswordSpecified;}
    VOID    SetPasswordSpecified(BOOL f) {m_fPasswordSpecified = f;}
    
    //
    //	Return the password in encrypted form
    //
    BOOL	SetDomain( LPTSTR szDomain);
    LPTSTR	GetDomain(){return m_szDomain;}
    
    VOID	SetAutoLogon( BOOL bAutoLogon) {m_bAutoLogon = bAutoLogon;}
    BOOL	IsAutoLogon() {return m_bAutoLogon;}
    
    VOID    SetSavePassword(BOOL fSavePass) {m_bSavePassword = fSavePass;}
    BOOL    GetSavePassword()  {return m_bSavePassword;}
    
    BOOL	IsConnected()	{return m_bConnected;}
    void	SetConnected(BOOL bCon)	{m_bConnected=bCon;}
    
    
    //
    // Screen res selection type
    //
    int     GetResType()    {return m_resType;}
    void    SetResType(int r)    {m_resType = r;}
    
    //
    // Return client width/height from the screen res setting
    //
    int	    GetDesktopWidth()	{return m_Width;}
    int	    GetDesktopHeight()	{return m_Height;}
    
    void	SetDesktopWidth(int i)	{m_Width = i;}
    void	SetDesktopHeight(int i)	{m_Height = i;}
    
    LPTSTR	GetProgramPath()	{return m_szProgramPath;}
    void	SetProgramPath(LPTSTR sz)	{lstrcpy(m_szProgramPath,sz);}
    
    LPTSTR  GetWorkDir()		{return m_szProgramStartIn;}
    void	SetWorkDir(LPTSTR sz)		{lstrcpy(m_szProgramStartIn,sz);}
    
    void	SetScopeID(HSCOPEITEM scopeID)	{m_scopeID = scopeID;}
    HSCOPEITEM	GetScopeID()				{return m_scopeID;}
    
    VOID    SetConnectToConsole(BOOL bConConsole) {m_bConnectToConsole = bConConsole;}
    BOOL    GetConnectToConsole()           {return m_bConnectToConsole;}
    
    VOID    SetRedirectDrives(BOOL b)  {m_bRedirectDrives = b;}
    BOOL    GetRedirectDrives()        {return m_bRedirectDrives;}
    
    //
    // Stream Persistance support
    //
    HRESULT	PersistToStream( IStream* pStm);
    HRESULT	InitFromStream( IStream* pStm);
    
    //
    // Connection initialized
    //
    BOOL	IsConnInitialized()	{return m_bConnectionInitialized;}
    void	SetConnectionInitialized(BOOL bCon)	{m_bConnectionInitialized=bCon;}
    
    IMsRdpClient*   GetTsClient();
    void        SetTsClient(IMsRdpClient* pTs);
    
    IMstscMhst* GetMultiHostCtl();
    void        SetMultiHostCtl(IMstscMhst* pMhst);
    
    //
    // Return the view interface this control is hosted on
    //
    IComponent* GetView();
    void        SetView(IComponent* pView);

    HRESULT SetClearTextPass(LPCTSTR szClearPass);
    HRESULT GetClearTextPass(LPTSTR szBuffer, INT cbLen);


private:
    BOOL        DataProtect(PBYTE pInData, DWORD cbLen, PBYTE* ppOutData, PDWORD pcbOutLen);
    BOOL        DataUnprotect(PBYTE pInData, DWORD cbLen, PBYTE* ppOutData, PDWORD pcbOutLen);

    HRESULT     ReadProtectedPassword(IStream* pStm);
    HRESULT     WriteProtectedPassword(IStream* pStm);

private:
    TCHAR	m_szServer[MAX_PATH];
    TCHAR	m_szDescription[MAX_PATH];
    TCHAR	m_szUserName[CL_MAX_USERNAME_LENGTH];
    TCHAR	m_szDomain[CL_MAX_DOMAIN_LENGTH];
    BOOL	m_bAutoLogon;
    BOOL    m_bSavePassword;
    
    BOOL	m_bConnected;
    BOOL	m_bConnectionInitialized;
    
    TCHAR	m_szProgramPath[MAX_PATH];
    TCHAR	m_szProgramStartIn[MAX_PATH];
    
    BOOL    m_bConnectToConsole;
    BOOL    m_bRedirectDrives;
    
    //
    // Screen resolution settings
    //
    int m_resType;
    int m_Width;
    int m_Height;
    
    HSCOPEITEM	m_scopeID;
    
    //
    // Interface pointer to the Multi-host container
    //
    IMstscMhst* m_pMhostCtl;
    
    //
    // Interface pointer to the TS client control
    //
    IMsRdpClient* m_pTsClientCtl;
    
    //
    // IComponent view
    //
    IComponent* m_pIComponent;
    
    //
    // Encrypted password
    //
    DATA_BLOB   _blobEncryptedPassword;
    
    BOOL    m_fPasswordSpecified;
};

#endif // _connode_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\snapin\compdata.h ===
// Compdata.h : Declaration of the CCompdata
//
// Component data is per snapin

#ifndef __COMPDATA_H_
#define __COMPDATA_H_

#include <mmc.h>

#include "tarray.h"
#include "resource.h"       // main symbols
#include "basenode.h"
#include "connode.h"
#define ROOT_NODE_NAME_LEN	128
#define CONNECTED_IMAGE		2
#define NOT_CONNECTED_IMAGE 1



/////////////////////////////////////////////////////////////////////////////
// CCompdata
class ATL_NO_VTABLE CCompdata : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CCompdata, &CLSID_Compdata>,
    public IComponentData,
    public ISnapinAbout,
    public ISnapinHelp,
    public IPersistStreamInit,
    public IExtendPropertySheet
{
public:
    CCompdata();
    ~CCompdata();

    DECLARE_REGISTRY_RESOURCEID(IDR_TSMMCREG)
    DECLARE_NOT_AGGREGATABLE(CCompdata)

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CCompdata)
        COM_INTERFACE_ENTRY( IComponentData )
        COM_INTERFACE_ENTRY( ISnapinAbout )
        COM_INTERFACE_ENTRY( IPersistStreamInit )
        COM_INTERFACE_ENTRY( IExtendPropertySheet )
        COM_INTERFACE_ENTRY( ISnapinHelp )
    END_COM_MAP()

    // ICompdata
    public:

    STDMETHOD( CompareObjects )( LPDATAOBJECT , LPDATAOBJECT );
    STDMETHOD( GetDisplayInfo )( LPSCOPEDATAITEM );
    STDMETHOD( QueryDataObject )( MMC_COOKIE , DATA_OBJECT_TYPES , LPDATAOBJECT * );
    STDMETHOD( Notify )( LPDATAOBJECT , MMC_NOTIFY_TYPE , LPARAM , LPARAM );
    STDMETHOD( CreateComponent )( LPCOMPONENT * );
    STDMETHOD( Initialize )( LPUNKNOWN );
    STDMETHOD( Destroy )();

    // ISnapinAbout

    STDMETHOD( GetSnapinDescription )( LPOLESTR * );
    STDMETHOD( GetProvider )( LPOLESTR * );
    STDMETHOD( GetSnapinVersion )( LPOLESTR *  );
    STDMETHOD( GetSnapinImage )( HICON * );
    STDMETHOD( GetStaticFolderImage )( HBITMAP * , HBITMAP *, HBITMAP *, COLORREF * );

    STDMETHOD( GetHelpTopic( LPOLESTR *ppszHelpFile));

    BOOL ExpandScopeTree( LPDATAOBJECT , BOOL , HSCOPEITEM );

    // IPersistStreamInit

    STDMETHOD(GetClassID)(CLSID *pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);
    STDMETHOD(InitNew)();
    STDMETHOD(SetDirty)(BOOL dirty);

    // IExtendPropertySheet
    STDMETHOD( CreatePropertyPages )( LPPROPERTYSHEETCALLBACK , LONG_PTR , LPDATAOBJECT );
    STDMETHOD( QueryPagesFor )( LPDATAOBJECT );
    static BOOL IsTSClientConnected(CConNode* pConNode);
    HRESULT AddNewConnection();

private:
    HRESULT InsertConnectionScopeNode(CConNode* pNode);
    BOOL    AddImages(IImageList* pImageList );
    BOOL    OnDelete( LPDATAOBJECT pDo );
    BOOL    DeleteConnode(CConNode* pConNode);
    HRESULT EncryptAndStorePass(LPTSTR szPass, CConNode* pNode);

private:
    LPCONSOLE m_pConsole;
    LPCONSOLENAMESPACE m_pConsoleNameSpace;
    LPDISPLAYHELP      m_pDisplayHelp;
    CBaseNode *m_pMainRoot;

    //
    // If data is dirty (i.e changes made that need to be persisted) this flag is set
    //
    BOOL    m_bIsDirty;

    //
    //	ID of the root node
    // 
    HSCOPEITEM m_rootID;
    TCHAR      m_szRootNodeName[ROOT_NODE_NAME_LEN];

    CArrayT<CConNode*> m_conNodesArray;
};

#endif //__COMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\snapin\newcondlg.h ===
#ifndef _NEWCONDLG_H_
#define _NEWCONDLG_H_

//
// New connection dialog
//

class CNewConDlg
{
private:
    HWND m_hWnd;
    HINSTANCE m_hInst;

//private methods
private:
//    static void PopContextHelp(LPARAM);
    BOOL    m_bSavePassword;
    BOOL    m_bConnectToConsole;

    TCHAR   m_szServer[MAX_PATH];
    TCHAR   m_szDescription[MAX_PATH];
    TCHAR   m_szUserName[CL_MAX_USERNAME_LENGTH];
    TCHAR   m_szPassword[CL_MAX_PASSWORD_LENGTH_BYTES/sizeof(TCHAR)];
    TCHAR   m_szDomain[CL_MAX_DOMAIN_LENGTH];

public:
    CNewConDlg(HWND hWndOwner, HINSTANCE hInst);
    ~CNewConDlg();
    INT_PTR DoModal();

    static CNewConDlg* m_pThis;

    static INT_PTR APIENTRY StaticDlgProc(HWND, UINT, WPARAM, LPARAM);
    INT_PTR DlgProc(HWND, UINT, WPARAM, LPARAM);


    LPTSTR  GetServer() {return m_szServer;}
    LPTSTR  GetDescription()    {return m_szDescription;}
    
    LPTSTR  GetUserName()   {return m_szUserName;}
    LPTSTR  GetPassword()   {return m_szPassword;}
    LPTSTR  GetDomain()     {return m_szDomain;}
    BOOL    GetSavePassword() {return m_bSavePassword;}
    BOOL    GetPasswordSpecified();
    
    BOOL    GetConnectToConsole()   {return m_bConnectToConsole;}

private:
    
    void ZeroPasswordMemory() { 
        SecureZeroMemory(m_szPassword, sizeof(m_szPassword));
    }
};
#endif // _NEWCONDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\snapin\compdata.cpp ===
// Copyright Microsoft Corportation 1999-2000
// Compdata.cpp : Implementation of CCompdata
//                IComponentData interface for ts mmc snapin
// nadima
#include "stdafx.h"
#include "ntverp.h"
#include "Tsmmc.h"
#include "Compdata.h"
#include "comp.h"
#include "connode.h"
#include "newcondlg.h"


#include "property.h"

#define ICON_MACHINE           1
#define ICON_CONNECTED_MACHINE 2

#define MSRDPCLIENT_CONTROL_GUID _T("{7cacbd7b-0d99-468f-ac33-22e495c0afe5}")


/////////////////////////////////////////////////////////////////////////////
// CCompdata
//
CCompdata::CCompdata( )
{
    m_pMainRoot = NULL;
    m_rootID = 0;
    LoadString( _Module.GetResourceInstance( ) , IDS_ROOTNODE_TEXT , m_szRootNodeName,
                SIZEOF_TCHARBUFFER( m_szRootNodeName ) );
    m_bIsDirty = FALSE;

    m_pConsole = NULL;
    m_pConsoleNameSpace = NULL;
    m_pDisplayHelp = NULL;
    
}

CCompdata::~CCompdata( )
{
    if ( m_pMainRoot != NULL )
    {
        delete m_pMainRoot;
    }
}

//------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::CompareObjects( LPDATAOBJECT , LPDATAOBJECT )
{
    return E_NOTIMPL;
}

//------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::GetDisplayInfo( LPSCOPEDATAITEM pItem)
{
    CBaseNode* pNode = (CBaseNode*) pItem->lParam;
    if ( pNode->GetNodeType() == CONNECTION_NODE )
    {
        CConNode* conNode = (CConNode*) pNode;
        if ( pItem->mask & SDI_STR )
        {
            pItem->displayname = conNode->GetDescription();
        }
    }
    else if (pNode->GetNodeType() == MAIN_NODE)
    {
        if (pItem->mask & SDI_STR)
        {
            pItem->displayname = m_szRootNodeName;
        }
    }
    return S_OK;
}

//--------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::QueryDataObject( MMC_COOKIE cookie , DATA_OBJECT_TYPES type , LPDATAOBJECT *ppDataObject )
{
    *ppDataObject = NULL;

    switch ( type )
    {
    case CCT_SCOPE:     // FALL THROUGH 
    case CCT_SNAPIN_MANAGER:
        if ( cookie == 0 )
        {
            *ppDataObject = ( LPDATAOBJECT )new CBaseNode( );
            if(!*ppDataObject)
            {
                return E_OUTOFMEMORY;
            }
            ((CBaseNode*) *ppDataObject)->SetNodeType(MAIN_NODE);
        }
        else
        {
            *ppDataObject = ( LPDATAOBJECT )cookie;

            // this is the only scopenode keep this one alive

            ( ( LPDATAOBJECT )*ppDataObject)->AddRef( );
        }
        break;

    case CCT_RESULT:
        // here we can cast from cookie for each node
        break;

    case CCT_UNINITIALIZED:
        break;
    }

    return( *ppDataObject == NULL ) ? E_FAIL : S_OK ;
}

//--------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::Notify( LPDATAOBJECT pDataObj , MMC_NOTIFY_TYPE event , LPARAM arg , LPARAM param )
{
    HRESULT hr = NOERROR;
    switch ( event )
    {
    case MMCN_RENAME:
        ODS( L"IComponentdata -- MMCN_RENAME\n");
        break;

    case MMCN_EXPAND:
        ODS( L"IComponentdata -- MMCN_EXPAND\n" );
        ExpandScopeTree( pDataObj , ( BOOL ) arg , ( HSCOPEITEM )param );
        break;

    case MMCN_DELETE:
        ODS( L"IComponentdata -- MMCN_DELETE\n" );
        OnDelete( pDataObj );
        break;

    case MMCN_PROPERTY_CHANGE:
        ODS( L"IComponentdata -- MMCN_PROPERTY_CHANGE\n" );
        break;

    case MMCN_PRELOAD:
        ODS( L"PRELOAD - MMCN_PRELOAD\n");
        break;

    default:
        ODS( L"CCompdata::Notify - - event not defined!\n" );
        hr = E_NOTIMPL;
    }

    return hr;
}

//--------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::CreateComponent( LPCOMPONENT* ppComponent )
{
#ifdef ECP_TIMEBOMB
    if(!CheckTimeBomb())
    {
        return E_FAIL;
    }
#endif
    CComObject< CComp > *pComp;
    HRESULT hr = CComObject< CComp >::CreateInstance( &pComp );
    if ( SUCCEEDED( hr ) )
    {
        hr = pComp->QueryInterface( IID_IComponent , ( LPVOID *)ppComponent );
    }

    if ( SUCCEEDED( hr ) )
    {
        pComp->SetCompdata( this );
    }

    return hr;
}

//--------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::Initialize( LPUNKNOWN pUnk )
{
    HRESULT hr;
    hr = pUnk->QueryInterface( IID_IConsole , ( LPVOID *)&m_pConsole );
    if(FAILED(hr))
    {
        return hr;
    }

    hr = pUnk->QueryInterface( IID_IDisplayHelp, (LPVOID*)&m_pDisplayHelp );
    if(FAILED(hr))
    {
        return hr;
    }

    hr = pUnk->QueryInterface( IID_IConsoleNameSpace , ( LPVOID * )&m_pConsoleNameSpace );
    if(FAILED(hr))
    {
        return hr;
    }

    //
    //	Load the scope pane icons
    //
    IImageList *pImageList;
    hr = m_pConsole->QueryScopeImageList(&pImageList);
    ASSERT(S_OK == hr);
    HR_RET_IF_FAIL(hr);

    if (!AddImages( pImageList))
    {
        ODS(L"AddImages failed!\n");
        return S_FALSE;
    }
    pImageList->Release();

    if(!AtlAxWinInit())
    {
        return E_FAIL;
    }

    return hr;
}

//--------------------------------------------------------------------------
BOOL CCompdata::AddImages(IImageList* pImageList )
{
    HICON hiconMachine  = LoadIcon( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( IDI_ICON_MACHINE ) );
    HICON hiconConnectedMachine = LoadIcon( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( IDI_ICON_CONNECTED_MACHINE ) );

    HRESULT hr;

    ASSERT(pImageList);
    if (!pImageList)
    {
        return FALSE;
    }

    hr = pImageList->ImageListSetIcon( ( PLONG_PTR  )hiconMachine , ICON_MACHINE );
    if (FAILED(hr))
    {
        return FALSE;
    }

    hr = pImageList->ImageListSetIcon( ( PLONG_PTR )hiconConnectedMachine , ICON_CONNECTED_MACHINE );
    if (FAILED(hr))
    {
        return FALSE;
    }
    return TRUE;
}


//--------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::Destroy()
{
    HRESULT hr = S_OK;

    ODS(L"In CCompData::Destroy\n");
    ASSERT(m_pConsoleNameSpace);
    if(!m_pConsoleNameSpace)
    {
        return E_FAIL;
    }
    //
    // If there are any connection nodes left
    // they have to be deleted so they free
    // references to the TS control and the
    // multihost control
    //
    while(m_conNodesArray.GetSize())
    {
        CConNode** ppConNode = m_conNodesArray.GetAt(0);
        if(ppConNode)
        {

            //
            // Delete the connode and free any references
            // it has to controls
            //
            if(!DeleteConnode( *ppConNode))
            {
                hr = E_FAIL;
                goto bail_out;
            }
        }
        m_conNodesArray.DeleteItemAt(0);
    }

    hr = S_OK;
bail_out:
    if ( m_pConsole != NULL )
    {
        m_pConsole->Release( );
        m_pConsole = NULL;
    }

    if ( m_pConsoleNameSpace != NULL )
    {
        m_pConsoleNameSpace->Release( );
        m_pConsoleNameSpace = NULL;
    }

    if ( m_pDisplayHelp )
    {
        m_pDisplayHelp->Release();
        m_pDisplayHelp = NULL;
    }

    AtlAxWinTerm();

    return hr;
}

//--------------------------------------------------------------------------
BOOL CCompdata::OnDelete( LPDATAOBJECT pDo )
{
    CConNode *pNode = dynamic_cast< CConNode *>( pDo );
    if ( pNode == NULL )
    {
        ODS( L"TSCC: OnDelete, node == NULL\n");
        return FALSE;
    }

    BOOL bFound;
    int idx = m_conNodesArray.FindItem( pNode , bFound );

    HRESULT hr;
    if ( bFound )
    {
        ASSERT(m_pConsoleNameSpace);
        if(!m_pConsoleNameSpace)
        {
            return E_FAIL;
        }

        ASSERT(m_pConsole);
        if(!m_pConsole)
        {
            return E_FAIL;
        }

        if(IsTSClientConnected(pNode))
        {
            //
            // Display a warning message prompt
            // deleting a connected node
            //
            int retVal =0;

            TCHAR szSnapinName[MAX_PATH];
            TCHAR szWarnDelete[MAX_PATH];

            if(LoadString(_Module.GetResourceInstance(),
                           IDS_PROJNAME,
                           szSnapinName,
                           SIZEOF_TCHARBUFFER( szSnapinName)))
            {
                if(LoadString(_Module.GetResourceInstance(),
                               IDS_MSG_WARNDELETE,
                               szWarnDelete,
                               SIZEOF_TCHARBUFFER(szWarnDelete)))
                {
                    hr = m_pConsole->MessageBox( szWarnDelete, szSnapinName,
                                                 MB_YESNO, 
                                           &retVal);
                    if(SUCCEEDED(hr) && (IDNO == retVal))
                    {
                        //We need to bail out user selected NO
                        return TRUE;
                    }
                }
            }
        }

        //
        //	Delete the node
        //

        hr = m_pConsoleNameSpace->DeleteItem( pNode->GetScopeID(), TRUE);
        if (FAILED(hr))
        {
            return hr;
        }

        //
        // Delete the connode and free any references
        // it has to controls
        //
        DeleteConnode( pNode);


        m_conNodesArray.DeleteItemAt( idx );
    }

    m_pConsole->UpdateAllViews( ( LPDATAOBJECT )m_conNodesArray.GetAt( 0 ) , 0 , 0 );
    return TRUE;
}

//
// Delete the given connection node
// by disconnecting any connected clients
// and releasing references to any controls
//
BOOL CCompdata::DeleteConnode(CConNode* pNode)
{
    HRESULT hr = S_OK;
    BOOL fRet = TRUE;
    IMsRdpClient* pTS = NULL;
    if(!pNode)
    {
        fRet = FALSE;
        goto bail_out;
    }

    pTS = pNode->GetTsClient();
    if(NULL != pTS)
    {
        if (pNode->IsConnected())
        {
            hr = pTS->Disconnect();
        }

        if (SUCCEEDED(hr))
        {
            IMstscMhst* pMultiHost = NULL;
            pMultiHost = pNode->GetMultiHostCtl();

            //Remove references to controls to Release() them.
            pNode->SetTsClient(NULL);
            pNode->SetMultiHostCtl(NULL);

            //Remove the TS client from MultiHost control
            if(NULL != pMultiHost)
            {
                pMultiHost->Remove( pTS);
                pMultiHost->Release();
                pMultiHost = NULL;
            }
        }
        else
        {
            DBGMSG(L"Failed to disconnect: 0x%x\n", hr);
            fRet = FALSE;
        }

        pTS->Release();
        pTS = NULL;
    }

    pNode->Release();

bail_out:
    return fRet;
}

//
// Encrypt's and stores the password szPass in the connection
// node.
//
HRESULT CCompdata::EncryptAndStorePass(LPTSTR szPass, CConNode* pConNode)
{
    HRESULT hr = E_FAIL;

    if(!szPass || !pConNode) {
        return E_INVALIDARG;
    }

    hr = pConNode->SetClearTextPass(szPass);

    return hr;
}


//--------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::GetSnapinDescription( LPOLESTR * ppStr)
{
    TCHAR tchDescription[ 1024 ];
    int iCharCount = LoadString( _Module.GetResourceInstance( ) , IDS_DESCRIPTION , tchDescription , SIZE_OF_BUFFER( tchDescription ) );
    *ppStr = ( LPOLESTR )CoTaskMemAlloc( iCharCount * sizeof( TCHAR ) + sizeof( TCHAR ) );
    if ( *ppStr != NULL )
    {
        lstrcpy( *ppStr , tchDescription );
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//--------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::GetProvider( LPOLESTR * ppStr)
{
    TCHAR tchProvider[ 128 ];
    int iCharCount = LoadString( _Module.GetResourceInstance( ) , IDS_PROVIDER , tchProvider , SIZE_OF_BUFFER( tchProvider ) );
    *ppStr = ( LPOLESTR )CoTaskMemAlloc( iCharCount * sizeof( TCHAR ) + sizeof( TCHAR ) );
    if ( *ppStr != NULL )
    {
        lstrcpy( *ppStr , tchProvider );
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//--------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::GetSnapinVersion( LPOLESTR * ppStr )
{
    char chVersion[ 32 ] = VER_PRODUCTVERSION_STR;
    TCHAR tchVersion[ 32 ];
    int iCharCount = MultiByteToWideChar( CP_ACP , 0 , chVersion , sizeof( chVersion ) , tchVersion , SIZE_OF_BUFFER( tchVersion ) );
    *ppStr = ( LPOLESTR )CoTaskMemAlloc( ( iCharCount + 1 ) * sizeof( TCHAR ) );
    if ( *ppStr != NULL && iCharCount != 0 )
    {
        lstrcpy( *ppStr , tchVersion );
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//--------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::GetSnapinImage( HICON * phIcon)
{
    *phIcon = ( HICON )LoadImage( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( IDI_ICON_MACHINES )  , IMAGE_ICON , 32 ,32 , LR_DEFAULTCOLOR );
    return S_OK;
}

//--------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::GetStaticFolderImage(  HBITMAP *phSmallImage , HBITMAP *phSmallImageOpen , HBITMAP *phLargeImage, COLORREF *pClr )
{
    *phSmallImage = ( HBITMAP )LoadImage( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( UI_IDB_DOMAINEX )  , IMAGE_BITMAP , 16 ,16 , LR_DEFAULTCOLOR );
    *phSmallImageOpen = ( HBITMAP )LoadImage( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( UI_IDB_DOMAIN )  , IMAGE_BITMAP , 16 ,16 , LR_DEFAULTCOLOR );
    *phLargeImage = ( HBITMAP )LoadImage( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( UI_IDB_SERVER )  , IMAGE_BITMAP , 32 ,32 , LR_DEFAULTCOLOR );
    *pClr = RGB( 0 , 255 , 0 );
    return S_OK;
}

//----------------------------------------------------------------------------------------------------------
// MMC will ask for our help file
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::GetHelpTopic( LPOLESTR *ppszHelpFile )
{
    ODS( L"CCompdata::GetHelpTopic called\n" );

    if( ppszHelpFile == NULL )
    {
        return E_INVALIDARG;
    }

    TCHAR tchHelpFile[ MAX_PATH ];

    if(!LoadString( _Module.GetResourceInstance( ) , IDS_TSCMMCSNAPHELP , tchHelpFile , SIZE_OF_BUFFER( tchHelpFile )))
    {
        ODS( L"Error loading help file");
        return E_FAIL;
    }
  
    // mmc will call CoTaskMemFree
    *ppszHelpFile = ( LPOLESTR )CoTaskMemAlloc( sizeof( tchHelpFile ) );
    if( *ppszHelpFile != NULL )
    {
        if( GetSystemWindowsDirectory( *ppszHelpFile , MAX_PATH ) != 0 )
        {
            lstrcat( *ppszHelpFile , tchHelpFile );
        }
        else
        {
            lstrcpy( *ppszHelpFile , tchHelpFile );
        }
        ODS( *ppszHelpFile );
        ODS( L"\n" );
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//----------------------------------------------------------------------------------------------------------
// Prepareing for parent entry
BOOL CCompdata::ExpandScopeTree( LPDATAOBJECT pRoot , BOOL bExpand , HSCOPEITEM hConsole )
{   
    if ( !bExpand )
    {
        return FALSE;
    }

    CBaseNode *pNode = dynamic_cast< CBaseNode *>( pRoot );
    if ( pNode == NULL )
    {
        return FALSE;
    }

    if ( pNode->GetNodeType( ) != MAIN_NODE ) // ROOT_NODE add subscope items
    {
        return FALSE;
    }

    //
    // Keep track of the ID of the root node
    //
    m_rootID = hConsole;

    // make sure we're not re-adding
    if ( m_pMainRoot != NULL )
    {
        return TRUE;
    }

    //
    //	In the case when we we have just loaded connection node
    //	info from msc file, the new nodes have to be added to the 
    //	tree on the first expansion
    //
    for (int i=0; i<m_conNodesArray.GetSize(); i++)
    {
        CConNode** ppNode = m_conNodesArray.GetAt(i);
        if (!ppNode || *ppNode == NULL)
        {
            return S_FALSE;
        }

        if (FAILED(InsertConnectionScopeNode( *ppNode)))
        {
            return FALSE;
        }
    }

    return TRUE;
}

//
// Figure out if the TS client is currently running in the result pane
// and if so..is it connected
//
BOOL CCompdata::IsTSClientConnected(CConNode* pConNode)
{
    short conn_status;
    IMsRdpClient* pTS;

    ASSERT(pConNode);
    if(!pConNode)
    {
        return FALSE;
    }

    if(pConNode->IsConnected())
    {
        pTS = pConNode->GetTsClient();
        if (NULL != pTS)
        {
            if(FAILED(pTS->get_Connected(&conn_status)))
            {
                return FALSE;
            }

            pTS->Release();

            //
            // Update connection node's con status
            //
            BOOL bConnected = (conn_status != 0);
            pConNode->SetConnected(bConnected);
            return (bConnected);
        }
        else
        {
            return FALSE;
        }
    }
    return FALSE;
}

HRESULT CCompdata::InsertConnectionScopeNode(CConNode* pNode)
{
    //
    // Insert a new scope node for the connection node pNode
    //
    ASSERT(pNode);
    if (!pNode)
    {
        return S_FALSE;
    }
    SCOPEDATAITEM sdi;

    ZeroMemory( &sdi , sizeof( SCOPEDATAITEM ) );
    sdi.mask = SDI_STR | SDI_PARAM | SDI_PARENT | SDI_CHILDREN | SDI_IMAGE | SDI_OPENIMAGE;
    sdi.displayname = MMC_CALLBACK;
    sdi.relativeID = m_rootID;
    sdi.cChildren = 0;
    sdi.nImage = NOT_CONNECTED_IMAGE;
    sdi.nOpenImage = CONNECTED_IMAGE;

    sdi.lParam = (LPARAM)pNode;

    HRESULT hr;
    hr =  m_pConsoleNameSpace->InsertItem( &sdi );
    if ( FAILED( hr ) )
    {
        return S_FALSE;
    }

    //
    //	Keep track of the scope ID
    //
    pNode->SetScopeID(sdi.ID);
    return S_OK;
}

HRESULT CCompdata::AddNewConnection()
{
    //
    // Invoke add new connection dialog...
    //
    HWND hwndMain;
    HRESULT hr;
    m_pConsole->GetMainWindow( &hwndMain);
    HINSTANCE hInst = _Module.GetModuleInstance();

    CNewConDlg dlg( hwndMain, hInst);
    INT_PTR dlgRetVal =dlg.DoModal();

    if (IDOK != dlgRetVal)
    {
        return S_FALSE;
    }
    
    CConNode* pConNode = new CConNode;
    if ( pConNode == NULL )
    {
        ODS( L"Scope node failed allocation\n" );
        return FALSE;
    }

    pConNode->SetNodeType( CONNECTION_NODE );
    pConNode->SetDescription( dlg.GetDescription());
    pConNode->SetServerName( dlg.GetServer());
    pConNode->SetConnectToConsole( dlg.GetConnectToConsole());

    pConNode->SetSavePassword( dlg.GetSavePassword());

    pConNode->SetUserName( dlg.GetUserName());
    pConNode->SetDomain( dlg.GetDomain());

    //
    // Encrypt the password and store it in the 
    // connode
    //

    if (dlg.GetPasswordSpecified())
    {
        hr = EncryptAndStorePass( dlg.GetPassword(), pConNode);
        ASSERT(SUCCEEDED(hr));
        if(FAILED(hr))
        {
            return hr;
        }
        pConNode->SetPasswordSpecified(TRUE);
    }
    else
    {
        pConNode->SetPasswordSpecified(FALSE);
    }

    //
    // Need to mark state as dirty
    // 
    m_bIsDirty = TRUE;
    m_conNodesArray.Insert( pConNode);
    //
    //	Insert the actual scope node
    //
    hr = InsertConnectionScopeNode( pConNode);
    return hr;
}

//IPersistStreamInit
STDMETHODIMP CCompdata::GetClassID(CLSID *pClassID)
{
    UNREFERENCED_PARAMETER(pClassID);
    ATLTRACENOTIMPL(_T("CCOMPDATA::GetClassID"));
}   

STDMETHODIMP CCompdata::IsDirty()
{
    if (m_bIsDirty)
    {
        //
        // Signal that changes have been made
        //
        return S_OK;
    }

    return S_FALSE;
}

STDMETHODIMP CCompdata::SetDirty(BOOL dirty)
{
    m_bIsDirty = dirty;
    return S_OK;
}

STDMETHODIMP CCompdata::Load(IStream *pStm)
{
    HRESULT hr;
    ATLTRACE(_T("CCOMPDATA::Load"));

    //
    //	Initialize from the stream
    //	there should be no connection nodes at this time
    //
    if ( m_conNodesArray.GetSize() != 0)
    {
        ASSERT(m_conNodesArray.GetSize());
        return FALSE;
    }

    LONG nodeCount;
    ULONG cbRead;

    //
    // Read in the nodeCount
    //
    hr = pStm->Read( &nodeCount, sizeof(nodeCount), &cbRead);
    HR_RET_IF_FAIL(hr);

    //
    // Create new connection nodes from the persisted data
    //
    for (int i = 0; i < nodeCount; i++)
    {
        CConNode* pNode = new CConNode();
        if (!pNode)
        {
            return E_OUTOFMEMORY;
        }

        hr = pNode->InitFromStream( pStm);
        HR_RET_IF_FAIL(hr);

        pNode->SetNodeType( CONNECTION_NODE );
        m_conNodesArray.Insert(pNode);
    }
    return S_OK;
}

STDMETHODIMP CCompdata::Save(IStream *pStm, BOOL fClearDirty)
{
    HRESULT hr;
    ATLTRACE(_T("CCOMPDATA::Save"));
    UNREFERENCED_PARAMETER(fClearDirty);

    //
    // Save the connection nodes to the stream
    //
    LONG nodeCount;
    nodeCount = m_conNodesArray.GetSize();
    ULONG cbWritten;

    //
    // Write out the nodecount
    //

    hr = pStm->Write( &nodeCount, sizeof(nodeCount), &cbWritten);
    HR_RET_IF_FAIL(hr);

    //
    // Persist out each connection node's data
    //
    for (int i = 0; i < nodeCount; i++)
    {
        CConNode** ppNode = m_conNodesArray.GetAt(i);
        ASSERT(ppNode);
        if (!ppNode || *ppNode == NULL)
        {
            return S_FALSE;
        }

        hr = (*ppNode)->PersistToStream( pStm);
        HR_RET_IF_FAIL(hr);
    }

    //
    // We are clean at this point
    //
    SetDirty(FALSE);

    return S_OK;
}

STDMETHODIMP CCompdata::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    ATLTRACENOTIMPL(_T("CCOMPDATA::GetSizeMax"));
    UNREFERENCED_PARAMETER(pcbSize);
}

STDMETHODIMP CCompdata::InitNew()
{
    ATLTRACE(_T("CCOMPDATA::InitNew\n"));
    return S_OK;
}

// IExtendPropertySheet
STDMETHODIMP CCompdata::CreatePropertyPages(
                                LPPROPERTYSHEETCALLBACK psc,
                                LONG_PTR Handle,
                                LPDATAOBJECT pDo
                                )
{
    IPropertySheetProvider* pPropSheetProvider = NULL;
    CProperty* prop = NULL;

    UNREFERENCED_PARAMETER(Handle);
    HRESULT hr = S_FALSE;
    if (!psc || !pDo) {
        return E_UNEXPECTED;
    }

    ASSERT( ((CBaseNode*)pDo)->GetNodeType() == CONNECTION_NODE);
    if (((CBaseNode*)pDo)->GetNodeType() != CONNECTION_NODE) {
        return E_UNEXPECTED;
    }

    CConNode* pCon = (CConNode*) pDo;
    ASSERT(pCon);
    if (!pCon) {
        return S_FALSE;
    }

    HWND hMain;
    if (FAILED( m_pConsole->GetMainWindow(&hMain ))) {
        hMain = NULL;
        return E_FAIL;
    }

    prop = new CProperty( hMain, _Module.GetModuleInstance());
    if (!prop) {
        return E_OUTOFMEMORY;
    }

    prop->SetDisplayHelp( m_pDisplayHelp );

    prop->SetDescription( pCon->GetDescription());
    prop->SetServer( pCon->GetServerName() );
    prop->SetResType( pCon->GetResType() );

    prop->SetWidth( pCon->GetDesktopWidth() );
    prop->SetHeight( pCon->GetDesktopHeight() );

    prop->SetProgramPath( pCon->GetProgramPath() );
    prop->SetWorkDir( pCon->GetWorkDir());
    //
    // Enable the start program option if a program is specified
    //
    if (lstrcmp(pCon->GetProgramPath(), L""))
    {
        prop->SetStartProgram(TRUE);
    }
    else
    {
        prop->SetStartProgram(FALSE);
    }

    prop->SetSavePassword( pCon->GetSavePassword() );
    prop->SetUserName( pCon->GetUserName() );
    prop->SetDomain( pCon->GetDomain());
    prop->SetConnectToConsole( pCon->GetConnectToConsole());
    prop->SetRedirectDrives( pCon->GetRedirectDrives() );

    //hr = prop->InitPropSheets( hMain, psc, pCon, Handle);
    //ASSERT(S_OK == hr);

    if (prop->CreateModalPropPage())
    {
        BOOL bThisNodeIsDirty = FALSE;
        //user OK'd the property sheet
        //

        // Save the new values if any changes have been made
        //

        //
        // Prop page 1 values
        //
        if (lstrcmp(prop->GetDescription(),pCon->GetDescription()))
        {
            bThisNodeIsDirty = TRUE;
            pCon->SetDescription( prop->GetDescription());
        }

        if (lstrcmp(prop->GetServer(),pCon->GetServerName()))
        {
            bThisNodeIsDirty = TRUE;
            pCon->SetServerName( prop->GetServer());
        }

        if (lstrcmp(prop->GetUserName(),pCon->GetUserName()))
        {
            bThisNodeIsDirty = TRUE;
            pCon->SetUserName( prop->GetUserName());
        }

        if(prop->GetChangePassword())
        {
            if (prop->GetPasswordSpecified())
            {
                //
                // User requested to change password. Encrypt and
                // store this new password
                //
                bThisNodeIsDirty = TRUE;
                hr = EncryptAndStorePass( prop->GetPassword(), pCon);
                ASSERT(SUCCEEDED(hr));
                if(FAILED(hr))
                {
                    DBGMSG(_T("EncryptAndStorePassFailed 0x%x\n"), hr);
                    goto bail_out;
                }
                pCon->SetPasswordSpecified(TRUE);
            }
            else
            {
                pCon->SetPasswordSpecified(FALSE);
            }
        }

        if (lstrcmp(prop->GetDomain(),pCon->GetDomain()))
        {
            bThisNodeIsDirty = TRUE;
            pCon->SetDomain( prop->GetDomain());
        }

        if (prop->GetSavePassword() != pCon->GetSavePassword())
        {
            bThisNodeIsDirty = TRUE;
            pCon->SetSavePassword( prop->GetSavePassword());
        }

        if (prop->GetConnectToConsole() != pCon->GetConnectToConsole())
        {
            bThisNodeIsDirty = TRUE;
            pCon->SetConnectToConsole( prop->GetConnectToConsole());
        }

        //
        // Prop page 2
        //
        if (prop->GetResType() != pCon->GetResType())
        {
            bThisNodeIsDirty = TRUE;
            pCon->SetResType( prop->GetResType());
        }

        if (prop->GetWidth() != pCon->GetDesktopWidth())
        {
            bThisNodeIsDirty = TRUE;
            pCon->SetDesktopWidth( prop->GetWidth());
        }

        if (prop->GetHeight() != pCon->GetDesktopHeight())
        {
            bThisNodeIsDirty = TRUE;
            pCon->SetDesktopHeight( prop->GetHeight());
        }

        //
        // Prop page 3
        //
        if (lstrcmp(prop->GetProgramPath(), pCon->GetProgramPath()))
        {
            bThisNodeIsDirty = TRUE;
            pCon->SetProgramPath( prop->GetProgramPath());
        }

        if (lstrcmp(prop->GetWorkDir(), pCon->GetWorkDir()))
        {
            bThisNodeIsDirty = TRUE;
            pCon->SetWorkDir( prop->GetWorkDir());
        }

        if (prop->GetRedirectDrives() != pCon->GetRedirectDrives())
        {
            bThisNodeIsDirty = TRUE;
            pCon->SetRedirectDrives( prop->GetRedirectDrives() );
        }

        if(bThisNodeIsDirty)
        {
            //Set snapin-wide is dirty flag for persistence
            m_bIsDirty = TRUE;

            //Mark the conn settings as uninitialized so that they are
            //reset on the next connection
            pCon->SetConnectionInitialized(FALSE);
        }
    }

bail_out:
    if (prop) {
        delete prop;
    }

    //
    // We return failure because we're not using MMC's prop sheet
    // mechanism as we want a modal prop sheet. Returning failure
    // causes MMC to properly cleanup all the propsheet resources
    // it allocated
    // 

    return E_FAIL;
}

STDMETHODIMP CCompdata::QueryPagesFor( LPDATAOBJECT pDo)
{
    if ( dynamic_cast< CConNode *>( pDo ) == NULL )
    {
        return S_FALSE;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\snapin\newcondlg.cpp ===
#include "stdafx.h"
#include "newcondlg.h"
#include "browsedlg.h"
#include "resource.h"
#include "validate.h"

CNewConDlg* CNewConDlg::m_pThis = NULL;
CNewConDlg::CNewConDlg(HWND hWndOwner, HINSTANCE hInst) : m_hWnd(hWndOwner), m_hInst(hInst)
{
    m_pThis = this;
    //
    // Password saving is disabled by default
    // 
    m_bSavePassword = FALSE;

    //
    // Connect to console is enabled by default
    //
    m_bConnectToConsole = TRUE;

    ZeroMemory(m_szServer, sizeof(m_szServer));
    ZeroMemory(m_szDescription, sizeof(m_szDescription));
    ZeroMemory(m_szUserName, sizeof(m_szUserName));
    ZeroMemory(m_szPassword, sizeof(m_szPassword));
    ZeroMemory(m_szDomain, sizeof(m_szDomain));
}

CNewConDlg::~CNewConDlg()
{
    ZeroPasswordMemory();
}

INT_PTR
CNewConDlg::DoModal()
{
    INT_PTR retVal;

    retVal = DialogBox( m_hInst,MAKEINTRESOURCE(IDD_NEWCON), m_hWnd, StaticDlgProc);
    return retVal;
}

INT_PTR CALLBACK CNewConDlg::StaticDlgProc(HWND hDlg,UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    //
    // need access to class variables so redirect to non-static version of callback
    //
    return m_pThis->DlgProc(hDlg,uMsg,wParam,lParam);
}

INT_PTR
CNewConDlg::DlgProc(HWND hDlg,UINT uMsg, WPARAM wParam, LPARAM)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            //Limit length of these edit boxes
            SendMessage(GetDlgItem(hDlg, IDC_DESCRIPTION), EM_LIMITTEXT, CL_MAX_DESC_LENGTH, 0);
            SendMessage(GetDlgItem(hDlg, IDC_SERVER), EM_LIMITTEXT, CL_MAX_DOMAIN_LENGTH, 0);

            SendMessage(GetDlgItem(hDlg, IDC_USERNAME), EM_LIMITTEXT, CL_MAX_USERNAME_LENGTH, 0);
            SendMessage(GetDlgItem(hDlg, IDC_PASSWORD), EM_LIMITTEXT, CL_MAX_PASSWORD_EDIT, 0);
            SendMessage(GetDlgItem(hDlg, IDC_DOMAIN), EM_LIMITTEXT, CL_MAX_DOMAIN_LENGTH, 0);

            //Save password settings
            SendMessage(GetDlgItem(hDlg, IDC_SAVE_PASSWORD), BM_SETCHECK,
                        m_bSavePassword ? (WPARAM)BST_CHECKED : (WPARAM)BST_UNCHECKED, 0);
            
            //Connect to console settings
            SendMessage(GetDlgItem(hDlg, IDC_CONNECT_TO_CONSOLE), BM_SETCHECK,
                        m_bConnectToConsole ? (WPARAM)BST_CHECKED : (WPARAM)BST_UNCHECKED, 0);

            EnableWindow(GetDlgItem(hDlg, IDC_USERNAME), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_PASSWORD), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_DOMAIN), TRUE);

            EnableWindow(GetDlgItem(hDlg, IDC_USERNAME_STATIC), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_PASSWORD_STATIC), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_DOMAIN_STATIC), TRUE);

            SetFocus(GetDlgItem(hDlg, IDC_SERVER));


            break; // WM_INITDIALOG
        }

    case WM_COMMAND:
        {
            if (BN_CLICKED == HIWORD(wParam))
            {
                if (IDCANCEL == (int) LOWORD(wParam))
                {
                    //
                    // Cancel out of the dialog
                    //

                    EndDialog( hDlg, IDCANCEL);
                }
                else if (IDOK == (int) LOWORD(wParam))
                {
                    //
                    // Ok button pressed
                    // validate and store dialog settings
                    //

                    // todo: validate here.
                    if (!CValidate::Validate(hDlg, m_hInst))
                    {
                        return FALSE;
                    }


                    //Retrieve the data to be stored.
                    GetDlgItemText(hDlg, IDC_DESCRIPTION, m_szDescription, MAX_PATH);
                    GetDlgItemText(hDlg, IDC_SERVER, m_szServer, MAX_PATH);
                    if (!lstrcmp( m_szDescription, L""))
                    {
                        //if no description is specified. Default to the server name

                        //todo: check for existing server
                        lstrcpy(m_szDescription, m_szServer);
                    }

                    //
                    // Get user/pass/domain
                    //
                    GetDlgItemText(hDlg, IDC_USERNAME, m_szUserName,
                                   CL_MAX_USERNAME_LENGTH - 1);
                    GetDlgItemText(hDlg, IDC_PASSWORD, m_szPassword,
                                   CL_MAX_PASSWORD_LENGTH_BYTES / sizeof(TCHAR) - 1);
                    GetDlgItemText(hDlg, IDC_DOMAIN,   m_szDomain,
                                   CL_MAX_DOMAIN_LENGTH -1);

                    if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_SAVE_PASSWORD))
                    {
                        m_bSavePassword = TRUE;
                    }
                    else
                    {
                        m_bSavePassword = FALSE;
                    }

                    if(BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_CONNECT_TO_CONSOLE))
                    {
                        m_bConnectToConsole = TRUE;
                    }
                    else
                    {
                        m_bConnectToConsole = FALSE;
                    }
                    EndDialog( hDlg, IDOK);
                }
                if (IDC_BROWSE_SERVERS == LOWORD(wParam))
                {
                    INT_PTR nResult = IDCANCEL;
                    CBrowseDlg dlg( hDlg, m_hInst);
                    nResult = dlg.DoModal();
                
                    if (-1 == nResult)
                    {
                        ODS(L"DialogBox failed newcondlg.cpp\n");
                    }
                    if (IDOK == nResult)
                    {
                        SetDlgItemText(hDlg, IDC_SERVER, dlg.GetServer());
                        //
                        // set connection name as well if necessary
                        //
                        TCHAR   szDesc[CL_MAX_DESC_LENGTH];
                        GetDlgItemText(hDlg, IDC_DESCRIPTION, szDesc, CL_MAX_DESC_LENGTH);
                        if(!lstrcmp(szDesc, L""))
                        {
                            SetDlgItemText(hDlg, IDC_DESCRIPTION, dlg.GetServer());
                        }
                    }
                    SetFocus(hDlg);
                }
            }
            else if (EN_KILLFOCUS == HIWORD(wParam))
            {
                if(IDC_SERVER == LOWORD(wParam))
                {
                    //
                    // set connection name to server name if conn name is blank
                    //
                    TCHAR   szDesc[CL_MAX_DESC_LENGTH];
                    TCHAR   szServer[CL_MAX_DESC_LENGTH];
        
                    GetDlgItemText(hDlg, IDC_DESCRIPTION, szDesc, CL_MAX_DESC_LENGTH);
                    
                    if(!lstrcmp(szDesc, L""))
                    {
                        GetDlgItemText(hDlg, IDC_SERVER, szServer, CL_MAX_DOMAIN_LENGTH);
                        SetDlgItemText(hDlg, IDC_DESCRIPTION, szServer);
                    }
                }
            }
            else if (EN_CHANGE == HIWORD(wParam))
            {
                if ((LOWORD(wParam) == IDC_USERNAME))
                {
                    //Handle UPN style user names
                    //by disabling the domain field if there
                    //is an @ in the username
                    TCHAR szUserName[CL_MAX_USERNAME_LENGTH];
                    BOOL fDisableDomain = FALSE;

                    GetDlgItemText( hDlg, IDC_USERNAME,
                                    szUserName, SIZEOF_TCHARBUFFER(szUserName));

                    if(!_tcsstr(szUserName, TEXT("@")))
                    {
                        fDisableDomain = TRUE;
                    }
                    EnableWindow(GetDlgItem(hDlg, IDC_DOMAIN),
                                 fDisableDomain);
                }
            }
            break; // WM_COMMAND
        }
    }
    return FALSE;
}

BOOL CNewConDlg::GetPasswordSpecified()
{
    BOOL fPasswordSpecified = FALSE;

    if (_tcslen(m_szPassword) != 0)
    {
        fPasswordSpecified = TRUE;
    }

    return fPasswordSpecified;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\snapin\connode.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include "stdafx.h"
#include "connode.h"
#include "resource.h"
#include "license.h"
#include "tssec.h"
#include "defaults.h"
#include "wincrypt.h"

#define NO_PASSWORD_VALUE_LEN   4
#define NO_PASSWORD_VALUE       0x45628275

CConNode::CConNode()
{
    m_bConnected = FALSE;
    m_bConnectionInitialized = FALSE;

    m_szServer[0] = NULL;
    m_szDescription[0] = NULL;

    m_szUserName[0] = NULL;
    m_szDomain[0] = NULL;

    m_bSavePassword = FALSE;

    m_resType = SCREEN_RES_FILL_MMC;
    m_Width = DEFAULT_RES_WIDTH;
    m_Height = DEFAULT_RES_HEIGHT;

    m_szProgramPath[0] = NULL;
    m_szProgramStartIn[0] = NULL;

    m_pMhostCtl = NULL;
    m_pTsClientCtl = NULL;

    m_bConnectToConsole = FALSE;
    m_bRedirectDrives = FALSE;
    m_pIComponent = NULL;
    m_fPasswordSpecified = FALSE;

    _blobEncryptedPassword.cbData = 0;
    _blobEncryptedPassword.pbData = 0;
}


CConNode::~CConNode()
{
    if (m_pIComponent)
    {
        m_pIComponent->Release();
        m_pIComponent = NULL;
    }

    if (_blobEncryptedPassword.pbData && _blobEncryptedPassword.cbData) {
        LocalFree(_blobEncryptedPassword.pbData);
        _blobEncryptedPassword.pbData = NULL;
        _blobEncryptedPassword.cbData = 0;
    }
}

BOOL CConNode::SetServerName( LPTSTR szServerName)
{
    ASSERT(szServerName);
    if (szServerName != NULL)
    {
        lstrcpy(m_szServer, szServerName);
    }
    else
    {
        m_szServer[0] = NULL;
    }
    return TRUE;
}

BOOL CConNode::SetDescription( LPTSTR szDescription)
{
    ASSERT(szDescription);
    if (szDescription != NULL)
    {
        lstrcpy(m_szDescription, szDescription);
    }
    else
    {
        m_szDescription[0] = NULL;
    }
    return TRUE;
}

BOOL CConNode::SetUserName( LPTSTR szUserName)
{
    ASSERT(szUserName);
    if (szUserName != NULL)
    {
        lstrcpy(m_szUserName, szUserName);
    }
    else
    {
        m_szUserName[0] = NULL;
    }

    return TRUE;
}

BOOL CConNode::SetDomain(LPTSTR szDomain)
{
    ASSERT(szDomain);
    if (szDomain != NULL)
    {
        lstrcpy(m_szDomain, szDomain);
    }
    else
    {
        m_szDomain[0] = NULL;
    }
    return TRUE;
}

//
// DataProtect
// Protect data for persistence using data protection API
// params:
//      pInData   - (in) input bytes to protect
//      cbLen     - (in) length of pInData in bytes
//      ppOutData - (out) output bytes
//      pcbOutLen - (out) length of output
// returns: bool status
//
BOOL CConNode::DataProtect(PBYTE pInData, DWORD cbLen, PBYTE* ppOutData, PDWORD pcbOutLen)
{
    DATA_BLOB DataIn;
    DATA_BLOB DataOut;
    ASSERT(pInData && cbLen);
    ASSERT(ppOutData);
    ASSERT(pcbOutLen);
    if (pInData && cbLen && ppOutData && pcbOutLen)
    {
        DataIn.pbData = pInData;
        DataIn.cbData = cbLen;

        if (CryptProtectData( &DataIn,
                              TEXT("ps"), // DESCRIPTION STRING.
                              NULL, // optional entropy
                              NULL, // reserved
                              NULL, // NO prompting
                              CRYPTPROTECT_UI_FORBIDDEN, //don't pop UI
                              &DataOut ))
        {
            *ppOutData = (PBYTE)LocalAlloc(LPTR, DataOut.cbData);
            if (*ppOutData)
            {
                //copy the output data
                memcpy(*ppOutData, DataOut.pbData, DataOut.cbData);
                *pcbOutLen = DataOut.cbData;
                LocalFree(DataOut.pbData);
                return TRUE;
            }
            else
            {
                LocalFree(DataOut.pbData);
                return FALSE;
            }
        }
        else
        {
            DWORD dwLastErr = GetLastError();
            DBGMSG( L"CryptProtectData FAILED error:%d\n",dwLastErr);
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }
}

//
// DataUnprotect
// UnProtect persisted out data using data protection API
// params:
//      pInData   - (in) input bytes to UN protect
//      cbLen     - (in) length of pInData in bytes
//      ppOutData - (out) output bytes
//      pcbOutLen - (out) length of output
// returns: bool status
//
//
BOOL CConNode::DataUnprotect(PBYTE pInData, DWORD cbLen, PBYTE* ppOutData, PDWORD pcbOutLen)
{
    DATA_BLOB DataIn;
    DATA_BLOB DataOut;
    ASSERT(pInData && cbLen && ppOutData && pcbOutLen);
    if (pInData && cbLen && ppOutData && pcbOutLen)
    {
        DataIn.pbData = pInData;
        DataIn.cbData = cbLen;

        if (CryptUnprotectData( &DataIn,
                                NULL, // NO DESCRIPTION STRING
                                NULL, // optional entropy
                                NULL, // reserved
                                NULL, // NO prompting
                                CRYPTPROTECT_UI_FORBIDDEN, //don't pop UI
                                &DataOut ))
        {
            *ppOutData = (PBYTE)LocalAlloc(LPTR, DataOut.cbData);
            if (*ppOutData)
            {
                //copy the output data
                memcpy(*ppOutData, DataOut.pbData, DataOut.cbData);
                *pcbOutLen = DataOut.cbData;
                LocalFree(DataOut.pbData);
                return TRUE;
            }
            else
            {
                LocalFree(DataOut.pbData);
                return FALSE;
            }
        }
        else
        {
            DWORD dwLastErr = GetLastError();
            DBGMSG( L"CryptUnprotectData FAILED error:%d\n",dwLastErr);
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }
}


HRESULT CConNode::PersistToStream( IStream* pStm)
{
    //
    // Persist the data of this connection node to the stream
    //
    // The data is persisted started at the current seek position
    // of the stream.

    HRESULT hr;
    ULONG   cbWritten;

    ASSERT(pStm);
    if (!pStm)
    {
        return E_FAIL;
    }

    //
    //Persist info version
    //
    int persist_ver = CONNODE_PERSIST_INFO_VERSION;
    hr = pStm->Write( &persist_ver, sizeof(persist_ver), &cbWritten);
    HR_RET_IF_FAIL(hr);

    //
    //server
    //
    hr = pStm->Write( &m_szServer, sizeof(m_szServer), &cbWritten);
    HR_RET_IF_FAIL(hr);

    //
    //description
    //
    hr = pStm->Write( &m_szDescription, sizeof(m_szDescription), &cbWritten);
    HR_RET_IF_FAIL(hr);

    //
    //user name
    //
    hr = pStm->Write( &m_szUserName, sizeof(m_szUserName), &cbWritten);
    HR_RET_IF_FAIL(hr);


    //
    //encrypted password
    //

    //Intentional ignore of failure code as crypto may fail
    hr = WriteProtectedPassword( pStm);
    
    //
    //domain
    //
    hr = pStm->Write( &m_szDomain, sizeof(m_szDomain), &cbWritten);
    HR_RET_IF_FAIL(hr);

    //
    //Password specified flag
    //
    BOOL fWritePassword = GetPasswordSpecified() && GetSavePassword();
    hr = pStm->Write( &fWritePassword, sizeof(fWritePassword), &cbWritten);
    HR_RET_IF_FAIL(hr);

    //
    // Screen resolution
    //
    hr = pStm->Write( &m_resType, sizeof(m_resType), &cbWritten);
    HR_RET_IF_FAIL(hr);

    hr = pStm->Write( &m_Width, sizeof(m_Width), &cbWritten);
    HR_RET_IF_FAIL(hr);

    hr = pStm->Write( &m_Height, sizeof(m_Height), &cbWritten);
    HR_RET_IF_FAIL(hr);

    //
    // Start program
    //
    hr = pStm->Write( &m_szProgramPath, sizeof(m_szProgramPath), &cbWritten);
    HR_RET_IF_FAIL(hr);

    //
    // Work dir
    //
    hr = pStm->Write( &m_szProgramStartIn, sizeof(m_szProgramStartIn), &cbWritten);
    HR_RET_IF_FAIL(hr);

    //
    // Connect to console
    //
    hr = pStm->Write( &m_bConnectToConsole, sizeof(m_bConnectToConsole), &cbWritten);
    HR_RET_IF_FAIL(hr);

    hr = pStm->Write( &m_bRedirectDrives, sizeof(m_bRedirectDrives), &cbWritten);
    HR_RET_IF_FAIL(hr);

    //
    // PADDING for future extension
    //
    DWORD dwPad = (DWORD)-1;
    hr = pStm->Write( &dwPad, sizeof(dwPad), &cbWritten);
    HR_RET_IF_FAIL(hr);
    hr = pStm->Write( &dwPad, sizeof(dwPad), &cbWritten);
    HR_RET_IF_FAIL(hr);
    hr = pStm->Write( &dwPad, sizeof(dwPad), &cbWritten);
    HR_RET_IF_FAIL(hr);

    return S_OK;
}

HRESULT CConNode::InitFromStream( IStream* pStm)
{
    //
    // Reads in the data for this connection node from the stream
    // starting at the current seek position in the stream.
    //
    HRESULT hr;
    ULONG   cbRead;

    ASSERT(pStm);
    if (!pStm)
    {
        return E_FAIL;
    }

    int persist_info_version;
    //
    //Persist info version
    //
    hr = pStm->Read( &persist_info_version, sizeof(persist_info_version), &cbRead);
    HR_RET_IF_FAIL(hr);

    if (persist_info_version <= CONNODE_PERSIST_INFO_VERSION_TSAC_BETA)
    {
        //
        // Unsupported perist version
        //
        return E_FAIL;
    }

    //
    //server
    //
    hr = pStm->Read( &m_szServer, sizeof(m_szServer), &cbRead);
    m_szServer[sizeof(m_szServer) / sizeof(TCHAR) - 1] = NULL;
    HR_RET_IF_FAIL(hr);

    //
    //description
    //
    hr = pStm->Read( &m_szDescription, sizeof(m_szDescription), &cbRead);
    m_szDescription[sizeof(m_szDescription) / sizeof(TCHAR) - 1] = NULL;
    HR_RET_IF_FAIL(hr);

    //
    //user name
    //
    hr = pStm->Read( &m_szUserName, sizeof(m_szUserName), &cbRead);
    m_szUserName[sizeof(m_szUserName) / sizeof(TCHAR) - 1] = NULL;
    HR_RET_IF_FAIL(hr);

    //
    // Password
    //

    BOOL fGotPassword = FALSE;
    if (CONNODE_PERSIST_INFO_VERSION_TSAC_BETA == persist_info_version)
    {
        //
        // We drop the password if it's in TSAC format as we dropped
        // support for that format
        //

        //
        // Just seek past the correct number of bytes
        //

        LARGE_INTEGER seekDelta = {0, CL_OLD_PASSWORD_LENGTH + CL_SALT_LENGTH};
        hr = pStm->Seek(seekDelta,
                        STREAM_SEEK_CUR,
                        NULL);
        HR_RET_IF_FAIL(hr);
    }
    else if (persist_info_version <= CONNODE_PERSIST_INFO_VERSION_DOTNET_BETA3) {
        //
        // We drop support for the legacy DPAPI+Control obfuscation formats
        //
        DWORD cbSecureLen = 0;
        //
        //encrypted bytes length
        //
        hr = pStm->Read( &cbSecureLen, sizeof(cbSecureLen), &cbRead);
        HR_RET_IF_FAIL(hr);

        //
        // Just seek ahead in the stream
        //
        LARGE_INTEGER seekDelta;
        seekDelta.LowPart = cbSecureLen;
        seekDelta.HighPart = 0;
        hr = pStm->Seek(seekDelta,
                        STREAM_SEEK_CUR,
                        NULL);
        HR_RET_IF_FAIL(hr);
    }
    else
    {
        //Read the new more secure format
        hr = ReadProtectedPassword(pStm);
        if(SUCCEEDED(hr)) {
            fGotPassword = TRUE;
        }
        else {
            ODS(TEXT("Failed to ReadProtectedPassword\n"));
        }
    }
    //
    //domain
    //
    if(persist_info_version >= CONNODE_PERSIST_INFO_VERSION_DOTNET_BETA3)
    {
        hr = pStm->Read( &m_szDomain, sizeof(m_szDomain), &cbRead);
        m_szDomain[sizeof(m_szDomain) / sizeof(TCHAR) - 1] = NULL;
        HR_RET_IF_FAIL(hr);
    }
    else
    {
        //Old length for domain
        hr = pStm->Read( &m_szDomain, CL_OLD_DOMAIN_LENGTH * sizeof(TCHAR),
                         &cbRead);
        m_szDomain[CL_OLD_DOMAIN_LENGTH - 1] = NULL;
        HR_RET_IF_FAIL(hr);
    }

    //
    //Password specified flag
    //
    hr = pStm->Read( &m_fPasswordSpecified, sizeof(m_fPasswordSpecified), &cbRead);
    HR_RET_IF_FAIL(hr);

    //
    // Override the autologon flag if we failed to
    // get a password, e.g if we were unable to decrypt
    // it because the current user doesn't match credentials
    //
    if(!fGotPassword)
    {
        m_fPasswordSpecified = FALSE;
    }

    //
    // If the password was specified in the file
    // it means we want it saved
    //
    m_bSavePassword = m_fPasswordSpecified;

    //
    // Screen resolution
    //
    hr = pStm->Read( &m_resType, sizeof(m_resType), &cbRead);
    HR_RET_IF_FAIL(hr);

    hr = pStm->Read( &m_Width, sizeof(m_Width), &cbRead);
    HR_RET_IF_FAIL(hr);

    hr = pStm->Read( &m_Height, sizeof(m_Height), &cbRead);
    HR_RET_IF_FAIL(hr);

    //
    // Start program
    //
    hr = pStm->Read( &m_szProgramPath, sizeof(m_szProgramPath), &cbRead);
    m_szProgramPath[sizeof(m_szProgramPath) / sizeof(TCHAR) - 1] = NULL;
    HR_RET_IF_FAIL(hr);

    //
    // Work dir
    //
    hr = pStm->Read( &m_szProgramStartIn, sizeof(m_szProgramStartIn), &cbRead);
    m_szProgramStartIn[sizeof(m_szProgramStartIn) / sizeof(TCHAR) - 1] = NULL;
    HR_RET_IF_FAIL(hr);


    if(persist_info_version >= CONNODE_PERSIST_INFO_VERSION_WHISTLER_BETA1)
    {
        //
        // Connect to console
        //
        hr = pStm->Read( &m_bConnectToConsole, sizeof(m_bConnectToConsole), &cbRead);
        HR_RET_IF_FAIL(hr);

        hr = pStm->Read( &m_bRedirectDrives, sizeof(m_bRedirectDrives), &cbRead);
        HR_RET_IF_FAIL(hr);
    
        //
        // PADDING for future extension
        //
        DWORD dwPad;
        hr = pStm->Read( &dwPad, sizeof(dwPad), &cbRead);
        HR_RET_IF_FAIL(hr);
        hr = pStm->Read( &dwPad, sizeof(dwPad), &cbRead);
        HR_RET_IF_FAIL(hr);
        hr = pStm->Read( &dwPad, sizeof(dwPad), &cbRead);
        HR_RET_IF_FAIL(hr);
    }

    return S_OK;
}

HRESULT CConNode::ReadProtectedPassword(IStream* pStm)
{
    HRESULT hr = E_FAIL;
    ULONG cbRead;
    if (pStm)
    {
        //
        // NOTE: About password encryption
        //       at runtime the password is passed around in DPAPI form
        //
        //       Legacy formats had the password first encrypted with the
        //       control's password obfuscation - we got rid of those.
        //
        // persistence format is
        // -DWORD giving size of encrypted data field
        // -Data protection ENCRYPTED BYTES of encryptedpass+salt concatenation
        //
        DWORD cbSecureLen = 0;
        //
        //encrypted bytes length
        //
        hr = pStm->Read( &cbSecureLen, sizeof(cbSecureLen), &cbRead);
        HR_RET_IF_FAIL(hr);
        
        if (cbSecureLen == 0) {
            return E_FAIL;
        }

        PBYTE pEncryptedBytes = (PBYTE) LocalAlloc(LPTR, cbSecureLen);
        if (!pEncryptedBytes) {
            return E_OUTOFMEMORY;
        }

        //
        //read in the encrypted pass+salt combo
        //
        hr = pStm->Read( pEncryptedBytes, cbSecureLen, &cbRead);
        HR_RET_IF_FAIL(hr);
        if (cbSecureLen != cbRead)
        {
            LocalFree(pEncryptedBytes);
            return E_FAIL;
        }

        if (cbSecureLen == NO_PASSWORD_VALUE_LEN)
        {
            ODS(TEXT("Read cbSecurLen of NO_PASSWORD_VALUE_LEN. No password."));
            LocalFree(pEncryptedBytes);
            return E_FAIL;
        }
        
        //
        // DPAPI decrypt the persisted secure bytes to test if the decryption
        // succeeds
        // 
        PBYTE pUnSecureBytes;
        DWORD cbUnSecureLen;
        if (!DataUnprotect( (PBYTE)pEncryptedBytes, cbSecureLen,
                            &pUnSecureBytes, &cbUnSecureLen))
        {
            //DPAPI Password encryption failed
            ODS(TEXT("DataUnProtect encryption FAILED\n"));
            LocalFree(pEncryptedBytes);
            return E_FAIL;
        }

        //
        // Free any existing data in the blob
        //
        if (_blobEncryptedPassword.pbData && _blobEncryptedPassword.cbData) {
            LocalFree(_blobEncryptedPassword.pbData);
            _blobEncryptedPassword.pbData = NULL;
            _blobEncryptedPassword.cbData = 0;
        }

        //
        // Do not free the encrypted bytes, they are kept around
        // in the data blob in DPAPI format - ConNode will take care
        // of correctly freeing the bytes when they are no longer needed.
        //
        _blobEncryptedPassword.pbData = pEncryptedBytes;
        _blobEncryptedPassword.cbData = cbSecureLen;

        SecureZeroMemory(pUnSecureBytes, cbUnSecureLen);
        LocalFree(pUnSecureBytes);
        return hr;
    }
    else
    {
        return E_INVALIDARG;
    }
}


//
// Write a DPAPI protected password out to the stream
//
HRESULT CConNode::WriteProtectedPassword(IStream* pStm)
{
    HRESULT hr = E_FAIL;
    ULONG cbWritten;
    if (pStm)
    {
        //
        // NOTE: About password encryption
        //       at runtime the password is passed around in DPAPI form

        //
        // Save the password/salt in the following format
        // -DWORD giving size of encrypted data field
        // -Data protection ENCRYPTED BYTES of encryptedpass+salt concatenation
        //

        PBYTE pSecureBytes = NULL;
        DWORD cbSecureLen = NULL;
        BOOL  fFreeSecureBytes = FALSE;

        DWORD dwDummyBytes = NO_PASSWORD_VALUE;

        //
        // Don't save the password if the setting is not selected or if there
        // isn't any data to save.
        //
        if (!GetSavePassword() || 0 == _blobEncryptedPassword.cbData) {
            //
            // User chose not to save the password, write 4 bytes
            //
            cbSecureLen = 4;
            pSecureBytes = (PBYTE)&dwDummyBytes;
        }


        //
        //encrypted bytes length
        //
        cbSecureLen = _blobEncryptedPassword.cbData;
        hr = pStm->Write(&cbSecureLen, sizeof(cbSecureLen), &cbWritten);

        //
        //write out secured bytes
        //
        if (SUCCEEDED(hr)) {
            pSecureBytes = _blobEncryptedPassword.pbData;
            hr = pStm->Write(pSecureBytes, cbSecureLen, &cbWritten);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}


IMsRdpClient* CConNode::GetTsClient()
{
    if (m_pTsClientCtl)
    {
        m_pTsClientCtl->AddRef();
    }
    return m_pTsClientCtl;
}

void CConNode::SetTsClient(IMsRdpClient* pTs)
{
    if (NULL == pTs)
    {
        if (m_pTsClientCtl)
        {
            m_pTsClientCtl->Release();
            m_pTsClientCtl = NULL;
        }
    }
    else
    {
        m_pTsClientCtl = pTs;
        m_pTsClientCtl->AddRef();
    }
}

IMstscMhst* CConNode::GetMultiHostCtl()
{
    if (m_pMhostCtl)
    {
        m_pMhostCtl->AddRef();
    }
    return m_pMhostCtl;
}

void CConNode::SetMultiHostCtl(IMstscMhst* pMhst)
{
    if (NULL == pMhst)
    {
        if (m_pMhostCtl)
        {
            m_pMhostCtl->Release();
        }
        m_pMhostCtl = NULL;
    }
    else
    {
        m_pMhostCtl = pMhst;
        m_pMhostCtl->AddRef();
    }
}

IComponent* CConNode::GetView()
{
    if (m_pIComponent)
    {
        m_pIComponent->AddRef();
    }
    return m_pIComponent;
}

void CConNode::SetView(IComponent* pView)
{
    if (!pView)
    {
        if (m_pIComponent)
        {
            m_pIComponent->Release();
            m_pIComponent = NULL;
        }
    }
    else
    {
        if (m_pIComponent)
        {
            ODS( L"Clobbering IComponent interface, could be leaking\n" );
        }

        pView->AddRef();
        m_pIComponent = pView;
    }
}


//
// Store a clear text password in encrypted form
//
HRESULT
CConNode::SetClearTextPass(LPCTSTR szClearPass)
{
    HRESULT hr = E_FAIL;

    DATA_BLOB din;
    din.cbData = _tcslen(szClearPass) * sizeof(TCHAR);
    din.pbData = (PBYTE)szClearPass;
    if (_blobEncryptedPassword.pbData)
    {
        LocalFree(_blobEncryptedPassword.pbData);
        _blobEncryptedPassword.pbData = NULL;
        _blobEncryptedPassword.cbData = 0;
    }
    if (din.cbData)
    {
        if (CryptProtectData(&din,
                             TEXT("ps"), // DESCRIPTION STRING.
                             NULL, // optional entropy
                             NULL, // reserved
                             NULL, // NO prompting
                             CRYPTPROTECT_UI_FORBIDDEN, //don't pop UI
                             &_blobEncryptedPassword))
        {
            hr = S_OK;
        }
        else
        {
            ODS((_T("DataProtect failed")));
            hr = E_FAIL;
        }
    }
    else
    {
        ODS((_T("0 length password, not encrypting")));
        hr = S_OK;
    }

    return hr;
}

//
// Retrieve a clear text password
//
//
// Params
// [out] szBuffer - receives decrypted password
// [int] cbLen    - length of szBuffer
//
HRESULT
CConNode::GetClearTextPass(LPTSTR szBuffer, INT cbLen)
{
    HRESULT hr = E_FAIL;

    DATA_BLOB dout;
    dout.cbData = 0;
    dout.pbData = NULL;
    if (_blobEncryptedPassword.cbData)
    {
        memset(szBuffer, 0, cbLen);
        if (CryptUnprotectData(&_blobEncryptedPassword,
                               NULL, // NO DESCRIPTION STRING
                               NULL, // optional entropy
                               NULL, // reserved
                               NULL, // NO prompting
                               CRYPTPROTECT_UI_FORBIDDEN, //don't pop UI
                               &dout))
        {
            memcpy(szBuffer, dout.pbData,
                   min( dout.cbData,(UINT)cbLen-sizeof(TCHAR)));

            //
            // Nuke the original copy
            //
            SecureZeroMemory(dout.pbData, dout.cbData);
            LocalFree( dout.pbData );
            hr = S_OK;
        }
        else
        {
            ODS((_T("DataUnprotect failed")));
            hr = E_FAIL;
        }
    }
    else
    {
        ODS(_T("0 length encrypted pass, not decrypting"));

        //
        // Just reset the output buffer
        //
        memset(szBuffer, 0, cbLen);
        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\snapin\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\snapin\property.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       property.h
//
//--------------------------------------------------------------------------

#ifndef _PROPERTY_
#define _PROPERTY_

#include "mmc.h"
#include "connode.h"
#include "resource.h"

//
// Property sheet
//
#define APIENTRY WINAPI
class CProperty
{
private:
    HWND m_hWnd;
    HINSTANCE m_hInst;

    //
    //UI data members
    //

    //
    //Prop page 1
    //
    TCHAR   m_szServer[MAX_PATH];
    TCHAR   m_szDescription[MAX_PATH];
    TCHAR   m_szUserName[CL_MAX_USERNAME_LENGTH];
    TCHAR   m_szPassword[CL_MAX_PASSWORD_LENGTH_BYTES/sizeof(TCHAR)];
    TCHAR   m_szDomain[CL_MAX_DOMAIN_LENGTH];
    BOOL    m_bSavePassword;
    BOOL    m_bConnectToConsole;
    BOOL    m_bChangePassword;

    //
    //Prop page 2
    //
    int         m_resType;
    int         m_Width;
    int         m_Height;

    //
    //Prop page 3
    //
    BOOL    m_bStartProgram;
    TCHAR   m_szProgramPath[MAX_PATH];
    TCHAR   m_szProgramStartIn[MAX_PATH];
    BOOL    m_bRedirectDrives;

    //
    // IDisplayHelp interface
    //
    LPDISPLAYHELP m_pDisplayHelp;


//private methods
private:
//    static void PopContextHelp(LPARAM);
    void ProcessResolution(HWND hDlg);
    //Needs to hold an m_szDescription and additional text 'Properties'
    TCHAR m_szCaption[MAX_PATH*2];

public:
    CProperty(HWND hWndOwner, HINSTANCE hInst);
    ~CProperty();

    static CProperty* m_pthis;
    BOOL    CreateModalPropPage();

    static INT_PTR APIENTRY StaticPage1Proc(HWND, UINT, WPARAM, LPARAM);
    static INT_PTR APIENTRY StaticPage2Proc(HWND, UINT, WPARAM, LPARAM);
    static INT_PTR APIENTRY StaticPage3Proc(HWND, UINT, WPARAM, LPARAM);

    INT_PTR APIENTRY Page1Proc(HWND, UINT, WPARAM, LPARAM);
    INT_PTR APIENTRY Page2Proc(HWND, UINT, WPARAM, LPARAM);
    INT_PTR APIENTRY Page3Proc(HWND, UINT, WPARAM, LPARAM);
    
    //
    // Access functions
    //
    LPTSTR  GetServer()         {return m_szServer;}
    void    SetServer(LPTSTR sz)        {lstrcpy(m_szServer,sz);}

    LPTSTR  GetDescription()    {return m_szDescription;}
    void    SetDescription(LPTSTR sz)   {lstrcpy(m_szDescription,sz);}

    BOOL    GetConnectToConsole()   {return m_bConnectToConsole;}
    VOID    SetConnectToConsole(BOOL b) {m_bConnectToConsole = b;}

    LPTSTR  GetUserName()       {return m_szUserName;}
    void    SetUserName(LPTSTR sz)      {lstrcpy(m_szUserName,sz);}

    LPTSTR  GetPassword()       {return m_szPassword;}
    void    SetPassword(LPTSTR sz)      {lstrcpy(m_szPassword,sz);}

    BOOL    GetChangePassword() {return m_bChangePassword;}
    
    LPTSTR  GetDomain()         {return m_szDomain;}
    void    SetDomain(LPTSTR sz)        {lstrcpy(m_szDomain,sz);}

    int     GetResType()    {return m_resType;}
    void    SetResType(int r)    {m_resType = r;}
    int     GetWidth()      {return m_Width;}
    void    SetWidth(int r)    {m_Width = r;}
    int     GetHeight()      {return m_Height;}
    void    SetHeight(int r)    {m_Height = r;}

    LPTSTR  GetProgramPath()    {return m_szProgramPath;}
    void    SetProgramPath(LPTSTR sz)   {lstrcpy(m_szProgramPath,sz);}

    LPTSTR  GetWorkDir()        {return m_szProgramStartIn;}
    void    SetWorkDir(LPTSTR sz)       {lstrcpy(m_szProgramStartIn,sz);}

    BOOL    GetStartProgram()   {return m_bStartProgram;}
    void    SetStartProgram(BOOL b)     {m_bStartProgram = b;}

    BOOL    GetRedirectDrives() {return m_bRedirectDrives;}
    void    SetRedirectDrives(BOOL b) {m_bRedirectDrives = b;}

    void    SetDisplayHelp(LPDISPLAYHELP lpHelp);
    HRESULT DisplayHelp();

    VOID    SetSavePassword(BOOL fSavePass) {m_bSavePassword = fSavePass;}
    BOOL    GetSavePassword()  {return m_bSavePassword;}

    BOOL    GetPasswordSpecified();
};
#endif //_PROPERTY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\snapin\tsmmc.cpp ===
// tsmmc.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f tsmmcps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "tsmmc.h"

#include "tsmmc_i.c"
#include "compdata.h"

LONG RecursiveDeleteKey( HKEY hKeyParent , LPTSTR lpszKeyChild );

TCHAR tchSnapKey[]    = TEXT( "Software\\Microsoft\\MMC\\Snapins\\" );

TCHAR tchNameString[] = TEXT( "NameString" );
//
// MUI compatible name string
//
TCHAR tchNameStringIndirect[] = TEXT( "NameStringIndirect" );

TCHAR tchAbout[]      = TEXT( "About" );

TCHAR tchNodeType[]   = TEXT( "NodeTypes" );

TCHAR tchStandAlone[] = TEXT( "StandAlone" );


extern const GUID GUID_ResultNode = { /* 84e0518f-97a8-4caf-96fb-e9a956b10df8 */
    0x84e0518f,
    0x97a8,
    0x4caf,
    {0x96, 0xfb, 0xe9, 0xa9, 0x56, 0xb1, 0x0d, 0xf8}
  };


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Compdata, CCompdata)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        //_Module.Init(ObjectMap, hInstance, &LIBID_TSMMCLib);

		_Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HKEY hKeyRoot , hKey;
    INT nLen;
    
    TCHAR tchGUID[ 40 ];

    TCHAR tchKey[ MAX_PATH ];//TEXT( "Software\\Microsoft\\MMC\\Snapins\\" );

    lstrcpy( tchKey , tchSnapKey );

    StringFromGUID2( CLSID_Compdata,tchGUID,sizeof( tchGUID ) /sizeof(TCHAR) );
    lstrcat( tchKey , tchGUID );

    if( RegCreateKey( HKEY_LOCAL_MACHINE,tchKey,&hKeyRoot ) != ERROR_SUCCESS )
    {
        return GetLastError( );
    }

    //
    // Use a MUI happy name string
    // Format is '@pathtomodule,-RESID' where RESID is the resource id of our string
    TCHAR tchBuf[ 512 ];
    TCHAR szModPath[MAX_PATH];
    if (GetModuleFileName( _Module.GetResourceInstance( ),
                           szModPath,
                           MAX_PATH ))
    {
        // Ensure NULL termination.
        szModPath[MAX_PATH - 1] = NULL;

        _stprintf( tchBuf, _T("@%s,-%d"),
                   szModPath, IDS_SNAPIN_REG_TSMMC_NAME );
        nLen = _tcslen(tchBuf) + 1;

        RegSetValueEx( hKeyRoot,
                       tchNameStringIndirect,
                       NULL, REG_SZ,
                       (PBYTE)&tchBuf[0],
                       nLen * sizeof(TCHAR));
    }

    //
    // Write legacy non-MUI namestring for fallback in case
    // of error loading the MUI string.
    //
    memset(tchBuf, 0, sizeof(tchBuf));
    if (LoadString(_Module.GetResourceInstance( ),
               IDS_PROJNAME, tchBuf, SIZEOF_TCHARBUFFER(tchBuf) - 1))
    {
        nLen = _tcslen(tchBuf);
        RegSetValueEx(hKeyRoot, tchNameString, NULL,
                      REG_SZ, ( PBYTE )&tchBuf[0], nLen * sizeof(TCHAR));
    }

    //
    // Write the 'About' info
    //

    RegSetValueEx( hKeyRoot,
                   tchAbout,
                   NULL, 
                   REG_SZ,
                   (PBYTE)&tchGUID[0],
                   sizeof( tchGUID ) );
    
    lstrcpy( tchKey,tchStandAlone );
    RegCreateKey( hKeyRoot,tchKey,&hKey );
    RegCloseKey( hKey );
	lstrcpy( tchKey,tchNodeType );
	RegCreateKey( hKeyRoot,tchKey,&hKey );

	TCHAR szGUID[ 40 ];
	HKEY hDummy;
	StringFromGUID2( GUID_ResultNode,szGUID,sizeof(szGUID)/sizeof(TCHAR));
	RegCreateKey( hKey,szGUID,&hDummy );
	RegCloseKey( hDummy );
	RegCloseKey( hKey );
    RegCloseKey( hKeyRoot );

    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HKEY hKey;

    TCHAR tchGUID[ 40 ];

    TCHAR tchKey[ MAX_PATH ];

    lstrcpy( tchKey , tchSnapKey );

    if( RegOpenKey( HKEY_LOCAL_MACHINE , tchKey , &hKey ) != ERROR_SUCCESS )
    {
        return GetLastError( ) ;
    }

    StringFromGUID2( CLSID_Compdata , tchGUID , sizeof( tchGUID ) / sizeof(TCHAR) );

	RecursiveDeleteKey( hKey , tchGUID );
	
	RegCloseKey( hKey );
    
    return _Module.UnregisterServer();
}


//---------------------------------------------------------------------------
// Delete a key and all of its descendents.
//---------------------------------------------------------------------------
LONG RecursiveDeleteKey( HKEY hKeyParent , LPTSTR lpszKeyChild )
{
	// Open the child.
	HKEY hKeyChild;

	LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild , 0 , KEY_ALL_ACCESS, &hKeyChild);

	if (lRes != ERROR_SUCCESS)
	{
		return lRes;
	}

	// Enumerate all of the decendents of this child.

	FILETIME time;

	TCHAR szBuffer[256];

	DWORD dwSize = SIZEOF_TCHARBUFFER( szBuffer );

	while( RegEnumKeyEx( hKeyChild , 0 , szBuffer , &dwSize , NULL , NULL , NULL , &time ) == S_OK )
	{
        // Delete the decendents of this child.

		lRes = RecursiveDeleteKey(hKeyChild, szBuffer);

		if (lRes != ERROR_SUCCESS)
		{
			RegCloseKey(hKeyChild);

			return lRes;
		}

		dwSize = SIZEOF_TCHARBUFFER( szBuffer );
	}

	// Close the child.

	RegCloseKey( hKeyChild );

	// Delete this child.

	return RegDeleteKey( hKeyParent , lpszKeyChild );
}

#ifdef ECP_TIMEBOMB
//
// Return's true if timebomb test passed otherwise puts up warning
// UI and return's FALSE
//
DCBOOL CheckTimeBomb()
{
    SYSTEMTIME lclTime;
    FILETIME   lclFileTime;
    GetLocalTime(&lclTime);

    DCBOOL bTimeBombOk = TRUE;

    //
    // Simply check that the local date is less than June 30, 2000
    //
    if(lclTime.wYear < ECP_TIMEBOMB_YEAR)
    {
        return TRUE;
    }
    else if (lclTime.wYear == ECP_TIMEBOMB_YEAR)
    {
        if(lclTime.wMonth < ECP_TIMEBOMB_MONTH)
        {
            return TRUE;
        }
        else if(lclTime.wMonth == ECP_TIMEBOMB_MONTH)
        {
            if(lclTime.wDay < ECP_TIMEBOMB_DAY)
            {
                return TRUE;
            }
        }

    }

    DCTCHAR timeBombStr[256];
    if (LoadString(_Module.GetResourceInstance(),
                    IDS_TIMEBOMB_EXPIRED,
                    timeBombStr,
                    SIZEOF_TCHARBUFFER(timeBombStr)) != 0)
    {
        MessageBox(NULL, timeBombStr, NULL, 
                   MB_ICONERROR | MB_OK);
    }


    //
    // If we reach this point the timebomb should trigger
    // so put up a messagebox and return FALSE
    // so the calling code can disable functionality
    //


    return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\snapin\validate.h ===
#ifndef _validate_h_
#define _validate_h_

class CValidate
{
public:
    //
    // Validation functions are static. They are shared by newcondlg and property sheet
    //
    static BOOL Validate(HWND hDlg, HINSTANCE hInst);
    static int  ValidateUserName(HWND hwnd, HINSTANCE hInst, TCHAR *szDesc);
    static BOOL IsValidUserName(TCHAR *szDesc);
    static int  ValidateParams(HWND hDlg, HINSTANCE hInst, TCHAR *szDesc, BOOL bServer=FALSE);

};



#endif //_validate_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\snapin\tsmmc.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Fri Oct 15 18:57:39 1999
 */
/* Compiler settings for tsmmc.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __tsmmc_h__
#define __tsmmc_h__

/* Forward Declarations */ 

#ifndef __Compdata_FWD_DEFINED__
#define __Compdata_FWD_DEFINED__

#ifdef __cplusplus
typedef class Compdata Compdata;
#else
typedef struct Compdata Compdata;
#endif /* __cplusplus */

#endif 	/* __Compdata_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "mmc.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __TSMMCLib_LIBRARY_DEFINED__
#define __TSMMCLib_LIBRARY_DEFINED__

/* library TSMMCLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_TSMMCLib;

EXTERN_C const CLSID CLSID_Compdata;

#ifdef __cplusplus

class DECLSPEC_UUID("3d5d035e-7721-4b83-a645-6c07a3d403b7")
Compdata;
#endif
#endif /* __TSMMCLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\snapin\validate.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "shlwapi.h"
#include "validate.h"

int CValidate::ValidateParams(HWND hDlg, HINSTANCE hInst, TCHAR *szDesc, BOOL bServer)
{
    TCHAR szTitle[MAX_PATH] = _T(""), szText[MAX_PATH] = _T("");
    LoadString(hInst, IDS_MAINWINDOWTITLE, szTitle, SIZEOF_TCHARBUFFER(szTitle));

    LoadString(hInst, bServer ? IDS_INVALID_SERVER_NAME : IDS_INVALID_DOMAIN_NAME,
               szText, SIZEOF_TCHARBUFFER(szText));

    if (!*szDesc)
    {
        TCHAR szText[MAX_PATH] = _T("");
        LoadString(hInst, IDS_E_SPECIFY_SRV, szText, SIZEOF_TCHARBUFFER(szText));
        MessageBox(hDlg, szText, szTitle, MB_OK|MB_ICONSTOP);
        return 1;
    }

    if (bServer) //The characters cannot contain even spaces and tabs.
    {
        if ( (NULL != _tcschr(szDesc, _T(' '))) || (NULL != _tcschr(szDesc, _T('\t'))) )
        {
            MessageBox(hDlg, szText, szTitle, MB_OK|MB_ICONSTOP);
            return 1;
        }
    }

    //Kill all the leading spaces and trailing spaces.
    StrTrim(szDesc, L" \t");

    //Not all characters can be white spaces. Now that all the leading and
    //trailing spaces are removed, verify if the string has become empty.
    if (!*szDesc)
    {
        TCHAR szText[MAX_PATH] = _T("");
        LoadString(hInst, IDS_ALL_SPACES, szText, SIZEOF_TCHARBUFFER(szText));
        MessageBox(hDlg, szText, szTitle, MB_OK|MB_ICONSTOP);
        return 1;
    }

    //The characters ;  :  "  <  >  *  +  =  \  |  ?  , are illegal in machine name.
    while (*szDesc)
    {
        if ( (*szDesc == _T(';')) || (*szDesc == _T(':')) || (*szDesc == _T('"')) || (*szDesc == _T('<')) ||
             (*szDesc == _T('>')) || (*szDesc == _T('*')) || (*szDesc == _T('+')) || (*szDesc == _T('=')) ||
             (*szDesc == _T('\\')) || (*szDesc == _T('|')) || (*szDesc == _T(',')) || (*szDesc == _T('?')) )
        {
            MessageBox(hDlg, szText, szTitle, MB_OK|MB_ICONSTOP);
            return 1;
        }
        szDesc = CharNext(szDesc);
    }
    return 0;
}

BOOL CValidate::IsValidUserName(TCHAR *szDesc)
{
    //A user name cannot consist solely of periods (.) and spaces.
    //NOTE:- "     " is invalid. ")))))" is invalid.
    //But "(((.)   )" is a valid string. (Confusion?)

    TCHAR szTemp[CL_MAX_USERNAME_LENGTH + 1] = _T("");

    lstrcpy(szTemp, szDesc);
    StrTrim(szTemp, _T(" "));
    if (!*szTemp)
        return FALSE;

    lstrcpy(szTemp, szDesc);
    StrTrim(szTemp, _T("."));
    if (!*szTemp)
        return FALSE;

    lstrcpy(szTemp, szDesc);
    StrTrim(szTemp, _T("("));
    if (!*szTemp)
        return FALSE;

    lstrcpy(szTemp, szDesc);
    StrTrim(szTemp, _T(")"));
    if (!*szTemp)
        return FALSE;

    return TRUE; //OK
}

int CValidate::ValidateUserName(HWND hwnd, HINSTANCE hInst, TCHAR *szDesc)
{
    TCHAR szTitle[MAX_PATH] = _T(""), szText[MAX_PATH] = _T("");
    LoadString(hInst, IDS_MAINWINDOWTITLE, szTitle, SIZEOF_TCHARBUFFER(szTitle));    

    //At this stage the user name can be empty.
    if (!*szDesc)
        return 0; //No problems.

    if (*szDesc)
    {
        if (!IsValidUserName(szDesc))
        {
            LoadString(hInst, IDS_INVALID_PARAMS, szText, SIZEOF_TCHARBUFFER(szText));
            MessageBox(hwnd, szText, szTitle, MB_OK|MB_ICONSTOP);
            return 1;
        }
    }
    //The characters "  /  \  [  ]  :  ;  |  =  ,  +  *  ?  <  > are illegal in user name.
    while (*szDesc)
    {
        if ( (*szDesc == _T('"')) || (*szDesc == _T('/')) || (*szDesc == _T('\\')) || (*szDesc == _T('[')) ||
             (*szDesc == _T(']')) || (*szDesc == _T(':')) || (*szDesc == _T(';')) || (*szDesc == _T('|')) ||
             (*szDesc == _T('=')) || (*szDesc == _T(',')) || (*szDesc == _T('+'))  ||(*szDesc == _T('*')) ||
             (*szDesc == _T('?')) || (*szDesc == _T('<')) || (*szDesc == _T('>')))
        {
            LoadString(hInst, IDS_INVALID_USER_NAME, szText, SIZEOF_TCHARBUFFER(szText));
            MessageBox(hwnd, szText, szTitle, MB_OK|MB_ICONSTOP);
            return 1;
        }
        szDesc = CharNext(szDesc);
    }
    return 0;
}


BOOL
CValidate::Validate(HWND hDlg, HINSTANCE hInst)
{
    //Validate the description.
    TCHAR szBuf[MAX_PATH] = _T("");
    GetDlgItemText(hDlg, IDC_DESCRIPTION, szBuf, SIZEOF_TCHARBUFFER(szBuf) - 1);

    TCHAR szTitle[MAX_PATH] = _T("");
    LoadString(hInst, IDS_MAINWINDOWTITLE, szTitle, SIZEOF_TCHARBUFFER(szTitle));

    //Do a validation for the server name entered.
    GetDlgItemText(hDlg, IDC_SERVER, szBuf, SIZEOF_TCHARBUFFER(szBuf) - 1);
    if (0 < ValidateParams(hDlg, hInst, szBuf, TRUE))
    {
        HWND hEdit = GetDlgItem(hDlg, IDC_SERVER);
        SetFocus(hEdit);
        SendMessage(hEdit, EM_SETSEL, (WPARAM) 0, (LPARAM) -1);
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
        return FALSE;
    }

    GetDlgItemText(hDlg, IDC_USERNAME, szBuf, SIZEOF_TCHARBUFFER(szBuf) - 1);

    if (0 < ValidateUserName(hDlg, hInst, szBuf))
    {
        HWND hEdit= GetDlgItem(hDlg, IDC_USERNAME);
        SendMessage(hEdit, EM_SETSEL, (WPARAM) 0, (LPARAM) -1);
        SetFocus(hEdit);
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
        return FALSE;
    }

    GetDlgItemText(hDlg, IDC_DOMAIN, szBuf, SIZEOF_TCHARBUFFER(szBuf) - 1);

    if (*szBuf)
    {
        if (0 < ValidateParams(hDlg, hInst, szBuf))
        {
            HWND hEdit = GetDlgItem(hDlg, IDC_DOMAIN);
            //Now the domain name is stripped off any leading and trailing
            //spaces and tabs. Set this as the new text.
            SetDlgItemText(hDlg, IDC_DOMAIN, szBuf);
            SetFocus(hEdit);
            SendMessage(hEdit, EM_SETSEL, (WPARAM) 0, (LPARAM) -1);
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
            return FALSE;
        }
        SetDlgItemText(hDlg, IDC_DOMAIN, szBuf);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\uilib\browsesrv.cpp ===
//
// browsesrv.cpp: browse for servers list box
//
// This file is built for both UNICODE and ANSI
// and is shared between the mstsc replacement (clshell) and
// the mmc client
//

#include "stdafx.h"
#include "browsesrv.h"

//#include "atlconv.h"
#include "winsock.h"
#include "wuiids.h"

CBrowseServersCtl::CBrowseServersCtl(HINSTANCE hResInstance) : _hInst(hResInstance)
{
    bIsWin95 = FALSE;
    hLibrary = NULL;
#ifndef OS_WINCE
    lpfnNetServerEnum = NULL;
    lpfnNetApiBufferFree = NULL;
    lpfnNetServerEnum2 = NULL;
    lpfnNetWkStaGetInfo = NULL;
    lpfnNetWkStaGetInfo_NT = NULL;
    lpfnDsGetDcName = NULL;
    lpfnNetEnumerateTrustedDomains = NULL;
#else
    lpfnWNetOpenEnum = NULL;
    lpfnWNetEnumResource = NULL;
    lpfnWNetCloseEnum = NULL;
#endif
    _fbrowseDNSDomain = FALSE;
    _hEvent = NULL;
    _hwndDialog = NULL;
    _refCount = 0;

    _nServerImage=0;
    _nDomainImage=0;
    _nDomainSelectedImage=0;
    _hPrev = (HTREEITEM) TVI_FIRST; 
    _hPrevRootItem = NULL; 
    _hPrevLev2Item = NULL;
}

CBrowseServersCtl::~CBrowseServersCtl()
{
//    ASSERT(0 == _refCount);
#ifdef OS_WINCE
    if (hLibrary)
        FreeLibrary(hLibrary);
#endif
}

//
// Ref count mechanism is used to control lifetime because up to two threads
// use this class and have different lifetimes..
//
DCINT CBrowseServersCtl::AddRef()
{
    #ifdef OS_WIN32
    return InterlockedIncrement( ( LPLONG )&_refCount );
    #else
    return InterlockedIncrement(  ++_refCount );
    #endif
}

DCINT CBrowseServersCtl::Release()
{
    #ifdef OS_WIN32
    if( InterlockedDecrement( ( LPLONG )&_refCount ) == 0 )
    #else
    if(0 == --_refCount)
    #endif
    {
        delete this;

        return 0;
    }
    return _refCount;
}

//
// Initialize the image lists
//

#define NUM_IMGLIST_ICONS 2
BOOL CBrowseServersCtl::Init(HWND hwndDlg)
{
    HIMAGELIST himl;  // handle to image list 
    HICON hIcon;      // handle to icon
    HWND hwndTV = NULL;
    UINT uFlags = TRUE;
    int cxSmIcon;
    int cySmIcon;

    cxSmIcon = GetSystemMetrics(SM_CXSMICON);
    cySmIcon = GetSystemMetrics(SM_CYSMICON);

    hwndTV = GetDlgItem( hwndDlg, UI_IDC_SERVERS_TREE);
    if(!hwndTV)
    {
        return FALSE;
    }

    // Create the image list. 
    if ((himl = ImageList_Create(cxSmIcon, cySmIcon, 
        TRUE, NUM_IMGLIST_ICONS, 1)) == NULL)
    {
        return FALSE; 
    }

    // Add icons for the tree (computer, domain)
    hIcon = (HICON)LoadImage(_hInst, MAKEINTRESOURCE(UI_IDI_SERVER), IMAGE_ICON,
            cxSmIcon, cySmIcon, LR_DEFAULTCOLOR); 
    if (hIcon)
    {
        _nServerImage = ImageList_AddIcon(himl, hIcon); 
        DestroyIcon(hIcon); 
    }

    hIcon = (HICON)LoadImage(_hInst, MAKEINTRESOURCE(UI_IDI_DOMAIN), IMAGE_ICON,
            cxSmIcon, cySmIcon, LR_DEFAULTCOLOR); 
    if (hIcon)
    {
        _nDomainImage = ImageList_AddIcon(himl, hIcon); 
        DestroyIcon(hIcon); 
    }

    // Fail if not all of the images were added. 
    if (ImageList_GetImageCount(himl) < NUM_IMGLIST_ICONS) 
        return FALSE; 

    // Associate the image list with the tree view control. 
    TreeView_SetImageList(hwndTV, himl, TVSIL_NORMAL); 

    return TRUE; 
}

//
// Cleanup any image lists that need to be freed
//
BOOL CBrowseServersCtl::Cleanup()
{
    return TRUE;
}

#ifdef OS_WIN32

/****************************************************************************/
/* Name:      PopulateListBox                                             */
/*                                                                          */
/* Purpose:   Fills in the owner-draw list box with the Hydra servers       */
/*                                                                          */
/* Returns:   pointer to a domain list box item array.                      */
/*                                                                          */
/* Params:  HWND hwndDlg Handle to the dialogwindow containing the list-box */
/****************************************************************************/
ServerListItem*
CBrowseServersCtl::PopulateListBox(
    HWND hwndDlg,
    DCUINT *pDomainCount
    )
{
    //
    // check to see we are running on win9x and call out appropriate worker
    // routine.
    //
#ifndef OS_WINCE
    if( bIsWin95 == TRUE ) {
        return( PopulateListBox95(hwndDlg, pDomainCount) );
    }
#endif
    return( PopulateListBoxNT(hwndDlg, pDomainCount) );
}

#ifndef OS_WINCE
/****************************************************************************/
/* Name:      PopulateListBox95                                           */
/*                                                                          */
/* Purpose:   Fills in the owner-draw list box with the Hydra servers       */
/*                                                                          */
/* Returns:   pointer to a domain list box item array.                      */
/*                                                                          */
/* Params:  HWND hwndDlg Handle to the dialogwindow containing the list-box */
/****************************************************************************/

ServerListItem*
CBrowseServersCtl::PopulateListBox95(
    HWND hwndDlg,
    DCUINT *pDomainCount
    )
{
    DWORD dwError;

    ServerListItem *plbi = NULL;
    ServerListItem *plbiAllotted = NULL;
    ServerListItem *plbiReturned = NULL;

    DWORD dwIndex = 0;
    struct wksta_info_10 *pwki10 = NULL;

    unsigned short cb;
    DWORD dwDomains;
    int nCount;
    HWND hTree = NULL;


    hTree = GetDlgItem( hwndDlg, UI_IDC_SERVERS_TREE );

    //
    // set return parameters to zero first.
    //

    *pDomainCount = 0;

    //
    // check to see the load library was done before calling this
    // routine, if not, simply return.
    //

    if( lpfnNetWkStaGetInfo == NULL ) {
        dwError = ERROR_INVALID_DATA;
        goto Cleanup;
    }

    if( hwndDlg == NULL ) {
        dwError = ERROR_INVALID_HANDLE;
        goto Cleanup;
    }

    //
    // get work group domain.
    //

    dwError = (*lpfnNetWkStaGetInfo)(NULL, 10, NULL, 0, &cb);

    if( dwError != NERR_BufTooSmall ) {
        goto Cleanup;
    }

    //
    // allocated required buffer size.
    //

    pwki10 = (struct wksta_info_10 *)LocalAlloc(LMEM_FIXED, cb);

    if( pwki10 == NULL ){
        dwError = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // query again.
    //

    dwError = (*lpfnNetWkStaGetInfo)(NULL, 10, (char *)pwki10, cb, &cb);

    if( dwError != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // check to see we are browsing a dns domain also, if so, allocated 2 list
    // entries.
    //

    dwDomains = _fbrowseDNSDomain ? 2 : 1;

    plbiAllotted = plbi =
        (ServerListItem*)LocalAlloc( LMEM_FIXED, sizeof(ServerListItem) * dwDomains );

    if( plbiAllotted == NULL ) {
        dwError = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // display and expand DNS domain if we need to.
    //

    if( _fbrowseDNSDomain ) {

        _tcscpy( plbi->ContainerName, (LPTSTR)_browseDNSDomainName );
        plbi->Comment[0] = _T('\0');
        plbi->bContainsServers = TRUE;
        plbi->bServersExpandedOnce = FALSE;
        plbi->bDNSDomain = TRUE;
        plbi->nServerCount = 0;
        plbi->ServerItems = NULL;

        AddItemToTree( hTree, plbi->ContainerName, NULL,
                       plbi, SRV_TREE_DOMAINLEVEL);

        //
        // Expand DNS Domain
        //

        ExpandDomain(hwndDlg, plbi->ContainerName, plbi, &dwIndex);

        //
        // move to the next list box entry.
        //

        plbi++;
    }

    //
    // fill up the work group domain now.
    //
    #ifdef UNICODE
    //
    // convert to UNICODE.
    //
    nCount =
        MultiByteToWideChar(
            CP_ACP,
            MB_COMPOSITE,
            (LPSTR)pwki10->wki10_langroup,
            -1,
            plbi->ContainerName,
            sizeof(plbi->ContainerName)/sizeof(WCHAR));

    if( nCount == 0 )
    {
        dwError = GetLastError();
        goto Cleanup;
    }
    #else
    _tcscpy( plbi->ContainerName, pwki10->wki10_langroup );
    #endif
    
    plbi->Comment[0] = _T('\0');
    plbi->bContainsServers = TRUE;
    plbi->bServersExpandedOnce = FALSE;
    plbi->bDNSDomain = FALSE;
    plbi->nServerCount = 0;
    plbi->ServerItems = NULL;

    AddItemToTree( hTree, plbi->ContainerName, NULL,
                   plbi, SRV_TREE_DOMAINLEVEL);


    //
    // Expand the present Domain
    //

    ExpandDomain(hwndDlg, NULL, plbi, &dwIndex);

    //
    // we successfully populated the domain list,
    // set return parameters.
    //

    plbiReturned = plbiAllotted;
    *pDomainCount = dwDomains;

    plbiAllotted = NULL;

    dwError = ERROR_SUCCESS;

Cleanup:

    if( plbiAllotted != NULL ) {
        LocalFree(plbiAllotted);
    }

    if( pwki10 != NULL ) {
        LocalFree(pwki10);
    }

    SetLastError( dwError );
    return plbiReturned;
}
#endif

/****************************************************************************/
/* Name:      PopulateListBoxNT                                           */
/*                                                                          */
/* Purpose:   Fills in the owner-draw list box with the Hydra servers       */
/*                                                                          */
/* Returns:   pointer to a domain list box item array.                      */
/*                                                                          */
/* Params:  HWND hwndDlg Handle to the dialogwindow containing the list-box */
/****************************************************************************/

ServerListItem*
CBrowseServersCtl::PopulateListBoxNT(
    HWND hwndDlg,
    DCUINT *pdwDomainCount
    )
{
    DWORD dwError;
    PDCTCHAR pchTrustedDomains = NULL;
    PDCTCHAR pchTDomain;

    DCUINT dwDomainCount = 0;
    ServerListItem *plbiAllotted = NULL;
    ServerListItem *plbiReturned = NULL;
    ServerListItem *plbi;
    HWND hTree = NULL;

    DWORD dwDlgIndex=0;
    DWORD i;

    hTree = GetDlgItem( hwndDlg, UI_IDC_SERVERS_TREE );
    //
    // set the return parameter to zero first.
    //

    *pdwDomainCount = 0;

    if( hwndDlg == NULL ) {
        dwError = ERROR_INVALID_HANDLE;
        goto Cleanup;
    }

    //
    // enumurate trusted domain names.
    //

    pchTrustedDomains = UIGetTrustedDomains();

    if( pchTrustedDomains == NULL ) {
        dwError = ERROR_CANT_ACCESS_DOMAIN_INFO;
        goto Cleanup;
    }

    //
    // count number of domains.
    //

    pchTDomain = pchTrustedDomains;
    while( *pchTDomain != _T('\0') ) {
        dwDomainCount++;
        pchTDomain += (_tcslen(pchTDomain) + 1);
    }

    //
    // check to see we need to browse the DNS domain.
    //

    if( _fbrowseDNSDomain ) {
        dwDomainCount++;
    }

    //
    // allocate the memory for the ServerListItem (based on the no. of domains)
    //

    plbiAllotted = (ServerListItem *)
        LocalAlloc( LMEM_FIXED, (sizeof(ServerListItem) * dwDomainCount) );

    if ( plbiAllotted == NULL ) {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // set scan variables.
    //

    plbi = plbiAllotted;
    pchTDomain = pchTrustedDomains;

    //
    // display and expand DNS domain if we need to.
    //

    if( _fbrowseDNSDomain ) {

        _tcscpy(plbi->ContainerName, (LPTSTR)_browseDNSDomainName );
        plbi->Comment[0] = _T('\0');
        plbi->bContainsServers = TRUE;
        plbi->bServersExpandedOnce = FALSE;
        plbi->bDNSDomain = TRUE;
        plbi->nServerCount = 0;
        plbi->ServerItems = NULL;
        plbi->hTreeParentItem = NULL;

        plbi->hTreeItem = AddItemToTree( hTree, plbi->ContainerName,
                                         NULL, plbi, SRV_TREE_DOMAINLEVEL);
        //
        // expand the primary domain
        //

        ExpandDomain(hwndDlg, plbi->ContainerName, plbi, &dwDlgIndex);

        //
        // move to next list entry.
        //
        plbi++;
    }

    //
    // first entry in the domain list is the primary domain,
    // display it and expand it by default.
    //

    _tcscpy(plbi->ContainerName, pchTDomain);
    plbi->Comment[0] = _T('\0');
    plbi->bContainsServers = TRUE;
    plbi->bServersExpandedOnce = FALSE;
    plbi->bDNSDomain = FALSE;
    plbi->nServerCount = 0;
    plbi->ServerItems = NULL;
    plbi->hTreeParentItem = NULL;

    plbi->hTreeItem = AddItemToTree( hTree, pchTDomain, NULL, plbi,
                   SRV_TREE_DOMAINLEVEL);


    //
    // expand the primary domain
    //

    if(ExpandDomain(hwndDlg, NULL, plbi, &dwDlgIndex))
    {
        if(plbi->hTreeItem)
        {
            //Expand default domain
            TreeView_Expand( hTree, plbi->hTreeItem, TVE_EXPAND);
        }
    }

    //
    // display other domains, don't expand them.
    //

    for((i = (_fbrowseDNSDomain == TRUE) ? 2 : 1); i < dwDomainCount; i++) {

        //
        // move to the next entry in the domain list.
        //

        plbi++;
        pchTDomain += (_tcslen(pchTDomain) + 1);

        _tcscpy(plbi->ContainerName, pchTDomain);
        plbi->Comment[0] = _T('\0');
        plbi->bContainsServers = TRUE;
        plbi->bServersExpandedOnce = FALSE;
        plbi->bDNSDomain = FALSE;
        plbi->nServerCount = 0;
        plbi->ServerItems = NULL;
        plbi->hTreeParentItem = NULL;

        plbi->hTreeItem = AddItemToTree( hTree, pchTDomain, NULL, plbi,
                       SRV_TREE_DOMAINLEVEL);

    }

    //
    // we successfully populated the domain list,
    // set return parameters.
    //
    *pdwDomainCount = dwDomainCount;
    plbiReturned = plbiAllotted;
    plbiAllotted = NULL;
    dwError = ERROR_SUCCESS;

Cleanup:

    if( pchTrustedDomains != NULL ) {
        LocalFree( pchTrustedDomains );
    }

    if( plbiAllotted != NULL ) {
        LocalFree( plbiAllotted );
    }

    SetLastError( dwError );
    return( plbiReturned );
}

#endif //OS_WIN32

#ifdef OS_WIN32
/****************************************************************************/
/* Name:      LoadLibraries                                                 */
/*                                                                          */
/* Purpose:   Load the appropriate libraries for win95 and winnt.           */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    None                                                          */
/****************************************************************************/
void CBrowseServersCtl::LoadLibraries(void)
{
#ifndef OS_WINCE
    OSVERSIONINFOA osVersionInfo;
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

    //A version to avoid wrapping
    if(GetVersionExA(&osVersionInfo) == TRUE)
    {
        if(VER_PLATFORM_WIN32_WINDOWS == osVersionInfo.dwPlatformId )
        {
            bIsWin95 = TRUE;
            if(!hLibrary)
            {
                hLibrary = LoadLibrary(__T("msnet32.dll"));
            }
            if(NULL == hLibrary)
                return ;

            lpfnNetServerEnum2 = (LPFNNETSERVERENUM2)GetProcAddress((HMODULE)hLibrary,
                                                                    (LPCSTR)0x0029);

            lpfnNetWkStaGetInfo = (LPFNNETWKSTAGETINFO)GetProcAddress((HMODULE)hLibrary,
                                                                      (LPCSTR)0x0039);
        }
        else if(VER_PLATFORM_WIN32_NT == osVersionInfo.dwPlatformId )
        {
            if(!hLibrary)
            {
                hLibrary = LoadLibrary(__T("NetApi32.dll"));
            }
            if(NULL == hLibrary)
                return;

            lpfnNetServerEnum = (LPFNNETSERVERENUM)
                                              GetProcAddress((HMODULE)hLibrary,
                                               "NetServerEnum");

            lpfnNetApiBufferFree = (LPFNNETAPIBUFFERFREE)
                                              GetProcAddress((HMODULE)hLibrary,
                                                "NetApiBufferFree");

            lpfnNetWkStaGetInfo_NT = (LPFNNETWKSTAGETINFO_NT)GetProcAddress(
                                                (HMODULE)hLibrary,
                                                "NetWkstaGetInfo");

            lpfnNetEnumerateTrustedDomains = (LPFNNETENUMERATETRUSTEDDOMAINS)
                                              GetProcAddress((HMODULE)hLibrary,
                                                "NetEnumerateTrustedDomains");

#ifdef UNICODE
            lpfnDsGetDcName = (LPFNDSGETDCNAME)
                                             GetProcAddress((HMODULE)hLibrary,
                                                "DsGetDcNameW");
#else  // UNICODE
            lpfnDsGetDcName = (LPFNDSGETDCNAME)
                                             GetProcAddress((HMODULE)hLibrary,
                                                "DsGetDcNameA");
#endif // UNICODE
        }
    }
    return;
#else
    hLibrary = LoadLibrary(L"coredll.dll");
    lpfnWNetOpenEnum = (LPFNWNETOPENENUM )
                                      GetProcAddress((HMODULE)hLibrary,
                                       L"WNetOpenEnumW");
    lpfnWNetEnumResource = (LPFNWNETENUMRESOURCE )
                                      GetProcAddress((HMODULE)hLibrary,
                                       L"WNetEnumResourceW");
    lpfnWNetCloseEnum = (LPFNWNETCLOSEENUM )
                                      GetProcAddress((HMODULE)hLibrary,
                                       L"WNetCloseEnum");
#endif
                        
}
#endif //OS_WIN32

/****************************************************************************/
/* Name:      ExpandDomain                                                */
/*                                                                          */
/* Purpose:   Enumerates the Hydra Servers in a Domain/workgroup, adds      */
/*            them to the linked-list and as items in the list box.         */
/*                                                                          */
/* Returns:                                                                 */
/*                                                                          */
/* Params:  HWND hwndDlg Handle to the dialogwindow containing the list-box */
/****************************************************************************/

int CBrowseServersCtl::ExpandDomain(HWND hwndDlg, TCHAR *pDomainName,
                      ServerListItem *plbi, DWORD *pdwIndex)
{
    //
    // check to see we are expanding a DNS domain.
    //

    if( plbi->bDNSDomain ) {
        return( UIExpandDNSDomain( hwndDlg, pDomainName, plbi, pdwIndex ) );
    }

    //
    // check to we are running on Win9x machine.
    //
#ifndef OS_WINCE
    if( bIsWin95 == TRUE) {
        return( ExpandDomain95(hwndDlg, pDomainName, plbi, pdwIndex) );
    }
    else {
        return( ExpandDomainNT(hwndDlg, pDomainName, plbi, pdwIndex) );
    }
#else
    return ExpandDomainCE(hwndDlg, pDomainName, plbi, pdwIndex);
#endif
}//ExpandDomain


/****************************************************************************/
/* Name:      ExpandDomain95                                              */
/*                                                                          */
/* Purpose:   Enumerates the Hydra Servers in a Domain/workgroup, adds      */
/*            them to the linked-list and as items in the list box.         */
/*                                                                          */
/* Returns:                                                                 */
/*                                                                          */
/* Params:  HWND hwndDlg Handle to the dialogwindow containing the list-box */
/****************************************************************************/
#ifdef OS_WIN32
#ifndef OS_WINCE
int CBrowseServersCtl::ExpandDomain95(HWND hwndDlg, TCHAR *pDomainName,
                      ServerListItem *plbi, DWORD *pdwIndex)
{
    UNREFERENCED_PARAMETER(pDomainName);

    DWORD  dwIndex = *pdwIndex;
    unsigned short  AvailCount = 0, TotalEntries = 0;

    ServerListItem *plbistore = NULL, *pItemsStore = NULL;
    DCUINT index = 0, cb = 0;
    struct server_info_1 *pInfo1 = NULL;
    int  err = 0;
    int nCount = 0;
    HWND hTree = NULL;

    if(NULL == lpfnNetServerEnum2)
        return 0;

    SetCursor(LoadCursor(NULL, IDC_WAIT));

    if(!plbi->ServerItems)
    {

        // Determine how much information is available
        err = (*lpfnNetServerEnum2)(NULL, 1, NULL, 0, &AvailCount,
        &TotalEntries, HYDRA_SERVER_LANMAN_BITS, NULL);

        if(err != ERROR_MORE_DATA)
            return 0;

        // Allocate memory to receive the information
        // Give a little extra, since sometimes one is missed
        cb = (TotalEntries + 1) * sizeof(struct server_info_1);
        pInfo1 = (struct server_info_1 *)LocalAlloc(0, cb);

        if ( pInfo1 == NULL )
        {
            goto done1;
        }

        memset(pInfo1,0,cb);

        //
        // lpfnNetServerEnum2 is going to take a long time,


        // Retrieve the information
        err = (*lpfnNetServerEnum2)(
                    NULL,
                    1,
                    (char far *)pInfo1,
                    (unsigned short)cb,
                     &AvailCount,
                    &TotalEntries,
                    HYDRA_SERVER_LANMAN_BITS,
                    NULL);


        // Due to the dynamic nature of the network, we may get
        // ERROR_MORE_DATA, but that means we got the bulk of the
        // correct values, and we should display them
        if ((err != NERR_Success) && (err != ERROR_MORE_DATA))
            goto done1;

        //Allocate memory.
        cb = sizeof(ServerListItem)*AvailCount;
        plbi->ServerItems = (ServerListItem *)LocalAlloc(0, (sizeof(ServerListItem)*AvailCount));
        if ( plbi->ServerItems == NULL )
        {
            goto done1;
        }

        memset(plbi->ServerItems,0,sizeof(ServerListItem)*AvailCount);

        pItemsStore = plbi->ServerItems;

        if(IsBadWritePtr((LPVOID)plbi->ServerItems,sizeof(ServerListItem)*AvailCount))
            goto done1;

        // Traverse list, copy servers to plbi.
        for( index = 0; index < AvailCount; index++ )
        {
            if( ((pInfo1[index].sv1_version_major & MAJOR_VERSION_MASK) >=
                    4) && (pInfo1[index].sv1_version_minor >= 0) )
            {
#ifdef UNICODE
                nCount =
                    MultiByteToWideChar(
                        CP_ACP,
                        MB_COMPOSITE,
                        (LPSTR)pInfo1[index].sv1_name,
                        -1,
                        pItemsStore->ContainerName,
                        sizeof(pItemsStore->ContainerName)/sizeof(WCHAR));

                if( nCount == 0 )
                {
                    return 0;
                }                
#else
                _tcscpy(pItemsStore->ContainerName, pInfo1[index].sv1_name);
#endif

                if(pInfo1[index].sv1_comment != NULL)
                {
#ifdef UNICODE
                    nCount =
                        MultiByteToWideChar(
                            CP_ACP,
                            MB_COMPOSITE,
                            (LPSTR)pInfo1[index].sv1_comment,
                            -1,
                            pItemsStore->Comment,
                            sizeof(pItemsStore->Comment)/sizeof(WCHAR));

                    if( nCount == 0 )
                    {
                        return 0;
                    }                
#else
                    _tcscpy(pItemsStore->Comment, pInfo1[index].sv1_comment);
#endif
                }

                pItemsStore->bContainsServers = FALSE;
                pItemsStore++;
                plbi->nServerCount++;
            }
        }

done1:
        if ( AvailCount && pInfo1 )
        {
            LocalFree( pInfo1 );
        }
        if(!plbi->ServerItems)
        {
            return 0;
        }
    }
    else
        AvailCount = (unsigned short)plbi->nServerCount;

    // Traverse the plbi>ServerItems and add the servers to the List-box:
    pItemsStore = plbi->ServerItems;
    hTree = GetDlgItem( hwndDlg, UI_IDC_SERVERS_TREE );
    HTREEITEM hTreeParentNode = plbi->hTreeItem;
    for (index = 0; index < plbi->nServerCount; ++index)
    {
        if(hwndDlg)
        {
            if (DC_TSTRCMP(pItemsStore->ContainerName, _T("")))
            {
                pItemsStore->hTreeParentItem = hTreeParentNode;
                pItemsStore->hTreeItem = 
                    AddItemToTree(hTree, pItemsStore->ContainerName,
                                  hTreeParentNode,
                                  pItemsStore, SRV_TREE_SERVERLEVEL);
            }


        }
        pItemsStore++;
    }

    plbi->bServersExpandedOnce = TRUE;

    *pdwIndex = dwIndex;

    if(hwndDlg)
    {
        InvalidateRect(hwndDlg, NULL, TRUE);
    }

    SetCursor(LoadCursor(NULL, IDC_ARROW));

    return AvailCount;

}/* ExpandDomain95 */


/****************************************************************************/
/* Name:      ExpandDomainNT                                              */
/*                                                                          */
/* Purpose:   Enumerates the Hydra Servers in a Domain/workgroup, adds      */
/*            them to the linked-list and as items in the list box.         */
/*                                                                          */
/* Returns:                                                                 */
/*                                                                          */
/* Params:  HWND hwndDlg Handle to the dialogwindow containing the list-box */
/****************************************************************************/
int CBrowseServersCtl::ExpandDomainNT(HWND hwndDlg, TCHAR *pDomainName,
                      ServerListItem *plbi, DWORD *pdwIndex)
{
    DWORD  dwIndex = *pdwIndex, AvailCount = 0, TotalEntries = 0;
    SERVER_INFO_101 *pInfo = NULL;
    DCUINT index = 0;
    ServerListItem *plbistore = NULL, *pItemsStore = NULL;
    WCHAR pDomain[BROWSE_MAX_ADDRESS_LENGTH];
    int nCount = 0;
    HWND hTree = NULL;

    if(NULL == lpfnNetServerEnum)
        return 0;

    if(NULL == lpfnNetApiBufferFree)
        return 0;

    SetCursor(LoadCursor(NULL, IDC_WAIT));

    if(plbi->ServerItems)
    {
        AvailCount = plbi->nServerCount;
    }
    else
    {
        //
        //enumerate the servers in the primary domain if not already present
        //
        if(pDomainName)
        {
            #ifndef UNICODE
            nCount = MultiByteToWideChar(CP_ACP,
                                         MB_COMPOSITE,
                                         pDomainName,
                                         lstrlen(pDomainName) * sizeof(TCHAR),
                                         (LPWSTR)pDomain,
                                         sizeof(pDomain) / sizeof(TCHAR));

            if(nCount)
            {
                pDomain[nCount] = 0;
            }
            else
            {
                AvailCount = 0;
                goto done;
            }
            #else
            _tcsncpy( pDomain, (LPTSTR)pDomainName,
                      sizeof(pDomain)/sizeof(TCHAR) - 1);
            pDomain[sizeof(pDomain)/sizeof(TCHAR) - 1] = 0;
            #endif
        }

        //
        // lpfnNetServerEnum is going to take a long time,
        //

        if ((*lpfnNetServerEnum)(NULL,
                                 101,
                                 (LPBYTE *)&pInfo,
                                 (DWORD) -1,
                                 &AvailCount,
                                 &TotalEntries,
                                 HYDRA_SERVER_LANMAN_BITS,
                                 pDomainName ?
                                    (LPTSTR)pDomain :
                                    NULL,
                                 NULL ) || !AvailCount )
        {
            AvailCount = 0;
            goto done;
        }


        //Allocate memory.
        if ( (plbi->ServerItems = (ServerListItem *)LocalAlloc(0,
             (sizeof(ServerListItem)*AvailCount))) == NULL )
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto done;
        }

        memset(plbi->ServerItems,0,sizeof(ServerListItem)*AvailCount);
        pItemsStore = plbi->ServerItems;

        // Traverse list, copy servers to plbi.
        for( index = 0; index < AvailCount; index++ )
        {
            if( ((pInfo[index].sv101_version_major & MAJOR_VERSION_MASK) >=
                4) )
            {
                #ifdef UNICODE
                lstrcpy(pItemsStore->ContainerName, pInfo[index].sv101_name);
                lstrcpy(pItemsStore->Comment, pInfo[index].sv101_comment);
                #else

                WideCharToMultiByte(CP_ACP,
                                    WC_COMPOSITECHECK|WC_SEPCHARS,
                                    (LPCWSTR)pInfo[index].sv101_name,
                                    wcslen((const wchar_t *)pInfo[index].sv101_name),
                                    pItemsStore->ContainerName,
                                    sizeof(pItemsStore->ContainerName),
                                    NULL,
                                    NULL);

                WideCharToMultiByte(CP_ACP,
                                    WC_COMPOSITECHECK|WC_SEPCHARS,
                                    (LPCWSTR)pInfo[index].sv101_comment,
                                    wcslen((const wchar_t *)pInfo[index].sv101_comment),
                                    pItemsStore->Comment,
                                    sizeof(pItemsStore->Comment),
                                    NULL,
                                    NULL);
                #endif

                pItemsStore->bContainsServers = FALSE;
                pItemsStore++;
                plbi->nServerCount ++;
            }
        }

done:
        if ( AvailCount && pInfo )
        {
            (*lpfnNetApiBufferFree)( pInfo );
        }
    }

    // Traverse the plbi>ServerItems and add the servers to the List-box:
    pItemsStore = plbi->ServerItems;
    hTree = GetDlgItem( hwndDlg, UI_IDC_SERVERS_TREE );
    HTREEITEM hTreeParentNode = plbi->hTreeItem;
    for (index = 0; index < plbi->nServerCount;++index)
    {
        if(hwndDlg)
        {

            if (DC_TSTRCMP(pItemsStore->ContainerName, _T("")))
            {
                pItemsStore->hTreeParentItem = hTreeParentNode;
                pItemsStore->hTreeItem = 
                    AddItemToTree(hTree, pItemsStore->ContainerName,
                                  hTreeParentNode,
                                  pItemsStore, SRV_TREE_SERVERLEVEL);
           }

        }

        plbi->bServersExpandedOnce = TRUE;
        pItemsStore++;
    }

    *pdwIndex = dwIndex;

    SetCursor(LoadCursor(NULL, IDC_ARROW));

    return AvailCount;

} /* ExpandDomainNT */
#else

/****************************************************************************/
/* Name:      ExpandDomainCE                                                */
/*                                                                          */
/* Purpose:   Enumerates the Hydra Servers in a Domain/workgroup, adds      */
/*            them to the linked-list and as items in the list box.         */
/*                                                                          */
/* Returns:                                                                 */
/*                                                                          */
/* Params:  HWND hwndDlg Handle to the dialogwindow containing the list-box */
/****************************************************************************/
int CBrowseServersCtl::ExpandDomainCE(HWND hwndDlg, TCHAR *pDomainName,
                      ServerListItem *plbi, DWORD *pdwIndex)
{
    DWORD  AvailCount = 0;
    NETRESOURCE *pNetRsrc = NULL;
    HWND hTree = NULL;
    DWORD dwInitBufSize = 16*1024;

    if((NULL == lpfnWNetOpenEnum) || (NULL == lpfnWNetCloseEnum) || (NULL == lpfnWNetEnumResource))
        return 0;

    SetCursor(LoadCursor(NULL, IDC_WAIT));

    if(plbi->ServerItems)
    {
        AvailCount = plbi->nServerCount;
    }
    else
    {
        NETRESOURCE netrsrc;
        HANDLE hEnum = NULL;
        DWORD dwRet = NO_ERROR;

        netrsrc.dwScope = RESOURCE_GLOBALNET;
        netrsrc.dwType = RESOURCETYPE_ANY;
        netrsrc.dwDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
        netrsrc.dwUsage = RESOURCEUSAGE_CONTAINER;
        netrsrc.lpLocalName = NULL;
        netrsrc.lpRemoteName = pDomainName;
        netrsrc.lpComment = NULL;
        netrsrc.lpProvider = NULL;

        hTree = GetDlgItem( hwndDlg, UI_IDC_SERVERS_TREE );
        dwRet = lpfnWNetOpenEnum(RESOURCE_GLOBALNET, RESOURCETYPE_RESERVED, HYDRA_SERVER_LANMAN_BITS, &netrsrc, &hEnum);
        if ((dwRet != NO_ERROR) || (hEnum == NULL))
            return 0;

        AvailCount = 0;
        pNetRsrc = (NETRESOURCE *)LocalAlloc(0, dwInitBufSize);
        if (!pNetRsrc)
            goto done;

        while(dwRet == NO_ERROR)
        {
            DWORD dwCount, dwTempSize;
            dwCount = 0xffffffff;
            dwTempSize = dwInitBufSize;
            dwRet = lpfnWNetEnumResource(hEnum, &dwCount, pNetRsrc, &dwTempSize);
            if (dwRet == NO_ERROR)
            {
                AvailCount += dwCount;
                for (DWORD i=0; i<dwCount; i++)
                {
                    AddItemToTree(hTree, pNetRsrc[i].lpRemoteName,
                                  plbi->hTreeItem,
                                  NULL, SRV_TREE_SERVERLEVEL);
                }
            }
        }

        lpfnWNetCloseEnum(hEnum);
        hEnum = NULL;

done:
        if (pNetRsrc)
            LocalFree(pNetRsrc);
        lpfnWNetCloseEnum(hEnum);
    }

    SetCursor(LoadCursor(NULL, IDC_ARROW));

    return AvailCount;

} /* ExpandDomainCE */

#endif
#endif //OS_WIN32

/****************************************************************************/
/* Name:      UIGetTrustedDomains                                           */
/*                                                                          */
/* Purpose:   Queries teh registry for a list of the Trusted Domains        */
/*                                                                          */
/* Returns:                                                                 */
/*                                                                          */
/* Params:  HWND hwndDlg Handle to the dialogwindow containing the list-box */
/****************************************************************************/

#ifdef OS_WIN32
#ifndef OS_WINCE
PDCTCHAR CBrowseServersCtl::UIGetTrustedDomains()
{

    HKEY hKey = NULL;
    DWORD size = 0 , size1 = 0;
    PDCTCHAR pTrustedDomains = NULL;
    PDCTCHAR pPutHere = NULL;

    PDCTCHAR szPrimaryDomain = NULL;
    PDCTCHAR szWkstaDomainName = NULL;
    PDCTCHAR pDomain = NULL;

    BOOL bGetTrustedDomains = FALSE;
    OSVERSIONINFOA OsVer;

    memset(&OsVer, 0x0, sizeof(OSVERSIONINFOA));
    OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
    GetVersionExA(&OsVer);

    if(OsVer.dwMajorVersion <= 4)
    {
        // Get the current domain information from the winlogon settings.
        if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, DOMAIN_KEY, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
            DWORD dwResult = 0;

            dwResult = RegQueryValueEx(hKey, PRIMARY_VAL, NULL, NULL, NULL, &size);
            if (dwResult == ERROR_SUCCESS && size > 0)
            {
                szPrimaryDomain = (PDCTCHAR)LocalAlloc(LPTR, (size + 1)*sizeof(TCHAR));
                if (szPrimaryDomain == NULL)
                {
                    goto Cleanup;
                }
                if ((RegQueryValueEx(
                        hKey,
                        PRIMARY_VAL,
                        NULL, NULL,
                        (LPBYTE)szPrimaryDomain,
                        &size
                        ) == ERROR_SUCCESS) &&
                        szPrimaryDomain[0])
                {
                    pDomain = szPrimaryDomain;
                }
            }
        }
    }
    else
    {
        if(NULL == lpfnDsGetDcName)
            return 0;

        DOMAIN_CONTROLLER_INFO *pDCI = NULL;

        // this section gets the current domain the app is running on
        if((*lpfnDsGetDcName)(NULL, NULL, NULL,
                            NULL, DS_RETURN_FLAT_NAME,
                            &pDCI ) == NO_ERROR)
        {
            pDomain = pDCI->DomainName;
        }
    }

    // Get the domain/work group information from NetWkStaGetInfo
    if (lpfnNetWkStaGetInfo_NT)
    {
        LPBYTE buffer = NULL;
        if ((*lpfnNetWkStaGetInfo_NT)(NULL, 100, &buffer) == NERR_Success && buffer)
        {
            LPWSTR langroup = ((WKSTA_INFO_100 *)buffer)->wki100_langroup;
            DWORD langroupLen = (langroup) ? wcslen(langroup) : 0;

            if (langroupLen)
            {
                szWkstaDomainName = (PDCTCHAR)LocalAlloc(LPTR, (langroupLen + 1)*sizeof(TCHAR));
                if (szWkstaDomainName == NULL)
                {
                    goto Cleanup;
                }

#ifdef UNICODE
                _tcscpy(szWkstaDomainName,langroup);
                pDomain = szWkstaDomainName;
#else
                // convert the unicode string to ansi
                if (WideCharToMultiByte(CP_ACP,
                                     0,
                                     langroup,
                                     -1,
                                     szWkstaDomainName,
                                     (langroupLen + 1) * sizeof(TCHAR),
                                     NULL,
                                     NULL))
                {
                    pDomain = szWkstaDomainName;
                }
#endif
            }
            if (lpfnNetApiBufferFree)
            {
                (*lpfnNetApiBufferFree)(buffer);
            }
        }
    }

    //
    // We should get the list of trusted domains only when the machine belongs to a domain, not a workgroup
    // We determine that the machine belongs to a domain if the winlogon cached information, and the langroup from
    // NetWkstaGetInfo match.
    //
    if (szPrimaryDomain &&
        szPrimaryDomain[0] &&
        szWkstaDomainName &&
        _tcscmp(szPrimaryDomain, szWkstaDomainName) == 0)
    {
        bGetTrustedDomains = TRUE;
    }

    size = (pDomain) ? _tcslen(pDomain) : 0;

    if(size > 0)
    {
        if (bGetTrustedDomains && hKey != NULL && (OsVer.dwMajorVersion < 4))
        {
            if(ERROR_SUCCESS == RegQueryValueEx(hKey, CACHE_VAL_NT351,
                                                NULL, NULL,
                                                NULL, &size1))
            {
                pTrustedDomains = (PDCTCHAR)LocalAlloc(LPTR, (size + size1 + 2) * sizeof(TCHAR));
                if(NULL == pTrustedDomains)
                    goto Cleanup;
                 _tcscpy(pTrustedDomains, pDomain);

                pPutHere = pTrustedDomains;
                pPutHere += (_tcslen(pTrustedDomains) + 1);

                *pPutHere = _T('\0');
            }
           else
           {
                goto Cleanup;
           }
        }
        else if (bGetTrustedDomains && hKey != NULL && (4 == OsVer.dwMajorVersion) )
        {
            if(ERROR_SUCCESS == RegQueryValueEx(hKey, CACHE_VAL,
                                                NULL, NULL,
                                                NULL, &size1))
            {
                pTrustedDomains = (PDCTCHAR)LocalAlloc(LPTR, (size + size1 + 2) * sizeof(TCHAR));
                if(NULL == pTrustedDomains)
                    goto Cleanup;
                _tcscpy(pTrustedDomains, pDomain);

                pPutHere = pTrustedDomains;
                pPutHere += (_tcslen(pTrustedDomains) + 1);

                *pPutHere = _T('\0');

                RegQueryValueEx(hKey, CACHE_VAL, NULL, NULL, (LPBYTE)pPutHere, &size1);
            }
        }
        else if (5 <= OsVer.dwMajorVersion)
        {
            LPWSTR szDomainNames = NULL;

            if(NULL == lpfnNetEnumerateTrustedDomains)
                goto Cleanup;

            size1 = 0;
            DWORD dwCount;
            LPWSTR szWideBuf = NULL;
            if( (*lpfnNetEnumerateTrustedDomains)(NULL,
                                                  &szDomainNames ) == ERROR_SUCCESS )
            {
                szWideBuf = szDomainNames;
                while(*szWideBuf && (*szWideBuf+1))
                {
                    size1 += wcslen(szWideBuf) + 1;
                    szWideBuf += wcslen(szWideBuf) + 1;
                }
                szWideBuf = szDomainNames;
            }

            pTrustedDomains = (PDCTCHAR)LocalAlloc(LPTR, (size + size1 + 2) * sizeof(TCHAR));
            if(NULL == pTrustedDomains)
                goto Cleanup;
            _tcscpy(pTrustedDomains, pDomain);
            pPutHere = pTrustedDomains + _tcslen(pTrustedDomains) + 1;
            *pPutHere = _T('\0');

            if(size1)
            {
                //
                // CONVERT unicode domain name to ansi.
                //
            
                while(*szWideBuf && (*szWideBuf+1))
                {
    #ifndef UNICODE
                    WideCharToMultiByte(CP_ACP, 0, szWideBuf, -1,
                                        pPutHere, wcslen(szWideBuf) * sizeof(TCHAR), NULL, NULL );
    #else   // UNICODE
                    lstrcpy(pPutHere, szWideBuf);
    #endif  //UNICODE
                    pPutHere += _tcslen(pPutHere);
                    *pPutHere++ = 0;
                    szWideBuf += wcslen(szWideBuf) + 1;
                }

                if(NULL == lpfnNetApiBufferFree)
                    return 0;

                (*lpfnNetApiBufferFree)( szDomainNames );
            }
        }
    }

Cleanup:

    if (hKey)
    {
        RegCloseKey(hKey);
    }

    if (szPrimaryDomain)
    {
        LocalFree(szPrimaryDomain);
    }

    if (szWkstaDomainName)
    {
        LocalFree(szWkstaDomainName);
    }

    return pTrustedDomains;
}

#else

PDCTCHAR CBrowseServersCtl::UIGetTrustedDomains()
{

    HKEY hKey = NULL;
    DWORD size = 0;
    PDCTCHAR szPrimaryDomain = NULL;
    PDCTCHAR pTrustedDomains = NULL;

    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, DOMAIN_KEY, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        DWORD dwResult = 0;

        dwResult = RegQueryValueEx(hKey, PRIMARY_VAL, NULL, NULL, NULL, &size);
        if (dwResult == ERROR_SUCCESS && size > 0)
        {
            szPrimaryDomain = (PDCTCHAR)LocalAlloc(LPTR, (size + 1)*sizeof(TCHAR));
            if (szPrimaryDomain == NULL)
            {
                RegCloseKey(hKey);
                return NULL;
            }
            if ((RegQueryValueEx(
                    hKey,
                    PRIMARY_VAL,
                    NULL, NULL,
                    (LPBYTE)szPrimaryDomain,
                    &size
                    ) == ERROR_SUCCESS) &&
                    szPrimaryDomain[0])
            {
                pTrustedDomains = szPrimaryDomain;
            }
            else
            {
                LocalFree(szPrimaryDomain);
            }
        }
    }

    return pTrustedDomains;
}

#endif
#endif //OS_WIN32
/* UIGetTrustedDomains */


/****************************************************************************/
/* Name:      UIExpandDNSDomain                                             */
/*                                                                          */
/* Purpose:   Enumerates the Hydra Servers in a DNS Domain, adds            */
/*            them to the linked-list and as items in the list box.         */
/*                                                                          */
/* Returns:   numbers of server expanded                                    */
/*                                                                          */
/* Params:  HWND hwndDlg Handle to the dialogwindow containing the list-box */
/****************************************************************************/
int
CBrowseServersCtl::UIExpandDNSDomain(
    HWND hwndDlg,
    TCHAR *pDomainName,
    ServerListItem *plbi,
    DWORD *pdwIndex
    )
{
    DWORD dwError;

    LPHOSTENT lpHostEnt;
    LPHOSTENT lpRevHostEnt;
    DWORD dwIPEntries;

    LPSTR FAR *lplpIPEntry;
    DWORD FAR *lpIPAddrsAlloted = NULL;
    DWORD FAR *lpIPAddrs;

    ServerListItem *lpServerListItem = NULL;
    ServerListItem *lpLBItem;

    DWORD i;
    DWORD dwEntriesDisplayed = 0;
    HWND hTree = NULL;
    HTREEITEM hTreeParentNode = NULL;

    //
    // set cursor to wait cursor while we do this.
    //

    SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    // check to see the specified list box entry is server entry.
    //


//    TRC_ASSERT((plbi->bContainsServers == TRUE),
//        (TB,"Not a server entry"));

    if( plbi->bContainsServers == FALSE ) {
        dwError = ERROR_INVALID_DATA;
        goto Cleanup;
    }

    if( hwndDlg == NULL ) {
        dwError = ERROR_INVALID_DATA;
        goto Cleanup;
    }

    //
    // resolve the DNS domain name if it is not done before.
    //

    if( plbi->ServerItems == NULL ) {

#ifdef UNICODE

        WCHAR achDomainName[BROWSE_MAX_ADDRESS_LENGTH];
        DWORD dwCount;

        //
        // CONVERT unicode domain name to ansi.
        //


        dwCount =
            WideCharToMultiByte(
                CP_ACP,
                WC_COMPOSITECHECK | WC_SEPCHARS,
                pDomainName,
                -1,
                (LPSTR)achDomainName,
                sizeof(achDomainName),
                NULL,
                NULL);

        if( dwCount == 0 ) {
            dwError = GetLastError();
            goto Cleanup;
        }

        achDomainName[dwCount/sizeof(TCHAR)]= '\0';

        lpHostEnt = gethostbyname( (LPSTR)achDomainName );

#else // UNICODE

        //
        // resolve the domain name to ip address list.
        //

        lpHostEnt = gethostbyname( pDomainName );

#endif // UNICODE

        if( lpHostEnt == NULL ) {
            dwError = GetLastError();
            goto Cleanup;
        }

        //
        // we handle only IP address type.
        //
/*
        TRC_ASSERT((lpHostEnt->h_addrtype == PF_INET),
            (TB,"Invalid address type"));

        TRC_ASSERT((lpHostEnt->h_length == 4),
            (TB,"Invalid address length"));
*/            

        if( (lpHostEnt->h_addrtype != PF_INET) ||
                (lpHostEnt->h_length != 4) ) {

            dwError = ERROR_INVALID_DATA;
            goto Cleanup;
        }

        dwIPEntries = 0;
        lplpIPEntry = lpHostEnt->h_addr_list;

        while( *lplpIPEntry != NULL ) {
            dwIPEntries++;
            lplpIPEntry++;
        }

        //
        // allocate memory for the ip address list and
        // save for further use in this routine (only).
        //
        // Note: lpHostEnt points to a thread storeage
        // which is reused by gethostbyname() and
        // gethostbyaddr() calls with in the same
        // thread, since we need to call gethostbyaddr()
        // we better save the address list.
        //

        lpIPAddrsAlloted =
            lpIPAddrs = (DWORD FAR *)
                LocalAlloc( LMEM_FIXED, sizeof(DWORD) * dwIPEntries );


        if( lpIPAddrs == NULL ) {
            dwError = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }

        lplpIPEntry = lpHostEnt->h_addr_list;

        while( *lplpIPEntry != NULL ) {
            *lpIPAddrs =   *(DWORD *)(*lplpIPEntry);
            lpIPAddrs++;
            lplpIPEntry++;
        }

        //
        // allocate memory for domain ServerListItem array.
        //

        lpLBItem =
            lpServerListItem = (ServerListItem *)
                LocalAlloc( LMEM_FIXED, dwIPEntries * sizeof(ServerListItem) );

        if( lpServerListItem == NULL ) {
             dwError = ERROR_OUTOFMEMORY;
             goto Cleanup;
        }

        //
        // reverse resolve each ip address and get the name.
        //

        lpIPAddrs = lpIPAddrsAlloted;

        for( i = 0; i < dwIPEntries; i++ ) {

            CHAR achContainerName[BROWSE_MAX_ADDRESS_LENGTH];
            int nCount;
            BOOL bIPAddressString = FALSE;

            lpRevHostEnt =
                gethostbyaddr(
                    (LPSTR)lpIPAddrs,
                    sizeof(*lpIPAddrs),
                    PF_INET );


            //
            // if we can not reverse resolve the address or
            // if the host name is too long, or
            // display the ipaddress.
            //

            if( (lpRevHostEnt == NULL) ||
                ((strlen(lpRevHostEnt->h_name) + 1) >
                    (BROWSE_MAX_ADDRESS_LENGTH/sizeof(TCHAR)) ) ) {

                bIPAddressString = TRUE;
            }
            else {

                LPSTR lpszDomainName;

#ifdef UNICODE
                lpszDomainName = (LPSTR)achDomainName;
#else // UNICODE
                lpszDomainName = pDomainName;
#endif // UNICODE

                //
                // the resolved name is same of the orginal name,
                // display the ipaddress.
                //

                //
                // compare the entire name first.
                //

                if( _stricmp(
                        lpRevHostEnt->h_name,
                        lpszDomainName ) != 0 ) {

                    LPSTR lpszDotPostion1;
                    LPSTR lpszDotPostion2;
                    DWORD dwCmpLen = 0;

                    //
                    // compare the only the first part of the name.
                    //

                    lpszDotPostion1 = strchr( lpRevHostEnt->h_name, '.');
                    lpszDotPostion2 = strchr( lpszDomainName, '.');

                    if( (lpszDotPostion1 == NULL) &&
                        (lpszDotPostion2 != NULL) ) {

                        dwCmpLen = (DWORD)(lpszDotPostion2 - lpszDomainName);
                    }
                    else if( (lpszDotPostion1 != NULL) &&
                            (lpszDotPostion2 == NULL) ) {

                        dwCmpLen = (DWORD)(lpszDotPostion1 -
                                lpRevHostEnt->h_name);
                    }

                    if( dwCmpLen != 0 ) {

                        if( _strnicmp(
                            lpRevHostEnt->h_name,
                            lpszDomainName,
                            (size_t)dwCmpLen ) == 0 ) {

                            bIPAddressString = TRUE;
                        }
                    }
                }
                else {

                    bIPAddressString = TRUE;
                }
            }


            if( bIPAddressString ) {

                strcpy(
                    (LPSTR)achContainerName,
                    inet_ntoa( *(struct in_addr *)lpIPAddrs ));
            }
            else {
                strcpy( (LPSTR)achContainerName, lpRevHostEnt->h_name);
            }


#ifdef UNICODE

            //
            // convert to UNICODE.
            //

            nCount =
                MultiByteToWideChar(
                    CP_ACP,
                    MB_COMPOSITE,
                    (LPSTR)achContainerName,
                    -1,
                    lpLBItem->ContainerName,
                    sizeof(lpLBItem->ContainerName)/sizeof(WCHAR));

            if( nCount == 0 ) {
                dwError = GetLastError();
                goto Cleanup;
            }


            //
            // terminate converted string.
            //

            lpLBItem->ContainerName[nCount] = _T('\0');

#else // UNICODE

            strcpy( lpLBItem->ContainerName, (LPSTR)achContainerName );

#endif // UNICODE

            lpLBItem->Comment[0] = _T('\0');
            lpLBItem->bContainsServers = FALSE;;
            lpLBItem->bServersExpandedOnce = FALSE;
            lpLBItem->bDNSDomain = FALSE;
            lpLBItem->nServerCount = 0;
            lpLBItem->ServerItems = NULL;

            //
            // move to next entry.
            //

            lpLBItem++;
            lpIPAddrs++;
        }

        //
        // Hook the allotted ServerListItem to the server
        // structure, it will be used in future.
        //

        plbi->ServerItems = lpServerListItem;
        plbi->nServerCount = dwIPEntries;

        //
        // set lpServerListItem to NULL, so that
        // it will not get freed.
        //

        lpServerListItem = NULL;

    }

    //
    // When we are here ..
    //
    // plbi->ServerItems points to the servers ServerListItem array
    // and plbi->nServerCount has the count.
    //

    //
    // display entires.
    //

    lpLBItem = plbi->ServerItems;

    hTree = GetDlgItem( hwndDlg, UI_IDC_SERVERS_TREE );
    hTreeParentNode = plbi->hTreeItem;

    for( i = 0; i < plbi->nServerCount; i++ ) {

        lpLBItem->hTreeParentItem = hTreeParentNode;
        lpLBItem->hTreeItem = 
            AddItemToTree(hTree, lpLBItem->ContainerName,
                          hTreeParentNode,
                          lpLBItem, SRV_TREE_SERVERLEVEL);
        lpLBItem++;
    }

    //
    // Refresh the dialog box.
    //

    InvalidateRect(hwndDlg, NULL, TRUE);

    plbi->bServersExpandedOnce = TRUE;
    dwEntriesDisplayed = plbi->nServerCount;

    //
    // We are done.
    //

    dwError = ERROR_SUCCESS;

Cleanup:

    if( lpIPAddrsAlloted != NULL ) {
        LocalFree( lpIPAddrsAlloted );
    }

    if( lpServerListItem != NULL ) {
        LocalFree( lpServerListItem );
    }

    if( dwError != ERROR_SUCCESS ) {
    //TRC_NRM((TB, "UIExpandDNSDomain failed, %ld", dwError));
    }

    SetLastError( dwError );

    SetCursor(LoadCursor(NULL, IDC_ARROW));

    return( dwEntriesDisplayed );
}


#ifdef OS_WIN32
DWORD WINAPI CBrowseServersCtl::UIStaticPopListBoxThread(LPVOID lpvThreadParm)
{
    DWORD dwRetVal=0;
    //TRC_ASSERT(lpvThreadParm, (TB, "Thread param is NULL (instance pointer should be set)\n"));
    if(lpvThreadParm)
    {
        CBrowseServersCtl* pBrowseSrv = (CBrowseServersCtl*)lpvThreadParm;
        dwRetVal = pBrowseSrv->UIPopListBoxThread(NULL);
    }
    
    return dwRetVal;
}

/****************************************************************************/
/* Name:      UIPopListBoxThread                                            */
/*                                                                          */
/* Purpose:   Thread function to populate the list box.                     */
/*                                                                          */
/* Returns:   Success/Failure of the function                               */
/*                                                                          */
/* Params:                                                                  */
/*                                                                          */
/****************************************************************************/
DWORD WINAPI CBrowseServersCtl::UIPopListBoxThread(LPVOID lpvThreadParm)
{
    DWORD dwResult = 0;
    
    ServerListItem *pBrowsePlbi = NULL, *ptempList = NULL;
    DCUINT browseCount = 0;

    DC_IGNORE_PARAMETER(lpvThreadParm);
//    TRC_ASSERT( _hwndDialog, (TB, "_hwndDialog is not set\n"));

    PostMessage(_hwndDialog, UI_LB_POPULATE_START, 0, 0);

    LoadLibraries();
    pBrowsePlbi = PopulateListBox( _hwndDialog, &browseCount);

    //message is posted to the main thread to notify that the listbox has been populated
    PostMessage(_hwndDialog, UI_LB_POPULATE_END, 0, 0);

    //wait for the event to be signalled when the "connect server" dialog box is destroyed
    if(_hEvent)
    {
        DWORD dwRetVal;
        dwRetVal = WaitForSingleObject(_hEvent, INFINITE);
        if(WAIT_FAILED == dwRetVal)
        {
///         TRC_ASSERT(WAIT_FAILED != dwRetVal, (TB, "Wait failed\n"));
        }
        if(!CloseHandle(_hEvent))
        {
            DWORD dwLastErr = GetLastError();
//          TRC_ABORT((TB, "Close handle failed: GetLastError=%d\n",dwLastErr));
        }
    }


    ptempList = pBrowsePlbi;
    //free the ServerListItems and memory to linked-list

    if(pBrowsePlbi)
    {
        while(browseCount)
        {
            if(ptempList->ServerItems)
            {
                LocalFree((HANDLE)ptempList->ServerItems);
            }
            ptempList++;
            browseCount --;
        }

        LocalFree((HLOCAL)pBrowsePlbi);
    }

    //decrement ref count for this object held by this thread
    Release();

    return (dwResult);
} /*UIPopListBoxThread*/
#endif /* OS_WIN32 */


HTREEITEM CBrowseServersCtl::AddItemToTree( HWND hwndTV, LPTSTR lpszItem,
                                           HTREEITEM hParent,
                                           ServerListItem* pItem,
                                           int nLevel)
{

    TVITEM tvi; 
    TVINSERTSTRUCT tvins; 
#ifndef OS_WINCE
    HTREEITEM hti; 
#endif

    tvi.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE |TVIF_SELECTEDIMAGE;

    if(nLevel == SRV_TREE_DOMAINLEVEL)
    {
        //
        // Assume all domains have child servers
        // they won't actually be enumerated until
        // the user tries to expand the nodes
        //
        tvi.mask |= TVIF_CHILDREN;
        tvi.cChildren = 1; //min number of children, will be updated
        tvi.iImage = _nDomainImage; 
        tvi.iSelectedImage = _nDomainImage; 
    }
    else
    {
        tvi.iImage = _nServerImage; 
        tvi.iSelectedImage = _nServerImage; 
    }
        

    // Set the text of the item. 
    tvi.pszText = lpszItem; 
    tvi.cchTextMax = lstrlen(lpszItem); 


    // Save the ServerListItem info in the user defined area
    // data area. 
    tvi.lParam = (LPARAM) pItem; 

    tvins.item = tvi; 
    tvins.hInsertAfter = _hPrev; 

    // Set the parent item based on the specified level. 
    tvins.hParent = hParent; 

    // Add the item to the tree view control. 
    _hPrev = (HTREEITEM) SendMessage(hwndTV, TVM_INSERTITEM, 0, 
         (LPARAM) (LPTVINSERTSTRUCT) &tvins); 

    // Save the handle to the item. 
    if (nLevel == SRV_TREE_DOMAINLEVEL) 
        _hPrevRootItem = _hPrev; 
    else if (nLevel == SRV_TREE_SERVERLEVEL) 
        _hPrevLev2Item = _hPrev; 

    return _hPrev; 
}

//
//Handle TVN_ITEMEXPANDING
//
// On first expansion of a domain node, enumerate
// all the servers in that node and add them to the
// tree. Subsequent expands/collapses will just be handled
// by the tree.
//
// Return TRUE to allow expansion
// false otherwise
//
BOOL CBrowseServersCtl::OnItemExpanding(HWND hwndDlg, LPNMTREEVIEW nmTv)
{
    ServerListItem* pSrvItem = NULL;
    if(nmTv &&
       (TVE_EXPAND == nmTv->action) &&
       (nmTv->itemNew.mask & TVIF_PARAM))
    {
        //
        // Expanding, need to build the list
        // of servers for this domain
        //
        pSrvItem = (ServerListItem*)nmTv->itemNew.lParam;
        if(pSrvItem)
        {
            //
            // Only expanddomain if we've never expanded this node
            // before
            //
            if(!pSrvItem->bServersExpandedOnce)
            {
                //Attempt to expand the domain
                DWORD cItems = 0;
                if(ExpandDomain( hwndDlg, pSrvItem->ContainerName,
                                   pSrvItem, (DWORD*)&cItems))
                {
                    return TRUE;
                }
                else
                {
                    //
                    // Pop a message explaining that
                    // there are no TS's in this domain
                    //
                    UINT intRC;
                    TCHAR noTerminalServer[MAX_PATH];
                    intRC = LoadString(_hInst,
                        UI_IDS_NO_TERMINAL_SERVER,
                        noTerminalServer,
                        MAX_PATH);

                    if(intRC)
                    {
                        TCHAR title[MAX_PATH];
                        intRC = LoadString(_hInst,
                            UI_IDS_APP_NAME,
                            title,
                            MAX_PATH);

                        if(intRC)
                        {
                            DCTCHAR szBuffer[MAX_PATH +
                                BROWSE_MAX_ADDRESS_LENGTH];

                            _stprintf(szBuffer, noTerminalServer,
                                      pSrvItem->ContainerName);
                            MessageBox( hwndDlg, szBuffer, title,
                                         MB_OK | MB_ICONINFORMATION);
                        }
                    }
                    return FALSE;
                }
            }
            else
            {
                //Already expanded so everythign is cached
                //and ready to go, allow expansion
                return TRUE;
            }
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        //Allow everythign else to expand
        return TRUE;
    }
}

BOOL CBrowseServersCtl::OnNotify( HWND hwndDlg, WPARAM wParam, LPARAM lParam)
{
    LPNMHDR pnmh = (LPNMHDR) lParam;
    if(pnmh)
    {
        switch( pnmh->code)
        {
            case TVN_ITEMEXPANDING:
            {
                return OnItemExpanding(
                            hwndDlg, (LPNMTREEVIEW) lParam);
            }
            break;
        }
    }
    return TRUE;
}

#ifndef OS_WINCE
//
// Returns currently selected server
// or false if current selection is not a server but a domain
//
BOOL CBrowseServersCtl::GetServer(LPTSTR szServer, int cchLen)
{
    HTREEITEM hti;
    HWND hTree;

    if(!_hwndDialog)
    {
        return FALSE;
    }

    hTree = GetDlgItem( _hwndDialog, UI_IDC_SERVERS_TREE );

    hti = TreeView_GetSelection( hTree );
    if( hti )
    {
        TVITEM item;
        item.hItem = hti;
        item.mask = TVIF_PARAM;
        if(TreeView_GetItem( hTree, &item))
        {
            ServerListItem* ps = (ServerListItem*)item.lParam;
            if(ps && !ps->bContainsServers)
            {
                _tcsncpy( szServer, ps->ContainerName, cchLen);
                return TRUE;
            }
            
        }
    }
    return FALSE;
}

#else

BOOL CBrowseServersCtl::GetServer(LPTSTR szServer, int cchLen)
{
    HTREEITEM hti;
    HWND hTree;

    if(!_hwndDialog)
    {
        return FALSE;
    }

    hTree = GetDlgItem( _hwndDialog, UI_IDC_SERVERS_TREE );

    hti = TreeView_GetSelection( hTree );
    if( hti )
    {
        TVITEM item;
        item.hItem = hti;
        item.mask = TVIF_TEXT | TVIF_PARAM;;
        item.pszText = szServer; 
        item.cchTextMax = cchLen; 

        if(TreeView_GetItem( hTree, &item))
        {
            _tcsncpy( szServer, item.pszText, item.cchTextMax);
            return TRUE;
        }
    }
    return FALSE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\snapin\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#ifndef _STDAFX_H_
#define _STDAFX_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>
#include <atlhost.h>


#define SIZEOF_TCHARBUFFER( x )  sizeof( x ) / sizeof( TCHAR )
#define SIZE_OF_BUFFER( x ) sizeof( x ) / sizeof( TCHAR )

#ifdef DBG
#define ODS OutputDebugString

#define DBGMSG( x , y ) \
    {\
    TCHAR tchErr[80]; \
    wsprintf( tchErr , x , y ); \
    ODS( tchErr ); \
    }

#define VERIFY_E( retval , expr ) \
    if( ( expr ) == retval ) \
    {  \
       ODS( L#expr ); \
       ODS( L" returned "); \
       ODS( L#retval ); \
       ODS( L"\n" ); \
    } \


#define VERIFY_S( retval , expr ) \
    if( ( expr ) != retval ) \
{\
      ODS( L#expr ); \
      ODS( L" failed to return " ); \
      ODS( L#retval ); \
      ODS( L"\n" ); \
}\

#define ASSERT( expr ) \
    if( !( expr ) ) \
    { \
       char tchAssertErr[ 80 ]; \
       wsprintfA( tchAssertErr , "Assertion in expression ( %s ) failed\nFile - %s\nLine - %d\nDo you wish to Debug?", #expr , (__FILE__) , __LINE__ ); \
       if( MessageBoxA( NULL , tchAssertErr , "ASSERTION FAILURE" , MB_YESNO | MB_ICONERROR )  == IDYES ) \
       {\
            DebugBreak( );\
       }\
    } \
    
#define HR_RET_IF_FAIL( q ) \
         if(FAILED(q)) \
         { \
            ASSERT(!FAILED(q));\
            return q; \
         } \
         
#else

#define ODS
#define DBGMSG
#define ASSERT( expr )
#define VERIFY_E( retval , expr ) ( expr )
#define VERIFY_S( retval , expr ) ( expr )
#define HR_RET_IF_FAIL( q )  if(FAILED(q)) {return q;}
#endif

//mstsc.exe can take a maximum of 32 characters for the
//command line including the null terminating character.
#define CL_MAX_DESC_LENGTH              31

#define CL_MAX_DOMAIN_LENGTH            512
//
// For compatability reasons keep the old
// max domain length as the persistence format
// used a fixed size.
//
#define CL_OLD_DOMAIN_LENGTH            52

//
// User name
//
#define CL_MAX_USERNAME_LENGTH          512

//This is the max length of password in bytes.
#define CL_MAX_PASSWORD_LENGTH_BYTES    512
#define CL_OLD_PASSWORD_LENGTH          32
#define CL_SALT_LENGTH					20

//This is the maximum length of the password that
//the user can type in the edit box.
#define CL_MAX_PASSWORD_EDIT            256
#define CL_MAX_APP_LENGTH_16            128


#define CL_MAX_PGMAN_LENGTH             64

#include <adcgbase.h>

//
// Header files for control interfaces (generated from IDL files)
//
#include "mstsax.h"
#include "multihost.h"


#ifdef ECP_TIMEBOMB
//
// Timebomb expires on June 30, 2000
//
#define ECP_TIMEBOMB_YEAR  2000
#define ECP_TIMEBOMB_MONTH 6
#define ECP_TIMEBOMB_DAY   30

//
// Return's true if timebomb test passed otherwise puts up warning
// UI and return's FALSE
//
DCBOOL CheckTimeBomb();
#endif

#define BOOL_TO_VB(x)   (x ? VARIANT_TRUE : VARIANT_FALSE)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\tsmmc\snapin\resource.h ===
//tsmmc.rc: resouce includes for the Remote Desktops snapin
//copyright Microsoft 2000
//
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tsmmc.rc
//
#include "wuiids.h"

#define HIDC_DESCRIPTION                0x001
#define HIDC_SERVER                     0x002
#define HIDC_AUTO_LOGON                 0x003
#define HIDC_USERNAME                   0x004
#define HIDC_PASSWORD                   0x005
#define HIDC_DOMAIN                     0x006
#define HIDC_RESOL1                     0x007
#define HIDC_RESOL2                     0x007
#define HIDC_RESOL3                     0x007
#define HIDC_RESOL4                     0x007
#define HIDC_RESOL5                     0x007
#define HIDC_WINDOW                     0x008
#define HIDC_FULLSCREEN                 0x009
#define HIDC_COMPRESSION                0x00a
#define HIDC_DESKTOP                    0x00b
#define HIDC_SPECIFY_APP                0x00c
#define HIDC_APP                        0x00d
#define HIDC_WORKDIR                    0x00e
#define HIDC_CHANGEICON                 0x0010
#define HIDI_DEFAULT_ICON1              0x0010
#define HIDC_PGMAN                      0x0011
#define HIDC_BROWSE_SERVERS             0x012
#define HIDC_BITMAP_PERSISTENCE         0x013
#define IDS_PROJNAME                    100
#define IDS_CTXM_NAME                   101
#define IDM_CREATECON                   101
#define IDS_CTXM_NEW_CONNECTION         101
#define IDS_CTXM_STATUS                 102
#define IDS_CTXM_STATUS_NEW_CONNECTION  102
#define IDM_CONNECT                     102
#define IDS_CTXM_CONNECT                103
#define IDM_DISCONNECT                  103
#define IDS_CTXM_STATUS_CONNECT         104
#define IDM_PROPERTIES                  104
#define IDS_CTXM_DISCONNECT             105
#define IDS_CTXM_STATUS_DISCONNECT      106
#define IDS_CTXM_PROPERTIES             107
#define IDS_CTXM_STATUS_PROPERTIES      108
#define IDC_BITMAP_PERSISTENCE          109
#define IDS_MSG_WARNDELETE              110
#define IDD_DIALOGBROWSESERVERS         112
#define IDD_PROPPAGE1                   120
#define IDD_PROPPAGE2                   121
#define IDD_PROPPAGE3                   122
#define IDD_NEWCON                      123
#define IDR_TSMMCREG                    201
#define IDC_RADIO_CHOOSE_SIZE           203
#define IDI_ICON_MACHINE                204
#define IDC_RADIO_CUSTOM_SIZE           204
#define IDI_ICON_MACHINES               205
#define IDC_RADIO_SIZE_FILL_MMC         205
#define IDC_EDIT_WIDTH                  206
#define IDI_ICON_CONNECTED_MACHINE      207
#define IDC_EDIT_HEIGHT                 207
#define IDC_STATIC_WIDTH                208
#define IDC_STATIC_HEIGHT               209
#define IDC_COMBO_RESOLUTIONS           213
#define IDC_CHANGEPASSWORD              214
#define IDI_ICON_RD_SNAPIN              215

//
// 380 - 390 is reserved (see wuiids.h)
// for the browse for servers UI (it's in 
// a shared lib)
//
#define UI_IDB_SERVER                   393
#define UI_IDB_DOMAINEX                 394
#define UI_IDB_DOMAIN                   395

//
// 663 is reserved
//

#define IDC_PGMAN                       1001
#define IDC_DESCRIPTION                 1008
#define IDC_PIC                         1028
#define IDC_SERVER                      1031
#define IDC_USERNAME                    1036
#define IDC_PASSWORD                    1037
#define IDC_DOMAIN                      1038
#define IDC_RESOL1                      1042
#define IDC_RESOL2                      1043
#define IDC_RESOL3                      1044
#define IDC_RESOL4                      1045
#define IDC_RESOL5                      1046
#define IDC_FULLSCREEN                  1047
#define IDC_COMPRESSION                 1048
//
// 1055 reserved by wuiids.h for browse for servers UI
//
#define IDC_SPECIFY_APP                 1056
#define IDC_APP                         1057
#define IDC_WORKDIR                     1058
#define IDC_SPECIFY_APP_TEXT            1059
#define IDC_WINDOW                      1061

#define IDC_BROWSE_SERVERS              1071
#define IDC_USERNAME_STATIC             1072
#define IDC_PASSWORD_STATIC             1073
#define IDC_DOMAIN_STATIC               1074
#define IDC_WORKDIR_STATIC              1075
#define IDC_CONNECT_TO_CONSOLE          1076
#define IDC_REDIRECT_DRIVES             1077
#define IDC_SAVE_PASSWORD               1078

//MUI strings for start menu, do not change
//without updating tsoc.inx
#define IDS_STARTMENU_NAME_TSMMC        10000
#define IDS_STARTMENU_TIP_TSMMC         10001
#define IDS_SNAPIN_REG_TSMMC_NAME       10002

#define IDS_PROPERTIES                  40094
#define IDS_NETCON                      40095
#define IDS_CONNOPT                     40096
#define IDS_OTHERTAB                    40097

#define IDS_INVALID_USER_NAME           40098
#define IDS_INVALID_DOMAIN_NAME         40099
#define IDS_INVALID_PARAMS              40100
#define IDS_INVALID_SERVER_NAME         40101
#define IDS_TOO_LONG                    40102
#define IDS_DEL_CONFIRM                 40103
#define IDS_DEL_TITLE                   40104
#define IDS_FILEFILTER                  40105
#define IDS_FILEEXTENSION               40106
#define IDS_EXPORTTITLE                 40107
#define IDS_IMPORTTITLE                 40108
#define IDS_EXPORTPASSWORD              40109
#define IDS_EXPORTOVERWRITE             40110
#define IDS_IMPORTOVERWRITE             40111
#define IDS_EMPTY_USER_NAME             40112
#define IDS_EMPTY_DOMAIN                40113
#define IDS_ALL_SPACES                  40114
#define IDS_EXPORTALLPASSWORDS          40115
#define IDS_SKIPALLPASSWORDS            40116
#define IDS_OVERWRITEALL                40117
#define IDS_OVERWRITENONE               40118
#define IDS_NOSESSIONS                  40119
#define IDS_CANTOPENFILE                40120
#define IDS_PROGMAN_GROUP               40121
#define IDS_PATHTOOLONG                 40122
#define IDS_SPECIFY_PGMAN               40123
#define IDS_WELCOME_FONT                40124
#define IDS_WELCOME_FONT_SIZE           40125
#define IDS_TITLE_FONT                  40126
#define IDS_TITLE_FONT_SIZE             40127
#define IDS_RDPDR                       40128
#define IDS_RDPDR_ADDINS                40129
#define IDS_WIZARD_TITLE                40130
#define IDS_CONN_NOT_EXIST              40131
#define IDS_CMD_INVALID                 40132
#define IDS_PASSWORD_INVALID            40133
#define IDS_PASSWORD_CHANGED            40134
#define IDS_AUTOLOGON_DISABLED          40135
#define IDS_MAINWINDOWTITLE             40136
#define IDS_E_SPECIFY_SRV               40137
#define IDS_ROOTNODE_TEXT               40138
#define IDS_PROVIDER                    40139
#define IDS_DESCRIPTION                 40140
#define IDS_INVALID_WIDTH_HEIGHT        40142
#define IDS_WIDTH_NOT_VALID             40143
#define IDS_PROPERTIES_CAPTION          40144
#define IDS_TIMEBOMB_EXPIRED            40145
#define IDS_TSCMMCSNAPHELP              40146
#define IDS_TSCMMCHELPTOPIC             40147
#define IDS_STATUS_DISCONNECTED         40148
#define IDS_STATUS_CONNECTING           40149
#define IDS_TSCMMCHELP_PROPS            40150
#define IDS_NO_TERMINAL_SERVER          40151
#define IDS_STATUS_CONNECTED            40152
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\uilib\progband.cpp ===
//
// progband.cpp: Progress band code
//
// Copyright Microsoft Corportation 2001
// (nadima)
//

#include "stdafx.h"

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "progband.cpp"
#include <atrcapi.h>

#include "progband.h"

CProgressBand::CProgressBand(HWND hwndOwner,
                             HINSTANCE hInst,
                             INT nYindex,
                             INT nResID,
                             INT nResID8bpp,
                             HPALETTE hPal) :
                   _fInitialized(FALSE),
                   _hwndOwner(hwndOwner),
				   _hInstance(hInst),
                   _nYIndex(nYindex),
                   _nResID(nResID),
                   _nResID8bpp(nResID8bpp),
                   _hbmpProgBand(NULL),
                   _nTimerID(0),
                   _nBandOffset(0),
                   _hPal(hPal)
{
    DC_BEGIN_FN("CProgressBand");

    InitBitmaps();

    _fInitialized = (_hbmpProgBand != NULL);

    DC_END_FN();
}

CProgressBand::~CProgressBand()
{
    StopSpinning();

    if (_hbmpProgBand) {
        DeleteObject(_hbmpProgBand);
    }

    //
    // Don't delete the palette we don't own it
    //

}


BOOL CProgressBand::Initialize()
{
    //
    // All init done in ctor
    //
    return _fInitialized;
}

BOOL CProgressBand::StartSpinning()
{
    DC_BEGIN_FN("StartSpinning");

    //
    // Kick off the animation timer
    //
    _nTimerID = SetTimer(_hwndOwner,
                          TIMER_PROGRESSBAND_ANIM_ID,
                          ANIM_DELAY_MSECS, NULL );


    DC_END_FN();
    return (_nTimerID != 0);
}


BOOL CProgressBand::StopSpinning()
{
    DC_BEGIN_FN("StopSpinning");

    if (_nTimerID) {
        KillTimer(_hwndOwner, _nTimerID);
        _nTimerID = 0;
    }

    DC_END_FN();
    return TRUE;
}

//
// Events that must be called by parent
//
BOOL CProgressBand::OnEraseParentBackground(HDC hdc)
{
    BOOL fRet = TRUE;
    DC_BEGIN_FN("StopSpinning");

    if (_hbmpProgBand) {
        PaintBand(hdc);
    }

    DC_END_FN();
    return fRet;
}

BOOL CProgressBand::OnTimer(INT nTimerID)
{
    BOOL fRet = TRUE;
    DC_BEGIN_FN("StopSpinning");

    if (_nTimerID == nTimerID) {
        HDC hDC;
        if (_hbmpProgBand) {
            hDC = GetDC(_hwndOwner);
            if (hDC) {
                _nBandOffset = (_nBandOffset + PROGRESSBAND_ANIM_INCR) %
                                _rcBand.right - _rcBand.left;

                PaintBand(hDC);
                ReleaseDC(_hwndOwner, hDC);
            }
        }
    }

    DC_END_FN();
    return fRet;
}

BOOL CProgressBand::ReLoadBmps()
{
    DC_BEGIN_FN("ReLoadBmps");

    if (_hbmpProgBand) {
        DeleteObject(_hbmpProgBand);
    }
    memset(&_rcBand, 0, sizeof(_rcBand));

    return InitBitmaps();

    DC_END_FN();
}

BOOL CProgressBand::InitBitmaps()
{
    BOOL fUse8BitDepth = FALSE;
    BITMAP bitmap;
    HDC hdcScreen;

    DC_BEGIN_FN("InitBitmaps");

    //
    // Get color depth
    //
    hdcScreen = GetDC(NULL);
    if (hdcScreen) {
        fUse8BitDepth = (GetDeviceCaps(hdcScreen, BITSPIXEL) <= 8);
        ReleaseDC(NULL, hdcScreen);
        hdcScreen = NULL;
    }

    memset(&_rcBand, 0, sizeof(_rcBand));

    //
    // Load bitmaps
    //
    _hbmpProgBand = (HBITMAP)LoadImage(
                                _hInstance,
                                MAKEINTRESOURCE(fUse8BitDepth ?
                                    _nResID8bpp : _nResID),
                                IMAGE_BITMAP,
                                0,
                                0,
#ifndef OS_WINCE
                                LR_CREATEDIBSECTION);
#else
                                0);
#endif

    if ((_hbmpProgBand != NULL) &&
        (GetObject(_hbmpProgBand,
                   sizeof(bitmap), &bitmap) >= sizeof(bitmap))) {
        SetRect(&_rcBand, 0, 0, bitmap.bmWidth, bitmap.bmHeight);
    }

    DC_END_FN();
    return (_hbmpProgBand != NULL);
}

BOOL CProgressBand::PaintBand(HDC hDC)
{
    BOOL fRet= FALSE;

    DC_BEGIN_FN("PaintBand");

#ifndef OS_WINCE
    HBRUSH hBrushBlue;
#endif
    HDC hdcBitmap;
    HPALETTE oldPalette = NULL;
    HBITMAP oldBitmap;
    RECT rc = { 0 };
    INT cxRect, cxBand;

    hdcBitmap = CreateCompatibleDC(hDC);
    if (!hdcBitmap) {
        return FALSE;
    }
        

    GetClientRect(_hwndOwner, &rc);

    if (_hPal) {
        oldPalette = SelectPalette(hDC, _hPal, FALSE);
        RealizePalette(hDC);
    }

    //
    // paint the band at its animation point (bandOffset)
    //
    oldBitmap = (HBITMAP)SelectObject(hdcBitmap, _hbmpProgBand);

    cxRect = rc.right-rc.left;
    cxBand = min((_rcBand.right-_rcBand.left), cxRect);

    StretchBlt(hDC,
               _nBandOffset, _nYIndex,
               cxRect, (_rcBand.bottom - _rcBand.top),
               hdcBitmap,
               ((_rcBand.right-_rcBand.left)-cxBand)/2, 0,
               cxBand, (_rcBand.bottom - _rcBand.top),
               SRCCOPY);

    StretchBlt(hDC,
               (-cxRect)+_nBandOffset, _nYIndex,
               cxRect, (_rcBand.bottom - _rcBand.top),
               hdcBitmap,
               ((_rcBand.right-_rcBand.left)-cxBand)/2, 0,
               cxBand, (_rcBand.bottom - _rcBand.top),
               SRCCOPY);


    if ( oldBitmap ) {
        SelectObject(hdcBitmap, oldBitmap);
    }

    if ( oldPalette ) {
        SelectPalette(hDC, oldPalette, TRUE);
    }

    DeleteDC(hdcBitmap);

    DC_END_FN();
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\uilib\stdafx.cpp ===
// stdafx.cpp : precompiled sourcefile

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\util\adcg.h ===
/**INC+**********************************************************************/
/* Header:    adcg.h                                                        */
/*                                                                          */
/* Purpose:   Precompiled header                                            */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/** Changes:
 * $Log:   Y:/logs/client/adcg.h_v  $
 * 
 *    Rev 1.4   03 Jul 1997 11:58:58   AK
 * SFR0000: Initial development completed
 * 
**/
/**INC-**********************************************************************/
#include <adcgbase.h>
#include <strsafe.h>
#ifdef UNIWRAP
//Unicode wrap replace
#include "uwrap.h"
#endif //UNIWRAP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\uilib\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(_STDAFX_H_)
#define _STDAFX_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers


// Windows Header Files:
#include <windows.h>

// C RunTime Header Files
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>


#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#ifdef UNIWRAP
//Unicode wrap replace
#include "uwrap.h"
#endif //UNIWRAP


#define CHECK_RET_HR(f)	\
    hr = f; \
	TRC_ASSERT(SUCCEEDED(hr), (TB, "ts control method failed: " #f ));		\
	if(FAILED(hr)) return FALSE;


#include <adcgbase.h>


#endif // !defined(_STDAFX_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\uilib\uilib.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    core.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Madan Appiah - Sep. 5th 1997

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

C_DEFINES = \
    $(C_DEFINES) \
    $(CLIENT_EXE_CDEFS) \

#
# List of sources
#

SOURCES_PLATFORM =

CLIENT_SOURCES_RC = \

SOURCES = \
    ..\browsesrv.cpp \
    ..\progband.cpp

#
# Precompiled specs
#

PRECOMPILED_INCLUDE = ..\stdafx.h
PRECOMPILED_SOURCEFILE = ..\stdafx.cpp
PRECOMPILED_CXX=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\util\reglic.cpp ===
/**MOD+**********************************************************************/
/* Module:    reglic.cpp                                                    */
/*                                                                          */
/* Purpose:   Creates and sets appropriate ACLs on MSLicensing registry key */
/*            This is done during DllRegisterServer which should be called  */
/*            by an Admin so the user should have rights to complete this   */
/*            We do this during control registration as it is the only valid*/
/*            place to do it during the control setup...e.g web CAB setup   */
/*            and Iexpress setups can't handle this by themselves           */
/*                                                                          */
/*            This code was shamelessly stolen from the client ACME setup   */
/* Copyright(C) Microsoft Corporation 1998-2000                             */
/*                                                                          */
/****************************************************************************/

#ifndef OS_WINCE

#include <adcg.h>
#include <cryptkey.h>

#include "reglic.h"

#define MSLICENSING_STORE_KEY             _T("SOFTWARE\\Microsoft\\MSLicensing\\Store")

typedef DWORD (*PSETENTRIESINACL)(
  ULONG cCountOfExplicitEntries,           // number of entries
  PEXPLICIT_ACCESS pListOfExplicitEntries, // buffer
  PACL OldAcl,                             // original ACL
  PACL *NewAcl                             // new ACL
);

//Note, only a user with sufficient privileges will
//be able to complete this operation (same as the DllRegisterServer)
//We don't do anything on failure
BOOL SetupMSLicensingKey()
{
    OSVERSIONINFOA OsVer;
    memset(&OsVer, 0x0, sizeof(OSVERSIONINFOA));
    OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
    GetVersionExA(&OsVer);

    if (VER_PLATFORM_WIN32_NT == OsVer.dwPlatformId)  //It should be Windows NT
    {
        if(CreateRegAddAcl())
        {
            // generate and write the HWID
            if (CreateAndWriteHWID())
            {
                return TRUE;
            }
            else
            {
                OutputDebugString(_T("FAILED to add Terminal Services MSLicensing HWID"));
            }
        }
        else
        {
            OutputDebugString(_T("FAILED to add Terminal Services MSLicensing key"));
        }
    }
    return FALSE;
}


BOOL
AddACLToObjectSecurityDescriptor(
                                HANDLE hObject,
                                SE_OBJECT_TYPE ObjectType                                
                                 )
{
    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    CreatorAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    PSID pAdminSid = NULL;
    PSID pSystemSid = NULL;
    PSID pPowerUsersSid = NULL;
    PSID pCreatorSid = NULL;
    PSID pUsersSid = NULL;
    PACL pNewDACL = NULL;

    DWORD                       dwError;
    BOOL                        bSuccess = TRUE;

    DWORD                       i;

    PALLOCATEANDINITIALIZESID_FN pAllocateAndInitializeSid = NULL;
    PSETENTRIESINACL            pSetEntriesInAcl = NULL;
    HMODULE                     pAdvApi32 = NULL;
    PFREESID_FN                 pFreeSid = NULL;

    PSETSECURITYINFO_FN pSetSecurityInfo;

    pAdvApi32 = LoadLibrary(ADVAPI_32_DLL);
    if (!pAdvApi32) {
        return(FALSE);
    }

    pAllocateAndInitializeSid = (PALLOCATEANDINITIALIZESID_FN)
                                   GetProcAddress(pAdvApi32,
                                                  ALLOCATE_AND_INITITIALIZE_SID);
    if (pAllocateAndInitializeSid == NULL)
    {
        goto ErrorCleanup;
    }

#ifdef UNICODE
    pSetEntriesInAcl = reinterpret_cast<PSETENTRIESINACL>(GetProcAddress( pAdvApi32, "SetEntriesInAclW" ));
#else
    pSetEntriesInAcl = reinterpret_cast<PSETENTRIESINACL>(GetProcAddress( pAdvApi32, "SetEntriesInAclA" ));
#endif

    if (!pSetEntriesInAcl) {
        FreeLibrary( pAdvApi32 );
        return(FALSE);
    }

    EXPLICIT_ACCESS             ExplicitAccess[5];
    //
    // Create SIDs - Admins and System
    //

    bSuccess = pAllocateAndInitializeSid( &NtAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_ADMINS,
                                                     0, 0, 0, 0, 0, 0,
                                                     &pAdminSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid( &NtAuthority,
                                                     1,
                                                     SECURITY_LOCAL_SYSTEM_RID,
                                                     0, 0, 0, 0, 0, 0, 0,
                                                     &pSystemSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid( &NtAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_POWER_USERS,
                                                     0, 0, 0, 0, 0, 0,
                                                     &pPowerUsersSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid( &CreatorAuthority,
                                                     1,
                                                     SECURITY_CREATOR_OWNER_RID,
                                                     0, 0, 0, 0, 0, 0, 0,
                                                     &pCreatorSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid(&NtAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_USERS,
                                                     0, 0, 0, 0, 0, 0,
                                                     &pUsersSid);

    if (bSuccess) {

        //
        // Initialize Access structures describing the ACEs we want:
        //  System Full Control
        //  Admins Full Control
        //
        // We'll take advantage of the fact that the unlocked private keys is
        // the same as the device parameters key and they are a superset of the
        // locked private keys.
        //
        // When we create the DACL for the private key we'll specify a subset of
        // the ExplicitAccess array.
        //
        for (i = 0; i < 5; i++) {
            ExplicitAccess[i].grfAccessMode = SET_ACCESS;
            ExplicitAccess[i].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;            
            ExplicitAccess[i].Trustee.pMultipleTrustee = NULL;
            ExplicitAccess[i].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
            ExplicitAccess[i].Trustee.TrusteeForm = TRUSTEE_IS_SID;
            ExplicitAccess[i].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
        }
        ExplicitAccess[0].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[0].Trustee.ptstrName = (LPTSTR)pAdminSid;

        ExplicitAccess[1].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[1].Trustee.ptstrName = (LPTSTR)pSystemSid;

        ExplicitAccess[2].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[2].Trustee.ptstrName = (LPTSTR)pCreatorSid;

        ExplicitAccess[3].grfAccessPermissions = GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | DELETE;
        ExplicitAccess[3].Trustee.ptstrName = (LPTSTR)pPowerUsersSid;

        ExplicitAccess[4].grfAccessPermissions = GENERIC_READ;
        ExplicitAccess[4].Trustee.ptstrName = (LPTSTR)pUsersSid;

        dwError = (DWORD)pSetEntriesInAcl( 5,
                                           ExplicitAccess,
                                           NULL,
                                           &pNewDACL );        
        
        pSetSecurityInfo = (PSETSECURITYINFO_FN)GetProcAddress(pAdvApi32,SET_SECURITY_INFO);
        
        if (pSetSecurityInfo == NULL)
        {
            OutputDebugString(_T("AddSidToObjectsSecurityDescriptor: Can't get proc SetSecurityInfo"));
            goto ErrorCleanup;
        }

        dwError = pSetSecurityInfo(
                    hObject,
                    ObjectType,
                    DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION,
                    NULL,
                    NULL,
                    pNewDACL,
                    NULL
                    );
        
    }
ErrorCleanup:

    pFreeSid = (PFREESID_FN)
            GetProcAddress(pAdvApi32,
                           FREE_SID);

    if(pFreeSid)
    {
        if(pAdminSid)
            pFreeSid(pAdminSid);
        if(pSystemSid)
            pFreeSid(pSystemSid);
        if(pPowerUsersSid)
            pFreeSid(pPowerUsersSid);
        if(pCreatorSid)
            pFreeSid(pCreatorSid);
        if(pUsersSid)
            pFreeSid(pUsersSid);
    }
    if(pNewDACL)
        LocalFree(pNewDACL);


    if(pAdvApi32)
        FreeLibrary( pAdvApi32 );

    return bSuccess;
}


BOOL
AddACLToStoreObjectSecurityDescriptor(
                                HANDLE hObject,
                                SE_OBJECT_TYPE ObjectType
                                 )
{
    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    CreatorAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    PSID pAdminSid = NULL;
    PSID pSystemSid = NULL;
    PSID pPowerUsersSid = NULL;
    PSID pCreatorSid = NULL;
    PSID pUsersSid = NULL;
    PACL pNewDACL = NULL;

    DWORD                       dwError;
    BOOL                        bSuccess = TRUE;

    DWORD                       i;

    PALLOCATEANDINITIALIZESID_FN pAllocateAndInitializeSid = NULL;
    PSETENTRIESINACL            pSetEntriesInAcl = NULL;    
    HMODULE                     pAdvApi32 = NULL;
    PFREESID_FN                 pFreeSid = NULL;
    PSETSECURITYINFO_FN pSetSecurityInfo;
    EXPLICIT_ACCESS             ExplicitAccess[6];

    pAdvApi32 = LoadLibrary(ADVAPI_32_DLL);
    if (!pAdvApi32) {
        return(FALSE);
    }

    pAllocateAndInitializeSid = (PALLOCATEANDINITIALIZESID_FN)
                                   GetProcAddress(pAdvApi32,
                                                  ALLOCATE_AND_INITITIALIZE_SID);
    if (pAllocateAndInitializeSid == NULL)
    {
        goto ErrorCleanup;
    }

#ifdef UNICODE
    pSetEntriesInAcl = reinterpret_cast<PSETENTRIESINACL>(GetProcAddress( pAdvApi32, "SetEntriesInAclW" ));
#else
    pSetEntriesInAcl = reinterpret_cast<PSETENTRIESINACL>(GetProcAddress( pAdvApi32, "SetEntriesInAclA" ));
#endif

    if (!pSetEntriesInAcl) {
        FreeLibrary( pAdvApi32 );
        return(FALSE);
    }
    
    //
    // Create SIDs - Admins and System
    //

    bSuccess = pAllocateAndInitializeSid( &NtAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_ADMINS,
                                                     0, 0, 0, 0, 0, 0,
                                                     &pAdminSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid( &NtAuthority,
                                                     1,
                                                     SECURITY_LOCAL_SYSTEM_RID,
                                                     0, 0, 0, 0, 0, 0, 0,
                                                     &pSystemSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid( &NtAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_POWER_USERS,
                                                     0, 0, 0, 0, 0, 0,
                                                     &pPowerUsersSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid( &CreatorAuthority,
                                                     1,
                                                     SECURITY_CREATOR_OWNER_RID,
                                                     0, 0, 0, 0, 0, 0, 0,
                                                     &pCreatorSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid(&NtAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_USERS,
                                                     0, 0, 0, 0, 0, 0,
                                                     &pUsersSid);

    if (bSuccess) {

        //
        // Initialize Access structures describing the ACEs we want:
        //  System Full Control
        //  Admins Full Control
        //
        // We'll take advantage of the fact that the unlocked private keys is
        // the same as the device parameters key and they are a superset of the
        // locked private keys.
        //
        // When we create the DACL for the private key we'll specify a subset of
        // the ExplicitAccess array.
        //
        for (i = 0; i < 6; i++) {
            ExplicitAccess[i].grfAccessMode = SET_ACCESS;              
            ExplicitAccess[i].Trustee.pMultipleTrustee = NULL;
            ExplicitAccess[i].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
            ExplicitAccess[i].Trustee.TrusteeForm = TRUSTEE_IS_SID;
            ExplicitAccess[i].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
        }
        ExplicitAccess[0].grfAccessPermissions = KEY_ALL_ACCESS; 
        ExplicitAccess[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ExplicitAccess[0].Trustee.ptstrName = (LPTSTR)pAdminSid;

        ExplicitAccess[1].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[1].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ExplicitAccess[1].Trustee.ptstrName = (LPTSTR)pSystemSid;

        ExplicitAccess[2].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[2].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ExplicitAccess[2].Trustee.ptstrName = (LPTSTR)pCreatorSid;

        ExplicitAccess[3].grfAccessPermissions = GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | DELETE;
        ExplicitAccess[3].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ExplicitAccess[3].Trustee.ptstrName = (LPTSTR)pPowerUsersSid;

        ExplicitAccess[4].grfAccessPermissions = GENERIC_READ | GENERIC_WRITE| KEY_CREATE_SUB_KEY |KEY_SET_VALUE;
        ExplicitAccess[4].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ExplicitAccess[4].Trustee.ptstrName = (LPTSTR)pUsersSid;

        ExplicitAccess[5].grfAccessPermissions = DELETE;
        ExplicitAccess[5].grfInheritance = INHERIT_ONLY_ACE | SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ExplicitAccess[5].Trustee.ptstrName = (LPTSTR)pUsersSid;

        dwError = (DWORD)pSetEntriesInAcl( 6,
                                           ExplicitAccess,
                                           NULL,
                                           &pNewDACL );
        
        pSetSecurityInfo = (PSETSECURITYINFO_FN)GetProcAddress(pAdvApi32,SET_SECURITY_INFO);
        
        if (pSetSecurityInfo == NULL)
        {
            OutputDebugString(_T("AddSidToObjectsSecurityDescriptor: Can't get proc SetSecurityInfo"));
            goto ErrorCleanup;
        }

        dwError = pSetSecurityInfo(
                    hObject,
                    ObjectType,
                    DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION,
                    NULL,
                    NULL,
                    pNewDACL,
                    NULL
                    );
        
    }
ErrorCleanup:

    pFreeSid = (PFREESID_FN)
            GetProcAddress(pAdvApi32,
                           FREE_SID);

    if(pFreeSid)
    {
        if(pAdminSid)
            pFreeSid(pAdminSid);
        if(pSystemSid)
            pFreeSid(pSystemSid);
        if(pPowerUsersSid)
            pFreeSid(pPowerUsersSid);
        if(pCreatorSid)
            pFreeSid(pCreatorSid);
        if(pUsersSid)
            pFreeSid(pUsersSid);
    }
    if(pNewDACL)
        LocalFree(pNewDACL);


    if(pAdvApi32)
        FreeLibrary( pAdvApi32 );

    return bSuccess;
}


BOOL
RestoreACLOnKey(
                                HANDLE hObject,
                                SE_OBJECT_TYPE ObjectType                                
                                 )
{
    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    CreatorAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    PSID pAdminSid = NULL;
    PSID pSystemSid = NULL;
    PSID pPowerUsersSid = NULL;
    PSID pCreatorSid = NULL;
    PSID pUsersSid = NULL;
    PACL pNewDACL = NULL;

    DWORD                       dwError;
    BOOL                        bSuccess = TRUE;

    DWORD                       i;

    PALLOCATEANDINITIALIZESID_FN pAllocateAndInitializeSid = NULL;
    PSETENTRIESINACL            pSetEntriesInAcl = NULL;
    HMODULE                     pAdvApi32 = NULL;
    PFREESID_FN                 pFreeSid = NULL;

    PSETSECURITYINFO_FN pSetSecurityInfo;

    pAdvApi32 = LoadLibrary(ADVAPI_32_DLL);
    if (!pAdvApi32) {
        return(FALSE);
    }

    pAllocateAndInitializeSid = (PALLOCATEANDINITIALIZESID_FN)
                                   GetProcAddress(pAdvApi32,
                                                  ALLOCATE_AND_INITITIALIZE_SID);
    if (pAllocateAndInitializeSid == NULL)
    {
        goto ErrorCleanup;
    }

#ifdef UNICODE
    pSetEntriesInAcl = reinterpret_cast<PSETENTRIESINACL>(GetProcAddress( pAdvApi32, "SetEntriesInAclW" ));
#else
    pSetEntriesInAcl = reinterpret_cast<PSETENTRIESINACL>(GetProcAddress( pAdvApi32, "SetEntriesInAclA" ));
#endif

    if (!pSetEntriesInAcl) {
        FreeLibrary( pAdvApi32 );
        return(FALSE);
    }

    EXPLICIT_ACCESS             ExplicitAccess[5];
    //
    // Create SIDs - Admins and System
    //

    bSuccess = pAllocateAndInitializeSid( &NtAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_ADMINS,
                                                     0, 0, 0, 0, 0, 0,
                                                     &pAdminSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid( &NtAuthority,
                                                     1,
                                                     SECURITY_LOCAL_SYSTEM_RID,
                                                     0, 0, 0, 0, 0, 0, 0,
                                                     &pSystemSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid( &NtAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_POWER_USERS,
                                                     0, 0, 0, 0, 0, 0,
                                                     &pPowerUsersSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid( &CreatorAuthority,
                                                     1,
                                                     SECURITY_CREATOR_OWNER_RID,
                                                     0, 0, 0, 0, 0, 0, 0,
                                                     &pCreatorSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid(&NtAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_USERS,
                                                     0, 0, 0, 0, 0, 0,
                                                     &pUsersSid);

    if (bSuccess) {

        //
        // Initialize Access structures describing the ACEs we want:
        //  System Full Control
        //  Admins Full Control
        //
        // We'll take advantage of the fact that the unlocked private keys is
        // the same as the device parameters key and they are a superset of the
        // locked private keys.
        //
        // When we create the DACL for the private key we'll specify a subset of
        // the ExplicitAccess array.
        //
        for (i = 0; i < 5; i++) {
            ExplicitAccess[i].grfAccessMode = SET_ACCESS;
            ExplicitAccess[i].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;            
            ExplicitAccess[i].Trustee.pMultipleTrustee = NULL;
            ExplicitAccess[i].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
            ExplicitAccess[i].Trustee.TrusteeForm = TRUSTEE_IS_SID;
            ExplicitAccess[i].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
        }
        ExplicitAccess[0].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[0].Trustee.ptstrName = (LPTSTR)pAdminSid;

        ExplicitAccess[1].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[1].Trustee.ptstrName = (LPTSTR)pSystemSid;

        ExplicitAccess[2].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[2].Trustee.ptstrName = (LPTSTR)pCreatorSid;

        ExplicitAccess[3].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[3].Trustee.ptstrName = (LPTSTR)pPowerUsersSid;

        ExplicitAccess[4].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[4].Trustee.ptstrName = (LPTSTR)pUsersSid;

        dwError = (DWORD)pSetEntriesInAcl( 5,
                                           ExplicitAccess,
                                           NULL,
                                           &pNewDACL );        
        
        pSetSecurityInfo = (PSETSECURITYINFO_FN)GetProcAddress(pAdvApi32,SET_SECURITY_INFO);
        
        if (pSetSecurityInfo == NULL)
        {
            OutputDebugString(_T("AddSidToObjectsSecurityDescriptor: Can't get proc SetSecurityInfo"));
            goto ErrorCleanup;
        }

        dwError = pSetSecurityInfo(
                    hObject,
                    ObjectType,
                    DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION,
                    NULL,
                    NULL,
                    pNewDACL,
                    NULL
                    );
        
    }
ErrorCleanup:

    pFreeSid = (PFREESID_FN)
            GetProcAddress(pAdvApi32,
                           FREE_SID);

    if(pFreeSid)
    {
        if(pAdminSid)
            pFreeSid(pAdminSid);
        if(pSystemSid)
            pFreeSid(pSystemSid);
        if(pPowerUsersSid)
            pFreeSid(pPowerUsersSid);
        if(pCreatorSid)
            pFreeSid(pCreatorSid);
        if(pUsersSid)
            pFreeSid(pUsersSid);
    }
    if(pNewDACL)
        LocalFree(pNewDACL);


    if(pAdvApi32)
        FreeLibrary( pAdvApi32 );

    return bSuccess;
}

//
// Create and ACL HKLM\Software\Microsoft\MSLicensing\Store
//
// 1) Set the ACL on MSLicensing, so that Users can only read (inherited).
// 2) Create the Store subkey, and set an ACL so that Users can
// read (inherited), write (inherited), create subkeys, enumerate subkeys,
// and delete subkeys, but not do anything else.
//

BOOL CreateRegAddAcl(VOID)
{
    BOOL fRet = FALSE;
    DWORD dwDisposition, dwError = NO_ERROR;
    HKEY hKey = NULL, hKeyStore = NULL;

    dwError = RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,
                    MSLICENSING_REG_KEY,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hKey,
                    &dwDisposition
                    );

    if (dwError != ERROR_SUCCESS) {
        return FALSE;
    }

    fRet = AddACLToObjectSecurityDescriptor(
                hKey,
                SE_REGISTRY_KEY
                );

    if (!fRet) {
        goto cleanup;
    }

    dwError = RegCreateKeyEx(
                    hKey,
                    MSLICENSING_STORE_SUBKEY,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hKeyStore,
                    &dwDisposition
                    );

    if (dwError != ERROR_SUCCESS) {
        fRet = FALSE;
        goto cleanup;
    }

    fRet = AddACLToStoreObjectSecurityDescriptor(
                hKeyStore,
                SE_REGISTRY_KEY
                );

cleanup:
    if (NULL != hKey)
    {
        RegCloseKey( hKey );
    }

    if (NULL != hKeyStore)
    {
        RegCloseKey( hKeyStore );
    }

    return fRet;
}


//
// Restore ACL on HKLM\Software\Microsoft\MSLicensing, HardwareID and Store 
// and subkeys if they exist on uninstall.
// Grant Users Full control. This is to make it operational with downlevel clients.
//

void RestoreRegAcl(VOID)
{
    DWORD dwDisposition, dwError = NO_ERROR;
    HKEY hKey = NULL;

    dwError = RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,
                    MSLICENSING_REG_KEY,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hKey,
                    &dwDisposition
                    );

    if (dwError == ERROR_SUCCESS) 
    {    
        RestoreACLOnKey(
                    hKey,
                    SE_REGISTRY_KEY
                    );

        if (NULL != hKey)
        {
            RegCloseKey( hKey );
            hKey = NULL;
        }
    }

    // Write HWID to registry

    dwError = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                MSLICENSING_HWID_KEY,
                0,
                KEY_ALL_ACCESS,
                &hKey
                );    

    if (dwError == ERROR_SUCCESS) 
    {    
        RestoreACLOnKey(
                    hKey,
                    SE_REGISTRY_KEY
                    );

        if (NULL != hKey)
        {
            RegCloseKey( hKey );
            hKey = NULL;
        }
    }

    dwError = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                MSLICENSING_STORE_KEY,
                0,
                KEY_ALL_ACCESS,
                &hKey
                );      

    if (dwError == ERROR_SUCCESS) 
    {
        RestoreACLOnKey(
                hKey,
                SE_REGISTRY_KEY
                );

        if (NULL != hKey)
        {
            RegCloseKey( hKey );
            hKey = NULL;
        }
    }

    return;
}



//
// Note: this uses low-level ACL APIs because the higher level APIs
// don't exist or have bugs on NT4
//

BOOL
AddSidToObjectsSecurityDescriptor(
    HANDLE hObject,
    SE_OBJECT_TYPE ObjectType,
    PSID pSid,
    DWORD dwNewAccess,
    ACCESS_MODE AccessMode,
    DWORD dwInheritance,
    BOOL fKeepExistingAcl
    )
{
    BOOL fReturn = FALSE;
    DWORD dwRet;
    PACL pOldDacl = NULL, pNewDacl = NULL;
    PSECURITY_DESCRIPTOR pSecDesc = NULL;
    HMODULE hModAdvapiDll = NULL;
    PGETSECURITYINFO_FN pGetSecurityInfo;
    PSETSECURITYINFO_FN pSetSecurityInfo;
    PADDACE_FN pAddAce;
    PGETLENGTHSID_FN pGetLengthSid;
    PCOPYSID_FN pCopySid;
    WORD cbAcl;
    PACCESS_ALLOWED_ACE pAceAllow = NULL;
    PACCESS_DENIED_ACE pAceDeny = NULL;
    PISVALIDSID_FN pIsValidSid;
    WORD cbAce;
    DWORD cbSid;
    PSID pSidLocation;

    //
    //  pSid cannot be NULL.
    //

    if (pSid == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        OutputDebugString(_T("AddSidToObjectsSecurityDescriptor: NULL pSid"));
        return(FALSE);
    }

    if ((AccessMode != GRANT_ACCESS) && (AccessMode != DENY_ACCESS)){
        SetLastError(ERROR_INVALID_PARAMETER);
        OutputDebugString(_T("AddSidToObjectsSecurityDescriptor: only Grant Aces and Deny Access supported"));
        return(FALSE);
    }

    if (!fKeepExistingAcl)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        OutputDebugString(_T("AddSidToObjectsSecurityDescriptor: only fKeepExistingAcl supported"));
        return(FALSE);
    }

    hModAdvapiDll = LoadLibrary(ADVAPI_32_DLL);

    if (hModAdvapiDll == NULL) {
        OutputDebugString(_T("AddSidToObjectsSecurityDescriptor: can't load Advapi32.dll"));
        return(FALSE);
    }

    pIsValidSid = (PISVALIDSID_FN)GetProcAddress(hModAdvapiDll, IS_VALID_SID);
    if (pIsValidSid == NULL)
    {
        OutputDebugString(_T("AddSidToObjectsSecurityDescriptor: Can't get proc IsValidSid"));
        goto ErrorCleanup;
    }

    if (!pIsValidSid(pSid)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        OutputDebugString(_T("AddSidToObjectsSecurityDescriptor: bad pSid"));
        goto ErrorCleanup;
    }


    if (fKeepExistingAcl) {
        //
        //  Get the objects security descriptor and current DACL.
        //

        pGetSecurityInfo = (PGETSECURITYINFO_FN)GetProcAddress(hModAdvapiDll, GET_SECURITY_INFO);
        if (pGetSecurityInfo == NULL)
        {
            OutputDebugString(_T("AddSidToObjectsSecurityDescriptor: Can't get proc GetSecurityInfo"));
            goto ErrorCleanup;
        }

        dwRet = pGetSecurityInfo(
                    hObject,
                    ObjectType,
                    DACL_SECURITY_INFORMATION,
                    NULL,
                    NULL,
                    &pOldDacl,
                    NULL,
                    &pSecDesc
                    );

        if (dwRet != ERROR_SUCCESS) {
            OutputDebugString(_T("AddSidToObjectsSecurityDescriptor: GetSecurityInfo failed"));
            goto ErrorCleanup;
        }
    }

    //
    //  Merge the new ACE into the existing DACL.
    //

    //
    // Calculate size of new ACL, and create it
    //

    pGetLengthSid = (PGETLENGTHSID_FN)GetProcAddress(hModAdvapiDll,GET_LENGTH_SID);
    if (pGetLengthSid == NULL)
    {
        OutputDebugString(_T("AddSidToObjectsSecurityDescriptor: Can't get proc GetLengthSid"));
        goto ErrorCleanup;
    }

    cbSid = pGetLengthSid(pSid);

    cbAcl = (WORD) (pOldDacl->AclSize + cbSid - sizeof(DWORD));

    if (AccessMode == GRANT_ACCESS)
    {
        cbAcl += (WORD) sizeof(ACCESS_ALLOWED_ACE);
    }
    else
    {
        cbAcl += (WORD) sizeof(ACCESS_DENIED_ACE);
    }

    pNewDacl = (PACL) LocalAlloc(LPTR, cbAcl);

    if (NULL == pNewDacl)
    {
        OutputDebugString(_T("AddSidToObjectsSecurityDescriptor: Can't allocate ACL"));
        goto ErrorCleanup;
    }

    CopyMemory(pNewDacl,pOldDacl,pOldDacl->AclSize);

    pNewDacl->AclSize = cbAcl;

    //
    // Create New Ace to be added
    //

    if (AccessMode == GRANT_ACCESS)
    {
        cbAce = (WORD) (sizeof(ACCESS_ALLOWED_ACE) + cbSid - sizeof(DWORD));

        pAceAllow = (PACCESS_ALLOWED_ACE) LocalAlloc(LPTR,cbAce);

        if (NULL == pAceAllow)
        {
            OutputDebugString(_T("AddSidToObjectsSecurityDescriptor: Can't allocate Ace"));
            goto ErrorCleanup;
        }

        pAceAllow->Header.AceFlags = (BYTE) dwInheritance;
        pAceAllow->Header.AceSize = cbAce;
        pAceAllow->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
        pAceAllow->Mask = dwNewAccess;

        pSidLocation = (PSID)(&pAceAllow->SidStart);
    }
    else
    {
        cbAce = (WORD) (sizeof(ACCESS_DENIED_ACE) + cbSid - sizeof(DWORD));

        pAceDeny = (PACCESS_DENIED_ACE) LocalAlloc(LPTR,cbAce);

        if (NULL == pAceDeny)
        {
            OutputDebugString(_T("AddSidToObjectsSecurityDescriptor: Can't allocate Ace"));
            goto ErrorCleanup;
        }

        pAceDeny->Header.AceFlags = (BYTE) dwInheritance;
        pAceDeny->Header.AceSize = cbAce;
        pAceDeny->Header.AceType = ACCESS_DENIED_ACE_TYPE;
        pAceDeny->Mask = dwNewAccess;

        pSidLocation = (PSID)(&pAceDeny->SidStart);
    }

    pCopySid = (PCOPYSID_FN)GetProcAddress(hModAdvapiDll,COPY_SID);
    if (pCopySid == NULL)
    {
        OutputDebugString(_T("AddSidToObjectsSecurityDescriptor: Can't get proc CopySid"));
        goto ErrorCleanup;
    }

    if (!pCopySid(cbSid, pSidLocation, pSid))
    {
        OutputDebugString(_T("AddSidToObjectsSecurityDescriptor: CopySid failed"));
        goto ErrorCleanup;
    }

    pAddAce = (PADDACE_FN)GetProcAddress(hModAdvapiDll,ADD_ACE);
    if (pAddAce == NULL)
    {
        OutputDebugString(_T("AddSidToObjectsSecurityDescriptor: Can't get proc AddAce"));
        goto ErrorCleanup;
    }

    if (!pAddAce(pNewDacl,
                 ACL_REVISION,
                 (AccessMode == GRANT_ACCESS) ? MAXDWORD : 0,
                 ((AccessMode == GRANT_ACCESS) ? (PVOID)pAceAllow : (PVOID)pAceDeny),
                 cbAce))
    {
        OutputDebugString(_T("AddSidToObjectsSecurityDescriptor: AddAce failed"));
        goto ErrorCleanup;
    }

    //
    //  Set the new security for the object.
    //

    pSetSecurityInfo = (PSETSECURITYINFO_FN)GetProcAddress(hModAdvapiDll,SET_SECURITY_INFO);
    if (pSetSecurityInfo == NULL)
    {
        OutputDebugString(_T("AddSidToObjectsSecurityDescriptor: Can't get proc SetSecurityInfo"));
        goto ErrorCleanup;
    }

    dwRet = pSetSecurityInfo(
                hObject,
                ObjectType,
                DACL_SECURITY_INFORMATION,
                NULL,
                NULL,
                pNewDacl,
                NULL
                );

    if (dwRet != ERROR_SUCCESS) {
        OutputDebugString(_T("AddSidToObjectsSecurityDescriptor: SetSecurityInfo failed"));
        goto ErrorCleanup;
    }

    fReturn = TRUE;

ErrorCleanup:
    if (hModAdvapiDll != NULL) {
        FreeLibrary(hModAdvapiDll);
    }

    if (pNewDacl != NULL) {
        LocalFree(pNewDacl);
    }

    if (pSecDesc != NULL) {
        LocalFree(pSecDesc);
    }

    if (pAceAllow != NULL) {
        LocalFree(pAceAllow);
    }

    if (pAceDeny != NULL) {
        LocalFree(pAceDeny);
    }

    return(fReturn);
}

BOOL
DeleteAceFromObjectsSecurityDescriptor(
    HANDLE hObject,
    SE_OBJECT_TYPE ObjectType,
    PSID pSid,
    DWORD dwAccess,
    ACCESS_MODE AccessMode,
    DWORD dwInheritance
    )
{
    BOOL fReturn = FALSE;
    DWORD dwRet;
    PACL pDacl = NULL;
    PSECURITY_DESCRIPTOR pSecDesc = NULL;
    HMODULE hModAdvapiDll = NULL;
    PGETSECURITYINFO_FN pGetSecurityInfo;
    PSETSECURITYINFO_FN pSetSecurityInfo;
    PGETACLINFORMATION_FN pGetAclInformation;
    PDELETEACE_FN pDeleteAce;
    PGETACE_FN pGetAce;
    PACCESS_ALLOWED_ACE pAce = NULL;
    PISVALIDSID_FN pIsValidSid;
    PEQUALSID_FN pEqualSid;
    DWORD cAce;
    ACL_SIZE_INFORMATION aclSizeInfo;
    PACE_HEADER          aceHeader;
    PACCESS_ALLOWED_ACE  aceAllowed;

    //
    //  pSid cannot be NULL.
    //

    if (pSid == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        OutputDebugString(_T("DeleteAceFromObjectsSecurityDescriptor: NULL pSid"));
        return(FALSE);
    }

    //
    // We only support GRANT_ACCESS Aces

    if (AccessMode != GRANT_ACCESS) {
        SetLastError(ERROR_INVALID_PARAMETER);
        OutputDebugString(_T("DeleteAceFromObjectsSecurityDescriptor: only Grant Aces allowed"));
        return(FALSE);
    }

    //
    // Load all the functions we'll need
    //

    hModAdvapiDll = LoadLibrary(ADVAPI_32_DLL);

    if (hModAdvapiDll == NULL) {
        OutputDebugString(_T("DeleteAceFromObjectsSecurityDescriptor: can't load Advapi32.dll"));
        return(FALSE);
    }

    pIsValidSid = (PISVALIDSID_FN)GetProcAddress(hModAdvapiDll, IS_VALID_SID);
    if (pIsValidSid == NULL)
    {
        OutputDebugString(_T("DeleteAceFromObjectsSecurityDescriptor: Can't get proc IsValidSid"));
        goto ErrorCleanup;
    }

    pEqualSid = (PEQUALSID_FN)GetProcAddress(hModAdvapiDll, EQUAL_SID);
    if (pEqualSid == NULL)
    {
        OutputDebugString(_T("DeleteAceFromObjectsSecurityDescriptor: Can't get proc EqualSid"));
        goto ErrorCleanup;
    }

    pDeleteAce = (PDELETEACE_FN)GetProcAddress(hModAdvapiDll,DELETE_ACE);
    if (pDeleteAce == NULL)
    {
        OutputDebugString(_T("DeleteSidToObjectsSecurityDescriptor: Can't get proc DeleteAce"));
        goto ErrorCleanup;
    }

    pGetAce = (PGETACE_FN)GetProcAddress(hModAdvapiDll,GET_ACE);
    if (pGetAce == NULL)
    {
        OutputDebugString(_T("DeleteSidToObjectsSecurityDescriptor: Can't get proc GetAce"));
        goto ErrorCleanup;
    }

    pGetSecurityInfo = (PGETSECURITYINFO_FN)GetProcAddress(hModAdvapiDll, GET_SECURITY_INFO);
    if (pGetSecurityInfo == NULL)
    {
        OutputDebugString(_T("DeleteAceFromObjectsSecurityDescriptor: Can't get proc GetSecurityInfo"));
        goto ErrorCleanup;
    }

    pGetAclInformation = (PGETACLINFORMATION_FN)GetProcAddress(hModAdvapiDll, GET_ACL_INFORMATION);
    if (pGetAclInformation == NULL)
    {
        OutputDebugString(_T("DeleteAceFromObjectsSecurityDescriptor: Can't get proc GetAclInformation"));
        goto ErrorCleanup;
    }

    pSetSecurityInfo = (PSETSECURITYINFO_FN)GetProcAddress(hModAdvapiDll,SET_SECURITY_INFO);
    if (pSetSecurityInfo == NULL)
    {
        OutputDebugString(_T("DeleteAceFromObjectsSecurityDescriptor: Can't get proc SetSecurityInfo"));
        goto ErrorCleanup;
    }

    //
    // Make sure Sid passed in is valid
    //

    if (!pIsValidSid(pSid)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        OutputDebugString(_T("DeleteAceFromObjectsSecurityDescriptor: bad pSid"));
        goto ErrorCleanup;
    }

    //
    //  Get the object's security descriptor and current DACL.
    //

    dwRet = pGetSecurityInfo(
                             hObject,
                             ObjectType,
                             DACL_SECURITY_INFORMATION,
                             NULL,
                             NULL,
                             &pDacl,
                             NULL,
                             &pSecDesc
                             );

    if (dwRet != ERROR_SUCCESS) {
        OutputDebugString(_T("DeleteAceFromObjectsSecurityDescriptor: GetSecurityInfo failed"));
        goto ErrorCleanup;
    }

    //
    //  Find the ACE to be deleted
    //

    if (!pGetAclInformation(pDacl, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
    {
        OutputDebugString(_T("DeleteAceFromObjectsSecurityDescriptor: GetAclInformation failed"));
        goto ErrorCleanup;
    }

    for (cAce = 0; cAce < aclSizeInfo.AceCount; cAce++)
    {
        if (!pGetAce(pDacl, cAce, (LPVOID *) &aceHeader))
        {
            continue;
        }

        if (aceHeader->AceType != ACCESS_ALLOWED_ACE_TYPE)
        {
            continue;
        }

        aceAllowed = (PACCESS_ALLOWED_ACE)aceHeader;

        if ((aceAllowed->Header.AceFlags & INHERITED_ACE) != (dwInheritance & INHERITED_ACE))
        {
            continue;
        }

        if ((aceAllowed->Header.AceFlags & CONTAINER_INHERIT_ACE) != (dwInheritance & CONTAINER_INHERIT_ACE))
        {
            continue;
        }

        if ((aceAllowed->Header.AceFlags & OBJECT_INHERIT_ACE) != (dwInheritance & OBJECT_INHERIT_ACE))
        {
            continue;
        }

        if (aceAllowed->Mask != dwAccess)
        {
            continue;
        }

        if (0 == pEqualSid((PSID)&(aceAllowed->SidStart), pSid))
        {
            continue;
        }

        break;
    }

    if (cAce != aclSizeInfo.AceCount)
    {
        //
        // found one
        //
        if (!pDeleteAce(pDacl,cAce))
        {
            OutputDebugString(_T("DeleteAceFromObjectsSecurityDescriptor: DeleteAce failed"));
            goto ErrorCleanup;
        }

        //
        //  Set the new security for the object.
        //

        dwRet = pSetSecurityInfo(
                                 hObject,
                                 ObjectType,
                                 DACL_SECURITY_INFORMATION,
                                 NULL,
                                 NULL,
                                 pDacl,
                                 NULL
                                 );

        if (dwRet != ERROR_SUCCESS) {
            OutputDebugString(_T("DeleteAceFromObjectsSecurityDescriptor: SetSecurityInfo failed"));
            goto ErrorCleanup;
        }

    }

    fReturn = TRUE;

ErrorCleanup:
    if (hModAdvapiDll != NULL) {
        FreeLibrary(hModAdvapiDll);
    }

    if (pSecDesc != NULL) {
        LocalFree(pSecDesc);
    }

    return(fReturn);
}

BOOL
AddUsersGroupToObjectsSecurityDescriptor(
    HANDLE hObject,
    SE_OBJECT_TYPE ObjectType,
    ACCESS_MASK AccessMask,
    ACCESS_MODE AccessMode,
    DWORD Inheritance,
    BOOL fKeepExistingAcl
    )
{
    BOOL fReturn = FALSE;
    DWORD dwRet = ERROR_SUCCESS;
    PSID pSid = NULL;
    SID_IDENTIFIER_AUTHORITY SepNtAuthority = SECURITY_NT_AUTHORITY;
    HMODULE hModAdvapiDll = NULL;
    PALLOCATEANDINITIALIZESID_FN pAllocateAndInitializeSid;
    PFREESID_FN pFreeSid;

    //
    //  Create the SID
    //

    hModAdvapiDll = LoadLibrary(ADVAPI_32_DLL);

    if (hModAdvapiDll == NULL) {
        return(FALSE);
    }

    pAllocateAndInitializeSid = (PALLOCATEANDINITIALIZESID_FN)
                                   GetProcAddress(hModAdvapiDll,
                                                  ALLOCATE_AND_INITITIALIZE_SID);
    if (pAllocateAndInitializeSid == NULL)
    {
        goto ErrorCleanup;
    }

    if (!pAllocateAndInitializeSid(
            &SepNtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_USERS,
            0, 0, 0, 0, 0, 0,
            &pSid
            )) {
        dwRet = GetLastError();
        OutputDebugString(_T("Failed to AllocateAndInitializeSid()"));
        goto ErrorCleanup;
    }

    if (!AddSidToObjectsSecurityDescriptor(
            hObject,
            ObjectType,
            pSid,
            AccessMask,
            AccessMode,
            Inheritance,
            fKeepExistingAcl
            )) {
        dwRet = GetLastError();
        OutputDebugString(_T("Failed to AddSidToObjectsSecurityDescriptor()"));
        goto ErrorCleanup;
    }

    fReturn = TRUE;

ErrorCleanup:

    if ((hModAdvapiDll != NULL) && (pSid != NULL)) {

        pFreeSid = (PFREESID_FN)
            GetProcAddress(hModAdvapiDll,
                           FREE_SID);

        if (pFreeSid != NULL) {
            pFreeSid(pSid);
        }
    }

    if (hModAdvapiDll != NULL) {
        FreeLibrary(hModAdvapiDll);
    }

    SetLastError(dwRet);

    return(fReturn);
}

BOOL
AddTSUsersGroupToObjectsSecurityDescriptor(
    HANDLE hObject,
    SE_OBJECT_TYPE ObjectType,
    ACCESS_MASK AccessMask,
    ACCESS_MODE AccessMode,
    DWORD Inheritance,
    BOOL fKeepExistingAcl
    )
{
    BOOL fReturn = FALSE;
    DWORD dwRet = ERROR_SUCCESS;
    PSID pSid = NULL;
    SID_IDENTIFIER_AUTHORITY SepNtAuthority = SECURITY_NT_AUTHORITY;
    HMODULE hModAdvapiDll = NULL;
    PALLOCATEANDINITIALIZESID_FN pAllocateAndInitializeSid;
    PFREESID_FN pFreeSid;

    //
    //  Create the SID
    //

    hModAdvapiDll = LoadLibrary(ADVAPI_32_DLL);

    if (hModAdvapiDll == NULL) {
        return(FALSE);
    }

    pAllocateAndInitializeSid = (PALLOCATEANDINITIALIZESID_FN)
                                   GetProcAddress(hModAdvapiDll,
                                                  ALLOCATE_AND_INITITIALIZE_SID);
    if (pAllocateAndInitializeSid == NULL)
    {
        goto ErrorCleanup;
    }

    if (!pAllocateAndInitializeSid(
            &SepNtAuthority,
            1,
            SECURITY_TERMINAL_SERVER_RID,
            0, 0, 0, 0, 0, 0, 0,
            &pSid
            )) {
        dwRet = GetLastError();
        OutputDebugString(_T("Failed to AllocateAndInitializeSid()"));
        goto ErrorCleanup;
    }

    if (!AddSidToObjectsSecurityDescriptor(
            hObject,
            ObjectType,
            pSid,
            AccessMask,
            AccessMode,
            Inheritance,
            fKeepExistingAcl
            )) {
        dwRet = GetLastError();
        OutputDebugString(_T("Failed to AddSidToObjectsSecurityDescriptor()"));
        goto ErrorCleanup;
    }

    fReturn = TRUE;

ErrorCleanup:

    if ((hModAdvapiDll != NULL) && (pSid != NULL)) {

        pFreeSid = (PFREESID_FN)
            GetProcAddress(hModAdvapiDll,
                           FREE_SID);

        if (pFreeSid != NULL) {
            pFreeSid(pSid);
        }
    }

    if (hModAdvapiDll != NULL) {
        FreeLibrary(hModAdvapiDll);
    }

    SetLastError(dwRet);

    return(fReturn);
}

BOOL
DeleteUsersGroupAceFromObjectsSecurityDescriptor(
    HANDLE hObject,
    SE_OBJECT_TYPE ObjectType,
    ACCESS_MASK AccessMask,
    ACCESS_MODE AccessMode,
    DWORD Inheritance
    )
{
    BOOL fReturn = FALSE;
    DWORD dwRet = ERROR_SUCCESS;
    PSID pSid = NULL;
    SID_IDENTIFIER_AUTHORITY SepNtAuthority = SECURITY_NT_AUTHORITY;
    HMODULE hModAdvapiDll = NULL;
    PALLOCATEANDINITIALIZESID_FN pAllocateAndInitializeSid;
    PFREESID_FN pFreeSid;

    //
    //  Create the SID
    //

    hModAdvapiDll = LoadLibrary(ADVAPI_32_DLL);

    if (hModAdvapiDll == NULL) {
        return(FALSE);
    }

    pAllocateAndInitializeSid = (PALLOCATEANDINITIALIZESID_FN)
                                   GetProcAddress(hModAdvapiDll,
                                                  ALLOCATE_AND_INITITIALIZE_SID);
    if (pAllocateAndInitializeSid == NULL)
    {
        goto ErrorCleanup;
    }

    if (!pAllocateAndInitializeSid(
            &SepNtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_USERS,
            0, 0, 0, 0, 0, 0,
            &pSid
            )) {
        dwRet = GetLastError();
        OutputDebugString(_T("Failed to AllocateAndInitializeSid()"));
        goto ErrorCleanup;
    }

    if (!DeleteAceFromObjectsSecurityDescriptor(
            hObject,
            ObjectType,
            pSid,
            AccessMask,
            AccessMode,
            Inheritance
            )) {
        dwRet = GetLastError();
        OutputDebugString(_T("Failed to DeleteAceFromObjectsSecurityDescriptor()"));
        goto ErrorCleanup;
    }

    fReturn = TRUE;

ErrorCleanup:

    if ((hModAdvapiDll != NULL) && (pSid != NULL)) {

        pFreeSid = (PFREESID_FN)
            GetProcAddress(hModAdvapiDll,
                           FREE_SID);

        if (pFreeSid != NULL) {
            pFreeSid(pSid);
        }
    }

    if (hModAdvapiDll != NULL) {
        FreeLibrary(hModAdvapiDll);
    }

    SetLastError(dwRet);

    return(fReturn);
}

BOOL
CreateAndWriteHWID(VOID)
{
    BOOL fRet = FALSE;
    DWORD dwDisposition, dwError = NO_ERROR;
    HKEY hKey = NULL;
    HWID hwid;

    // Write HWID to registry

    dwError = RegCreateKeyEx(
                             HKEY_LOCAL_MACHINE,
                             MSLICENSING_HWID_KEY,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS,
                             NULL,
                             &hKey,
                             &dwDisposition
                             );

    if (dwError != ERROR_SUCCESS) {
        goto cleanup;
    }    

    if (dwDisposition == REG_CREATED_NEW_KEY)
    {
        // generate HWID

        if (LICENSE_STATUS_OK == GenerateClientHWID(&hwid))
        {

            dwError = RegSetValueEx(hKey,
                                    MSLICENSING_HWID_VALUE,
                                    0,
                                    REG_BINARY,
                                    (LPBYTE)&hwid,
                                    sizeof(HWID));
            
            if (dwError != ERROR_SUCCESS) {
                goto cleanup;
            }
        }

        fRet = TRUE;
    }
    else
    {
        fRet = TRUE;
    }

cleanup:
    if (NULL != hKey)
    {
        RegCloseKey( hKey );
    }

    return fRet;
}

#endif //OS_WINCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\util\autil.cpp ===
/****************************************************************************/
// autil.c
//
// RDP client utilities
//
// Copyright(C) Microsoft Corporation 1997-1999
/****************************************************************************/

#include <adcg.h>
/****************************************************************************/
/* Define TRC_FILE and TRC_GROUP.                                           */
/****************************************************************************/
extern "C" {
#ifndef OS_WINCE
#include <hydrix.h>
#endif

#ifndef OS_WINCE
#include <process.h>
#endif
}

#define TRC_FILE    "autil"
#define TRC_GROUP   TRC_GROUP_UTILITIES
#include <atrcapi.h>

#include "autil.h"

#ifdef OS_WINCE
#include "cryptkey.h"

#ifndef MAX_COMPUTERNAME_LENGTH
#define MAX_COMPUTERNAME_LENGTH 15
#endif
#define HWID_COMPUTER_NAME_STR_LEN ((MAX_COMPUTERNAME_LENGTH + 1)*sizeof(WCHAR)) // 15 hex characters + one NULL
#define REG_WBT_RDP_COMPUTER_NAME_KEY   _T("Software\\Microsoft\\WBT")
#define REG_WBT_RDP_COMPUTER_NAME_VALUE     _T("Client Name")   

#define BAD_HARDCODED_NAME1 "WBT"
#define BAD_HARDCODED_NAME2 "WinCE"

DCBOOL UT_GetWBTComputerName(PDCTCHAR szBuff, DCUINT32 len);
TCHAR MakeValidChar(BYTE data);

#endif

/****************************************************************************/
/*                                                                          */
/* External DLL                                                             */
/*                                                                          *
/****************************************************************************/
#ifndef OS_WINCE
#ifdef UNICODE
#define T  "W"
#else
#define T  "A"
#endif
#else //OS_WINCE
#define T  _T("W")
#endif //OS_WINCE
#ifndef OS_WINCE
#define MAKE_API_NAME(nm)    CHAR  c_sz##nm[] = #nm
#else
#define MAKE_API_NAME(nm)    TCHAR  c_sz##nm[] = CE_WIDETEXT(#nm)
#endif //OS_WINCE

/****************************************************************************/
/* IMM32 DLL                                                                */
/****************************************************************************/
MAKE_API_NAME(ImmAssociateContext);
MAKE_API_NAME(ImmGetIMEFileNameW);
MAKE_API_NAME(ImmGetIMEFileNameA);

/****************************************************************************/
/* WINNLS DLL                                                               */
/****************************************************************************/
MAKE_API_NAME(WINNLSEnableIME);
#ifdef OS_WIN32
MAKE_API_NAME(IMPGetIMEW);
MAKE_API_NAME(IMPGetIMEA);
#else
MAKE_API_NAME(IMPGetIME);
#endif

/****************************************************************************/
/* F3AHVOAS DLL                                                             */
/****************************************************************************/
MAKE_API_NAME(FujitsuOyayubiControl);


CUT::CUT()
{
    #ifdef DC_DEBUG
    _UT.dwDebugThreadWaitTimeout = INFINITE;
    #endif
}

CUT::~CUT()
{
}


//
// API members
//

/****************************************************************************/
/* Name:      UT_Init                                                       */
/*                                                                          */
/* Purpose:   Initialize UT                                                 */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    None                                                          */
/*                                                                          */
/****************************************************************************/
DCVOID DCAPI CUT::UT_Init(DCVOID)
{
#ifdef DC_DEBUG
    DCUINT seed;
#endif

    DC_BEGIN_FN("UT_Init");
    DC_MEMSET(&_UT, 0, sizeof(_UT));

#ifdef DC_DEBUG
    _UT.dwDebugThreadWaitTimeout = INFINITE;
    //
    // On checked builds we look at a reg setting to determine
    // if we should wait with a smaller timeout to help catch deadlocks
    //
    if (!UTReadRegistryInt(
            UTREG_SECTION,
            UTREG_DEBUG_THREADTIMEOUT,
            (PDCINT)&_UT.dwDebugThreadWaitTimeout)) {
        _UT.dwDebugThreadWaitTimeout = INFINITE;
    }
#endif    


#if defined(OS_WIN32)
    /********************************************************************/
    /*                                                                  */
    /* IMM32 DLL                                                        */
    /*                                                                  */
    /********************************************************************/

    _UT.Imm32Dll.func.rgFunctionPort[0].pszFunctionName = c_szImmAssociateContext;
    _UT.Imm32Dll.func.rgFunctionPort[1].pszFunctionName = c_szImmGetIMEFileNameW;
#ifndef OS_WINCE
    _UT.Imm32Dll.func.rgFunctionPort[2].pszFunctionName = c_szImmGetIMEFileNameA;
#endif
#endif // OS_WIN32

#if !defined(OS_WINCE)
    /********************************************************************/
    /*                                                                  */
    /* WINNLS DLL                                                       */
    /*                                                                  */
    /********************************************************************/

    _UT.WinnlsDll.func.rgFunctionPort[0].pszFunctionName = c_szWINNLSEnableIME;
    _UT.WinnlsDll.func.rgFunctionPort[1].pszFunctionName = c_szIMPGetIMEW;
    _UT.WinnlsDll.func.rgFunctionPort[2].pszFunctionName = c_szIMPGetIMEA;
#endif  // !defined(OS_WINCE)

#if defined(OS_WINNT)
    /********************************************************************/
    /*                                                                  */
    /* F3AHVOAS DLL                                                     */
    /*                                                                  */
    /********************************************************************/

    _UT.F3AHVOasysDll.func.rgFunctionPort[0].pszFunctionName = c_szFujitsuOyayubiControl;
#endif // OS_WINNT

#ifdef DC_DEBUG
    seed = (DCUINT)UT_GetCurrentTimeMS();
    srand(seed);

    TRC_NRM((TB, _T("Random seed : %d"), seed));
    UT_SetRandomFailureItem(UT_FAILURE_MALLOC, 0);
    UT_SetRandomFailureItem(UT_FAILURE_MALLOC_HUGE, 0);
#endif /* DC_DEBUG */

    /************************************************************************/
    /* Set the OS version                                                   */
    /************************************************************************/
	OSVERSIONINFO   osVersionInfo;
	DCBOOL			bRc;
    osVersionInfo.dwOSVersionInfoSize = sizeof(osVersionInfo);
    bRc = GetVersionEx(&osVersionInfo);

    TRC_ASSERT((bRc), (TB,_T("GetVersionEx failed")));
#ifdef OS_WINCE
    TRC_ASSERT((osVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_CE),
               (TB,_T("Unknown os version %d"), osVersionInfo.dwPlatformId));
#else
    TRC_ASSERT(((osVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) ||
                (osVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)),
                (TB,_T("Unknown os version %d"), osVersionInfo.dwPlatformId));
#endif

    _UT.osMinorType =
                  (osVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) ?
                        TS_OSMINORTYPE_WINDOWS_95 : TS_OSMINORTYPE_WINDOWS_NT;


    DC_END_FN();

    return;

} /* UT_Init */


/****************************************************************************/
/* Name:      UT_Term                                                       */
/*                                                                          */
/* Purpose:   Terminate UT                                                  */
/****************************************************************************/
DCVOID DCAPI CUT::UT_Term(DCVOID)
{
    DC_BEGIN_FN("UT_Term");
    DC_END_FN();
} /* UT_Term */


/****************************************************************************/
/* Name:      UT_MallocReal                                                 */
/*                                                                          */
/* Purpose:   Attempts to dynamically allocate memory of a size which is    */
/*            specified using a DCUINT, ie for Win16 this allocates up to   */
/*            one 64K segement.                                             */
/*                                                                          */
/* Returns:   pointer to allocated memory, or NULL if the function fails.   */
/*                                                                          */
/* Params:    length - length in bytes of the memory to allocate.           */
/*                                                                          */
/****************************************************************************/
PDCVOID DCAPI CUT::UT_MallocReal(DCUINT length)
{
    PDCVOID rc;

    DC_BEGIN_FN("UT_MallocReal");

#ifdef DC_DEBUG
    if (UT_TestRandomFailure(UT_FAILURE_MALLOC))
    {
        rc = NULL;
        TRC_NRM((TB, _T("Fake Malloc failure of %#x bytes"), length));
        DC_QUIT;
    }
#endif /* DC_DEBUG */

    rc = UTMalloc(length);

    if (rc == NULL)
    {
        TRC_ERR((TB, _T("Failed to allocate %#x bytes"), length));
    }
    else
    {
        TRC_NRM((TB, _T("Allocated %#x bytes at %p"), length, rc));
    }

DC_EXIT_POINT:
    DC_END_FN();
    return(rc);
}


/****************************************************************************/
/* Name:      UT_MallocHugeReal                                             */
/*                                                                          */
/* Purpose:   Attempts to dynamically allocate memory of a size which is    */
/*            specified using a DCUINT32, ie for Win16 this returns a HUGE  */
/*            pointer which can be used to address memory straddling more   */
/*            than one 64K segment. For Win32, this is identical to         */
/*            UT_Malloc.                                                    */
/*                                                                          */
/* Returns:   pointer to allocated memory, or NULL if the function fails.   */
/*                                                                          */
/* Params:    length - length in bytes of the memory to allocate.           */
/*                                                                          */
/****************************************************************************/
HPDCVOID DCAPI CUT::UT_MallocHugeReal(DCUINT32 length)
{
    HPDCVOID rc;

    DC_BEGIN_FN("UT_MallocHugeReal");

#ifdef DC_DEBUG
    if (UT_TestRandomFailure(UT_FAILURE_MALLOC_HUGE))
    {
        rc = NULL;
        TRC_NRM((TB, _T("Fake MallocHuge failure of %#lx bytes"), length));
        DC_QUIT;
    }
#endif /* DC_DEBUG */

    rc = UTMallocHuge(length);

    if (rc == NULL)
    {
        TRC_ERR((TB, _T("Failed to HUGE allocate %#lx bytes"), length));
    }
    else
    {
        TRC_NRM((TB, _T("Allocated %#lx bytes at %p"), length, rc));
    }

DC_EXIT_POINT:
    DC_END_FN();
    return(rc);
}


/****************************************************************************/
/* Name:      UT_FreeReal                                                   */
/*                                                                          */
/* Purpose:   Frees dynamically allocated memory obtained using UT_Malloc   */
/*                                                                          */
/* Params:    pMemory - pointer to memory to free                           */
/****************************************************************************/
DCVOID DCAPI CUT::UT_FreeReal(PDCVOID pMemory)
{
#ifndef OS_WINCE
    UINT32 size;
#endif

    DC_BEGIN_FN("UT_FreeReal");

#ifdef OS_WIN32
#ifndef OS_WINCE
    size = (UINT32)LocalSize(LocalHandle(pMemory));
#endif
#else
    size = GlobalSize((HGLOBAL)LOWORD(GlobalHandle(SELECTOROF(pMemory))));
#endif
#ifndef OS_WINCE
    TRC_NRM((TB, _T("Free %#lx bytes at %p"), size, pMemory));
#endif

    UTFree(pMemory);

    DC_END_FN();
}


/****************************************************************************/
/* Name:      UT_ReadRegistryString                                         */
/*                                                                          */
/* Purpose:   Read a string from the registry                               */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    IN      pSection      - registy section                       */
/*            IN      pEntry        - entry name                            */
/*            IN      pDefaultValue - default value                         */
/*            OUT     pBuffer       - output buffer                         */
/*            IN      bufferSize    - output buffer size                    */
/****************************************************************************/
DCVOID DCAPI CUT::UT_ReadRegistryString(PDCTCHAR pSection,
                                   PDCTCHAR pEntry,
                                   PDCTCHAR pDefaultValue,
                                   PDCTCHAR pBuffer,
                                   DCINT    bufferSize)
{
    DC_BEGIN_FN("UT_ReadRegistryString");

    /************************************************************************/
    /* Check for NULL parameters                                            */
    /************************************************************************/
    TRC_ASSERT((pSection != NULL), (TB, _T("NULL pointer to section name")));
    TRC_ASSERT((pEntry != NULL), (TB, _T("NULL pointer to entry name")));

    /************************************************************************/
    /* Allow NULL default (returns empty string).                           */
    /************************************************************************/
    TRC_ASSERT(!((pDefaultValue != NULL) &&
                 (((DCINT)DC_TSTRBYTELEN(pDefaultValue) > bufferSize))),
               (TB, _T("Default string NULL, or too long for entry %s"), pEntry));

    /************************************************************************/
    /* Read the registry entry                                              */
    /************************************************************************/
    if (!UTReadRegistryString(pSection, pEntry, pBuffer, bufferSize))
    {
        TRC_NRM((TB, _T("Failed to read registry entry [%s] %s"),
                                                           pSection, pEntry));

        if (pDefaultValue != NULL)
        {
            StringCchCopy(pBuffer, bufferSize, pDefaultValue);
        }
        else
        {
            pBuffer[0] = 0;
        }

        DC_QUIT;
    }

DC_EXIT_POINT:
    DC_END_FN();
} /* UT_ReadRegistryString */


//
// Caller must free return buffer ppBuffer
//
DCBOOL DCAPI CUT::UT_ReadRegistryExpandSZ(PDCTCHAR  pSection,
                                       PDCTCHAR   pEntry,
                                       PDCTCHAR*  ppBuffer,
                                       PDCINT     pBufferSize )
{
    DC_BEGIN_FN("UT_ReadRegistryExpandSZ");

    /************************************************************************/
    /* Check for NULL parameters                                            */
    /************************************************************************/
    TRC_ASSERT((pSection != NULL), (TB, _T("NULL pointer to section name")));
    TRC_ASSERT((pEntry != NULL), (TB, _T("NULL pointer to entry name")));
    TRC_ASSERT((ppBuffer != NULL), (TB,_T("NULL pBuffer")));
    TRC_ASSERT((pBufferSize != NULL), (TB,_T("NULL pBufferSize")));

    /************************************************************************/
    /* Read the registry entry                                              */
    /************************************************************************/
    if (!UTReadRegistryExpandString(pSection, pEntry, ppBuffer, pBufferSize))
    {
        TRC_NRM((TB, _T("Failed to read registry entry [%s] %s"),
                                                           pSection, pEntry));

        *ppBuffer = NULL;
        *pBufferSize = 0;

        return FALSE;
    }
    else
    {
        return TRUE;
    }

DC_EXIT_POINT:
    DC_END_FN();
}


/****************************************************************************/
/* Name:      UT_ReadRegistryInt                                            */
/*                                                                          */
/* Purpose:   Read an INT from the registry                                 */
/*                                                                          */
/* Returns:   Integer read from registry / default                          */
/*                                                                          */
/* Params:    IN      pSection      - registy section                       */
/*            IN      pEntry        - entry name                            */
/*            IN      defaultValue  - default value                         */
/****************************************************************************/
DCINT DCAPI CUT::UT_ReadRegistryInt(PDCTCHAR pSection,
                               PDCTCHAR pEntry,
                               DCINT    defaultValue)
{
    DCINT rc;

    DC_BEGIN_FN("UT_ReadRegistryInt");

    /************************************************************************/
    /* Check for NULL parameters                                            */
    /************************************************************************/
    TRC_ASSERT((pSection != NULL), (TB, _T("NULL pointer to section name")));
    TRC_ASSERT((pEntry != NULL), (TB, _T("NULL pointer to entry name")));

    /************************************************************************/
    /* Read the registry entry.                                             */
    /************************************************************************/
    if (!UTReadRegistryInt(pSection, pEntry, &rc))
    {
        TRC_NRM((TB, _T("Failed to read registry entry [%s] %s"),
                                                           pSection, pEntry));
        rc = defaultValue;
    }

    DC_END_FN();
    return(rc);
} /* UT_ReadRegistryInt */


/****************************************************************************/
/* Name:      UT_ReadRegistryBinary                                         */
/*                                                                          */
/* Purpose:   Read binary data from the registry                            */
/*                                                                          */
/* Params:    IN      pSection      - registy section                       */
/*            IN      pEntry        - entry name                            */
/*            OUT     pBuffer       - output buffer                         */
/*            IN      bufferSize    - output buffer size                    */
/****************************************************************************/
DCVOID DCAPI CUT::UT_ReadRegistryBinary(PDCTCHAR pSection,
                                   PDCTCHAR pEntry,
                                   PDCTCHAR pBuffer,
                                   DCINT    bufferSize)
{
    DC_BEGIN_FN("UT_ReadRegistryBinary");

    /************************************************************************/
    /* Check for NULL parameters                                            */
    /************************************************************************/
    TRC_ASSERT((pSection != NULL), (TB, _T("NULL pointer to section name")));
    TRC_ASSERT((pEntry != NULL), (TB, _T("NULL pointer to entry name")));

    /************************************************************************/
    /* Read the registry entry                                              */
    /************************************************************************/
    if (!UTReadRegistryBinary(pSection, pEntry, pBuffer, bufferSize))
    {
        TRC_NRM((TB, _T("Failed to read reg entry [%s] %s"), pSection, pEntry));
        *pBuffer = 0;
    }

    DC_END_FN();
} /* UT_ReadRegistryBinary */


/****************************************************************************/
/* Name:      UT_EnumRegistry                                               */
/*                                                                          */
/* Purpose:   Enumerate registry keys from a section                        */
/*                                                                          */
/* Returns:   TRUE  - registry key returned                                 */
/*            FALSE - no more registry keys to enumerate                    */
/*                                                                          */
/* Params:    IN      pSection      - registy section                       */
/*            IN      index         - index of key to enumerate             */
/*            OUT     pBuffer       - output buffer                         */
/*            IN      bufferSize    - output buffer size                    */
/****************************************************************************/
DCBOOL DCAPI CUT::UT_EnumRegistry( PDCTCHAR pSection,
                              DCUINT32 index,
                              PDCTCHAR pBuffer,
                              PDCINT   pBufferSize )
{
    DCBOOL rc;
    DC_BEGIN_FN("UT_EnumRegistry");

    rc = UTEnumRegistry(pSection, index, pBuffer, pBufferSize);

    DC_END_FN();
    return(rc);
} /* UT_EnumRegistry */


/****************************************************************************/
/* Name:      UT_WriteRegistryString                                        */
/*                                                                          */
/* Purpose:   Write a string to the registry                                */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise                           */
/*                                                                          */
/* Params:    IN      pSection      - registy section                       */
/*            IN      pEntry        - entry name                            */
/*            IN      pDefaultValue - default value                         */
/*            IN      pBuffer       - string to write                       */
/****************************************************************************/
DCBOOL DCAPI CUT::UT_WriteRegistryString(PDCTCHAR pSection,
                                    PDCTCHAR pEntry,
                                    PDCTCHAR pDefaultValue,
                                    PDCTCHAR pBuffer)
{
    DCBOOL rc = FALSE;

    DC_BEGIN_FN("UT_WriteRegistryString");

    /************************************************************************/
    /* Check for NULL parameters.                                           */
    /************************************************************************/
    TRC_ASSERT((pSection != NULL), (TB, _T("NULL pointer to section name")));
    TRC_ASSERT((pEntry != NULL), (TB, _T("NULL pointer to entry name")));
    TRC_ASSERT((pBuffer != NULL), (TB, _T("NULL pointer to value")));

    /************************************************************************/
    /* Check the passed value against the default.                          */
    /************************************************************************/
    if (pDefaultValue != NULL)
    {
        if (0 == DC_TSTRICMP(pBuffer, pDefaultValue))
        {
            /****************************************************************/
            /* They match - in this case we just need to delete any         */
            /* existing entry from the registry.                            */
            /****************************************************************/
            if (UTDeleteEntry(pSection, pEntry))
            {
                rc = TRUE;
                DC_QUIT;
            }
        }
    }

    /************************************************************************/
    /* Write the registry string.                                           */
    /************************************************************************/
    if (!UTWriteRegistryString(pSection, pEntry, pBuffer))
    {
        TRC_NRM((TB, _T("Failed to write registry entry [%s] %s"),
                                                           pSection, pEntry));
        DC_QUIT;
    }
    rc = TRUE;

DC_EXIT_POINT:
    DC_END_FN();
    return(rc);
} /* UT_WriteRegistryString */


/****************************************************************************/
/* Name:      UT_WriteRegistryInt                                           */
/*                                                                          */
/* Purpose:   Write an INT to the registry                                  */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise                           */
/*                                                                          */
/* Params:    IN      pSection      - registy section                       */
/*            IN      pEntry        - entry name                            */
/*            IN      defaultValue  - default value                         */
/*            IN      value         - value to write                        */
/****************************************************************************/
DCBOOL DCAPI CUT::UT_WriteRegistryInt(PDCTCHAR pSection,
                                 PDCTCHAR pEntry,
                                 DCINT    defaultValue,
                                 DCINT    value)
{
    DCBOOL rc = FALSE;

    DC_BEGIN_FN("UT_WriteRegistryInt");

    /************************************************************************/
    /* Check for NULL parameters.                                           */
    /************************************************************************/
    TRC_ASSERT((pSection != NULL), (TB, _T("NULL pointer to section name")));
    TRC_ASSERT((pEntry != NULL), (TB, _T("NULL pointer to entry name")));

    /************************************************************************/
    /* Check the passed value against the default.                          */
    /************************************************************************/
    if (value == defaultValue)
    {
        /********************************************************************/
        /* They match - in this case we just need to delete any             */
        /* existing entry from the registry.                                */
        /********************************************************************/
        if (UTDeleteEntry(pSection, pEntry))
        {
            rc = TRUE;
            DC_QUIT;
        }
    }

    /************************************************************************/
    /* Write the registry value.                                            */
    /************************************************************************/
    if (!UTWriteRegistryInt(pSection, pEntry, (DCINT) value))
    {
        TRC_NRM((TB, _T("Bad rc %hd for entry [%s] %s"), rc, pSection, pEntry));
        DC_QUIT;
    }
    rc = TRUE;

DC_EXIT_POINT:
    DC_END_FN();
    return(rc);
} /* UT_WriteRegistryInt */


/****************************************************************************/
/* Name:      UT_ParseUserData                                              */
/*                                                                          */
/* Purpose:   Parses the user data and finds the type of data requested     */
/*                                                                          */
/* Returns:   A pointer to the value requested                              */
/*                                                                          */
/* Params:                                                                  */
/*   pUserData:         The data to be parsed.                              */
/*   userDataLen:       The total length of the data.                       */
/*   typeRequested:     The type of data requested.                         */
/****************************************************************************/
PRNS_UD_HEADER DCAPI CUT::UT_ParseUserData(PRNS_UD_HEADER  pUserData,
                                      DCUINT          userDataLen,
                                      DCUINT16        typeRequested)
{
    PDCUINT8       pUDEnd;
    PRNS_UD_HEADER pUDRequested;

    DC_BEGIN_FN("UT_ParseUserData");

    /************************************************************************/
    /* Check that the user data to be parsed is valid.                      */
    /************************************************************************/
    TRC_ASSERT((pUserData != NULL),(TB, _T("Null User Data in UT_ParseUserData")));
    TRC_ASSERT((userDataLen != 0), (TB,_T("Null user data in UT_ParseUserData")));
    pUDRequested = NULL;
    pUDEnd = (PDCUINT8)pUserData + userDataLen;
    TRC_NRM((TB, _T("Parsing user data(len:%u) from %p to %p for type %#hx"),
                  userDataLen,
                  (PDCUINT8)pUserData,
                  pUDEnd,
                  typeRequested));

    /************************************************************************/
    /* We shouldn't trust that the PRNS_UD_HEADER is even valid, or we may  */
    /* AV trying to read it.                                                */
    /************************************************************************/
    if ((PDCUINT8)pUserData + sizeof(PRNS_UD_HEADER) > pUDEnd)
    {
        TRC_ABORT((TB, _T("Invalid UserData")));
        DC_QUIT;
    }

    /************************************************************************/
    /* Parse user data until the typeRequested is found.                    */
    /************************************************************************/
    while (pUserData->length != 0 && (pUserData->type) != typeRequested)
    {
        TRC_NRM((TB, _T("Skip UserData type %#hx len %hu"),
                     pUserData->type, pUserData->length));
        pUserData = (PRNS_UD_HEADER)((PDCUINT8)pUserData + pUserData->length);
        if ((PDCUINT8)pUserData >= pUDEnd)
        {
            TRC_ERR((TB, _T("No data of type %#hx"),typeRequested));
            DC_QUIT;
        }

        /************************************************************************/
        /* Again, don't trust the PRNS_UD_HEADER to be there...                 */
        /************************************************************************/
        if ((PDCUINT8)pUserData + sizeof(PRNS_UD_HEADER) > pUDEnd)
        {
            TRC_ABORT((TB, _T("Invalid UserData")));
            DC_QUIT;
        }
    }

    if (pUserData->length == 0) {
        TRC_ERR((TB, _T("Invalid UserData")));
        DC_QUIT;
    }
    /**************************************************************************/
    /* we found the requested user data type, check to see we have sufficient */
    /* data                                                                   */
    /**************************************************************************/

    if( ((PDCUINT8)pUserData + pUserData->length) > pUDEnd ) {
        TRC_ERR((TB, _T("Insufficient user data of type %#hx"),typeRequested));
        DC_QUIT;

    }

    pUDRequested = pUserData;

DC_EXIT_POINT:
    DC_END_FN();
    return(pUDRequested);
} /* UT_ParseUserData */


/****************************************************************************/
/* Name:      UT_WriteRegistryBinary                                        */
/*                                                                          */
/* Purpose:   Write binary data to the registry                             */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise                           */
/*                                                                          */
/* Params:    IN      pSection      - registy section                       */
/*            IN      pEntry        - entry name                            */
/*            IN      pBuffer       - string to write                       */
/*            IN      bufferSize    - Buffer size                           */
/*                                                                          */
/****************************************************************************/
DCBOOL DCAPI CUT::UT_WriteRegistryBinary(PDCTCHAR pSection,
                                    PDCTCHAR pEntry,
                                    PDCTCHAR pBuffer,
                                    DCINT    bufferSize)
{
    DCBOOL rc = FALSE;

    DC_BEGIN_FN("UT_WriteRegistryBinary");

    /************************************************************************/
    /* Check for NULL parameters.                                           */
    /************************************************************************/
    TRC_ASSERT((pSection != NULL), (TB, _T("NULL pointer to section name")));
    TRC_ASSERT((pEntry != NULL), (TB, _T("NULL pointer to entry name")));
    TRC_ASSERT((pBuffer != NULL), (TB, _T("NULL pointer to value")));

    /************************************************************************/
    /* Write the registry data.                                           */
    /************************************************************************/
    if (!UTWriteRegistryBinary(pSection, pEntry, pBuffer, bufferSize))
    {
        TRC_NRM((TB, _T("Failed to write registry entry [%s] %s"),
                                                           pSection, pEntry));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DC_END_FN();
    return(rc);
} /* UT_WriteRegistryBinary */


/****************************************************************************/
// UT_GetCapsSet
//
// Extracts the specified capability set from the combined caps.
//
// Returns: Pointer to the capability set within the combined caps, or NULL
// if the requested capability type was not found.
//
// Params:    IN: capsLength - number of bytes pointed to by pCaps
//            IN: pCaps - pointer to the combined capabilities
//            IN: capsSet - caps set to get
/****************************************************************************/
PDCVOID DCINTERNAL CUT::UT_GetCapsSet(DCUINT capsLength,
                                 PTS_COMBINED_CAPABILITIES pCaps,
                                 DCUINT capsSet)
{
    PTS_CAPABILITYHEADER pCapsHeader;
    unsigned capsOffset;

    DC_BEGIN_FN("UT_GetCapsSet");

    TRC_ASSERT((!IsBadReadPtr(pCaps, sizeof(*pCaps) + sizeof(*pCapsHeader))),
               (TB, _T("Invalid combined capabilities pointer")));
    TRC_ASSERT((pCaps->numberCapabilities >= 1), (TB, _T("No capability sets")));

    TRC_NRM((TB, _T("%u capability sets present, length %u, getting %u"),
                                           (DCUINT)pCaps->numberCapabilities,
                                            capsLength,
                                            capsSet));

    /************************************************************************/
    /* Find the specified capability set in the combined caps.              */
    /* First, get a pointer to the header for the first capability set.     */
    /************************************************************************/
    pCapsHeader = (PTS_CAPABILITYHEADER)pCaps->data;
    capsOffset = sizeof(TS_COMBINED_CAPABILITIES) - 1;
    TRC_ASSERT((!IsBadReadPtr(pCapsHeader, sizeof(*pCapsHeader))),
            (TB, _T("Invalid capability header")));
    TRC_ASSERT((!IsBadReadPtr(pCapsHeader, pCapsHeader->lengthCapability)),
               (TB, _T("Invalid initial capability set")));
    while (pCapsHeader->lengthCapability != 0 && pCapsHeader->capabilitySetType != capsSet)
    {
        /********************************************************************/
        /* Add the length of this capability to the offset, to keep track   */
        /* of how much of the combined caps we have processed.              */
        /********************************************************************/
        capsOffset += pCapsHeader->lengthCapability;
        if (capsOffset >= capsLength)
        {
            TRC_NRM((TB, _T("Capability set not found (type %d)"), capsSet));
            pCapsHeader = NULL;
            DC_QUIT;
        }

        /********************************************************************/
        /* Add the length of this capability to the header pointer, so it   */
        /* points to the next capability set.                               */
        /********************************************************************/
        pCapsHeader = (PTS_CAPABILITYHEADER)
                (((PDCUINT8)pCapsHeader) + pCapsHeader->lengthCapability);
        TRC_ASSERT((!IsBadReadPtr(pCapsHeader, sizeof(*pCapsHeader))),
                (TB, _T("Invalid capability header")));
        TRC_ASSERT((!IsBadReadPtr(pCapsHeader,
                pCapsHeader->lengthCapability)),
                (TB, _T("Invalid combined capability set")));
        TRC_NRM((TB, _T("Next order set: %u"), pCapsHeader->capabilitySetType));
    }

    if (pCapsHeader->lengthCapability == 0) {
        TRC_ERR((TB, _T("Invalid capsheader")));
        pCapsHeader = NULL;
        DC_QUIT;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return pCapsHeader;
} /* UT_GetCapsSet */


#if !defined(OS_WINCE)
/****************************************************************************/
/* Name:      UT_GetFullPathName                                            */
/*                                                                          */
/* Purpose:   Retrieves the full path and filename of a specified file      */
/*                                                                          */
/* Returns:   If the function succeeds, the return value is the length,     */
/*            in characters, of the string copied to lpBuffer,              */
/*            not including the terminating null character.                 */
/*                                                                          */
/* Params:    IN: lpFileName - address of name of file to find path for     */
/*            IN: nBufferLength - size, in characters, of path buffer       */
/*            OUT: lpBuffer - address of path buffer                        */
/*            OUT: *lpFilePart - address of filename in path                */
/****************************************************************************/
DCUINT DCINTERNAL CUT::UT_GetFullPathName(PDCTCHAR lpFileName,
                                     DCUINT   nBufferLength,
                                     PDCTCHAR lpBuffer,
                                     PDCTCHAR *lpFilePart)
{
    DCUINT ret = FALSE;

    DC_BEGIN_FN("UT_GetFullPathName");

    ret = GetFullPathName(lpFileName,nBufferLength,lpBuffer,lpFilePart);

    DC_END_FN();
    return(ret);
} /* UT_GetFullPathName */
#endif // !defined(OS_WINCE)


#ifdef OS_WIN32

/****************************************************************************/
/* Name:      UT_StartThread                                                */
/*                                                                          */
/* Purpose:   Start a new thread                                            */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise                           */
/*                                                                          */
/* Params:    IN      entryFunction - pointer to thread startup function    */
/****************************************************************************/
DCBOOL DCAPI CUT::UT_StartThread(UTTHREAD_PROC   entryFunction,
                            PUT_THREAD_DATA pThreadData, PDCVOID threadParam)
{
    DCBOOL rc;

    DC_BEGIN_FN("UT_StartThread");

    /************************************************************************/
    /* Call onto the internal function, requiring no userParam.             */
    /* Note that this is OS-specific.                                       */
    /************************************************************************/
    rc = UTStartThread(entryFunction, pThreadData, threadParam);

    DC_END_FN();
    return(rc);
} /* UT_StartThread  */


//
// WaitWithMessageLoop
// Waits on a handle while allowing window messages to be processed
// 
// Params:
//      hEvent  - event to wait on
//      Timeout - timeout value to wait for
//
// Returns:
//      Results of wait see MsgWaitForMultipleObjects in MSDN
//
//
DWORD CUT::UT_WaitWithMessageLoop(HANDLE hEvent, ULONG Timeout)
{
    DWORD dwRet;
    DWORD dwTemp;
    MSG msg;
    DWORD dwStartTime = GetTickCount();
    while (1) 
    {
        dwRet = MsgWaitForMultipleObjects( 1,        // One event to wait for
                                           &hEvent,  // The array of events
                                           FALSE,    // Wait for 1 event
                                           Timeout,  // Timeout value
                                           QS_ALLINPUT);   // Any message wakes up
        if (dwRet == WAIT_OBJECT_0 + 1) {

            // There is a window message available. Dispatch it.
            while (PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE)) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }

            if (INFINITE != Timeout) {
                //
                // If we keep getting flooded by messages the timer will constantly
                // reset and the timeout interval will be _very_ long. So do a check
                // and bail out
                //
                dwTemp = GetTickCount();
                if (dwTemp - dwStartTime >= Timeout) {
                    dwRet = WAIT_TIMEOUT;
                    break;
                }
                Timeout -= dwTemp - dwStartTime;
                dwStartTime = dwTemp;
            }
        }
        else 
        {
            break;
        }
    }
 
    return dwRet;
}

/****************************************************************************/
/* Name:      UT_DestroyThread                                              */
/*                                                                          */
/* Purpose:   Terminate a thread                                            */
/*                                                                          */
/* Returns:   TRUE - success                                                */
/*            FALSE  - failed                                               */
/*                                                                          */
/* Params:    IN      threadID   - thread ID                                */
/*            fPumpMessages      - TRUE if wait should pump messages        */
/****************************************************************************/
DCBOOL DCAPI CUT::UT_DestroyThread(UT_THREAD_DATA threadData,
                                   BOOL fPumpMessages)
{
    DCBOOL rc;

    DC_BEGIN_FN("UT_DestroyThread");

    rc = UTStopThread(threadData, fPumpMessages);

    DC_END_FN();
    return(rc);
} /* UT_DestroyThread */

#endif /* OS_WIN32 */





#ifdef DC_DEBUG
/****************************************************************************/
/* Name: UT_SetRandomFailureItem                                            */
/*                                                                          */
/* Purpose: Sets the percentage failure of a specified function             */
/*                                                                          */
/* Params: IN - itemID - identifies the function                            */
/*         IN - percent - the new percentage failure                        */
/****************************************************************************/
DCVOID DCAPI CUT::UT_SetRandomFailureItem(DCUINT itemID, DCINT percent)
{
    DC_BEGIN_FN("UT_SetRandomFailureItem");

    TRC_ASSERT( ( (percent >= 0) && (percent <= 100) ) ,
                 (TB,_T("Bad failure percentage passed to UT")));

    TRC_ASSERT(( ( itemID >= UT_FAILURE_BASE ) &&
                 ( itemID <= (UT_FAILURE_BASE + UT_FAILURE_MAX_INDEX ) ) ),
                 (TB,_T("Bad itemID")));

    TRC_NRM((TB, _T("Setting item %d"), itemID));

    _UT.failPercent[itemID - UT_FAILURE_BASE] = percent;

    DC_END_FN();
} /* UT_SetRandomFailureItem */


/****************************************************************************/
/* Name: UT_GetRandomFailureItem                                            */
/*                                                                          */
/* Purpose: Gets the percentage failure for a specified function            */
/*                                                                          */
/* Returns: The percentage                                                  */
/*                                                                          */
/* Params: IN - itemID - identifies the function                            */
/****************************************************************************/
DCINT DCAPI CUT::UT_GetRandomFailureItem(DCUINT itemID)
{
    DCINT rc = 0;

    DC_BEGIN_FN("UT_GetRandomFailureItem");

    TRC_ASSERT(( ( itemID >= UT_FAILURE_BASE ) &&
                 ( itemID <= UT_FAILURE_BASE + UT_FAILURE_MAX_INDEX ) ),
                 (TB,_T("Bad itemID")));

    rc = _UT.failPercent[itemID - UT_FAILURE_BASE];

    DC_END_FN();
    return(rc);
} /* UT_GetRandomFailureItem */


/****************************************************************************/
/* Name: UT_TestRandomFailure                                               */
/*                                                                          */
/* Purpose: Simulates random failure of a function specified, according to  */
/*          the percentage asscociated with that function                   */
/*                                                                          */
/* Returns: TRUE if function is simualted as failed                         */
/*                                                                          */
/* Params: IN - itemID - specifies function on which to simulate failure    */
/*                                                                          */
/****************************************************************************/
DCBOOL DCAPI CUT::UT_TestRandomFailure(DCUINT itemID)
{
    DCBOOL rc = FALSE;

    DC_BEGIN_FN("UT_TestRandomFailure");

    TRC_ASSERT(( itemID >= UT_FAILURE_BASE &&
                 itemID <= UT_FAILURE_BASE + UT_FAILURE_MAX_INDEX ),
                 (TB,_T("Bad itemID")));

    if ((rand() % 100) < _UT.failPercent[itemID - UT_FAILURE_BASE])
    {
        rc = TRUE;
    }
    else
    {
        rc = FALSE;
    }

    DC_END_FN();
    return(rc);
} /* UT_TestRandomFailure */

#endif /* DC_DEBUG */


/****************************************************************************/
/* Name:      UT_GetANSICodePage                                             */
/*                                                                          */
/* Purpose:   Get the local ANSI code page                                  */
/*                                                                          */
/* Returns:   Code page                                                     */
/*                                                                          */
/* Operation: Look at the version info for GDI.EXE                          */
/****************************************************************************/
DCUINT DCINTERNAL CUT::UT_GetANSICodePage(DCVOID)
{
    DCUINT     codePage;

    DC_BEGIN_FN("UT_GetANSICodePage");

    //
    // Get the ANSI code page.  This function always returns a valid value.
    //
    codePage = GetACP();

    TRC_NRM((TB, _T("Return codepage %u"), codePage));

    DC_END_FN();
    return(codePage);
} /* UT_GetANSICodePage */


/****************************************************************************/
/* Name:      UT_IsNEC98platform                                            */
/*                                                                          */
/* Purpose:   Is client platform a NEC PC-98 ?                              */
/*                                                                          */
/* Returns:   TRUE if platform is it.                                       */
/****************************************************************************/
DCBOOL DCINTERNAL CUT::UT_IsNEC98platform(DCVOID)
{
#if !defined(OS_WINCE)
    if (GetKeyboardType(0) == 7 &&                     /* 7 is a Japanese */
        HIBYTE(LOWORD(GetKeyboardType(1))) == 0x0D)    /* 0x0d is a NEC */
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
#else // !defined(OS_WINCE)
    return FALSE;
#endif // !defined(OS_WINCE)
}


/****************************************************************************/
/* Name:      UT_IsNX98Key                                                  */
/*                                                                          */
/* Purpose:   Is client configured with a NEC PC-98NX keyboard ?            */
/*                                                                          */
/* Returns:   TRUE if NEC PC-98NX keyboard is attached.                     */
/****************************************************************************/
DCBOOL DCINTERNAL CUT::UT_IsNX98Key(DCVOID)
{
#if !defined(OS_WINCE)
    if (GetKeyboardType(0) == 7 &&                     /* 7 is a Japanese */
        GetKeyboardType(1) == 2 &&                     /* 2 is a 106 keyboard */
        GetKeyboardType(2) == 15)                      /* Number of function key is 15 */
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
#else // !defined(OS_WINCE)
    return FALSE;
#endif // !defined(OS_WINCE)
}


/****************************************************************************/
/* Name:      UT_GetRealDriverNameNT                                        */
/*                                                                          */
/* Purpose:   Get real keyboard driver name for NT.                         */
/*                                                                          */
/* Returns:   TRUE if get driver name.                                      */
/****************************************************************************/
#if !defined(OS_WINCE)
DCBOOL DCINTERNAL CUT::UT_GetRealDriverNameNT(
    PDCTCHAR lpszRealDriverName,
    UINT     cchDriverName
    )
{
    DCBOOL   fRet = FALSE;
    HKEY     hKey = NULL;
    DWORD    DataType = REG_SZ;
    DCTCHAR  SubKey[MAX_PATH];
    DCTCHAR  Buffer[MAX_PATH];
    DWORD    DataSize;
    DCTCHAR  kbdName[KL_NAMELENGTH];
    HRESULT  hr;
    DC_BEGIN_FN("UT_GetRealDriverNameNT");

    if (GetKeyboardLayoutName(kbdName))
    {
        hr = StringCchPrintf(
                        SubKey,
                        SIZE_TCHARS(SubKey),
                        _T("System\\CurrentControlSet\\Control\\Keyboard Layouts\\%s"),
                        kbdName
                        );
        if (FAILED(hr)) {
            TRC_ERR((TB,_T("Failed to printf subkey: 0x%x"),hr));
            return FALSE;
        }


        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         SubKey,
                         0,                      /* reserved                 */
                         KEY_READ,
                         &hKey) == ERROR_SUCCESS)
        {
            DataSize = sizeof(Buffer);
            if (RegQueryValueEx(hKey,
                                _T("Layout File"),
                                0,                   /* reserved                 */
                                &DataType,
                                (LPBYTE)Buffer,
                                &DataSize) == ERROR_SUCCESS)
            {
                if (_tcsicmp(Buffer, _T("KBDJPN.DLL")) == 0)
                {
                    HMODULE hLibModule;
                    BOOL (*pfnDriverNT4)(LPWSTR);
                    BOOL (*pfnDriver)(HKL, LPWSTR, LPVOID, LPVOID);

                    hLibModule = LoadLibrary(Buffer);
                    if (hLibModule != NULL)
                    {
                        /*
                         * if the layout driver is not "REAL" layout driver, the driver has
                         * "3" and "5" entry point, then we call this to get real layout driver..
                         * This is nessesary for Japanese and Korean system. because thier
                         * keyboard layout driver is "KBDJPN.DLL" or "KBDKOR.DLL", but its
                         * "REAL" driver become diffrent thier keyboard hardware.
                         */
                        /*
                         * Get the entrypoint.
                         */
                        pfnDriver = (BOOL(*)(HKL, LPWSTR, LPVOID, LPVOID))GetProcAddress((HMODULE)hLibModule, (LPCSTR)5);
                        pfnDriverNT4 = (BOOL(*)(LPWSTR))GetProcAddress((HMODULE)hLibModule, (LPCSTR)3);

                        if (pfnDriver != NULL ||
                            pfnDriverNT4 != NULL ) {
                            DCWCHAR wBuffer[MAX_PATH];
                            /*
                             * Call the entry.
                             * a. NT5 / Hydra (oridinal=4)
                             * b. NT4 compatible (3)
                             */
                            if ((pfnDriver && pfnDriver((HKL)MAKELANGID(LANG_JAPANESE,SUBLANG_DEFAULT),
                                                        wBuffer,NULL,NULL)) ||
                                (pfnDriverNT4 && pfnDriverNT4(wBuffer)))
                            {
#ifndef UNICODE
                                Buffer[0] = _T('\0');
                                wcstombs(Buffer, wBuffer, sizeof(Buffer));
                                hr = StringCchCopy(lpszRealDriverName,
                                                  cchDriverName,
                                                  wBuffer);
#else
                                hr = StringCchCopy(lpszRealDriverName,
                                                  cchDriverName,
                                                  wBuffer);
#endif
                                if (SUCCEEDED(hr)) {
                                    fRet = TRUE;
                                }
                                else {
                                    TRC_ERR((TB,
                                     _T("Failed to copy real driver name: 0x%x"),hr));
                                }
                            }
                        }
                        FreeLibrary((HMODULE)hLibModule);
                    }
                }
            }
            RegCloseKey(hKey);
        }
    }

    DC_END_FN();
    return fRet;
}
#endif // !OS_WINCE


/****************************************************************************/
/* Name:      UT_IsNew106Layout                                             */
/*                                                                          */
/* Purpose:   Is client configured with an new 106 keyboard layout ?        */
/*                                                                          */
/* Returns:   TRUE if new 106 keyboard is attached.                         */
/****************************************************************************/
DCBOOL DCINTERNAL CUT::UT_IsNew106Layout(DCVOID)
{
#if !defined(OS_WINCE)
    if (GetKeyboardType(0) == 7 &&                     /* 7 is a Japanese */
        GetKeyboardType(1) == 2 &&                     /* 2 is a 106 keyboard */
        GetKeyboardType(2) == 12)                      /* Number of function key is 12 */
    {
        DCBOOL  fRet = FALSE;
        HKEY    hKey = NULL;
        DWORD   DataType = REG_SZ;
        DCTCHAR SubKey[MAX_PATH];
        DCTCHAR Buffer[MAX_PATH];
        DWORD   DataSize;

        if (UT_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_95)
        {
            /***************************************************************************\
             * Get value of new 106 from the registry
             * PATH:"HKCU\Control Panel\Keyboard"
             * VALUE:"New106Keyboard" (REG_SZ)
             * DATA: "Yes" or "No"
            \***************************************************************************/
            if (RegOpenKeyEx(HKEY_CURRENT_USER,
                             _T("Control Panel\\Keyboard"),
                             0,                          /* reserved                 */
                             KEY_READ,
                             &hKey) == ERROR_SUCCESS)
            {
                DataSize = sizeof(Buffer);
                if (RegQueryValueEx(hKey,
                                    _T("New106Keyboard"),
                                    0,                   /* reserved                 */
                                    &DataType,
                                    (LPBYTE)Buffer,
                                    &DataSize) == ERROR_SUCCESS)
                {
                    if (_tcsicmp(Buffer, _T("Yes")) == 0)
                    {
                        fRet = TRUE;
                    }
                }

                RegCloseKey(hKey);
            }
        }
        else if (UT_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_NT)
        {
            if (UT_GetRealDriverNameNT(Buffer, SIZE_TCHARS(Buffer)))
            {
                if (_tcsicmp(Buffer, _T("kbd106n.dll")) == 0)
                {
                    fRet = TRUE;
                }
            }
        }
        return fRet;
    }
    else
    {
        return FALSE;
    }
#else // !defined(OS_WINCE)
    return FALSE;
#endif // !defined(OS_WINCE)
}

/****************************************************************************/
/* Name:      UT_IsFujitsuLayout                                            */
/*                                                                          */
/* Purpose:   Is client configured with Fujitsu keyboard layout ?           */
/*                                                                          */
/* Returns:   TRUE if Fujitsu keyboard is attached.                         */
/****************************************************************************/
DCBOOL DCINTERNAL CUT::UT_IsFujitsuLayout(DCVOID)
{
#if !defined(OS_WINCE)
    if (GetKeyboardType(0) == 7 &&                     /* 7 is a Japanese */
        GetKeyboardType(1) == 2 &&                     /* 2 is a 106 keyboard */
        GetKeyboardType(2) == 12)                      /* Number of function key is 12 */
    {
        DCBOOL  fRet = FALSE;
        HKEY    hKey = NULL;
        DWORD   DataType = REG_SZ;
        DCTCHAR SubKey[MAX_PATH];
        DCTCHAR Buffer[MAX_PATH];
        DWORD   DataSize;

        if (UT_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_95)
        {
            /***************************************************************************\
             * Windows 95/98 doesn't support
            \***************************************************************************/
        }
        else if (UT_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_NT)
        {
            if (UT_GetRealDriverNameNT(Buffer, SIZE_TCHARS(Buffer)))
            {
                if (_tcsicmp(Buffer, _T("f3ahvoas.dll")) == 0)
                {
                    fRet = TRUE;

                    if (_UT.F3AHVOasysDll.hInst == NULL) {
                        _UT.F3AHVOasysDll.hInst = LoadExternalDll(
                            _T("f3ahvoas.dll"),
                            _UT.F3AHVOasysDll.func.rgFunctionPort,
                            sizeof(_UT.F3AHVOasysDll.func.rgFunctionPort)/sizeof(_UT.F3AHVOasysDll.func.rgFunctionPort[0]));
                    }
                }
            }
        }
        return fRet;
    }
    else
    {
        return FALSE;
    }
#else // !defined(OS_WINCE)
    return FALSE;
#endif // !defined(OS_WINCE)
}


/****************************************************************************/
/* Name:      UT_IsKorean101LayoutForWin9x                                  */
/*                                                                          */
/* Purpose:   Is Win9x client configured with a Korean 101A/B/C keyboard ?  */
/*                                                                          */
/* Returns:   TRUE if Korean 101A/B/C keyboard is attached.                 */
/****************************************************************************/
DCBOOL DCINTERNAL CUT::UT_IsKorean101LayoutForWin9x(DCVOID)
{
#if !defined(OS_WINCE)
    if (UT_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_95)
    {
        int subtype = GetKeyboardType(1);

        if (GetKeyboardType(0) == 8 &&                     /* 8 is a Korean */
            (subtype == 3 ||                               /* 3 is a 101A keyboard */
             subtype == 4 ||                               /* 4 is a 101B keyboard */
             subtype == 5   )          )                   /* 5 is a 101C keyboard */
        {
            return TRUE;
        }
    }
    return FALSE;
#else // !defined(OS_WINCE)
    return FALSE;
#endif // !defined(OS_WINCE)
}


/****************************************************************************/
/* Name:      UT_IsKorean101LayoutForNT351                                  */
/*                                                                          */
/* Purpose:   Is NT 3.51 client configured with a Korean 101A/B keyboard ?  */
/*                                                                          */
/* Returns:   TRUE if Korean 101A/B keyboard is attached.                   */
/****************************************************************************/
DCBOOL DCINTERNAL CUT::UT_IsKorean101LayoutForNT351(DCVOID)
{
#if !defined(OS_WINCE)
    if (UT_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_NT)
    {
        int subtype = GetKeyboardType(1);

        if (GetKeyboardType(0) == 8 &&                     /* 8 is a Korean */
            (subtype == 3 ||                               /* 3 is a 101A keyboard */
             subtype == 4   )          )                   /* 4 is a 101B keyboard */
        {
            OSVERSIONINFO    osVersionInfo;
            BOOL             bRc;

            osVersionInfo.dwOSVersionInfoSize = sizeof(osVersionInfo);
            bRc = GetVersionEx(&osVersionInfo);
            if (osVersionInfo.dwMajorVersion == 3 &&
                osVersionInfo.dwMinorVersion == 51  )
            {
                return TRUE;
            }
        }
    }
    return FALSE;
#else // !defined(OS_WINCE)
    return FALSE;
#endif // !defined(OS_WINCE)
}

#ifdef OS_WINCE
TCHAR MakeValidChar(BYTE data)
/*++

Routine Description:

    MakeValidChar.

Arguments:

    data - BYTE data which we need to convert to a printable character 
           which is a valid character that can be used in a computer name.

Return Value:

    Returns the character

More Info:
    
    A valid character that can be used in a computer name is from the range 0x30 to 0x39
    and again from 0x40 to 0x5A, and  from 0x61 to 0x7A. (See the ascii table for these ranges).
    To be precise, it includes the numbers 0 to 9, characters 'A' to 'Z'and characters 'a' to 'z'

 --*/
{
    BYTE temp = (BYTE)(data & (BYTE)0x7F);

    if ((temp >= 0x30 && temp <= 0x39) ||
        (temp >= 0x40 && temp <= 0x5A) ||
        (temp >= 0x61 && temp <= 0x7A)) {
        return (TCHAR)temp;
    }
    else {
        //
        // generate a random number in the above range, and return it
        //
        // The number of valid combinations is (0x30 to 0x39) + (0x40 to 0x5A) + (0x61 to 0x7A)
        // That is 10 + 27 + 26 = 63
        DWORD dw = rand() % 63; 
        if (dw < 10)
            return (TCHAR)(0x30 + dw);
        else
        if (dw < 37)
            return (TCHAR)(dw - 10 + 0x40);
        else
            return (TCHAR)(dw - 37 + 0x61);
    }
}

DCBOOL UT_GetWBTComputerName(PDCTCHAR szBuff, DCUINT32 len)
/*++

Routine Description:

    UT_GetWBTComputerName.

Arguments:

    szBuff - pointer to a buffer where the computer name is returned.

    len - length of the above buffer.

Return Value:

    TRUE - If a computer name which is non-trivial is found or generated.
    FALSE - Otherwise.

 --*/
{
    CHAR achHostName[MAX_PATH+1];
    BOOL fGetHostNameSuccess = FALSE;
    HWID hwid;

    HKEY hKey = NULL;
    DWORD dwBufLen, dwValueType;
    DWORD dwResult = 0;

    BOOL fSuccess = FALSE;

    DC_BEGIN_FN("UT_GetWBTComputerName");

    // get the host name of the device
    if (0 == gethostname( achHostName, sizeof(achHostName) )) {

        fGetHostNameSuccess = TRUE;

        // Check for bad hardcoded values
        if ((0 == strcmp(achHostName,BAD_HARDCODED_NAME1))
            || (0 == strcmp(achHostName,BAD_HARDCODED_NAME2))
            || (len < ((strlen(achHostName) + 1)))) {
            goto use_registry;
        }
        else {
            // gethostname success
            goto use_gethostname;
        }
    }
    
use_registry:

    //
    // Try if we have previously stored a computername in the registry
    //
    dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        REG_WBT_RDP_COMPUTER_NAME_KEY,
                        0,
                        KEY_READ,
                        &hKey );

    if (dwResult != ERROR_SUCCESS) {
        goto use_uuid;
    }

    dwBufLen = len * sizeof (TCHAR);
    dwResult = RegQueryValueEx( hKey,
                    REG_WBT_RDP_COMPUTER_NAME_VALUE,
                    0,
                    &dwValueType,
                    (LPBYTE)szBuff,
                    &dwBufLen );

    RegCloseKey(hKey);
    hKey = NULL;

    if (dwResult == ERROR_SUCCESS &&
        szBuff[0] != _T('\0')) {
        fSuccess = TRUE;
        goto Cleanup;
    }

use_uuid:
    
    if (len >= HWID_COMPUTER_NAME_STR_LEN) {

        // Use UUID instead
        if (LICENSE_STATUS_OK == GenerateClientHWID(&hwid)) {

            DWORD dwDisposition = 0;

            DWORD dw1 = (hwid.dwPlatformID ^ hwid.Data4);
            DWORD dw2 = (hwid.Data4 ^ hwid.Data1);
            DWORD dw3 = (hwid.Data1 ^ hwid.Data2);
            DWORD dw4 = (hwid.Data2 ^ hwid.Data3);

            srand((UINT)GetTickCount());

            //
            // The generated string will be of the form {abcdefghijklm}
            //
            szBuff[0] = _T('{');

            szBuff[1] = MakeValidChar((BYTE)(dw1 & 0x000000FF));
            szBuff[2] = MakeValidChar((BYTE)((dw1 & 0x0000FF00) >> 8));
            szBuff[3] = MakeValidChar((BYTE)((dw1 & 0x00FF0000) >> 16));
            szBuff[4] = MakeValidChar((BYTE)((dw1 & 0xFF000000) >> 24));
            
            szBuff[5] = MakeValidChar((BYTE)(dw2 & 0x000000FF));
            szBuff[6] = MakeValidChar((BYTE)((dw2 & 0x0000FF00) >> 8));
            szBuff[7] = MakeValidChar((BYTE)((dw2 & 0x00FF0000) >> 16));
            szBuff[8] = MakeValidChar((BYTE)((dw2 & 0xFF000000) >> 24));
            
            szBuff[9] = MakeValidChar((BYTE)(dw3 & 0x000000FF));
            szBuff[10] = MakeValidChar((BYTE)((dw3 & 0x0000FF00) >> 8));
            szBuff[11] = MakeValidChar((BYTE)((dw3 & 0x00FF0000) >> 16));
            szBuff[12] = MakeValidChar((BYTE)((dw3 & 0xFF000000) >> 24));

            szBuff[13] = MakeValidChar((BYTE)(dw4 & 0x000000FF));
            
            szBuff[14] = _T('}');
            szBuff[15] = _T('\0');

            //
            // Write the string to the registry.
            //
            dwResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                              REG_WBT_RDP_COMPUTER_NAME_KEY,
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKey,
                              &dwDisposition );

            if (dwResult == ERROR_SUCCESS) {
                RegSetValueEx(hKey,
                    REG_WBT_RDP_COMPUTER_NAME_VALUE,
                    0,
                    REG_SZ,
                    (LPBYTE)szBuff,
                    (_tcslen(szBuff) + 1) * sizeof(TCHAR));

                RegCloseKey(hKey);
            }
            fSuccess = TRUE;
            goto Cleanup;
        }
    }

use_gethostname:
    
    if (fGetHostNameSuccess &&
       (len >= ((strlen(achHostName) + 1)))) {
        mbstowcs(szBuff, achHostName, (strlen(achHostName) + 1));
        fSuccess = TRUE;
    }

Cleanup:
    
    if (!fSuccess) {
        if (len > 0) {
            szBuff[0] = _T('\0');
        }
    }

    DC_END_FN();
    return (fSuccess);
}
#endif



/****************************************************************************/
/* Name:      UT_GetComputerName                                            */
/*                                                                          */
/* Purpose:   Retrieves the computer name.                                  */
/*                                                                          */
/* Returns:   Success                                                       */
/*                                                                          */
/* Params:    OUT szBuff - Computer name                                    */
/*            IN  len - length of buffer                                    */
/****************************************************************************/
DCBOOL DCAPI CUT::UT_GetComputerName(PDCTCHAR szBuff, DCUINT32 len)
{
    DCBOOL    rc;
    DC_BEGIN_FN("UT_GetComputerName");

#ifdef OS_WINCE
    rc = UT_GetWBTComputerName(szBuff, len);
#else // !OS_WINCE
    rc = GetComputerName(szBuff, &len);
#endif // OS_WINCE

    DC_END_FN();
    return(rc);
}

#ifdef OS_WINCE
#define DIRECTORY_LENGTH 256
#endif

/****************************************************************************/
/* Name:      UT_GetClientDirW                                              */
/*                                                                          */
/* Purpose:   Retrieves the client directory                                */
/****************************************************************************/
BOOL DCAPI CUT::UT_GetClientDirW(PDCUINT8 szBuff)
{
   BOOL rc = FALSE;
   UINT dirlength;
   TCHAR clientDir[DIRECTORY_LENGTH];
 
   DC_BEGIN_FN("UT_GetClientDirW");

   // initialize client dir length
   *((PDCUINT16_UA)szBuff) = 0;
   memset(clientDir, 0, sizeof(clientDir));

   dirlength = GetModuleFileName(UT_GetInstanceHandle(),
           clientDir, DIRECTORY_LENGTH) + 1;

   if (dirlength > 1) {
       // client dir length
       *((PDCUINT16_UA)szBuff) = (USHORT)(dirlength * 2);
       szBuff += sizeof(DCUINT16);

       // client dir name
#ifdef UNICODE
       memcpy(szBuff, clientDir, dirlength * 2);
#else // UNICODE
       {
       USHORT pstrW[DIRECTORY_LENGTH];
       
#ifdef OS_WIN32
       ULONG ulRetVal;

       ulRetVal = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
               clientDir, -1, pstrW, DIRECTORY_LENGTH);
       pstrW[ulRetVal] = 0;

       memcpy(szBuff, pstrW, (ulRetVal + 1) * 2);
#else // !OS_WIN32
       mbstowcs(pstrW, clientDir, dirlength);
       memcpy(szBuff, pstrW, dirlength * 2);
#endif // OS_WIN32
       }
#endif // UNICODE

       rc = TRUE;
   }

   DC_END_FN();
   return rc;
}

/***************************************************************************/
// UT_ValidateProductSuite and UT_IsTerminalServices determine 
// if the platform is terminal service enabled.
// Note that the UT_ValidateProductSuite() and UT_IsTerminalServices()
// APIs use ANSI versions of functions in order to maintain
// compatibility with Win9X platforms.
/***************************************************************************/
#ifdef OS_WINNT
BOOL DCAPI CUT::UT_ValidateProductSuite(LPSTR SuiteName)
{
    BOOL rVal = FALSE;
    LONG Rslt;
    HKEY hKey = NULL;
    DWORD Type = 0;
    DWORD Size = 0;
    LPSTR ProductSuite = NULL;
    LPSTR p;

    Rslt = RegOpenKeyA(
        HKEY_LOCAL_MACHINE,
        "System\\CurrentControlSet\\Control\\ProductOptions",
        &hKey
        );
    if (Rslt != ERROR_SUCCESS)
        goto exit;

    Rslt = RegQueryValueExA( hKey, "ProductSuite", NULL, &Type, NULL, &Size );
    if (Rslt != ERROR_SUCCESS || !Size)
        goto exit;

    ProductSuite = (LPSTR) LocalAlloc( LPTR, Size );
    if (!ProductSuite)
        goto exit;

    Rslt = RegQueryValueExA( hKey, "ProductSuite", NULL, &Type,
        (LPBYTE) ProductSuite, &Size );
     if (Rslt != ERROR_SUCCESS || Type != REG_MULTI_SZ)
        goto exit;

    p = ProductSuite;
    while (*p) {
        if (lstrcmpA( p, SuiteName ) == 0) {
            rVal = TRUE;
            break;
        }
        p += (lstrlenA( p ) + 1);
    }

exit:
    if (ProductSuite)
        LocalFree( ProductSuite );

    if (hKey)
        RegCloseKey( hKey );

    return rVal;
}


BOOL DCAPI CUT::UT_IsTerminalServicesEnabled(VOID)
{
    BOOL  bResult = FALSE;
    DWORD dwVersion;

    dwVersion = GetVersion();
    if (!(dwVersion & 0x80000000)) {
        if (LOBYTE(LOWORD(dwVersion)) > 4) {

            // In NT5 we need to use the Product Suite APIs
            // Don't static link because it won't load on non-NT5 systems

            HMODULE hmodK32;
            HMODULE hmodNTDLL;

            DWORDLONG dwlConditionMask = 0;

            typedef BOOL (FNVerifyVersionInfoA)(POSVERSIONINFOEXA, DWORD, DWORDLONG);
            FNVerifyVersionInfoA *pfnVerifyVersionInfoA;

            typedef ULONGLONG (FNVerSetConditionMask)(ULONGLONG, ULONG, UCHAR);
            FNVerSetConditionMask *pfnVerSetConditionMask;

            hmodNTDLL = GetModuleHandleA( "NTDLL.DLL" );
            
            if (hmodNTDLL != NULL) {
                pfnVerSetConditionMask = (FNVerSetConditionMask *)GetProcAddress( hmodNTDLL, "VerSetConditionMask");

                if (pfnVerSetConditionMask != NULL) {
                    dwlConditionMask = (*pfnVerSetConditionMask) (dwlConditionMask, VER_SUITENAME, VER_AND);

                    hmodK32 = GetModuleHandleA( "KERNEL32.DLL" );
                   
                    if (hmodK32 != NULL) {

                        pfnVerifyVersionInfoA = (FNVerifyVersionInfoA *)GetProcAddress( hmodK32, "VerifyVersionInfoA");

                        if (pfnVerifyVersionInfoA != NULL) {
                    
                            OSVERSIONINFOEXA osVersionInfo;

                            ZeroMemory(&osVersionInfo, sizeof(osVersionInfo));
                            osVersionInfo.dwOSVersionInfoSize = sizeof(osVersionInfo);
                            osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL;
                    
                    
                            //VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );
                            bResult = (*pfnVerifyVersionInfoA)(
                                      &osVersionInfo,
                                      VER_SUITENAME,
                                      dwlConditionMask);
                        }
                    }
                }
            }
        } 
        else {
           bResult = UT_ValidateProductSuite( "Terminal Server" );
        }
    }

    return bResult;
}
#endif


/********************************************************************/
/*                                                                  */
/* Load External Dll                                                */
/*                                                                  */
/********************************************************************/
HINSTANCE
CUT::LoadExternalDll(
    LPCTSTR       pszLibraryName,
    PFUNCTIONPORT rgFunction,
    DWORD         dwItem
    )
{
    DWORD     i;
    HINSTANCE hInst;
    BOOL      fGetModule = FALSE;

#ifdef OS_WIN32
    hInst = GetModuleHandle(pszLibraryName);
    if (hInst != NULL) {
        fGetModule = TRUE;
    }
    else {
        hInst = LoadLibrary(pszLibraryName);
    }
#else
    hInst = LoadLibrary(pszLibraryName);
    if (hInst <= HINSTANCE_ERROR) {
        hInst = NULL;
    }
#endif

    if (hInst) {
        for (i=0; i < dwItem; i++) {
            rgFunction[i].lpfnFunction = GetProcAddress(hInst, rgFunction[i].pszFunctionName);
            if (rgFunction[i].lpfnFunction == NULL) {
                if (!fGetModule) {
                    FreeLibrary(hInst);
                }
                hInst = NULL;
                break;
            }
        }
    }

    if (hInst == NULL) {
        for (i=0; i < dwItem; i++) {
            rgFunction[i].lpfnFunction = NULL;
        }
    }

    return hInst;
}

/********************************************************************/
/*                                                                  */
/* External Dll Initialize                                          */
/*                                                                  */
/********************************************************************/
VOID
CUT::InitExternalDll(
    VOID
    )
{
#if defined(OS_WIN32)
    _UT.Imm32Dll.hInst = LoadExternalDll(
#if defined (OS_WINCE)
        _T("COREDLL.DLL"),
#else
        _T("IMM32.DLL"),
#endif // OS_WINCE        
        _UT.Imm32Dll.func.rgFunctionPort,
        sizeof(_UT.Imm32Dll.func.rgFunctionPort)/sizeof(_UT.Imm32Dll.func.rgFunctionPort[0]));
#endif // OS_WIN32

#if !defined(OS_WINCE)
    _UT.WinnlsDll.hInst = LoadExternalDll(
#ifdef OS_WIN32
        _T("USER32.DLL"),
#else
        _T("WINNLS.DLL"),
#endif
        _UT.WinnlsDll.func.rgFunctionPort,
        sizeof(_UT.WinnlsDll.func.rgFunctionPort)/sizeof(_UT.WinnlsDll.func.rgFunctionPort[0]));
#endif  // !defined(OS_WINCE)

}

/**PROC+*********************************************************************/
/* Name:      StringtoBinary                                                */
/*                                                                          */
/* Purpose:   Converts a given string to equivalent binary                  */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise                           */
/*                                                                          */
/* Params:    IN      cbInBuffer - Size of the string buffer.               */
/*            IN      pbInBuffer - String buffer.                           */
/*            OUT     pszOutBuffer - Binary string buffer.                  */
/*            IN/OUT  cchOutBuffer - Size of the binary string buffer.      */
/**PROC-*********************************************************************/

BOOL CUT::StringtoBinary(size_t cbInBuffer, PBYTE pbInBuffer,
                         TCHAR *pszOutBuffer, DWORD *pcchOutBuffer)
{
    UINT i = 0, j = 0;
    TCHAR digits[] = _T("0123456789ABCDEF");
    BOOL fRet = FALSE;

    DC_BEGIN_FN("StringtoBinary");

    //
    // Validate pbInBuffer and pcchOutBuffer.
    //

    if (pbInBuffer == NULL || pcchOutBuffer == NULL) {
        fRet = FALSE;
        DC_QUIT;
    }

    //
    // Return how much space is needed for bytes converted to textual
    // binary if pszOutBuffer is NULL.
    //
    // Example:
    //
    // pbInBuffer = "ABCD" and cbInBuffer = 4
    // then
    // pszOutBuffer = "4142434400\0" and *pcchOutBuffer = 11
    //
    // Essentially, we need two characters for every byte and an additional
    // three characters for two trailing '0's and a NULL. I'm not sure why the
    // trailing zeros are there. They were produced by this code before I
    // fixed it.
    //
    
    if(pszOutBuffer == NULL) {
        *pcchOutBuffer = 2 * cbInBuffer + 3;
        fRet = TRUE;
        DC_QUIT;
    }

    //
    // j loops through the input buffer and i loops through the output
    // buffer. The check on j keeps us inside the input buffer. The
    // check on i makes sure that we can always write three characters:
    // two for the high and low nibble, and the last for a NULL which
    // will happen outside the loop.
    //

    while (j < cbInBuffer && i <= *pcchOutBuffer - 3) {
        //
        // Convert the left-most nibble in pbInBuffer[j] into 
        // a character and place it in pszOutBuffer[i].
        //
        
        pszOutBuffer[i++] = digits[(pbInBuffer[j] >> 4) & 0x0F];

        //
        // Convert the right-most nibble in pbInBuffer[j] into 
        // a character and place it in pszOutBuffer[i].
        //

        pszOutBuffer[i++] = digits[pbInBuffer[j] & 0x0F];

        j++;
    }
    
    if (i <= *pcchOutBuffer - 3) {
        //
        // We had enough space for the transformation, so finish off
        // by writing the two trailing zeros and a NULL. The count
        // returned in pcchOutBuffer includes the NULL.
        //

        pszOutBuffer[i] = _T('0');
        pszOutBuffer[i + 1] = _T('0');
        pszOutBuffer[i + 2] = NULL;
        
        *pcchOutBuffer = (DWORD) (i + 3);
        fRet = TRUE;
    } else {
        //
        // Oops! There is not enough space to write the trailing zeros.
        // We may have written the rest of the string successfully, but
        // an error is still returned. The count returned in pcchOutBuffer 
        // includes the NULL.
        //

        pszOutBuffer[i] = NULL;
    
        *pcchOutBuffer = (DWORD) (i + 1);
        fRet = FALSE;
    }


DC_EXIT_POINT:
    
    DC_END_FN();

    return fRet;
}


/**PROC+*********************************************************************/
/* Name:      BinarytoString                                                */
/*                                                                          */
/* Purpose:   Converts a given binary to equivalent string                  */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise                           */
/*                                                                          */
/* Params:    IN      cchInBuffer - Size of the binary string buffer.       */
/*            IN      pszInBuffer - Binary string buffer.                   */
/*            OUT     pbOutBuffer - String buffer.                          */
/*            IN/OUT  pcbOutBuffer - Size of the string buffer.             */
/**PROC-*********************************************************************/

BOOL CUT::BinarytoString(size_t cchInBuffer, TCHAR *pszInBuffer,
                         PBYTE pbOutBuffer, DWORD *pcbOutBuffer)
{
    UINT i = 0, j = 0;
    TCHAR c = 0;
    BOOL fRet = FALSE;

    DC_BEGIN_FN("BinarytoString");
    
    //
    // Validate pszInBuffer and pcbOutBuffer.
    //

    if (pszInBuffer == NULL || pcbOutBuffer == NULL) {
        fRet = FALSE;
        DC_QUIT;
    }

    
    //
    // Check that the input buffer length parameter is correct.
    //

    if (_tcslen(pszInBuffer) != cchInBuffer) {
        fRet = FALSE;
        DC_QUIT;
    }

    //
    // If we are trying to convert an empty binary string, or a
    // string consisting of a single nibble, write nothing and 
    // return FALSE. We don't even NULL terminate the output, 
    // as this would imply that the binary string contained "00".
    //

    if (cchInBuffer < 2) {
        fRet = FALSE;
        DC_QUIT;
    }

    //
    // Return how much space is needed for bytes converted from our
    // textual binary if pbOutBuffer is NULL. 
    //
    // Examples:
    //
    // 1. pszInBuffer = "4142434400\0" and cchInBuffer = 10
    //    then
    //    pszOutBuffer = "ABCD\0" and *pcbOutBuffer = 5
    //
    // 2. pszInBuffer = "414243\0" and cchInBuffer = 6
    //    then
    //    pszOutBuffer = "ABC\0" and *pcbOutBuffer = 4
    //
    // Note that from the above we can see that there are
    // two cases to handle. The textual binary may have two trailing 
    // zero characters, or if it was truncated during conversion, 
    // these will not be present.    
    //

    if(pbOutBuffer == NULL) {
        if (pszInBuffer[cchInBuffer - 2] == _T('0') 
              && pszInBuffer[cchInBuffer - 1] == _T('0')) {

            *pcbOutBuffer = cchInBuffer / 2;
        } else {
            *pcbOutBuffer = cchInBuffer / 2 + 1;
        }
        fRet = TRUE;

        
        DC_QUIT;
    }

    //
    // i loops through the output buffer and j loops through the
    // input buffer. The check on i makes sure that we do not overshoot 
    // the size of the output buffer. We must leave space for a NULL at 
    // the end of this buffer. The check on j makes sure that there are 
    // always two characters to read from the input string, a high nibble 
    // and a low nibble.
    //

    while (i < *pcbOutBuffer - 1 && j <= cchInBuffer - 2) {
        //
        // Obtain the left-most nibble of the resultant byte. Do this
        // by determining the ASCII value in pszInBuffer[j] and then
        // checking if it is above or below 'A'. If it is below 'A', we 
        // subtract '0' to give a number in the range 0x0 - 0x9, else 
        // we subtract '7' to give a number in the range 0xA - 0xF.
        //
        // Examples:
        //
        // 'A' - '7' = 0x41 - 0x37 = 0x0A
        // '4' - '0' = 0x34 - 0x30 = 0x04
        //
        // Once we have the value, shift left to put the result in the
        // left-most nibble of pbOutBuffer[i]. 
        //

        c = pszInBuffer[j++];
        pbOutBuffer[i] = (c >= _T('A')) ? c - _T('7') : c - _T('0');
        pbOutBuffer[i] <<= 4;

        //
        // Do the same as above, but this time the result goes in the
        // right-most nibble of pszInBuffer[i].
        //
        
        c = pszInBuffer[j++];
        pbOutBuffer[i] |= (c >= _T('A')) ? c - _T('7') : c - _T('0');
        
        i++;
    }


    //
    // NULL terminate and return the size including the NULL.
    //

    pbOutBuffer[i] = NULL;
    *pcbOutBuffer = (DWORD) (i + 1);

    fRet = TRUE;

DC_EXIT_POINT:
    
    DC_END_FN();

    return fRet;
}


//
// Validates the server name.
// format - server[:port]
//
// Params: szServerName - name of server to validate
//         fAllowPortSuffix - allow optional :port suffix
//
BOOL CUT::ValidateServerName(LPCTSTR szServerName, BOOL fAllowPortSuffix)
{
    DC_BEGIN_FN("ValidateServerName");
    //server name should not be empty
    if(!szServerName || !*szServerName)
    {
        return FALSE;
    }

    //Check for ;  "  <  >  *  +  =  |  ?  space and tab in the server name field.
    //Also validate for the :port sequence (it must appear at the end and port must
    //be numeric
    while(*szServerName)
    {
        if( (*szServerName == _T(';')) ||
            (*szServerName == _T('"')) || (*szServerName == _T('<')) ||
            (*szServerName == _T('>')) || (*szServerName == _T('*')) ||
            (*szServerName == _T('+')) || (*szServerName == _T('=')) ||
            (*szServerName == _T('|')) || (*szServerName == _T('?')) ||
            (*szServerName == _T(',')) || (*szServerName == _T(' ')) ||
            (*szServerName == _T('\t')))

        {
            return FALSE;
        }
        else if((*szServerName == _T(':')))
        {
            if(fAllowPortSuffix)
            {
                //Reached optional [:port] suffix
                szServerName++;
                //Rest of string can only contain numerics otherwise it's invalid
                //also port number must be less thant 65535
                LPCTSTR szStartNum = szServerName;
                if(!*szStartNum)
                {
                    return FALSE; //0 length number
                }
                while(*szServerName)
                {
                    if(!isdigit(*szServerName++))
                    {
                        return FALSE;
                    }
                }
                if((szServerName - szStartNum) > 5) //5 digit max
                {
                    return FALSE;
                }
                int port = _ttoi(szStartNum);
                if (port < 0 || port > 65535) {
                    return FALSE;
                }
                return TRUE; // reached end case
            }
            else
            {
                return FALSE;
            }
        }
        szServerName++;
    }

    return TRUE;

    DC_END_FN();
}

//
// Parse port number from server name
// if the server is specified as server:port
// if no port number could be found then return -1
//
// Params:
//  szServer - server name in form server[:port]
// Returns:
//  port number or -1 if none found
//
INT CUT::GetPortNumberFromServerName(LPTSTR szServer)
{
    DC_BEGIN_FN("GetPortNumberFromServerName");

    if(szServer && ValidateServerName(szServer, TRUE))
    {
        //Walk to the :
        while(*szServer && *szServer++ != _T(':'));
        if(*szServer)
        {
            //Because server name has been validate
            //and it has the port delimeter ':' it is
            //guaranteed to have a valid (syntax wise)
            //port number.
            return _ttoi(szServer);
        }
        else
        {
            //no port specified
            return -1;
        }
    }
    else
    {
        return -1;
    }

    DC_END_FN();
}

//
// GetServerNameFromFullAddress
// Splits the server name from a full address of the form
//  server:port
//
// Params:
//  IN - szFullName (full server name e.g. myserver:3389
//  IN/OUT - buffer for result string 
//  IN - length of output buffer
//
VOID CUT::GetServerNameFromFullAddress(
                    LPCTSTR szFullName,
                    LPTSTR szServerOnly,
                    ULONG len
                    )
{
    LPTSTR sz;
    DC_BEGIN_FN("GetServerNameFromFullAddress");

    _tcsncpy(szServerOnly, szFullName, len - 1);
    szServerOnly[len-1] = 0;
    sz = szServerOnly;
    while(*sz)
    {
        if (*sz == _T(':'))
        {
            *sz = NULL;
            break;
        }
        sz++;
    }

    DC_END_FN();
}

//
// Return a canonical server name from a longer connect string
// i.e. strip out all 'argument' portions from a long connect string
// and keep only the 'connect target' portion
//
// E.g a server name could be
//
// myserver:3398 /console
//
// return just myserver:3389
//
// Params:
//      IN  szFullConnectString - the full connection string
//      OUT szCanonicalServerName - the server name
//      IN  ccLenOut - length of output buffer in TCHARS
//      OUT pszArgs - if arguments are found return a pointer to the
//                    start of the arg list.
//      NOTE: do NOT free pszArgs it's a pointer within the
//            the return string szCanonicalServerName.
//
// Returns:
//      VOID
//
//
HRESULT CUT::GetCanonicalServerNameFromConnectString(
                IN LPCTSTR szFullConnectString,
                OUT LPTSTR  szCanonicalServerName,
                ULONG cchLenOut
                )
{
    LPTSTR szDelim;
    HRESULT hr = E_FAIL;

    DC_BEGIN_FN("GetCanonicalServerNameFromConnectString");

    szDelim = _tcspbrk(szFullConnectString, _T(" \\"));

    if (szDelim == NULL) {
        hr = StringCchCopy(
            szCanonicalServerName, cchLenOut,
            szFullConnectString
            );
    }
    else {
        ULONG cchCopyLen = (szDelim - szFullConnectString);
        hr = StringCchCopyN(
            szCanonicalServerName, cchLenOut,
            szFullConnectString, cchCopyLen);
    }

    if (FAILED(hr)) {
        TRC_ERR((TB,_T("Copy to result string failed: 0x%x"),hr));
    }

    DC_END_FN();
    return hr;
}


#ifndef OS_WINCE
typedef HANDLE (WINAPI FN_SCARDACCESSSTARTEDEVENT)(VOID);
typedef FN_SCARDACCESSSTARTEDEVENT * PFN_SCARDACCESSSTARTEDEVENT ;

BOOL CUT::IsSCardReaderInstalled()
{
    HMODULE hDll = NULL;
    PFN_SCARDACCESSSTARTEDEVENT pSCardAccessStartedEvent ;
    HANDLE hCalaisStarted = NULL;
    BOOL fEnable =FALSE;

    DC_BEGIN_FN("IsSCardReaderInstalled");

    hDll = LoadLibrary( _T("WINSCARD.DLL"));
    if (hDll)
    {
        pSCardAccessStartedEvent = (PFN_SCARDACCESSSTARTEDEVENT)
            GetProcAddress( hDll,
                            "SCardAccessStartedEvent");

        if (pSCardAccessStartedEvent)
        {
            hCalaisStarted = pSCardAccessStartedEvent();
    
            if (hCalaisStarted)
            {
                 if  (WAIT_OBJECT_0 == WaitForSingleObject(hCalaisStarted, 0))
                 {
                    fEnable = TRUE;
                 }
            }
        }
        FreeLibrary(hDll);
    }

    TRC_NRM((TB,_T("Detected scard %d"),fEnable));

    DC_END_FN();

    return fEnable;
}

#else

#ifdef WINCE_SDKBUILD

BOOL CUT::IsSCardReaderInstalled()
{
	return FALSE;
}

#else

#include <winscard.h>
typedef LONG (WINAPI *PFN_SCARDESTABLISHCONTEXT)(DWORD, LPCVOID, LPCVOID, LPSCARDCONTEXT);

BOOL CUT::IsSCardReaderInstalled()
{
    HMODULE hDll = NULL;
    PFN_SCARDESTABLISHCONTEXT pSCardEstablishContext;
    BOOL fEnable =FALSE;

    DC_BEGIN_FN("IsSCardReaderInstalled");

    hDll = LoadLibrary( _T("WINSCARD.DLL"));
    if (hDll)
    {
        pSCardEstablishContext = (PFN_SCARDESTABLISHCONTEXT) GetProcAddress( hDll, L"SCardEstablishContext");
        FreeLibrary(hDll);
		fEnable = (pSCardEstablishContext != NULL);
    }

    TRC_NRM((TB,_T("Detected scard %d"),fEnable));

    DC_END_FN();

    return fEnable;
}
#endif //WINCE_SDKBUILD

#endif //OS_WINCE


#ifndef OS_WINCE
//
// Notify the shell of our fullscreen mode transitions
// to 'fix' all the badness associated with the shell
// taskbar rude app autohide issues
// 
// Params:
// [in] hwndMarkFullScreen - window to mark as fullscreen
// [in] fNowFullScreen - TRUE if the window is now fullscreen
// [in/out] ppTsbl - interface pointer to taskbar (gets set
//                   if fQueriedForTaskbar is false).
// [in/out] fQueriedForTaskbar - if TRUE does not query for taskbar
//                               interface
//
// Return:
// Success flag
//
// Environment: CAN ONLY BE CALLED between CoIninitalize() and
//              CoUninitialize()
//
BOOL CUT::NotifyShellOfFullScreen(HWND hwndMarkFullScreen,
                                  BOOL fNowFullScreen,
                                  ITaskbarList2** ppTsbl2,
                                  PBOOL pfQueriedForTaskbar)
{
    ITaskbarList* ptsbl = NULL;
    HRESULT hr = E_FAIL;
    DC_BEGIN_FN("NotifyShellOfFullScreen");

    if (!ppTsbl2)
    {
        TRC_ERR((TB,_T("ppTsbl2 is NULL")));
        return FALSE;
    }

    if (!pfQueriedForTaskbar)
    {
        TRC_ERR((TB,_T("pfQueriedForTaskbar is NULL")));
        return FALSE;
    }


    if (!*ppTsbl2)
    {
        //On demand create unless already failed
        //in which case bail now
        if (!*pfQueriedForTaskbar)
        {
            hr = CoCreateInstance( CLSID_TaskbarList, NULL,
                                   CLSCTX_INPROC_SERVER, IID_ITaskbarList,
                                   (void**) &ptsbl );
            if(SUCCEEDED(hr))
            {
                //
                // Note we cache the ITaskBarList2
                // it is freed in the destructor on CContainerWnd
                //
                hr = ptsbl->QueryInterface( __uuidof(ITaskbarList2),
                                            (void**) ppTsbl2 );
                ptsbl->Release();
                ptsbl = NULL;
            }
            *pfQueriedForTaskbar = TRUE;

            if(FAILED(hr))
            {
                TRC_ERR((TB,_T("Failed to get ITaskBarList: 0x%x"),hr));
                return FALSE;
            }
        }
        else
        {
            TRC_NRM((TB,_T("Bailing out of shell notify")));
            return FALSE;
        }
    }

    if (*ppTsbl2)
    {
        hr = (*ppTsbl2)->MarkFullscreenWindow( hwndMarkFullScreen,
                                               fNowFullScreen );
        if(FAILED(hr))
        {
            TRC_ERR((TB,_T("MarkFullScreenWindow failed: 0x%x"),hr));
            return FALSE;
        }
    }

    DC_END_FN();
    return TRUE;
}
#endif

//
// Dynamic thunk for ImmGetIMEFileName
//
//
UINT CUT::UT_ImmGetIMEFileName(IN HKL hkl, OUT LPTSTR szName, IN UINT uBufLen)
{
    UINT result = 0;
    DC_BEGIN_FN("UT_ImmGetIMEFileName");

#ifndef UNIWRAP
    //
    // Not using a unicode wrapper make direct calls to the
    // appropriate entry points
    // 
    #ifdef  UNICODE
    if (_UT.Imm32Dll.func._ImmGetIMEFileNameW)
    {
        result = _UT.Imm32Dll.func._ImmGetIMEFileNameW(hkl, szName, uBufLen);
    }
    #else
    if (_UT.Imm32Dll.func._ImmGetIMEFileNameA)
    {
        result = _UT.Imm32Dll.func._ImmGetIMEFileNameA(hkl, szName, uBufLen);
    }
    #endif
    else
    {
        result = 0;
        TRC_ERR((TB,_T("_ImmGetIMEFileName entry point not loaded")));
        DC_QUIT;
    }
#else //UNIWRAP
    //
    // Call needs to go thru a unicode wrapper
    // pass both the Wide and Ansi entry points to the wrapper
    //
    result = ImmGetIMEFileName_DynWrapW(hkl, szName, uBufLen,
                                        _UT.Imm32Dll.func._ImmGetIMEFileNameW,
                                        _UT.Imm32Dll.func._ImmGetIMEFileNameA);
#endif

DC_EXIT_POINT:
    DC_END_FN();
    return result;
}

#if ! defined (OS_WINCE)
//
// Dynamic thunk for IMPGetIME
//
//
BOOL CUT::UT_IMPGetIME( IN HWND hwnd, OUT LPIMEPRO pImePro)
{
    BOOL fRes = FALSE;
    DC_BEGIN_FN("UT_IMPGetIME");

#ifndef UNIWRAP
    //
    // Not using a unicode wrapper make direct calls to the
    // appropriate entry points
    // 
    #ifdef  UNICODE
    if (_UT.WinnlsDll.func._IMPGetIMEW)
    {
        fRes = _UT.WinnlsDll.func._IMPGetIMEW(hwnd, pImePro);
    }
    #else
    if (_UT.WinnlsDll.func._IMPGetIMEA)
    {
        fRes = _UT.WinnlsDll.func._IMPGetIMEA(hwnd, pImePro);
    }
    #endif
    else
    {
        fRes = FALSE;
        TRC_ERR((TB,_T("_IMPGetIMEA entry point not loaded")));
        DC_QUIT;
    }
#else //UNIWRAP
    //
    // Call needs to go thru a unicode wrapper
    // pass both the Wide and Ansi entry points to the wrapper
    //
    fRes = ImpGetIME_DynWrapW(hwnd, pImePro,
                              _UT.WinnlsDll.func._IMPGetIMEW,
                              _UT.WinnlsDll.func._IMPGetIMEA);
#endif


DC_EXIT_POINT:
    DC_END_FN();
    return fRes;
}

//
// Get and return the palette for the bitmap
//
// Params:
//  hDCSrc  - src DC to base palette on
//  hBitmap - bitmap to get palette from
//
// Returns:
//  Handle to palette - caller must delete
//
HPALETTE CUT::UT_GetPaletteForBitmap(HDC hDCSrc, HBITMAP hBitmap)
{
    HPALETTE hPal = NULL;
    HDC hDCMem = NULL;
    HBITMAP hbmSrcOld = NULL;
    INT nCol = 0;
    LPLOGPALETTE pLogPalette = NULL;
    RGBQUAD rgb[256];

    DC_BEGIN_FN("UT_GetPaletteForBitmap");

    hDCMem = CreateCompatibleDC(hDCSrc);

    if (hDCMem) {

        hbmSrcOld = (HBITMAP)SelectObject(hDCMem, hBitmap);
        nCol = GetDIBColorTable(hDCMem, 0, 256, rgb);
        if (256 == nCol) {
            pLogPalette = (LPLOGPALETTE)LocalAlloc(LPTR,
                            sizeof(LOGPALETTE)*(sizeof(PALETTEENTRY)*256));
            if (pLogPalette)
            {
                pLogPalette->palVersion = 0x0300;
                pLogPalette->palNumEntries = 256;

                for (INT i=0; i<256; i++)
                {
                    pLogPalette->palPalEntry[i].peRed =  rgb[i].rgbRed;
                    pLogPalette->palPalEntry[i].peGreen = rgb[i].rgbGreen;
                    pLogPalette->palPalEntry[i].peBlue = rgb[i].rgbBlue;
                    pLogPalette->palPalEntry[i].peFlags = 0;
                }

                hPal = CreatePalette(pLogPalette);
                LocalFree(pLogPalette);
                pLogPalette = NULL;
            }
        }
        else {
            TRC_ALT((TB,_T("Did not get 256 color table entires!")));
        }

        if (hbmSrcOld) {
            SelectObject(hDCMem, hbmSrcOld);
        }

        DeleteDC(hDCMem);
    }

    DC_END_FN();
    return hPal;
}
#endif //OS_WINCE

//
// Safer generic string property put function.
//
// Does length validation before writing the string so that
// in the failure case we don't leave partially written
// property strings (even though they would still be NULL terminated).
//
// Params:
//      szDestString    - string to write to
//      cchDestLen      - destination length in characters (TCHARS)
//      szSourceString  - the source string
//
// Returns:
//      HRESULT
//
HRESULT
CUT::StringPropPut(
            LPTSTR szDestString,
            UINT   cchDestLen,
            LPTSTR szSourceString
            )
{
    HRESULT hr = E_FAIL;
    DC_BEGIN_FN("StringPropPut");

    if (szDestString && szSourceString) {

        if (_tcslen(szSourceString) <= (cchDestLen - 1)) {
            hr = StringCchCopy(szDestString,
                               cchDestLen,
                               szSourceString);
        }
        else {
            hr = E_INVALIDARG;
        }
    }
    else {
        hr = E_INVALIDARG;
    }

    DC_END_FN();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\util\nutint.cpp ===
/****************************************************************************/
/* Module:    nutint.cpp                                                    */
/*                                                                          */
/* Purpose:   Utilities - Win32 version                                     */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1998                             */
/****************************************************************************/

#include <adcg.h>
#undef TRC_FILE
#define TRC_FILE    "nutint"
#define TRC_GROUP   TRC_GROUP_UTILITIES

extern "C" {
#include <atrcapi.h>

#ifndef OS_WINCE
#include <process.h>
#endif
}

#include "autil.h"

/****************************************************************************/
/* Name:      UTStartThread                                                 */
/*                                                                          */
/* Purpose:   Start a new thread                                            */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise                           */
/*                                                                          */
/* Params:    IN      entryFunction - pointer to thread entry point         */
/*            OUT     threadID      - thread ID                             */
/*                                                                          */
/* Operation: Call UTThreadEntry: new thread (Win32) / immediate (Win16)    */
/*                                                                          */
/****************************************************************************/
DCBOOL DCINTERNAL CUT::UTStartThread( UTTHREAD_PROC   entryFunction,
                                 PUT_THREAD_DATA pThreadData,
                                 PDCVOID        threadParam )
{
    HANDLE          hndArray[2];
    DCUINT32        rc = FALSE;
    DWORD           dwrc;
    DWORD           threadID;
    UT_THREAD_INFO  info;

    DC_BEGIN_FN("UTStartThread");

    info.pFunc = entryFunction;

    /************************************************************************/
    /* For Win32, create a thread - use an Event to signal when the thread  */
    /* has started OK.                                                      */
    /* Create event - initially non-signalled; manual control.              */
    /************************************************************************/
    hndArray[0] = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (hndArray[0] == 0)
    {
        TRC_SYSTEM_ERROR("CreateEvent");
        DC_QUIT;
    }
    TRC_NRM((TB, _T("event %p created - now create thread"), hndArray[0]));

    info.sync  = (ULONG_PTR)hndArray[0];
    info.threadParam = threadParam;

    /************************************************************************/
    /* Start a new thread to run the DC-Share core task.                    */
    /* Use C runtime (which calls CreateThread) to avoid memory leaks.      */
    /************************************************************************/
    hndArray[1] = (HANDLE)
#if i386
                _beginthreadex
#else
                CreateThread
#endif
                              (NULL,               /* security - default    */
                               0,                  /* stack size - default  */
#if i386
                               ((unsigned (__stdcall *)(void*))UTStaticThreadEntry),
#else
                               ((unsigned long (__stdcall *)(void*))UTStaticThreadEntry),
#endif
                               (PDCVOID)&info,     /* thread parameter      */
                               0,                  /* creation flags        */
#if i386
                               (unsigned *)&threadID     /* thread ID       */
#else
                               (unsigned long *)&threadID/* thread ID       */
#endif
			);

    if (hndArray[1] == 0)
    {
        /********************************************************************/
        /* Failed!                                                          */
        /********************************************************************/
        TRC_SYSTEM_ERROR("_beginthreadex");
        DC_QUIT;
    }
    TRC_NRM((TB, _T("thread %p created - now wait signal"), hndArray[1]));

    /************************************************************************/
    /* Wait for thread exit or event to be set.                             */
    /************************************************************************/
    dwrc = WaitForMultipleObjects(2, hndArray, FALSE, INFINITE);
    switch (dwrc)
    {
        case WAIT_OBJECT_0:
        {
            /****************************************************************/
            /* Event triggered - thread initialised OK.                     */
            /****************************************************************/
            TRC_NRM((TB, _T("event signalled")));
            rc = TRUE;
        }
        break;

        case WAIT_OBJECT_0 + 1:
        {
            /****************************************************************/
            /* Thread exit                                                  */
            /****************************************************************/
            if (GetExitCodeThread(hndArray[1], &dwrc))
            {
                TRC_ERR((TB, _T("Thread exited with rc %x"), dwrc));
            }
            else
            {
                TRC_ERR((TB, _T("Thread exited with unknown rc")));
            }
        }
        break;

        default:
        {
            TRC_NRM((TB, _T("Wait returned %d"), dwrc));
        }
        break;

    }

    pThreadData->threadID = threadID;
    pThreadData->threadHnd = (ULONG_PTR)(hndArray[1]);
    TRC_ALT((TB, _T("Thread ID %#x handle %#x started"),
                 pThreadData->threadID, pThreadData->threadHnd));

DC_EXIT_POINT:
    /************************************************************************/
    /* Destroy event object.                                                */
    /************************************************************************/
    if (hndArray[0] != 0)
    {
        TRC_NRM((TB, _T("Destroy event object")));
        CloseHandle(hndArray[0]);
    }

    DC_END_FN();
    return(rc);
} /* UTStartThread */



/****************************************************************************/
/* Name:      UTStaticThreadEntry                                           */
/*                                                                          */
/* Purpose:   STATIC Thread entry point.                                    */
/*                                                                          */
/* Returns:   0                                                             */
/*                                                                          */
/* Params:    IN      pInfo - pointer to thread entry function+sync object  */
/*                                                                          */
/* Operation: signal started OK and call the thread enty function - which   */
/*            enters a message loop.                                        */
/*                                                                          */
/****************************************************************************/
DCUINT WINAPI CUT::UTStaticThreadEntry(UT_THREAD_INFO * pInfo)
{
    UTTHREAD_PROC pFunc;
    PDCVOID       pThreadParam;

    DC_BEGIN_FN("UTStaticThreadEntry");

    /************************************************************************/
    /* Take a copy of the target function, before signalling that the       */
    /* thread has started.                                                  */
    /************************************************************************/
    pFunc = pInfo->pFunc;
    /************************************************************************/
    /* Take a copy of the instance info before signalling that the          */
    /* thread has started.                                                  */
    /************************************************************************/
    pThreadParam = pInfo->threadParam;


    /************************************************************************/
    /* Flag that initialisation has succeeded.                              */
    /* NOTE: from now on, pInfo is not valid.  Set it to NULL to make sure  */
    /* no-one tries to dereference it.                                      */
    /************************************************************************/
    SetEvent((HANDLE)pInfo->sync);
    pInfo = NULL;

    /************************************************************************/
    /* Call the thread entry point.  This executes a message loop.          */
    /************************************************************************/
    pFunc(pThreadParam);

    DC_END_FN();
    return(0);
}


/****************************************************************************/
/* Name:      UTStopThread                                                  */
/*                                                                          */
/* Purpose:   End a child thread                                            */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise                           */
/*                                                                          */
/* Params:    IN      threadData - thread data                              */
/*                                                                          */
/* Operation: Post WM_QUIT to the thread.                                   */
/*                                                                          */
/****************************************************************************/
DCBOOL DCINTERNAL CUT::UTStopThread(UT_THREAD_DATA threadData,
                                    BOOL fPumpMessages)
{
    DCBOOL rc;
    DWORD retval;
    DWORD dwThreadTimeout;

    DC_BEGIN_FN("UTStopThread");

    // 
    // Bail out if we try to end a thread that never got created in the first
    // place
    //
    if (0 == threadData.threadID) {
        rc = FALSE;
        TRC_ERR((TB, _T("Trying to end thread ID %#x hnd: 0x%x"),
                 threadData.threadID,
                 threadData.threadHnd));
        DC_QUIT;
    }

    //
    // Post WM_QUIT to the thread.
    //
    TRC_NRM((TB, _T("Attempt to stop thread %#x"), threadData.threadID));
    if (PostThreadMessage(threadData.threadID, WM_QUIT, 0, 0))
    {
        rc = TRUE;
    }
    else
    {
        TRC_ERR((TB, _T("Failed to end thread ID %#x"), threadData.threadID));
        rc = FALSE;
    }

    //
    // Free build waits forever, checked build can be set to timeout
    // to help debug deadlocks. A lot of problems become apparent
    // in stress if the wait times out and the code is allowed to continue.
    //
#ifdef DC_DEBUG
    dwThreadTimeout = _UT.dwDebugThreadWaitTimeout;
#else
    dwThreadTimeout = INFINITE;
#endif    

    //
    // Wait for thread to complete.
    //

    TRC_NRM((TB, _T("Wait for thread %#x to die"), threadData.threadID));
    if (fPumpMessages) {
        retval = CUT::UT_WaitWithMessageLoop((HANDLE)(threadData.threadHnd),
                                     dwThreadTimeout);
    }
    else {
        retval = WaitForSingleObject((HANDLE)(threadData.threadHnd),
                                     dwThreadTimeout);
    }
    if (retval == WAIT_TIMEOUT)
    {
        TRC_ABORT((TB,
                 _T("Timeout waiting for threadID %#x handle %#x termination"),
                 threadData.threadID, threadData.threadHnd));
    }
    else
    {
        TRC_ALT((TB, _T("Thread id %#x exited."), threadData.threadID));
    }

DC_EXIT_POINT:

    DC_END_FN();
    return(rc);
} /* UTStopThread */


/****************************************************************************/
/* FUNCTION: UTGetCurrentTime(...)                                          */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* Get the current system time.                                             */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* pTime           : pointer to the time structure to be filled with the    */
/*                   current time.                                          */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL CUT::UTGetCurrentTime(PDC_TIME pTime)
{
    SYSTEMTIME  sysTime;

    DC_BEGIN_FN("UTGetCurrentTime");

    /************************************************************************/
    /* Get the system time                                                  */
    /************************************************************************/
    GetSystemTime(&sysTime);

    /************************************************************************/
    /* Now convert it to a DC_TIME - this isn't hard since the structures   */
    /* are very similar.                                                    */
    /************************************************************************/
    pTime->hour       = (DCUINT8)sysTime.wHour;
    pTime->min        = (DCUINT8)sysTime.wMinute;
    pTime->sec        = (DCUINT8)sysTime.wSecond;
    pTime->hundredths = (DCUINT8)(sysTime.wMilliseconds / 10);

    DC_END_FN();
    return;
} /* UTGetCurrentTime */

/****************************************************************************/
/* FUNCTION: UTGetCurrentDate(...)                                         */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* Get the current system date.                                             */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* pDate           : pointer to the date structure to be filled with the    */
/*                   current date.                                          */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL CUT::UTGetCurrentDate(PDC_DATE pDate)
{
    SYSTEMTIME  sysTime;

    DC_BEGIN_FN("UTGetCurrentDate");

    /************************************************************************/
    /* Get the system time                                                  */
    /************************************************************************/
    GetSystemTime(&sysTime);

    /************************************************************************/
    /* Now convert it to a DC_DATE - this isn't hard since the structures   */
    /* are very similar.                                                    */
    /************************************************************************/
    pDate->day   = (DCUINT8)sysTime.wDay;
    pDate->month = (DCUINT8)sysTime.wMonth;
    pDate->year  = (DCUINT16)sysTime.wYear;

    DC_END_FN();
    return;
} /* UTGetCurrentDate */


/****************************************************************************/
/* Name:      UTReadEntry                                                   */
/*                                                                          */
/* Purpose:   Read an entry from the given section of the registry          */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise                           */
/*                                                                          */
/* Params:    .                                                             */
/*   topLevelKey      : one of:                                             */
/*                        - HKEY_CURRENT_USER                               */
/*                        - HKEY_LOCAL_MACHINE                              */
/*   pSection         : the section name to read from.  The product prefix  */
/*                      string is prepended to give the full name.          */
/*   pEntry           : the entry name to read.                             */
/*   pBuffer          : a buffer to read the entry to.                      */
/*   bufferSize       : the size of the buffer.                             */
/*   expectedDataType : the type of data stored in the entry.               */
/*                                                                          */
/****************************************************************************/
DCBOOL DCINTERNAL CUT::UTReadEntry(HKEY     topLevelKey,
                              PDCTCHAR pSection,
                              PDCTCHAR pEntry,
                              PDCUINT8 pBuffer,
                              DCINT    bufferSize,
                              DCINT32  expectedDataType)
{
    LONG        sysrc;
    HKEY        key;
    DCINT32     dataType;
    DCINT32     dataSize;
    DCTCHAR     subKey[UT_MAX_SUBKEY];
    DCBOOL      keyOpen = FALSE;
    DCBOOL      rc = FALSE;

    DC_BEGIN_FN("UTReadEntry");

    /************************************************************************/
    /* Get a subkey for the value.                                          */
    /************************************************************************/
    UtMakeSubKey(subKey, SIZE_TCHARS(subKey), pSection);

    /************************************************************************/
    /* Try to open the key.  If the entry does not exist, RegOpenKeyEx will */
    /* fail.                                                                */
    /************************************************************************/
    sysrc = RegOpenKeyEx(topLevelKey,
                         subKey,
                         0,                   /* reserved                 */
                         KEY_READ,
                         &key);

    if (sysrc != ERROR_SUCCESS)
    {
        /********************************************************************/
        /* Don't trace an error here since the subkey may not exist...      */
        /********************************************************************/
        TRC_NRM((TB, _T("Failed to open key %s, rc = %ld"), subKey, sysrc));
        DC_QUIT;
    }
    keyOpen = TRUE;

    /************************************************************************/
    /* We successfully opened the key so now try to read the value.  Again  */
    /* it may not exist.                                                    */
    /************************************************************************/
    dataSize = (DCINT32)bufferSize;
    sysrc    = RegQueryValueEx(key,
                               pEntry,
                               0,          /* reserved */
                               (LPDWORD)&dataType,
                               (LPBYTE)pBuffer,
                               (LPDWORD)&dataSize);

    if (sysrc != ERROR_SUCCESS)
    {
        TRC_NRM((TB, _T("Failed to read value of [%s] %s, rc = %ld"),
                     pSection,
                     pEntry,
                     sysrc));
        DC_QUIT;
    }

    /************************************************************************/
    /* Check that the type is correct.  Special case: allow REG_BINARY      */
    /* instead of REG_DWORD, as long as the length is 32 bits.              */
    /************************************************************************/
    if ((dataType != expectedDataType) &&
        ((dataType != REG_BINARY) ||
         (expectedDataType != REG_DWORD) ||
         (dataSize != 4)))
    {
        TRC_ALT((TB,_T("Read value from [%s] %s, but type is %ld - expected %ld"),
                     pSection,
                     pEntry,
                     dataType,
                     expectedDataType));
        DC_QUIT;
    }
    rc = TRUE;

DC_EXIT_POINT:

    /************************************************************************/
    /* Close the key (if required).                                         */
    /************************************************************************/
    if (keyOpen)
    {
        sysrc = RegCloseKey(key);
        if (sysrc != ERROR_SUCCESS)
        {
            TRC_ERR((TB, _T("Failed to close key, rc = %ld"), sysrc));
        }
    }

    DC_END_FN();
    return(rc);

} /* UTReadEntry */

/****************************************************************************/
/* Name:      UTWriteEntry                                                  */
/*                                                                          */
/* Purpose:   Write an entry to the given section of the registry           */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise                           */
/*                                                                          */
/* Params:    .                                                             */
/*   topLevelKey      : one of:                                             */
/*                        - HKEY_CURRENT_USER                               */
/*                        - HKEY_LOCAL_MACHINE                              */
/*   pSection         : the section name to write to.  The product prefix   */
/*                      string is prepended to give the full name.          */
/*   pEntry           : the entry name to write                             */
/*   pData            : a pointer to the data to write                      */
/*   dataSize         : the size of the data to be written.  For strings    */
/*                      this must include the NULL terminator               */
/*   expectedDataType : the type of data to be written                      */
/*                                                                          */
/****************************************************************************/
DCBOOL DCINTERNAL CUT::UTWriteEntry(HKEY     topLevelKey,
                               PDCTCHAR pSection,
                               PDCTCHAR pEntry,
                               PDCUINT8 pData,
                               DCINT    dataSize,
                               DCINT32  dataType)
{
    LONG        sysrc;
    HKEY        key;
    DCTCHAR     subKey[UT_MAX_SUBKEY];
    DWORD       disposition;
    DCBOOL      keyOpen = FALSE;
    DCBOOL      rc = FALSE;

    DC_BEGIN_FN("UTWriteEntry");

    /************************************************************************/
    /* Get a subkey for the value.                                          */
    /************************************************************************/
    UtMakeSubKey(subKey, SIZE_TCHARS(subKey), pSection);

    /************************************************************************/
    /* Try to create the key.  If the entry already exists, RegCreateKeyEx  */
    /* will open the existing entry.                                        */
    /************************************************************************/
    sysrc = RegCreateKeyEx(topLevelKey,
                           subKey,
                           0,                   /* reserved             */
                           NULL,                /* class                */
                           REG_OPTION_NON_VOLATILE,
                           KEY_WRITE,
                           NULL,                /* security attributes  */
                           &key,
                           &disposition);

    if (sysrc != ERROR_SUCCESS)
    {
        TRC_ERR((TB, _T("Failed to create / open key %s, rc = %ld"),
                     subKey, sysrc));
        DC_QUIT;
    }

    keyOpen = TRUE;
    TRC_NRM((TB, _T("%s key %s"),
               (disposition == REG_CREATED_NEW_KEY) ? "Created" : "Opened",
               subKey));

    /************************************************************************/
    /* We've got the key, so set the value.                                 */
    /************************************************************************/
    sysrc = RegSetValueEx(key,
                          pEntry,
                          0,            /* reserved     */
                          dataType,
                          (LPBYTE)pData,
                          (DCINT32)dataSize);

    if (sysrc != ERROR_SUCCESS)
    {
        TRC_ERR((TB, _T("Failed to write value to [%s] %s, rc = %ld"),
                   pSection,
                   pEntry,
                   sysrc));
        DC_QUIT;
    }
    rc = TRUE;

DC_EXIT_POINT:

    /************************************************************************/
    /* Close the key (if required)                                          */
    /************************************************************************/
    if (keyOpen)
    {
        sysrc = RegCloseKey(key);
        if (sysrc != ERROR_SUCCESS)
        {
            TRC_ERR((TB, _T("Failed to close key, rc = %ld"), sysrc));
        }
    }

    DC_END_FN();
    return(rc);

} /* UTWriteEntry */


/****************************************************************************/
/* Name:      UTDeleteEntry                                                 */
/*                                                                          */
/* Purpose:   Deletes an entry from the registry                            */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise                           */
/*                                                                          */
/* Params:    IN      pSection - the section name of the entry to delete    */
/*            IN      pEntry   - the actual entry to delete                 */
/*                                                                          */
/****************************************************************************/
DCBOOL DCINTERNAL CUT::UTDeleteEntry(PDCTCHAR pSection,
                                PDCTCHAR pEntry)
{
    LONG        sysrc;
    HKEY        key;
    DCTCHAR     subKey[UT_MAX_SUBKEY];
    DCBOOL      keyOpen = FALSE;
    DCBOOL      rc = FALSE;

    DC_BEGIN_FN("UTDeleteEntry");

    /************************************************************************/
    /* Get a subkey for the value.                                          */
    /************************************************************************/
    UtMakeSubKey(subKey, SIZE_TCHARS(subKey), pSection);

    /************************************************************************/
    /* Try to open the key.  If the entry does not exist, RegOpenKeyEx will */
    /* fail.                                                                */
    /************************************************************************/
    sysrc = RegOpenKeyEx(HKEY_CURRENT_USER,
                         subKey,
                         0,                     /* reserved                 */
                         KEY_WRITE,
                         &key);

    if (sysrc != ERROR_SUCCESS)
    {
        /********************************************************************/
        /* Don't trace an error here since the subkey may not exist...      */
        /********************************************************************/
        TRC_NRM((TB, _T("Failed to open key %s, rc = %ld"), subKey, sysrc));
        DC_QUIT;
    }
    keyOpen = TRUE;

    /************************************************************************/
    /* Now try to delete the entry.                                         */
    /************************************************************************/
    sysrc = RegDeleteValue(key, pEntry);

    if (sysrc != ERROR_SUCCESS)
    {
        /********************************************************************/
        /* We failed to delete the entry - this is quite acceptable as it   */
        /* may never have existed...                                        */
        /********************************************************************/
        TRC_NRM((TB, _T("Failed to delete entry %s from section %s"),
                 pEntry,
                 pSection));
    }
    rc = TRUE;

DC_EXIT_POINT:

    /************************************************************************/
    /* Close the key (if required).                                         */
    /************************************************************************/
    if (keyOpen)
    {
        sysrc = RegCloseKey(key);
        if (sysrc != ERROR_SUCCESS)
        {
            TRC_ERR((TB, _T("Failed to close key, rc = %ld"), sysrc));
        }
    }

    DC_END_FN();
    return(rc);

} /* UTDeleteEntry */


/****************************************************************************/
/* Name:      UTEnumRegistry                                                */
/*                                                                          */
/* Purpose:   Enumerate keys from registry                                  */
/*                                                                          */
/* Returns:   TRUE  - registry key returned                                 */
/*            FALSE - no more registry keys to enumerate                    */
/*                                                                          */
/* Params:    IN      pSection      - registy section                       */
/*            IN      index         - index of key to enumerate             */
/*            OUT     pBuffer       - output buffer                         */
/*            IN      bufferSize    - output buffer size                    */
/*                                                                          */
/* Operation:                                                               */
/*                                                                          */
/****************************************************************************/
DCBOOL DCINTERNAL CUT::UTEnumRegistry( PDCTCHAR pSection,
                                  DCUINT32 index,
                                  PDCTCHAR pBuffer,
                                  PDCINT   pBufferSize )
{
    LONG        sysrc;
    DCTCHAR     subKey[UT_MAX_SUBKEY];
    DCBOOL      rc = FALSE;
    FILETIME    fileTime;

    DC_BEGIN_FN("UTEnumRegistry");

    /************************************************************************/
    /* Get a subkey for the value.                                          */
    /************************************************************************/
    UtMakeSubKey(subKey, SIZE_TCHARS(subKey), pSection);

    /************************************************************************/
    /* First time - open the key.  Try HKCU first.                          */
    /************************************************************************/
    if (index == 0)
    {
        sysrc = RegOpenKeyEx(HKEY_CURRENT_USER,
                             subKey,
                             0,
                             KEY_READ,
                             &_UT.enumHKey);
        TRC_NRM((TB, _T("Open HKCU %s, rc %d"), subKey, sysrc));

        if (sysrc != ERROR_SUCCESS)
        {
            /****************************************************************/
            /* Didn't find HKCU - try HKLM                                  */
            /****************************************************************/
            sysrc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 subKey,
                                 0,
                                 KEY_READ,
                                 &_UT.enumHKey);
            TRC_NRM((TB, _T("Open HKLM %s, rc %d"), subKey, sysrc));

            if (sysrc != ERROR_SUCCESS)
            {
                /************************************************************/
                /* Didn't find HKLM either - give up                        */
                /************************************************************/
                TRC_ALT((TB, _T("Didn't find subkey %s - give up"), subKey));
                DC_QUIT;
            }
        }
    }

    TRC_ASSERT((_UT.enumHKey != 0), (TB,_T("0 hKey")));

    /************************************************************************/
    /* If we get here, we have opened a key - do the enumeration now        */
    /************************************************************************/
    sysrc = RegEnumKeyEx(_UT.enumHKey,
                         index,
                         pBuffer,
                         (PDCUINT32)pBufferSize,
                         NULL, NULL, NULL,
                         &fileTime);

    /************************************************************************/
    /* If it worked, set the return code                                    */
    /************************************************************************/
    if (sysrc == ERROR_SUCCESS)
    {
        TRC_NRM((TB, _T("Enumerated key OK")));
        rc = TRUE;
    }
    else
    {
        /********************************************************************/
        /* End of enumeration - close the key                               */
        /********************************************************************/
        TRC_NRM((TB, _T("End of enumeration, rc %ld"), sysrc));
        sysrc = RegCloseKey(_UT.enumHKey);
        if (sysrc != ERROR_SUCCESS)
        {
            TRC_ERR((TB, _T("Failed to close key, rc = %ld"), sysrc));
        }
        _UT.enumHKey = 0;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return(rc);
} /* UTEnumRegistry */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\util\wutil.cpp ===
/**MOD+**********************************************************************/
/* Module:    wutil.cpp                                                     */
/*                                                                          */
/* Purpose:   Utilities - Win32 version                                     */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1999                             */
/*                                                                          */
/****************************************************************************/

#include <adcg.h>

#define TRC_FILE    "wutil"
#define TRC_GROUP   TRC_GROUP_UTILITIES
#include <atrcapi.h>

extern "C" {
#ifndef OS_WINCE
#include <process.h>
#endif
}

#include <autil.h>

/**PROC+*********************************************************************/
/* Name:      UTReadRegistryString                                          */
/*                                                                          */
/* Purpose:   Reads a string from the registry                              */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise                           */
/*                                                                          */
/* Params:                                                                  */
/*   pSection        : section containing the entry to read.                */
/*   pEntry          : entry name of string to retrieve (if NULL all        */
/*                     entries in the section are returned).                */
/*   pBuffer         : buffer to return the entry in.                       */
/*   bufferSize      : size of the buffer in bytes.                         */
/*                                                                          */
/**PROC-*********************************************************************/
DCBOOL DCINTERNAL CUT::UTReadRegistryString(PDCTCHAR pSection,
                                       PDCTCHAR pEntry,
                                       PDCTCHAR pBuffer,
                                       DCINT    bufferSize)
{
    DCBOOL rc = TRUE;

    DC_BEGIN_FN("UTReadRegistryString");

    /************************************************************************/
    /* First try to read the value from the current user section.           */
    /************************************************************************/
    if (!UTReadEntry( HKEY_CURRENT_USER,
                      pSection,
                      pEntry,
                      (PDCUINT8)pBuffer,
                      bufferSize,
                      REG_SZ ))
    {
        TRC_NRM((TB, _T("Failed to read string from current user section")));

        /********************************************************************/
        /* Couldn't read the value from the current user section.  Try to   */
        /* pick up a default value from the local machine section.          */
        /********************************************************************/
        if (!UTReadEntry( HKEY_LOCAL_MACHINE,
                          pSection,
                          pEntry,
                          (PDCUINT8)pBuffer,
                          bufferSize,
                          REG_SZ ))
        {
            TRC_NRM((TB, _T("Failed to read string from local machine section")));
            rc = FALSE;
        }
    }

    DC_END_FN();
    return(rc);

} /* UTReadRegistryString */


/**PROC+*********************************************************************/
/* Name:      UTReadRegistryExpandString                                    */
/*                                                                          */
/* Purpose:   Reads a REG_EXPAND_SZ string from the registry                */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise                           */
/*                                                                          */
/* Params:                                                                  */
/*   pSection        : section containing the entry to read.                */
/*   pEntry          : entry name of string to retrieve (if NULL all        */
/*                     entries in the section are returned).                */
/*   pBuffer         : buffer to return the entry in.                       */
/*   bufferSize      : size of the buffer in bytes.                         */
/*                                                                          */
/**PROC-*********************************************************************/
DCBOOL DCINTERNAL CUT::UTReadRegistryExpandString(PDCTCHAR pSection,
                                       PDCTCHAR pEntry,
                                       PDCTCHAR* ppBuffer,
                                       PDCINT    pBufferSize)
{
    DCBOOL rc = TRUE;

    DC_BEGIN_FN("UTReadRegistryString");

    #ifndef OS_WINCE

    TCHAR szBuf[MAX_PATH];
    INT bufferSize = MAX_PATH*sizeof(TCHAR);


    /************************************************************************/
    /* First try to read the value from the current user section.           */
    /************************************************************************/
    if (!UTReadEntry( HKEY_CURRENT_USER,
                      pSection,
                      pEntry,
                      (PDCUINT8)szBuf,
                      bufferSize,
                      REG_EXPAND_SZ ))
    {
        TRC_NRM((TB, _T("Failed to read string from current user section")));

        /********************************************************************/
        /* Couldn't read the value from the current user section.  Try to   */
        /* pick up a default value from the local machine section.          */
        /********************************************************************/
        if (!UTReadEntry( HKEY_LOCAL_MACHINE,
                          pSection,
                          pEntry,
                          (PDCUINT8)szBuf,
                          bufferSize,
                          REG_EXPAND_SZ ))
        {
            TRC_NRM((TB, _T("Failed to read string from local machine section")));
            rc = FALSE;
        }
    }

    if(rc)
    {
        //
        // Try to expand the string
        //
        DWORD dwChars = 
            ExpandEnvironmentStrings(szBuf,
                                    NULL,
                                    0);
        *ppBuffer = (PDCTCHAR)LocalAlloc(LPTR, (dwChars+1)*sizeof(TCHAR));
        if(*ppBuffer)
        {
            if(ExpandEnvironmentStrings(szBuf,
                                        (LPTSTR)*ppBuffer,
                                        dwChars))
            {
                rc = TRUE;
            }
        }

    }
    #else //OS_WINCE
    
    //CE doesn't have an ExpandEnvironmentStrings
    TRC_NRM((TB,_T("Not implemented on CE")));
    rc = FALSE;
    
    #endif


    DC_END_FN();
    return(rc);



} /* UTReadRegistryString */


/**PROC+*********************************************************************/
/* Name:      UTReadRegistryInt                                             */
/*                                                                          */
/* Purpose:   Reads an integer from the registry                            */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise                           */
/*                                                                          */
/* Params:                                                                  */
/*   pSection        : section containing the entry to read.                */
/*   pEntry          : entry name of string to retrieve (if NULL all        */
/*                     entries in the section are returned).                */
/*   pValue          : buffer to return the entry in.                       */
/*                                                                          */
/**PROC-*********************************************************************/
DCBOOL DCINTERNAL CUT::UTReadRegistryInt(PDCTCHAR pSection,
                                    PDCTCHAR pEntry,
                                    PDCINT   pValue)
{
    DCBOOL rc = TRUE;

    DC_BEGIN_FN("UTReadRegistryInt");

    /************************************************************************/
    /* First try to read the value from the current user section            */
    /************************************************************************/
    if (!UTReadEntry( HKEY_CURRENT_USER,
                      pSection,
                      pEntry,
                      (PDCUINT8)pValue,
                      sizeof(DCINT),
                      REG_DWORD ))
    {
        TRC_NRM((TB, _T("Failed to read int from current user section")));

        /********************************************************************/
        /* Couldn't read the value from the current user section.  Try to   */
        /* pick up a default value from the local machine section.          */
        /********************************************************************/
        if (!UTReadEntry( HKEY_LOCAL_MACHINE,
                          pSection,
                          pEntry,
                          (PDCUINT8)pValue,
                          sizeof(DCINT),
                          REG_DWORD ))
        {
            TRC_NRM((TB, _T("Failed to read int from local machine section")));
            rc = FALSE;
        }
    }

    DC_END_FN();
    return(rc);

} /* UTReadRegistryInt */


/**PROC+*********************************************************************/
/* Name:      UTReadRegistryBinary                                          */
/*                                                                          */
/* Purpose:   Reads binary data from the registry                           */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise                           */
/*                                                                          */
/* Params:                                                                  */
/*   pSection        : section containing the entry to read.                */
/*   pEntry          : entry name of data to retrieve (if NULL all          */
/*                     entries in the section are returned).                */
/*   pBuffer         : buffer to return the entry in.                       */
/*   bufferSize      : size of the buffer in bytes.                         */
/*                                                                          */
/**PROC-*********************************************************************/
DCBOOL DCINTERNAL CUT::UTReadRegistryBinary(PDCTCHAR pSection,
                                       PDCTCHAR pEntry,
                                       PDCTCHAR pBuffer,
                                       DCINT    bufferSize)
{
    DCBOOL rc = TRUE;

    DC_BEGIN_FN("UTReadRegistryBinary");

    /************************************************************************/
    /* First try to read the value from the current user section.           */
    /************************************************************************/
    if (!UTReadEntry( HKEY_CURRENT_USER,
                      pSection,
                      pEntry,
                      (PDCUINT8)pBuffer,
                      bufferSize,
                      REG_BINARY ))
    {
        TRC_NRM((TB, _T("Failed to read binary data from current user section")));

        /********************************************************************/
        /* Couldn't read the value from the current user section.  Try to   */
        /* pick up a default value from the local machine section.          */
        /********************************************************************/
        if (!UTReadEntry( HKEY_LOCAL_MACHINE,
                          pSection,
                          pEntry,
                          (PDCUINT8)pBuffer,
                          bufferSize,
                          REG_BINARY ))
        {
            TRC_NRM((TB, _T("Failed to read binary data from local machine section")));
            rc = FALSE;
        }
    }

    DC_END_FN();
    return(rc);

} /* UTReadRegistryBinary */


/**PROC+*********************************************************************/
/* Name:      UTWriteRegistryString                                         */
/*                                                                          */
/* Purpose:   Writes a string to the registry                               */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise                           */
/*                                                                          */
/* Params:                                                                  */
/*   pSection        : section containing the entry to read.                */
/*   pEntry          : entry name of string to write                        */
/*   pBuffer         : pointer to string to write in.                       */
/*                                                                          */
/**PROC-*********************************************************************/
DCBOOL DCINTERNAL CUT::UTWriteRegistryString(PDCTCHAR pSection,
                                        PDCTCHAR pEntry,
                                        PDCTCHAR pBuffer)
{
    DCBOOL rc;

    DC_BEGIN_FN("UTWriteRegistryString");

    /************************************************************************/
    /* Write the entry to the current user section                          */
    /************************************************************************/
    rc = UTWriteEntry( HKEY_CURRENT_USER,
                       pSection,
                       pEntry,
                       (PDCUINT8)pBuffer,
                       DC_TSTRBYTELEN(pBuffer),
                       REG_SZ );
    if (!rc)
    {
        TRC_NRM((TB, _T("Failed to write string")));
    }

    DC_END_FN();
    return(rc);

} /* UTWriteRegistryString */


/**PROC+*********************************************************************/
/* Name:      UTWriteRegistryString                                         */
/*                                                                          */
/* Purpose:   Writes a string to the registry                               */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise                           */
/*                                                                          */
/* Params:                                                                  */
/*   pSection        : section containing the entry to read.                */
/*   pEntry          : entry name of integer to write                       */
/*   value           : the integer to write                                 */
/*                                                                          */
/**PROC-*********************************************************************/
DCBOOL DCINTERNAL CUT::UTWriteRegistryInt(PDCTCHAR pSection,
                                     PDCTCHAR pEntry,
                                     DCINT    value)
{
    DCBOOL    rc;

    DC_BEGIN_FN("UTWriteRegistryInt");

    /************************************************************************/
    /* Write the entry to the current user section                          */
    /************************************************************************/
    rc = UTWriteEntry( HKEY_CURRENT_USER,
                       pSection,
                       pEntry,
                       (PDCUINT8)&value,
                       sizeof(DCINT),
                       REG_DWORD );
    if (!rc)
    {
        TRC_NRM((TB, _T("Failed to write int")));
    }

    DC_END_FN();
    return(rc);

} /* UTWriteRegistryInt */


/**PROC+*********************************************************************/
/* Name:      UTWriteRegistryBinary                                         */
/*                                                                          */
/* Purpose:   Writes binary data to the registry                            */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise                           */
/*                                                                          */
/* Params:                                                                  */
/*   pSection        : section containing the entry to read.                */
/*   pEntry          : entry name of data to write                          */
/*   pBuffer         : pointer to data to write in.                         */
/*                                                                          */
/**PROC-*********************************************************************/
DCBOOL DCINTERNAL CUT::UTWriteRegistryBinary(PDCTCHAR pSection,
                                        PDCTCHAR pEntry,
                                        PDCTCHAR pBuffer,
                                        DCINT    bufferSize)
{
    DCBOOL rc;

    DC_BEGIN_FN("UTWriteRegistryBinary");

    /************************************************************************/
    /* Write the entry to the current user section                          */
    /************************************************************************/
    rc = UTWriteEntry( HKEY_CURRENT_USER,
                       pSection,
                       pEntry,
                       (PDCUINT8)pBuffer,
                       bufferSize,
                       REG_BINARY );
    if (!rc)
    {
        TRC_NRM((TB, _T("Failed to write binary data")));
    }

    DC_END_FN();
    return(rc);

} /* UTWriteRegistryBinary */


/****************************************************************************/
/* Include platform specific functions.                                     */
/****************************************************************************/
#include <nutint.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\util\util.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    core.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Madan Appiah - Sep. 5th 1997

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

C_DEFINES = \
    $(C_DEFINES) \
    $(CLIENT_EXE_CDEFS) \

INCLUDES = \
        $(INCLUDES); \
        $(TSHRCLNT_ROOT)\newcore; \
        $(BASE_INC_PATH)

#
# List of sources
#
        
SOURCES_PLATFORM =

CLIENT_SOURCES_RC = \

CLIENT_SOURCES_COMMON = \
    ..\autil.cpp \
    ..\reglic.cpp \
    ..\uttime.cpp

CLIENT_SOURCES_LAST  = \
    ..\wutil.cpp

SOURCES = \
    $(CLIENT_SOURCES_RC) \
    $(SOURCES_PLATFORM) \
    $(CLIENT_SOURCES_COMMON) \
    $(CLIENT_SOURCES_LAST)

#
# Precompiled specs
#

PRECOMPILED_INCLUDE = ..\adcg.h
PRECOMPILED_PCH = adcg.pch
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\web\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1998 - 1998

Module Name:

    makefile.inc.

!ENDIF

CONTENT_SRC_DIR = .\content
PBUILD_SRC_DIR = .\pbuild
SETUP_SRC_DIR = .\setup

SRC_WEB_STATIC_FILES = \
        $(CONTENT_SRC_DIR)\bluebarh.gif   \
        $(CONTENT_SRC_DIR)\bluebarv.gif   \
        $(CONTENT_SRC_DIR)\win2000l.gif   \
        $(CONTENT_SRC_DIR)\win2000r.gif   \
        $(SETUP_SRC_DIR)\tsweb-eula.txt   \
        $(SETUP_SRC_DIR)\tsweb-readme.htm \
        $(SETUP_SRC_DIR)\tsweb-setup.inf  \
        $(SETUP_SRC_DIR)\tsweb-setup.sed  \
        
SRC_TEMPLATE_FILES = \
        $(CONTENT_SRC_DIR)\tsweb1.htm     \
        $(CONTENT_SRC_DIR)\msrdp.inf      \

SRC_SYMBOL_LST_FILES = \
        $(CONTENT_SRC_DIR)\msrdp.lst      \
        
SRC_TOOL_FILES = \
        $(PBUILD_SRC_DIR)\tscwebgen.cmd   \
        
static_files: $(SRC_WEB_STATIC_FILES)
        -for %i in ($**) do binplace -:DEST retail %i
        
template_files: $(SRC_TEMPLATE_FILES)
        -for %i in ($**) do binplace -:DEST TSClient\win32\* %i
        
tool_files: $(SRC_TOOL_FILES)
        -for %i in ($**) do binplace -:DEST TSClient\win32\* %i

symbol_lst_files: $(SRC_SYMBOL_LST_FILES)
        -for %i in ($**) do binplace -:DEST symbolcd\cablists %i
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\audit.c ===
/*******************************************************************************
* AUDIT.C
*
*     This module contains the routines for logging audit events
*
* Copyright Citrix Systems Inc. 1995
* Copyright (C) 1997-1999 Microsoft Corp.
*
*  Author: Thanh Luu
*******************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include <msaudite.h>


HANDLE AuditLogHandle = NULL;
//Authz Changes
AUTHZ_RESOURCE_MANAGER_HANDLE hRM         = NULL;
//END Authz Changes


NTSTATUS
AdtBuildLuidString(
    IN PLUID Value,
    OUT PUNICODE_STRING ResultantString
    );
VOID
AuditEvent( PGLOBALS pGlobals, ULONG EventId );

BOOL
AuditingEnabled ();

NTSTATUS
AuthzReportEventW( IN PAUTHZ_AUDIT_EVENT_TYPE_HANDLE pHAET, 
                   IN DWORD Flags, 
                   IN ULONG EventId, 
                   IN PSID pUserID, 
                   IN USHORT NumStrings,
                   IN ULONG DataSize OPTIONAL, //Future - DO NOT USE
                   IN PWSTR* Strings,
                   IN PVOID  Data OPTIONAL         //Future - DO NOT USE
                   );


BOOL AuthzInit( IN DWORD Flags,
                IN USHORT CategoryID,
                IN USHORT AuditID,
                IN USHORT ParameterCount,
                OUT PAUTHZ_AUDIT_EVENT_TYPE_HANDLE phAuditEventType
                );


NTSTATUS
AdtBuildLuidString(
    IN PLUID Value,
    OUT PUNICODE_STRING ResultantString
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed LUID.

    The resultant string will be formatted as follows:

        (0x00005678,0x12340000)

Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS                Status;
    UNICODE_STRING          IntegerString;

    ULONG                   Buffer[(16*sizeof(WCHAR))/sizeof(ULONG)];


    IntegerString.Buffer = (PWCHAR)&Buffer[0];
    IntegerString.MaximumLength = 16*sizeof(WCHAR);


    //
    // Length (in WCHARS) is  3 for   (0x
    //                       10 for   1st hex number
    //                        3 for   ,0x
    //                       10 for   2nd hex number
    //                        1 for   )
    //                        1 for   null termination
    //

    ResultantString->Length        = 0;
    ResultantString->MaximumLength = 28 * sizeof(WCHAR);

    ResultantString->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                               ResultantString->MaximumLength);
    if (ResultantString->Buffer == NULL) {
        return(STATUS_NO_MEMORY);
    }

    Status = RtlAppendUnicodeToString( ResultantString, L"(0x" );
    Status = RtlIntegerToUnicodeString( Value->HighPart, 16, &IntegerString );
    Status = RtlAppendUnicodeToString( ResultantString, IntegerString.Buffer );

    Status = RtlAppendUnicodeToString( ResultantString, L",0x" );
    Status = RtlIntegerToUnicodeString( Value->LowPart, 16, &IntegerString );
    Status = RtlAppendUnicodeToString( ResultantString, IntegerString.Buffer );

    Status = RtlAppendUnicodeToString( ResultantString, L")" );

    return(STATUS_SUCCESS);
}


VOID
AuditEvent( PGLOBALS pGlobals, ULONG EventId )
{
    NTSTATUS Status; 
    WINSTATIONNAME WinStationName;
    USHORT StringIndex = 0;
    WINSTATIONCLIENT ClientData;
    ULONG Length;
    BOOL bResult = FALSE;
    UNICODE_STRING LuidString;
    PWSTR StringPointerArray[6];
    TOKEN_STATISTICS TokenInformation;
    ULONG ReturnLength;
    BOOLEAN WasEnabled;
    LUID LogonId = {0,0};
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAET = NULL;

    if (!AuditingEnabled() || pGlobals->AuditLogFull)
        return;

   //
    //AUTHZ Changes 
    //
    if( !AuthzInit( 0, SE_CATEGID_LOGON, (USHORT)EventId, 6, &hAET ))
        goto badAuthzInit;

    StringPointerArray[StringIndex] = pGlobals->UserName ;
    StringIndex++;

    StringPointerArray[StringIndex] = pGlobals->Domain;
    StringIndex++;

    Status = AdtBuildLuidString( &pGlobals->LogonId, &LuidString );
    StringPointerArray[StringIndex] = LuidString.Buffer;
    StringIndex++;

    WinStationNameFromLogonId( SERVERNAME_CURRENT, LOGONID_CURRENT, WinStationName );
    StringPointerArray[StringIndex] = WinStationName;
    StringIndex++;

    bResult = WinStationQueryInformation( SERVERNAME_CURRENT,
                                          LOGONID_CURRENT,
                                          WinStationClient,
                                          &ClientData,
                                          sizeof(ClientData),
                                          &Length );

    if ( bResult ) 
        StringPointerArray[StringIndex] = ClientData.ClientName;
    else 
        StringPointerArray[StringIndex = L"Unknown";
    StringIndex++;

    if ( bResult )
        StringPointerArray[StringIndex] = ClientData.ClientAddress;
    else 
        StringPointerArray[StringIndex] = L"Unknown";
    StringIndex++;
    
    //Authz Changes
    
    Status = AuthzReportEventW( &hAET, 
                                APF_AuditSuccess, 
                                EventId, 
                                NULL, 
                                StringIndex,
                                0,
                                StringPointerArray,
                                NULL
                                );

    //end authz changes


     if ( !NT_SUCCESS(Status))
        DBGPRINT(("Termsrv - failed to report event \n" ));

badAuthzInit:
    if( hAET != NULL )
       AuthziFreeAuditEventType( hAET  );
}




/***************************************************************************\
* AuditingEnabled
*
* Purpose : Check auditing via LSA.
*
* Returns:  TRUE on success, FALSE on failure
*
* History:
* 5-6-92   DaveHart     Created.
\***************************************************************************/

BOOL
AuditingEnabled()
{
    NTSTATUS                    Status, IgnoreStatus;
    PPOLICY_AUDIT_EVENTS_INFO   AuditInfo;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    LSA_HANDLE                  PolicyHandle;

    //
    // Set up the Security Quality Of Service for connecting to the
    // LSA policy object.
    //

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes to open the Lsa policy object
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );
    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    //
    // Open the local LSA policy object
    //

    Status = LsaOpenPolicy(
                 NULL,
                 &ObjectAttributes,
                 POLICY_VIEW_AUDIT_INFORMATION | POLICY_SET_AUDIT_REQUIREMENTS,
                 &PolicyHandle
                 );
    if (!NT_SUCCESS(Status)) {
        DebugLog((DEB_ERROR, "Failed to open LsaPolicyObject Status = 0x%lx", Status));
        return FALSE;
    }

    Status = LsaQueryInformationPolicy(
                 PolicyHandle,
                 PolicyAuditEventsInformation,
                 (PVOID *)&AuditInfo
                 );
    IgnoreStatus = LsaClose(PolicyHandle);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    if (!NT_SUCCESS(Status)) {
        DebugLog((DEB_ERROR, "Failed to query audit event info Status = 0x%lx", Status));
        return FALSE;
    }

    return (AuditInfo->AuditingMode &&
            ((AuditInfo->EventAuditingOptions)[AuditCategoryLogon] &
                                          POLICY_AUDIT_EVENT_SUCCESS));
}


/*************************************************************
* AuthzInit Purpose : Initialize authz for logging an event to the security log
*Flags - unused
*Category Id - Security Category to which this event belongs
*Audit Id - An id for the event
*PArameter count - Number of parameters that will be passed to the logging function later
****************************************************************/

BOOL AuthzInit( IN DWORD Flags,
                IN USHORT CategoryID,
                IN USHORT AuditID,
                IN USHORT ParameterCount,
                OUT PAUTHZ_AUDIT_EVENT_TYPE_HANDLE phAuditEventType
                )                     
{
     BOOL fAuthzInit   = TRUE;

     if( NULL == phAuditEventType )
        goto badAuthzInit;

     if( NULL == hRM )
     {
            fAuthzInit = AuthzInitializeResourceManager( 0,
                                                         NULL,
                                                         NULL,
                                                         NULL,
                                                         L"Terminal Server",
                                                         &hRM
                                                         );

            if ( !fAuthzInit )
            {
                DBGPRINT(("TERMSRV: AuditEvent: AuthzInitializeResourceManager failed with %d\n", GetLastError()));
                goto badAuthzInit;
            }
    }

    fAuthzInit = AuthziInitializeAuditEventType( Flags,
                                                 CategoryID,
                                                 AuditID,
                                                 ParameterCount,
                                                 phAuditEventType
                                                 );

    if ( !fAuthzInit )
    {
        DBGPRINT(("TERMSRV: AuditEvent: AuthziInitializeAuditEventType failed with %d\n", GetLastError()));
      goto badAuthzInit;
    }

badAuthzInit:
    if( !fAuthzInit )
    {
        if( NULL != hRM )
        {
            if( !AuthzFreeResourceManager( hRM ))
                DBGPRINT(("TERMSRV: AuditEvent: AuthzFreeResourceManager failed with %d\n", GetLastError()));
            hRM = NULL;
        }
        if( NULL != *phAuditEventType )
        {
            if( !AuthziFreeAuditEventType( *phAuditEventType ))
                DBGPRINT(("TERMSRV: AuditEvent: AuthziFreeAuditEventType failed with %d\n", GetLastError()));
            *phAuditEventType = NULL;
        }
    }

  // if( fAuthzInit )
   //  DBGPRINT(("TERMSRV: Successfully initialized authz = %d\n", AuditID));
 return fAuthzInit;
}


/*********************************************************
* Purpose : Log an Event to the security log
* In pHAET
*  Audit Event type obtained from a call to AuthzInit() above
* In Flags
*   APF_AuditSuccess or others as listed in the header file
* pUserSID - Unused
* NumStrings - Number of strings contained within "Strings"
* DataSize - unused
* Strings- Pointer to a sequence of unicode strings
* Data - unused
*
**********************************************************/
NTSTATUS
AuthzReportEventW( IN PAUTHZ_AUDIT_EVENT_TYPE_HANDLE pHAET, 
                   IN DWORD Flags, 
                   IN ULONG EventId, 
                   IN PSID pUserSID, 
                   IN USHORT NumStrings,
                   IN ULONG DataSize OPTIONAL, //Future - DO NOT USE
                   IN PWSTR* Strings,
                   IN PVOID  Data OPTIONAL         //Future - DO NOT USE
                  )
{
    NTSTATUS status = STATUS_ACCESS_DENIED;
    AUTHZ_AUDIT_EVENT_HANDLE      hAE         = NULL;
    BOOL                          fSuccess   = FALSE;
    PAUDIT_PARAMS                 pParams     = NULL;

    if( NULL == hRM || NULL == pHAET || *pHAET == NULL )
        return status;

    fSuccess = AuthziAllocateAuditParams( &pParams,  NumStrings  );

    if ( !fSuccess )
    {
        DBGPRINT(("TERMSRV: AuditEvent: AuthzAllocateAuditParams failed with %d\n", GetLastError()));
        goto BadAuditEvent;
    }


    if( 6 == NumStrings )
    {
        fSuccess = AuthziInitializeAuditParamsWithRM( Flags,
                                                     hRM,
                                                     NumStrings,
                                                     pParams,
                                                     APT_String, Strings[0],
                                                     APT_String,  Strings[1],
                                                     APT_String,  Strings[2],
                                                     APT_String,  Strings[3],
                                                     APT_String, Strings[4],
                                                     APT_String, Strings[5]
                                                     );
    }
    else if( 0 == NumStrings )
    {
        fSuccess = AuthziInitializeAuditParamsWithRM( Flags,
                                                     hRM,
                                                     NumStrings,
                                                     pParams
                                                     );
    }
    else
    {
        //we don't support anything else
        fSuccess = FALSE;
        DBGPRINT(("TERMSRV: AuditEvent: unsupported audit type \n"));
        goto BadAuditEvent;
    }
    
    if ( !fSuccess )
    {
        DBGPRINT(("TERMSRV: AuditEvent: AuthziInitializeAuditParamsWithRM failed with %d\n", GetLastError()));
        goto BadAuditEvent;
    }

    fSuccess = AuthziInitializeAuditEvent( 0,
                                           hRM,
                                           *pHAET,
                                           pParams,
                                           NULL,
                                           INFINITE,
                                           L"",
                                           L"",
                                           L"",
                                           L"",
                                           &hAE
                                           );

    if ( !fSuccess )
    {
        DBGPRINT(("TERMSRV: AuditEvent: AuthziInitializeAuditEvent failed with %d\n", GetLastError()));
        goto BadAuditEvent;
    }    

    fSuccess = AuthziLogAuditEvent( 0,
                                    hAE,
                                    NULL
                                    );

    if ( !fSuccess )
    {
        DBGPRINT(("TERMSRV: AuditEvent: AuthziLogAuditEvent failed with %d\n", GetLastError()));
        goto BadAuditEvent;
    }    

BadAuditEvent:

    if( hAE )
        AuthzFreeAuditEvent( hAE );

    if( pParams )
        AuthziFreeAuditParams( pParams );
    
    if( fSuccess )
        status = STATUS_SUCCESS;

    //if( fSuccess )
    // DBGPRINT(("TERMSRV: Successfully audited event with authz= %d\n", EventId));
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\util\uttime.cpp ===
/*++

    Copyright(C) Microsoft Corporation 1997 - 1999

File:

    uttime.cpp

Abstract:

    Timer management utility API

History:

    02/22/99    FredCh      Created

--*/

#include <adcg.h>
#include <uttime.h>
#define TRC_GROUP TRC_GROUP_UTILITIES
#undef  TRC_FILE
#define TRC_FILE  "uttime"

extern "C"
{

#include <atrcapi.h>
}

#include "autil.h"

//-----------------------------------------------------------------------------
//
// UT_Timer structure returned as application timer handle
//
//-----------------------------------------------------------------------------

typedef struct _UT_Timer
{
    HWND    hWnd;
    DCUINT  EventId;
    DCUINT  ElaspeTime;
    INT_PTR hTimer;

} UT_TIMER;

typedef UT_TIMER * PUT_TIMER;
typedef PUT_TIMER LPUT_TIMER;

//-----------------------------------------------------------------------------
//
// Function:
//
//      UTCreateTimer
//
// Description:
//
//      Create a timer handle
//
// Parameters:
//
//      hWnd - Window handle to receive timer notification.
//      nIDEvent - Timer ID to identify this timer event
//      uElaspe - Elaspe time before a timer notification is sent
//
// Return:
//
//      A non-NULL handle if successful.  Returns NULL if failed.
//
//
//-----------------------------------------------------------------------------

HANDLE
CUT::UTCreateTimer(
    HWND        hWnd,   
    DCUINT      nIDEvent,
    DCUINT      uElapse )
{
    PUT_TIMER
        pNewTimer;
    
    pNewTimer = ( PUT_TIMER )UTMalloc( sizeof( UT_TIMER ) );

    if( NULL == pNewTimer )
    {
        return( NULL );
    }

    pNewTimer->hWnd = hWnd;
    pNewTimer->EventId = nIDEvent;
    pNewTimer->ElaspeTime = uElapse;
    pNewTimer->hTimer = 0;

    return( ( HANDLE )pNewTimer );
}


//-----------------------------------------------------------------------------
//
// Function:
//
//      UTStartTimer
//
// Description:
//
//      Start the identified by the given timer handle
//
// Parameter:
//
//      Timer handle identifying a timer that was previously created by 
//      UTCreateTimer
//
// Return:
//
//      TRUE if the timer is started successfully or FALSE otherwise.
//
//-----------------------------------------------------------------------------
     
DCBOOL
CUT::UTStartTimer(
    HANDLE      hTimer )
{
    PUT_TIMER
        pTimer = ( PUT_TIMER )hTimer;

    if( NULL == pTimer )
    {
        return( FALSE );
    }

    if( pTimer->hTimer )
    {
        //
        // stop the old timer
        //

        UTStopTimer( hTimer );
    }

    //
    // start a new timer
    //

    pTimer->hTimer = SetTimer( 
                            pTimer->hWnd, 
                            pTimer->EventId, 
                            pTimer->ElaspeTime, 
                            NULL );

    if( 0 == pTimer )
    {
        return( FALSE );
    }

    return( TRUE );
}


//-----------------------------------------------------------------------------
//
// Function:
//
//      UTStopTimer
//
// Description:
//
//      Stops a timer.
//
// Parameters:
//
//      hTimer - Timer handle identifying a timer that was started.
//
// Return:
//
//      TRUE if the timer is stopped successfully or FALSE otherwise.
//
//-----------------------------------------------------------------------------

DCBOOL
CUT::UTStopTimer(
    HANDLE      hTimer )
{
    PUT_TIMER
        pTimer = ( PUT_TIMER )hTimer;

    if( NULL == pTimer )
    {
        return( FALSE );
    }

    if( 0 == pTimer->hTimer )
    {
        return( FALSE );
    }

    if( KillTimer( pTimer->hWnd, pTimer->hTimer ) )
    {
        pTimer->hTimer = 0;
        return( TRUE );
    }
    
    return( FALSE );    
}


//-----------------------------------------------------------------------------
//
// Function:
//
//      UTDeleteTimer
//
// Description:
//
//      Deletes a timer.  The timer handle can no longer be used after it has
//      been deleted.
//
// Parameters:
//
//      hTimer - Timer handle identifying the timer to be deleted.
//
// Return:
//
//      TRUE if the timer is deleted successfully or FALSE otherwise.
//
//-----------------------------------------------------------------------------

DCBOOL
CUT::UTDeleteTimer(
    HANDLE      hTimer )
{
    if( NULL == ( PUT_TIMER )hTimer )
    {
        return( FALSE );
    }

    UTStopTimer( hTimer );

    UTFree( ( PDCVOID )hTimer );

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\debug.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.c
//
//  Contents:   Debugging support functions
//
//  Classes:
//
//  Functions:
//
//  Note:       This file is not compiled for retail builds
//
//  History:    4-29-93   RichardW   Created
//
//----------------------------------------------------------------------------

// #if DBG         // NOTE:  This file not compiled for retail builds
#include "precomp.h"
#pragma hdrstop
#if DBG         // NOTE:  This file not compiled for retail builds

FILE *  LogFile;
DWORD   WinlogonInfoLevel = 3;


// Debugging support functions.

// These two functions do not exist in Non-Debug builds.  They are wrappers
// to the commnot functions (maybe I should get rid of that as well...)
// that echo the message to a log file.

char * DebLevel[] = {   "Winlogon-Error",
                        "Winlogon-Warn",
                        "Winlogon-Trace",
                        "Winlogon-Trace-Init",
                        "Winlogon-Trace-Timeout",
                        "Winlogon-Trace-SAS",
                        "Winlogon-Trace-State",
                        "Winlogon-Trace-MPR",
                        "Should-not-see",
                        "Winlogon-Trace-Profile",
                        "Should-not-see",
                        "Should-not-see",
                        "Should-not-see",
                        "Winlogon-Trace-Migrate",
                        "Should-not-see",
                        "Winlogon-Trace-Setup"
                    };

typedef struct _DebugKeys {
    char *  Name;
    DWORD   Value;
} DebugKeys, *PDebugKeys;

DebugKeys   DebugKeyNames[] = {
                {"Error",       DEB_ERROR},
                {"Warning",     DEB_WARN},
                {"Trace",       DEB_TRACE},
                {"Init",        DEB_TRACE_INIT},
                {"Timeout",     DEB_TRACE_TIMEOUT},
                {"Sas",         DEB_TRACE_SAS},
                {"State",       DEB_TRACE_STATE},
                {"MPR",         DEB_TRACE_MPR},
                {"CoolSwitch",  DEB_COOL_SWITCH},
                {"Profile",     DEB_TRACE_PROFILE},
                {"DebugLsa",    DEB_DEBUG_LSA},
                {"DebugSpm",    DEB_DEBUG_LSA},
                {"DebugMpr",    DEB_DEBUG_MPR},
                {"DebugGo",     DEB_DEBUG_NOWAIT},
                {"Migrate",     DEB_TRACE_MIGRATE},
                {"DebugServices", DEB_DEBUG_SERVICES},
                {"Setup",       DEB_TRACE_SETUP}
                };

#define NUM_DEBUG_KEYS  sizeof(DebugKeyNames) / sizeof(DebugKeys)
#define NUM_BREAK_KEYS  sizeof(BreakKeyNames) / sizeof(DebugKeys)

//+---------------------------------------------------------------------------
//
//  Function:   LogEvent
//
//  Synopsis:   Logs an event to the console and, optionally, a file.
//
//  Effects:
//
//  Arguments:  [Mask]   --
//              [Format] --
//              [Format] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    4-29-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void
LogEvent(   long            Mask,
            const char *    Format,
            ...)
{
    va_list ArgList;
    int     Level = 0;
    int     PrefixSize = 0;
    char    szOutString[256];
    long    OriWinlogonlMask = Mask;


    if (Mask & WinlogonInfoLevel)
    {
        while (!(Mask & 1))
        {
            Level++;
            Mask >>= 1;
        }
        if (Level >= (sizeof(DebLevel) / sizeof(char *)) )
        {
            Level = (sizeof(DebLevel) / sizeof(char *)) - 1;
        }


        //
        // Make the prefix first:  "Process.Thread> Winlogon-XXX"
        //

        PrefixSize = sprintf(szOutString, "%d.%d> %s: ",
                GetCurrentProcessId(), GetCurrentThreadId(), DebLevel[Level]);


        va_start(ArgList, Format);

        if (_vsnprintf(&szOutString[PrefixSize], sizeof(szOutString) - PrefixSize,
                            Format, ArgList) < 0)
        {
            //
            // Less than zero indicates that the string could not be
            // fitted into the buffer.  Output a special message indicating
            // that:
            //

            OutputDebugStringA("Winlogon!LogEvent:  Could not pack string into 256 bytes\n");

        }
        else
        {
            OutputDebugStringA(szOutString);
        }


        if (LogFile)
        {
            SYSTEMTIME  stTime;
            FILETIME    ftTime;
            FILETIME    localtime;

            NtQuerySystemTime((PLARGE_INTEGER) &ftTime);
            FileTimeToLocalFileTime(&ftTime, &localtime);
            FileTimeToSystemTime(&localtime, &stTime);
            fprintf(LogFile, "%02d:%02d:%02d.%03d: %s\n",
                    stTime.wHour, stTime.wMinute, stTime.wSecond,
                    stTime.wMilliseconds, szOutString);

            fflush(LogFile);
        }

    }

}

void
OpenLogFile(LPSTR   pszLogFile)
{
    LogFile = fopen(pszLogFile, "a");
    if (!LogFile)
    {
        OutputDebugStringA("Winlogon: Could not open logfile for append");
        OutputDebugStringA(pszLogFile);
    }
    DebugLog((DEB_TRACE, "Log file '%s' begins\n", pszLogFile));
}


DWORD
GetDebugKeyValue(
    PDebugKeys      KeyTable,
    int             cKeys,
    LPSTR           pszKey)
{
    int     i;

    for (i = 0; i < cKeys ; i++ )
    {
        if (_strcmpi(KeyTable[i].Name, pszKey) == 0)
        {
            return(KeyTable[i].Value);
        }
    }
    return(0);
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadDebugParameters
//
//  Synopsis:   Loads debug parameters from win.ini
//
//  Effects:
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    4-29-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


void
LoadDebugParameters(char * szSection)
{
    char    szVal[128];
    char *  pszDebug;
    int     cbVal;

    cbVal = GetProfileStringA(szSection, "DebugFlags", "Error,Warning", szVal, sizeof(szVal));

    pszDebug = strtok(szVal, ", \t");
    while (pszDebug)
    {
        WinlogonInfoLevel |= GetDebugKeyValue(DebugKeyNames, NUM_DEBUG_KEYS, pszDebug);
        pszDebug = strtok(NULL, ", \t");
    }

    cbVal = GetProfileStringA(szSection, "LogFile", "", szVal, sizeof(szVal));
    if (cbVal)
    {
        OpenLogFile(szVal);
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   InitDebugSupport
//
//  Synopsis:   Initializes debugging support for the Winlogon
//
//  Effects:
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    4-29-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


void
InitDebugSupport(void)
{
    LoadDebugParameters("WinlogonDebug");
    LoadDebugParameters("Winlogon");

}



#else // DBG

//#pragma warning(disable:4206)   // Disable the empty transation unit
                                // warning/error

#endif  // NOTE:  This file not compiled for retail builds
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\ctxmon.c ===
/*******************************************************************************
*
*  CTXMON.C
*
*     This module contains code to monitor user processes
*
*  Copyright Microsoft, 1997
*
*  Author:
*
*
*******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <ntexapi.h>
#include "winreg.h"

/*=============================================================================
==   Local Defines
=============================================================================*/

#define BUFFER_SIZE 32*1024
#define MAXNAME 18


BOOL IsSystemLUID(HANDLE ProcessId);
//
// This table contains common NT system programs
//
DWORD dwNumberofSysProcs = 0;
LPTSTR *SysProcTable;

typedef struct {
    HANDLE hProcess;
    HANDLE TerminateEvent;
    //HWND hwndNotify;
    HANDLE Thread;
} USER_PROCESS_MONITOR, * PUSER_PROCESS_MONITOR;


/*=============================================================================
==   Internal Procedures
=============================================================================*/

HANDLE OpenUserProcessHandle();
BOOLEAN IsSystemProcess( PSYSTEM_PROCESS_INFORMATION);

/*=============================================================================
==   External Procedures
=============================================================================*/

VOID LookupSidUser( PSID pSid, PWCHAR pUserName, PULONG pcbUserName );

HANDLE
ImpersonateUser(
    HANDLE      UserToken,
    HANDLE      ThreadHandle
    );

BOOL
StopImpersonating(
    HANDLE  ThreadHandle
    );


BOOL CreateSystemProcList ()
{
	DWORD dwIndex;
    DWORD dwLongestProcName = 0;
    DWORD dwSize = 0;
    HKEY  hKeySysProcs = NULL;
    DWORD   iValueIndex = 0;
	LONG lResult;

    const LPCTSTR SYS_PROC_KEY = TEXT("SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\SysProcs");

    // to start with.
    SysProcTable = NULL;
    dwNumberofSysProcs = 0;


    lResult = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,         // handle of open key
        SYS_PROC_KEY,               // address of name of subkey to open
        0 ,                         // reserved
        KEY_READ,					// security access mask
        &hKeySysProcs               // address of handle of open key
        );

    if (lResult != ERROR_SUCCESS)
    {
        return FALSE;
    }

    lResult = RegQueryInfoKey(
          hKeySysProcs,                   // handle to key
          NULL,                           // class buffer
          NULL,                           // size of class buffer
          NULL,                           // reserved
          NULL,                           // number of subkeys
          NULL,                           // longest subkey name
          NULL,                           // longest class string
          &dwNumberofSysProcs,            // number of value entries
          &dwLongestProcName,             // longest value name
          NULL,                           // longest value data
          NULL,                           // descriptor length
          NULL                            // last write time
          );

    if (lResult != ERROR_SUCCESS || dwNumberofSysProcs == 0)
    {
		dwNumberofSysProcs = 0;
        RegCloseKey(hKeySysProcs);
        return FALSE;
    }


    dwLongestProcName += 1;  // provision for the terminating null
    SysProcTable = LocalAlloc(LPTR, sizeof(LPTSTR) * dwNumberofSysProcs);
	if (!SysProcTable)
	{
        SysProcTable = NULL;
        dwNumberofSysProcs = 0;
        RegCloseKey(hKeySysProcs);
        return FALSE;
	}

    for (dwIndex = 0; dwIndex < dwNumberofSysProcs; dwIndex++)
    {
        SysProcTable[dwIndex] = (LPTSTR) LocalAlloc(LPTR, dwLongestProcName * sizeof(TCHAR));

        if (SysProcTable[dwIndex] == NULL)
        {
            //
            // if we failed to alloc bail out.
            //

            while (dwIndex)
            {
                LocalFree(SysProcTable[dwIndex-1]);
                dwIndex--;
            }

            LocalFree(SysProcTable);
            SysProcTable = NULL;
            dwNumberofSysProcs = 0;
            RegCloseKey(hKeySysProcs);


            return FALSE;
        }

    }

    iValueIndex = 0;
    while (iValueIndex < dwNumberofSysProcs)
    {
        dwSize = dwLongestProcName;
        lResult = RegEnumValue(
                    hKeySysProcs,               // handle of key to query
                    iValueIndex,                // index of value to query
                    SysProcTable[iValueIndex],  // address of buffer for value string
                    &dwSize,                    // address for size of value buffer
                    0,                          // reserved
                    NULL,                       // address of buffer for type code
                    NULL,                       // address of buffer for value data
                    NULL                        // address for size of data buffer
                    );

        if (lResult != ERROR_SUCCESS)
        {
            lstrcpy(SysProcTable[iValueIndex], TEXT("")); // this is an invalid entry.

            if (lResult == ERROR_NO_MORE_ITEMS)
                break;
        }

        iValueIndex++;
    }


    return TRUE;
}

void DestroySystemprocList ()
{
	DWORD dwIndex;
    if (SysProcTable)
    {
        for (dwIndex = 0; dwIndex < dwNumberofSysProcs; dwIndex++)
        {
            if (SysProcTable[dwIndex])
            {
                LocalFree(SysProcTable[dwIndex]);
            }

        }

        LocalFree(SysProcTable);
        SysProcTable = NULL;
        dwNumberofSysProcs = 0;
    }
}

/***************************************************************************\
* FUNCTION: UserProcessMonitorThread
*
*    Thread monitoring user processes. It intiates a LOGOFF when there
*      are no more user processes.
*
*
\***************************************************************************/

DWORD UserProcessMonitorThread(
    LPVOID lpThreadParameter
    )
{
    PUSER_PROCESS_MONITOR pMonitor = (PUSER_PROCESS_MONITOR)lpThreadParameter;
    HANDLE ImpersonationHandle;
    DWORD WaitResult;
    HANDLE WaitHandle;
    HKEY hKey;
    DWORD dwVal = 0;


    //This value should be per user
    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Control\\WOW", 0,
                      KEY_WRITE, &hKey) == ERROR_SUCCESS) {

        //
        // Set the SharedWowTimeout to zero so that WOW exits as soon as all the 16 bit
        // processes are gone
        //
        RegSetValueEx (hKey, L"SharedWowTimeout", 0, REG_DWORD, (LPBYTE)&dwVal,
                       sizeof(DWORD));

        RegCloseKey(hKey);

    }

    if (!CreateSystemProcList ())
		DebugLog((DEB_ERROR, "ERROR, CreateSystemProcList failed.\n", GetLastError()));

    for (;;) {
        if ( !(pMonitor->hProcess = OpenUserProcessHandle()) ) {

            break;

        }

        // Wait for process to exit or terminate event to be signaled
        WaitResult = WaitForMultipleObjects( 2, &pMonitor->hProcess,
                                              FALSE, (DWORD)-1 );

        if ( WaitResult == 1 ) {          // if terminate event was signaled
            CloseHandle( pMonitor->hProcess );
            DestroySystemprocList ();

            return(0);
        }
    }

    DestroySystemprocList ();


    //
    // Initiate logoff
    //

    ImpersonationHandle = ImpersonateUser(g_UserToken , NULL );

    if( ImpersonationHandle ) {
        ExitWindowsEx(EWX_LOGOFF, 0);
        StopImpersonating(ImpersonationHandle);
    }

    WaitForSingleObject( pMonitor->TerminateEvent, (DWORD)-1 );

    return(0);
}


/***************************************************************************\
* FUNCTION: StartUserProcessMonitor
*
* PURPOSE:  Creates a thread to monitor user processes
*
\***************************************************************************/

LPVOID
StartUserProcessMonitor(
    //HWND hwndNotify
    )
{
    PUSER_PROCESS_MONITOR pMonitor;
    DWORD ThreadId;

    pMonitor = LocalAlloc(LPTR, sizeof(USER_PROCESS_MONITOR));
    if (pMonitor == NULL) {
        return(NULL);
    }

    //
    // Initialize monitor fields
    //

    //pMonitor->hwndNotify = hwndNotify;
    pMonitor->TerminateEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

    //
    // Create the monitor thread
    //

    pMonitor->Thread = CreateThread(
                        NULL,                       // Use default ACL
                        0,                          // Same stack size
                        UserProcessMonitorThread,   // Start address
                        (LPVOID)pMonitor,           // Parameter
                        0,                          // Creation flags
                        &ThreadId                   // Get the id back here
                        );
    if (pMonitor->Thread == NULL) {
        DebugLog((DEB_ERROR, "Failed to create monitor thread, error = %d", GetLastError()));
        LocalFree(pMonitor);
        return(NULL);
    }

    return((LPVOID)pMonitor);
}



VOID
DeleteUserProcessMonitor(
    LPVOID Parameter
    )
{
    PUSER_PROCESS_MONITOR pMonitor = (PUSER_PROCESS_MONITOR)Parameter;
    BOOL Result;


    if (!pMonitor)
        return;

    // Set the terminate event for this monitor
    // and wait for the monitor thread to exit
    SetEvent( pMonitor->TerminateEvent );
    if ( WaitForSingleObject( pMonitor->Thread, 5000 ) == WAIT_TIMEOUT )
        (VOID)TerminateThread(pMonitor->Thread, ERROR_SUCCESS);

    //
    // Close our handle to the monitor thread
    //

    Result = CloseHandle(pMonitor->Thread);
    if (!Result) {
        DebugLog((DEB_ERROR, "DeleteUserProcessMonitor: failed to close monitor thread, error = %d\n", GetLastError()));
    }

    //
    // Delete monitor object
    //

    CloseHandle(pMonitor->TerminateEvent);
    LocalFree(pMonitor);
}


HANDLE
OpenUserProcessHandle()
{
    HANDLE  ProcessHandle = NULL; // handle to notify process
    int rc;
    //WCHAR UserName[USERNAME_LENGTH];
    ULONG SessionId;
    //PSID pUserSid;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    SYSTEM_SESSION_PROCESS_INFORMATION SessionProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    PBYTE pBuffer;
    ULONG ByteCount;
    NTSTATUS status;
    ULONG MaxLen;
    ULONG TotalOffset;
    BOOL RetryIfNoneFound;
    ULONG retlen = 0;

    ByteCount = BUFFER_SIZE;

Retry:
    RetryIfNoneFound = FALSE;

    SessionProcessInfo.SessionId = g_SessionId;

    for(;;) {

        if ( (pBuffer = LocalAlloc(LPTR, ByteCount )) == NULL ) {
            return(NULL);
        }

        SessionProcessInfo.Buffer = pBuffer;
        SessionProcessInfo.SizeOfBuf = ByteCount;

        /*
         *  get process info
         */
        status = NtQuerySystemInformation(
                        SystemSessionProcessInformation,
                        &SessionProcessInfo,
                        sizeof(SessionProcessInfo),
                        &retlen );

        if ( NT_SUCCESS(status) )
            break;

        /*
         *  Make sure buffer is big enough
         */
        if ( status != STATUS_INFO_LENGTH_MISMATCH ) {
            LocalFree ( pBuffer );
            return(NULL);
        }

        LocalFree( pBuffer );
        ByteCount *= 2;
    }

    if (retlen == 0) {
       LocalFree(pBuffer);
       return NULL;
    } 

    /*
     * Loop through all processes. Find first process running on this station
     */
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pBuffer;
    TotalOffset = 0;
    rc = 0;

    for(;;) {

        ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);

//        SessionId = ProcessInfo->SessionId;

//        if (SessionId == g_SessionId) {

         /*
          * Get the User name for the SID of the process.
          */
         MaxLen = USERNAME_LENGTH;
         
         //LookupSidUser( pUserSid, UserName, &MaxLen);
         
         ProcessHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE,
                                     (DWORD)(UINT_PTR)ProcessInfo->UniqueProcessId);

         //
         // OpenProcess may fail for System processes like csrss.exe if we do not have enough privilege
         // In that case, we just skip that process because we r not worried about System processes anyway
         //
         if (!ProcessHandle && (GetLastError() == ERROR_ACCESS_DENIED) ) {
             goto NextProcess;
         }

         if ( ProcessHandle && !IsSystemLUID(ProcessHandle) && !IsSystemProcess( ProcessInfo) &&
              (ThreadInfo->ThreadState != 4) ) {
             //
             // Open the process for the monitor thread.
             //
         
         
                 break;
         }
         
         if (ProcessHandle) {
             CloseHandle(ProcessHandle);
             ProcessHandle = NULL;
         } else {

             //
             // When OpenProcess fails, it means the process is already
             // gone. This can happen if the list is sufficiently long.
             // If for example the process was userinit.exe, it may have
             // spawned progman and exited by the time we see the entry
             // for userinit. But, since this is a snapshot of the list
             // of processes, progman may not be in this snapshot. So,
             // if we don't find any processes in this list, we have to
             // get another snapshot to avoid prematurely logging off the
             // user.
             //
             RetryIfNoneFound = TRUE;
         
         }

//        }

NextProcess:
        if( ProcessInfo->NextEntryOffset == 0 ) {
            break;
        }
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&pBuffer[TotalOffset];
    }

    LocalFree( pBuffer );

    if (!ProcessHandle && RetryIfNoneFound) {
        Sleep(4000);
        goto Retry;
    }

    return(ProcessHandle);
}




BOOL IsSystemLUID(HANDLE ProcessId)
{
    HANDLE      TokenHandle;
    UCHAR       TokenInformation[ sizeof( TOKEN_STATISTICS ) ];
    ULONG       ReturnLength;
    LUID        CurrentLUID = { 0, 0 };
    LUID        SystemLUID = SYSTEM_LUID;
    NTSTATUS Status;


    Status = NtOpenProcessToken( ProcessId,
                                 TOKEN_QUERY,
                                 &TokenHandle );
    if ( !NT_SUCCESS( Status ) )
        return(TRUE);

    NtQueryInformationToken( TokenHandle, TokenStatistics, &TokenInformation,
                             sizeof(TokenInformation), &ReturnLength );
    NtClose( TokenHandle );

    RtlCopyLuid(&CurrentLUID,
                &(((PTOKEN_STATISTICS)TokenInformation)->AuthenticationId));


    if (RtlEqualLuid(&CurrentLUID, &SystemLUID)) {
        return(TRUE);
    } else {
        return(FALSE );
    }
}


/******************************************************************************
 *
 * IsSystemProcess
 *
 *   Return whether the given process described by SYSTEM_PROCESS_INFORMATION
 *   is an NT "system" process, and not a user program.
 *
 *  ENTRY:
 *  pProcessInfo (input)
 *      Pointer to an NT SYSTEM_PROCESS_INFORMATION structure for a single
 *      process.
 *  EXIT:
 *    TRUE if this is an NT system process; FALSE if a general user process.
 *
 *****************************************************************************/

BOOLEAN
IsSystemProcess( PSYSTEM_PROCESS_INFORMATION pSysProcessInfo)
{
    DWORD dwIndex;
	WCHAR *WellKnownSysProcTable[] = {
		L"csrss.exe",
		L"smss.exe",
		L"screg.exe",
		L"lsass.exe",
		L"spoolss.exe",
		L"EventLog.exe",
		L"netdde.exe",
		L"clipsrv.exe",
		L"lmsvcs.exe",
		L"MsgSvc.exe",
		L"winlogon.exe",
		L"NETSTRS.EXE",
		L"nddeagnt.exe",
		L"os2srv.exe",
		L"wfshell.exe",
		L"win.com",
		L"rdpclip.exe",
		L"conime.exe",
		L"proquota.exe",
        L"imepadsv.exe",
        L"ctfmon.exe",
		NULL
		};


	if (dwNumberofSysProcs == 0)
	{
		/*
		 * we failed to read the sys processes from registry. so lets fall back to our well known proc list.
		 */
		for( dwIndex=0; WellKnownSysProcTable[dwIndex]; dwIndex++) {
			if ( !_wcsnicmp( pSysProcessInfo->ImageName.Buffer,
							WellKnownSysProcTable[dwIndex],
							pSysProcessInfo->ImageName.Length) ) {
				return(TRUE);
			}
		}


	}
	else
	{
		/*
		 * Compare its image name against some well known system image names.
		 */
		for( dwIndex=0; dwIndex < dwNumberofSysProcs; dwIndex++) {
			if ( !_wcsnicmp( pSysProcessInfo->ImageName.Buffer,
							SysProcTable[dwIndex],
							pSysProcessInfo->ImageName.Length) ) {
				return(TRUE);
			}
		}
	}
    return(FALSE);

}  /* IsSystemProcess() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\drdbg.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name :
    
    drdbg.h

Abstract:

    User-Mode RDP Device Redirector Debugging Module.

Author:

    TadB

Revision History:
--*/

#ifndef _DRDBG_
#define _DRDBG_

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//  We can run a stand-alone unit test for testing.
//#define UNITTEST


////////////////////////////////////////////////////////
//      
//      Debugging
//
#undef ASSERT

// Used to scramble released memory.
#define DBG_GARBAGEMEM  0xCC

// Debug message levels
#define DBG_NONE        0x0000
#define DBG_INFO        0x0001
#define DBG_WARN        0x0002
#define DBG_WARNING     0x0002
#define DBG_ERROR       0x0004
#define DBG_TRACE       0x0008
#define DBG_SECURITY    0x0010
#define DBG_EXEC        0x0020
#define DBG_PORT        0x0040
#define DBG_NOTIFY      0x0080
#define DBG_PAUSE       0x0100
#define DBG_ASSERT      0x0200
#define DBG_THREADM     0x0400
#define DBG_MIN         0x0800
#define DBG_TIME        0x1000
#define DBG_FOLDER      0x2000
#define DBG_NOHEAD      0x8000

#if DBG
ULONG DbgPrint(PCH Format, ...);

VOID DbgBreakPoint(VOID);

/* These flags are not used as arguments to the DBGMSG macro.
 * You have to set the high word of the global variable to cause it to break.
 * It is ignored if used with DBGMSG.
 * (Here mainly for explanatory purposes.)
 */
#define DBG_BREAK_ON_WARNING    ( DBG_WARNING << 16 )
#define DBG_BREAK_ON_ERROR      ( DBG_ERROR << 16 )

/* Double braces are needed for this one, e.g.:
 *
 *     DBGMSG( DBG_ERROR, ( "Error code %d", Error ) );
 *
 * This is because we can't use variable parameter lists in macros.
 * The statement gets pre-processed to a semi-colon in non-debug mode.
 *
 * Set the global variable GLOBAL_DEBUG_FLAGS via the debugger.
 * Setting the flag in the low word causes that level to be printed;
 * setting the high word causes a break into the debugger.
 * E.g. setting it to 0x00040006 will print out all warning and error
 * messages, and break on errors.
 */
#define DBGMSG( Level, MsgAndArgs ) \
{                                   \
    if( ( Level & 0xFFFF ) & GLOBAL_DEBUG_FLAGS ) \
        DbgPrint MsgAndArgs;      \
    if( ( Level << 16 ) & GLOBAL_DEBUG_FLAGS ) \
        DbgBreakPoint(); \
}

#define ASSERT(expr)                      \
    if (!(expr)) {                           \
        DbgPrint( "Failed: %s\nLine %d, %s\n", \
                                #expr,       \
                                __LINE__,    \
                                __FILE__ );  \
        DebugBreak();                        \
    }

#else
#define DBGMSG
#define ASSERT(exp)
#endif

#ifdef __cplusplus
}
#endif // __cplusplus


#endif // #ifndef _DRDBG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-02-94   RichardW   Created
//
//----------------------------------------------------------------------------


#ifndef __DEBUG_H__
#define __DEBUG_H__

#if DBG

extern  DWORD   WinlogonInfoLevel;
extern  DWORD   GinaBreakFlags;

#define DebugLog(x) LogEvent x


void    LogEvent(long, const char *, ...);
void    InitDebugSupport(void);

#define DEB_ERROR           0x00000001
#define DEB_WARN            0x00000002
#define DEB_TRACE           0x00000004
#define DEB_TRACE_INIT      0x00000008
#define DEB_TRACE_TIMEOUT   0x00000010
#define DEB_TRACE_SAS       0x00000020
#define DEB_TRACE_STATE     0x00000040
#define DEB_TRACE_MPR       0x00000080
#define DEB_COOL_SWITCH     0x00000100
#define DEB_TRACE_PROFILE   0x00000200
#define DEB_DEBUG_LSA       0x00000400
#define DEB_DEBUG_MPR       0x00000800
#define DEB_DEBUG_NOWAIT    0x00001000
#define DEB_TRACE_MIGRATE   0x00002000
#define DEB_DEBUG_SERVICES  0x00004000
#define DEB_TRACE_SETUP     0x00008000



#else

#define DebugLog(x)
#define InitDebugSupport()


#endif



#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\drdevlst.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name :
    
    drdevlst.c

Abstract:

    Manage a list of installed devices for the user-mode RDP device manager
    component.

Author:

    TadB

Revision History:
--*/

#include "precomp.h"
#pragma hdrstop
#include "drdbg.h"
#include "drdevlst.h"
#include "errorlog.h"
#include "tsnutl.h"
#include <time.h>

void 
DRDEVLST_Create(
    IN PDRDEVLST    list
    )
/*++

Routine Description:

  Create a new device list.

Arguments:

    list        - Installed device list.        

Return Value:

    None

--*/
{
    list->devices = NULL;
    list->deviceCount = 0;
    list->listSize = 0;
}

void 
DRDEVLST_Destroy(
    IN PDRDEVLST    list
    )
/*++

Routine Description:

    Destroy a device list.  Note that the pointer to the list is not released.

Arguments:

    list        - Installed device list.        

Return Value:

    None

--*/
{
    ASSERT(list != NULL);

    if (list->devices != NULL) {
#if DBG
        ASSERT(list->listSize > 0);
        memset(list->devices, DBG_GARBAGEMEM, list->listSize);
#endif
        FREEMEM(list->devices);
    }
#if DBG
    else {
        ASSERT(list->listSize == 0);
    }
#endif
    list->listSize      = 0;
    list->deviceCount   = 0;
    list->devices       = NULL;
}

BOOL DRDEVLST_Add(
    IN PDRDEVLST    list,
    IN DWORD        clientDeviceID,
    IN DWORD        serverDeviceID,
    IN DWORD        deviceType,
    IN PCWSTR       serverDeviceName,
    IN PCWSTR       clientDeviceName,
    IN PCSTR        preferredDosName
    )
/*++

Routine Description:

  Add a device to a device management list.

Arguments:

    list                - Device list.        
    clientDeviceID      - ID for new device assigned by client component.
    serverDeviceID      - ID for new device assigned by server component.           
    deviceType          - Is it a printer, etc.
    serverDeviceName    - Server-designated device name.
    clientDeviceName    - Client-designated device name.

Return Value:
    
    Return TRUE on success.  FALSE, otherwise.      

--*/
{
    DWORD count;
    DWORD bytesRequired;
    DWORD len;
    BOOL result = TRUE;

    ASSERT(list != NULL);

    // 
    //  Size the device list if necessary.
    //
    bytesRequired = (list->deviceCount+1) * sizeof(DRDEVLSTENTRY);
    if (list->listSize < bytesRequired) {
        if (list->devices == NULL) {
            list->devices = ALLOCMEM(bytesRequired);
        }
        else {
            PDRDEVLSTENTRY pBuf = REALLOCMEM(list->devices, bytesRequired);

            if (pBuf != NULL) {
                list->devices = pBuf;
            } else {
                FREEMEM(list->devices);
                list->devices = NULL;
                list->deviceCount = 0;
            }
        }
        if (list->devices == NULL) {
            list->listSize = 0;
        }
        else {
            list->listSize = bytesRequired;
        }
    }

    //
    //  Add the new device.
    //
    if (list->devices != NULL) {
        
        //
        //  Allocate room for the variable-length string fields.
        //
        len = wcslen(serverDeviceName) + 1;
        list->devices[list->deviceCount].serverDeviceName = 
                (WCHAR *)ALLOCMEM(len * sizeof(WCHAR));
        result = (list->devices[list->deviceCount].serverDeviceName != NULL);

        if (result) {
            len = wcslen(clientDeviceName) + 1;
            list->devices[list->deviceCount].clientDeviceName = 
                    (WCHAR *)ALLOCMEM(len * sizeof(WCHAR));
            result = (list->devices[list->deviceCount].clientDeviceName != NULL);

            //
            //  Clean up the first alloc if we failed here.
            //
            if (!result) {
                FREEMEM(list->devices[list->deviceCount].serverDeviceName);
                list->devices[list->deviceCount].serverDeviceName = NULL;
            }
        }

        //
        //  Copy the fields and add a timestamp for when the device was installed.
        //
        if (result) {
            wcscpy(list->devices[list->deviceCount].serverDeviceName, serverDeviceName);
            wcscpy(list->devices[list->deviceCount].clientDeviceName, clientDeviceName);
            strcpy(list->devices[list->deviceCount].preferredDosName, preferredDosName);
            list->devices[list->deviceCount].clientDeviceID = clientDeviceID;
            list->devices[list->deviceCount].serverDeviceID = serverDeviceID;
            list->devices[list->deviceCount].deviceType = deviceType;
            list->devices[list->deviceCount].fConfigInfoChanged = FALSE;
            list->devices[list->deviceCount].installTime = time(NULL);
            list->devices[list->deviceCount].deviceSpecificData = NULL;
            list->deviceCount++;
        }
    }
    else {
        result = FALSE;
    }

    if (!result) {
        //
        //  Current failure scenarios are restricted to memory allocation failures.
        // 
        TsLogError(EVENT_NOTIFY_INSUFFICIENTRESOURCES, EVENTLOG_ERROR_TYPE, 
            0, NULL, __LINE__);
    }
    return result;
}

void
DRDEVLST_Remove(
    IN PDRDEVLST    list,
    IN DWORD        offset
    )
/*++

Routine Description:

    Remove the device at the specified offset.

Arguments:

    list   -    Device list.        
    offset -    Offset of element in installed devices list.

Return Value:

    None.

--*/
{
    DWORD toMove;

    ASSERT(list != NULL);
    ASSERT(offset < list->deviceCount);
    ASSERT(list->deviceCount > 0);

    ASSERT(list->devices[offset].deviceSpecificData == NULL);

    //
    //  Release variable-length string fields.
    //
    if (list->devices[offset].serverDeviceName != NULL) {
        FREEMEM(list->devices[offset].serverDeviceName);
    }
    if (list->devices[offset].clientDeviceName != NULL) {
        FREEMEM(list->devices[offset].clientDeviceName);
    }

    //
    //  Remove the deleted element.
    //
    if (offset < (list->deviceCount-1)) {
        toMove = list->deviceCount - offset - 1;
        memmove(&list->devices[offset], &list->devices[offset+1], 
                sizeof(DRDEVLSTENTRY) * toMove);
    }
    list->deviceCount--;

}

BOOL
DRDEVLST_FindByClientDeviceID(
    IN PDRDEVLST    list,
    IN DWORD        clientDeviceID,
    IN DWORD        *ofs
    )
/*++

Routine Description:

    Returns the offset of the device with the specified client-assigned id.

Arguments:

    list            -    Device list
    clientDeviceID  -    ID assigned by client for device to return.
    ofs             -    Offset of found element.

Return Value:

    TRUE if the specified device is found.  Otherwise, FALSE.

--*/
{
    ASSERT(list != NULL);

    for (*ofs=0; *ofs<list->deviceCount; (*ofs)++) {
        if (list->devices[*ofs].clientDeviceID == clientDeviceID) 
            break;
    }
    return(*ofs<list->deviceCount);
}

BOOL
DRDEVLST_FindByClientDeviceIDAndDeviceType(
    IN PDRDEVLST    list,
    IN DWORD        clientDeviceID,
    IN DWORD        deviceType,
    IN DWORD        *ofs
    )
/*++

Routine Description:

    Returns the offset of the device with the specified client-assigned id and device type.

Arguments:

    list            -    Device list
    clientDeviceID  -    ID assigned by client for device to return.
    deviceType      -    Device Type
    ofs             -    Offset of found element.

Return Value:

    TRUE if the specified device is found.  Otherwise, FALSE.

--*/
{
    ASSERT(list != NULL);

    for (*ofs=0; *ofs<list->deviceCount; (*ofs)++) {
        if ((list->devices[*ofs].clientDeviceID == clientDeviceID) &&
            (list->devices[*ofs].deviceType == deviceType))
            break;
    }
    return(*ofs<list->deviceCount);
}


BOOL
DRDEVLST_FindByServerDeviceID(
    IN PDRDEVLST    list,
    IN DWORD        serverDeviceID,
    IN DWORD        *ofs
    )
/*++

Routine Description:

    Returns the offset of the device with the specified server-assigned id.

Arguments:

    list            -    Device list
    serverDeviceID  -    ID assigned by server for device to return.
    ofs             -    Offset of found element.

Return Value:

    TRUE if the specified device is found.  Otherwise, FALSE.

--*/
{
    ASSERT(list != NULL);

    for (*ofs=0; *ofs<list->deviceCount; (*ofs)++) {
        if (list->devices[*ofs].serverDeviceID == serverDeviceID) 
            break;
    }
    return(*ofs<list->deviceCount);
}

BOOL 
DRDEVLST_FindByServerDeviceName(
    IN PDRDEVLST    list,
    IN PCWSTR       serverDeviceName,
    IN DWORD        *ofs
    )
/*++

Routine Description:

    Returns the offset of the device with the specified name.

Arguments:

    list              -    Device list
    serverDeviceName  -    Server-designated device name of element to return.
    ofs               -    Offset of found element.

Return Value:

    TRUE if the specified device is found.  Otherwise, FALSE.

--*/
{
    ASSERT(list != NULL);

    for (*ofs=0; *ofs<list->deviceCount; (*ofs)++) {
        if (!wcscmp(list->devices[*ofs].serverDeviceName, serverDeviceName)) 
            break;
    }
    return(*ofs<list->deviceCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\errorlog.h ===
/****************************************************************************/
// errorlog.h
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/

#include <notifyev.h>

void
TsInitLogging();

void 
TsStopLogging();
    
void
TsLogError(
    IN DWORD dwEventID,
    IN DWORD dwErrorType,
    IN int nStringsCount,
    IN WCHAR * pStrings[],
    DWORD LineNumber
    );

void TsPopupError(
    IN DWORD dwEventID,
    IN WCHAR * pStrings[]
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\drdevlst.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name :
    
    drdevlst.h

Abstract:

    Manage a list of installed devices for the user-mode RDP device manager
    component.

Author:

    TadB

Revision History:
--*/

#ifndef _DRDEVLST_
#define _DRDEVLST_

#include <rdpdr.h>

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
//  Device List Definitions
//
typedef struct tagDRDEVLSTENTRY
{
    DWORD   clientDeviceID;             // Client-given device ID.
    DWORD   serverDeviceID;             // Server-given device ID.
    DWORD   deviceType;         
    BOOL    fConfigInfoChanged;
    WCHAR  *serverDeviceName;           // Server-designated device name
    WCHAR  *clientDeviceName;           // Client-designated device name
    UCHAR   preferredDosName[PREFERRED_DOS_NAME_SIZE];
    time_t  installTime;                // Time device was installed.
    PVOID   deviceSpecificData;        // Hook for additional device-specific
                                        //  data.
} DRDEVLSTENTRY, *PDRDEVLSTENTRY;

typedef struct tagDRDEVLST
{
    PDRDEVLSTENTRY  devices;     
    DWORD           deviceCount;// Number of elements in device list.
    DWORD           listSize;   // Size, in bytes, of the device list.
} DRDEVLST, *PDRDEVLST;

// Create a new device list.
void DRDEVLST_Create(
    IN PDRDEVLST    list
    );

// Destroy a device list.  Note that the pointer to the list is not released.
void DRDEVLST_Destroy(
    IN PDRDEVLST    list
    );

// Add a device to a device management list.
BOOL DRDEVLST_Add(
    IN PDRDEVLST    list,
    IN DWORD        clientDeviceID,
    IN DWORD        serverDeviceID,
    IN DWORD        deviceType,
    IN PCWSTR       serverDeviceName,
    IN PCWSTR       clientDeviceName,
    IN PCSTR        preferredDosName
    );

// Remove the device at the specified offset.
void DRDEVLST_Remove(
    IN PDRDEVLST    list,
    IN DWORD        offset
    );

// Return the offset of the device with the specified id.
BOOL DRDEVLST_FindByClientDeviceID(
    IN PDRDEVLST    list,
    IN DWORD        clientDeviceID,
    IN DWORD        *ofs
    );

// Return the offset of the device with the specified id and device type.
BOOL DRDEVLST_FindByClientDeviceIDAndDeviceType(
    IN PDRDEVLST    list,
    IN DWORD        clientDeviceID,
    IN DWORD        deviceType,
    IN DWORD        *ofs
    );

// Returns the offset of the device with the specified server-assigned id.
BOOL DRDEVLST_FindByServerDeviceID(
    IN PDRDEVLST    list,
    IN DWORD        serverDeviceID,
    IN DWORD        *ofs
    );

// Return the offset of the device with the specified name.
BOOL DRDEVLST_FindByServerDeviceName(
    IN PDRDEVLST    list,
    IN PCWSTR       serverDeviceName,
    IN DWORD        *ofs
    );

#ifdef __cplusplus
}
#endif // __cplusplus

#endif //#ifndef _DRDEVLST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\execsrv.c ===
/*************************************************************************
*
* execsvr.c
*
* Remote CreateProcess server to allow programs to be started on a given
* Session. Needed for OLE2 support.
*
* NOTE: Maybe this should be converted to RPC in the future when we
*       have more time so that it can be a more general facility.
*
* copyright notice: Microsoft, 1997
*
* Author:
*
*
*************************************************************************/

#define UNICODE 1

#include "precomp.h"
#pragma hdrstop
#include <execsrv.h>
#include <wincrypt.h>

HANDLE ExecThreadHandle = NULL;
HANDLE ExecServerPipe = NULL;

static HANDLE ghUserToken = NULL;
extern CRITICAL_SECTION GlobalsLock;


DWORD
ExecServerThread(
    LPVOID lpThreadParameter
    );


BOOLEAN
ProcessExecRequest(
    HANDLE hPipe,
    PCHAR  pBuf,
    DWORD  AmountRead
    );

HANDLE
ImpersonateUser(
    HANDLE      UserToken,
    HANDLE      ThreadHandle
    );

BOOL
StopImpersonating(
    HANDLE  ThreadHandle
    );

HANDLE 
CreateExecSrvPipe( 
    LPCTSTR lpPipeName 
    );

/*****************************************************************************
 *
 *  CtxExecServerLogon
 *
 *   Notify the Exec Server service that a user has logged on
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

VOID
CtxExecServerLogon(
    HANDLE hToken
    )
{

    EnterCriticalSection( &GlobalsLock );

    //
    // Store information about the current user
    // so we can create processes under their account
    // as needed.
    //
    ghUserToken = hToken;

    LeaveCriticalSection( &GlobalsLock );
}

/*****************************************************************************
 *
 *  CtxExecServerLogoff
 *
 *   Notify the Exec Server service that a user has logged off
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

VOID
CtxExecServerLogoff()
{

    EnterCriticalSection( &GlobalsLock );

    //
    // Release information stored about the current logged
    // on user.
    //
    ghUserToken = NULL;

    LeaveCriticalSection( &GlobalsLock );
}

//-----------------------------------------------------
// Helper functions copied from SALEM
// (nt\termsrv\remdsk\server\sessmgr\helper.cpp)
//-----------------------------------------------------

DWORD
GenerateRandomBytes(
    IN DWORD dwSize,
    IN OUT LPBYTE pbBuffer
    )
/*++

Description:

    Generate fill buffer with random bytes.

Parameters:

    dwSize : Size of buffer pbBuffer point to.
    pbBuffer : Pointer to buffer to hold the random bytes.

Returns:

    TRUE/FALSE

--*/
{
    HCRYPTPROV hProv = (HCRYPTPROV)NULL;
    DWORD dwStatus = ERROR_SUCCESS;

    //
    // Create a Crypto Provider to generate random number
    //
    if( !CryptAcquireContext(
                    &hProv,
                    NULL,
                    NULL,
                    PROV_RSA_FULL,
                    CRYPT_VERIFYCONTEXT
                ) )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    if( !CryptGenRandom(hProv, dwSize, pbBuffer) )
    {
        dwStatus = GetLastError();
    }

CLEANUPANDEXIT:    

    if( (HCRYPTPROV)NULL != hProv )
    {
        CryptReleaseContext( hProv, 0 );
    }

    return dwStatus;
}


DWORD
GenerateRandomString(
    IN DWORD dwSizeRandomSeed,
    IN OUT LPTSTR* pszRandomString
    )
/*++


--*/
{
    PBYTE lpBuffer = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSuccess;
    DWORD cbConvertString = 0;

    if( 0 == dwSizeRandomSeed || NULL == pszRandomString )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        ASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }

    *pszRandomString = NULL;

    lpBuffer = (PBYTE)LocalAlloc( LPTR, dwSizeRandomSeed );  
    if( NULL == lpBuffer )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    dwStatus = GenerateRandomBytes( dwSizeRandomSeed, lpBuffer );

    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    // Convert to string
    // cbConvertString will include the NULL character
    bSuccess = CryptBinaryToString(
                                lpBuffer,
                                dwSizeRandomSeed,
                                CRYPT_STRING_BASE64,
                                NULL,
                                &cbConvertString
                            );
    if( FALSE == bSuccess )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    *pszRandomString = (LPTSTR)LocalAlloc( LPTR, cbConvertString*sizeof(TCHAR) );
    if( NULL == *pszRandomString )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    bSuccess = CryptBinaryToString(
                                lpBuffer,
                                dwSizeRandomSeed,
                                CRYPT_STRING_BASE64,
                                *pszRandomString,
                                &cbConvertString
                            );
    if( FALSE == bSuccess )
    {
        dwStatus = GetLastError();
    }
    else
    {
        if( (*pszRandomString)[cbConvertString - 1] == '\n' &&
            (*pszRandomString)[cbConvertString - 2] == '\r' )
        {
            (*pszRandomString)[cbConvertString - 2] = 0;
        }
    }

CLEANUPANDEXIT:

    if( ERROR_SUCCESS != dwStatus )
    {
        if( NULL != *pszRandomString )
        {
            LocalFree(*pszRandomString);
            *pszRandomString = NULL;
        }
    }

    if( NULL != lpBuffer )
    {
        LocalFree(lpBuffer);
    }

    return dwStatus;
}

/*****************************************************************************
 *
 *  StartExecServerThread
 *
 *   Start the remote exec server thread.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN
StartExecServerThread()
{
    DWORD ThreadId;
    BOOL  Result;
    WCHAR szPipeName[EXECSRVPIPENAMELEN];
    SECURITY_ATTRIBUTES SecurityAttributes;
    PSECURITY_ATTRIBUTES pSecurityAttributes = NULL;
    PSECURITY_DESCRIPTOR lpSecurityDescriptor = NULL;    
    LPTSTR pszRandomString = NULL;
    ULONG RandomLen;
    DWORD dwStatus = ERROR_SUCCESS;

#if DBG
    OutputDebugString (TEXT("EXECSERVERSYSTEM: Starting ExecServerThread\n"));
#endif

    RandomLen = sizeof(szPipeName)/sizeof(WCHAR) - 30;

    dwStatus = GenerateRandomString( RandomLen, &pszRandomString );
    if( ERROR_SUCCESS != dwStatus ) {
        return FALSE;
    }

    // the string generated is always greater than what we ask
    pszRandomString[RandomLen] = L'\0';

    _snwprintf(&szPipeName[0], EXECSRVPIPENAMELEN, L"\\\\.\\Pipe\\TerminalServer\\%ws\\%d", pszRandomString, NtCurrentPeb()->SessionId);
    szPipeName[EXECSRVPIPENAMELEN-1] = L'\0';

    ExecServerPipe = CreateExecSrvPipe( &szPipeName[0] );
    if( ExecServerPipe == (HANDLE)-1 ) {
        OutputDebugString (TEXT("EXECSRV: Could not get pipe for ExecSrvr\n"));
        return( FALSE );
    }

    WinStationSetInformation( SERVERNAME_CURRENT, NtCurrentPeb()->SessionId, WinStationExecSrvSystemPipe, &szPipeName[0], sizeof(szPipeName) );
    
    ExecThreadHandle = CreateThread(
                 NULL,                       // Use default ACL
                 0,                          // Same stack size
                 ExecServerThread,           // Start address
                 (LPVOID)ExecServerPipe,     // Parameter
                 0,                          // Creation flags
                 &ThreadId                   // Get the id back here
                 );

   if( ExecThreadHandle == NULL ) {
       OutputDebugString (TEXT("WLEXECSERVER: Could not create server thread Error\n"));
       return(FALSE);
   }

   return(TRUE);
}

/*****************************************************************************
 *
 *  ExecServerThread
 *
 *   Thread that listens on the named pipe for remote exec service
 *   requests and executes them. Passes the results back to the caller.
 *
 * ENTRY:
 *   lpThreadParameter (input)
 *     Handle to exec server pipe
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

DWORD
ExecServerThread(
    LPVOID lpThreadParameter
    )
{
    BOOL   Result;
    DWORD  AmountRead;
    CHAR   *pBuf;
    HANDLE hPipe = (HANDLE)lpThreadParameter;

    pBuf = LocalAlloc(LMEM_FIXED,  EXECSRV_BUFFER_SIZE );

    if (pBuf  == NULL) {
        OutputDebugString (TEXT("WLEXECSERVER: ExecServerThread : nomemory \n"));
        return(STATUS_NO_MEMORY);
    }

   while( 1 ) {

        // read the pipe for a request (pipe is in message mode)
        Result = ConnectNamedPipe( hPipe, NULL );
        if( !Result ) {
            OutputDebugString (TEXT("WLEXECSERVER: ConnectNamePipe failed\n"));
            LocalFree( pBuf );
            return(FALSE);
        }

        // read the request from the pipe
        Result = ReadFile(
                     hPipe,
                     pBuf,
                     EXECSRV_BUFFER_SIZE,
                     &AmountRead,
                     NULL
                     );

        if( Result ) {
            ProcessExecRequest( hPipe, pBuf, AmountRead );
        }
        else {
            OutputDebugString (TEXT("WLEXECSERVER: Error reading pipe after connect\n"));
            // Could handle the to big error, but this means mismatched client
        }

        // wait until the client reads out the reply
        Result = FlushFileBuffers( hPipe );
#if DBG
        if( Result == 0 ) {
            OutputDebugString (TEXT("EXECSRV: FlushFileBuffers failed! \n"));
        }
#endif

        // disconnect the name pipe
        Result = DisconnectNamedPipe( hPipe );
#if DBG
        if( Result == 0 ) {
            OutputDebugString (TEXT("EXECSRV: Disconnect Named Pipe failed! Error \n"));
        }
#endif
    }
}


/*****************************************************************************
 *
 *  ProcessExecRequest
 *
 *   Do the work of processing a remote exec request
 *
 * ENTRY:
 *   hPipe (input)
 *     Pipe handle for reply
 *
 *   pBuf (input)
 *     Request buffer
 *
 *   AmountRead (input)
 *     Amount in request buffer
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN
ProcessExecRequest(
    HANDLE hPipe,
    PCHAR  pBuf,
    DWORD  AmountRead
    )
{
    DWORD AmountWrote;
    BOOL  Result;
    HANDLE ImpersonationHandle = NULL;
    SECURITY_ATTRIBUTES saProcess;
    EXECSRV_REPLY    Rep;
    HANDLE LocalProc = NULL;
    HANDLE RemoteProc = NULL;
    HANDLE LocalhProcess = NULL;
    HANDLE LocalhThread = NULL;
    PEXECSRV_REQUEST p = (PEXECSRV_REQUEST)pBuf;
    LPVOID lpEnvironment = NULL;
    HANDLE hUserToken=NULL;
    BOOL   bEnvBlockCreatedLocally = FALSE;

#if DBG
    KdPrint(("WLEXECSERVER: AmountRead = %d, pBuf->Size= %d \n", AmountRead, p->Size ));
#endif

    RtlZeroMemory(&Rep,sizeof(EXECSRV_REPLY));

    if( AmountRead < sizeof(EXECSRV_REQUEST) ) {
        // drop the request
        OutputDebugString (TEXT("WLEXECSERVER: BAD EXECSRV Request size (WinLogon)\n"));
        return(FALSE);
    }

    // normalize the pointers

    if( p->lpszImageName ) {
        p->lpszImageName = (PWCHAR)(((ULONG_PTR)p->lpszImageName) + pBuf);
        if( ( (PCHAR)p->lpszImageName > (PCHAR)(pBuf+AmountRead)) ||
            ((PCHAR)p->lpszImageName < (PCHAR)(pBuf + sizeof(EXECSRV_REQUEST))) ) {
            OutputDebugString (TEXT("WLEXECSERVER: Invalid image name pointer\n"));
            // drop the request
            return(FALSE);
        }
    }

    if( p->lpszCommandLine ) {
        p->lpszCommandLine = (PWCHAR)(((ULONG_PTR)p->lpszCommandLine) + pBuf);
        if( ((PCHAR)p->lpszCommandLine > (PCHAR)(pBuf+AmountRead)) ||
            ((PCHAR)p->lpszCommandLine < (PCHAR)(pBuf + sizeof(EXECSRV_REQUEST)))) {
            OutputDebugString (TEXT("WLEXECSERVER: Invalid command line pointer\n"));
            // drop the request
            return(FALSE);
        }
    }

    if( p->lpszCurDir ) {
        p->lpszCurDir = (PWCHAR)(((ULONG_PTR)p->lpszCurDir) + pBuf);
        if( ((PCHAR)p->lpszCurDir > (PCHAR)(pBuf+AmountRead)) ||
            ((PCHAR)p->lpszCurDir < (PCHAR)(pBuf + sizeof(EXECSRV_REQUEST))) ) {
            OutputDebugString (TEXT("WLEXECSERVER: Invalid CurDir pointer\n"));
            // drop the request
            return(FALSE);
        }
    }

    if( p->StartInfo.lpDesktop ) {
        p->StartInfo.lpDesktop = (PWCHAR)(((ULONG_PTR)p->StartInfo.lpDesktop) + pBuf);
        if( ((PCHAR)p->StartInfo.lpDesktop > (PCHAR)(pBuf+AmountRead)) ||
             ((PCHAR)p->StartInfo.lpDesktop < (PCHAR)(pBuf + sizeof(EXECSRV_REQUEST))) ) {
            OutputDebugString (TEXT("WLEXECSERVER: Invalid StartInfo.lpDesktop pointer\n"));
            // drop the request
            return(FALSE);
        }
    }

    if( p->StartInfo.lpTitle ) {
        p->StartInfo.lpTitle = (PWCHAR)(((ULONG_PTR)p->StartInfo.lpTitle) + pBuf);
        if( ((PCHAR)p->StartInfo.lpTitle > (PCHAR)(pBuf+AmountRead)) ||
             ((PCHAR)p->StartInfo.lpTitle < (PCHAR)(pBuf + sizeof(EXECSRV_REQUEST))) ) {
            OutputDebugString (TEXT("WLEXECSERVER: Invalid StartInfo.lpTitle pointer\n"));
            // drop the request
            return(FALSE);
        }
    }

    if (p->lpvEnvironment )
    {
        p->lpvEnvironment = (PWCHAR)(((ULONG_PTR)p->lpvEnvironment) + pBuf);
        if( ((PCHAR)p->lpvEnvironment > (PCHAR)(pBuf+AmountRead)) ||
            ((PCHAR)p->lpvEnvironment < (PCHAR)(pBuf + sizeof(EXECSRV_REQUEST)))  ) {
            OutputDebugString (TEXT("WLEXECSERVER: Invalid env pointer\n"));
            // drop the request
            return(FALSE);
         }
    }

    // We do not know what the reserved is, so make sure it is NULL
    p->StartInfo.lpReserved = NULL;

    //if( p->lpszImageName )
       //OutputDebugString (TEXT("WLEXECSERVER: Got request ImageName :%ws:\n", p->lpszImageName));

    //if( p->lpszCommandLine )
       //OutputDebugString (TEXT("WLEXECSERVER: Got request command line :%ws:\n", p->lpszCommandLine));

    //OutputDebugString (TEXT("WLEXECSERVER: CreateFlags 0x%x\n",p->fdwCreate));

    //OutputDebugString (TEXT("System Flag 0x%x\n",p->System));

    //
    // Can only service user security level requests when a user is logged on.
    //
    if( !p->System ) {

        EnterCriticalSection( &GlobalsLock );

        if (ghUserToken == NULL) {
#if DBG
            OutputDebugString (TEXT("WLEXECSERVER: No USER Logged On for USER CreateProcess Request!\n"));
#endif
            LeaveCriticalSection( &GlobalsLock );
            return( FALSE );
        }

        //
        // We need to open the remote process in order to duplicate the user token.
        // But for that, we need to impersonate the named pipe client.
        //
        if ( ImpersonateNamedPipeClient( hPipe ) == 0 ) {
            LeaveCriticalSection( &GlobalsLock );
            return( FALSE );
        }

        //
        // Get the handle to remote process
        //
        RemoteProc = OpenProcess(
                         PROCESS_DUP_HANDLE|PROCESS_QUERY_INFORMATION,
                         FALSE,   // no inherit
                         p->RequestingProcessId
                         );

        if( RemoteProc == NULL ) {
            OutputDebugString (TEXT("WLEXECSERVER: Could not get handle to remote process \n"));
            //
            // on retail builds we can not duplicate a handle into
            // service controller process
            //
            //  The handles are not used by SCM right now, we must
            //  have another way to pass handles if this function
            //  is used by other services.
            //
            ASSERT( FALSE ); // Should not happen in WinLogon
            RevertToSelf();  // Imperonation of named pipe client had succeeded.
            LeaveCriticalSection( &GlobalsLock );
            goto ReturnError;
        }

        if ( !RevertToSelf() ) {
            ASSERT( FALSE ); // This RevertToSelf should not fail.
            LeaveCriticalSection( &GlobalsLock );
            return( FALSE );
        }

        //
        // Get the handle to current process
        //
        LocalProc = OpenProcess(
                        PROCESS_DUP_HANDLE|PROCESS_QUERY_INFORMATION,
                        FALSE,   // no inherit
                        GetCurrentProcessId()
                        );

        if( LocalProc == NULL ) {
            OutputDebugString (TEXT("WLEXECSERVER: Could not get handle to local process\n"));
            LeaveCriticalSection( &GlobalsLock );
            goto ReturnError;
        }

        // decide if we are creating the new process for the currntly logged in user, or a
        // new user
        if (p->hToken)
        {
            //
            // we are dealing with a new user, for which we have a token comming from
            // services.exe (for SecLogon)
            //
            Result = DuplicateHandle(
                 RemoteProc,         // Source of the handle (us)
                 p->hToken,          // Source handle
                 LocalProc,          // Target of the handle
                 &hUserToken, // Target handle
                 0,                 // ignored since  DUPLICATE_SAME_ACCESS is set
                 FALSE,             // no inherit on the handle
                 DUPLICATE_SAME_ACCESS
                 );

            if( !Result ) {
                OutputDebugString (TEXT("WLEXECSERVER: Error duping process handle to target process\n"));
                LeaveCriticalSection( &GlobalsLock );
                goto ReturnError;
            }

        }
        else
        {
            hUserToken=ghUserToken;  // currently logged in user
        }

        lpEnvironment = p->lpvEnvironment ;

        //
        // Create Environment Block if we have none
        //
        if ( !lpEnvironment )
        {
            if (!CreateEnvironmentBlock (&lpEnvironment, hUserToken, FALSE)) {
                KdPrint(("WLEXECSERVER: CreateEnvironmentBlock() Failed\n"));
            }
            else
            {
                bEnvBlockCreatedLocally = TRUE;
            }
        }

        //
        // If we are to run the process under USER security, impersonate
        // the user.
        //
        // This will also access check the users access to the exe image as well.
        //
        ImpersonationHandle = ImpersonateUser(hUserToken, NULL );
        if (ImpersonationHandle == NULL) {
            OutputDebugString (TEXT("WLEXECSERVER: failed to impersonate user\n"));
            LeaveCriticalSection( &GlobalsLock );
            goto ReturnError;
        }

        LeaveCriticalSection( &GlobalsLock );

        // this environment block is UNICODE
        p->fdwCreate |= CREATE_UNICODE_ENVIRONMENT;

        Result = CreateProcessAsUserW(
                     hUserToken,
                     p->lpszImageName,
                     p->lpszCommandLine,
                     NULL,    // &saProcess,
                     NULL,    // &p->saThread
                     p->fInheritHandles,
                     p->fdwCreate,
                     lpEnvironment,
                     p->lpszCurDir,
                     &p->StartInfo,
                     &Rep.ProcInfo
                     );

        if ( bEnvBlockCreatedLocally ) {
            DestroyEnvironmentBlock (lpEnvironment);
        }
    }
    else {
        // If creating system, force separate WOW
        p->fdwCreate |= CREATE_SEPARATE_WOW_VDM;

        // CreateProcessAsUser() does not take a NULL token for SYSTEM
        Result = CreateProcessW(
                     p->lpszImageName,
                     p->lpszCommandLine,
                     NULL,    // &saProcess,
                     NULL,    // &p->saThread
                     p->fInheritHandles,
                     p->fdwCreate,
                     NULL,    //p->lpvEnvironment
                     p->lpszCurDir,
                     &p->StartInfo,
                     &Rep.ProcInfo
                     );
    }

    if( !Result ){
         if( ImpersonationHandle ) {
            StopImpersonating(ImpersonationHandle);
        }
        //
        //         Rep.Result = FALSE;
        //         Rep.LastError = GetLastError();
        //         Result = WriteFile( hPipe, &Rep, sizeof(Rep), &AmountWrote, NULL );
        //         OutputDebugString (TEXT("WLEXECSERVER: Error in CreateProcess\n"));
        //         return(FALSE);
        goto ReturnError;
    }

    // Stop impersonating the process
    if( ImpersonationHandle ) {
        StopImpersonating(ImpersonationHandle);
    }

    if (!Result) {
        OutputDebugString (TEXT("ExecServer: failed to resume new process thread\n"));
        CloseHandle(Rep.ProcInfo.hProcess);
        CloseHandle(Rep.ProcInfo.hThread);
        goto ReturnError;
    }

    //
    // do any tricky handle DUP stuff
    //
    LocalhProcess = Rep.ProcInfo.hProcess;
    LocalhThread = Rep.ProcInfo.hThread;

    Result = DuplicateHandle(
                 LocalProc,     // Source of the handle (us)
                 Rep.ProcInfo.hProcess,  // Source handle
                 RemoteProc,    // Target of the handle
                 &Rep.ProcInfo.hProcess,  // Target handle
                 0,             // ignored since  DUPLICATE_SAME_ACCESS is set
                 FALSE,         // no inherit on the handle
                 DUPLICATE_SAME_ACCESS
                 );

    if( !Result ) {
        OutputDebugString (TEXT("WLEXECSERVER: Error duping process handle to target process\n"));
    }

    //
    // If the program got launched into the shared WOW virtual machine,
    // then the hThread will be NULL.
    //
    if( Rep.ProcInfo.hThread != NULL ) {
        Result = DuplicateHandle(
                     LocalProc,     // Source of the handle (us)
                     Rep.ProcInfo.hThread,  // Source handle
                     RemoteProc,    // Target of the handle
                     &Rep.ProcInfo.hThread,  // Target handle
                     0,             // ignored since  DUPLICATE_SAME_ACCESS is set
                     FALSE,         // no inherit on the handle
                     DUPLICATE_SAME_ACCESS
                     );

        if( !Result ) {
            //OutputDebugString (TEXT("WLEXECSERVER: Error %d duping thread handle to target process, Handle 0x%x, ThreadId 0x%x\n",GetLastError(),Rep.ProcInfo.hThread,Rep.ProcInfo.dwThreadId));
        }
    }

    //OutputDebugString (TEXT("WLXEXECSERVER: Success for %d type exec\n",p->System));

    //
    // build the reply packet with the handle valid in the context
    // of the requesting process
    //
    Rep.Result = TRUE;
    Rep.LastError = 0;
    Result = WriteFile( hPipe, &Rep, sizeof(Rep), &AmountWrote, NULL );

    if( !Result ) {
        OutputDebugString (TEXT("WLEXECSERVER: Error sending reply \n"));
    }

    //
    // close our versions of the handles. The requestors references
    // are now the main ones
    //
    if( LocalProc != NULL )
        CloseHandle( LocalProc );

    if( RemoteProc != NULL )
        CloseHandle( RemoteProc );

    if( LocalhProcess != NULL )
        CloseHandle( LocalhProcess );

    if( LocalhThread != NULL )
        CloseHandle( LocalhThread );

    if (hUserToken  && (hUserToken != ghUserToken))
    {
        CloseHandle( hUserToken );
    }
    return (BOOLEAN)Result;

ReturnError:
    Rep.Result = FALSE;
    Rep.LastError = GetLastError();

    //OutputDebugString (TEXT("WLXEXECSERVER: Error %d for %d type exec\n",Rep.LastError,p->System));
    Result = WriteFile( hPipe, &Rep, sizeof(Rep), &AmountWrote, NULL );

    if( LocalProc != NULL )
        CloseHandle( LocalProc );

    if( RemoteProc != NULL )
        CloseHandle( RemoteProc );

    if( LocalhProcess != NULL )
        CloseHandle( LocalhProcess );

    if( LocalhThread != NULL )
        CloseHandle( LocalhThread );

    if (hUserToken  && (hUserToken != ghUserToken) )
    {
        CloseHandle( hUserToken );
    }
    return (BOOLEAN)Result;
}



/***************************************************************************\
* FUNCTION: ImpersonateUser
*
* PURPOSE:  Impersonates the user by setting the users token
*           on the specified thread. If no thread is specified the token
*           is set on the current thread.
*
* RETURNS:  Handle to be used on call to StopImpersonating() or NULL on failure
*           If a non-null thread handle was passed in, the handle returned will
*           be the one passed in. (See note)
*
* NOTES:    Take care when passing in a thread handle and then calling
*           StopImpersonating() with the handle returned by this routine.
*           StopImpersonating() will close any thread handle passed to it -
*           even yours !
*
*
\***************************************************************************/

HANDLE
ImpersonateUser(
    HANDLE      UserToken,
    HANDLE      ThreadHandle
    )
{
    NTSTATUS Status, IgnoreStatus;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ImpersonationToken;
    BOOL ThreadHandleOpened = FALSE;

    if (ThreadHandle == NULL) {

        //
        // Get a handle to the current thread.
        // Once we have this handle, we can set the user's impersonation
        // token into the thread and remove it later even though we ARE
        // the user for the removal operation. This is because the handle
        // contains the access rights - the access is not re-evaluated
        // at token removal time.
        //

        Status = NtDuplicateObject( NtCurrentProcess(),     // Source process
                                    NtCurrentThread(),      // Source handle
                                    NtCurrentProcess(),     // Target process
                                    &ThreadHandle,          // Target handle
                                    THREAD_SET_THREAD_TOKEN,// Access
                                    0L,                     // Attributes
                                    DUPLICATE_SAME_ATTRIBUTES
                                  );
        if (!NT_SUCCESS(Status)) {
            KdPrint(("ImpersonateUser : Failed to duplicate thread handle, status = 0x%lx", Status));
            return(NULL);
        }

        ThreadHandleOpened = TRUE;
    }


    //
    // If the usertoken is NULL, there's nothing to do
    //

    if (UserToken != NULL) {

        //
        // UserToken is a primary token - create an impersonation token version
        // of it so we can set it on our thread
        //

        InitializeObjectAttributes(
                            &ObjectAttributes,
                            NULL,
                            0L,
                            NULL,
                            //UserProcessData->NewThreadTokenSD);
                            NULL);

        SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
        SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
        SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        SecurityQualityOfService.EffectiveOnly = FALSE;

        ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;


        Status = NtDuplicateToken( UserToken,
                                   TOKEN_IMPERSONATE | TOKEN_READ,
                                   &ObjectAttributes,
                                   FALSE,
                                   TokenImpersonation,
                                   &ImpersonationToken
                                 );
        if (!NT_SUCCESS(Status)) {

            KdPrint(("Failed to duplicate users token to create"
                     " impersonation thread, status = 0x%lx\n", Status));

            if (ThreadHandleOpened) {
                IgnoreStatus = NtClose(ThreadHandle);
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }

            return(NULL);
        }



        //
        // Set the impersonation token on this thread so we 'are' the user
        //

        Status = NtSetInformationThread( ThreadHandle,
                                         ThreadImpersonationToken,
                                         (PVOID)&ImpersonationToken,
                                         sizeof(ImpersonationToken)
                                       );
        //
        // We're finished with our handle to the impersonation token
        //

        IgnoreStatus = NtClose(ImpersonationToken);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        //
        // Check we set the token on our thread ok
        //

        if (!NT_SUCCESS(Status)) {

            KdPrint(( "Failed to set user impersonation token on winlogon thread, status = 0x%lx", Status));

            if (ThreadHandleOpened) {
                IgnoreStatus = NtClose(ThreadHandle);
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }

            return(NULL);
        }

    }


    return(ThreadHandle);

}


/***************************************************************************\
* FUNCTION: StopImpersonating
*
* PURPOSE:  Stops impersonating the client by removing the token on the
*           current thread.
*
* PARAMETERS: ThreadHandle - handle returned by ImpersonateUser() call.
*
* RETURNS:  TRUE on success, FALSE on failure
*
* NOTES: If a thread handle was passed in to ImpersonateUser() then the
*        handle returned was one and the same. If this is passed to
*        StopImpersonating() the handle will be closed. Take care !
*
* HISTORY:
*
*   04-21-92 Davidc       Created.
*
\***************************************************************************/

BOOL
StopImpersonating(
    HANDLE  ThreadHandle
    )
{
    NTSTATUS Status, IgnoreStatus;
    HANDLE ImpersonationToken;


    //
    // Remove the user's token from our thread so we are 'ourself' again
    //

    ImpersonationToken = NULL;

    Status = NtSetInformationThread( ThreadHandle,
                                     ThreadImpersonationToken,
                                     (PVOID)&ImpersonationToken,
                                     sizeof(ImpersonationToken)
                                   );
    //
    // We're finished with the thread handle
    //

    IgnoreStatus = NtClose(ThreadHandle);
    ASSERT(NT_SUCCESS(IgnoreStatus));


    if (!NT_SUCCESS(Status)) {
        KdPrint(("Failed to remove user impersonation token from winlogon thread, status = 0x%lx", Status));
    }

    return(NT_SUCCESS(Status));
}


//---------------------------------------------------------------------------------------
//
//  CreateExecSrvPipe
//  Creates exec server named pipe with appropriate DACL. It allows access only to local
//  system, local service and network service. 
//  It return handle to the newly created pipe. If the operation fails, it returns 
//  INVALID_HANDLE_VALUE.
//
//---------------------------------------------------------------------------------------

HANDLE CreateExecSrvPipe( LPCTSTR lpPipeName )
{
    HANDLE hPipe = INVALID_HANDLE_VALUE;
    NTSTATUS    Status;
    SECURITY_ATTRIBUTES SecAttr;
    PSID pSystemSid = NULL;
    PSID pLocalServiceSid = NULL;
    PSID pNetworkServiceSid = NULL;
    PSECURITY_DESCRIPTOR pSd = NULL;
    PACL pDacl;
    ULONG AclLength;
    SID_IDENTIFIER_AUTHORITY SystemAuth = SECURITY_NT_AUTHORITY;

    // Allocate and Initialize the "System" Sid.
    Status = RtlAllocateAndInitializeSid( &SystemAuth,
                                          1,
                                          SECURITY_LOCAL_SYSTEM_RID,
                                          0, 0, 0, 0, 0, 0, 0,
                                          &pSystemSid );
    if (!NT_SUCCESS(Status)) {
        goto CreatePipeErr;
    }

    // Allocate and Initialize the "Local Service" Sid.
    Status = RtlAllocateAndInitializeSid( &SystemAuth,
                                          1,
                                          SECURITY_LOCAL_SERVICE_RID,
                                          0, 0, 0, 0, 0, 0, 0,
                                          &pLocalServiceSid );
    if (!NT_SUCCESS(Status)) {
        goto CreatePipeErr;
    }

    // Allocate and Initialize the "Network Service" Sid.
    Status = RtlAllocateAndInitializeSid( &SystemAuth,
                                          1,
                                          SECURITY_NETWORK_SERVICE_RID,
                                          0, 0, 0, 0, 0, 0, 0,
                                          &pNetworkServiceSid );
    if (!NT_SUCCESS(Status)) {
        goto CreatePipeErr;
    }

    // Allocate space for the security descriptor.
    AclLength = (ULONG)sizeof(ACL) +
                3 * sizeof(ACCESS_ALLOWED_ACE) +
                RtlLengthSid( pSystemSid ) +
                RtlLengthSid( pLocalServiceSid ) +
                RtlLengthSid( pNetworkServiceSid ) -
                3 * sizeof( ULONG );

    pSd = (PSECURITY_DESCRIPTOR) LocalAlloc( LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH + AclLength );
    if (pSd == NULL) {
        goto CreatePipeErr;
    }

    pDacl = (PACL) ((BYTE*)(pSd) + SECURITY_DESCRIPTOR_MIN_LENGTH);

    // Set up a new ACL with no ACE.
    Status = RtlCreateAcl( pDacl, AclLength, ACL_REVISION2 );
    if ( !NT_SUCCESS(Status) ) {
        goto CreatePipeErr;
    }

    // System access
    Status = RtlAddAccessAllowedAce( pDacl,
                                     ACL_REVISION2,
                                     GENERIC_READ | GENERIC_WRITE,
                                     pSystemSid
                                   );
    if (!NT_SUCCESS(Status)) {
        goto CreatePipeErr;
    }

    // Local Service access
    Status = RtlAddAccessAllowedAce( pDacl,
                                     ACL_REVISION2,
                                     GENERIC_READ | GENERIC_WRITE,
                                     pLocalServiceSid
                                   );
    if (!NT_SUCCESS(Status)) {
        goto CreatePipeErr;
    }

    // Network Service access
    Status = RtlAddAccessAllowedAce( pDacl,
                                     ACL_REVISION2,
                                     GENERIC_READ | GENERIC_WRITE,
                                     pNetworkServiceSid
                                   );
    if (!NT_SUCCESS(Status)) {
        goto CreatePipeErr;
    }

    // Now initialize security descriptors that export this protection
    Status = RtlCreateSecurityDescriptor(pSd, SECURITY_DESCRIPTOR_REVISION1);
    if (!NT_SUCCESS(Status)) {
        goto CreatePipeErr;
    }

    Status = RtlSetDaclSecurityDescriptor(pSd, TRUE, pDacl, FALSE);
    if (!NT_SUCCESS(Status)) {
        goto CreatePipeErr;
    }

    // Fill the Security Attributes
    ZeroMemory(&SecAttr, sizeof(SecAttr));
    SecAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
    SecAttr.lpSecurityDescriptor = pSd;
    SecAttr.bInheritHandle = FALSE;

    hPipe = CreateNamedPipeW(
                lpPipeName,
                PIPE_ACCESS_DUPLEX,
                PIPE_WAIT | PIPE_READMODE_MESSAGE | PIPE_TYPE_MESSAGE,
                PIPE_UNLIMITED_INSTANCES,
                EXECSRV_BUFFER_SIZE,
                EXECSRV_BUFFER_SIZE,
                0,
                &SecAttr
            );

    // It's very unlikely, but still make sure that pipe with this name does not exist.
    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        NtClose( hPipe );
        hPipe = INVALID_HANDLE_VALUE;
    }

CreatePipeErr:

    // Free the SIDs
    if ( pSystemSid ) {
        RtlFreeSid( pSystemSid );
    }

    if ( pLocalServiceSid ) {
        RtlFreeSid( pLocalServiceSid );
    }

    if ( pNetworkServiceSid ) {
        RtlFreeSid( pNetworkServiceSid );
    }

    if (pSd) {
        LocalFree(pSd);
    }

    return hPipe;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\errorlog.c ===
/****************************************************************************/
// errorlog.c
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/

#include "precomp.h"

#include "errorlog.h"
#include <wlnotify.h>

static WCHAR gs_LogErrorTitle[MAX_PATH+1] = L"";
static HANDLE gs_LogHandle = NULL;
extern HINSTANCE g_hInstance;

void
TsInitLogging()
/*++

Routine Description:

    Initialize the global variables that we use for Logging events.

Arguments:

Return Value:
    
--*/
{
    //
    // Register ourselves as an event source
    //
    gs_LogHandle = RegisterEventSourceW(
                    NULL,
                    L"TermServDevices"
                    );

    if (gs_LogHandle == NULL) {
        KdPrint(("UMRDPDR: Failed to open log file\n"));
    }
}

void TsStopLogging()
{
/*++

Routine Description:

    Free up resources that we created in TsInitLogging

Arguments:

Return Value:
    

--*/
    //
    // Unregister Event Source
    //
    if (gs_LogHandle) {
        if (!DeregisterEventSource(gs_LogHandle)) {
            KdPrint(("UMRDPDR:Failed to Deregister Event Source.\n"));
        }

        gs_LogHandle = NULL;
    }
}


void
TsLogError(
    IN DWORD dwEventID,
    IN DWORD dwErrorType,
    IN int nStringsCount,
    IN WCHAR * pStrings[],
    IN DWORD LineNumber
    )
{
/*++

Routine Description:

    Log the Error message specified by dwEventID.
    Along with the message, the error value returned by GetLastError is logged.
    The caller should make sure that the Last Error is appropriately set.

Arguments:

    dwEventID -             ID of the message (as specified in the .mc file).
    nStringsCount -         Number of Insert Strings for this event message.
    pStrings -              An array of Insert Strings.
    LineNumber -            The caller will pass __LINE__ for this.

Return Value:
    
--*/
    if (gs_LogHandle) {
        
        DWORD RawData[2];
    
        //
        // The raw data we will be writing comprises of two DWORDS. 
        // The first DWORD is the GetLastError value
        // The second DWORD is the LineNumber in which the error occurred.
        //

        RawData[0] = GetLastError();
        RawData[1] = LineNumber;
        
        if (!ReportEventW(gs_LogHandle,        // LogHandle
            (WORD)dwErrorType,                 // EventType
            0,                                 // EventCategory
            dwEventID,                         // EventID
            NULL,                              // UserSID
            (WORD)nStringsCount,               // NumStrings
            sizeof(RawData),                   // DataSize
            pStrings,                          // Strings
            (LPVOID)RawData)) {                // Raw Data

            KdPrint(("UMRDPDR: ReportEvent Failed. Error code: %ld\n", GetLastError()));
        }
        
        //
        // ReportEvent modifies the Last Error value.
        // So, we will set it back to the original error value.
        // 
        SetLastError(RawData[0]);
    }
}

void TsPopupError(
    IN DWORD dwEventID,
    IN WCHAR * pStrings[]
    )
{
/*++

Routine Description:

    Popup an Error message specified by dwEventID.
    Along with the message, the error value returned by GetLastError is displayed.
    The caller should make sure that the Last Error is appropriately set.

    The routine displays the error message in the format "%s \n %s" where the first
    insert string is the specific error message as specified by dwEventID, and the
    second insert string is the formatted error message for the error value in 
    GetLastError.

Arguments:

    dwEventID -             ID of the message (as specified in the .mc file).
    pStrings -              An array of Insert Strings.

Return Value:
    
--*/
    WCHAR * formattedMsg = NULL;
    WCHAR * formattedLastError = NULL;
    WCHAR * finalformattedMsg = NULL;

    DWORD dwLastError = GetLastError();

    //
    //  Load the error dialog string.
    //
    if (!wcslen(gs_LogErrorTitle)) {

        if (!LoadString(
                    g_hInstance,
                    IDS_TSERRORDIALOG_STRING,
                    gs_LogErrorTitle,
                    sizeof(gs_LogErrorTitle) / sizeof(gs_LogErrorTitle[0])
                    )) {
            KdPrint(("UMRDPPRN:LoadString %ld failed with Error: %ld.\n", 
                    IDS_TSERRORDIALOG_STRING, GetLastError()));
            wcscpy(gs_LogErrorTitle, L"Terminal Server Notify Error");
            ASSERT(FALSE);
        }
    }

    //
    // Format the message
    //
    if (!FormatMessageW(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | 
            FORMAT_MESSAGE_FROM_HMODULE |
            FORMAT_MESSAGE_ARGUMENT_ARRAY,
        (LPCVOID) g_hInstance,
        dwEventID,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPWSTR) &formattedMsg,
        0,
        (va_list*)pStrings)) {
            
        KdPrint(("UMRDPDR: FormatMessage failed. Error code: %ld.\n", GetLastError()));
        goto Cleanup;
    }

    //
    // Format the GetLastError message
    //

    if (dwLastError != ERROR_SUCCESS) { 
        if (FormatMessageW(
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_FROM_SYSTEM |
                FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            dwLastError,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPWSTR)&formattedLastError,
            0,
            NULL
            )) {
        
        //
        // Allocate enough memory for constructing the final formattedmessage.
        // 

        finalformattedMsg = (WCHAR *) LocalAlloc (LMEM_FIXED,
            LocalSize(formattedLastError) +
            LocalSize(formattedMsg) +
            3*sizeof(WCHAR));           // For constructing a string in the format "%s\n%s"
        }
        else {
            KdPrint(("UMRDPDR: FormatMessage failed. Error code: %ld.\n", GetLastError()));
        }
    }

    if (finalformattedMsg) {
        swprintf(finalformattedMsg, L"%ws\n%ws", formattedMsg, formattedLastError);
        MessageBoxW(NULL, finalformattedMsg, gs_LogErrorTitle, MB_ICONERROR);
    }
    else {
        MessageBoxW(NULL, formattedMsg, gs_LogErrorTitle, MB_ICONERROR);
    }

Cleanup:
    
    if (formattedLastError != NULL) {
        LocalFree(formattedLastError);
    }

    if (formattedMsg != NULL) {
        LocalFree(formattedMsg);
    }

    if (finalformattedMsg != NULL) {
        LocalFree(finalformattedMsg);
    }

    SetLastError(dwLastError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\precomp.h ===
/****************************************************************************/
// precomp.h
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <winwlx.h>
#include "munotify.h"
#include <regapi.h>
#include <winsta.h>
#include <syslib.h>
#include <winwlx.h>
#include "debug.h"
#include "winsta.h"
#include <tsappcmp.h>
#include <userenv.h>
#include "umrdpdr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\munotify.h ===
/****************************************************************************/
// munotify.h
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/

#define LOGOFF_CMD_TIMEOUT (60*1000)

VOID CtxExecServerLogon( HANDLE hToken );
VOID CtxExecServerLogoff( );

extern BOOL g_Console;
extern ULONG g_SessionId;
HANDLE g_UserToken;

DWORD ExecServerThread(
    LPVOID lpThreadParameter
    );


BOOLEAN
ProcessExecRequest(
    HANDLE hPipe,
    PCHAR  pBuf,
    DWORD  AmountRead
    );
BOOLEAN StartExecServerThread(void);

LPVOID
StartUserProcessMonitor(
    );

VOID
DeleteUserProcessMonitor(
    LPVOID Parameter
    );

LPVOID UserProcessMonitor;


#if 0
VOID ProcessLogoff(PTERMINAL pTerm);




#endif

BOOL AllocTempDirVolatileEnvironment();

VOID RemovePerSessionTempDirs();



#define IsActiveConsoleSession() (BOOLEAN)(USER_SHARED_DATA->ActiveConsoleId == NtCurrentPeb()->SessionId)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\procutil.c ===
/******************************************************************************
*  PROCUTIL.C
*
*  This is a scaled down version of procutil.c from utils\citrix\utilsub
*  that is included here.
*
*  We can not use utilsub.lib unless we modify every user of perflib.lib
*  to also include this library. Also since utilsub.lib includes 'C' runtimes
*  such as malloc() and free(), we would have to also include 'C' runtimes
*  with every user of this library. (Currently advapi32.dll and winlogon.exe)
*
*
* Copyright Citrix Systems Inc. 1994
* Copyright (C) 1997-1999 Microsoft Corp.
*
*  Author:      John Richardson
*******************************************************************************/

#include "precomp.h"
#pragma hdrstop


#define MAX_USER_NAME_LENGTH       (MAX_PATH*sizeof(WCHAR))
#define MAX_WINSTATION_NAME_LENGTH (MAX_PATH*sizeof(WCHAR))

#define ALLOCMEM(heap, flags, size)     HeapAlloc (heap, flags, size)
#define REALLOCMEM(heap, flags, pointer, newsize) \
                                    HeapReAlloc (heap, flags, pointer, newsize)
#define FREEMEM(heap, flags, pointer)   HeapFree (heap, flags, pointer)

/*
 * Set MAX_DOMAIN_LENGTH to MAX_USER_NAME_LENGTH
 */

#define MAX_DOMAIN_LENGTH MAX_USER_NAME_LENGTH

/*
 * Local function prototypes.
 */
VOID LookupSidUser( PSID pSid, PWCHAR pUserName, PULONG pcbUserName );
VOID RefreshUserSidCrcCache( void );


/*******************************************************************************
 *
 *  CalculateCrc16
 *
 *      Calculates a 16-bit CRC of the specified buffer.
 *
 *  ENTRY:
 *      pBuffer (input)
 *          Points to buffer to calculate CRC for.
 *      length (input)
 *          Length in bytes of the buffer.
 *
 *  EXIT:
 *      (USHORT)
 *          The 16-bit CRC of the buffer.
 *
 ******************************************************************************/

/*
 * updcrc macro derived from article Copyright (C) 1986 Stephen Satchell.
 *  NOTE: First argument must be in range 0 to 255.
 *        Second argument is referenced twice.
 *
 * Programmers may incorporate any or all code into their programs,
 * giving proper credit within the source. Publication of the
 * source routines is permitted so long as proper credit is given
 * to Stephen Satchell, Satchell Evaluations and Chuck Forsberg,
 * Omen Technology.
 */

#define updcrc(cp, crc) ( crctab[((crc >> 8) & 255)] ^ (crc << 8) ^ cp)


/* crctab calculated by Mark G. Mendel, Network Systems Corporation */
unsigned short crctab[256] = {
    0x0000,  0x1021,  0x2042,  0x3063,  0x4084,  0x50a5,  0x60c6,  0x70e7,
    0x8108,  0x9129,  0xa14a,  0xb16b,  0xc18c,  0xd1ad,  0xe1ce,  0xf1ef,
    0x1231,  0x0210,  0x3273,  0x2252,  0x52b5,  0x4294,  0x72f7,  0x62d6,
    0x9339,  0x8318,  0xb37b,  0xa35a,  0xd3bd,  0xc39c,  0xf3ff,  0xe3de,
    0x2462,  0x3443,  0x0420,  0x1401,  0x64e6,  0x74c7,  0x44a4,  0x5485,
    0xa56a,  0xb54b,  0x8528,  0x9509,  0xe5ee,  0xf5cf,  0xc5ac,  0xd58d,
    0x3653,  0x2672,  0x1611,  0x0630,  0x76d7,  0x66f6,  0x5695,  0x46b4,
    0xb75b,  0xa77a,  0x9719,  0x8738,  0xf7df,  0xe7fe,  0xd79d,  0xc7bc,
    0x48c4,  0x58e5,  0x6886,  0x78a7,  0x0840,  0x1861,  0x2802,  0x3823,
    0xc9cc,  0xd9ed,  0xe98e,  0xf9af,  0x8948,  0x9969,  0xa90a,  0xb92b,
    0x5af5,  0x4ad4,  0x7ab7,  0x6a96,  0x1a71,  0x0a50,  0x3a33,  0x2a12,
    0xdbfd,  0xcbdc,  0xfbbf,  0xeb9e,  0x9b79,  0x8b58,  0xbb3b,  0xab1a,
    0x6ca6,  0x7c87,  0x4ce4,  0x5cc5,  0x2c22,  0x3c03,  0x0c60,  0x1c41,
    0xedae,  0xfd8f,  0xcdec,  0xddcd,  0xad2a,  0xbd0b,  0x8d68,  0x9d49,
    0x7e97,  0x6eb6,  0x5ed5,  0x4ef4,  0x3e13,  0x2e32,  0x1e51,  0x0e70,
    0xff9f,  0xefbe,  0xdfdd,  0xcffc,  0xbf1b,  0xaf3a,  0x9f59,  0x8f78,
    0x9188,  0x81a9,  0xb1ca,  0xa1eb,  0xd10c,  0xc12d,  0xf14e,  0xe16f,
    0x1080,  0x00a1,  0x30c2,  0x20e3,  0x5004,  0x4025,  0x7046,  0x6067,
    0x83b9,  0x9398,  0xa3fb,  0xb3da,  0xc33d,  0xd31c,  0xe37f,  0xf35e,
    0x02b1,  0x1290,  0x22f3,  0x32d2,  0x4235,  0x5214,  0x6277,  0x7256,
    0xb5ea,  0xa5cb,  0x95a8,  0x8589,  0xf56e,  0xe54f,  0xd52c,  0xc50d,
    0x34e2,  0x24c3,  0x14a0,  0x0481,  0x7466,  0x6447,  0x5424,  0x4405,
    0xa7db,  0xb7fa,  0x8799,  0x97b8,  0xe75f,  0xf77e,  0xc71d,  0xd73c,
    0x26d3,  0x36f2,  0x0691,  0x16b0,  0x6657,  0x7676,  0x4615,  0x5634,
    0xd94c,  0xc96d,  0xf90e,  0xe92f,  0x99c8,  0x89e9,  0xb98a,  0xa9ab,
    0x5844,  0x4865,  0x7806,  0x6827,  0x18c0,  0x08e1,  0x3882,  0x28a3,
    0xcb7d,  0xdb5c,  0xeb3f,  0xfb1e,  0x8bf9,  0x9bd8,  0xabbb,  0xbb9a,
    0x4a75,  0x5a54,  0x6a37,  0x7a16,  0x0af1,  0x1ad0,  0x2ab3,  0x3a92,
    0xfd2e,  0xed0f,  0xdd6c,  0xcd4d,  0xbdaa,  0xad8b,  0x9de8,  0x8dc9,
    0x7c26,  0x6c07,  0x5c64,  0x4c45,  0x3ca2,  0x2c83,  0x1ce0,  0x0cc1,
    0xef1f,  0xff3e,  0xcf5d,  0xdf7c,  0xaf9b,  0xbfba,  0x8fd9,  0x9ff8,
    0x6e17,  0x7e36,  0x4e55,  0x5e74,  0x2e93,  0x3eb2,  0x0ed1,  0x1ef0
};

USHORT
CalculateCrc16( PBYTE pBuffer,
                USHORT length )
{

   USHORT Crc = 0;
   USHORT Data;

   while ( length-- ) {
      Data = (USHORT) *pBuffer++;
      Crc = updcrc( Data, Crc );
   }

   return(Crc);

} /* CalculateCrc16() */

/*
 * RefreshCitrixObjectCaches()
 *
 *  Refresh (invalidate) any caches that may be used by Citrix object
 *  utilities.
 *
 */
VOID
RefreshCitrixObjectCaches()
{
    RefreshUserSidCrcCache();
}

/*
 * This is the cache maintained by the GetUserNameFromSid function
 *
 * It is thread safe through the use of ULock.
 */

typedef struct TAGUSERSIDLIST {
    struct TAGUSERSIDLIST *Next;
    USHORT SidCrc;
    WCHAR  UserName[MAX_USER_NAME_LENGTH];
} USERSIDLIST, *PUSERSIDLIST;

static PUSERSIDLIST pUList = NULL;
static RTL_CRITICAL_SECTION ULock;
static BOOLEAN ULockInited = FALSE;

/***************************************************************************
 *
 *  InitULock
 *
 *  Since we do not require the user to call an initialize function,
 *  we must initialize our critical section in a thread safe manner.
 *
 *  The problem is, a critical section is needed to guard against multiple
 *  threads trying to init the critical section at the same time.
 *
 *  The solution that Nt uses, in which RtlInitializeCriticalSection itself
 *  uses, is to wait on a kernel supported process wide Mutant before proceding.
 *  This Mutant almost works by itself, but RtlInitializeCriticalSection does
 *  not wait on it until after trashing the semaphore count. So we wait on
 *  it ourselves, since it can be acquired recursively.
 *
 ***************************************************************************/
NTSTATUS InitULock()
{
    NTSTATUS Status = STATUS_SUCCESS;

    RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);


    /*
     * Make sure another thread did not beat us here
     */
    if( ULockInited == FALSE ){
        Status = RtlInitializeCriticalSection( &ULock );
        if (NT_SUCCESS(Status)) {
            ULockInited = TRUE;
        }
    }

    RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);
    return Status;
}


/***************************************************************************
 *
 * RefreshUserSidCrcCache
 *
 *  Invalidate the User/SidCrc cache so that the newest information
 *  will be fetched from the system.
 *
 ***************************************************************************/
VOID
RefreshUserSidCrcCache( void )
{
    PUSERSIDLIST pEntry, pNext;
    NTSTATUS Status;

    if( pUList == NULL ) return;

    /*
     * Make sure critical section has been inited
     */
    if( !ULockInited ) {
       Status = InitULock();
       if (!NT_SUCCESS(Status)) {
           return;
       }
    }

    RtlEnterCriticalSection( &ULock );

    pEntry = pUList;

    while( pEntry ) {
       pNext = pEntry->Next;
       FREEMEM( RtlProcessHeap(), 0, pEntry );
       pEntry = pNext;
    }

    pUList = NULL;

    RtlLeaveCriticalSection( &ULock );
}

/******************************************************************************
 *
 * GetUserNameFromSid
 *
 *  Attempts to retrieve the user (login) name of the process by first looking
 *  in our User/SidCrc cache table, then (if no match) looking up the SID in
 *  the SAM database and adding the new entry to the User/SidCrc table.
 *
 *  Input
 *
 *   IN pUserSid   Sid pointer
 *
 *   OUT ppName   pointer to PWCHAR
 *
 *  Will always return a user name, which will be "(unknown)" if the SID is
 *  invalid or can't determine the user/SID relationship for any other reason.
 *
 *****************************************************************************/

NTSTATUS
GetUserNameFromSid( PSID pUserSid, PWCHAR *ppName )
{
    USHORT SidCrc = 0;
    PUSERSIDLIST pEntry;
    WCHAR pNameBuf[MAX_USER_NAME_LENGTH];
    ULONG  NameLength;
    NTSTATUS Status;

    /*
     * Make sure critical section has been inited
     */
    if( !ULockInited ) {
       Status = InitULock();
       if (!NT_SUCCESS(Status)) {
           return Status;
       }
    }

    /*
     * Determine SID length in bytes and calculate a 16-bit CRC for it,
     * to facilitate quick matching.
     */
    if ( pUserSid ) {
        SidCrc = CalculateCrc16( (PBYTE)pUserSid,
                                  (USHORT)GetLengthSid(pUserSid) );
    }
    else {
        // A NULL SID has a CRC of 0
        SidCrc = 0;
    }

    /*
     * First: Before performing the expensive LookupAccountSid() function,
     * see if we've encountered this SID already, and match the user name
     * if so.
     */
    if ( pUList ) {

        RtlEnterCriticalSection( &ULock );

        pEntry = pUList;

        while( pEntry ) {

            if ( SidCrc == pEntry->SidCrc ) {

                // We got a hit, return the name
                *ppName = pEntry->UserName;

                RtlLeaveCriticalSection( &ULock );
                return(STATUS_SUCCESS);
            }
            pEntry = pEntry->Next;
        }

        RtlLeaveCriticalSection( &ULock );
    }

    /*
     * Last resort: Determine the user name associated with the SID using
     * the LookupAccountSid() API, embedded in our local function
     * LookupSidUser().
     */
    NameLength = MAX_USER_NAME_LENGTH;
    if( pUserSid ) {
        LookupSidUser( pUserSid, pNameBuf, &NameLength );
    }
    else {
        // NULL SID maps the the "Idle" user name string
        wcscpy( pNameBuf, L"Idle" );
    }

    /*
     * Add this new User/Sid relationship in our User/Sid cache list.
     */
    RtlEnterCriticalSection( &ULock );

    if ( (pEntry = (PUSERSIDLIST)ALLOCMEM(RtlProcessHeap(), 0, sizeof(USERSIDLIST))) ) {

        pEntry->SidCrc = SidCrc;
        wcsncpy( pEntry->UserName, pNameBuf, MAX_USER_NAME_LENGTH - 1 );
        pEntry->UserName[MAX_USER_NAME_LENGTH-1] = 0;
        pEntry->Next = pUList;
        pUList = pEntry;
        // Return the name
        *ppName = pEntry->UserName;
    }

    RtlLeaveCriticalSection( &ULock );

    return(STATUS_SUCCESS);
}


/******************************************************************************
 * LookupSidUser
 *
 *      Fetch the user name associated with the specified SID.
 *
 *  ENTRY:
 *      pSid (input)
 *          Points to SID to match to user name.
 *      pUserName (output)
 *          Points to buffer to place the user name into.
 *      pcbUserName (input/output)
 *          Specifies the size in bytes of the user name buffer.  The returned
 *          user name will be truncated to fit this buffer (including NUL
 *          terminator) if necessary and this variable set to the number of
 *          characters copied to pUserName.
 *
 *  EXIT:
 *
 *      LookupSidUser() will always return a user name.  If the specified
 *      SID fails to match to a user name, then the user name "(unknown)" will
 *      be returned.
 *
 *****************************************************************************/

VOID
LookupSidUser( PSID pSid,
               PWCHAR pUserName,
               PULONG pcbUserName )
{
    WCHAR DomainBuffer[MAX_DOMAIN_LENGTH], UserBuffer[MAX_USER_NAME_LENGTH];
    DWORD cDomainBuffer = sizeof(DomainBuffer) / sizeof(WCHAR);
    DWORD cUserBuffer = sizeof(UserBuffer) / sizeof(WCHAR);
    DWORD Error;
    PWCHAR pDomainBuffer = NULL, pUserBuffer = NULL;
    SID_NAME_USE SidNameUse;
    PWCHAR pUnknown = L"(Unknown)";

    /*
     * Fetch user name from SID: try user lookup with a reasonable Domain and
     * Sid buffer size first, before resorting to alloc.
     */
    if ( !LookupAccountSid( NULL, pSid,
                            UserBuffer, &cUserBuffer,
                            DomainBuffer, &cDomainBuffer, &SidNameUse ) ) {

        if ( ((Error = GetLastError()) == ERROR_INSUFFICIENT_BUFFER) ) {

            if ( cDomainBuffer > (sizeof(DomainBuffer) / sizeof(WCHAR)) ) {

                if ( !(pDomainBuffer =
                        (PWCHAR)ALLOCMEM( RtlProcessHeap(), 0,
                            cDomainBuffer * sizeof(WCHAR))) ) {

                    Error = ERROR_NOT_ENOUGH_MEMORY;
                    goto BadDomainAlloc;
                }
            }

            if ( cUserBuffer > (sizeof(UserBuffer) / sizeof(WCHAR)) ) {

                if ( !(pUserBuffer =
                        (PWCHAR)ALLOCMEM( RtlProcessHeap(), 0,
                            cUserBuffer * sizeof(WCHAR))) ) {

                    Error = ERROR_NOT_ENOUGH_MEMORY;
                    goto BadUserAlloc;
                }
            }

            if ( !LookupAccountSid( NULL, pSid,
                                     pUserBuffer ?
                                        pUserBuffer : UserBuffer,
                                     &cUserBuffer,
                                     pDomainBuffer ?
                                        pDomainBuffer : DomainBuffer,
                                     &cDomainBuffer,
                                     &SidNameUse ) ) {

                Error = GetLastError();
                goto BadLookup;
            }

        } else {

            goto BadLookup;
        }
    }

    /*
     * Copy the user name into the specified buffer, truncating if necessary.
     */
    wcsncpy( pUserName, pUserBuffer ? pUserBuffer : UserBuffer,
              ((*pcbUserName)-1) );
    pUserName[((*pcbUserName)-1)] = 0;
    *pcbUserName = wcslen(pUserName);

    /*
     * Free our allocs (if any) and return.
     */
    if ( pDomainBuffer )
        FREEMEM( RtlProcessHeap(), 0, pDomainBuffer);
    if ( pUserBuffer )
        FREEMEM( RtlProcessHeap(), 0, pUserBuffer);
    return;

/*--------------------------------------
 * Error clean-up and return...
 */
BadLookup:
BadUserAlloc:
BadDomainAlloc:
    if ( pDomainBuffer )
        FREEMEM( RtlProcessHeap(), 0, pDomainBuffer);
    if ( pUserBuffer )
        FREEMEM( RtlProcessHeap(), 0, pUserBuffer);
    wcsncpy( pUserName, pUnknown, ((*pcbUserName)-1) );
    pUserName[((*pcbUserName)-1)] = 0;
    *pcbUserName = wcslen(pUserName);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\mulogoff.c ===
/****************************************************************************/
// mulogoff.c
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/

#ifdef _HYDRA_


/*****************************************************************************
 *
 *  ProcessLogoff
 *
 *   Do _HYDRA_ specific logoff processing
 *   Handle  logoff processing still under the users profile.
 *
 *   This is currently used to clean up auto created printers, but is
 *   designed for future logoff processing services, such as notifying
 *   a user global service controller to cancel per user services.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

VOID
ProcessLogoff(
    PTERMINAL pTerm
    )
{
    DWORD  Error;
    BOOLEAN Result;
    DWORD   RetVal;
    PWSTR   pszTok;
    HANDLE hProcess, hThread;
    TCHAR lpOldDir[MAX_PATH];
    HANDLE uh;
    PWSTR  pchData;
    PWINDOWSTATION pWS = pTerm->pWinStaWinlogon;

    if( !pTerm->UserLoggedOn ) {
        // Not logged on
        return;
    }

    /*
     * Notify the EXEC service that the user is
     * logging off.
     */
    CtxExecServerLogoff( pTerm );

    /*
     * See if there are logoff program(s) to run
     */
    pchData = AllocAndGetPrivateProfileString(
                  APPLICATION_NAME,
                  LOGOFFAPP_KEY,
                  TEXT(""),
                  NULL
                  );

    if( !pchData ) {
        // No string
        return;
    }

    //
    // We must unlock the Window station to allow the
    // new process to attach
    //
    UnlockWindowStation( pTerm->pWinStaWinlogon->hwinsta );

    lpOldDir[0] = 0;

    //
    // Save the current directory, then set it to the user's profile
    // (so that chgcdm can write there...even if C2 High security.
    //
    if (GetCurrentDirectory(MAX_PATH, lpOldDir)) {
       if (pWS->UserProcessData.CurrentDirectory[0]) {
          SetCurrentDirectory(pWS->UserProcessData.CurrentDirectory);
       }
    }

    //
    // Handle multiple commands, for MS additions
    //
    pszTok = wcstok(pchData, TEXT(","));
    while (pszTok) {
        if (*pszTok == TEXT(' '))
        {
            while (*pszTok++ == TEXT(' '))
                ;
        }


        Result = StartSystemProcess(
                     (LPTSTR)pszTok,
                     APPLICATION_DESKTOP_NAME,
                     HIGH_PRIORITY_CLASS | DETACHED_PROCESS,
                     STARTF_USESHOWWINDOW,     // Startup Flags
                     NULL,  // Environment
                     FALSE, // fSaveHandle
                     &hProcess,
                     &hThread
                     );

        if( Result ) {

            Error = WlxAssignShellProtection(
                        pTerm,
                        pTerm->pWinStaWinlogon->UserProcessData.UserToken,
                        hProcess,
                        hThread
                        );

            if( Error == 0 ) {

               // Wait for it to complete
               RetVal = WaitForSingleObject( hProcess, LOGOFF_CMD_TIMEOUT );

               if( RetVal != 0 ) {
                   //Logoff does not terminate process on timeout
                   DbgPrint("ProcessLogoff: Result %d, Error %d waiting for logoff command\n",RetVal,GetLastError());
               }

               CloseHandle(hThread);
               CloseHandle( hProcess );

            }
            else {
                // We do not run it unless its under user security
                DbgPrint("ProcessLogoff: Error %d creating user protection\n",Error);

                TerminateProcess( hProcess, 0 );
                CloseHandle( hThread );
                CloseHandle( hProcess );
            }
        }
        else {
            DbgPrint("ProcessLogoff: Could process logoff command %d\n",GetLastError());
        }

        pszTok = wcstok(NULL, TEXT(","));
    }

    Free( pchData );

    //
    // Restore the old directory
    //
    if (lpOldDir[0]) {
       SetCurrentDirectory(lpOldDir);
    }

    //
    // Relock the WindowStation
    //
    LockWindowStation( pTerm->pWinStaWinlogon->hwinsta );

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\rdpprutl.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name :
    
    rdpprutl.h

Abstract:

	Contains print redirection supporting routines for the TS printer
	redirection user-mode component.

    This is a supporting module.  The main module is umrdpdr.c.
    
Author:

    TadB

Revision History:
--*/

#ifndef _RDPPRUTL_
#define _RDPPRUTL_

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

    
//  Return a new default printer security descriptor.  
PSECURITY_DESCRIPTOR RDPDRUTL_CreateDefaultPrinterSecuritySD(
   IN PSID userSid
   );

//  Initialize this module.  This must be called prior to any other functions
//  in this module being called.
BOOL RDPDRUTL_Initialize(
    IN  HANDLE hTokenForLoggedOnUser
    );

//  Map a source printer driver name to a destination printer driver name.
BOOL RDPDRUTL_MapPrintDriverName(
    IN  PCWSTR driverName,
    IN  PCWSTR infName,
    IN  PCWSTR sectionName,
    IN  ULONG sourceFieldOfs,
    IN  ULONG dstFieldOfs,
    OUT PWSTR retBuf,
    IN  DWORD retBufSize,
    OUT PDWORD requiredSize
    );

//  Remove all TS printers on the system.
DWORD RDPDRUTL_RemoveAllTSPrinters();

//  Close down this module.  Right now, we just need to shut down the
//  background thread.
void RDPDRUTL_Shutdown();

//  Return whether an open printer is a TSRDP printer.
BOOL RDPDRUTL_PrinterIsTS(
    IN PWSTR printerName
    );

#ifdef __cplusplus
}
#endif // __cplusplus

#endif //#ifndef _RDPPRUTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\notify.c ===
/****************************************************************************/
// notify.c
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "errorlog.h"
#include "regapi.h"
#include "drdbg.h"
#include "rdpprutl.h"
#include "Sddl.h"
//
//  Some helpful tips about winlogon's notify events
//
//  1)  If you plan to put up any UI at logoff, you have to set
//      Asynchronous flag to 0.  If this isn't set to 0, the user's
//      profile will fail to unload because UI is still active.
//
//  2)  If you need to spawn child processes, you have to use
//      CreateProcessAsUser() otherwise the process will start
//      on winlogon's desktop (not the user's)
//
//  2)  The logon notification comes before the user's network
//      connections are restored.  If you need the user's persisted
//      net connections, use the StartShell event.
//
//


//  Global debug flag.
extern DWORD GLOBAL_DEBUG_FLAGS;

BOOL g_Console = TRUE;
ULONG g_SessionId;
BOOL g_InitialProg = FALSE;
HANDLE hExecProg;
HINSTANCE g_hInstance = NULL;
CRITICAL_SECTION GlobalsLock;
CRITICAL_SECTION ExecProcLock;
BOOL g_IsPersonal;
BOOL bInitLocks = FALSE;


#define NOTIFY_PATH   TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\\HydraNotify")
#define VOLATILE_PATH TEXT("Volatile Environment")
#define STARTUP_PROGRAM               TEXT("StartupPrograms")
#define APPLICATION_DESKTOP_NAME      TEXT("Default")
#define WINDOW_STATION_NAME           TEXT("WinSta0")

#define IsTerminalServer() (BOOLEAN)(USER_SHARED_DATA->SuiteMask & (1 << TerminalServer))

PCRITICAL_SECTION
CtxGetSyslibCritSect(void);



BOOL TSDLLInit(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    NTSTATUS Status;
    OSVERSIONINFOEX versionInfo;
    static BOOL sLogInit = FALSE;

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            {
                if (!IsTerminalServer()) {
                   return FALSE;
                }
                g_hInstance = hInstance;
                if (g_SessionId = NtCurrentPeb()->SessionId) {
                    g_Console = FALSE;
                }

                Status = RtlInitializeCriticalSection( &GlobalsLock );
                if( !NT_SUCCESS(Status) ) {
                    OutputDebugString (TEXT("LibMain (PROCESS_ATTACH): Could not initialize critical section\n"));
                    return(FALSE);
                }
                Status = RtlInitializeCriticalSection( &ExecProcLock );
                if( !NT_SUCCESS(Status) ) {
                    OutputDebugString (TEXT("LibMain (PROCESS_ATTACH): Could not initialize critical section\n"));
                    RtlDeleteCriticalSection( &GlobalsLock );
                    return(FALSE);
                }

                if (CtxGetSyslibCritSect() != NULL) {
                    TsInitLogging();
                    sLogInit = TRUE;
                }else{
                    RtlDeleteCriticalSection( &GlobalsLock );
                    RtlDeleteCriticalSection( &ExecProcLock );
                    return FALSE;
                }

                //
                //  Find out if we are running Personal.
                //
                versionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
                if (!GetVersionEx((LPOSVERSIONINFO)&versionInfo)) {
                    DBGMSG(DBG_TRACE, ("GetVersionEx:  %08X\n", GetLastError())); 
                    RtlDeleteCriticalSection( &GlobalsLock );
                    RtlDeleteCriticalSection( &ExecProcLock );
                    return FALSE;
                }
                g_IsPersonal = (versionInfo.wProductType == VER_NT_WORKSTATION) && 
                               (versionInfo.wSuiteMask & VER_SUITE_PERSONAL);
                
                bInitLocks = TRUE;
            }
            break;
        case DLL_PROCESS_DETACH:
            {
				PRTL_CRITICAL_SECTION pLock = NULL;

                g_hInstance = NULL;
                if (sLogInit) {
                    TsStopLogging();
					pLock = CtxGetSyslibCritSect();
					if (pLock)
						RtlDeleteCriticalSection(pLock);
                }
                if (bInitLocks) {
                    RtlDeleteCriticalSection( &GlobalsLock );
                    RtlDeleteCriticalSection( &ExecProcLock );
                    bInitLocks = FALSE;
                }
            }
            break;
    }

    return TRUE;

}


VOID ExecApplications() {
    BOOL      rc;
    ULONG     ReturnLength;
    WDCONFIG  WdInfo;


    //
    // HelpAssistant session doesn't need rdpclip.exe
    //
    if( WinStationIsHelpAssistantSession(SERVERNAME_CURRENT, LOGONID_CURRENT) ) {
        return;
    }

    //
    // Query winstation driver info
    //
    rc = WinStationQueryInformation(
            SERVERNAME_CURRENT,
            LOGONID_CURRENT,
            WinStationWd,
            (PVOID)&WdInfo,
            sizeof(WDCONFIG),
            &ReturnLength);

    if (rc) {
        if (ReturnLength == sizeof(WDCONFIG)) {
            HKEY  hSpKey;
            WCHAR szRegPath[MAX_PATH];

            //
            // Open winstation driver reg key
            //
            wcscpy( szRegPath, WD_REG_NAME );
            wcscat( szRegPath, L"\\" );
            wcscat( szRegPath, WdInfo.WdPrefix );
            wcscat( szRegPath, L"wd" );

            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegPath, 0, KEY_READ,
                   &hSpKey) == ERROR_SUCCESS) {
                DWORD dwLen;
                DWORD dwType;
                WCHAR szCmdLine[MAX_PATH];

                //
                // Get StartupPrograms string value
                //
                dwLen = sizeof( szCmdLine );
                if (RegQueryValueEx(hSpKey, STARTUP_PROGRAM, NULL, &dwType,
                        (PCHAR) &szCmdLine, &dwLen) == ERROR_SUCCESS) {
                    PWSTR               pszTok;
                    WCHAR               szDesktop[MAX_PATH];
                    STARTUPINFO         si;
                    PROCESS_INFORMATION pi;
                    LPBYTE              lpEnvironment = NULL;

                    //
                    // set STARTUPINFO fields
                    //
                    wsprintfW(szDesktop, L"%s\\%s", WINDOW_STATION_NAME,
                            APPLICATION_DESKTOP_NAME);
                    si.cb = sizeof(STARTUPINFO);
                    si.lpReserved = NULL;
                    si.lpTitle = NULL;
                    si.lpDesktop = szDesktop;
                    si.dwX = si.dwY = si.dwXSize = si.dwYSize = 0L;
                    si.dwFlags = STARTF_USESHOWWINDOW;
                    si.wShowWindow = SW_SHOWNORMAL | SW_SHOWMINNOACTIVE;
                    si.lpReserved2 = NULL;
                    si.cbReserved2 = 0;

                    //
                    // Get the user Environment block to be used in CreateProcessAsUser
                    //
                    if (CreateEnvironmentBlock (&lpEnvironment, g_UserToken, FALSE)) {
                        //
                        // Enumerate the StartupPrograms string,
                        //
                        pszTok = wcstok(szCmdLine, L",");
                        while (pszTok != NULL) {
                            // skip any white space
                            if (*pszTok == L' ') {
                                while (*pszTok++ == L' ');
                            }

                            //
                            // Call CreateProcessAsUser to start the program
                            //
                            si.lpReserved = (LPTSTR)pszTok;
                            si.lpTitle = (LPTSTR)pszTok;
                            rc = CreateProcessAsUser(
                                    g_UserToken,
                                    NULL,
                                    (LPTSTR)pszTok,
                                    NULL,
                                    NULL,
                                    FALSE,
                                    NORMAL_PRIORITY_CLASS | CREATE_UNICODE_ENVIRONMENT,
                                    lpEnvironment,
                                    NULL,
                                    &si,
                                    &pi);

                            if (rc) {
                                DebugLog((DEB_TRACE, "TSNOTIFY: successfully called CreateProcessAsUser for %s",
                                        (LPTSTR)pszTok));

                                CloseHandle(pi.hThread);
                                //CloseHandle(pi.hProcess);
                                hExecProg = pi.hProcess;
                            }
                            else {
                                DebugLog((DEB_ERROR, "TSNOTIFY: failed calling CreateProcessAsUser for %s",
                                        (LPTSTR)pszTok));
                            }

                            // move onto the next token
                            pszTok = wcstok(NULL, L",");
                        }
                        DestroyEnvironmentBlock(lpEnvironment);
                    }
                    else {
                        DebugLog((DEB_ERROR,
                            "TSNOTIFY: failed to get Environment block for user, %ld",
                            GetLastError()));

                    }
                }
                else {
                    DebugLog((DEB_ERROR, "TSNOTIFY: failed to read the StartupPrograms key"));
                }

                RegCloseKey(hSpKey);
            }
            else {
                DebugLog((DEB_ERROR, "TSNOTIFY: failed to open the rdpwd key"));
            }
        }
        else {
            DebugLog((DEB_ERROR, "TSNOTIFY: WinStationQueryInformation didn't return correct length"));
        }
    }
    else {
        DebugLog((DEB_ERROR, "TSNOTIFY: WinStationQueryInformation call failed"));
    }
}

VOID TSUpdateUserConfig( PWLX_NOTIFICATION_INFO pInfo) 
{

    HINSTANCE  hLib;
    typedef void ( WINAPI TypeDef_fp) ( HANDLE );
    TypeDef_fp  *fp1;


    hLib = LoadLibrary(TEXT("winsta.dll"));

    if ( !hLib)
    {
        DebugLog (( DEB_ERROR, "TSNOTIFY: Unable to load lib winsta.dll"));
        return;
    }

    fp1 = ( TypeDef_fp  *)
        GetProcAddress(hLib, "_WinStationUpdateUserConfig");
    
    if (fp1)
    {
        fp1 ( pInfo->hToken  );
    }
    else
    {
        DebugLog (( DEB_ERROR, "TSNOTIFY: Unable to find proc in winsta.dll"));
    }

    FreeLibrary(hLib);
}


VOID TSEventLogon (PWLX_NOTIFICATION_INFO pInfo)
{

    if (!IsTerminalServer()) {
       return;
    }

    g_UserToken = pInfo->hToken;

    if (!g_Console) {

        //
        // Notify the EXEC service that the user is
        // logged on
        //
        CtxExecServerLogon( pInfo->hToken );
    }


    EnterCriticalSection( &ExecProcLock );
    if (!IsActiveConsoleSession() && (hExecProg == NULL)) {

        //
        // Search for StartupPrograms string in Terminal Server WD registry key
        // and start processes as needed
        //
        ExecApplications();
    }
    LeaveCriticalSection( &ExecProcLock );
}

VOID TSEventLogoff (PWLX_NOTIFICATION_INFO pInfo)
{

    if (!IsTerminalServer()) {
       return;
    }

    if (!g_Console) {

        RemovePerSessionTempDirs();


        CtxExecServerLogoff();

    }


    if ( g_InitialProg ) {

        DeleteUserProcessMonitor( UserProcessMonitor );

    }


    if (g_Console) {

        //
        //Turn off the install mode if the console user is logging off
        //
        SetTermsrvAppInstallMode( FALSE );

    }


    EnterCriticalSection( &ExecProcLock );
    // Shut down the user-mode RDP device manager component.
    if (!g_IsPersonal) {
        UMRDPDR_Shutdown();
    }

    g_UserToken = NULL;
    CloseHandle(hExecProg);
    hExecProg = NULL;
    LeaveCriticalSection( &ExecProcLock );
}


VOID TSEventStartup (PWLX_NOTIFICATION_INFO pInfo)
{
    if (!IsTerminalServer()) {

      return;

    }
   
    if (!g_Console) {

        //
        // Start ExecServer thread
        //
        StartExecServerThread();
    }
}

VOID TSEventShutdown (PWLX_NOTIFICATION_INFO pInfo)
{
   if (!IsTerminalServer()) {

      return;

   }
   

    // Shut down the user-mode RDP device manager component.  This function can be
    // called multiple times, in the event that it was already called as a result of
    // a log off.
   if (!g_IsPersonal) {
        UMRDPDR_Shutdown();
   }
}

LPTSTR GetStringSid(PWLX_NOTIFICATION_INFO pInfo)
{
    LPTSTR sStringSid = NULL;
    DWORD ReturnLength = 0;
    PTOKEN_USER pTokenUser = NULL;
    PSID pSid = NULL;

    NtQueryInformationToken(pInfo->hToken,
                                TokenUser,
                                NULL,
                                0,
                                &ReturnLength);

    if (ReturnLength == 0)
        return NULL;

    pTokenUser = RtlAllocateHeap(RtlProcessHeap(), 0, ReturnLength);

    if (pTokenUser != NULL)
    {
        if (NT_SUCCESS(NtQueryInformationToken(pInfo->hToken,
                                                    TokenUser,
                                                    pTokenUser,
                                                    ReturnLength,
                                                    &ReturnLength)))
        {
            pSid = pTokenUser->User.Sid;
            if (pSid != NULL)
            {
                if (!ConvertSidToStringSid(pSid, &sStringSid))
                    sStringSid = NULL;
            }
        }
    }

    if (pTokenUser != NULL)
        RtlFreeHeap(RtlProcessHeap(), 0, pTokenUser);

    return sStringSid;
}

BOOL IsAppServer(void)
{
    OSVERSIONINFOEX osVersionInfo;
    DWORDLONG dwlConditionMask = 0;
    BOOL fIsWTS = FALSE;
    
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    fIsWTS = GetVersionEx((OSVERSIONINFO *)&osVersionInfo) &&
             (osVersionInfo.wSuiteMask & VER_SUITE_TERMINAL) &&
             !(osVersionInfo.wSuiteMask & VER_SUITE_SINGLEUSERTS);

    return fIsWTS;
}

VOID RemoveClassesKey(PWLX_NOTIFICATION_INFO pInfo)
{
    HINSTANCE  hLib;
    typedef BOOL ( WINAPI TypeDef_fp) (LPTSTR);
    TypeDef_fp  *fp1;
    LPTSTR sStringSid = NULL;

    sStringSid = GetStringSid(pInfo);
    if (sStringSid == NULL)
    {
        DebugLog((DEB_ERROR, "TSNOTIFY: Unable to obtain sid"));
        return;
    }

    hLib = LoadLibrary(TEXT("tsappcmp.dll"));

    if (!hLib)
    {
        DebugLog((DEB_ERROR, "TSNOTIFY: Unable to load lib tsappcmp.dll"));
        return;
    }

    fp1 = (TypeDef_fp*)
        GetProcAddress(hLib, "TermsrvRemoveClassesKey");
    
    if (fp1)
        fp1(sStringSid);
    else
        DebugLog((DEB_ERROR, "TSNOTIFY: Unable to find proc in tsappcmp.dll"));

    FreeLibrary(hLib);
}

VOID TSEventStartShell (PWLX_NOTIFICATION_INFO pInfo)
{
    if (!IsTerminalServer())
        return;

    // We are either a TS-App-Server, a TS-Remote-Admin, or a PTS since
    // IsTerminalServer() call is using the kernel flag to check this.

    // by now, group policy has update user's hive, so we can tell termsrv
    // to update user's config.

    TSUpdateUserConfig(pInfo);

    if (IsAppServer())
        RemoveClassesKey(pInfo);
}

VOID TSEventReconnect (PWLX_NOTIFICATION_INFO pInfo)
{
   if (!IsTerminalServer()) {

      return;

   }

   EnterCriticalSection( &ExecProcLock );
   if (!IsActiveConsoleSession()) {

       if (g_UserToken && hExecProg == NULL) {
          //
          // Search for StartupPrograms string in Terminal Server WD registry key
          // and start processes as needed
          //
          ExecApplications();
                        
          // Initialize the user-mode RDP device manager component.
          if (!g_IsPersonal) {
              if (!UMRDPDR_Initialize(g_UserToken)) {
                  WCHAR buf[256];
                  WCHAR *parms[1];
                  parms[0] = buf; 
                  wsprintf(buf, L"%ld", g_SessionId);
                  TsLogError(EVENT_NOTIFY_INIT_FAILED, EVENTLOG_ERROR_TYPE, 1, parms, __LINE__);
              }
          }
       }

   } else {

       if (hExecProg) {
          TerminateProcess(hExecProg, 0);
          CloseHandle(hExecProg);
          hExecProg = NULL;
       }
       // Shut down the user-mode RDP device manager component.
       if (!g_IsPersonal) {
        UMRDPDR_Shutdown();
       }
   }
   LeaveCriticalSection( &ExecProcLock );
}

VOID TSEventDisconnect (PWLX_NOTIFICATION_INFO pInfo)
{
   if (!IsTerminalServer()) {

      return;

   }


}

VOID TSEventPostShell (PWLX_NOTIFICATION_INFO pInfo)
{
    OSVERSIONINFOEX versionInfo;

    if (!IsTerminalServer()) {

       return;

    }

    if ( !g_Console ) {
        ULONG Length;
        BOOLEAN Result;
        WINSTATIONCONFIG ConfigData;


        Result = WinStationQueryInformation( SERVERNAME_CURRENT,
                                           LOGONID_CURRENT,
                                           WinStationConfiguration,
                                           &ConfigData,
                                           sizeof(ConfigData),
                                           &Length );


        if (Result && ConfigData.User.InitialProgram[0] &&
            lstrcmpi(ConfigData.User.InitialProgram, TEXT("explorer.exe"))) {

            if ( !(UserProcessMonitor = StartUserProcessMonitor()) ) {
                DebugLog((DEB_ERROR, "Failed to start user process monitor thread"));
            }

            g_InitialProg = TRUE;

        }
    }

    //
    //  Clean up old TS queues on Pro.
    //
    versionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if (!GetVersionEx((LPOSVERSIONINFO)&versionInfo)) {
        DBGMSG(DBG_TRACE, ("GetVersionEx:  %08X\n", GetLastError()));
        ASSERT(FALSE);
    }
    //
    //  This code only runs on Pro because it's the only platform where
    //  we can guarantee that we have one session per machine.  Printers are
    //  cleaned up on boot in Server.
    //
    else if ((versionInfo.wProductType == VER_NT_WORKSTATION) && 
             !(versionInfo.wSuiteMask & VER_SUITE_PERSONAL)) {
        RDPDRUTL_RemoveAllTSPrinters();
    }

    //
    //  This code shouldn't run on Personal.  Device redirection isn't 
    //  supported for Personal.
    //
    if (!g_IsPersonal) {
        EnterCriticalSection( &ExecProcLock );
        // Initialize the user-mode RDP device manager component.
        if (!UMRDPDR_Initialize(pInfo->hToken)) {
            WCHAR buf[256];
            WCHAR *parms[1];
            wsprintf(buf, L"%ld", g_SessionId);
            parms[0] = buf;
            TsLogError(EVENT_NOTIFY_INIT_FAILED, EVENTLOG_ERROR_TYPE, 1, parms, __LINE__);
        }
        LeaveCriticalSection(&ExecProcLock);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\rdpprutl.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name :

    rdpprutl.c

Abstract:

        Contains print redirection supporting routines for the TS printer
        redirection user-mode component.

    This is a supporting module.  The main module is umrdpdr.c.

Author:

    TadB

Revision History:
--*/

#include "precomp.h"
#pragma hdrstop

#include <winspool.h>
#include <setupapi.h>
#include "printui.h"
#include "drdbg.h"
#include <regapi.h>
#include <aclapi.h>
#include "errorlog.h"
#include "tsnutl.h"
#include <wlnotify.h>
#include <wchar.h>


////////////////////////////////////////////////////////
//
//      Defines
//

#define SETUPAPILIBNAME  TEXT("setupapi.dll")
#define ISNUM(c) ((c>='0')&&(c<='9'))


////////////////////////////////////////////////////////
//
//      Globals
//

extern DWORD GLOBAL_DEBUG_FLAGS;
HANDLE   SetupAPILibHndl            = NULL;
FARPROC  SetupOpenInfFileFunc       = NULL;
FARPROC  SetupFindFirstLineFunc     = NULL;
FARPROC  SetupFindNextLineFunc      = NULL;
FARPROC  SetupGetStringFieldFunc    = NULL;


////////////////////////////////////////////////////////
//
//      Internal Prototypes
//

//  Loads setupapi.dll and related functions.
BOOL LoadSetupAPIDLLFunctions();
void DeleteTSPrinters(
    IN PRINTER_INFO_5 *pPrinterInfo,
    IN DWORD count
    );

BOOL
RDPDRUTL_Initialize(
    IN  HANDLE hTokenForLoggedOnUser
    )
/*++

Routine Description:

    Initialize this module.  This must be called prior to any other functions
    in this module being called.

Arguments:

    hTokenForLoggedOnUser - This is the token for the logged in user.

Return Value:

    Returns TRUE on success.  FALSE, otherwise.

--*/
{
    DBGMSG(DBG_TRACE, ("RDPPRUTL:RDPDRUTL_Initialize.\n"));

    //
    //  Make sure we don't get called twice.
    //
    ASSERT(SetupAPILibHndl == NULL);

    //
    //  Load Setup API Library.
    //
    DBGMSG(DBG_TRACE, ("RDPPRUTL:RDPDRUTL_Initialize done.\n"));

    //  Just return TRUE for now.
    return TRUE;
}

void
RDPDRUTL_Shutdown()
/*++

Routine Description:

    Close down this module.  Right now, we just need to shut down the
    background thread.

Arguments:

Return Value:

    Returns TRUE on success.  FALSE, otherwise.

--*/
{
    DBGMSG(DBG_TRACE, ("RDPPRUTL:RDPDRUTL_Shutdown.\n"));

    //
    //  Release the Setup API library.
    //
    if (SetupAPILibHndl != NULL) {
        FreeLibrary(SetupAPILibHndl);
        SetupAPILibHndl = NULL;
    }

    //
    //  Zero the entry points.
    //
    SetupOpenInfFileFunc       = NULL;
    SetupFindFirstLineFunc     = NULL;
    SetupFindNextLineFunc      = NULL;
    SetupGetStringFieldFunc    = NULL;

    //
    //  Load Setup API Library.
    //
    DBGMSG(DBG_TRACE, ("RDPPRUTL:RDPDRUTL_Shutdown done.\n"));
}


BOOL
LoadSetupAPIDLLFunctions()
/*++

Routine Description:

    Loads setupapi.dll and related functions.

Arguments:

Return Value:

    Returns TRUE on success.  FALSE, otherwise.
--*/
{
    BOOL result;

    //
    //  Only load if we are not already loaded.
    //
    if (SetupAPILibHndl == NULL) {
        SetupAPILibHndl = LoadLibrary(SETUPAPILIBNAME);

        result = (SetupAPILibHndl != NULL);
        if (!result) {
            DBGMSG(DBG_ERROR,
                ("RDPPRUTL:Unable to load SETUPAPI DLL. Error: %ld\n",
                GetLastError()));
        }
        else {
            SetupOpenInfFileFunc    = GetProcAddress(SetupAPILibHndl,
                                                    "SetupOpenInfFileW");
            SetupFindFirstLineFunc  = GetProcAddress(SetupAPILibHndl,
                                                    "SetupFindFirstLineW");
            SetupFindNextLineFunc   = GetProcAddress(SetupAPILibHndl,
                                                    "SetupFindNextLine");
            SetupGetStringFieldFunc = GetProcAddress(SetupAPILibHndl,
                                                    "SetupGetStringFieldW");

            //
            //  If we failed to load any of the functions.
            //
            if ((SetupOpenInfFileFunc == NULL)    ||
                (SetupFindFirstLineFunc == NULL)  ||
                (SetupFindNextLineFunc == NULL)   ||
                (SetupGetStringFieldFunc == NULL)) {

                DBGMSG(DBG_ERROR,
                    ("RDPPRUTL:Failed to load setup func. Error: %ld\n",
                    GetLastError()));

                FreeLibrary(SetupAPILibHndl);
                SetupAPILibHndl = NULL;

                SetupOpenInfFileFunc       = NULL;
                SetupFindFirstLineFunc     = NULL;
                SetupFindNextLineFunc      = NULL;
                SetupGetStringFieldFunc    = NULL;

                result = FALSE;
            }
            else {
                result = TRUE;
            }
        }
    }
    else {
        result = TRUE;
    }
    return result;
}

BOOL
RDPDRUTL_PrinterIsTS(
    IN PWSTR printerName
)
/*++

Routine Description:

    Return whether an open printer is a TSRDP printer.

Arguments:

    printerName -   Name of printer to check.

Return Value:

    Returns TRUE if the printer is a TS printer.  Otherwise, FALSE is
    returned.
--*/
{
    DWORD regValueDataType;
    DWORD sessionID;
    DWORD bufSize;
    HANDLE hPrinter;
    PRINTER_DEFAULTS defaults = {NULL, NULL, PRINTER_ALL_ACCESS};
    BOOL result;

    DBGMSG(DBG_TRACE, ("RDPPRUTL:Entering RDPDRUTL_PrinterIsTS.\n"));

    //
    //  Open the printer.
    //
    result = OpenPrinter(printerName, &hPrinter, &defaults);

    //
    //  See if a session id for the printer defined in its associated
    //  registry information.
    //
    if (result) {
        result = GetPrinterData(
                       hPrinter,
                       DEVICERDR_SESSIONID,
                       &regValueDataType,
                       (PBYTE)&sessionID, sizeof(sessionID),
                       &bufSize
                       ) == ERROR_SUCCESS;
        ClosePrinter(hPrinter);
    }
    else {
        DBGMSG(DBG_ERROR, ("RDPPRUTL:Error opening %ws:  %ld.\n",
                printerName, GetLastError()));
    }

    DBGMSG(DBG_TRACE, ("RDPPRUTL:Exiting RDPDRUTL_PrinterIsTS.\n"));

    return result;
}

BOOL
RDPDRUTL_MapPrintDriverName(
    IN  PCWSTR driverName,
    IN  PCWSTR infName,
    IN  PCWSTR sectionName,
    IN  ULONG srcFieldOfs,
    IN  ULONG dstFieldOfs,
    OUT PWSTR retBuf,
    IN  DWORD retBufSize,
    OUT PDWORD requiredSize
    )
/*++

Routine Description:

    Map a client-side printer driver name to its server-side equivalent,
    using the specified INF and section name.

Arguments:

    driverName              - Driver name to map.
    infName                 - Name of INF mapping file.
    sectionName             - Name of INF mapping section.
    srcFieldOfs             - In mapping section, the field offset (0-based)
                              of the source name.
    dstFieldOfs             - In mapping section, the field offset (0-based)
                              of the resulting name.
    retBuf                  - Mapped driver name.
    retBufSize              - Size in characters of retBuf.
    requiredSize            - Required size (IN CHARACTERS) of return buffer is
                              returned here.  GetLastError() will return
                              ERROR_INSUFFICIENT_BUFFER if the supplied
                              buffer was too small for the operation
                              to successfully complete.

Return Value:

    Returns TRUE on success.  FALSE, otherwise.  If there is not room in
    retBuf, then FALSE is returned and GetLastError() will return
    ERROR_INSUFFICIENT_BUFFER.

    Extended error information can be retrieved by a call to GetLastError.
--*/
{
    HINF inf;
    PWSTR returnString = NULL;
    BOOL outOfEntries;
    BOOL result = TRUE;
    INFCONTEXT infContext;
    WCHAR  *parms[1];

    DBGMSG(DBG_TRACE, ("RDPPRUTL:Entering RDPDRUTL_MapPrintDriverName.\n"));

    //
    //  Just get out fast if we can't load the setup API's
    //

    if (!LoadSetupAPIDLLFunctions()) {

        //
        //  Need to make sure it didn't fail because of insufficient buffer
        //  because that has meaning when returned from this function.
        //
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            SetLastError(ERROR_NOT_ENOUGH_SERVER_MEMORY);
        }
        return FALSE;
    }

    //
    //  Open the INF.
    //
    inf = SetupOpenInfFile(
                infName, NULL,
                INF_STYLE_OLDNT | INF_STYLE_WIN4,
                NULL
                );

    //
    //  Get the first entry from the INF section.
    //
    if (inf != INVALID_HANDLE_VALUE) {
        
        memset(&infContext, 0, sizeof(infContext));
        
        outOfEntries = !SetupFindFirstLine(inf, sectionName, NULL, &infContext);

        if (!outOfEntries) {
            result = SetupGetStringField(&infContext, srcFieldOfs, retBuf,retBufSize,
                                     requiredSize);

            //
            //  This API returns success with no error code for a NULL buffer.
            //
            if (result && (retBuf == NULL)) {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                result = FALSE;
            }
        }
        else {
            DBGMSG(DBG_ERROR, ("RDPPRUTL:SetupFindFirstLine failed with %08X.\n",  GetLastError()));
            result = FALSE;
        }
    }
    else {
        DBGMSG(DBG_ERROR, ("RDPPRUTL:SetupOpenInfFile failed with %08X.\n",
                GetLastError()));
        outOfEntries = TRUE;
        result = FALSE;
    }

    //
    //  Look through the INF for a matching name in the INF mapping section.
    //
    while (result && !outOfEntries) {
        //
        //  If we have a match, then read the first field out of the current entry.
        //  This is the information that we should return.
        //
        if (!wcscmp(retBuf, driverName)) {
            result = SetupGetStringField(&infContext, dstFieldOfs, retBuf,retBufSize,
                                         requiredSize);
            if (result) {
                DBGMSG(DBG_TRACE, ("RDPPRUTL:Found match %ws in INF for %ws.\n",
                       driverName, retBuf));
            }
            else {
                DBGMSG(DBG_TRACE, ("RDPPRUTL:Error processing INF for %ws.\n",
                        driverName));
            }
            break;
        }

        //
        //  Get the next entry.
        //
        outOfEntries = !SetupFindNextLine(&infContext, &infContext);

        if (!outOfEntries) {
            result = SetupGetStringField(&infContext, srcFieldOfs, retBuf, retBufSize,
                                         requiredSize);
        }
    }

    //
    //  Close the INF.
    //
    if (inf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(inf);
    }

    //
    //  Log an error if there was a real problem.
    //
    if (!result && (GetLastError() != ERROR_INSUFFICIENT_BUFFER)) {
        ASSERT((sizeof(parms)/sizeof(WCHAR *)) >= 1);
        parms[0] = (WCHAR *)infName;
        TsLogError(EVENT_NOTIFY_ERRORPARSINGINF, EVENTLOG_ERROR_TYPE,
                    1, parms, __LINE__);
    }

    DBGMSG(DBG_ERROR, ("RDPPRUTL:Finished RDPDRUTL_MapPrintDriverName.\n"));

    return result && !outOfEntries;
}

PACL
GiveLoggedOnUserFullPrinterAccess(
    IN LPTSTR printerName,
    IN HANDLE hTokenForLoggedOnUser,
    PSECURITY_DESCRIPTOR *ppsd
)
/*++

Routine Description:

    Give the logged on user full privilege to manage the specified
    printer.  The original DACL is returned on success.  It can be
    used to restore the security settings to what they were prior to
    calling this function.

    When the caller is done with the returned PSD, it should be freed
    using LocalFree. Don't free DACL, it is contained in PSD.

Arguments:

    printerName             -   The name of the relevant printer.
    hTokenForLoggedOnUser   -   Token for logged on user.
    ppsd                    -   Pointer to the return security descriptor
                                parameter.

Return Value:

    NULL on error.  Otherwise, a pointer to the original DACL is
    returned.

--*/
{
    PACL pOldDacl = NULL;
    PACL pNewDacl = NULL;
    ULONG dwResult;
    PSID psidUser = NULL;
    DWORD dwDaclLength;
    DWORD index;
    ACCESS_ALLOWED_ACE  *pDaclAce;
    PSECURITY_DESCRIPTOR psd = NULL;
    SECURITY_DESCRIPTOR_CONTROL sdcSDControl;
    DWORD dwSDRevision;
    PSID psidEveryone = NULL;
    SID_IDENTIFIER_AUTHORITY sidEveryoneAuthority = SECURITY_WORLD_SID_AUTHORITY;
    WCHAR *eventLogParam;

    DBGMSG(DBG_INFO, ("UMRDPPRN:GiveLoggedOnUserFullPrinterAccess entered.\n"));

    //
    // Get the Security descriptor for the printer
    //
    dwResult = GetNamedSecurityInfoW(
        (LPTSTR)printerName,        //Object Name
        SE_PRINTER,                 //Object Type
        DACL_SECURITY_INFORMATION,  //Security Information to retrieve
        NULL,                       //ppsidOwner
        NULL,                       //ppsidGroup
        &pOldDacl,                  //pointer to Dacl
        NULL,                       //pointer to Sacl
        &psd                        //pointer to Security Descriptor
        );

    //
    //      NULL is a valid return value for a Dacl from GetNamedSecurityInfo, but
    //      is not valid for a printer.
    //
    if ((dwResult == ERROR_SUCCESS) && (pOldDacl == NULL)) {
            DBGMSG(DBG_ERROR, ("UMRDPPRN: NULL Dacl.\n"));
            dwResult = ERROR_INVALID_ACL;
            ASSERT(FALSE);
    }

    //
    //  Get the SID for the logged on user.
    //
    if (dwResult == ERROR_SUCCESS) {

        ASSERT(IsValidAcl(pOldDacl));

        if ((psidUser = TSNUTL_GetUserSid(hTokenForLoggedOnUser)) == NULL) {
            dwResult = GetLastError();
            DBGMSG(DBG_ERROR, ("UMRDPPRN: Failed to get user SID:  %ld\n",
                    dwResult));
        }
    }

    //
    //  Get the SID for the "Everyone" group.
    //
    if (dwResult == ERROR_SUCCESS) {
        if (!AllocateAndInitializeSid (
                &sidEveryoneAuthority,          // pIdentifierAuthority
                1,                              // count of subauthorities
                SECURITY_WORLD_RID,             // subauthority 0
                0, 0, 0, 0, 0, 0, 0,            // subauthorities n
                &psidEveryone)) {               // pointer to pointer to SID
            dwResult = GetLastError();
            DBGMSG(DBG_ERROR,
                ("UMRDPDR:AllocateAndInitializeSid Failed for Everyone, Error: %ld\n",
                dwResult));
        }
    }

    //
    //  Get SD control bits
    //
    if (dwResult == ERROR_SUCCESS) {
        if (!GetSecurityDescriptorControl(
                psd,
                (PSECURITY_DESCRIPTOR_CONTROL)&sdcSDControl,
                (LPDWORD) &dwSDRevision
                )) {
            dwResult = GetLastError();
            DBGMSG(DBG_ERROR,
                ("UMRDPDR:GetSecurityDescriptorControl %ld\n", dwResult));
        }
    }

    //
    //  Calculate the size of the new ACL.
    //
    if (dwResult == ERROR_SUCCESS) {
        dwDaclLength = sizeof(ACL);

        //  For logged on user ACE, first set of permissions.
        dwDaclLength += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                            GetLengthSid(psidUser);

        //  For logged on user ACE, second set of permissions.
        dwDaclLength += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                            GetLengthSid(psidUser);

        //  Add some room for existing entries.
        if (SE_DACL_PRESENT & sdcSDControl) {
                dwDaclLength += pOldDacl->AclSize;
        }
    }

    //
    //  Create the new DACL.
    //
    if (dwResult == ERROR_SUCCESS) {
        pNewDacl = (PACL)LocalAlloc(LMEM_FIXED, dwDaclLength);
        if (pNewDacl == NULL) {
            DBGMSG(DBG_ERROR, ("UMRDPPRN:Failed to allocate new ACL.\n"));
            dwResult = ERROR_INSUFFICIENT_BUFFER;
        }
    }

    //
    //  Initialize it.
    //
    if (dwResult == ERROR_SUCCESS) {
        if (!InitializeAcl(pNewDacl, dwDaclLength, ACL_REVISION)) {
            dwResult = GetLastError();
            DBGMSG(DBG_ERROR, ("UMRDPPRN:InitializeAcl: %ld\n", dwResult));
        }
    }

    //
    //  Copy the ACE's from the old DACL to the new one.
    //
    for (index = 0; (dwResult == ERROR_SUCCESS) &&
                    (index < pOldDacl->AceCount); index++) {

        if (!GetAce(pOldDacl, index, (LPVOID *)&pDaclAce)) {
            dwResult = GetLastError();
            DBGMSG(DBG_ERROR, ("UMRDPPRN:GetAce Failed, Error: %ld\n", dwResult));
        }
        else {
            //
            //  Copy the ACE if it is not for "Everyone" because the "Everyone"
            //  group denies us access.
            //
            if (!EqualSid((PSID) &(pDaclAce->SidStart), psidEveryone)) {

                //
                //  If it's a deny access ACE.
                //
                if (pDaclAce->Header.AceType == ACCESS_DENIED_ACE_TYPE ||
                    pDaclAce->Header.AceType == ACCESS_DENIED_OBJECT_ACE_TYPE) {

                    if (!AddAccessDeniedAce(
                                    pNewDacl, ACL_REVISION, pDaclAce->Mask,
                                    (PSID)&(pDaclAce->SidStart))
                                    ) {
                       dwResult = GetLastError();
                       DBGMSG(DBG_ERROR,
                           ("UMRDPPRN:AddAccessDeniedAce Failed, Error: %ld\n", dwResult));
                   }
                }
                //
                //  Otherwise, it's an add access ACE.
                //
                else {
                    if (!AddAccessAllowedAce(
                                pNewDacl,
                                ACL_REVISION,
                                pDaclAce->Mask,
                                (PSID)&(pDaclAce->SidStart))) {
                        dwResult = GetLastError();
                        DBGMSG(DBG_ERROR,
                           ("UMRDPPRN:AddAccessAllowedAce Failed, Error: %ld\n", dwResult));
                   }
                }
            }
        }
    }

    //
    //  Give the user full privilege
    //
    if (dwResult == ERROR_SUCCESS) {
        if ( ! AddAccessAllowedAce (
                    pNewDacl,
                    ACL_REVISION,
                    PRINTER_READ | PRINTER_WRITE | PRINTER_EXECUTE
                    | PRINTER_ALL_ACCESS,
                    psidUser) ) {

            dwResult = GetLastError();
            DBGMSG(DBG_ERROR,
                ("UMRDPDR:AddAccessAllowedAce Failed for Current User, Error: %ld\n",
                dwResult));
        }

        if ( ! AddAccessAllowedAceEx (
                    pNewDacl,
                    ACL_REVISION,
                    OBJECT_INHERIT_ACE | INHERIT_ONLY_ACE,
                    JOB_ALL_ACCESS | GENERIC_ALL,
                    psidUser) ) {

            dwResult = GetLastError();
            DBGMSG(DBG_ERROR,
                ("UMRDPDR:AddAccessAllowedAce Failed for Current User, Error: %ld\n",
                dwResult));
        }

        //
        //  Check the integrity of the new DACL.
        //
        ASSERT(IsValidAcl(pNewDacl));
    }

    //
    //  Add the new settings to the printer.
    //
    if (dwResult == ERROR_SUCCESS) {
        dwResult = SetNamedSecurityInfoW(
                        (LPTSTR)printerName,        //Object Name
                        SE_PRINTER,                 //Object Type
                        DACL_SECURITY_INFORMATION,  //Security Information to set
                        NULL,                       //psidOwner
                        NULL,                       //psidGroup
                        pNewDacl,                   //pDacl
                        NULL                        //pSacl
                        );
        if (dwResult != ERROR_SUCCESS) {
            DBGMSG(DBG_ERROR, ("UMRDPPRN:SetNamedSecurityInfoW returned %ld\n",
                    dwResult));
        }
    }

    //
    //  Log an event if this function failed.
    //
    if (dwResult != ERROR_SUCCESS) {
        eventLogParam = printerName;

        DBGMSG(DBG_ERROR,
              ("UMRDPDR:GiveLoggedOnUserFullPrinterAccess failed with Error Code: %ld.\n",
              dwResult));

        SetLastError(dwResult);
        TsLogError(EVENT_NOTIFY_SET_PRINTER_ACL_FAILED,
            EVENTLOG_ERROR_TYPE,
            1,
            &eventLogParam,
            __LINE__);

        //
        //      Release the security descriptor.  This effectively releases the Dacl returned
        //      by GetNamedSecurityInfo.
        //
        if (psd) LocalFree(psd);

        //
        // return NULL values when unsuccessful.
        //
        pOldDacl = NULL;
        psd = NULL;
    }

    //
    //  Clean up and return.
    //
    if (pNewDacl) LocalFree(pNewDacl);
    if (psidUser) LocalFree(psidUser);
    if (psidEveryone) FreeSid(psidEveryone);

    //
    // set return parameter.
    //
    ASSERT( ppsd != NULL );
    if( ppsd ) *ppsd = psd;

    DBGMSG(DBG_INFO, ("UMRDPPRN:GiveLoggedOnUserFullPrinterAccess done.\n"));
    return pOldDacl;
}

DWORD
SetPrinterDACL(
    IN LPTSTR printerName,
    IN PACL pDacl
)
/*++

Routine Description:

    Set the current security settings for a printer to the specified
    DACL.

Arguments:

    printerName -   The name of the relevant printer.
    pDacl       -   The DACL.  This function does not free the memory
                    associated with this data structure.

Return Value:

    ERROR_SUCCESS on success.  Windows error code is returned otherwise.

--*/
{
    DWORD dwResult;

    DBGMSG(DBG_TRACE, ("UMRDPDR:SetPrinterDACL entered\n"));
    dwResult = SetNamedSecurityInfoW(
                    (LPTSTR)printerName,        //Object Name
                    SE_PRINTER,                 //Object Type
                    DACL_SECURITY_INFORMATION,  //Security Information to set
                    NULL,                       //psidOwner
                    NULL,                       //psidGroup
                    pDacl,                      //pDacl
                    NULL                        //pSacl
                    );
    if (dwResult != ERROR_SUCCESS) {
        DBGMSG(DBG_ERROR, ("UMRDPPRN:SetNamedSecurityInfoW returned %ld\n",
                dwResult));
    }

    DBGMSG(DBG_TRACE, ("UMRDPDR:SetPrinterDACL done\n"));
    return dwResult;
}

PSECURITY_DESCRIPTOR
RDPDRUTL_CreateDefaultPrinterSecuritySD(
   IN PSID userSid
   )
{
/*++

Routine Description:

    Return a new default printer security descriptor.  The default
    settings are:

    1. Administrators: All privileges
    2. Current Logon user: Manager personal preferences and printing only.
    3. Creator_Owner: This function adds document management privilege
    4. Everyone:  Permission for the "Everyone" group is completely removed.

Arguments:

    userSid  -   SID, identifying the current TS session/user.

Return Value:

    A valid security desriptor or NULL on error.  The caller should release
    the returned security descriptor and its contained Dacl in a single call
    to LocalFree.

    GetLastError can be used to retrieve the error status on error.

--*/
    PACL pNewDacl = NULL;
    PSID psidAdmin = NULL;
    PSID psidCreatorOwner = NULL;
    PSID psidPowerUser = NULL;
    DWORD len;
    PBYTE sdBuf;

    DWORD       dwSDRevision;
    DWORD       dwDaclLength;

    DWORD dwReturnValue = ERROR_SUCCESS;

    PSECURITY_DESCRIPTOR psd = NULL;

    SID_IDENTIFIER_AUTHORITY sidNTAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY sidCreatorOwnerAuthority = SECURITY_CREATOR_SID_AUTHORITY;

    ACCESS_ALLOWED_ACE  *pDaclAce;

    DWORD index;        //for use in a for loop
    DWORD dwResult;

    DBGMSG(DBG_TRACE, ("UMRDPDR:RDPDRUTL_CreateDefaultPrinterSecuritySD entered\n"));

    //
    //  Get SID of Administrators
    //
    if (!AllocateAndInitializeSid (
            &sidNTAuthority,                // pIdentifierAuthority
            2,                              // count of subauthorities
            SECURITY_BUILTIN_DOMAIN_RID,    // subauthority 0
            DOMAIN_ALIAS_RID_ADMINS,        // subauthority 1
            0, 0, 0, 0, 0, 0,               // subauthorities n
            &psidAdmin)) {                  // pointer to pointer to SID
        dwReturnValue = GetLastError();
        DBGMSG(DBG_ERROR,
            ("UMRDPDR:AllocateAndInitializeSid Failed for Admin, Error: %ld\n",
            dwReturnValue ));
        goto CLEANUPANDEXIT;
    }

    //
    //  Get SID of CreatorOwner
    //
    if (!AllocateAndInitializeSid (
            &sidCreatorOwnerAuthority,          // pIdentifierAuthority
            1,                                  // count of subauthorities
            SECURITY_CREATOR_OWNER_RID,         // subauthority 0
            0, 0, 0, 0, 0, 0, 0,                // subauthorities n
            &psidCreatorOwner)) {               // pointer to pointer to SID
        dwReturnValue = GetLastError();
        DBGMSG(DBG_ERROR,
            ("UMRDPDR:AllocateAndInitializeSid Failed for CreatorOwner, Error: %ld\n",
            GetLastError() ));
        goto CLEANUPANDEXIT;
    }

    //
    // Get SID of Power Users
    //
    if (!AllocateAndInitializeSid (
            &sidNTAuthority,                // pIdentifierAuthority
            2,                              // count of subauthorities
            SECURITY_BUILTIN_DOMAIN_RID,    // subauthority 0
            DOMAIN_ALIAS_RID_POWER_USERS,   // subauthority 1
            0, 0, 0, 0, 0, 0,               // subauthorities n
            &psidPowerUser)) {              // pointer to pointer to SID
        dwReturnValue = GetLastError();
        DBGMSG(DBG_ERROR,
            ("UMRDPDR:AllocateAndInitializeSid Failed for Power User, Error: %ld\n",
            dwReturnValue ));
        goto CLEANUPANDEXIT;
    }


    //
    //  Get size of memory needed for new DACL
    //
    dwDaclLength = sizeof(ACL);
    dwDaclLength += 2* (sizeof(ACCESS_ALLOWED_ACE) -
        sizeof (DWORD) + GetLengthSid(psidAdmin));         //For Admin ACE

    dwDaclLength += 3 * (sizeof(ACCESS_ALLOWED_ACE) -
        sizeof (DWORD) + GetLengthSid(userSid));           //For Session/User ACE

    dwDaclLength += 2* (sizeof(ACCESS_ALLOWED_ACE) -
        sizeof (DWORD) + GetLengthSid(psidCreatorOwner));  //For Creator_Owner ACE

    dwDaclLength += 2* (sizeof(ACCESS_ALLOWED_ACE) -
        sizeof (DWORD) + GetLengthSid(psidPowerUser));     //For PowerUser ACE

    //
    //  Allocate the new security descriptor and the dacl in one chunk.
    //
    sdBuf = LocalAlloc(LMEM_FIXED, sizeof(SECURITY_DESCRIPTOR) + dwDaclLength);
    if (sdBuf == NULL) {
        DBGMSG(DBG_ERROR, ("LocalAlloc failed.\n"));
        dwReturnValue = ERROR_OUTOFMEMORY;
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the security descriptor.
    //
    psd = (PSECURITY_DESCRIPTOR)sdBuf;
    if (!InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION)) {
        DBGMSG(DBG_ERROR, ("InitializeSecurityDescriptor failed.\n"));
        dwReturnValue = GetLastError();
        goto CLEANUPANDEXIT;
    }

    //
    //  Init new DACL
    //
    pNewDacl = (PACL)(sdBuf + sizeof(SECURITY_DESCRIPTOR));
    if (!InitializeAcl(pNewDacl, dwDaclLength, ACL_REVISION)) {
        dwReturnValue = GetLastError();
        DBGMSG(DBG_ERROR, ("UMRDPDR:InitializeAcl Failed, Error: %ld\n", dwReturnValue));
        goto CLEANUPANDEXIT;
    }

    //
    //  We will add an ACL with permissions to Admin, Power User, and Current User
    //
    if (!AddAccessAllowedAceEx(
                    pNewDacl,
                    ACL_REVISION,
                    INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE,
                    JOB_ALL_ACCESS,
                    psidAdmin) || 
        !AddAccessAllowedAceEx(
                    pNewDacl,
                    ACL_REVISION,
                    0,
                    PRINTER_ALL_ACCESS,
                    psidAdmin) || 
        !AddAccessAllowedAceEx(
                    pNewDacl,
                    ACL_REVISION,
                    INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE,
                    READ_CONTROL,
                    psidCreatorOwner) ||  // S-1-3-0
        !AddAccessAllowedAceEx(
                    pNewDacl,
                    ACL_REVISION,
                    INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE,
                    JOB_ALL_ACCESS,
                    psidCreatorOwner) ||  // s-1-3-0
        !AddAccessAllowedAceEx(
                    pNewDacl,
                    ACL_REVISION,
                    INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE,
                    JOB_ALL_ACCESS,
                    psidPowerUser) || 
        !AddAccessAllowedAceEx(
                    pNewDacl,
                    ACL_REVISION,
                    0,
                    PRINTER_ALL_ACCESS,
                    psidPowerUser) || 
        !AddAccessAllowedAceEx (
                    pNewDacl,
                    ACL_REVISION,
                    0,
                    PRINTER_READ,
                    userSid) ||
        !AddAccessAllowedAceEx (
                    pNewDacl,
                    ACL_REVISION,
                    INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE,
                    READ_CONTROL,
                    userSid) ||
        !AddAccessAllowedAceEx (
                    pNewDacl,
                    ACL_REVISION,
                    INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE,
                    JOB_ALL_ACCESS,
                    userSid)) {

        dwReturnValue = GetLastError();
        DBGMSG(DBG_ERROR, ("UMRDPDR:AddAccessAllowedAceEx returned False: %ld\n", dwReturnValue));
        goto CLEANUPANDEXIT;

    }

    //
    //  Check if everything went ok
    //
    if (!IsValidAcl(pNewDacl)) {
        dwReturnValue = STATUS_INVALID_ACL;
        DBGMSG(DBG_ERROR, ("UMRDPDR:IsValidAcl returned False: %ld\n", dwReturnValue));
        goto CLEANUPANDEXIT;
    }

    //
    //  Set the Dacl for the SD.
    //
    if (!SetSecurityDescriptorDacl(psd,
                                TRUE,
                                pNewDacl,
                                FALSE)) {
        dwReturnValue = GetLastError();
        DBGMSG(DBG_ERROR, ("UMRDPDR:Could not set security info for printer : %ld\n", 
                dwReturnValue));
    }

CLEANUPANDEXIT:

    //
    //  Log an event if this function failed.
    //
    if (dwReturnValue != ERROR_SUCCESS) {
        DBGMSG(DBG_ERROR,
              ("UMRDPDR:RDPDRUTL_CreateDefaultPrinterSecuritySD failed with Error Code: %ld.\n",
              dwReturnValue));
        SetLastError(dwReturnValue);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }

    if (psidCreatorOwner) {
        FreeSid(psidCreatorOwner);
    }
	
    if (psidPowerUser) {
        FreeSid(psidPowerUser);
    }

    //
    //  Release the SD on failure.
    //
    if (dwReturnValue != ERROR_SUCCESS) {
        LocalFree(psd);
        psd = NULL;
    }

    SetLastError(dwReturnValue);
    return psd;
}

DWORD
RDPDRUTL_RemoveAllTSPrinters()
/*++

Routine Description:

    Remove all TS printers on the system.

Arguments:

Return Value:

    ERROR_SUCCESS if successful.  Otherwise, an error code is returned.

--*/
{
    PRINTER_INFO_5 *pPrinterInfo = NULL;
    DWORD cbBuf = 0;
    DWORD cReturnedStructs = 0;
    DWORD tsPrintQueueFlags;
    NTSTATUS status;
    PBYTE buf = NULL;
    unsigned char stackBuf[4 * 1024];   //  Initial EnumPrinter buffer size to 
                                        //   avoid two round-trip RPC's, if possible.
    //
    //  Try to enumerate printers using the stack buffer, first, to avoid two 
    //  round-trip RPC's to the spooler, if possible.
    //
    if (!EnumPrinters(
            PRINTER_ENUM_LOCAL,     // Flags
            NULL,                   // Name
            5,                      // Print Info Type
            stackBuf,               // buffer
            sizeof(stackBuf),       // Size of buffer
            &cbBuf,                 // Required
            &cReturnedStructs)) {
        status = GetLastError();

        //
        //  See if we need to allocate more room for the printer information.
        //
        if (status == ERROR_INSUFFICIENT_BUFFER) {
            buf = LocalAlloc(LMEM_FIXED, cbBuf);
            if (buf == NULL) {
                DBGMSG(DBG_ERROR, ("RDPPNUTL: ALLOCMEM failed. Error: %08X.\n", 
                    GetLastError()));
                status = ERROR_OUTOFMEMORY;
            }
            else {
                pPrinterInfo = (PRINTER_INFO_5 *)buf;
                status = ERROR_SUCCESS;
            }

            //
            //  Enumerate printers.
            //
            if (status == ERROR_SUCCESS) {
                if (!EnumPrinters(
                        PRINTER_ENUM_LOCAL,
                        NULL,
                        5,
                        (PBYTE)pPrinterInfo,
                        cbBuf,
                        &cbBuf,
                        &cReturnedStructs)) {

                    DBGMSG(DBG_ERROR, ("RDPPNUTL: EnumPrinters failed. Error: %08X.\n", 
                        GetLastError()));
                    status = GetLastError();
                }
                else {
                    DBGMSG(DBG_INFO, ("RDPPNUTL: Second EnumPrinters succeeded.\n"));
                }
            }
        }
	    else {
            DBGMSG(DBG_ERROR, ("RDPPNUTL: EnumPrinters failed. Error: %08X.\n", 
                        GetLastError()));
	    }
    }
    else {
        DBGMSG(DBG_ERROR, ("RDPPNUTL: First EnumPrinters succeeded.\n"));
        status = ERROR_SUCCESS;
        pPrinterInfo = (PRINTER_INFO_5 *)stackBuf;
    }

    //
    //  Delete all the TS printers.  We allow ERROR_INSUFFICIENT_BUFFER here because
    //  a second invokation of EnumPrinters may have missed a few last-minute
    //  printer additions.
    //
    if (status == ERROR_SUCCESS) {

        DeleteTSPrinters(pPrinterInfo, cReturnedStructs);

        status = ERROR_SUCCESS;
    }

    //
    //  Release the printer info buffer.
    //
    if (buf != NULL) {
        LocalFree(buf);                
    }

    DBGMSG(DBG_TRACE, ("TShrSRV: RDPPNUTL_RemoveAllTSPrinters exit\n"));

    return status;
}

void 
DeleteTSPrinters(
    IN PRINTER_INFO_5 *pPrinterInfo,
    IN DWORD count
    )
/*++    

Routine Description:

    Actually performs the printer deletion.

Arguments:

    pPrinterInfo    -   All printer queues on the system.
    count           -   Number of printers in pPrinterInfo

Return Value:

    NA

--*/
{
    DWORD i;
    DWORD regValueDataType;
    DWORD sessionID;
    HANDLE hPrinter = NULL;
    DWORD bufSize;
    PRINTER_DEFAULTS defaults = {NULL, NULL, PRINTER_ALL_ACCESS};

    DBGMSG(DBG_TRACE, ("RDPPNUTL: DeleteTSPrinters entry\n"));

    for (i=0; i<count; i++) {

        if (pPrinterInfo[i].pPrinterName) {

            DBGMSG(DBG_TRACE, ("RDPPNUTL: Checking %ws for TS printer status.\n",
			    pPrinterInfo[i].pPrinterName));

            //
            //  Is this a TS printer?
            //
            if (pPrinterInfo[i].pPortName &&
                (pPrinterInfo[i].pPortName[0] == 'T') &&
                (pPrinterInfo[i].pPortName[1] == 'S') &&
                ISNUM(pPrinterInfo[i].pPortName[2])) {

                DBGMSG(DBG_ERROR, ("RDPPNUTL: %ws is a TS printer.\n",
                      pPrinterInfo[i].pPrinterName));

            }
            else {
                continue;
            }

            //
            //  Purge and delete the printer.
            //
            if (OpenPrinter(pPrinterInfo[i].pPrinterName, &hPrinter, &defaults)) {
                if (!SetPrinter(hPrinter, 0, NULL, PRINTER_CONTROL_PURGE) ||
                    !DeletePrinter(hPrinter)) {
                    DBGMSG(DBG_ERROR, ("RDPPNUTL: Error deleting printer %ws.\n", 
                           pPrinterInfo[i].pPrinterName));
                }
                else {
                    DBGMSG(DBG_ERROR, ("RDPPNUTL: Successfully deleted %ws.\n",
			            pPrinterInfo[i].pPrinterName));
                }
                ClosePrinter(hPrinter);
            }
            else {
                DBGMSG(DBG_ERROR, 
                        ("RDPPNUTL: OpenPrinter failed for %ws. Error: %08X.\n",
                        pPrinterInfo[i].pPrinterName,
                        GetLastError())
                        );
            }
        }
        else {
            DBGMSG(DBG_ERROR, ("RDPPNUTL: Printer %ld is NULL\n", i));
        }
    }

    DBGMSG(DBG_TRACE, ("RDPPNUTL: DeleteTSPrinters exit\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\shlext.c ===
/*****************************************************************************
 *
 *  scratch.c
 *
 *	Scratch application.
 *
 *****************************************************************************/

#include "precomp.h"

#include <shlobj.h>
#include <shlobjp.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <shellapi.h>
#include <ole2.h>

#include "umrdpdr.h"
#include "drdevlst.h"
#include "umrdpdrv.h"
#include "drdbg.h"

#include <wlnotify.h>

#define ALLOCMEM(size) HeapAlloc(RtlProcessHeap(), 0, size)
#define FREEMEM(pointer)                HeapFree(RtlProcessHeap(), 0, \
                                                 pointer)

//  Global debug flag.
extern DWORD GLOBAL_DEBUG_FLAGS;
extern HINSTANCE g_hInstance;

/******************************************************************************
 *
 *  This is the private version of createsession key
 *
 ******************************************************************************/

#define REGSTR_PATH_EXPLORER             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer")
                                                             
HKEY _SHGetExplorerHkey()
{
    HKEY hUser;
    HKEY hkeyExplorer = NULL;
        
    if (RegOpenCurrentUser(KEY_WRITE, &hUser) == ERROR_SUCCESS) {
        RegCreateKey(hUser, REGSTR_PATH_EXPLORER, &hkeyExplorer);
        RegCloseKey(hUser);
    }
        
    return hkeyExplorer;    
}

//
//  The "Session key" is a volatile registry key unique to this session.
//  A session is a single continuous logon.  If Explorer crashes and is
//  auto-restarted, the two Explorers share the same session.  But if you
//  log off and back on, that new Explorer is a new session.
//
//  Note that Win9x doesn't support volatile registry keys, so
//  we just fake it.
//

//
//  The s_SessionKeyName is the name of the session key relative to
//  REGSTR_PATH_EXPLORER\SessionInfo.  On NT, this is normally the
//  Authentication ID, but we pre-initialize it to something safe so
//  we don't fault if for some reason we can't get to it.  Since
//  Win95 supports only one session at a time, it just stays at the
//  default value.
//
//  Sometimes we want to talk about the full path (SessionInfo\BlahBlah)
//  and sometimes just the partial path (BlahBlah) so we wrap it inside
//  this goofy structure.
//

union SESSIONKEYNAME {
    TCHAR szPath[12+16+1];
    struct {
        TCHAR szSessionInfo[12];    // strlen("SepssionInfo\\")
        TCHAR szName[16+1];         // 16 = two DWORDs converted to hex
    };
} s_SessionKeyName = {
    { TEXT("SessionInfo\\.Default") }
};
#ifdef WINNT
BOOL g_fHaveSessionKeyName = FALSE;
#endif

//
//  samDesired = a registry security access mask, or the special value
//               0xFFFFFFFF to delete the session key.
//  phk        = receives the session key on success
//
//  NOTE!  Only Explorer should delete the session key (when the user
//         logs off).
//
STDAPI _SHCreateSessionKey(REGSAM samDesired, HKEY *phk)
{
    LONG lRes;
    HKEY hkExplorer;

    *phk = NULL;

#ifdef WINNT
    DBGMSG(DBG_TRACE, ("SHLEXT: _SHCreateSessionKey\n"));


    if (!g_fHaveSessionKeyName)
    {
        HANDLE hToken;

        //
        //  Build the name of the session key.  We use the authentication ID
        //  which is guaranteed to be unique forever.  We can't use the
        //  Hydra session ID since that can be recycled.
        //
        if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken) ||
                OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
        {
            TOKEN_STATISTICS stats;
            DWORD cbOut;

            DBGMSG(DBG_TRACE, ("SHLEXT: thread token: %p\n", hToken));

            if (GetTokenInformation(hToken, TokenStatistics, &stats, sizeof(stats), &cbOut))
            {
                wsprintf(s_SessionKeyName.szName, TEXT("%08x%08x"),
                         stats.AuthenticationId.HighPart,
                         stats.AuthenticationId.LowPart);

                DBGMSG(DBG_TRACE, ("SHLEXT: Session Key: %S\n", s_SessionKeyName.szName));

                g_fHaveSessionKeyName = TRUE;
            }
            else {
                DBGMSG(DBG_TRACE, ("SHLEXT: failed to get token info, error: %d\n",
                               GetLastError()));
            }

            CloseHandle(hToken);
        }
        else {
            DBGMSG(DBG_TRACE, ("SHLEXT: failed to open thread token, error: %d\n",
                               GetLastError()));
        }
    }                                      
#endif

    DBGMSG(DBG_TRACE, ("SHLEXT: SessionKey: %S\n", s_SessionKeyName.szName));                               
    
    hkExplorer = _SHGetExplorerHkey();

    if (hkExplorer)
    {
        if (samDesired != 0xFFFFFFFF)
        {
            DWORD dwDisposition;
            lRes = RegCreateKeyEx(hkExplorer, s_SessionKeyName.szPath, 0,
                           NULL,
                           REG_OPTION_VOLATILE,
                           samDesired,
                           NULL,
                           phk,
                           &dwDisposition );            
        }
        else
        {
            lRes = SHDeleteKey(hkExplorer, s_SessionKeyName.szPath);            
        }

        RegCloseKey(hkExplorer);
    }
    else
    {
        lRes = ERROR_ACCESS_DENIED;        
    }
    return HRESULT_FROM_WIN32(lRes);
}


//
// Get a key to HKEY_CURRENT_USER\Software\Classes\CLSID
//
HKEY GetHKCUClassesCLSID()
{
    HKEY hUser;
    HKEY hkClassesCLSID = NULL;

    if (RegOpenCurrentUser(KEY_WRITE, &hUser) == ERROR_SUCCESS) {
        if (RegCreateKeyW(hUser,
                L"Software\\Classes\\CLSID",
                &hkClassesCLSID) == ERROR_SUCCESS) {
            RegCloseKey(hUser);
            return hkClassesCLSID;
        } else {
            RegCloseKey(hUser);
            return NULL;
        }
    }
    else {
        return NULL;
    }
}

#ifdef _WIN64
//
// Get a key to HKEY_CURRENT_USER\Software\Classes\Wow6432Node\CLSID
//
HKEY GetHKCUWow64ClassesCLSID()
{
    HKEY hUser;
    HKEY hkClassesCLSID = NULL;

    if (RegOpenCurrentUser(KEY_WRITE, &hUser) == ERROR_SUCCESS) {
        if (RegCreateKeyW(hUser,
                L"Software\\Classes\\Wow6432Node\\CLSID",
                &hkClassesCLSID) == ERROR_SUCCESS) {
            RegCloseKey(hUser);
            return hkClassesCLSID;
        } else {
            RegCloseKey(hUser);
            return NULL;
        }
    }
    else {
        return NULL;
    }
}
#endif

// Describes a registry key in the form specified in the article
// http://msdn.microsoft.com/library/techart/shellinstobj.htm
//
// {guid}=REG_SZ:"Sample Instance Object"
//     value InfoTip=REG_SZ:"Demonstrate sample shell registry folder"
//   DefaultIcon=REG_EXPAND_SZ:"%SystemRoot%\system32\shell32.dll,9"
//   InProcServer32=REG_EXPAND_SZ:"%SystemRoot%\system32\shdocvw.dll"
//     value ThreadingModel=REG_SZ:"Apartment"
//   ShellFolder
//     value Attributes=REG_DWORD:0x60000000
//     value WantsFORPARSING=REG_SZ:""
//   Instance
//     value CLSID=REG_SZ:"{0AFACED1-E828-11D1-9187-B532F1E9575D}"
//     InitPropertyBag
//       value Target=REG_SZ:"\\raymondc\public"

typedef struct _REGKEYENTRY {
    PWCHAR  pszSubkey;
    PWCHAR  pszValue;
    DWORD   dwType;
    LPVOID  pvData;
} REGKEYENTRY;

REGKEYENTRY g_RegEntry[] = {
    {   
        NULL,
        NULL,
        REG_SZ,
        L"tsclient drive",                          /* folder display name e.g. \\tsclient\c */
    },

    {
        NULL,
        L"InfoTip",
        REG_SZ,
        L"Your local machine's disk storage",       // info tip comments
    },

    {
        L"DefaultIcon",
        NULL,
        REG_EXPAND_SZ,
        L"%SystemRoot%\\system32\\shell32.dll,9",   // icon resource file
    },

    {   
        L"InProcServer32",
        NULL,
        REG_EXPAND_SZ,
        L"%SystemRoot%\\system32\\shdocvw.dll",
    },

    {   
        L"InProcServer32",
        L"ThreadingModel",
        REG_SZ,
        L"Apartment",
    },

    {   
        L"InProcServer32",
        L"LoadWithoutCOM",
        REG_SZ,
        L"",
    },
    
    {   
        L"ShellFolder",
        L"Attributes",
        REG_DWORD,
        ((VOID *)(ULONG_PTR)0xF0000000),
    },

    {   
        L"ShellFolder",
        L"WantsFORPARSING",
        REG_SZ,
        L"",
    },

    {   
        L"Instance",
        L"CLSID",
        REG_SZ,
        L"{0AFACED1-E828-11D1-9187-B532F1E9575D}",
    },

    {   
        L"Instance",
        L"LoadWithoutCOM",
        REG_SZ,
        L"",
    },
    
    {   
        L"Instance\\InitPropertyBag",
        L"Target",
        REG_SZ,
        L"\\\\tsclient\\c",                          /* Target name e.g. \\tsclient\c */
    },
};

#define NUM_REGKEYENTRY   (sizeof(g_RegEntry)/sizeof(g_RegEntry[0]))
#define DISPLAY_INDEX     0
#define INFOTIP_INDEX     1
#define TARGET_INDEX      (NUM_REGKEYENTRY - 1)


//
//  Create volatile shell folder reg entries
// 
BOOL CreateVolatilePerUserCLSID(HKEY hkClassesCLSID, PWCHAR pszGuid)
{
    BOOL fSuccess = FALSE;
    unsigned i;
    HKEY hk;

    if (RegCreateKeyEx(hkClassesCLSID, pszGuid, 0, NULL,
                       REG_OPTION_VOLATILE, KEY_WRITE, NULL,
                       &hk, NULL) == ERROR_SUCCESS) {

        fSuccess = TRUE;

        // Okay, now fill the key with the information above
        for (i = 0; i < NUM_REGKEYENTRY && fSuccess; i++) {
            HKEY hkSub;
            HKEY hkClose = NULL;
            LONG lRes;

            if (g_RegEntry[i].pszSubkey && *g_RegEntry[i].pszSubkey) {
                lRes = RegCreateKeyEx(hk, g_RegEntry[i].pszSubkey, 0, NULL,
                                      REG_OPTION_VOLATILE, KEY_WRITE, NULL,
                                      &hkSub, NULL);
                hkClose = hkSub;
            } else {
                hkSub = hk;
                lRes = ERROR_SUCCESS;
            }

            if (lRes == ERROR_SUCCESS) {
                LPVOID pvData;
                DWORD cbData;
                DWORD dwData;

                if (g_RegEntry[i].dwType == REG_DWORD) {
                    cbData = 4;
                    dwData = PtrToUlong(g_RegEntry[i].pvData);
                    pvData = (LPVOID)&dwData;
                } else {
                    cbData = (lstrlen((LPCTSTR)g_RegEntry[i].pvData) + 1) * sizeof(TCHAR);
                    pvData = g_RegEntry[i].pvData;
                }

                if (RegSetValueEx(hkSub, g_RegEntry[i].pszValue, 0,
                                  g_RegEntry[i].dwType, (LPBYTE)pvData, cbData) != ERROR_SUCCESS) {
                    fSuccess = FALSE;
                }

                if (hkClose) RegCloseKey(hkClose);
            } else {
                fSuccess = FALSE;
            }                
        }

        RegCloseKey(hk);

        if (!fSuccess) {
            SHDeleteKey(hkClassesCLSID, pszGuid);
        }
    }

    return fSuccess;
}

//
//  Create shell reg folder for redirected client drive connection
//
BOOL CreateDriveFolder(WCHAR *RemoteName, WCHAR *ClientDisplayName, PDRDEVLSTENTRY deviceEntry) 
{
    BOOL fSuccess = FALSE;
    WCHAR *szGuid = NULL;
    WCHAR szBuf[MAX_PATH];
    GUID guid;

    HRESULT hrInit = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    
    DBGMSG(DBG_TRACE, ("SHLEXT: CreateDriveFolder\n"));

    fSuccess = SUCCEEDED(CoCreateGuid(&guid));

    if (fSuccess) {
        //  Allocate guid string buffer
        szGuid = (WCHAR *) ALLOCMEM(GUIDSTR_MAX * sizeof(WCHAR));

        if (szGuid != NULL) {
            fSuccess = TRUE;
        }
        else {
            fSuccess = FALSE;
        }
    }
    
    if (fSuccess) {
        PVOID pvData;
        WCHAR onString[32];
        WCHAR infoTip[64];
        LPWSTR args[2];

        SHStringFromGUID(&guid, szGuid, GUIDSTR_MAX);
        
        onString[0] = L'\0';
        infoTip[0] = L'\0';

        LoadString(g_hInstance, IDS_ON, onString, sizeof(onString) / sizeof(WCHAR));
        LoadString(g_hInstance, IDS_DRIVE_INFO_TIP, infoTip, sizeof(infoTip) / sizeof(WCHAR));

        // Set up shell folder display name
        pvData = ALLOCMEM(MAX_PATH * sizeof(WCHAR));
        if (pvData) {
            args[0] = deviceEntry->clientDeviceName;
            args[1] = ClientDisplayName;
            
            FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                          onString, 0, 0, pvData, MAX_PATH, (va_list*)args);
            
            g_RegEntry[DISPLAY_INDEX].pvData = pvData;
        }
        else {
            fSuccess = FALSE;
        }

        // Setup shell folder target name
        if (fSuccess) {
            pvData = ALLOCMEM((wcslen(RemoteName) + 1) * sizeof(WCHAR));
            if (pvData) {
                wcscpy(pvData, RemoteName);
                g_RegEntry[TARGET_INDEX].pvData = pvData;
            }
            else {
                fSuccess = FALSE;
                FREEMEM(g_RegEntry[DISPLAY_INDEX].pvData);
                g_RegEntry[DISPLAY_INDEX].pvData = NULL;
            }
    
            // Create the shell instance object as a volatile per-user objects
            if (fSuccess) {
                pvData = ALLOCMEM((wcslen(infoTip) + 1) * sizeof(WCHAR));
                
                if (pvData) {
                    wcscpy(pvData, infoTip);
                    g_RegEntry[INFOTIP_INDEX].pvData = pvData;
                }
                else {
                    fSuccess = FALSE;
                    FREEMEM(g_RegEntry[DISPLAY_INDEX].pvData);
                    g_RegEntry[DISPLAY_INDEX].pvData = NULL;

                    FREEMEM(g_RegEntry[TARGET_INDEX].pvData);
                    g_RegEntry[TARGET_INDEX].pvData = NULL;
                }                
            }

            if (fSuccess) {
                HKEY hk64ClassesCLSID;
                HKEY hkClassesCLSID;
                    
                hkClassesCLSID = GetHKCUClassesCLSID();
                
                if (hkClassesCLSID) {
                    fSuccess = CreateVolatilePerUserCLSID(hkClassesCLSID, szGuid);
                    RegCloseKey(hkClassesCLSID);
                } 
                else {
                    fSuccess = FALSE;
                }

#ifdef _WIN64
                hk64ClassesCLSID = GetHKCUWow64ClassesCLSID();


                if (hk64ClassesCLSID) {
                    fSuccess = CreateVolatilePerUserCLSID(hk64ClassesCLSID, szGuid);
                    RegCloseKey(hk64ClassesCLSID);
                } 
                else {
                    fSuccess = FALSE;
                }
#endif

                FREEMEM(g_RegEntry[DISPLAY_INDEX].pvData);
                g_RegEntry[DISPLAY_INDEX].pvData = NULL;

                FREEMEM(g_RegEntry[TARGET_INDEX].pvData);
                g_RegEntry[TARGET_INDEX].pvData = NULL;

                FREEMEM(g_RegEntry[INFOTIP_INDEX].pvData);
                g_RegEntry[INFOTIP_INDEX].pvData = NULL;
            }
        }
    }
    else {
        DBGMSG(DBG_ERROR, ("SHLEXT: Failed to create the GUID\n"));
    }

    // Register this object under the per-session My Computer namespace
    if (fSuccess) {
        HKEY hkSession;
        HKEY hkOut;

        DBGMSG(DBG_TRACE, ("SHLEXT: Created VolatilePerUserCLSID\n"));

        fSuccess = SUCCEEDED(_SHCreateSessionKey(KEY_WRITE, &hkSession));

        if (fSuccess) {
            wnsprintf(szBuf, MAX_PATH, L"MyComputer\\Namespace\\%s", szGuid);
            
            if (RegCreateKeyEx(hkSession, szBuf, 0, NULL,
                          REG_OPTION_VOLATILE, KEY_WRITE, NULL,
                          &hkOut, NULL) == ERROR_SUCCESS) {

                fSuccess = TRUE;
                RegCloseKey(hkOut);
            } else {
                fSuccess = FALSE;
            }

            RegCloseKey(hkSession);
        }
    }

   // Now tell the shell that the object was recently created
   if (fSuccess) {
       DBGMSG(DBG_TRACE, ("SHLEXT: Created per session MyComputer namespace\n"));

       wnsprintf(szBuf, MAX_PATH,
                 TEXT("::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::%s"),
                 szGuid);
       SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, szBuf, NULL);
   }
   else {
       DBGMSG(DBG_TRACE, ("SHLEXT: Failed to create per session MyComputer namespace\n"));
   }

   if (SUCCEEDED(hrInit)) 
       CoUninitialize();

   // Save the guid in device entry so we can delete reg entry later
   deviceEntry->deviceSpecificData = (PVOID)szGuid;

   return fSuccess;
}

//
//  Delete shell reg folder for redirected client drive connection
//
BOOL DeleteDriveFolder(IN PDRDEVLSTENTRY deviceEntry) 
{
    WCHAR szBuf[MAX_PATH];
    WCHAR *szGuid;
    HKEY hkSession;
    HKEY hkClassesCLSID;
    HKEY hk64ClassesCLSID;

    HRESULT hrInit = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

    DBGMSG(DBG_TRACE, ("SHLEXT: DeleteDriveFolder\n"));

    ASSERT(deviceEntry != NULL);
    szGuid = (WCHAR *)(deviceEntry->deviceSpecificData);
    
    if (szGuid != NULL) {
    
        // Delete it from the namespace
        if (SUCCEEDED(_SHCreateSessionKey(KEY_WRITE, &hkSession))) {
            wnsprintf(szBuf, MAX_PATH, L"MyComputer\\Namespace\\%s", szGuid);
            RegDeleteKey(hkSession, szBuf);
            RegCloseKey(hkSession);
    
            DBGMSG(DBG_TRACE, ("SHLEXT: Delete GUID from my computer session namespace\n"));
        }
    
        // Delete it from HKCU\...\CLSID
        hkClassesCLSID = GetHKCUClassesCLSID();
        if (hkClassesCLSID) {
            SHDeleteKey(hkClassesCLSID, szGuid);
    
            DBGMSG(DBG_TRACE, ("SHLEXT: Delete GUID from HKCU Classes\n"));
    
            RegCloseKey(hkClassesCLSID);
        }

#ifdef _WIN64
        hk64ClassesCLSID = GetHKCUWow64ClassesCLSID();
        if (hk64ClassesCLSID) {
            SHDeleteKey(hk64ClassesCLSID, szGuid);
    
            DBGMSG(DBG_TRACE, ("SHLEXT: Delete GUID from HKCU Classes\n"));
    
            RegCloseKey(hk64ClassesCLSID);
        }
#endif    

        // Tell the shell that it's gone
        wnsprintf(szBuf, MAX_PATH,
                  TEXT("::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::%s"),
                  szGuid);
        SHChangeNotify(SHCNE_DELETE, SHCNF_PATH, szBuf, NULL);
    
        FREEMEM(szGuid);
        deviceEntry->deviceSpecificData = NULL;        
    }

    //
    // Need to reset the session key on disconnect/logoff
    //
    g_fHaveSessionKeyName = FALSE;
    
    if (SUCCEEDED(hrInit)) 
        CoUninitialize();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\tempdir.c ===
/****************************************************************************/
// tempdir.c
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/


#include "precomp.h"

#pragma hdrstop

#define VOLATILE_PATH TEXT("Volatile Environment")


PWSTR gszTmpDirPath;
PWSTR gszTempDirPath;

VOID RemovePerSessionTempDirs()
{

    HKEY hKey;
    ULONG ultemp, ulType, ulValueData, fDelTemp = 1;
    NTSTATUS Status;

    if (!gszTempDirPath && !gszTmpDirPath) 
        return;

    //
    // See if the registry value is set to delete the Per Session temp directory
    //
    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                      REG_CONTROL_TSERVER,
                      0,
                      KEY_READ,
                      &hKey) == ERROR_SUCCESS) {
        ultemp = sizeof(fDelTemp);
        RegQueryValueEx(hKey,
                        REG_CITRIX_DELETETEMPDIRSONEXIT,
                        NULL,
                        &ulType,
                        (LPBYTE)&fDelTemp,
                        &ultemp);
        RegCloseKey(hKey);
    }


    //
    // See if the POLICY registry value is set to delete the Per Session temp directory
    //
    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                      TS_POLICY_SUB_TREE,
                      0,
                      KEY_READ,
                      &hKey) == ERROR_SUCCESS) 
    {
        ultemp = sizeof(fDelTemp);

        if ( ERROR_SUCCESS == RegQueryValueEx(hKey,
                        REG_CITRIX_DELETETEMPDIRSONEXIT,
                        NULL,
                        &ulType,
                        (LPBYTE)&ulValueData,
                        &ultemp) )
        {
            fDelTemp = ulValueData;
        }
        RegCloseKey(hKey);
    }

    if (fDelTemp) {

        if (gszTempDirPath) {
            RemoveDir(gszTempDirPath);
            free(gszTempDirPath);
            gszTempDirPath = NULL;
        }
        if (gszTmpDirPath) {
            RemoveDir(gszTmpDirPath);
            free(gszTmpDirPath);
            gszTmpDirPath = NULL;

        }
    }
}


BOOL
TermsrvCreateTempDir( PVOID *pEnv, 
                      HANDLE UserToken,
                      PSECURITY_DESCRIPTOR SD
                      )
{
    CTX_USER_DATA Ctx_User_Data;
    PCTX_USER_DATA pCtx_User_Data = NULL;
    BOOL retval;
    WCHAR pwcSessionId[16];
    
    if(UserToken || SD)
    {
        Ctx_User_Data.UserToken = UserToken;
        Ctx_User_Data.NewThreadTokenSD = SD;
        pCtx_User_Data = &Ctx_User_Data;
    }
    
    wsprintf(pwcSessionId,L"%lx",NtCurrentPeb()->SessionId);

    retval = CtxCreateTempDir(L"TEMP", pwcSessionId, pEnv, 
                                &gszTempDirPath, pCtx_User_Data );

    retval = CtxCreateTempDir(L"TMP", pwcSessionId, pEnv, 
                                &gszTmpDirPath, pCtx_User_Data );

    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\tsnutl.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name :
    
    tsnutl.c

Abstract:

    Contains TS Notification DLL Utilities

Author:

    TadB

Revision History:
--*/

#include <precomp.h>
#pragma hdrstop 

#include "tsnutl.h"
#include "drdbg.h"

//
//  For Tracing
//
extern DWORD GLOBAL_DEBUG_FLAGS;

BOOL TSNUTL_IsProtocolRDP()
/*++

Routine Description:

    Returns TRUE if the protocol is RDP for this Winstation

Arguments:

Return Value:
    
    TRUE if the protocol is RDP.

--*/
{
    ULONG Length;
    BOOL bResult;
    WINSTATIONCLIENT ClientData;

    bResult = WinStationQueryInformation(SERVERNAME_CURRENT,
                                         LOGONID_CURRENT,
                                         WinStationClient,
                                         &ClientData,
                                         sizeof(ClientData),
                                         &Length);

    if (bResult) {
        return ClientData.ProtocolType == PROTOCOL_RDP;
    }
    else {
        DBGMSG(DBG_ERROR, ("UMRDPPRN:WinStationQueryInformation returned false:  %ld\n",
            GetLastError()));
        return FALSE;
    }
}

BOOL TSNUTL_FetchRegistryValue(
    IN HKEY regKey, 
    IN LPWSTR regValueName, 
    IN OUT PBYTE *buf
    )
/*++

Routine Description:

    Fetch a registry value.  

Arguments:

    regKey          -   Open reg key for value to fetch.
    regValueName    -   Name of registry value to fetch.
    buf             -   Location of fetched value.

Return Value:

    TRUE if the value was successfully fetched.  Otherwise, FALSE
    is returned and GetLastError returns the error code.

--*/
{
    LONG sz;
    BOOL result = FALSE;
    LONG s;
    WCHAR tmp[1];

    //
    //  Get the size.
    //
    sz = 0;
    s = RegQueryValueEx(regKey, 
                        regValueName, NULL,
                        NULL, (PBYTE)&tmp, &sz);

    //
    //  Get the value.
    //
    if (s == ERROR_MORE_DATA) {

        //
        //  Allocate the buf.
        //
        if (*buf != NULL) {
            PBYTE pTmp = REALLOCMEM(*buf, sz);

            if (pTmp != NULL) {
                *buf = pTmp;
            } else {
                FREEMEM(*buf);
                *buf = NULL;
            }
        }
        else {
            *buf = ALLOCMEM(sz);
        }

        //
        //  Fetch the value.
        //
        if (*buf) {
            s = RegQueryValueEx(
                            regKey, 
                            regValueName, NULL,
                            NULL, 
                            *buf, &sz
                            );
            if (s != ERROR_SUCCESS) {
                DBGMSG(DBG_ERROR, ("TSNUTL:  Can't fetch resource %s:  %ld.\n", 
                        regValueName, GetLastError()));
                FREEMEM(*buf);
                *buf = NULL;
            }
            else {
                result = TRUE;
            }
        }
        else {
            DBGMSG(DBG_ERROR, ("TSNUTL:  Can't allocate %ld bytes\n", sz));
        }
    }

    return result;
}

BOOL
TSNUTL_GetTextualSid(
    IN PSID pSid,          
    IN OUT LPTSTR textualSid,  
    IN OUT LPDWORD pSidSize  
    )
/*++

Routine Description:

    Get a textual representation of a user SID.  

Arguments:

    pSid        -   Binary SID
    textualSid  -   buffer for Textual representaion of Sid
    pSidSize    -   required/provided textualSid buffersize

Return Value:

    TRUE if the conversion was successful.  Otherwise,  FALSE is returned.
    GetLastError() can be used for retrieving extended error information.

--*/
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwCounter;
    DWORD sidCopySize;
    PUCHAR pCount;
    BOOL result;

    //
    //  Test if Sid passed in is valid
    //
    result = IsValidSid(pSid);

    //
    //  Obtain SidIdentifierAuthority
    //
    if (result) {
        psia = GetSidIdentifierAuthority(pSid);
        result = GetLastError() == ERROR_SUCCESS;
    }

    // 
    //  Obtain sidsubauthority count
    //
    if (result) {

        pCount = GetSidSubAuthorityCount(pSid);
        result = GetLastError() == ERROR_SUCCESS;
        if (result) {
            dwSubAuthorities = *pCount;
        }

    }

    //
    //  Compute approximate buffer length
    //
    if (result) {
#if DBG
        WCHAR buf[MAX_PATH];
        wsprintf(buf, TEXT("%lu"), SID_REVISION);
        ASSERT(wcslen(buf) <= 15);
#endif
        //            'S-' + SID_REVISION + identifierauthority- + subauthorities-         + NULL
        sidCopySize = (2   + 15           + 12                   + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);
    }

    //
    //  Check provided buffer length.
    //  If not large enough, indicate proper size and setlasterror
    //
    if (result) {

        if(*pSidSize < sidCopySize) {
            *pSidSize = sidCopySize;
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            result = FALSE;
        }

    }

    //
    //  Prepare S-SID_REVISION-
    //
    if (result) {
        sidCopySize = wsprintf(textualSid, TEXT("S-%lu-"), SID_REVISION );
    }

    //
    //  Prepare SidIdentifierAuthority
    //
    if (result) {
        if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) ) {
            sidCopySize += wsprintf(textualSid + sidCopySize,
                        TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                        (USHORT)psia->Value[0],
                        (USHORT)psia->Value[1],
                        (USHORT)psia->Value[2],
                        (USHORT)psia->Value[3],
                        (USHORT)psia->Value[4],
                        (USHORT)psia->Value[5]);
        } else {
            sidCopySize += wsprintf(textualSid + sidCopySize,
                        TEXT("%lu"),
                        (ULONG)(psia->Value[5]      )   +
                        (ULONG)(psia->Value[4] <<  8)   +
                        (ULONG)(psia->Value[3] << 16)   +
                        (ULONG)(psia->Value[2] << 24)   );
        }
    }

    //
    //  Loop through SidSubAuthorities
    //
    if (result) {
        for(dwCounter = 0 ; result && (dwCounter < dwSubAuthorities) ; dwCounter++) {
            PDWORD ptr = GetSidSubAuthority(pSid, dwCounter);
            result = GetLastError() == ERROR_SUCCESS;
            if (result) {
                sidCopySize += wsprintf(textualSid + sidCopySize, TEXT("-%lu"), *ptr);
            }
        }
    }

    //
    //  Tell the caller how many chars we provided, not including NULL
    //
    if (result) {
        *pSidSize = sidCopySize;
    }

    return result;
}

PSID
TSNUTL_GetUserSid(
    IN HANDLE hTokenForLoggedOnUser
    )
{
/*++

Routine Description:

    Allocates memory for psid and returns the psid for the current user
    The caller should call FREEMEM to free the memory.

Arguments:

    Access Token for the User

Return Value:

    if successful, returns the PSID
    else, returns NULL

--*/
    TOKEN_USER * ptu = NULL;
    BOOL bResult;
    PSID psid = NULL;

    DWORD defaultSize = sizeof(TOKEN_USER);
    DWORD Size;
    DWORD dwResult;

    ptu = (TOKEN_USER *)ALLOCMEM(defaultSize);
    if (ptu == NULL) {
        goto Cleanup;
    }

    bResult = GetTokenInformation(
                    hTokenForLoggedOnUser,  // Handle to Token
                    TokenUser,              // Token Information Class
                    ptu,                    // Buffer for Token Information
                    defaultSize,            // Size of Buffer
                    &Size);                 // Return length

    if (bResult == FALSE) {
        dwResult = GetLastError();
        if (dwResult == ERROR_INSUFFICIENT_BUFFER) {
            //
            //Allocate required memory
            //
            FREEMEM(ptu);
            ptu = (TOKEN_USER *)ALLOCMEM(Size);

            if (ptu == NULL) {
                goto Cleanup;
            }
            else {
                defaultSize = Size;
                bResult = GetTokenInformation(
                                hTokenForLoggedOnUser,
                                TokenUser,
                                ptu,
                                defaultSize,
                                &Size);

                if (bResult == FALSE) {  //Still failed
                    DBGMSG(DBG_ERROR,
                        ("UMRDPDR:GetTokenInformation Failed, Error: %ld\n", GetLastError()));
                    goto Cleanup;
                }
            }
        }
        else {
            DBGMSG(DBG_ERROR, ("UMRDPDR:GetTokenInformation Failed, Error: %ld\n", dwResult));
            goto Cleanup;
        }
    }

    Size = GetLengthSid(ptu->User.Sid);

    //
    // Allocate memory. This will be freed by the caller.
    //

    psid = (PSID) ALLOCMEM(Size);

    if (psid != NULL) {         // Make sure the allocation succeeded
        if (!CopySid(Size, psid, ptu->User.Sid)) {
            DBGMSG(DBG_ERROR,
                ("UMRDPDR:CopySid Failed, Error: %ld\n", GetLastError()));
            FREEMEM(psid);
            psid = NULL;
            goto Cleanup;
        }
    }

Cleanup:
    if (ptu != NULL)
        FREEMEM(ptu);

    return psid;
}

#ifdef ENABLETHISWHENITISUSED
PSID
TSNUTL_GetLogonSessionSid(
    IN HANDLE hTokenForLoggedOnUser
    )
{
/*++

Routine Description:

    Get a SID for a logon session.

Arguments:

    Access Token for the User

Return Value:

    if successful, returns the PSID
    else, returns NULL and GetLastError() can be used to get the error code.

--*/
    TOKEN_GROUPS * ptg = NULL;
    BOOL bResult;
    PSID psid = NULL;
    DWORD i;

    DWORD defaultSize = sizeof(TOKEN_GROUPS);
    DWORD size;
    DWORD dwResult = ERROR_SUCCESS;

    ptg = (TOKEN_GROUPS *)ALLOCMEM(defaultSize);
    if (ptg == NULL) {
        goto CLEANUPANDEXIT;
    }

    bResult = GetTokenInformation(
                    hTokenForLoggedOnUser,  // Handle to Token
                    TokenGroups,            // Token Information Class
                    ptg,                    // Buffer for Token Information
                    defaultSize,            // Size of Buffer
                    &size);                 // Return length

    if (bResult == FALSE) {
        dwResult = GetLastError();
        if (dwResult == ERROR_INSUFFICIENT_BUFFER) {
            //
            //Allocate required memory
            //
            FREEMEM(ptg);
            ptg = (TOKEN_GROUPS *)ALLOCMEM(size);
            if (ptg == NULL) {
                dwResult = ERROR_OUTOFMEMORY;
                goto CLEANUPANDEXIT;
            }
            else {
                defaultSize = size;
                bResult = GetTokenInformation(
                                hTokenForLoggedOnUser,
                                TokenGroups,
                                ptg,
                                defaultSize,
                                &size);

                if (bResult == FALSE) {  //Still failed
                    dwResult = GetLastError();
                    DBGMSG(DBG_ERROR,
                        ("UMRDPDR:GetTokenInformation Failed, Error: %ld\n", GetLastError()));
                    goto CLEANUPANDEXIT;
                }
            }
        }
        else {
            DBGMSG(DBG_ERROR, ("UMRDPDR:GetTokenInformation Failed, Error: %ld\n", dwResult));
            goto CLEANUPANDEXIT;
        }
    }

    //
    //  Iterate through the groups until we find the session SID.
    //
    for (i=0; i<ptg->GroupCount; i++) {
        if (ptg->Groups[i].Attributes & SE_GROUP_LOGON_ID) {
            size = GetLengthSid(ptg->Groups[i].Sid);

            psid = (PSID)ALLOCMEM(size);
            if (psid != NULL) {         // Make sure the allocation succeeded
                CopySid(size, psid, ptg->Groups[i].Sid);
            }
            break;
        }
    }

CLEANUPANDEXIT:

    if (ptg != NULL) {
        FREEMEM(ptg);
    }

    SetLastError(dwResult);

    return psid;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\tsnutl.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name :
    
    tsnutl.h

Abstract:

    Contains TS Notification DLL Utilities
    
Author:

    TadB

Revision History:
--*/

#ifndef _TSNUTL_
#define _TSNUTL_

//
//  Memory Allocation Macros
//
#define REALLOCMEM(pointer, newsize)    HeapReAlloc(RtlProcessHeap(), \
                                                    0, pointer, newsize)
#define FREEMEM(pointer)                HeapFree(RtlProcessHeap(), 0, \
                                                    pointer)

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


__inline LPVOID ALLOCMEM(SIZE_T size) 
{
    LPVOID ret = HeapAlloc(RtlProcessHeap(), 0, size);

    if (ret == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
    }
    return ret;
}

//  
//  Fetch a registry value.  
//
BOOL TSNUTL_FetchRegistryValue(
    IN HKEY regKey, 
    IN LPWSTR regValueName, 
    IN OUT PBYTE *buf
    );

//
//  Returns TRUE if the protocol is RDP for this Winstation
//
BOOL TSNUTL_IsProtocolRDP();

//
//  Get a textual representation of a user SID.  
//
BOOL TSNUTL_GetTextualSid(
    IN PSID pSid,          
    IN OUT LPTSTR textualSid,  
    IN OUT LPDWORD pSidSize  
    );

//
//  Allocates memory for psid and returns the psid for the current user
//  The caller should call FREEMEM to free the memory.
//
PSID TSNUTL_GetUserSid(
    IN HANDLE hTokenForLoggedOnUser
    );

//
//  Allocates memory for psid and returns the psid for the current TS session.
//  The caller should call FREEMEM to free the memory.
//
PSID TSNUTL_GetLogonSessionSid(
    IN HANDLE hTokenForLoggedOnUser
    );

#ifdef __cplusplus
}
#endif // __cplusplus

#endif //#ifndef _RDPPRUTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\umrdpdr.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name :

    umrdpdr.c

Abstract:

    User-Mode Component for RDP Device Management

    This module is included in the TermSrv tsnotify.dll, which is attached
    to WINLOGON.EXE.  This module, after being entered, creates a background
    thread that is used by the RDPDR kernel-mode component (rdpdr.sys) to perform
    user-mode device management operations.

    The background thread communicates with the rdpdr.sys via IOCTL calls.

Author:

    TadB

Revision History:
--*/

#include "precomp.h"
#pragma hdrstop

#include <nt.h>
#include <ntioapi.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <winuser.h>
#include <string.h>
#ifdef UNITTEST
#include <stdio.h>
#endif
#include <stdlib.h>
#include <winreg.h>
#include <shlobj.h>
#include <winspool.h>
#include <rdpdr.h>
#include "drdbg.h"
#include "drdevlst.h"
#include "umrdpprn.h"
#include "umrdpdr.h"
#include "umrdpdrv.h"
#include <winsta.h>
#include "tsnutl.h"
#include "wtblobj.h"

#include "errorlog.h"


////////////////////////////////////////////////////////
//
//      Defines
//

//DWORD GLOBAL_DEBUG_FLAGS=0xFFFF;
DWORD GLOBAL_DEBUG_FLAGS=0x0;

// TS Network Provider Name
WCHAR ProviderName[MAX_PATH];

// Check if we are running on PTS platform 
BOOL fRunningOnPTS = FALSE;

#ifndef BOOL
#define BOOL int
#endif

#define PRINTUILIBNAME  TEXT("printui.dll")

// PrintUI "Run INF Install" wsprintf Format String.  %s fields are, in order:
//  Printer Name, Location of INF Directory, Port Name, Driver Name
#define PUI_RUNINFSTR   L"/Hwzqu /if /b \"%s\" /f \"%s\\inf\\ntprint.inf\" /r \"%s\" /m \"%s\""

//  Console Session ID
#define CONSOLESESSIONID    0

//  Get a numeric representation of our session ID.
#if defined(UNITTEST)
ULONG g_SessionId = 0;
#else
extern ULONG g_SessionId;
#endif
#define GETTHESESSIONID()   g_SessionId

//  Initial size of IOCTL output buffer (big enough for the event header
//  and a "buffer too small" event.
#define INITIALIOCTLOUTPUTBUFSIZE (sizeof(RDPDRDVMGR_EVENTHEADER) + \
                                   sizeof(RDPDR_BUFFERTOOSMALL))

#if defined(UNITTEST)
//  Test driver name.
#define TESTDRIVERNAME      L"AGFA-AccuSet v52.3"
#define TESTPNPNAME         L""
#define TESTPRINTERNAME     TESTDRIVERNAME

//  Test port name.
#define TESTPORTNAME        L"LPT1"
#endif

//  Number of ms to wait for background thread to exit.
#define KILLTHREADTIMEOUT   (1000 * 8 * 60)     // 8 minutes.
//#define KILLTHREADTIMEOUT   (1000 * 30)

//
//  Registry Locations
//
#define THISMODULEENABLEDREGKEY     \
    L"SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\Wds\\rdpwd"

#define THISMODULEENABLEDREGVALUE   \
    L"fEnablePrintRDR"

#define DEBUGLEVELREGKEY     \
    L"SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\Wds\\rdpwd"

#define TSNETWORKPROVIDER   \
    L"SYSTEM\\CurrentControlSet\\Services\\RDPNP\\NetworkProvider"

#define TSNETWORKPROVIDERNAME \
    L"Name"

#define DEBUGLEVELREGVALUE   \
    L"UMRDPDRDebugLevel"


////////////////////////////////////////////////////////
//
//      Globals to this Module
//

//  Event that we will use to terminate the background thread.
HANDLE CloseThreadEvent = NULL;

//  Record whether shutdown is currently active.
LONG ShutdownActiveCount = 0;

BOOL g_UMRDPDR_Init = FALSE;


////////////////////////////////////////////////////////
//
//      Internal Prototypes
//

DWORD BackgroundThread(LPVOID tag);

BOOL SetToApplicationDesktop(
    OUT HDESK *phDesk
    );

void DeleteInstalledDevices(
    IN PDRDEVLST deviceList
    );

BOOL StopBackgroundThread(
    );

BOOL HandleRemoveDeviceEvent(
    IN PRDPDR_REMOVEDEVICE evt
    );

BOOL UMRDPDR_ResizeBuffer(
    IN OUT void    **buffer,
    IN DWORD        bytesRequired,
    IN OUT DWORD    *bufferSize
    );

VOID DispatchNextDeviceEvent(
    IN PDRDEVLST deviceList,
    IN OUT PBYTE *incomingEventBuffer,
    IN OUT DWORD *incomingEventBufferSize,
    IN DWORD incomingEventBufferValidBytes
    );

VOID CloseThreadEventHandler(
    IN HANDLE waitableObject,
    IN PVOID tag
    );

BOOL HandleSessionDisconnectEvent();

VOID UMRDPDR_GetUserSettings();

VOID MainLoop();

VOID CloseWaitableObjects();

VOID GetNextEvtOverlappedSignaled(
    IN HANDLE waitableObject,
    IN PVOID tag
    );

#ifdef UNITTEST
void TellDrToAddTestPrinter();
#endif


////////////////////////////////////////////////////////
//
//      Globals
//

BOOL g_fAutoClientLpts;     // Automatically install client printers?
BOOL g_fForceClientLptDef;  // Force the client printer as the default printer?


////////////////////////////////////////////////////////
//
//      Globals to this Module
//

HANDLE   BackgroundThreadHndl           = NULL;
DWORD    BackGroundThreadId             = 0;

//  The waitable object manager.
WTBLOBJMGR  WaitableObjMgr              = NULL;

//  True if this module is enabled.
BOOL ThisModuleEnabled                  = FALSE;

//  List of installed devices.
DRDEVLST   InstalledDevices;

//  Overlapped IO structs..
OVERLAPPED GetNextEvtOverlapped;
OVERLAPPED SendClientMsgOverlapped;

//  RDPDR Incoming Event Buffer
PBYTE RDPDRIncomingEventBuffer = NULL;
DWORD RDPDRIncomingEventBufferSize = 0;

//  True if an IOCTL requesting the next device-related
//  event is pending.
BOOL RDPDREventIOPending = FALSE;

//  This module should shut down.
BOOL ShutdownFlag = FALSE;

//  Token for the currently logged in user
HANDLE TokenForLoggedOnUser = NULL;

//  Handle to RDPDR.SYS.
HANDLE RDPDRHndl = INVALID_HANDLE_VALUE;

BOOL
UMRDPDR_Initialize(
    IN HANDLE hTokenForLoggedOnUser
    )
/*++

Routine Description:

    Initialize function for this module.  This function spawns a background
    thread that does most of the work.

Arguments:

    hTokenForLoggedOnUser - Handle to logged on user.

Return Value:

    Returns TRUE on success.  FALSE, otherwise.

--*/
{
    BOOL result;
    NTSTATUS status;
    HKEY regKey;
    LONG sz;
    DWORD dwLastError;


    /////////////////////////////////////////////////////
    //
    //  Check a reg key to see if we should be running by
    //  reading a reg key.  We are enabled by default.
    //
    DWORD   enabled = TRUE;

    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, THISMODULEENABLEDREGKEY, 0,
                          KEY_READ, &regKey);
    if (status == ERROR_SUCCESS) {
        sz = sizeof(enabled);
        RegQueryValueEx(regKey, THISMODULEENABLEDREGVALUE, NULL,
                NULL, (PBYTE)&enabled, &sz);
        RegCloseKey(regKey);
    }

    // If we are in a non-console RDP session, then we are enabled.
    ThisModuleEnabled = enabled && TSNUTL_IsProtocolRDP() &&
                    (!IsActiveConsoleSession());


    /////////////////////////////////////////////////////
    //
    //  Read the TS Network Provider out of the registry
    //
    ProviderName[0] = L'\0';
    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, TSNETWORKPROVIDER, 0,
            KEY_READ, &regKey);
    if (status == ERROR_SUCCESS) {
        sz = sizeof(ProviderName);
        RegQueryValueEx(regKey, TSNETWORKPROVIDERNAME, NULL, 
                NULL, (PBYTE)ProviderName, &sz); 
        RegCloseKey(regKey);
    }
    else {
        // Should Assert here
        ProviderName[0] = L'\0';
    }              
 
    /////////////////////////////////////////////////////
    //
    //  Read the debug level out of the registry.
    //
#if DBG
    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, DEBUGLEVELREGKEY, 0,
                          KEY_READ, &regKey);
    if (status == ERROR_SUCCESS) {
        sz = sizeof(GLOBAL_DEBUG_FLAGS);
        RegQueryValueEx(regKey, DEBUGLEVELREGVALUE, NULL,
                    NULL, (PBYTE)&GLOBAL_DEBUG_FLAGS, &sz);
        RegCloseKey(regKey);
    }
#endif

#ifdef UNITTEST
    ThisModuleEnabled = TRUE;
#endif

    // Just return if we are not enabled.
    if (!ThisModuleEnabled || g_UMRDPDR_Init) {
        return TRUE;
    }

    DBGMSG(DBG_TRACE, ("UMRDPDR:UMRDPDR_Initialize.\n"));

    //
    //  If the background thread didn't exit properly the last time we were 
    //  shut down then we risk re-entrancy by reinitializing.
    //
    if (BackgroundThreadHndl != NULL) {
        ASSERT(FALSE);
        SetLastError(ERROR_ALREADY_INITIALIZED);
        return FALSE;
    }

    //  Record the token for the logged on user.
    TokenForLoggedOnUser = hTokenForLoggedOnUser;

    //  Reset the shutdown flag.
    ShutdownFlag = FALSE;

    // Load the global user settings for this user.
    UMRDPDR_GetUserSettings();

    // Initialize the installed device list.
    DRDEVLST_Create(&InstalledDevices);

    //
    //  Create the waitable object manager.
    //
    WaitableObjMgr = WTBLOBJ_CreateWaitableObjectMgr();
    result = WaitableObjMgr != NULL;

    //
    //  Initialize the supporting module for printing devices.  If this module
    //  fails to initialize, device redirection for non-port/printing devices
    //  can continue to function.
    //
    if (result) {
        UMRDPPRN_Initialize(
                        &InstalledDevices,
                        WaitableObjMgr,
                        TokenForLoggedOnUser
                        );
    }

    //
    //  Set the RDPDR incoming event buffer to the minimum starting size.
    //
    if (result) {
        if (!UMRDPDR_ResizeBuffer(&RDPDRIncomingEventBuffer, INITIALIOCTLOUTPUTBUFSIZE,
                         &RDPDRIncomingEventBufferSize)) {
            DBGMSG(DBG_ERROR, ("UMRDPPRN:Cannot allocate input buffer. Error %ld\n",
             GetLastError()));
            result = FALSE;
        }
    }

    //
    //  Init get next device management event overlapped io struct.
    //
    if (result) {
        RtlZeroMemory(&GetNextEvtOverlapped, sizeof(OVERLAPPED));
        GetNextEvtOverlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (GetNextEvtOverlapped.hEvent != NULL) {
            dwLastError = WTBLOBJ_AddWaitableObject(
                                    WaitableObjMgr, NULL,
                                    GetNextEvtOverlapped.hEvent,
                                    GetNextEvtOverlappedSignaled
                                    );
            if (dwLastError != ERROR_SUCCESS) {
                result = FALSE;
            }
        }
        else {
            dwLastError = GetLastError();

            DBGMSG(DBG_ERROR,
                ("UMRDPPRN:Error creating overlapped IO event. Error: %ld\n", dwLastError));

            result = FALSE;
        }
    }

    //
    //  Init send device management event overlapped io struct.
    //
    RtlZeroMemory(&SendClientMsgOverlapped, sizeof(OVERLAPPED));
    if (result) {
        SendClientMsgOverlapped.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (SendClientMsgOverlapped.hEvent == NULL) {
            dwLastError = GetLastError();

            DBGMSG(DBG_ERROR,
                ("UMRDPPRN:Error creating overlapped IO event. Error: %ld\n", dwLastError));

            result = FALSE;
        }
    }

    //
    //  Create the event that we will use to synchronize shutdown of the
    //  background thread.
    //
    if (result) {
        CloseThreadEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

        //
        //  Add it to the waitable object manager.
        //
        if (CloseThreadEvent != NULL) {
            dwLastError = WTBLOBJ_AddWaitableObject(
                                    WaitableObjMgr, NULL,
                                    CloseThreadEvent,
                                    CloseThreadEventHandler
                                    );
            if (dwLastError != ERROR_SUCCESS) {
                result = FALSE;
            }
        }
        else {
            dwLastError = GetLastError();
            DBGMSG(DBG_ERROR,
                ("UMRDPPRN:Error creating event to synchronize thread shutdown. Error: %ld\n",
                dwLastError));

            result = FALSE;

        }
    }

    //
    //  Create the background thread.
    //
    if (result) {
        BackgroundThreadHndl = CreateThread(
                                    NULL, 0,
                                    (LPTHREAD_START_ROUTINE )BackgroundThread,
                                    NULL,
                                    0,&BackGroundThreadId
                                    );
        result = (BackgroundThreadHndl != NULL);
        if (!result) {
            dwLastError = GetLastError();
            DBGMSG(DBG_ERROR,
                ("UMRDPPRN:Error creating background thread. Error: %ld\n",
                dwLastError));
        }
    }

    
    if (result) {
        OSVERSIONINFOEX osVersionInfo;
        DWORDLONG dwlConditionMask = 0;
        BOOL fSuiteTerminal = FALSE;
        BOOL fSuiteSingleUserTS = FALSE;

        DBGMSG(DBG_INFO, ("UMRDPDR:UMRDPDR_Initialize succeeded.\n"));

        ZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
        osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL; 
        VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );
        fSuiteTerminal = VerifyVersionInfo(&osVersionInfo,VER_SUITENAME,dwlConditionMask);
        osVersionInfo.wSuiteMask = VER_SUITE_SINGLEUSERTS;
        fSuiteSingleUserTS = VerifyVersionInfo(&osVersionInfo,VER_SUITENAME,dwlConditionMask);
        
        if( (TRUE == fSuiteSingleUserTS) && (FALSE == fSuiteTerminal) )
        {
            fRunningOnPTS = TRUE;
        }
    }
    else {

        //
        //  Zero the token for the logged on user.
        //
        TokenForLoggedOnUser = NULL;

        //
        //  Release the incoming RDPDR event buffer.
        //
        if (RDPDRIncomingEventBuffer != NULL) {
            FREEMEM(RDPDRIncomingEventBuffer);
            RDPDRIncomingEventBuffer = NULL;
            RDPDRIncomingEventBufferSize = 0;
        }

        //
        //  Shut down the supporting module for printing device management.
        //
        UMRDPPRN_Shutdown();

        //
        //  Close all waitable objects.
        //
        CloseWaitableObjects();

        //
        //  Zero the background thread handle.
        //
        if (BackgroundThreadHndl != NULL) {
            CloseHandle(BackgroundThreadHndl);
            BackgroundThreadHndl = NULL;
        }

        SetLastError(dwLastError);
    }

    if (result) {
       g_UMRDPDR_Init = TRUE;
    }
    return result;
}

VOID
CloseWaitableObjects()
/*++

Routine Description:

    Close out all waitable objects for this module.

Arguments:

    NA

Return Value:

    NA

--*/
{
    DBGMSG(DBG_TRACE, ("UMRDPDR:CloseWaitableObjects begin.\n"));

    if (CloseThreadEvent != NULL) {
        ASSERT(WaitableObjMgr != NULL);
        WTBLOBJ_RemoveWaitableObject(
                WaitableObjMgr,
                CloseThreadEvent
                );
        CloseHandle(CloseThreadEvent);
        CloseThreadEvent = NULL;
    }

    if (GetNextEvtOverlapped.hEvent != NULL) {
        ASSERT(WaitableObjMgr != NULL);
        WTBLOBJ_RemoveWaitableObject(
                WaitableObjMgr,
                GetNextEvtOverlapped.hEvent
                );
        CloseHandle(GetNextEvtOverlapped.hEvent);
        GetNextEvtOverlapped.hEvent = NULL;
    }

    if (SendClientMsgOverlapped.hEvent != NULL) {
        CloseHandle(SendClientMsgOverlapped.hEvent);
        SendClientMsgOverlapped.hEvent = NULL;
    }

    if (WaitableObjMgr != NULL) {
        WTBLOBJ_DeleteWaitableObjectMgr(WaitableObjMgr);
        WaitableObjMgr = NULL;
    }

    DBGMSG(DBG_TRACE, ("UMRDPDR:CloseWaitableObjects end.\n"));
}

BOOL
UMRDPDR_Shutdown()
/*++

Routine Description:

    Close down this module.  Right now, we just need to shut down the
    background thread.

Arguments:

Return Value:

    Returns TRUE on success.  FALSE, otherwise.

--*/
{
    BOOL backgroundThreadShutdown;

    g_UMRDPDR_Init = FALSE;
    //
    //  Just return if we are not enabled.
    //
    if (!ThisModuleEnabled) {
        return TRUE;
    }

    DBGMSG(DBG_TRACE, ("UMRDPDR:UMRDPDR_Shutdown.\n"));

    //
    //  Record whether shutdown is currently active.
    //
    if (InterlockedIncrement(&ShutdownActiveCount) > 1) {
        DBGMSG(DBG_TRACE, ("UMRDPDR:UMRDPDR_Shutdown already busy.  Exiting.\n"));
        InterlockedDecrement(&ShutdownActiveCount);

        return TRUE;
    }

    //
    //  Terminate the background thread.
    //
    //  If it won't shut down, winlogon will eventually shut it down.  
    //  Although, this should never happen.
    //
    backgroundThreadShutdown = StopBackgroundThread();
    if (backgroundThreadShutdown) {

        //
        //  Make sure link to RDPDR.SYS is closed.
        //
        if (RDPDRHndl != INVALID_HANDLE_VALUE) {
            CloseHandle(RDPDRHndl);
            RDPDRHndl = INVALID_HANDLE_VALUE;
        }
        RDPDRHndl = INVALID_HANDLE_VALUE;

        //
        //  Release the incoming RDPDR event buffer.
        //
        if (RDPDRIncomingEventBuffer != NULL) {
            FREEMEM(RDPDRIncomingEventBuffer);
            RDPDRIncomingEventBuffer = NULL;
            RDPDRIncomingEventBufferSize = 0;
        }

        //
        //  Delete installed devices.
        //
        DeleteInstalledDevices(&InstalledDevices);


        //
        //  Shut down the supporting module for printing device management.
        //
        UMRDPPRN_Shutdown();

        //
        //  Close all waitable objects and shut down the waitable
        //  object manager.
        //
        CloseWaitableObjects();

        //
        //  Destroy the list of installed devices.
        //
        DRDEVLST_Destroy(&InstalledDevices);

        //
        //  Zero the token for the logged on user.
        //
        TokenForLoggedOnUser = NULL;
    }

    InterlockedDecrement(&ShutdownActiveCount);

    DBGMSG(DBG_TRACE, ("UMRDPDR:UMRDPDR_Shutdown succeeded.\n"));
    return TRUE;
}

BOOL
StopBackgroundThread()
/*++

Routine Description:

    This routine shuts down and cleans up after the background thread.

Arguments:

Return Value:

    Returns TRUE on success.  FALSE, otherwise.

--*/
{
    DWORD waitResult;

    //
    //  Set the shutdown flag.
    //
    ShutdownFlag = TRUE;

    //
    //  Set the event that signals the background thread to check the
    //  shut down flag.
    //
    if (CloseThreadEvent != NULL) {
        SetEvent(CloseThreadEvent);
    }

    //
    //  Make sure it shut down.
    //
    if (BackgroundThreadHndl != NULL) {
        DBGMSG(DBG_TRACE, ("UMRDPDR:Waiting for background thread to shut down.\n"));

        waitResult = WaitForSingleObject(BackgroundThreadHndl, KILLTHREADTIMEOUT);
        if (waitResult != WAIT_OBJECT_0) {
#if DBG
            if (waitResult == WAIT_FAILED) {
                DBGMSG(DBG_ERROR, ("UMRDPDR:Wait failed:  %ld.\n", GetLastError()));
            }
            else if (waitResult == WAIT_ABANDONED) {
                DBGMSG(DBG_ERROR, ("UMRDPDR:Wait abandoned\n"));
            }
            else if (waitResult == WAIT_TIMEOUT) {
                DBGMSG(DBG_ERROR, ("UMRDPDR:Wait timed out.\n"));
            }
            else {
                DBGMSG(DBG_ERROR, ("UMRDPDR:Unknown wait return status:  %08X.\n", waitResult));
                ASSERT(0);
            }
#endif
            DBGMSG(DBG_ERROR, ("UMRDPDR:Error waiting for background thread to exit.\n"));
            ASSERT(FALSE);

        }
        else {
            DBGMSG(DBG_INFO, ("UMRDPDR:Background thread shut down on its own.\n"));
            CloseHandle(BackgroundThreadHndl);
            BackgroundThreadHndl = NULL;
        }
    }
    DBGMSG(DBG_TRACE, ("UMRDPDR:Background thread completely shutdown.\n"));

    return(BackgroundThreadHndl == NULL);
}

void DeleteInstalledDevices(
    IN PDRDEVLST deviceList
    )
/*++

Routine Description:

    Delete installed devices and release the installed device list.

Arguments:

    devices -   Devices to delete.

Return Value:

    TRUE on success.  FALSE, otherwise.

--*/
{
    DBGMSG(DBG_TRACE, ("UMRDPDR:Removing installed devices.\n"));
    while (deviceList->deviceCount > 0) {
        if (deviceList->devices[0].deviceType == RDPDR_DTYP_PRINT) {
            UMRDPPRN_DeleteNamedPrinterQueue(deviceList->devices[0].serverDeviceName);
        }
        else if (deviceList->devices[0].deviceType == RDPDR_DTYP_FILESYSTEM) {
            UMRDPDRV_DeleteDriveConnection(&(deviceList->devices[0]), TokenForLoggedOnUser);
        }
        else if (deviceList->devices[0].deviceType != RDPDR_DRYP_PRINTPORT) {
            UMRDPPRN_DeleteSerialLink( deviceList->devices[0].preferredDosName,
                                       deviceList->devices[0].serverDeviceName,
                                       deviceList->devices[0].clientDeviceName );            
        }

        DRDEVLST_Remove(deviceList, 0);
    }
    DBGMSG(DBG_TRACE, ("UMRDPDR:Done removing installed devices.\n"));
}

VOID CloseThreadEventHandler(
    IN HANDLE waitableObject,
    IN PVOID tag
    )
/*++

Routine Description:

    Called when the shutdown waitable object is signaled.

Arguments:

    waitableObject  -   Relevant waitable object.
    tag             -   Client data, ignored.

Return Value:

    NA

--*/
{
    //  Do nothing.  The background thread should pick up the
    //  shutdown flag at the top of its loop.
}

VOID GetNextEvtOverlappedSignaled(
    IN HANDLE waitableObject,
    IN PVOID tag
    )
/*++

Routine Description:

    Called by the Waitable Object Manager when a pending IO event from RDPDR.SYS
    has completed.

Arguments:

    waitableObject  -   Relevant waitable object.
    tag             -   Client data, ignored.

Return Value:

    NA

--*/
{
    DWORD bytesReturned;

    DBGMSG(DBG_TRACE, ("UMRDPDR:GetNextEvtOverlappedSignaled begin.\n"));

    //
    //  IO from RDPDR.SYS is no longer pending.
    //
    RDPDREventIOPending = FALSE;

    //
    //  Dispatch the event.
    //
    if (GetOverlappedResult(RDPDRHndl, &GetNextEvtOverlapped,
                            &bytesReturned, FALSE)) {

        ResetEvent(GetNextEvtOverlapped.hEvent);

        DispatchNextDeviceEvent(
            &InstalledDevices,
            &RDPDRIncomingEventBuffer,
            &RDPDRIncomingEventBufferSize,
            bytesReturned
            );
    }
    else {
        DBGMSG(DBG_ERROR, ("UMRDPDR:GetOverlappedResult failed:  %ld.\n",
            GetLastError()));
        ASSERT(0);
        ShutdownFlag = TRUE;
    }

    DBGMSG(DBG_TRACE, ("UMRDPDR:GetNextEvtOverlappedSignaled end.\n"));
}

DWORD BackgroundThread(
    IN PVOID tag
    )
/*++

Routine Description:

    This thread handles all device-install/uninstall-related issues.

Arguments:

    tag     -   Ignored.

Return Value:

--*/
{
    BOOL    result=TRUE;
    HDESK   hDesk = NULL;
    WCHAR drPath[MAX_PATH+1];
    DWORD dwLastError;
    DWORD dwFailedLineNumber;
    HDESK hDeskSave = NULL;

    DBGMSG(DBG_TRACE, ("UMRDPDR:BackgroundThread.\n"));

    //
    //  Create the path to the "dr."
    //
    wsprintf(drPath, L"\\\\.\\%s%s%ld",
             RDPDRDVMGR_W32DEVICE_NAME_U,
             RDPDYN_SESSIONIDSTRING,
              GETTHESESSIONID());
    ASSERT(wcslen(drPath) <= MAX_PATH);

    //
    //  Open a connection to the RDPDR.SYS device manager device.
    //
    RDPDRHndl = CreateFile(
                    drPath,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                    NULL
                    );
    if (RDPDRHndl == INVALID_HANDLE_VALUE) {
        dwLastError = GetLastError();
        dwFailedLineNumber = __LINE__;

        DBGMSG(DBG_ERROR,
            ("Error opening RDPDR device manager component. Error: %ld\n", dwLastError));

        result = FALSE;
        goto CleanupAndExit;
    }

    //
    //  Save the current thread desktop.
    //
    hDeskSave = GetThreadDesktop(GetCurrentThreadId());
    if (hDeskSave == NULL) {
        dwLastError = GetLastError();
        dwFailedLineNumber = __LINE__;
        result = FALSE;
        DBGMSG(DBG_ERROR, ("UMRDPDR:  GetThreadDesktop:  %08X\n", dwLastError));
        goto CleanupAndExit;
    }

    //
    //  Set the current desktop for our thread to the application desktop.
    //
    if (!SetToApplicationDesktop(&hDesk)) {
        dwLastError = GetLastError();
        dwFailedLineNumber = __LINE__;
        result = FALSE;
        goto CleanupAndExit;
    }

    DBGMSG(DBG_TRACE, ("UMRDPDR:After setting the application desktop.\n"));

    //
    //  Enter the main loop until it completes, indicating time to exit.
    //
    MainLoop();

    DBGMSG(DBG_TRACE, ("UMDRPDR:Exiting background thread.\n"));

    //
    //  Close the application desktop handle.
    //
CleanupAndExit:
    if (!result) {
        SetLastError(dwLastError);
        TsLogError(EVENT_NOTIFY_PRINTER_REDIRECTION_FAILED, EVENTLOG_ERROR_TYPE,
                                0, NULL, dwFailedLineNumber);
    }

    if (RDPDRHndl != INVALID_HANDLE_VALUE) {
        DBGMSG(DBG_TRACE, ("UMRDPDR:Closing connection to RDPDR.SYS.\n"));
        if (!CloseHandle(RDPDRHndl)) {
            DBGMSG(DBG_TRACE, ("UMRDPDR:Error closing connection to RDPDR.SYS:  %ld.\n",
                    GetLastError()));
        }
        else {
            RDPDRHndl = INVALID_HANDLE_VALUE;
            DBGMSG(DBG_TRACE, ("UMRDPDR:Connection to RDPDR.SYS successfully closed\n"));
        }
    }

    if (hDeskSave != NULL) {
        if (!SetThreadDesktop(hDeskSave)) {
            DBGMSG(DBG_ERROR, ("UMRDPDR:SetThreadDesktop:  %08X\n", GetLastError()));
        }
    }

    if (hDesk != NULL) {
        if (!CloseDesktop(hDesk)) {
            DBGMSG(DBG_ERROR, ("UMRDPDR:CloseDesktop:  %08X\n", GetLastError()));
        }
        else {
            DBGMSG(DBG_TRACE, ("UMRDPDR:CloseDesktop succeeded.\n"));
        }
    }

    DBGMSG(DBG_TRACE, ("UMDRPDR:Done exiting background thread.\n"));
    return result;
}

VOID
MainLoop()
/*++

Routine Description:

    Main loop for the background thread.

Arguments:

Return Value:

    NA

--*/
{
    DWORD   waitResult;
    BOOL    result;
    DWORD   bytesReturned;

    //
    //  Reset the flag, indicating that IO to RDPDR is not yet pending.
    //
    RDPDREventIOPending = FALSE;

    //
    //  Loop until the background thread should exit and this module should
    //  shut down.
    //
    while (!ShutdownFlag) {

        //
        //  Send an IOCTL to RDPDR.SYS to get the next "device management event."
        //
        if (!RDPDREventIOPending) {

            DBGMSG(DBG_TRACE, ("UMRDPDR:Sending IOCTL to RDPDR.\n"));
            result = DeviceIoControl(
                            RDPDRHndl,
                            IOCTL_RDPDR_GETNEXTDEVMGMTEVENT,
                            NULL,
                            0,
                            RDPDRIncomingEventBuffer,
                            RDPDRIncomingEventBufferSize,
                            &bytesReturned, &GetNextEvtOverlapped
                            );

            //
            //  If the IOCTL finished.
            //
            if (result && !ShutdownFlag) {
                DBGMSG(DBG_TRACE, ("UMRDPDR:DeviceIoControl no pending IO.  Data ready.\n"));

                if (!ResetEvent(GetNextEvtOverlapped.hEvent)) {
                    DBGMSG(DBG_ERROR, ("UMRDPDR:  ResetEvent:  %08X\n",
                          GetLastError()));
                    ASSERT(FALSE);
                }

                DispatchNextDeviceEvent(
                            &InstalledDevices,
                            &RDPDRIncomingEventBuffer,
                            &RDPDRIncomingEventBufferSize,
                            bytesReturned
                            );
            }
            else if (!result && (GetLastError() != ERROR_IO_PENDING)) {

                DBGMSG(DBG_ERROR, ("UMRDPPRN:DeviceIoControl failed. Error: %ld\n",
                    GetLastError()));

                TsLogError(
                    EVENT_NOTIFY_PRINTER_REDIRECTION_FAILED, EVENTLOG_ERROR_TYPE,
                    0, NULL, __LINE__
                    );

                //
                //  Shut down the background thread and the module, in general.
                //
                ShutdownFlag = TRUE;
            }
            else {
                DBGMSG(DBG_TRACE, ("UMRDPDR:DeviceIoControl indicated IO pending.\n"));

                RDPDREventIOPending = TRUE;
            }
        }

        //
        //  If IO to RDPDR.SYS is pending, then wait for one of our waitable objects to
        //  become signaled.  This way, the shutdown event and data from RDPDR.SYS gets
        //  priority.
        //
        if (!ShutdownFlag && RDPDREventIOPending) {
            if (WTBLOBJ_PollWaitableObjects(WaitableObjMgr) != ERROR_SUCCESS) {
                ShutdownFlag = TRUE;
            }
        }
    }
}

VOID
DispatchNextDeviceEvent(
    IN PDRDEVLST deviceList,
    IN OUT PBYTE *incomingEventBuffer,
    IN OUT DWORD *incomingEventBufferSize,
    IN DWORD incomingEventBufferValidBytes
    )
/*++

Routine Description:

    Dispatch the next device-related event from RDPDR.SYS.

Arguments:

    deviceList                      -   Master list of installed devices.
    incomingEventBuffer             -   Incoming event buffer.
    incomingEventBufferSize         -   Incoming event buffer size
    incomingEventBufferValidBytes   -   Number of valid bytes in the event
                                        buffer.

Return Value:

    NA

--*/
{
    PRDPDR_PRINTERDEVICE_SUB printerAnnounceEvent;
    PRDPDR_PORTDEVICE_SUB portAnnounceEvent;
    PRDPDR_DRIVEDEVICE_SUB driveAnnounceEvent;
    PRDPDR_REMOVEDEVICE removeDeviceEvent;
    PRDPDRDVMGR_EVENTHEADER eventHeader;
    PRDPDR_BUFFERTOOSMALL bufferTooSmallEvent;
    DWORD eventDataSize;
    PBYTE eventData;
    DWORD lastError = ERROR_SUCCESS;
    DWORD dwFailedLineNumber;
    DWORD errorEventCode;

    DBGMSG(DBG_TRACE, ("UMRDPDR:DispatchNextDeviceEvent.\n"));

    //
    //  The first few bytes of the result buffer are the header.
    //
    ASSERT(incomingEventBufferValidBytes >= sizeof(RDPDRDVMGR_EVENTHEADER));
    eventHeader = (PRDPDRDVMGR_EVENTHEADER)(*incomingEventBuffer);
    eventData   = *incomingEventBuffer + sizeof(RDPDRDVMGR_EVENTHEADER);
    eventDataSize = incomingEventBufferValidBytes - sizeof(RDPDRDVMGR_EVENTHEADER);

    //
    //  Dispatch the event.
    //
    switch(eventHeader->EventType) {

    case RDPDREVT_BUFFERTOOSMALL    :

        DBGMSG(DBG_TRACE, ("UMRDPDR:Buffer too small msg received.\n"));

        ASSERT((incomingEventBufferValidBytes - sizeof(RDPDRDVMGR_EVENTHEADER)) >=
                sizeof(RDPDR_BUFFERTOOSMALL));
        bufferTooSmallEvent = (PRDPDR_BUFFERTOOSMALL)(*incomingEventBuffer +
                                                    sizeof(RDPDRDVMGR_EVENTHEADER));
                if (!UMRDPDR_ResizeBuffer(incomingEventBuffer, bufferTooSmallEvent->RequiredSize,
                                                                incomingEventBufferSize)) {
            ShutdownFlag = TRUE;

            lastError = ERROR_INSUFFICIENT_BUFFER;
            errorEventCode = EVENT_NOTIFY_INSUFFICIENTRESOURCES;
            dwFailedLineNumber = __LINE__;
        }
        break;

    case RDPDREVT_PRINTERANNOUNCE   :

        DBGMSG(DBG_TRACE, ("UMRDPDR:Printer announce msg received.\n"));

        ASSERT(eventDataSize >= sizeof(RDPDR_PRINTERDEVICE_SUB));
        printerAnnounceEvent = (PRDPDR_PRINTERDEVICE_SUB)eventData;
        if (!UMRDPPRN_HandlePrinterAnnounceEvent(
                                printerAnnounceEvent
                                )) {
        }
        break;

    case RDPDREVT_PORTANNOUNCE   :

        DBGMSG(DBG_TRACE, ("UMRDPDR:Port announce event received.\n"));

        ASSERT(eventDataSize >= sizeof(PRDPDR_PORTDEVICE_SUB));
        portAnnounceEvent = (PRDPDR_PORTDEVICE_SUB)eventData;
        UMRDPPRN_HandlePrintPortAnnounceEvent(portAnnounceEvent);
        break;

    case RDPDREVT_DRIVEANNOUNCE   :

        DBGMSG(DBG_TRACE, ("UMRDPDR:Drive announce event received.\n"));

        ASSERT(eventDataSize >= sizeof(PRDPDR_DRIVEDEVICE_SUB));
        driveAnnounceEvent = (PRDPDR_DRIVEDEVICE_SUB)eventData;
        UMRDPDRV_HandleDriveAnnounceEvent(deviceList, driveAnnounceEvent,
                                          TokenForLoggedOnUser);
        break;

    case RDPDREVT_REMOVEDEVICE    :

        DBGMSG(DBG_TRACE, ("UMRDPDR:Remove device event received.\n"));

        ASSERT(eventDataSize >= sizeof(RDPDR_REMOVEDEVICE));
        removeDeviceEvent = (PRDPDR_REMOVEDEVICE)eventData;
        HandleRemoveDeviceEvent(removeDeviceEvent);
        break;

    case RDPDREVT_SESSIONDISCONNECT :

        DBGMSG(DBG_TRACE, ("UMRDPDR:Session disconnected event received.\n"));

        //  There isn't any event data associated with a session disconnect event.
        ASSERT(eventDataSize == 0);
        HandleSessionDisconnectEvent();
        break;

    default                        :

        DBGMSG(DBG_WARN, ("UMRDPDR:Unrecognized msg from RDPDR.SYS.\n"));
    }

    //
    //  Log an error if there is one to be logged.
    //
    if (lastError != ERROR_SUCCESS) {

        SetLastError(lastError);
        TsLogError(
            errorEventCode,
            EVENTLOG_ERROR_TYPE,
            0,
            NULL,
            dwFailedLineNumber
            );
    }
}

BOOL
HandleSessionDisconnectEvent()
/*++

Routine Description:

    Handles session disconnect device management by deleting all known
    session devices.

Arguments:

Return Value:

    Return TRUE on success.  FALSE, otherwise.

--*/
{
    DBGMSG(DBG_TRACE, ("UMRDPDR:HandleSessionDisconnectEvent.\n"));

    //
    //  Delete installed devices.
    //
    DeleteInstalledDevices(&InstalledDevices);

    return TRUE;
}

BOOL
HandleRemoveDeviceEvent(
    IN PRDPDR_REMOVEDEVICE evt
    )
/*++

Routine Description:

    Handle a device removal component from RDPDR.SYS.

Arguments:

    removeDeviceEvent -  Device removal event.

Return Value:

    Return TRUE on success.  FALSE, otherwise.

--*/
{
    DWORD ofs;
    BOOL result;

    DBGMSG(DBG_TRACE, ("UMRDPDR:HandleRemoveDeviceEvent.\n"));

    // Find the device in our device list via the client-assigned device ID.
    if (DRDEVLST_FindByClientDeviceID(&InstalledDevices, evt->deviceID, &ofs)) {

        //
        //  Switch on the type of device being removed.
        //
        switch(InstalledDevices.devices[ofs].deviceType)
        {
        case RDPDR_DTYP_PRINT :

            DBGMSG(DBG_WARN, ("UMRDPDR:Printer queue %ws removed.\n",
                               InstalledDevices.devices[ofs].serverDeviceName));

            if (UMRDPPRN_DeleteNamedPrinterQueue(
                        InstalledDevices.devices[ofs].serverDeviceName)) {
                DRDEVLST_Remove(&InstalledDevices, ofs);
                result = TRUE;
            }
            else {
                result = FALSE;
            }
            break;

        case RDPDR_DTYP_SERIAL :
        case RDPDR_DTYP_PARALLEL :
            DBGMSG(DBG_WARN, ("UMRDPDR:Serial port %ws removed.\n",
                   InstalledDevices.devices[ofs].serverDeviceName));

            if (UMRDPPRN_DeleteSerialLink( InstalledDevices.devices[ofs].preferredDosName,
                                       InstalledDevices.devices[ofs].serverDeviceName,
                                       InstalledDevices.devices[ofs].clientDeviceName )) {
                DRDEVLST_Remove(&InstalledDevices, ofs);
                result = TRUE;
            }
            else {
                result = FALSE;
            }
            break;
        
        case RDPDR_DRYP_PRINTPORT :

            DBGMSG(DBG_WARN, ("UMRDPDR:Parallel port %ws removed.\n",
                               InstalledDevices.devices[ofs].serverDeviceName));
            DRDEVLST_Remove(&InstalledDevices, ofs);
            result = TRUE;
            break;

        case RDPDR_DTYP_FILESYSTEM:

            DBGMSG(DBG_WARN, ("UMRDPDR:Redirected drive %ws removed.\n",
                               InstalledDevices.devices[ofs].serverDeviceName));

            if (UMRDPDRV_DeleteDriveConnection(&(InstalledDevices.devices[ofs]),
                                               TokenForLoggedOnUser)) {
                DRDEVLST_Remove(&InstalledDevices, ofs);
                result = TRUE;
            }
            else {
                result = FALSE;
            }
            break;

        default:

            result = FALSE;
            DBGMSG(DBG_WARN, ("UMRDPDR:Remove event received for unknown device type %ld.\n",
                    InstalledDevices.devices[ofs].deviceType));

        }
    }
    else {
        result = FALSE;
        DBGMSG(DBG_ERROR, ("UMRDPDR:Cannot find device with id %ld for removal.\n",
                    evt->deviceID));
    }

    return result;
}

BOOL
UMRDPDR_SendMessageToClient(
    IN PVOID    msg,
    IN DWORD    msgSize
    )
/*++
Routine Description:

    Send a message to the TS client corresponding to this session, via the kernel
    mode component.

Arguments:

    msg                 - The message.
    msgSize             - Size (in bytes) of message.

Return Value:

    TRUE on success.  FALSE otherwise.
--*/
{
    BOOL result;
    BYTE outBuf[MAX_PATH];
    DWORD bytesReturned;
    BOOL wait;
    DWORD waitResult;

    DBGMSG(DBG_TRACE, ("UMRDPDR:UMRDPDR_SendMessageToClient.\n"));

    //
    //  Send the "client message" IOCTL to RDPDR.
    //

    result = DeviceIoControl(
                    RDPDRHndl,
                    IOCTL_RDPDR_CLIENTMSG,
                    msg,
                    msgSize,
                    outBuf,
                    sizeof(outBuf),
                    &bytesReturned,
                    &SendClientMsgOverlapped
                    );

    //
    //  See if we need to wait for the IO complete.  RDPDR.SYS is designed to
    //  return immediately, in response to this IOCTL.
    //
    if (result) {
        DBGMSG(DBG_TRACE, ("UMRDPDR:DeviceIoControl no pending IO.  Data ready.\n"));
        wait = FALSE;
        result = TRUE;
    }
    else if (!result && (GetLastError() != ERROR_IO_PENDING)) {
        DBGMSG(DBG_ERROR, ("UMRDPPRN:DeviceIoControl Failed. Error: %ld\n",
            GetLastError()));

        TsLogError(EVENT_NOTIFY_PRINTER_REDIRECTION_FAILED, EVENTLOG_ERROR_TYPE, 0, NULL, __LINE__);
        wait = FALSE;
        result = FALSE;
    }
    else {
        DBGMSG(DBG_TRACE, ("UMRDPDR:DeviceIoControl indicated IO pending.\n"));
        wait = TRUE;
        result = TRUE;
    }

    //
    //  Wait for the IO to complete.
    //
    if (wait) {
        DBGMSG(DBG_TRACE, ("UMRDPDR:UMRDPDR_SendMessageToClient IO is pending.\n"));
        waitResult = WaitForSingleObject(SendClientMsgOverlapped.hEvent, INFINITE);
        if (waitResult != WAIT_OBJECT_0) {
            DBGMSG(DBG_ERROR, ("UMRDPPRN:RDPDR.SYS failed client message IOCTL. Error: %ld\n",
                GetLastError()));

            TsLogError(EVENT_NOTIFY_PRINTER_REDIRECTION_FAILED, EVENTLOG_ERROR_TYPE, 0, NULL, __LINE__);
            result = FALSE;
        }
        else {
            DBGMSG(DBG_TRACE, ("UMRDPDR:Client message sent successfully.\n"));
        }
    }
    return result;
}

BOOL
UMRDPDR_ResizeBuffer(
    IN OUT void    **buffer,
    IN DWORD        bytesRequired,
    IN OUT DWORD    *bufferSize
    )
/*++

Routine Description:

    Make sure a buffer is large enough.

Arguments:

    buffer              - The buffer.
    bytesRequired       - Required size.
    bufferSize          - Current buffer size.

Return Value:

    Returns FALSE if buffer cannot be resized.

--*/
{
    BOOL result;

    if (*bufferSize < bytesRequired) {
        if (*buffer == NULL) {
            *buffer = ALLOCMEM(bytesRequired);
        }
        else {
            void *pTmp = REALLOCMEM(*buffer, bytesRequired);
            if (pTmp != NULL) {
                *buffer = pTmp;
            } else {
                FREEMEM(*buffer);
                *buffer = NULL;
            }
        }
        if (*buffer == NULL) {
            *bufferSize = 0;
            DBGMSG(DBG_ERROR, ("UMRDPPRN:Error resizing buffer. Error: %ld\n",
                GetLastError()));
            result = FALSE;
        }
        else {
            result = TRUE;
            *bufferSize = bytesRequired;
        }
    } else {
        result = TRUE;
    }
    return result;
}

BOOL
SetToApplicationDesktop(
    OUT HDESK *phDesk
    )
/*++

Routine Description:

    Set the current desktop for our thread to the application desktop.
    Callers of this function should call CloseDesktop with the returned
    desktop handle when they are done with the desktop.

Arguments:

    phDesk              - Pointer to the application desktop.

Return Value:

    Returns TRUE on success.  FALSE, otherwise.

--*/
{
    ASSERT(phDesk != NULL);

    *phDesk = OpenDesktopW(L"default", 0, FALSE,
                        DESKTOP_READOBJECTS | DESKTOP_CREATEWINDOW |
                        DESKTOP_CREATEMENU | DESKTOP_WRITEOBJECTS |
                        STANDARD_RIGHTS_REQUIRED);
    if (*phDesk == NULL) {
        DBGMSG(DBG_ERROR, ("UMRDPPRN:Failed to open desktop. Error: %ld\n",
            GetLastError()));
        return FALSE;
    }
    else if (!SetThreadDesktop(*phDesk)) {
        DBGMSG(DBG_ERROR, ("UMRDPPRN:Failed to set current thread desktop. Error: %ld\n",
            GetLastError()));
        CloseDesktop(*phDesk);
        *phDesk = NULL;
        return FALSE;
    }
    else {
        return TRUE;
    }
}

VOID
UMRDPDR_GetUserSettings()
/*++

Routine Description:

    Gets the flags to determine whether we do automatic installation

Arguments:
    None.

Return Value:
    None.

--*/
{
    NTSTATUS Status;
    WINSTATIONCONFIG WinStationConfig;
    ULONG ReturnLength;
    HANDLE hServer;

    DBGMSG(DBG_TRACE, ("UMRDPDR:UMRDPDR_GetUserFlags called.\n"));

    g_fAutoClientLpts = FALSE;
    g_fForceClientLptDef = FALSE;

    hServer = WinStationOpenServer(NULL);

    if (hServer) {
        Status = WinStationQueryInformation(hServer, g_SessionId,
                WinStationConfiguration, &WinStationConfig,
                sizeof(WinStationConfig), &ReturnLength);

        if (NT_SUCCESS(Status)) {
            g_fAutoClientLpts = WinStationConfig.User.fAutoClientLpts;
            g_fForceClientLptDef = WinStationConfig.User.fForceClientLptDef;
        } else {
            DBGMSG(DBG_ERROR, ("UMRDPDR:Error querying user settings\n"));
        }
        WinStationCloseServer(hServer);
    } else {
        DBGMSG(DBG_ERROR, ("UMRDPDR:Opening winstation\n"));
    }

    DBGMSG(DBG_TRACE, ("UMRDPDR:Client printers will%sbe mapped\n",
            g_fAutoClientLpts ? " " : " not "));
    DBGMSG(DBG_TRACE, ("UMRDPDR:Client printers will%sbe made default\n",
            g_fForceClientLptDef ? " " : " not "));
}
BOOL UMRDPDR_fAutoInstallPrinters()
{
    return g_fAutoClientLpts;
}
BOOL UMRDPDR_fSetClientPrinterDefault()
{
    return g_fForceClientLptDef;
}

#if DBG
VOID DbgMsg(CHAR *msgFormat, ...)
/*++

Routine Description:

    Print debug output.

Arguments:

    pathBuffer  -  Address of a buffer to receive the path name selected by
                   the user. The size of this buffer is assumed to be
                   MAX_PATH bytes.  This buffer should contain the default
                   path.

Return Value:

    Returns TRUE on success.  FALSE, otherwise.

--*/
{
    CHAR   msgText[256];
    va_list vargs;

    va_start(vargs, msgFormat);
    wvsprintfA(msgText, msgFormat, vargs);
    va_end( vargs );

    if (*msgText)
        OutputDebugStringA("UMRDPDR: ");
    OutputDebugStringA(msgText);
}
#endif

/*++

  Unit-Test Entry Point

--*/
#ifdef UNITTEST
void __cdecl main(int argc, char **argv)
{
    BOOL killLoop = FALSE;
    int i;
    BOOL result;
    NTSTATUS ntStatus;
    HKEY regKey;
    LONG regValueSize;
    LONG status;
    HANDLE pHandle;
    HANDLE tokenHandle;

    TsInitLogging();

    //
    //  Check the command-line args to see what test we are performing.
    //
    if ((argc > 1) && strcmp(argv[1], "\\?")) {
        if (!strcmp(argv[1], "AddPrinter")) {

            TellDrToAddTestPrinter();
            exit(-1);

        }
        else if (!strcmp(argv[1], "StandAlone")) {
            pHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE,
                                GetCurrentProcessId());
            if (!OpenProcessToken(pHandle, TOKEN_ALL_ACCESS, &tokenHandle)) {
                OutputDebugString(TEXT("Error opening process token.  Exiting\n"));
                exit(-1);
            }

            UMRDPDR_Initialize(tokenHandle);
            while (!killLoop) {
                Sleep(100);
            }

            UMRDPDR_Shutdown();
            OutputDebugString(L"UMRDPDR:Exiting.\r\n");
            exit(-1);
        }
    }
    else {
        printf("\\?             for command line parameters.\n");
        printf("AddPrinter      to tell RDPDR.SYS to generate a test printer.\n");
        printf("StandAlone      to run normally, but stand-alone.\n");
        printf("UnitTest        to run a simple unit-test.\n");
        exit(-1);
    }
}

void TellDrToAddTestPrinter()
/*++

Routine Description:

    This function uses a debug IOCTL to tell RDPDR to generate a test
    printer event.

Arguments:

Return Value:

--*/
{
    WCHAR drPath[MAX_PATH+1];
    UNICODE_STRING uncDrPath;
    HANDLE drHndl = INVALID_HANDLE_VALUE;
    BOOL result;
    OBJECT_ATTRIBUTES fileAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS ntStatus;
    BYTE inbuf[MAX_PATH];
    BYTE outbuf[MAX_PATH];
    DWORD bytesReturned;

    //
    //  Create the path to the "dr."
    //
    wsprintf(drPath, L"\\\\.\\%s%s%ld",
             RDPDRDVMGR_W32DEVICE_NAME_U,
             RDPDYN_SESSIONIDSTRING,
             0x9999);

    ASSERT(wcslen(drPath) <= MAX_PATH);

    //
    //  Open a connection to the RDPDR.SYS device manager device.
    //
    drHndl = CreateFile(
                drPath,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );
    if (drHndl == INVALID_HANDLE_VALUE) {
        TsLogError(EVENT_NOTIFY_RDPDR_FAILED, EVENTLOG_ERROR_TYPE, 0, NULL, __LINE__);
        DBGMSG(DBG_ERROR, ("UMRDPPRN:Error opening RDPDR device manager component. Error: %ld\n",
            GetLastError()));
    }
    else {

        // Tell the DR to add a new test printer.
        if (!DeviceIoControl(drHndl, IOCTL_RDPDR_DBGADDNEWPRINTER, inbuf,
                0, outbuf, sizeof(outbuf), &bytesReturned, NULL)) {

            TsLogError(EVENT_NOTIFY_RDPDR_FAILED, EVENTLOG_ERROR_TYPE, 0, NULL, __LINE__);

            DBGMSG(DBG_ERROR, ("UMRDPPRN:Error sending IOCTL to device manager component. Error: %ld\n",
                GetLastError()));
        }
        // Clean up.
        CloseHandle(drHndl);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\umrdpdrv.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name :
	
    umrdpdrv.h

Abstract:

    User-Mode Component for RDP Device Management that Handles Drive Device-
    Specific tasks.

    This is a supporting module.  The main module is umrdpdr.c.

Author:

    Joy Chik     2/1/2000

Revision History:
--*/

#ifndef _UMRDPDRV_
#define _UMRDPDRV_

#include <rdpdr.h>

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//  Handle a drive device announce event from the "dr" by creating 
//  UNC connection for redirect client drive devices.
BOOL UMRDPDRV_HandleDriveAnnounceEvent(
    IN PDRDEVLST installedDevices,
    IN PRDPDR_DRIVEDEVICE_SUB pDriveAnnounce,
    IN HANDLE TokenForLoggedOnUser
    );

//  Delete drive device connection on disconnect / logoff
//  This also cleans up the shell reg folder stuff in my computer
BOOL UMRDPDRV_DeleteDriveConnection(
    IN PDRDEVLSTENTRY deviceEntry,
    IN HANDLE TokenForLoggedOnUser
    );

//  Create a shell reg folder under My Computer for client
//  redirected drive connection
BOOL CreateDriveFolder(
    IN WCHAR *RemoteName, 
    IN WCHAR *ClientDisplayName,
    IN PDRDEVLSTENTRY deviceEntry
    );

//  Delete a shell reg folder under My Computer for client
//  redirected drive connection
BOOL DeleteDriveFolder(
    IN PDRDEVLSTENTRY deviceEntry
    );

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _UMRDPDRV_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\umrdpprn.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name :
	
    umrdpprn.h

Abstract:

    User-Mode Component for RDP Device Management that Handles Printing Device-
    Specific tasks.

    This is a supporting module.  The main module is umrdpdr.c.

Author:

    TadB

Revision History:
--*/

#ifndef _UMRDPPRN_
#define _UMRDPPRN_

#include <rdpdr.h>
#include "wtblobj.h"

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//  Initialize this module.  This must be called prior to any other functions
//  in this module being called.
BOOL UMRDPPRN_Initialize(
    IN PDRDEVLST deviceList,
    IN WTBLOBJMGR waitableObjMgr,
    IN HANDLE hTokenForLoggedOnUser
    );

//  Close down this module.  Right now, we just need to shut down the
//  background thread.
BOOL UMRDPPRN_Shutdown();

//  Handle a printing device announce event from the "dr" by doing 
//  whatever it takes to get the device installed.
BOOL UMRDPPRN_HandlePrinterAnnounceEvent(
    IN PRDPDR_PRINTERDEVICE_SUB pPrintAnnounce
    );

//  Handle a printer port device announce event from the "dr" by doing 
//  whatever it takes to get the device installed.
BOOL UMRDPPRN_HandlePrintPortAnnounceEvent(
    IN PRDPDR_PORTDEVICE_SUB pPortAnnounce
    );

//  Delete the symbolic link for the serial port and restore the original
//  symbolic link if it exists
BOOL UMRDPPRN_DeleteSerialLink(
    IN UCHAR *preferredDosName,
    IN WCHAR *ServerDeviceName,
    IN WCHAR *ClientDeviceName
    );

//  Delete the named printer.  This function does not remove the printer
//  from the comprehensive device management list. 
BOOL UMRDPPRN_DeleteNamedPrinterQueue(
    IN PWSTR printerName
    );
#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _UMRDPPRN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\umrdpprn.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name :

    umrdpprn.c

Abstract:

    User-Mode Component for RDP Device Management that Handles Printing Device-
    Specific tasks.

    This is a supporting module.  The main module is umrdpdr.c.

Author:

    TadB

Revision History:
--*/

#include "precomp.h"
#pragma hdrstop

#include <winspool.h>
#include <rdpdr.h>
#include <aclapi.h>
#include "setupapi.h"
#include "printui.h"
#include "drdevlst.h"
#include "umrdpdr.h"
#include "umrdpprn.h"
#include "drdbg.h"
#include "rdpprutl.h"
#include "tsnutl.h"
#include "rdpdr.h"

#include "errorlog.h"
#include <wlnotify.h>
#include <time.h>

////////////////////////////////////////////////////////
//
//      Defines
//

#ifndef BOOL
#define BOOL int
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))
#endif

#define PRINTUILIBNAME  TEXT("printui.dll")

//
//  Printui Printer Configuration Save/Restore Flags.
//

//  This one should be called as user for fetching the configuration data.
#define CMDLINE_FOR_STORING_CONFIGINFO_IMPERSONATE L"/q /Ss /n \"%ws\" /a \"%ws\" 2 7 c d u g"

//  This one should be called first as system for restoring configuration data.
#define CMDLINE_FOR_RESTORING_CONFIGINFO_NOIMPERSONATE L"/q /Sr /n \"%ws\" /a \"%ws\" 2 7 c d g r p h i" 
//  This one should be called second as user for restoring configuration data.
#define CMDLINE_FOR_RESTORING_CONFIGINFO_IMPERSONATE L"/q /Sr /n \"%ws\" /a \"%ws\" u r"


#define TEMP_FILE_PREFIX L"prn"

#define INF_PATH   L"\\inf\\ntprint.inf"

//
//  Reg key for configurable parms.
//
#define CONFIGREGKEY     \
    L"SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\Wds\\rdpwd"

//
//  Location of configurable threshold for delta between printer installation
//  time and forwarding of first user-initiated configuration change data
//  to the client.  The units for this value is in seconds.
//
#define CONFIGTHRESHOLDREGVALUE   \
    L"PrintRdrConfigThreshold"

//
//  Default Value for Configurable Printer Configuration Threshold
//
#define CONFIGTHRESHOLDDEFAULT  20

//
//  Registry key for storing default, per-user, printer names.
//
#define USERDEFAULTPRNREGKEY \
    L"SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\Wds\\rdpwd\\DefaultPrinterStore"

#define TSSERIALDEVICEMAP  \
    L"HARDWARE\\DEVICEMAP\\SERIALCOMM"
    
//
//  Registry location of configurable client driver name mapping INF and INF
//  section.
//
#define CONFIGUSERDEFINEDMAPPINGINFNAMEVALUE\
    L"PrinterMappingINFName"
#define CONFIGUSERDEFINEDMAPPINGINFSECTIONVALUE\
    L"PrinterMappingINFSection"

//
//  Location of Windows Directory Path
//
#define WINDOWSDIRKEY       L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"
#define WINDOWSDIRVALUENAME L"PathName"

//  Get a numeric representation of our session ID.
#if defined(UNITTEST)
#define GETTHESESSIONID()   0
#else
extern ULONG g_SessionId;
#define GETTHESESSIONID()   g_SessionId
#endif

#if defined(UNITTEST)
HINSTANCE g_hInstance;
#else
extern HINSTANCE g_hInstance;
#endif

extern BOOL fRunningOnPTS;

//  Return true if the device type represents a serial or parallel port.
#define ISPRINTPORT(type)   (((type) == RDPDR_DTYP_SERIAL) || \
                            ((type) == RDPDR_DTYP_PARALLEL) || \
                            ((type) == RDPDR_DRYP_PRINTPORT))

//  Maximum number of characters in a session ID (Max chars in a dword is 17)
#define MAXSESSIONIDCHARS   17

//  The field types we are waiting on (Printer Config change Notification)
#define IS_CONFIG_INFO_FIELD(field) \
    (field == PRINTER_NOTIFY_FIELD_SHARE_NAME) || \
    (field == PRINTER_NOTIFY_FIELD_DEVMODE) || \
    (field == PRINTER_NOTIFY_FIELD_COMMENT) || \
    (field == PRINTER_NOTIFY_FIELD_LOCATION) || \
    (field == PRINTER_NOTIFY_FIELD_SEPFILE) || \
    (field == PRINTER_NOTIFY_FIELD_PRINT_PROCESSOR) || \
    (field == PRINTER_NOTIFY_FIELD_PARAMETERS) || \
    (field == PRINTER_NOTIFY_FIELD_DATATYPE) || \
    (field == PRINTER_NOTIFY_FIELD_ATTRIBUTES) || \
    (field == PRINTER_NOTIFY_FIELD_PRIORITY) || \
    (field == PRINTER_NOTIFY_FIELD_DEFAULT_PRIORITY) || \
    (field == PRINTER_NOTIFY_FIELD_START_TIME) || \
    (field == PRINTER_NOTIFY_FIELD_UNTIL_TIME) || \
    (field == PRINTER_NOTIFY_FIELD_STATUS)

#define CONFIG_WAIT_PERIOD (30 * 1000)

#define INFINITE_WAIT_PERIOD (0xDFFFFFFF) //just a large number.Ok for 64-bit also.

#define DEVICE_MAP_NAME          L"\\??\\"
#define DEVICE_MAP_NAME_COUNT    4     // 4 chars - \??\




////////////////////////////////////////////////////////////////////////
//
//  Typedefs
//
typedef struct tagPRINTNOTIFYREC
{
    HANDLE  notificationObject;         // Notification object registered
                                        //  FindFirstPrinterChangeNotification.
    HANDLE  printerHandle;              // Open handle to the printer.
    DWORD   serverDeviceID;             // Server-side printer identifier.
} PRINTNOTIFYREC, *PPRINTNOTIFYREC;


////////////////////////////////////////////////////////////////////////
//
//  External Prototypes
//
#if DBG
extern void DbgMsg(CHAR *msgFormat, ...);
#endif


////////////////////////////////////////////////////////////////////////
//
//  Local Prototypes
//

WCHAR *ANSIToUnicode(
    IN LPCSTR   ansiString,
    IN UINT     codePage
    );
BOOL InstallPrinterWithPortName(
    IN DWORD  deviceID,
    IN HANDLE hTokenForLoggedOnUser,
    IN BOOL   bSetDefault,
    IN ULONG  ulFlags,
    IN PCWSTR portName,
    IN PCWSTR driverName,
    IN PCWSTR printerName,
    IN PCWSTR clientComputerName,
    IN PBYTE  cacheData,
    IN DWORD  cacheDataLen
    );
BOOL HandlePrinterNameChangeNotification(
    IN DWORD serverDeviceID,
    IN LPWSTR printerName
    );
BOOL SendAddPrinterMsgToClient(
    IN PCWSTR   printerName,
    IN PCWSTR   driverName,
    IN PCSTR    dosDevicePort
    );
BOOL SendDeletePrinterMsgToClient(
    IN PCWSTR   printerName
    );
BOOL HandlePrinterDeleteNotification(
    IN DWORD serverDeviceID
    );
void HandlePrinterRefreshNotification(
    IN PPRINTER_NOTIFY_INFO notifyInfo
    );

DWORD AddSessionIDToPrinterQueue(
    IN  HANDLE  hPrinter,
    IN  DWORD   sessionID
    );

BOOL SetDefaultPrinterToFirstFound(
    BOOL impersonate
    );

DWORD GetPrinterConfigInfo(
    LPCWSTR printerName,
    LPBYTE * ppBuffer,
    LPDWORD pdwBufSize
    );
DWORD SetPrinterConfigInfo(
    LPCWSTR printerName,
    LPVOID lpBuffer,
    DWORD dwBufSize
    );

BOOL HandlePrinterConfigChangeNotification(
    IN DWORD serverDeviceID
    );
BOOL SendPrinterConfigInfoToClient(
    IN PCWSTR printerName,
    IN LPBYTE pConfigInfo,
    IN DWORD  ConfigInfoSize
    );

DWORD CallPrintUiPersistFunc(
    LPCWSTR printerName,
    LPCWSTR fileName,
    LPCWSTR formatString
    );
BOOL
SendPrinterRenameToClient(
    IN PCWSTR oldprinterName,
    IN PCWSTR newprinterName
    );
VOID LoadConfigurableValues();
BOOL GetPrinterPortName(
    IN  HANDLE hPrinter,
    OUT PWSTR *portName
    );

BOOL MapClientPrintDriverName(
    IN  PCWSTR clientDriver,
    IN OUT PWSTR *mappedName,
    IN OUT DWORD *mappedNameBufSize
    );

DWORD PrinterDriverInstalled(
    IN PCWSTR clientDriver
    );

HANDLE RegisterForPrinterPrefNotify();

PACL GiveLoggedOnUserFullPrinterAccess(
    IN LPTSTR printerName,
    IN HANDLE hToken,
    PSECURITY_DESCRIPTOR *ppsd
);

DWORD SetPrinterDACL(
    IN LPTSTR printerName,
    IN PACL pDacl
);

VOID CloseWaitablePrintingObjects();

VOID GlobalPrintNotifyObjectSignaled(
    IN HANDLE waitableObject,
    IN PVOID clientData
    );
VOID PrintPreferenceChangeEventSignaled(
    HANDLE eventHandle,
    PVOID clientData
    );
void WaitableTimerSignaled(
    HANDLE waitableObject,
    PVOID clientData
    );
BOOL
RegisterPrinterConfigChangeNotification(
    IN DWORD serverDeviceID
    );
BOOL RestoreDefaultPrinterContext();
BOOL SaveDefaultPrinterContext(PCWSTR currentlyInstallingPrinterName);
BOOL SavePrinterNameAsGlobalDefault(
    IN PCWSTR printerName
    );

// Struct used to split a full printer name.
// Once filled, each psz points to a substring in the buffer
// or to one of the original names. Nothing allocated.
typedef struct _TS_PRINTER_NAMES {
    WCHAR   szTemp[MAX_PATH+1];
    ULONG   ulTempLen;
    PCWSTR  pszFullName;
    PCWSTR  pszCurrentClient;
    PCWSTR  pszServer;
    PCWSTR  pszClient;
    PCWSTR  pszPrinter;
} TS_PRINTER_NAMES, *PTS_PRINTER_NAMES;

void FormatPrinterName(
    PWSTR pszNewNameBuf,
    ULONG ulBufLen,
    ULONG ulFlags,
    PTS_PRINTER_NAMES pPrinterNames);

DWORD AddNamesToPrinterQueue(
    IN  HANDLE  hPrinter,
    IN  PTS_PRINTER_NAMES pPrinterNames
    );

VOID TriggerConfigChangeTimer();

#ifdef UNITTEST
void TellDrToAddTestPrinter();
void SimpleUnitTest();
#endif


////////////////////////////////////////////////////////
//
//      Globals
//

//
//  Set to TRUE when the DLL is trying to shut down.
//
extern BOOL ShutdownFlag;


////////////////////////////////////////////////////////
//
//      Globals to this Module
//

//  True if this module has been successfully initialized.
BOOL PrintingModuleInitialized = FALSE;

//  Comprehensive Device List
PDRDEVLST DeviceList;

//  Handle to the print system dev mode for this user.  This is the key
//  that is modified when a user changes a printer's printing preferences.
HKEY DevModeHKey = INVALID_HANDLE_VALUE;

//  Configurable threshold for delta between printer installation
//  time and forwarding of first user-initiated configuration change data
//  to the client.  The units for this value is in seconds.
DWORD ConfigSendThreshold;

//
//  Printer Change Notification Events
//
HANDLE   PrintNotificationEvent             = INVALID_HANDLE_VALUE;
HANDLE   PrintPreferenceChangeEvent         = NULL;

HANDLE   PrintUILibHndl                     = NULL;
FARPROC  PrintUIEntryFunc                   = NULL;
FARPROC  PnpInterfaceFunc                   = NULL;
HANDLE   UMRPDPPRN_TokenForLoggedOnUser     = INVALID_HANDLE_VALUE;
HANDLE   LocalPrinterServerHandle           = NULL;
WCHAR    PrinterInfPath[MAX_PATH + (sizeof(INF_PATH)/sizeof(WCHAR)) + 2]   = L"";   // of the form "%windir%\\inf\\ntprint.inf"
LPPRINTER_INFO_2  PrinterInfo2Buf           = NULL;
DWORD    PrinterInfo2BufSize                = 0;
//WCHAR    SessionString[MAX_PATH+1];
WCHAR    g_szFromFormat[MAX_PATH+1];
WCHAR    g_szOnFromFormat[MAX_PATH+1];

BOOL g_fIsPTS = FALSE;

BOOL g_fTimerSet = FALSE;
HANDLE WaitableTimer = NULL;

BOOL g_fDefPrinterEncountered = FALSE;

//  Global debug flag.
extern DWORD GLOBAL_DEBUG_FLAGS;

//  Printer Notify Parameters
WORD PrinterFieldType[] =
{
    PRINTER_NOTIFY_FIELD_SHARE_NAME,
    PRINTER_NOTIFY_FIELD_PRINTER_NAME,
    PRINTER_NOTIFY_FIELD_COMMENT,
    PRINTER_NOTIFY_FIELD_LOCATION,
    PRINTER_NOTIFY_FIELD_DEVMODE,
    PRINTER_NOTIFY_FIELD_SEPFILE,
    PRINTER_NOTIFY_FIELD_PRINT_PROCESSOR,
    PRINTER_NOTIFY_FIELD_PARAMETERS,
    PRINTER_NOTIFY_FIELD_DATATYPE,
    PRINTER_NOTIFY_FIELD_ATTRIBUTES,
    PRINTER_NOTIFY_FIELD_PRIORITY,
    PRINTER_NOTIFY_FIELD_DEFAULT_PRIORITY,
    PRINTER_NOTIFY_FIELD_START_TIME,
    PRINTER_NOTIFY_FIELD_UNTIL_TIME,
    PRINTER_NOTIFY_FIELD_STATUS
};

PRINTER_NOTIFY_OPTIONS_TYPE PrinterNotifyOptionsType[] =
{
    {
        PRINTER_NOTIFY_TYPE,
        0,
        0,
        0,
        sizeof(PrinterFieldType) / sizeof(WORD),
        PrinterFieldType
    }
};
PRINTER_NOTIFY_OPTIONS PrinterNotifyOptions =
{
    2,
    0,
    sizeof(PrinterNotifyOptionsType) / sizeof(PRINTER_NOTIFY_OPTIONS_TYPE),
    PrinterNotifyOptionsType
};

//
//  User-Configurable Client Driver Mapping INF Name and INF Section.
//
LPWSTR UserDefinedMappingINFName = NULL;
LPWSTR UserDefinedMappingINFSection = NULL;

//
//  Buffer for converting from Win9x driver names to Win2K driver names.
//
PWSTR   MappedDriverNameBuf = NULL;
DWORD   MappedDriverNameBufSize = 0;

//
//  Waitable Object Manager
//
WTBLOBJMGR UMRDPPRN_WaitableObjMgr = NULL;

//
//  Default Printer Name
//
WCHAR SavedDefaultPrinterName[MAX_PATH+1] = L"";

//
// Printer section names
//

static WCHAR* prgwszPrinterSectionNames[] = {
            L"Printer Driver Mapping_Windows NT x86_Version 2",
            L"Printer Driver Mapping_Windows NT x86_Version 3",
            NULL
};


BOOL IsItPTS()
{
    OSVERSIONINFOEX gOsVersion;
    ZeroMemory(&gOsVersion, sizeof(OSVERSIONINFOEX));
    gOsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    GetVersionEx( (LPOSVERSIONINFO ) &gOsVersion);

    return (gOsVersion.wProductType == VER_NT_WORKSTATION)  // product type must be workstation.
                && !(gOsVersion.wSuiteMask & VER_SUITE_PERSONAL) // and product suite must not be personal.
                    && (gOsVersion.wSuiteMask & VER_SUITE_SINGLEUSERTS); // it must be single user ts.
}


BOOL UMRDPPRN_Initialize(
    IN PDRDEVLST deviceList,
    IN WTBLOBJMGR waitableObjMgr,
    IN HANDLE hTokenForLoggedOnUser
    )
/*++

Routine Description:

    Initialize this module.  This must be called prior to any other functions
    in this module being called.

Arguments:

    deviceList              - Comprehensive list of redirected devices.
    waitableObjMgr          - Waitable object manager.
    hTokenForLoggedOnUser   - This is the token for the logged in user.

Return Value:

    Returns TRUE on success.  FALSE, otherwise.

--*/
{
    HKEY regKey;
    LONG sz;
    DWORD errorEventID = -1;
    DWORD errorEventLineNumber = 0;

    BOOL result, impersonated = FALSE;

    DBGMSG(DBG_TRACE, ("UMRDPPRN:UMRDPPRN_Initialize.\n"));

    //
    //  Make sure we don't get called twice without getting cleaned up.
    //
    ASSERT((PrintNotificationEvent == INVALID_HANDLE_VALUE) &&
           (PrintPreferenceChangeEvent == NULL) &&
           (PrintUILibHndl == NULL) &&
           (PrintUIEntryFunc == NULL) &&
           (PnpInterfaceFunc == NULL) &&
           (UMRPDPPRN_TokenForLoggedOnUser == INVALID_HANDLE_VALUE) &&
           (PrinterInfo2Buf == NULL) &&
           (PrinterInfo2BufSize == 0) &&
           (UMRDPPRN_WaitableObjMgr == NULL) &&
           (WaitableTimer == NULL) &&
           (DeviceList == NULL) &&
           !PrintingModuleInitialized);

    //
    // Is it PTS?
    //
    g_fIsPTS = IsItPTS();

    //
    //  Zero the default printer name record.
    //
    wcscpy(SavedDefaultPrinterName, L"");

    //
    //  Record the device list.
    //
    DeviceList = deviceList;

    //
    //  Record the waitable object mananager.
    //
    UMRDPPRN_WaitableObjMgr = waitableObjMgr;

    //
    //  Record the token for the logged in user.
    //
    UMRPDPPRN_TokenForLoggedOnUser = hTokenForLoggedOnUser;

    ASSERT(UMRPDPPRN_TokenForLoggedOnUser != NULL);
    
    if (UMRPDPPRN_TokenForLoggedOnUser != NULL) {
        impersonated = ImpersonateLoggedOnUser(UMRPDPPRN_TokenForLoggedOnUser);
        //
        // not fatal. Just a perf hit
        //
        if (!impersonated) {
            DBGMSG(DBG_ERROR,
             ("UMRDPPRN:Impersonation failed. Error: %ld\n", GetLastError()));
        }
            
    }
    //
    //  Open the local print server while impersonating.
    //  We need to impersonate so that notifications for 
    //  the printers belonging to the current user's sessions 
    //  are not sent to any other sessions.
    //

    result = OpenPrinter(NULL, &LocalPrinterServerHandle, NULL);

    if (impersonated) {
        RevertToSelf();
    }

    //
    //  Initialize the print utility module, RDPDRPRT
    //
    if (result) {
        result = RDPDRUTL_Initialize(hTokenForLoggedOnUser);
        if (!result) {
            errorEventID = EVENT_NOTIFY_INSUFFICIENTRESOURCES;
            errorEventLineNumber = __LINE__;
        }
    }
    else {
        errorEventID = EVENT_NOTIFY_SPOOLERERROR;
        errorEventLineNumber = __LINE__;
        DBGMSG(DBG_ERROR,
            ("UMRDPPRN:Error opening printer. Error: %ld\n",
            GetLastError()));
    }

    //
    //  Load configurable values out of the registry.
    //
    LoadConfigurableValues();

    //
    //  Create the timer even that we use for staggering printer
    //  configuration changes to the client.
    //
    if (result) {
        WaitableTimer = CreateWaitableTimer(
                            NULL,       // Security Attribs
                            TRUE,      // Manual Reset
                            NULL);      // Timer Name
        if (WaitableTimer != NULL) {
            if (WTBLOBJ_AddWaitableObject(
                                UMRDPPRN_WaitableObjMgr, NULL,
                                WaitableTimer,
                                WaitableTimerSignaled
                                ) != ERROR_SUCCESS) {
                errorEventID = EVENT_NOTIFY_INSUFFICIENTRESOURCES;
                errorEventLineNumber = __LINE__;
                result = FALSE;
            }

        }
        else {
            errorEventID = EVENT_NOTIFY_INSUFFICIENTRESOURCES;
            errorEventLineNumber = __LINE__;
            DBGMSG(DBG_ERROR,
                ("UMRDPPRN:Error creating Waitable timer. Error: %ld\n",
                GetLastError()));
            result = FALSE;
        }
    }

    //
    //  Register for changes to one of this session's printers' Printing
    //  Preferences.
    //
    if (result) {
        PrintPreferenceChangeEvent = RegisterForPrinterPrefNotify();
        if (PrintPreferenceChangeEvent != NULL) {
            if (WTBLOBJ_AddWaitableObject(
                                UMRDPPRN_WaitableObjMgr, NULL,
                                PrintPreferenceChangeEvent,
                                PrintPreferenceChangeEventSignaled
                                ) != ERROR_SUCCESS) {
                errorEventID = EVENT_NOTIFY_INSUFFICIENTRESOURCES;
                errorEventLineNumber = __LINE__;
                result = FALSE;
            }
        }
        else {
            result = FALSE;
        }
    }

    //
    //  Register for change notification on addition/deletion of a
    //  printer.
    //
    if (result) {
        PrintNotificationEvent = FindFirstPrinterChangeNotification(
                                                    LocalPrinterServerHandle,
                                                    0, 0, &PrinterNotifyOptions
                                                    );
        if (PrintNotificationEvent != INVALID_HANDLE_VALUE) {
            DWORD dwLastError = WTBLOBJ_AddWaitableObject(
                                UMRDPPRN_WaitableObjMgr, NULL,
                                PrintNotificationEvent,
                                GlobalPrintNotifyObjectSignaled
                                );
            result = dwLastError == ERROR_SUCCESS;
        }
        else {
            DWORD dwLastError = GetLastError();

            errorEventID = EVENT_NOTIFY_SPOOLERERROR;
            errorEventLineNumber = __LINE__;

            ClosePrinter(LocalPrinterServerHandle);
            LocalPrinterServerHandle = NULL;
            DBGMSG(DBG_ERROR,
                ("UMRDPPRN:Error registering for printer change notification. Error: %ld\n",
                dwLastError));
        }
    }

    //
    //  Construct the inf path for printer installation
    //
    if (result) {
        DWORD dwResult;
        dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINDOWSDIRKEY, 0,
                              KEY_READ, &regKey);
        result = (dwResult == ERROR_SUCCESS);
        if (result)  {
            sz = sizeof(PrinterInfPath);
            dwResult = RegQueryValueEx(regKey,
                                    WINDOWSDIRVALUENAME,
                                    NULL,
                                    NULL,
                                    (PBYTE)PrinterInfPath,
                                    &sz);

            result = (dwResult == ERROR_SUCCESS);
            if (result) {
                wcscat(PrinterInfPath, INF_PATH);
            }
            else {
                DBGMSG(DBG_ERROR,
                    ("UMRDPPRN:Error reading registry value for windows directory. Error: %ld\n",
                    dwResult));
            }
            RegCloseKey(regKey);
        }
        else {
            errorEventID = EVENT_NOTIFY_INTERNALERROR;
            errorEventLineNumber = __LINE__;
            DBGMSG(DBG_ERROR,
                ("UMRDPPRN:Error opening registry key for windows directory. Error: %ld\n",
                dwResult));
        }
    }

    //
    //  Load the PrintUILib DLL.
    //
    if (result) {
        PrintUILibHndl = LoadLibrary(PRINTUILIBNAME);

        result = (PrintUILibHndl != NULL);
        if (!result) {
            errorEventID = EVENT_NOTIFY_INTERNALERROR;
            errorEventLineNumber = __LINE__;
            DBGMSG(DBG_ERROR,
                ("UMRDPPRN:Unable to load PRINTUI DLL. Error: %ld\n",
                GetLastError()));
        }
    }

    //
    //  Get a pointer to the only entry point that we use.
    //
    if (result) {
        PrintUIEntryFunc = GetProcAddress(PrintUILibHndl, "PrintUIEntryW");
        PnpInterfaceFunc = GetProcAddress(PrintUILibHndl, "PnPInterface");
        result = (PrintUIEntryFunc != NULL && PnpInterfaceFunc != NULL);
        if (!result) {
            errorEventID = EVENT_NOTIFY_INTERNALERROR;
            errorEventLineNumber = __LINE__;
            DBGMSG(DBG_ERROR,
                ("UMRDPPRN:Unable to locate PRINTUI DLL function. Error: %ld\n",
                GetLastError()));
        }
    }

    //
    //  Initialize the printer driver name mapping buffer to a reasonable size.
    //  Failure of this function to allocate memory is not a critical error because
    //  we can try again later, if necessary.
    //
    UMRDPDR_ResizeBuffer(&MappedDriverNameBuf, MAX_PATH * sizeof(WCHAR),
                        &MappedDriverNameBufSize);

    //
    //  Load our localizable "session" printer name component from the resource file.
    //
    if (result) {
        if (!LoadString(g_hInstance,
            g_fIsPTS?IDS_TSPTEMPLATE_FROM:IDS_TSPTEMPLATE_FROM_IN,
            g_szFromFormat,
            sizeof(g_szFromFormat) / sizeof(g_szFromFormat[0])
            )) {
            DBGMSG(DBG_ERROR, ("UMRDPPRN:LoadString failed with Error: %ld.\n", GetLastError()));
            g_szFromFormat[0] = L'\0';
        }

        if (!LoadString(g_hInstance,
            g_fIsPTS?IDS_TSPTEMPLATE_ON_FROM:IDS_TSPTEMPLATE_ON_FROM_IN,
            g_szOnFromFormat,
            sizeof(g_szOnFromFormat) / sizeof(g_szOnFromFormat[0])
            )) {
            DBGMSG(DBG_ERROR, ("UMRDPPRN:LoadString failed with Error: %ld.\n", GetLastError()));
            g_szOnFromFormat[0] = L'\0';
        }
    }

    if (result) {
        DBGMSG(DBG_INFO, ("UMRDPPRN:UMRDPPRN_Initialize succeeded.\n"));
        PrintingModuleInitialized = TRUE;
    }
    else {

        //
        //  Log an error event if we were able to discern one.
        //
        if (errorEventID != -1) {
            TsLogError(errorEventID, EVENTLOG_ERROR_TYPE, 0, NULL, errorEventLineNumber);
        }

        if (PrintUILibHndl != NULL) {
            FreeLibrary(PrintUILibHndl);
            PrintUILibHndl = NULL;
        }
        PrintUIEntryFunc = NULL;
        PnpInterfaceFunc = NULL;

        //
        //  Close down waitable objects.
        //
        CloseWaitablePrintingObjects();

        //
        //  Zero the waitable object manager.
        //
        UMRDPPRN_WaitableObjMgr = NULL;

        if (LocalPrinterServerHandle != NULL) {
            ClosePrinter(LocalPrinterServerHandle);
            LocalPrinterServerHandle = NULL;
        }

        //
        //  Release the user-configurable client driver name mapping INF
        //  and section names.
        //
        if (UserDefinedMappingINFName != NULL) {
            FREEMEM(UserDefinedMappingINFName);
            UserDefinedMappingINFName = NULL;
        }
        if (UserDefinedMappingINFSection != NULL) {
            FREEMEM(UserDefinedMappingINFSection);
            UserDefinedMappingINFSection = NULL;
        }
    }
    return result;
}

BOOL
UMRDPPRN_Shutdown()
/*++

Routine Description:

    Close down this module.  Right now, we just need to shut down the
    background thread.

Arguments:

    NA

Return Value:

    Returns TRUE on success.  FALSE, otherwise.

--*/
{
    DBGMSG(DBG_TRACE, ("UMRDPPRN:UMRDPPRN_Shutdown.\n"));

    //
    // Check if we are already shutdown
    //
    if (!PrintingModuleInitialized) {
        return TRUE;
    }

    //
    //  Unload printui.dll.
    //
    if (PrintUILibHndl != NULL) {
        FreeLibrary(PrintUILibHndl);
        PrintUILibHndl = NULL;
    }

    //
    //  Zero the printui entry point function.
    //
    PrintUIEntryFunc = NULL;
    PnpInterfaceFunc = NULL;

    //
    //  Shut down the print utility module, RDPDRPRT
    //
    RDPDRUTL_Shutdown();

    //
    //  Close down waitable objects.
    //
    CloseWaitablePrintingObjects();

    //
    //  Zero the waitable object manager.
    //
    UMRDPPRN_WaitableObjMgr = NULL;

    //
    //  Zero the device list.
    //
    DeviceList = NULL;

    //
    //  Close the handle to the open printing system dev mode registry
    //  key for this user.
    //
    if (DevModeHKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(DevModeHKey);
        DevModeHKey = INVALID_HANDLE_VALUE;
    }

    //
    //  Close the handle to the local print server.
    //
    if (LocalPrinterServerHandle != NULL) {
        ClosePrinter(LocalPrinterServerHandle);
        LocalPrinterServerHandle = NULL;
    }

    //
    //  Release the printer information level 2 buffer.
    //
    if (PrinterInfo2Buf != NULL) {
        FREEMEM(PrinterInfo2Buf);
        PrinterInfo2Buf = NULL;
        PrinterInfo2BufSize = 0;
    }

    //
    //  Release the printer driver name conversion buffer.
    //
    if (MappedDriverNameBuf != NULL) {
        FREEMEM(MappedDriverNameBuf);
        MappedDriverNameBuf = NULL;
        MappedDriverNameBufSize = 0;
    }

    //
    //  Release the user-configurable client driver name mapping INF
    //  and section names.
    //
    if (UserDefinedMappingINFName != NULL) {
        FREEMEM(UserDefinedMappingINFName);
        UserDefinedMappingINFName = NULL;
    }
    if (UserDefinedMappingINFSection != NULL) {
        FREEMEM(UserDefinedMappingINFSection);
        UserDefinedMappingINFSection = NULL;
    }

    //
    //  Zero the logged on user token.
    //
    UMRPDPPRN_TokenForLoggedOnUser = INVALID_HANDLE_VALUE;

    //
    //  We are no longer initialized.
    //
    PrintingModuleInitialized = FALSE;

    DBGMSG(DBG_TRACE, ("UMRDPPRN:UMRDPPRN_Shutdown succeeded.\n"));
    return TRUE;
}

VOID
CloseWaitablePrintingObjects()
/*++

Routine Description:

    Close out all waitable objects for this module.

Arguments:

    NA

Return Value:

    NA

--*/
{
    DWORD ofs;

    DBGMSG(DBG_TRACE, ("UMRDPPRN:CloseWaitablePrintingObjects begin.\n"));

    //
    //  Scan the device list, looking for printing devices with registered
    //  change notifications.
    //
    if (DeviceList != NULL) {
        for (ofs=0; ofs<DeviceList->deviceCount; ofs++) {

            if ((DeviceList->devices[ofs].deviceType == RDPDR_DTYP_PRINT) &&
                (DeviceList->devices[ofs].deviceSpecificData != NULL)) {

                PPRINTNOTIFYREC notifyRec = (PPRINTNOTIFYREC)
                                            DeviceList->devices[ofs].deviceSpecificData;
                ASSERT(notifyRec->notificationObject != NULL);
                ASSERT(notifyRec->printerHandle != NULL);

                if (UMRDPPRN_WaitableObjMgr != NULL) {
                    WTBLOBJ_RemoveWaitableObject(
                                UMRDPPRN_WaitableObjMgr,
                                notifyRec->notificationObject
                                );
                }

                FindClosePrinterChangeNotification(
                    notifyRec->notificationObject
                    );
                FREEMEM(notifyRec);
                DeviceList->devices[ofs].deviceSpecificData = NULL;
            }

        }
    }

    //
    //  Close the waitable timer.
    //
    if (WaitableTimer != NULL) {
        if (UMRDPPRN_WaitableObjMgr != NULL) {
            WTBLOBJ_RemoveWaitableObject(
                    UMRDPPRN_WaitableObjMgr,
                    WaitableTimer
                    );
        }
        CloseHandle(WaitableTimer);
        WaitableTimer = NULL;
    }

    //
    //  Close the handle to the printer notification event.
    //
    if (PrintNotificationEvent != INVALID_HANDLE_VALUE) {
        if (UMRDPPRN_WaitableObjMgr != NULL) {
            WTBLOBJ_RemoveWaitableObject(
                    UMRDPPRN_WaitableObjMgr,
                    PrintNotificationEvent
                    );
        }
        FindClosePrinterChangeNotification(PrintNotificationEvent);
        PrintNotificationEvent = INVALID_HANDLE_VALUE;
    }

    //
    //  Close the handle to the printer preference change notification event.
    //
    if (PrintPreferenceChangeEvent != NULL) {
        if (UMRDPPRN_WaitableObjMgr != NULL) {
            WTBLOBJ_RemoveWaitableObject(
                    UMRDPPRN_WaitableObjMgr,
                    PrintPreferenceChangeEvent
                    );
        }
        CloseHandle(PrintPreferenceChangeEvent);
        PrintPreferenceChangeEvent = NULL;
    }

    DBGMSG(DBG_TRACE, ("UMRDPPRN:CloseWaitablePrintingObjects end.\n"));
}

BOOL
UMRDPPRN_HandlePrinterAnnounceEvent(
    IN PRDPDR_PRINTERDEVICE_SUB pPrintAnnounce
    )
/*++

Routine Description:

    Handle a printing device announce event from the "dr" by installing a
    local print queue and adding a record for the device to the list of
    installed devices.

Arguments:

    hTokenForLoggedOnUser - Logged on user token.
    pPrintAnnounce -  Printer device announce event.

Return Value:

    Return TRUE on success.  FALSE, otherwise.

--*/
{
    PWSTR driverName;
    PWSTR printerName;
    PBYTE pDataFollowingEvent;
    UINT codePage;
    int numChars;
    PWSTR drvNameStringConvertBuf=NULL;
    PWSTR prnNameStringConvertBuf=NULL;
    BOOL result = FALSE;
    PBYTE pPrinterCacheData=NULL;
    DWORD PrinterCacheDataLen=0;
    BOOL bSetDefault = FALSE;

#if DBG
    HANDLE hPrinter = NULL;
    PRINTER_DEFAULTS defaults = {NULL, NULL, PRINTER_ALL_ACCESS};
#endif

    if (!PrintingModuleInitialized) {
        return FALSE;
    }

    DBGMSG(DBG_TRACE, ("UMRDPPRN:HandlePrinterAnnounceEvent.\n"));

    // Sanity check the incoming event.
    ASSERT(pPrintAnnounce->deviceFields.DeviceType == RDPDR_DTYP_PRINT);
    ASSERT(pPrintAnnounce->deviceFields.DeviceDataLength >=
           sizeof(PRDPDR_PRINTERDEVICE_ANNOUNCE));

    // Get a pointer to the data that follows the event.
    pDataFollowingEvent = ((PBYTE)pPrintAnnounce) +
                        sizeof(RDPDR_PRINTERDEVICE_SUB);

    // The driver name is the second field.
    driverName = (PWSTR)(pDataFollowingEvent +
                          pPrintAnnounce->clientPrinterFields.PnPNameLen
                          );

    // The printer name is the third field.
    printerName = (PWSTR)(pDataFollowingEvent +
                          pPrintAnnounce->clientPrinterFields.PnPNameLen +
                          pPrintAnnounce->clientPrinterFields.DriverLen
                          );
    // NULL-terminate the names.
    // Length (in bytes) from client includes the null.
    // So, we need to subtract 1 and then NULL-terminate.
    if (pPrintAnnounce->clientPrinterFields.DriverLen > 0) {
        driverName[pPrintAnnounce->clientPrinterFields.DriverLen/sizeof(WCHAR) - 1] = L'\0';
    }

    if (pPrintAnnounce->clientPrinterFields.PrinterNameLen > 0) {
        printerName[pPrintAnnounce->clientPrinterFields.PrinterNameLen/sizeof(WCHAR) - 1] = L'\0';
    }

    // Cache data is the last field
    if (pPrintAnnounce->clientPrinterFields.CachedFieldsLen > 0) {
        PrinterCacheDataLen = pPrintAnnounce->clientPrinterFields.CachedFieldsLen;
        pPrinterCacheData = (PBYTE)(pDataFollowingEvent +
                                  pPrintAnnounce->clientPrinterFields.PnPNameLen +
                                  pPrintAnnounce->clientPrinterFields.DriverLen +
                                  pPrintAnnounce->clientPrinterFields.PrinterNameLen
                                  );
        DBGMSG(DBG_TRACE, ("PrinterNameLen - %ld\n", pPrintAnnounce->clientPrinterFields.PrinterNameLen));
    }

    //
    //  See if we need to convert the name from ANSI to UNICODE.
    //
    if (pPrintAnnounce->clientPrinterFields.Flags & RDPDR_PRINTER_ANNOUNCE_FLAG_ANSI) {

        DBGMSG(DBG_TRACE, ("UMRDPPRN:HandlePrinterAnnounceEvent ansi flag is set.\n"));
        DBGMSG(DBG_TRACE, ("UMRDPPRN:HandlePrinterAnnounceEvent converting to unicode.\n"));

        //
        //  Convert the driver name.
        //
        drvNameStringConvertBuf = ANSIToUnicode(
                                    (LPCSTR)driverName,
                                    pPrintAnnounce->clientPrinterFields.CodePage
                                    );
        if (drvNameStringConvertBuf != NULL) {
            driverName = drvNameStringConvertBuf;
        }
        else {
            return FALSE;
        }

        //
        //  Convert the printer name.
        //
        prnNameStringConvertBuf = ANSIToUnicode(
                                    (LPCSTR)printerName,
                                    pPrintAnnounce->clientPrinterFields.CodePage
                                    );
        if (prnNameStringConvertBuf != NULL) {
            printerName = prnNameStringConvertBuf;
        }
        else {
            FREEMEM(drvNameStringConvertBuf);
            return FALSE;
        }
    }

    if (pPrintAnnounce->clientPrinterFields.Flags &
                        RDPDR_PRINTER_ANNOUNCE_FLAG_DEFAULTPRINTER) {
        bSetDefault = TRUE;
        g_fDefPrinterEncountered = TRUE;
    }
    else {
        bSetDefault = (!g_fDefPrinterEncountered) ? TRUE : FALSE;
    }

    DBGMSG(DBG_TRACE, ("UMRDPPRN:HandlePrinterAnnounceEvent driver name is %ws.\n",
            driverName));
    DBGMSG(DBG_TRACE, ("UMRDPPRN:HandlePrinterAnnounceEvent printer name is %ws.\n",
            printerName));

    // We will install the printer using the driver name only for now.
    // Later, we can take advantage of the rest of the fields.
    if (UMRDPDR_fAutoInstallPrinters()) {

        result =  InstallPrinterWithPortName(
                                    pPrintAnnounce->deviceFields.DeviceId,
                                    UMRPDPPRN_TokenForLoggedOnUser,
                                    bSetDefault,
                                    pPrintAnnounce->clientPrinterFields.Flags,
                                    pPrintAnnounce->portName,
                                    driverName,
                                    printerName,
                                    pPrintAnnounce->clientName,
                                    pPrinterCacheData,
                                    PrinterCacheDataLen
                                    );
    }
    else {
            result = TRUE;
    }


    // Release any buffers allocated for string conversion.
    if (drvNameStringConvertBuf != NULL) {
        FREEMEM(drvNameStringConvertBuf);
    }

    if (prnNameStringConvertBuf != NULL) {
        FREEMEM(prnNameStringConvertBuf);
    }

    return result;
}

void
PrintPreferenceChangeEventSignaled(
    HANDLE eventHandle,
    PVOID clientData
    )
/*++

Routine Description:

    This function handles when the user changes one of this session's printers'
    Printing Preferences settings.

Arguments:

    eventHandle - Signaled event.
    clientData  - Client data associated with callback registration.

Return Value:

    NA

--*/

{
    time_t timeDelta;
    ULONG ofs;
    ULONG ret;

    DBGMSG(DBG_TRACE, ("UMRDPPRN:PrintPreferenceChangeEventSignaled entered.\n"));

    //
    //  Reregister the change notification.
    //
    ASSERT(DevModeHKey != INVALID_HANDLE_VALUE);
    ret = RegNotifyChangeKeyValue(
                          DevModeHKey,
                          TRUE,
                          REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,
                          eventHandle,
                          TRUE
                          );

    //
    //  On failure, remove the notification registration.
    //
    if (ret != ERROR_SUCCESS) {

        //
        //  Catch this with an assert so we can know how often this happens.
        //
        ASSERT(FALSE);

        if (PrintPreferenceChangeEvent != NULL) {
            if (UMRDPPRN_WaitableObjMgr != NULL) {
                WTBLOBJ_RemoveWaitableObject(
                        UMRDPPRN_WaitableObjMgr,
                        PrintPreferenceChangeEvent
                        );
            }
            CloseHandle(PrintPreferenceChangeEvent);
            PrintPreferenceChangeEvent = NULL;
        }

        DBGMSG(DBG_ERROR,
            ("UMRDPPRN: can't register for registry key change event:  %ld.\n",
            ret));
    }

    //
    //  Since we have no way of knowing which printer changed, we need to
    //  handle this change for all printing devices.
    //
    for (ofs=0; ofs<DeviceList->deviceCount; ofs++)  {

        if (DeviceList->devices[ofs].deviceType == RDPDR_DTYP_PRINT) {

            //
            //  Get the delta between the current time and when this device was
            //  installed.  It outside the configurable threshhold, then the
            //  updated configuration should be sent to the client.
            //
            timeDelta = time(NULL) - DeviceList->devices[ofs].installTime;
            if ((DWORD)timeDelta > ConfigSendThreshold) {

                DBGMSG(DBG_TRACE,
                    ("UMRDPPRN:Processing config change because outside time delta.\n")
                    );

                //
                //  Need to record that the configuration has changed and set a
                //  timer on forwarding to the client in order to compress changes into
                //  a single message to the client.
                //
                DeviceList->devices[ofs].fConfigInfoChanged = TRUE;
                TriggerConfigChangeTimer();
            }
        }
    }

    DBGMSG(DBG_TRACE, ("UMRDPPRN:PrintPreferenceChangeEventSignaled done.\n"));
}

void
GlobalPrintNotifyObjectSignaled(
    HANDLE waitableObject,
    PVOID clientData
    )
/*++

Routine Description:

    This function is called when the notification object for the local
    print server is signaled.  This is how we catch "global" changes to
    the server printer configuration.

    Changes detected here allow us to detect manually added TS printers
    as well as a subset of possible configuration changes to existing
    printers for this session.

Arguments:

    waitableObject  -   Associated waitable object.
    clientData      -   Client data associated with callback registration.

Return Value:

    NA

--*/
{
    DWORD changeValue;
    PPRINTER_NOTIFY_INFO notifyInfo=NULL;
    UINT32 i;
    BOOL result;

    DBGMSG(DBG_TRACE, ("UMRDPPRN:GlobalPrintNotifyObjectSignaled entered.\n"));

    //
    //  Return immediately if the DLL is trying to shut down.  This
    //  is to help prevent us from getting stuck in a system call.
    //
    if (ShutdownFlag) {
        return;
    }

    //
    //  These two objects should be on in the same.
    //
    ASSERT(PrintNotificationEvent == waitableObject);

    //
    //  Find out what changed.
    //
    PrinterNotifyOptions.Flags &= ~PRINTER_NOTIFY_OPTIONS_REFRESH;
    result = FindNextPrinterChangeNotification(
            PrintNotificationEvent, &changeValue,
            &PrinterNotifyOptions, &notifyInfo
            );

    if (result && (notifyInfo != NULL)) {

        //
        //  If this is not a refresh, then just handle individual notification
        //  events.
        //
        if (!(notifyInfo->Flags & PRINTER_NOTIFY_INFO_DISCARDED)) {

            for (i=0; i<notifyInfo->Count; i++) {

                // Notification Type must be PRINTER_NOTIFY_TYPE.
                ASSERT(notifyInfo->aData[i].Type == PRINTER_NOTIFY_TYPE);

                //
                //  If we have a printer name change event.  This is what we use to
                //  detect new printers and renamed printers.
                //
                if (notifyInfo->aData[i].Field == PRINTER_NOTIFY_FIELD_PRINTER_NAME) {

                    HandlePrinterNameChangeNotification(
                                            notifyInfo->aData[i].Id,
                                            (LPWSTR)notifyInfo->aData[i].NotifyData.Data.pBuf
                                            );
                }
                //
                // If the Configuration Information changed.
                //
                else if (IS_CONFIG_INFO_FIELD(notifyInfo->aData[i].Field)) {

                    HandlePrinterConfigChangeNotification(
                                            notifyInfo->aData[i].Id
                                            );
                }
            }
        }
        //
        //  Otherwise, we need to refresh.  This is an unusual case.
        //
        else {
            DBGMSG(DBG_TRACE,
                  ("UMRDPPRN:!!!!FindNextPrinterChangeNotification refresh required.!!!!\n"));

            //
            //  This refreshes the complete list of printers.
            //
            FreePrinterNotifyInfo(notifyInfo);
            notifyInfo = NULL;
            PrinterNotifyOptions.Flags |= PRINTER_NOTIFY_OPTIONS_REFRESH;
            result = FindNextPrinterChangeNotification(
                    PrintNotificationEvent, &changeValue,
                    &PrinterNotifyOptions, &notifyInfo
                    );

            //
            //  Make sure our view of the list of available printers
            //  is accurate.
            //
            if (result) {
                HandlePrinterRefreshNotification(
                                            notifyInfo
                                            );
            }
            else {
                DBGMSG(DBG_ERROR, ("UMRDPPRN:FindNextPrinterChangeNotification failed:  %ld.\n",
                        GetLastError()));
            }
        }

    }

    //
    //  On failure, we need to remove the printer change notification object so we don't
    //  get into an infinite loop caused by the notification object never entering a
    //  non-signaled state.  This can happen on a stressed machine and is an unusual
    //  case.
    //
    if (!result) {
        
        DBGMSG(DBG_ERROR, ("UMRDPPRN:FindNextPrinterChangeNotification failed:  %ld.\n",
                GetLastError()));
        DBGMSG(DBG_ERROR, ("UMRDPPRN:Disabling print change notification.\n"));

        if (PrintNotificationEvent != INVALID_HANDLE_VALUE) {
            WTBLOBJ_RemoveWaitableObject(
                    UMRDPPRN_WaitableObjMgr,
                    PrintNotificationEvent
                    );
            FindClosePrinterChangeNotification(PrintNotificationEvent);
            PrintNotificationEvent = INVALID_HANDLE_VALUE;
        }
    }

    //
    //  Release the notification buffer.
    //
    if (notifyInfo != NULL) {
        FreePrinterNotifyInfo(notifyInfo);
    }
}

VOID
SinglePrinterNotifyObjectSignaled(
    HANDLE waitableObject,
    PPRINTNOTIFYREC notifyRec
    )
/*++

Routine Description:

    This function is called when the notification object for a single
    printer is signaled.  This function indicates that we need to forward
    configuration information for a specific printer to the client for
    persistent storage.

Arguments:

    waitableObject  -   Associated waitable object.
    serverDeviceID  -   Device list identifier for printing device being
                        signaled.

Return Value:

    NA

--*/
{
    DWORD ofs;
    BOOL result;
    DWORD changeValue;

    DBGMSG(DBG_TRACE, ("UMRDPPRN:SinglePrinterNotifyObjectSignaled entered.\n"));

    //
    //  Return immediately if the DLL is trying to shut down.  This
    //  is to help prevent us from getting stuck in a system call.
    //
    if (ShutdownFlag) {
        return;
    }

    result = DRDEVLST_FindByServerDeviceID(
                                    DeviceList,
                                    notifyRec->serverDeviceID,
                                    &ofs);
    ASSERT(result);

    //
    //  Re-register the change notification.
    //
    if (result) {

        ASSERT(notifyRec ==
                (PPRINTNOTIFYREC)DeviceList->devices[ofs].deviceSpecificData)
        ASSERT(notifyRec->notificationObject != NULL);
        ASSERT(notifyRec->printerHandle != NULL);
        ASSERT(notifyRec->notificationObject == waitableObject);

        result = FindNextPrinterChangeNotification(
                        notifyRec->notificationObject,
                        &changeValue,
                        NULL, NULL
                        );
    }

    //
    //  If this failed, we need to release the change notification
    //  object to prevent infinitely looping on a signaled object.
    //
    if (!result) {
        //
        //  Catch this with an assert so we can know how often this happens.
        //
        ASSERT(FALSE);

        WTBLOBJ_RemoveWaitableObject(
                            UMRDPPRN_WaitableObjMgr,
                            notifyRec->notificationObject
                            );

        FindClosePrinterChangeNotification(
                            notifyRec->notificationObject
                            );
        ClosePrinter(notifyRec->printerHandle);
        FREEMEM(notifyRec);
        DeviceList->devices[ofs].deviceSpecificData = NULL;

    }


    //
    //  Handle the change.
    //
    if (result) {

        //
        //  If it's a printer deletion.
        //
        if (changeValue & PRINTER_CHANGE_DELETE_PRINTER) {

            HandlePrinterDeleteNotification(notifyRec->serverDeviceID);
        }
        //
        //  If it's a configuration change.
        //
        else if (changeValue &
                 (PRINTER_CHANGE_ADD_PRINTER_DRIVER |
                  PRINTER_CHANGE_SET_PRINTER_DRIVER |
                  PRINTER_CHANGE_DELETE_PRINTER_DRIVER)) {

            HandlePrinterConfigChangeNotification(notifyRec->serverDeviceID);
        }
    }

    DBGMSG(DBG_TRACE,
        ("UMRDPPRN:SinglePrinterNotifyObjectSignaled exit.\n")
        );
}

void
HandlePrinterRefreshNotification(
    IN PPRINTER_NOTIFY_INFO notifyInfo
    )
/*++

Routine Description:

    Handle a print notification refresh from the spooler.

Arguments:

    notifyInfo          - Notify info pointer returned by
                          FindNextPrinterChangeNotification.

Return Value:

    NA

--*/
{
    DWORD deviceListOfs;
    DWORD notifyOfs;
    LPWSTR printerName;
    DWORD i;

    DBGMSG(DBG_TRACE, ("UMRDPPRN:HandlePrinterRefreshNotification entered.\n"));

    //
    //  Return immediately if the DLL is trying to shut down.  This
    //  is to help prevent us from getting stuck in a system call.
    //
    if (ShutdownFlag) {
        return;
    }

    //
    //  Handle printer additions, renames, etc.
    //
    for (i=0; i<notifyInfo->Count; i++) {

        // Notification Type must be PRINTER_NOTIFY_TYPE.
        ASSERT(notifyInfo->aData[i].Type == PRINTER_NOTIFY_TYPE);

        //
        //  If we have a printer name change event.  This is what we use to
        //  detect new printers and renamed printers.
        //
        if (notifyInfo->aData[i].Field == PRINTER_NOTIFY_FIELD_PRINTER_NAME) {

            printerName = (LPWSTR)notifyInfo->aData[i].NotifyData.Data.pBuf;
            HandlePrinterNameChangeNotification(
                                    notifyInfo->aData[i].Id,
                                    printerName
                                    );
        }
    }
}

BOOL
HandlePrinterDeleteNotification(
    IN DWORD serverDeviceID
    )
/*++

Routine Description:

    Handle notification from the spooler that a printer has been deleted.hanged.

Arguments:

    serverDeviceID      - Server-assigned device ID for printer being deleted.

Return Value:

    Return TRUE on success.  FALSE, otherwise.

--*/
{
    DWORD ofs;
    BOOL result;

    DBGMSG(DBG_TRACE, ("UMRDPPRN:HandlePrinterDeleteNotification with server ID %ld.\n",
        serverDeviceID));

    //
    //  Return immediately if the DLL is trying to shut down.  This
    //  is to help prevent us from getting stuck in a system call.
    //
    if (ShutdownFlag) {
        return FALSE;
    }

    //
    //  If this is for one of our printers.
    //
    if (DRDEVLST_FindByServerDeviceID(DeviceList,
                                    serverDeviceID, &ofs)) {
        DBGMSG(DBG_TRACE, ("UMRDPPRN:****Printer %ws has been removed.****\n",
            DeviceList->devices[ofs].serverDeviceName));

        //
        //  Send a message to the client to let it know that a printer has been
        //  deleted.
        //
        result = SendDeletePrinterMsgToClient(
                            DeviceList->devices[ofs].clientDeviceName);

        //
        //  Clean up the notification object if one is registered.
        //
        if (DeviceList->devices[ofs].deviceSpecificData != NULL) {

            PPRINTNOTIFYREC notifyRec =
                (PPRINTNOTIFYREC)DeviceList->devices[ofs].deviceSpecificData;
            ASSERT(notifyRec->notificationObject != NULL);
            ASSERT(notifyRec->printerHandle != NULL);

            WTBLOBJ_RemoveWaitableObject(
                        UMRDPPRN_WaitableObjMgr,
                        notifyRec->notificationObject
                        );
            FindClosePrinterChangeNotification(
                        notifyRec->notificationObject
                        );

            ClosePrinter(notifyRec->printerHandle);
            FREEMEM(notifyRec);
            DeviceList->devices[ofs].deviceSpecificData = NULL;
        }

        //
        //  Remove it from the list of managed devices.
        //
        DRDEVLST_Remove(DeviceList, ofs);
    }
    else {
        result = TRUE;
    }
    return result;
}

BOOL
HandlePrinterNameChangeNotification(
    IN DWORD serverDeviceID,
    IN LPWSTR printerName
    )
/*++

Routine Description:

    Handle notification from the spooler that the name of a printer has changed.
    This allows us to track these significant events:

    -A printer automatically created by us has been assigned a device ID by the
     spooler.
    -A new printer has been manually added to the system and attached to one
     of our redirected ports.
    -A printer attached to one of our redirected ports has had its name changed.

Arguments:

    serverDeviceID      - Server-assigned device ID associated with the printer
                          name change.
    printerName         - New printer name.

Return Value:

    Return TRUE on success.  FALSE, otherwise.

--*/
{
    HANDLE hPrinter = NULL;
    BOOL result = TRUE;
    PRINTER_DEFAULTS defaults = {NULL, NULL, PRINTER_ALL_ACCESS};
    BOOL printerInList;
    BOOL isNewPrinter;
    DWORD ofs;
    BOOL printerNameExists;
    PWSTR portName;
    DWORD printerNameOfs;
    DWORD len;

    DBGMSG(DBG_TRACE, ("UMRDPPRN:HandlePrinterNameChangeNotification printer %ws.\n",
            printerName));

    //
    //  Return immediately if the DLL is trying to shut down.  This
    //  is to help prevent us from getting stuck in a system call.
    //
    if (ShutdownFlag) {
        return FALSE;
    }

    //
    //  See if we already have a matching printer name.
    //
    printerNameExists =
        (DRDEVLST_FindByServerDeviceName(DeviceList, printerName,
                                        &printerNameOfs)
            && (DeviceList->devices[printerNameOfs].deviceType ==
                RDPDR_DTYP_PRINT));

    //
    //  If a printer automatically created by us has been assigned a
    //  device ID by the spooler.  In some cases, we may get a repeat
    //  printer name.  That is okay because the ID should be the same.
    //
    if (printerNameExists) {

        DBGMSG(DBG_TRACE,
            ("UMRDPPRN:****Printer %ws has had its ID assigned to  %ld.****\n",
            DeviceList->devices[printerNameOfs].serverDeviceName,
            serverDeviceID));
        DeviceList->devices[printerNameOfs].serverDeviceID = serverDeviceID;

        //
        //  Register a notification object with the printer, so we can
        //  be notified when its configuration changes.  This change notification
        //  is registered for events that are not picked up by the global
        //  change notification object.
        //
        result = RegisterPrinterConfigChangeNotification(
                                        serverDeviceID
                                        );
    }
    //
    //  If a printer attached to one of our redirected ports has had
    //  its name changed.
    //
    else if (DRDEVLST_FindByServerDeviceID(
                            DeviceList,
                            serverDeviceID, &ofs
                            )) {
        WCHAR *pBuf;

        DBGMSG(DBG_TRACE,
            ("UMRDPPRN:****Printer %ws has had its name changed to %ws.****\n",
            DeviceList->devices[ofs].serverDeviceName,
            printerName));

        //
        //  Reallocate the server name field.
        //
        len = wcslen(printerName) + 1;
        pBuf = REALLOCMEM(DeviceList->devices[ofs].serverDeviceName,
                        len * sizeof(WCHAR));
        if (pBuf != NULL) {
            DeviceList->devices[ofs].serverDeviceName = pBuf;
        } else {
            FREEMEM(DeviceList->devices[ofs].serverDeviceName);
            DeviceList->devices[ofs].serverDeviceName = NULL;
        }
            
        if (DeviceList->devices[ofs].serverDeviceName != NULL) {
            wcscpy(DeviceList->devices[ofs].serverDeviceName,
                    printerName);

            //
            // Send this information (printer name change) across to the client
            //
            DBGMSG(DBG_TRACE,("UMRDPPRN:clientDeviceID is %ld.\n",
                DeviceList->devices[ofs].clientDeviceID ));

            if (SendPrinterRenameToClient(
                        DeviceList->devices[ofs].clientDeviceName,
                        printerName
                        )) {

                //
                //  Update the client name
                //
                pBuf = REALLOCMEM(DeviceList->devices[ofs].clientDeviceName,
                    len * sizeof(WCHAR));
                if (pBuf != NULL) {
                    DeviceList->devices[ofs].clientDeviceName = pBuf;
                } else {
                    FREEMEM(DeviceList->devices[ofs].clientDeviceName);
                    DeviceList->devices[ofs].clientDeviceName = NULL;
                }
                    
                if (DeviceList->devices[ofs].clientDeviceName != NULL) {
                    wcscpy(DeviceList->devices[ofs].clientDeviceName,
                        printerName);
                }
            }

            result = TRUE;
        }
        else {
            DBGMSG(DBG_ERROR,("UMRDPPRN:Unable to allocate %ld bytes.\n",
                    len * sizeof(WCHAR)));

            TsLogError(EVENT_NOTIFY_INSUFFICIENTRESOURCES, EVENTLOG_ERROR_TYPE,
                        0, NULL, __LINE__);

            result = FALSE;
        }
    }
    else {

        //
        //  Return immediately if the DLL is trying to shut down.  This
        //  is to help prevent us from getting stuck in a system call.
        //
        if (ShutdownFlag) {
            result = FALSE;
        }

        //
        //  Open the printer to get the associated port name.
        //
        if (result) {
            result = OpenPrinter(printerName, &hPrinter, &defaults);
        }
        if (!result && !ShutdownFlag) {
            //
            //  If the error is a result of a non-existent printer, the printer has
            //  probably been renamed and is pending delete, so this is ok.
            //
            if (GetLastError() == ERROR_INVALID_PRINTER_NAME) {
                DBGMSG(DBG_WARN,
                            ("UMRDPDPRN:Error opening %ws in refresh. Error: %ld.  Probably ok.\n",
                            printerName, GetLastError()));
                result = TRUE;
            }
            else {
                DBGMSG(DBG_ERROR,
                            ("UMRDPDPRN:Error opening %ws in refresh. Error: %ld.\n",
                            printerName, GetLastError()));
            }
            goto CleanupAndExit;
        }

        //
        //  Get the port name for the printer.
        //
        if (result) {
            result = GetPrinterPortName(hPrinter, &portName);
            if (!result) {
                DBGMSG(DBG_ERROR,
                    ("UMRDPDPRN:GetPrinterPortName Failed. Error: %ld.\n",
                    GetLastError()));
            }
        }

        //
        //  If a new printer has been manually added to the system and
        //  attached to one of our redirected ports.
        //
        if (result) {
            if (DRDEVLST_FindByServerDeviceName(DeviceList, portName, &ofs) &&
                ISPRINTPORT(DeviceList->devices[ofs].deviceType)) {

                DBGMSG(DBG_TRACE,
                    ("UMRDPPRN:****New printer %ws manually attached to %ws.****\n",
                    printerName, portName));

                //
                //  Send the add printer message to the client.  We don't care about
                //  the return status, since we can't do anything to recover from
                //  a failure to send the message to the client.
                //
                SendAddPrinterMsgToClient(
                                printerName,
                                PrinterInfo2Buf->pDriverName,
                                DeviceList->devices[ofs].preferredDosName
                                );

                //
                //  Add the session number to the printer queue data to identify the printer
                //  as a TS printer.  Don't care about the return value here, because its
                //  failure for a manually installed printer is not a critical error.
                //
                AddSessionIDToPrinterQueue(hPrinter, GETTHESESSIONID());

                //
                //  Add the new printer to our list of managed printers.
                //
                result = DRDEVLST_Add(
                            DeviceList, RDPDR_INVALIDDEVICEID,
                            serverDeviceID,
                            RDPDR_DTYP_PRINT, printerName, printerName, "UNKNOWN"
                            );

                //
                //  Register a notification object with the printer, so we can
                //  be notified when its configuration changes.  This change notification
                //  is registered for events that are not picked up by the global
                //  change notification object.
                //
                if (result) {
                    RegisterPrinterConfigChangeNotification(
                                                serverDeviceID
                                                );
                }
            }
        }
    }

CleanupAndExit:
    //
    //  Close the printer.
    //
    if (hPrinter != NULL) {
        ClosePrinter(hPrinter);
    }
    return result;
}

BOOL
RegisterPrinterConfigChangeNotification(
    IN DWORD serverDeviceID
    )
/*++

Routine Description:

    Register a change notification event with the spooler so that we are
    notified when the configuration for a specific printer has been changed.

Arguments:

    serverDeviceID  -   Server-side ID for the device that is used to
                        track the device in the device list.

Return Value:

    TRUE on success.  Otherwise, FALSE is returned.

--*/
{
    DWORD offset;
    BOOL result;
    PRINTER_DEFAULTS printerDefaults;
    PPRINTNOTIFYREC notifyRec;

    DBGMSG(DBG_TRACE,
        ("UMRDPPRN:RegisterPrinterConfigChangeNotification id %ld.\n",
        serverDeviceID)
        );

    //
    //  Find the printer in the device list.
    //
    result = DRDEVLST_FindByServerDeviceID(
                    DeviceList, serverDeviceID, &offset
                    );

    //
    //  Register a notification object with the printer, so we can
    //  be notified when its configuration changes.  This change notification
    //  is registered for events that are not picked up by the global
    //  change notification object.
    //
    if (result && (DeviceList->devices[offset].deviceSpecificData == NULL)) {
        LPWSTR name = DeviceList->devices[offset].serverDeviceName;

        printerDefaults.pDatatype     = NULL;
        printerDefaults.pDevMode      = NULL;
        printerDefaults.DesiredAccess = PRINTER_ALL_ACCESS;

        //
        //  Allocate a new notification record.
        //
        notifyRec = ALLOCMEM(sizeof(PRINTNOTIFYREC));
        result = (notifyRec != NULL);
        if (result) {
            notifyRec->printerHandle = NULL;
            notifyRec->notificationObject = NULL;
            notifyRec->serverDeviceID = serverDeviceID;
            result = OpenPrinter(name, &notifyRec->printerHandle,
                                &printerDefaults);
        }

        //
        //  Register the notification.
        //
        if (result) {
            notifyRec->notificationObject =
                FindFirstPrinterChangeNotification(
                                    notifyRec->printerHandle,
                                    PRINTER_CHANGE_PRINTER_DRIVER |
                                    PRINTER_CHANGE_DELETE_PRINTER, 0,
                                    NULL
                                    );
            if (notifyRec->notificationObject != NULL) {
                result =
                    WTBLOBJ_AddWaitableObject(
                            UMRDPPRN_WaitableObjMgr,
                            notifyRec,
                            notifyRec->notificationObject,
                            SinglePrinterNotifyObjectSignaled
                            ) == ERROR_SUCCESS;
            }
            else {
                DBGMSG(
                    DBG_ERROR,
                    ("UMRDPPRN:FindFirstPrinterChangeNotification failed for %ws:  %ld.\n",
                    name, GetLastError())
                    );
                result = FALSE;
            }
        }
        else {
            DBGMSG(DBG_ERROR, ("UMRDPPRN:  Can't open printer %ws:  %ld.\n",
                    name, GetLastError()));
        }

        //
        //  Record the notification record or clean up.
        //
        if (result) {
            DeviceList->devices[offset].deviceSpecificData = notifyRec;
        }
        else if (notifyRec != NULL) {
            if (notifyRec->notificationObject != NULL) {
                WTBLOBJ_RemoveWaitableObject(
                            UMRDPPRN_WaitableObjMgr,
                            notifyRec->notificationObject
                            );
                FindClosePrinterChangeNotification(
                        notifyRec->notificationObject
                        );
            }

            if (notifyRec->printerHandle != NULL) {
                ClosePrinter(notifyRec->printerHandle);
            }

            FREEMEM(notifyRec);
        }
    }
    DBGMSG(DBG_TRACE, ("UMRDPPRN:RegisterPrinterConfigChangeNotification done.\n"));

    return result;
}

BOOL
SendAddPrinterMsgToClient(
    IN PCWSTR   printerName,
    IN PCWSTR   driverName,
    IN PCSTR    dosDevicePort
    )
/*++

Routine Description:

    Send an add printer message to the client.

Arguments:

    printerName -   Name of new printer.
    driverName  -   Name of printer driver.
    portName    -   Client-side dos device port name.


Return Value:

    Return TRUE on success.  FALSE, otherwise.

--*/
{
    PRDPDR_PRINTER_CACHEDATA_PACKET cachedDataPacket;
    DWORD cachedDataPacketSize;
    PRDPDR_PRINTER_ADD_CACHEDATA cachedData;
    BOOL result;
    DWORD driverSz, printerSz;
    PWSTR str;

    DBGMSG(DBG_TRACE, ("UMRDPPRN:SendAddPrinterMsgToClient.\n"));
    DBGMSG(DBG_TRACE, ("UMRDPPRN:SendAddPrinterMsgToClient printer name is %ws.\n",
            printerName));
    DBGMSG(DBG_TRACE, ("UMRDPPRN:SendAddPrinterMsgToClient driver name is %ws.\n",
            driverName));
    DBGMSG(DBG_TRACE, ("UMRDPPRN:SendAddPrinterMsgToClient dos device port is %s.\n",
            dosDevicePort));

    //
    //  Calculate the message size.
    //
    driverSz  = ((wcslen(driverName) + 1) * sizeof(WCHAR));
    printerSz = ((wcslen(printerName) + 1) * sizeof(WCHAR));
    cachedDataPacketSize =  sizeof(RDPDR_PRINTER_CACHEDATA_PACKET) +
                            sizeof(RDPDR_PRINTER_ADD_CACHEDATA) +
                            driverSz + printerSz;

    //
    //  Allocate the message.
    //
    cachedDataPacket = (PRDPDR_PRINTER_CACHEDATA_PACKET)ALLOCMEM(
                                                    cachedDataPacketSize
                                                    );
    result = (cachedDataPacket != NULL);

    if (result) {
        //
        //  Set up the packet.
        //
        cachedDataPacket->Header.PacketId = DR_PRN_CACHE_DATA;
        cachedDataPacket->Header.Component = RDPDR_CTYP_PRN;
        cachedDataPacket->EventId = RDPDR_ADD_PRINTER_EVENT;

        //
        //  Set up the cached data.
        //
        cachedData = (PRDPDR_PRINTER_ADD_CACHEDATA)(
                            (PBYTE)cachedDataPacket +
                            sizeof(RDPDR_PRINTER_CACHEDATA_PACKET)
                            );
        strcpy(cachedData->PortDosName, dosDevicePort);
        cachedData->PnPNameLen = 0;
        cachedData->DriverLen = driverSz;
        cachedData->PrinterNameLen = printerSz;
        cachedData->CachedFieldsLen = 0;

        //
        //  Add the driver name.
        //
        str = (PWSTR)((PBYTE)cachedData + sizeof(RDPDR_PRINTER_ADD_CACHEDATA));
        wcscpy(str, driverName);

        //
        //  Add the printer name.
        //
        str = str + driverSz/2;
        wcscpy(str, printerName);

        //
        //  Send the message to the client.
        //
        result = UMRDPDR_SendMessageToClient(
                                    cachedDataPacket,
                                    cachedDataPacketSize
                                    );

        // Release the buffer.
        FREEMEM(cachedDataPacket);
    }

    return result;
}

BOOL
SendDeletePrinterMsgToClient(
    IN PCWSTR   printerName
    )
/*++

Routine Description:

    Send a delete printer message to the client.

Arguments:

    printerName -   Client-recognized name of printer to delete.


Return Value:

    Return TRUE on success.  FALSE, otherwise.

--*/
{
    PRDPDR_PRINTER_CACHEDATA_PACKET cachedDataPacket;
    DWORD cachedDataPacketSize;
    PRDPDR_PRINTER_DELETE_CACHEDATA cachedData;
    BOOL result;
    DWORD printerSz;
    PWSTR str;

    DBGMSG(DBG_TRACE, ("UMRDPPRN:SendDeletePrinterMsgToClient printer name is %ws.\n",
            printerName));

    //
    //  Calculate the message size.
    //
    printerSz = ((wcslen(printerName) + 1) * sizeof(WCHAR));
    cachedDataPacketSize =  sizeof(RDPDR_PRINTER_CACHEDATA_PACKET) +
                            sizeof(RDPDR_PRINTER_DELETE_CACHEDATA) +
                            printerSz;

    //
    //  Allocate the message.
    //
    cachedDataPacket = (PRDPDR_PRINTER_CACHEDATA_PACKET)ALLOCMEM(
                                                    cachedDataPacketSize
                                                    );
    result = (cachedDataPacket != NULL);
    if (result) {
        //
        //  Set up the packet.
        //
        cachedDataPacket->Header.PacketId = DR_PRN_CACHE_DATA;
        cachedDataPacket->Header.Component = RDPDR_CTYP_PRN;
        cachedDataPacket->EventId = RDPDR_DELETE_PRINTER_EVENT;

        //
        //  Set up the cached data.
        //
        cachedData = (PRDPDR_PRINTER_DELETE_CACHEDATA)(
                            (PBYTE)cachedDataPacket +
                            sizeof(RDPDR_PRINTER_CACHEDATA_PACKET)
                            );
        cachedData->PrinterNameLen = printerSz;

        //
        //  Add the printer name.
        //
        str = (PWSTR)((PBYTE)cachedData + sizeof(RDPDR_PRINTER_DELETE_CACHEDATA));
        wcscpy(str, printerName);

        //
        //  Send the message to the client.
        //
        result = UMRDPDR_SendMessageToClient(
                                    cachedDataPacket,
                                    cachedDataPacketSize
                                    );

        // Release the buffer.
        FREEMEM(cachedDataPacket);
    }

    return result;
}

BOOL
RegisterSerialPort(
    IN PCWSTR portName,
    IN PCWSTR devicePath
    )
/*++

Routine Description:

    Register a serial port device by creating the symbolic link

Arguments:

    portName -     Port name for the serial device
    devicePath -   NT device path for the symbolic link

Return Value:

    Return TRUE on success.  FALSE, otherwise.

--*/

{
    DWORD SymLinkNameLen;
    size_t RemainingCharCount;
    PWSTR pNtSymLinkName, buffer;
    UNICODE_STRING SymLinkName, SymLinkValue;
    HANDLE SymLinkHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;
    ULONG dwErrorCode, LUIDDeviceMapsEnabled;
    BOOL  fImpersonated = FALSE, fLUIDDeviceMapsEnabled;
    BOOL  result = TRUE;

    DBGMSG(DBG_TRACE, ("UMRDPPRN:RegisterSerialPort with port %ws.\n", portName));
    DBGMSG(DBG_TRACE, 
           ("UMRDPPRN:RegisterSerialPort with device path %ws.\n", devicePath));

    buffer = NULL;

    //
    // Check if LUID DosDevices maps are enabled
    //
    Status = NtQueryInformationProcess( NtCurrentProcess(),
                                        ProcessLUIDDeviceMapsEnabled,
                                        &LUIDDeviceMapsEnabled,
                                        sizeof(LUIDDeviceMapsEnabled),
                                        NULL
                                      );

    if (NT_SUCCESS(Status)) {
        fLUIDDeviceMapsEnabled = (LUIDDeviceMapsEnabled != 0);
    }
    else {
        fLUIDDeviceMapsEnabled = FALSE;
    }

    //
    // If LUID Device Maps are enabled,
    // We need to impersonate the logged on user in order to create
    // the symbolic links in the correct device map
    // If LUID Device Maps are disabled,
    // we should not impersonate the logged on user in order to delete
    // any existing symbolic links
    //
    if (fLUIDDeviceMapsEnabled == TRUE) {
        fImpersonated = ImpersonateLoggedOnUser(UMRPDPPRN_TokenForLoggedOnUser);

        if (!fImpersonated) {
            DBGMSG(DBG_ERROR,
                ("UMRDPPRN:Error impersonate user in function RegisterSerialPort. Error: %ld\n",
                GetLastError()));
            return FALSE;
        }
    }
    
    // length of ( portName ) + Length of("\\??\\") + UNICODE NULL
    RemainingCharCount = wcslen(portName) + DEVICE_MAP_NAME_COUNT + 1;

    SymLinkNameLen = RemainingCharCount * sizeof( WCHAR );

    pNtSymLinkName = (PWSTR) ALLOCMEM( SymLinkNameLen );

    if (pNtSymLinkName == NULL) {
        DBGMSG(DBG_ERROR,
            ("UMRDPPRN:Error allocating memory in function RegisterSerialPort. Error: %ld\n",
            GetLastError()));
        return( FALSE );
    }

    //
    // Copy \??\ to the symbolic link name
    //
    wcsncpy( pNtSymLinkName, DEVICE_MAP_NAME, RemainingCharCount );

    RemainingCharCount = RemainingCharCount - DEVICE_MAP_NAME_COUNT;

    //
    // Append the portname to the symbolic link name
    //
    wcsncat( pNtSymLinkName, portName, RemainingCharCount );

    RtlInitUnicodeString(&SymLinkName, (PCWSTR)pNtSymLinkName);

    RtlInitUnicodeString(&SymLinkValue, devicePath);

    InitializeObjectAttributes( &ObjectAttributes,
                                &SymLinkName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    Status = NtCreateSymbolicLinkObject( &SymLinkHandle,
                                         SYMBOLIC_LINK_ALL_ACCESS,
                                         &ObjectAttributes,
                                         &SymLinkValue
                                       );

    //
    // If LUID device maps are disabled, then CsrPopulateDosDevices() would
    // have copied the global symbolic link into this TS device map, which
    // would cause the create to fail, so we need to delete the copy before
    // creating our symbolic link
    //
    if (Status == STATUS_OBJECT_NAME_COLLISION) {
        Status = NtOpenSymbolicLinkObject( &SymLinkHandle,
                                           SYMBOLIC_LINK_QUERY | DELETE,
                                           &ObjectAttributes
                                         );

        if (NT_SUCCESS ( Status)) {
            UNICODE_STRING SymLinkString;
            unsigned SymLinkValueLen, ReturnedLength, bufLen;

            SymLinkValueLen = wcslen(devicePath);

            // Find how much buffer is required for the symlink value
            SymLinkString.Buffer = NULL;
            SymLinkString.Length = 0;
            SymLinkString.MaximumLength = 0;
            ReturnedLength = 0;
            Status = NtQuerySymbolicLinkObject( SymLinkHandle,
                                                &SymLinkString,
                                                &ReturnedLength
                                               );

            if (Status != STATUS_BUFFER_TOO_SMALL) {
                ReturnedLength = 0;
            }

            bufLen = SymLinkValueLen * sizeof(WCHAR) + sizeof(UNICODE_NULL) * 2 + ReturnedLength;
            buffer = (PWSTR) ALLOCMEM( bufLen );

            if (buffer == NULL) {
                NtClose(SymLinkHandle);
                DBGMSG(DBG_ERROR,
                        ("UMRDPPRN:Error allocating memory in function RegisterSerialPort. Error: %ld\n",
                        GetLastError()));
                return( FALSE );
            }

            // Setup the devicepath as the first entry
            wcscpy(buffer, devicePath);
            buffer[SymLinkValueLen] = UNICODE_NULL;

            if (ReturnedLength > 0) {
                // Get the existing symlink
                SymLinkString.Buffer = buffer + SymLinkValueLen + 1;
                SymLinkString.Buffer[0] = UNICODE_NULL;
                SymLinkString.MaximumLength = (USHORT)(bufLen - (SymLinkValueLen + 1) * sizeof(WCHAR));
                SymLinkString.Length = 0;
                ReturnedLength = 0;
    
                Status = NtQuerySymbolicLinkObject( SymLinkHandle,
                                                    &SymLinkString,
                                                    &ReturnedLength
                                                   );

                if (Status == STATUS_SUCCESS) {
                    if (ReturnedLength > 2 && (SymLinkString.Buffer[ReturnedLength/sizeof(WCHAR) - 2] != UNICODE_NULL) ) {
                        // Make sure we always end with an UNICODE_NULL
                        SymLinkString.Buffer[ReturnedLength/sizeof(WCHAR)] = UNICODE_NULL;                                                        
                        ReturnedLength += sizeof(UNICODE_NULL);
                    }
                }
                else {
                    ReturnedLength = 0;
                }
            }
            
            // Setup the symlink string
            SymLinkString.Buffer = buffer;
            SymLinkString.Length = (USHORT)(SymLinkValueLen * sizeof(WCHAR));
            SymLinkString.MaximumLength = (USHORT)((SymLinkValueLen + 1) * sizeof(WCHAR) + ReturnedLength);

            Status = NtMakeTemporaryObject( SymLinkHandle );
            NtClose( SymLinkHandle );
            SymLinkHandle = NULL;

            if (NT_SUCCESS ( Status)) {

                Status = NtCreateSymbolicLinkObject( &SymLinkHandle,
                                                     SYMBOLIC_LINK_ALL_ACCESS,
                                                     &ObjectAttributes,
                                                     &SymLinkString
                                                   );
            }            
        }
    }

    // Revert the thread token to self
    if (fImpersonated) {
        RevertToSelf();
    }

    //
    // After the revert to Local System
    //
    if (NT_SUCCESS(Status)) {
        Status = NtMakePermanentObject( SymLinkHandle );   // must be Local System
        NtClose ( SymLinkHandle );
    }

    if (NT_SUCCESS(Status)) {
        result = TRUE;
        DBGMSG(DBG_TRACE, ("UMRDPPRN:RegisterSerialPort with port %ws succeeded.\n", portName));
    }
    else {
        dwErrorCode = RtlNtStatusToDosError( Status );
        SetLastError( dwErrorCode );

        result = FALSE;
        DBGMSG(DBG_ERROR, ("UMRDPPRN:RegisterSerialPort with port %ws failed: %x.\n",
                           portName, GetLastError()));
    }


    //
    // Cleanup the memory that we allocated
    //
    if (pNtSymLinkName != NULL) {
        FREEMEM(pNtSymLinkName);
    }

    if (buffer != NULL) {
        FREEMEM(buffer);
    }
    return result;
}

BOOL
UMRDPPRN_HandlePrintPortAnnounceEvent(
    IN PRDPDR_PORTDEVICE_SUB pPortAnnounce
    )
/*++

Routine Description:

    Handle a printer port device announce event from the "dr" by
    adding a record for the device to the list of installed devices.

Arguments:

    pPortAnnounce -     Port device announce event.

Return Value:

    Return TRUE on success.  FALSE, otherwise.

--*/
{

    DBGMSG(DBG_TRACE, ("UMRDPPRN:UMRDPPRN_HandlePrintPortAnnounceEvent with port %ws.\n",
                        pPortAnnounce->portName));
    DBGMSG(DBG_TRACE, ("UMRDPPDRN:Preferred DOS name is %s.\n",
                        pPortAnnounce->deviceFields.PreferredDosName));

    ASSERT( ISPRINTPORT(pPortAnnounce->deviceFields.DeviceType) );

    if (pPortAnnounce->deviceFields.DeviceType == RDPDR_DTYP_SERIAL ||
            pPortAnnounce->deviceFields.DeviceType == RDPDR_DTYP_PARALLEL) {

        WCHAR serverDevicePath[MAX_PATH];

        // Query the original symbolic link for the serial port and save it for restore
        // later
        serverDevicePath[0] = L'\0';
        if (QueryDosDevice(pPortAnnounce->portName, serverDevicePath, MAX_PATH) != 0) {
            DBGMSG(DBG_TRACE, ("UMRDPPRN:QueryDosDevice on port: %ws, returns path: %ws.\n",
                               pPortAnnounce->portName, serverDevicePath));
        }
        else {
            DBGMSG(DBG_ERROR, ("UMRDPPRN:QueryDosDevice on port: %ws returns error: %x.\n",
                               pPortAnnounce->portName, GetLastError()));
        }

        // Register the new symbolic link name
        RegisterSerialPort(pPortAnnounce->portName, pPortAnnounce->devicePath);

        // Just record the port so we can remember it for later.
        // We save the new serial symbolic link name in client device name and
        // the original symbolic link in server device name
        return DRDEVLST_Add(
                DeviceList,
                pPortAnnounce->deviceFields.DeviceId,
                UMRDPDR_INVALIDSERVERDEVICEID,
                pPortAnnounce->deviceFields.DeviceType,
                serverDevicePath,
                pPortAnnounce->devicePath,
                pPortAnnounce->deviceFields.PreferredDosName
                );
    }
    else {
        if (!PrintingModuleInitialized) {
            return FALSE;
        }

        // Just record the port so we can remember it for later.
        return DRDEVLST_Add(
                DeviceList,
                pPortAnnounce->deviceFields.DeviceId,
                UMRDPDR_INVALIDSERVERDEVICEID,
                pPortAnnounce->deviceFields.DeviceType,
                pPortAnnounce->portName,
                pPortAnnounce->portName,
                pPortAnnounce->deviceFields.PreferredDosName
                );

    }
}

BOOL
UMRDPPRN_DeleteSerialLink(
    UCHAR *preferredDosName,
    WCHAR *ServerDeviceName,
    WCHAR *ClientDeviceName
    )
/*++

Routine Description:

    Delete the new symbolic link on disconnect/logoff and restore the old one
    as necessary

Arguments:

    preferredDosName - the port name in ANSI char
    ServerDeviceName - the original serial link symbolic path
    ClientDeviceName - the new serial link symbolic path

Return Value:

    Return TRUE on success.  FALSE, otherwise.

--*/
{
    ULONG LUIDDeviceMapsEnabled;
    BOOL fImpersonated = FALSE, fLUIDDeviceMapsEnabled;
    WCHAR PortNameBuff[PREFERRED_DOS_NAME_SIZE];
    NTSTATUS Status;

    DBGMSG(DBG_TRACE, ("UMRDPPRN:UMRDPPRN_DeleteSerialLink\n"));

    // Assemble the port name from preferred dos name
    PortNameBuff[0] = L'\0';
    MultiByteToWideChar(CP_ACP, 0, preferredDosName, -1, PortNameBuff, PREFERRED_DOS_NAME_SIZE);

    //
    // Check if LUID DosDevices maps are enabled
    //
    Status = NtQueryInformationProcess( NtCurrentProcess(),
                                        ProcessLUIDDeviceMapsEnabled,
                                        &LUIDDeviceMapsEnabled,
                                        sizeof(LUIDDeviceMapsEnabled),
                                        NULL
                                      );

    if (NT_SUCCESS(Status)) {
        fLUIDDeviceMapsEnabled = (LUIDDeviceMapsEnabled != 0);
    }
    else {
        fLUIDDeviceMapsEnabled = FALSE;
    }

    //
    // If LUID Device Maps are enabled,
    // We need to impersonate the logged on user in order to delete
    // the symbolic links from the correct device map
    // If LUID Device Maps are disabled,
    // we should not impersonate the logged on user in order to delete
    // any existing symbolic links
    //
    if (fLUIDDeviceMapsEnabled == TRUE) {
        fImpersonated = ImpersonateLoggedOnUser(UMRPDPPRN_TokenForLoggedOnUser);

        if (!fImpersonated) {
            DBGMSG(DBG_ERROR,
                ("UMRDPPRN:Error impersonate user in function UMRDPPRN_DeleteSerialLink. Error: %ld\n",
                GetLastError()));
            return FALSE;
        }
    }

    if (PortNameBuff[0] != L'\0') {
        // Just need to delete the new symbolic link for this session
        if (DefineDosDevice(DDD_RAW_TARGET_PATH | DDD_REMOVE_DEFINITION | DDD_EXACT_MATCH_ON_REMOVE,
                PortNameBuff,
                ClientDeviceName) != 0) {
            DBGMSG(DBG_TRACE, ("UMRDPPRN:Delete port %ws with link %ws succeeded.\n",
                                PortNameBuff, ClientDeviceName));
        }
        else {
            DBGMSG(DBG_ERROR, ("UMRDPPRN:Delete port: %ws with link %ws failed: %x\n",
                               PortNameBuff, ClientDeviceName, GetLastError()));
        }        
    }
    else {
        DBGMSG(DBG_ERROR, ("UMRDPPRN:UMRDPPRN_DeleteSerialLink failed to get the port name\n"));
    }

    // Delete the serial registry entry if on PTS box
    
    if (fRunningOnPTS) {
        DWORD rc;
        HKEY regKey;
        
        rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, TSSERIALDEVICEMAP, 0,
                KEY_ALL_ACCESS, &regKey);
        if (rc == ERROR_SUCCESS) {
            RegDeleteValue(regKey, PortNameBuff);
            RegCloseKey(regKey);
        }
    }

    // Revert the thread token to self
    if (fImpersonated) {
        RevertToSelf();
    }

    return TRUE;
}

WCHAR *ANSIToUnicode(
    IN LPCSTR   ansiString,
    IN UINT     codePage
    )
/*++

Routine Description:

  Convert an ANSI string to Unicode.

Arguments:


Return Value:

    Returns the converted string or NULL on error..  It is up to the caller to
    release this string.

--*/

{
    int numChars;
    PWSTR buf=NULL;

    //
    //  Convert the driver name.
    //
    // First, get the required buffer size.
    numChars = MultiByteToWideChar(
                    codePage, 0, ansiString,
                    -1, NULL, 0
                    );

    // Allocate the buffer.
    buf = (PWSTR)ALLOCMEM((numChars + 1) * sizeof(WCHAR));
    if (buf != NULL) {
        buf[0] = L'\0';
        numChars = MultiByteToWideChar(
                                codePage, 0, ansiString,
                                -1, buf, numChars
                                );
        // Find out if the conversion succeeded.

        if ((numChars != 0) || !ansiString[0]) {
            return buf;
        }
        else {
            DBGMSG(DBG_ERROR,
                ("UMRDPPRN:Error converting to Unicode. Error: %ld\n",
                GetLastError()));
            FREEMEM(buf);
            return NULL;
        }
    }
    else {
        DBGMSG(DBG_ERROR,
            ("UMRDPPRN:Error allocating memory in function AnsiToUNICODE. Error: %ld\n",
            GetLastError()));
        return NULL;
    }
}

DWORD
InstallPrinter(
    IN PCWSTR portName,
    IN PCWSTR driverName,
    IN PWSTR printerNameBuf,
    IN DWORD cchPrintNameBuf,
    IN BOOL cachedDataExists,
    OUT BOOL *triggerConfigChangeEvent
    )
/*++


--*/
{
    INT_PTR status = ERROR_SUCCESS; // PnpInterfaceFunc() returns INT_PTR
    TAdvInfInstall tii;
    TParameterBlock tpb;
    PSECURITY_DESCRIPTOR psd;
    PSID pSid = NULL;
    BOOL  daclPresent;
    PACL dacl;
    BOOL daclDefaulted;

    DBGMSG(DBG_WARN,
            ("UMRDPPRN:InstallPrinter portName %ws, driverName %ws, printerName %ws\n",
            portName, driverName, printerNameBuf));

    *triggerConfigChangeEvent = FALSE;

    //
    //  Get the user sid.
    //
    if ((pSid = TSNUTL_GetUserSid(UMRPDPPRN_TokenForLoggedOnUser)) == NULL) {
        status = GetLastError();
        DBGMSG(DBG_ERROR, ("UMRDPPRN: Failed to get user SID:  %ld\n",
                status));
        goto CLEANUPANDEXIT;
    }

    //
    //  Get the default printer security descriptor.
    //
    psd = RDPDRUTL_CreateDefaultPrinterSecuritySD(pSid);
    if (psd == NULL) {
        status = GetLastError();
        goto CLEANUPANDEXIT;
    }

    tii.cbSize = sizeof(tii);
    tii.pszModelName = driverName;              
    tii.pszServerName = NULL;                   
    tii.pszInfName = PrinterInfPath;
    tii.pszPortName = portName;
    tii.pszPrinterNameBuffer = printerNameBuf;
    tii.cchPrinterName = cchPrintNameBuf;
    tii.pszSourcePath = NULL;
    tii.dwFlags = kPnPInterface_Quiet |
                    kPnPInterface_NoShare |
                    kPnpInterface_UseExisting |
                    kPnpInterface_HydraSpecific;
    tii.dwAttributes = PRINTER_ATTRIBUTE_TS;
    tii.pSecurityDescriptor = psd;


    //
    //  If cached data does not exist, then OR in the flag that
    //  enables printui to set a default ICM color profile, for 
    //  color printers.  Note that there is no additional overhead
    //  for non-color printers.
    //
    if (!cachedDataExists) {
        tii.dwFlags |= kPnPInterface_InstallColorProfiles;
    }

    memset(&tpb, 0, sizeof(tpb));
    tpb.pAdvInfInstall = &tii;

    status = PnpInterfaceFunc(kAdvInfInstall, &tpb);

    //
    //  The configuration info needs to be cached on the client if
    //  the printer is color and we didn't have any cached data to begin 
    //  with.  This is a performance optimization so we don't need to 
    //  create a color profile for the remote printer each time we log in.
    //
    if (status == ERROR_SUCCESS) {
        *triggerConfigChangeEvent = !cachedDataExists && 
                                    (tii.dwOutFlags & kAdvInf_ColorPrinter); 
    }

    //
    //  Release the Security Descriptor.
    //
    LocalFree(psd);

CLEANUPANDEXIT:

    if (pSid != NULL) FREEMEM(pSid);

    DBGMSG(DBG_WARN,("UMRDPPRN:InstallPrinter returns %ld\n", status));

    return (DWORD)status;
}

VOID
TriggerConfigChangeTimer()
/*++

Routine Description:
    
    Set the config change timer callback to fire 1 time.       

Arguments:

Return Value:

--*/
{
    LARGE_INTEGER li;

    if (g_fTimerSet == FALSE) {
        
        li.QuadPart = Int32x32To64(CONFIG_WAIT_PERIOD, -10000);      // 30 seconds (in nano second units)
        if (SetWaitableTimer(WaitableTimer,
                                &li,
                                0,
                                NULL,
                                NULL,
                                FALSE)) {
            g_fTimerSet = TRUE;
        }
        else {
            DBGMSG(DBG_TRACE, ("UMRDPPRN:SetWaitableTimer Failed. Error: %ld.\n", GetLastError()));
        }
    }
}


BOOL
InstallPrinterWithPortName(
    IN DWORD  deviceID,
    IN HANDLE hTokenForLoggedOnUser,
    IN BOOL   bSetDefault,
    IN ULONG  ulFlags,
    IN PCWSTR portName,
    IN PCWSTR driverName,
    IN PCWSTR printerName,
    IN PCWSTR clientComputerName,
    IN PBYTE  cacheData,
    IN DWORD  cacheDataLen
    )
/*++

Routine Description:

  Install the printing device.

Arguments:

    deviceID -          Device identifier assigned by kernel mode component and client.
    hTokenForLoggedOnUser - Logged on user token.
    portName    -       Name of printer port.
    driverName  -       Printer driver name. (eg. AGFA-AccuSet v52.3)
    printerName -       Printer name.  This function appends "/Session X/Computer Name"
    clientComputerName -        Name of client computer.

Return Value:

    Return TRUE on success.  FALSE, otherwise.

--*/
{
    WCHAR   printerNameBuf[MAX_PATH+1];
    size_t  printerNameLen;
    DWORD status = ERROR_SUCCESS;
    WCHAR   errorBuf[256];
    HANDLE  hPrinter;
    TS_PRINTER_NAMES printerNames;
    PRINTER_DEFAULTS defaults = {NULL, NULL, PRINTER_ALL_ACCESS};
    BOOL    queueCreated = FALSE;
    DWORD   requiredSize;
    BOOL    clientDriverMapped;
    WCHAR  *parms[2];
    BOOL    triggerConfigChangeEvent;
    DWORD   ofs;
    BOOL printerNameExists;

#if DBG
    DWORD i;
#endif

    DBGMSG(DBG_TRACE, ("UMRDPPRN:InstallPrinterWithPortName.\n"));

    DBGMSG(DBG_TRACE, ("UMRDPPRN:Port name is %ws driver name is %ws\n", portName, driverName));

#ifndef UNICODE
    ASSERT(0);
#endif

    //
    // format printer name
    //
    printerNames.ulTempLen = sizeof(printerNames.szTemp)/sizeof(printerNames.szTemp[0]);
    printerNames.pszFullName = printerName;
    printerNames.pszCurrentClient = clientComputerName;
    printerNames.pszServer = NULL;
    printerNames.pszClient = NULL;
    printerNames.pszPrinter = NULL;

    FormatPrinterName(printerNameBuf,
                      sizeof(printerNameBuf)/sizeof(printerNameBuf[0]),
                      ulFlags,
                      &printerNames);

    printerNameLen = wcslen(printerNameBuf);

    //
    //  Delete the printer if it already exists.
    //
    if (OpenPrinter(printerNameBuf, &hPrinter, &defaults)) {

        DBGMSG(DBG_WARN,
            ("UMRDPPRN:Deleting existing printer %ws in InstallPrinterWithPortName!\n",
             printerNameBuf));

        if (!SetPrinter(hPrinter, 0, NULL, PRINTER_CONTROL_PURGE) ||
            !DeletePrinter(hPrinter)) {

            DBGMSG(DBG_ERROR,
                ("UMRDPPRN:Error deleting existing printer %ws:  %08X!\n",
                 printerNameBuf,GetLastError()));

            ClosePrinter(hPrinter);
            return FALSE;
        }
        else {
            ClosePrinter(hPrinter);
            hPrinter = INVALID_HANDLE_VALUE;
        }
    }
    else {
        hPrinter = INVALID_HANDLE_VALUE;
    }

    //
    //  Return immediately if the DLL is trying to shut down.  This
    //  is to help prevent us from getting stuck in a system call.
    //
    if (ShutdownFlag) {
        status = ERROR_SHUTDOWN_IN_PROGRESS;
        goto Cleanup;
    }

    //
    // We want to check if driver already install first because
    // if we simply dump installation of a nt4 or win9x driver
    // to print UI, it will takes a long time for it to find out
    // that driver does not exist, on other case, if a OEM driver
    // already install, we also want to use it.
    //

    //
    // MapClientPrintDriverName() will try out with upgrade infs file
    // first, so if NT4/Win9x driver (not in ntprintf.inf), we will
    // pick up mapping first.
    //
    status = PrinterDriverInstalled( driverName );

    if( ERROR_SHUTDOWN_IN_PROGRESS == status ) {
        goto Cleanup;
    }

    if( ERROR_SUCCESS == status ) {

        //
        // Driver already install.  Try installing the printer.  If this fails,
        // driver must be blocked.
        //
        status = InstallPrinter(
                        portName,
                        driverName,
                        printerNameBuf,
                        sizeof(printerNameBuf) / sizeof(printerNameBuf[0]),
                        cacheDataLen > 0,
                        &triggerConfigChangeEvent
                        );

        if( ERROR_SUCCESS == status ) {
            queueCreated = TRUE;
        }

        if( ShutdownFlag ) {
            // overwrite last error since we are shutting down
            status = ERROR_SHUTDOWN_IN_PROGRESS;
            goto Cleanup;
        }
    }

    if( ERROR_SUCCESS != status ) {

        //
        // Driver not installed or failed to installed printer with
        // driver already exist on system, go thru mapping process
        //
        clientDriverMapped = MapClientPrintDriverName(
                                                driverName,
                                                &MappedDriverNameBuf,
                                                &MappedDriverNameBufSize
                                            );

        status = InstallPrinter(
                        portName,
                        (clientDriverMapped) ? MappedDriverNameBuf : driverName,
                        printerNameBuf,
                        sizeof(printerNameBuf) / sizeof(printerNameBuf[0]),
                        cacheDataLen > 0,
                        &triggerConfigChangeEvent
                    );

        if( ERROR_SUCCESS == status ) {
            queueCreated = TRUE;
        }
    }

    if( ShutdownFlag ) {
        // overwrite last error since we are shutting down
        status = ERROR_SHUTDOWN_IN_PROGRESS;
        goto Cleanup;
    }

    //
    // Log an error message if the driver wasn't found
    //
    if (!queueCreated) {
        ASSERT( status != ERROR_SUCCESS );
        if ((status == ERROR_FILE_NOT_FOUND) || (status == ERROR_PATH_NOT_FOUND)) {
            ASSERT((sizeof(parms)/sizeof(WCHAR *)) >= 2);
            parms[0] = (WCHAR *)driverName;
            parms[1] = (WCHAR *)printerName;
            TsLogError(EVENT_NOTIFY_DRIVER_NOT_FOUND, EVENTLOG_ERROR_TYPE, 2,
                        parms, __LINE__);
        }
        else if (status == ERROR_UNKNOWN_PRINTER_DRIVER) {
            ASSERT((sizeof(parms)/sizeof(WCHAR *)) >= 2);
            parms[0] = (WCHAR *)driverName;
            parms[1] = (WCHAR *)printerName;
            TsLogError(EVENT_NOTIFY_UNKNOWN_PRINTER_DRIVER, EVENTLOG_ERROR_TYPE, 2,
                        parms, __LINE__);
        }
        DBGMSG(DBG_TRACE, ("UMRDPPRN:Printui func failed with status %08x.\n", status));
    }

    //
    //  Set the new printer as the default printer, after saving the
    //  current printer context, if so configured.
    //
    if (ERROR_SUCCESS == status && UMRDPDR_fSetClientPrinterDefault() && bSetDefault) {

        DWORD statusSave = ERROR_SUCCESS;
        BOOL fImpersonated = FALSE;
        SaveDefaultPrinterContext(printerNameBuf);

        //
        //impersonate before setting the default printer as the api
        //accesses hkcu. If the impersonation fails, the api will fail
        //and we will log an error. But, before logging an error, we will
        //need to revert to self.
        //
        if (!(fImpersonated = ImpersonateLoggedOnUser(hTokenForLoggedOnUser))) {
            DBGMSG(DBG_TRACE, ("UMRDPDR:ImpersonateLoggedOnUser failed. Error:%ld.\n", GetLastError()));
        }

        if (!SetDefaultPrinter(printerNameBuf)) {
            statusSave = GetLastError();
        }

        //
        //if revert to self fails, consider it fatal
        //
        if (fImpersonated && !RevertToSelf()) {
            status = GetLastError();
            DBGMSG(DBG_TRACE, ("UMRDPDR:RevertToSelf failed. Error:%ld.\n", status));
            goto Cleanup;
        }
        
        if (statusSave != ERROR_SUCCESS) {
            WCHAR * param = printerNameBuf;

            DBGMSG(DBG_ERROR, ("UMRDPPRN: SetDefaultPrinter failed. Error: %ld\n",
                statusSave));

            TsLogError(EVENT_NOTIFY_SETDEFAULTPRINTER_FAILED,
                EVENTLOG_ERROR_TYPE,
                1,
                &param,
                __LINE__);
        }
    }

    //
    //  Return immediately if the DLL is trying to shut down.  This
    //  is to help prevent us from getting stuck in a system call.
    //
    if (ShutdownFlag) {
        status = ERROR_SHUTDOWN_IN_PROGRESS;
        goto Cleanup;
    }

    //
    //  Restore cached data for the new printer.
    //
    if (ERROR_SUCCESS == status && cacheDataLen) {

        status = SetPrinterConfigInfo(
                            printerNameBuf,
                            cacheData,
                            cacheDataLen
                            );

        if (status != ERROR_SUCCESS) {

            WCHAR * param = printerNameBuf;

            DBGMSG(DBG_TRACE, ("UMRDPPRN:SetPrinterConfigInfo failed: %ld.\n", status));

            SetLastError(status);
            TsLogError(EVENT_NOTIFY_RESTORE_PRINTER_CONFIG_FAILED,
                EVENTLOG_WARNING_TYPE,
                1,
                &param,
                __LINE__);

            //
            //  We will go ahead and leave the queue created, but assume the config 
            //  settings are bad on the client and cause them to be overwritten with
            //  the default config settings.
            //
            status = ERROR_SUCCESS;
            triggerConfigChangeEvent = TRUE;
        }

    }

    //
    //  Return immediately if the DLL is trying to shut down.  This
    //  is to help prevent us from getting stuck in a system call.
    //
    if (ShutdownFlag) {
        status = ERROR_SHUTDOWN_IN_PROGRESS;
        goto Cleanup;
    }

    //
    //  Open the printer to make some modifications
    //
    if (queueCreated && (status == ERROR_SUCCESS)) {

        ASSERT(hPrinter == INVALID_HANDLE_VALUE);
        DBGMSG(DBG_TRACE, ("UMRDPPRN:InstallPrinterWithPortName installing printer queue succeeded.\n"));
        if( OpenPrinter(printerNameBuf, &hPrinter, &defaults) == FALSE ) {
            hPrinter = INVALID_HANDLE_VALUE;
            status = GetLastError();
            DBGMSG(DBG_TRACE, ("UMRDPPRN:OpenPrinter() %ws failed with %ld.\n", printerNameBuf, status));
        }

        //
        //  Add the session number to the printer queue data.
        //
        if (ERROR_SUCCESS == status) {
            status = AddSessionIDToPrinterQueue(hPrinter, GETTHESESSIONID());
            if( ERROR_SUCCESS != status ) {
                DBGMSG(DBG_ERROR,
                    ("UMRDPPRN:AddSessionIDToPrinterQueue failed for %ws.\n",
                    printerNameBuf)
                    );
            }
        }

        //
        //  Add the different names to the printer queue data.
        //  They will be used if we need to redirect (again!) the printer.
        //
        if (ERROR_SUCCESS == status) {
            status = AddNamesToPrinterQueue(hPrinter, &printerNames);
            if (status != ERROR_SUCCESS) {
                DBGMSG(DBG_ERROR,
                    ("UMRDPPRN:AddNamesToPrinterQueue failed for %ws with status %08x.\n",
                    printerNameBuf, status)
                    );
            }
        }
    }

    //
    //  Return immediately if the DLL is trying to shut down.  This
    //  is to help prevent us from getting stuck in a system call.
    //
    if (ShutdownFlag) {
        status = ERROR_SHUTDOWN_IN_PROGRESS;
        goto Cleanup;
    }

    //
    //  Check to make sure the printer doesn't already exist in the device list
    //
    printerNameExists =
        (DRDEVLST_FindByServerDeviceName(DeviceList, printerNameBuf,
                                        &ofs)
            && (DeviceList->devices[ofs].deviceType ==
                RDPDR_DTYP_PRINT));
    
    if (!printerNameExists) {
        //
        //  Add the printer to the list of installed devices.
        //
        if (ERROR_SUCCESS == status) {
            if( !DRDEVLST_Add(DeviceList, deviceID,
                              UMRDPDR_INVALIDSERVERDEVICEID,
                              RDPDR_DTYP_PRINT,
                              printerNameBuf,
                              printerName,
                              "UNKNOWN") ) {

                // DRDEVLST_Add
                status = ERROR_OUTOFMEMORY;
            }
        }

        //
        //  Trigger a config change event if the install function
        //  indicated that we need to push config data out to the client.
        //
        if (triggerConfigChangeEvent && (status == ERROR_SUCCESS)) {

            DRDEVLST_FindByClientDeviceID(DeviceList, deviceID, &ofs);
            DeviceList->devices[ofs].fConfigInfoChanged = TRUE;
            TriggerConfigChangeTimer();
        }
    }

Cleanup:

    //
    //  Close the printer handle if it was left open.
    //
    if (hPrinter != INVALID_HANDLE_VALUE) {
        ClosePrinter(hPrinter);
    }

    //
    //  Delete the queue on failure.
    //
    if (status != ERROR_SUCCESS && queueCreated) {
        UMRDPPRN_DeleteNamedPrinterQueue(printerNameBuf);
    }

    SetLastError(status);

    return (status == ERROR_SUCCESS);
}

DWORD
AddSessionIDToPrinterQueue(
    IN  HANDLE  hPrinter,
    IN  DWORD   sessionID
    )
/*++

Routine Description:

    Add the session ID to printer queue associated with the specified
    handle.

Arguments:

    hPrinter    -   Handle for printer returned by OpenPrinter.
    sessionID   -   Session ID.

Return Value:

    Returns ERROR_SUCCESS on success.  Error code, otherwise.

--*/
{
    DWORD result;

    result = SetPrinterData(
                hPrinter, DEVICERDR_SESSIONID, REG_DWORD,
                (PBYTE)&sessionID, sizeof(sessionID)
                );
    if (result != ERROR_SUCCESS) {
        DBGMSG(DBG_ERROR, ("UMRDPPRN:SetPrinterData failed with status %08x.\n", result));
    }
    return result;
}

DWORD
AddNamesToPrinterQueue(
    IN  HANDLE  hPrinter,
    IN  PTS_PRINTER_NAMES pPrinterNames
    )
/*++

Routine Description:

    Add the Server\Client\Printer names to printer queue
    associated with the specified handle.

Arguments:

    hPrinter    -   Handle for printer returned by OpenPrinter.
    pPrinterNames - struct conataining the names.

Return Value:

    Returns ERROR_SUCCESS on success.  Error code, otherwise.

--*/
{
    DWORD result = ERROR_SUCCESS;

    if(pPrinterNames->pszServer) {
        result = SetPrinterData(
                    hPrinter, DEVICERDR_PRINT_SERVER_NAME, REG_SZ,
                    (PBYTE)pPrinterNames->pszServer, (wcslen(pPrinterNames->pszServer) + 1)*sizeof(WCHAR)
                    );
        if (result != ERROR_SUCCESS) {
            DBGMSG(DBG_ERROR, ("UMRDPPRN:SetPrinterData failed to set %ws with status %08x.\n",
                   pPrinterNames->pszServer, result));
        }
    }
    if((result == ERROR_SUCCESS) && pPrinterNames->pszClient) {
        result = SetPrinterData(
                    hPrinter, DEVICERDR_CLIENT_NAME, REG_SZ,
                    (PBYTE)pPrinterNames->pszClient, (wcslen(pPrinterNames->pszClient) + 1)*sizeof(WCHAR)
                    );
        if (result != ERROR_SUCCESS) {
            DBGMSG(DBG_ERROR, ("UMRDPPRN:SetPrinterData failed to set %ws with status %08x.\n",
                   pPrinterNames->pszClient, result));
        }
    }
    if((result == ERROR_SUCCESS) && pPrinterNames->pszPrinter) {
        result = SetPrinterData(
                    hPrinter, DEVICERDR_PRINTER_NAME, REG_SZ,
                    (PBYTE)pPrinterNames->pszPrinter, (wcslen(pPrinterNames->pszPrinter) + 1)*sizeof(WCHAR)
                    );
        if (result != ERROR_SUCCESS) {
            DBGMSG(DBG_ERROR, ("UMRDPPRN:SetPrinterData failed to set %ws with status %08x.\n",
                   pPrinterNames->pszPrinter, result));
        }
    }
    return result;
}

BOOL
UMRDPPRN_DeleteNamedPrinterQueue(
    IN PWSTR printerName
    )
/*++

Routine Description:

    Delete the named printer.  This function does not remove the printer
    from the comprehensive device management list.

Arguments:

    printerName  -  Name of printer to delete.

Return Value:

    Returns TRUE on success.  FALSE, otherwise.

--*/
{
    HANDLE hPrinter;
    PRINTER_DEFAULTS defaults = {NULL, NULL, PRINTER_ALL_ACCESS};
    DWORD ofs;
    BOOL result;

    WCHAR defaultPrinterNameBuffer[MAX_PATH+1];
    DWORD bufSize = sizeof(defaultPrinterNameBuffer) / sizeof(defaultPrinterNameBuffer[0]);

    BOOL fPrinterIsDefault;
    BOOL fDefaultPrinterSet = FALSE;
    BOOL fImpersonated = FALSE;

    defaultPrinterNameBuffer[0] = L'\0';

    if (!PrintingModuleInitialized) {
        return FALSE;
    }

    //
    //  If the printer is one of the devices we are tracking, then
    //  we need to remove the notification object associated with the
    //  printer.
    //
    if (DRDEVLST_FindByServerDeviceName(DeviceList, printerName, &ofs) &&
        (DeviceList->devices[ofs].deviceSpecificData != NULL)) {

        PPRINTNOTIFYREC notifyRec = (PPRINTNOTIFYREC)
                                    DeviceList->devices[ofs].deviceSpecificData;
        ASSERT(notifyRec->notificationObject != NULL);
        ASSERT(notifyRec->printerHandle != NULL);

        WTBLOBJ_RemoveWaitableObject(
                    UMRDPPRN_WaitableObjMgr,
                    notifyRec->notificationObject
                    );

        FindClosePrinterChangeNotification(
            notifyRec->notificationObject
            );

        ClosePrinter(notifyRec->printerHandle);

        FREEMEM(notifyRec);

        DeviceList->devices[ofs].deviceSpecificData = NULL;
    }

    //
    // Check to see if the printer we are deleting is a default printer
    //

    if (!(fImpersonated = ImpersonateLoggedOnUser(UMRPDPPRN_TokenForLoggedOnUser))) {
            DBGMSG(DBG_TRACE, ("UMRDPDR:ImpersonateLoggedOnUser failed. Error:%ld.\n", GetLastError()));
    }


    fPrinterIsDefault = (GetDefaultPrinter(defaultPrinterNameBuffer, &bufSize) &&
                      (wcscmp(defaultPrinterNameBuffer, printerName) == 0));

    DBGMSG(DBG_TRACE, ("UMRDPPRN:DeleteNamedPrinter deleting %ws.\n",
            printerName));

    if (fImpersonated&& !RevertToSelf()) {
        DBGMSG(DBG_TRACE, ("UMRDPDR:RevertToSelf failed. Error:%ld.\n", GetLastError()));
    }


    //
    //  Open the printer.
    //
    result = OpenPrinter(printerName, &hPrinter, &defaults);

    //
    //  Purge and delete the printer.
    //
    if (result) {

        result = SetPrinter(hPrinter, 0, NULL, PRINTER_CONTROL_PURGE) &&
                 DeletePrinter(hPrinter);

    }
    else {
        hPrinter = NULL;
    }

    //
    //  If the printer is the default, then restore the previously stored
    //  printer context.
    //
    if (fPrinterIsDefault) {
        RestoreDefaultPrinterContext();
    }

    //
    //  Log an event on failure.
    //
    if (!result) {
        WCHAR * param = printerName;
        TsLogError(EVENT_NOTIFY_DELETE_PRINTER_FAILED,
                EVENTLOG_ERROR_TYPE,
                1,
                &param,
                __LINE__);

        DBGMSG(DBG_ERROR,
            ("UMRDPPRN:Unable to delete redirected printer - %ws. Error: %ld\n",
            printerName, GetLastError()));
    }
    else
    {
        DBGMSG(DBG_TRACE, ("UMRDPPRN:Printer successfully deleted.\n"));
    }

    //
    //  Close the printer if we successfully opened it.
    //
    if (hPrinter != NULL) {
        ClosePrinter(hPrinter);
     }

     return result;
}

BOOL
SetDefaultPrinterToFirstFound(
    BOOL impersonate
    )
/*++

Routine Description:

    Enumerate all printers visible to the user and try to set the
    first one we "can" to default.

Arguments:

    impersonate -   TRUE if this function should impersonate the user
                    prior to setting the default printer.

Return Value:

    Returns TRUE on success.  FALSE, otherwise.

--*/
{
    BOOL fSuccess = FALSE;
    BOOL fImpersonated = FALSE;
    PRINTER_INFO_4 * pPrinterInfo = NULL;
    DWORD cbBuf = 0;
    DWORD cReturnedStructs = 0;
    DWORD i;

    DBGMSG(DBG_TRACE, ("UMRDPDR:SetDefaultPrinterToFirstFound Entered.\n"));

    if (impersonate) {

        //
        // Impersonate Client
        //

        if ((UMRPDPPRN_TokenForLoggedOnUser == INVALID_HANDLE_VALUE) ||
            !(fImpersonated = ImpersonateLoggedOnUser(UMRPDPPRN_TokenForLoggedOnUser))) {

            if (UMRPDPPRN_TokenForLoggedOnUser == INVALID_HANDLE_VALUE) {
                DBGMSG(DBG_TRACE, ("UMRDPDR:UMRPDPPRN_TokenForLoggedOnUser is INVALID_HANDLE_VALUE.\n"));
            }
            else {
                DBGMSG(DBG_TRACE, ("UMRDPDR:ImpersonateLoggedOnUser failed. Error:%ld.\n", GetLastError()));
            }
            goto Cleanup;
        }

    }

    //
    // Enumerate Printers
    //

    if (!EnumPrinters(
            PRINTER_ENUM_LOCAL,     // Flags
            NULL,                   // Name
            4,                      // Print Info Type
            (PBYTE)pPrinterInfo,    // buffer
            0,                      // Size of buffer
            &cbBuf,                 // Required
            &cReturnedStructs)) {

        if(GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {
            DBGMSG(DBG_ERROR, ("UMRDPPRN: EnumPrinters failed. Error: %ld.\n", GetLastError()));
            goto Cleanup;
        }
    }

    if (cbBuf == 0) {
        goto Cleanup;
    }

    pPrinterInfo = (PRINTER_INFO_4 *)ALLOCMEM(cbBuf);

    if (pPrinterInfo == NULL) {
        DBGMSG(DBG_ERROR, ("UMRDPPRN: ALLOCMEM failed. Error: %ld.\n", GetLastError()));
        goto Cleanup;
    }

    if (!EnumPrinters(
            PRINTER_ENUM_LOCAL,
            NULL,
            4,
            (PBYTE)pPrinterInfo,
            cbBuf,
            &cbBuf,
            &cReturnedStructs)) {

        DBGMSG(DBG_ERROR, ("UMRDPPRN: EnumPrinters failed. Error: %ld.\n", GetLastError()));
        goto Cleanup;
    }

    DBGMSG(DBG_TRACE, ("UMRDPPRN: Found %ld Local printers on Session %ld.\n",
            cReturnedStructs, GETTHESESSIONID()));

    if (fImpersonated) {
        RevertToSelf();
        fImpersonated = FALSE;
    }

    //
    // Try to set one of the available printers as the default printer
    //

    for (i = 0; i < cReturnedStructs; i++) {

        if (pPrinterInfo[i].pPrinterName) {
            
            DWORD status = ERROR_SUCCESS;

            DBGMSG(DBG_TRACE, ("UMRDPPRN: EnumPrinters - #%ld; Printer Name - %ws.\n",
                i, pPrinterInfo[i].pPrinterName));

            //
            //impersonate before setting the default printer as the api
            //accesses hkcu. If the impersonation fails, the api will fail
            //and we will log an error. But, before logging an error, we will
            //need to revert to self.
            //

            if (!(fImpersonated = ImpersonateLoggedOnUser(UMRPDPPRN_TokenForLoggedOnUser))) {
                DBGMSG(DBG_TRACE, ("UMRDPDR:ImpersonateLoggedOnUser failed. Error:%ld.\n", GetLastError()));
            }
                
            if (!SetDefaultPrinter(pPrinterInfo[i].pPrinterName)) {
                //
                //save the last error
                //
                status = GetLastError();
            }

            //
            //if revert to self fails, consider it fatal
            //

            if (fImpersonated && !RevertToSelf()) {
                DBGMSG(DBG_TRACE, ("UMRDPDR:RevertToSelf failed. Error:%ld.\n", GetLastError()));
                fSuccess = FALSE;
                break;
            }
            
            fImpersonated = FALSE;

            if (status == ERROR_SUCCESS) {
                fSuccess = TRUE;
                DBGMSG(DBG_TRACE, ("UMRDPPRN: The printer %ws was set as the Default Printer.\n",
                    pPrinterInfo[i].pPrinterName));

                break;
            }
            else {
                WCHAR * param = pPrinterInfo[i].pPrinterName;

                DBGMSG(DBG_ERROR, ("UMRDPPRN: SetDefaultPrinter failed. Error: %ld\n",
                    status));

                TsLogError(EVENT_NOTIFY_SETDEFAULTPRINTER_FAILED,
                    EVENTLOG_ERROR_TYPE,
                    1,
                    &param,
                    __LINE__);
            }
        }
    }

Cleanup:

    if (fImpersonated) {
        RevertToSelf();
    }

    if (pPrinterInfo != NULL) {
        FREEMEM(pPrinterInfo);
    }

    DBGMSG(DBG_TRACE, ("UMRDPDR:SetDefaultPrinterToFirstFound Leaving. fSuccess is %d.\n", fSuccess));
    return fSuccess;
}

BOOL
HandlePrinterConfigChangeNotification(
    IN DWORD serverDeviceID
    )
/*++

Routine Description:

    Handle notification from the spooler that the config info of a printer has changed.

Arguments:

    serverDeviceID      - Server-assigned device ID associated with the printer

Return Value:

    Returns TRUE.

--*/
{
    DWORD ofs;
    time_t timeDelta;

    DBGMSG(DBG_TRACE, ("UMRDPPRN:HandlePrinterConfigChangeNotification entered.\n"));
    //
    //  If this is for one of our printers.
    //
    if (DRDEVLST_FindByServerDeviceID(DeviceList,
                                    serverDeviceID, &ofs)) {

        DBGMSG(DBG_TRACE, ("UMRDPPRN:Config Info for Printer %ws has changed.\n",
            DeviceList->devices[ofs].serverDeviceName));

        //
        //  The install time for the device needs to be beyond a configurable threshold
        //  before we will do anything about the change.  This eliminates forwarding
        //  unnecessary (non-user initiated) configuration changes to the client.
        //
        timeDelta = time(NULL) - DeviceList->devices[ofs].installTime;
        if ((DWORD)timeDelta > ConfigSendThreshold) {

            DBGMSG(DBG_TRACE,
                ("UMRDPPRN:Processing config change because outside change time delta.\n")
                );

            //
            //  Need to record that the configuration has changed and set a
            //  timer on forwarding to the client in order to compress changes into
            //  a single message to the client.
            //
            DeviceList->devices[ofs].fConfigInfoChanged = TRUE;
            TriggerConfigChangeTimer();
        }
        else {
            DBGMSG(DBG_TRACE,
                ("UMRDPPRN:Skipping config change because inside change time delta.\n")
                );
        }

    }
    return TRUE;
}

BOOL
SendPrinterConfigInfoToClient(
    IN PCWSTR printerName,
    IN LPBYTE pConfigInfo,
    IN DWORD  ConfigInfoSize
    )
/*++

Routine Description:

    Send a printer update cache data message to the client.

Arguments:

    printerName -   Name of printer.
    pConfigInfo -   Configuration Information.
    ConfigInfoSize -   size of config info.

Return Value:

    Return TRUE on success.  FALSE, otherwise.

--*/
{
    PRDPDR_PRINTER_CACHEDATA_PACKET cachedDataPacket;
    DWORD cachedDataPacketSize;
    PRDPDR_PRINTER_UPDATE_CACHEDATA cachedData;
    BOOL result;
    DWORD printerSz;
    PWSTR str;

    DBGMSG(DBG_TRACE, ("UMRDPPRN: SendPrinterConfigInfoToClient entered.\n"));
    DBGMSG(DBG_TRACE, ("UMRDPPRN:SendPrinterConfigInfoToClient printer name is %ws.\n",
            printerName));

    //
    //  Calculate the message size.
    //
    printerSz = ((wcslen(printerName) + 1) * sizeof(WCHAR));
    cachedDataPacketSize =  sizeof(RDPDR_PRINTER_CACHEDATA_PACKET) +
                            sizeof(RDPDR_PRINTER_UPDATE_CACHEDATA) +
                            printerSz +
                            ConfigInfoSize;

    //
    //  Allocate the message.
    //
    cachedDataPacket = (PRDPDR_PRINTER_CACHEDATA_PACKET)ALLOCMEM(
                                                    cachedDataPacketSize
                                                    );
    result = (cachedDataPacket != NULL);
    if (result) {

        PBYTE pData = NULL;
        //
        //  Set up the packet.
        //
        cachedDataPacket->Header.PacketId = DR_PRN_CACHE_DATA;
        cachedDataPacket->Header.Component = RDPDR_CTYP_PRN;
        cachedDataPacket->EventId = RDPDR_UPDATE_PRINTER_EVENT;

        //
        //  Set up the cached data.
        //
        cachedData = (PRDPDR_PRINTER_UPDATE_CACHEDATA)(
                            (PBYTE)cachedDataPacket +
                            sizeof(RDPDR_PRINTER_CACHEDATA_PACKET)
                            );
        cachedData->PrinterNameLen = printerSz;
        cachedData->ConfigDataLen = ConfigInfoSize;

        //
        //  Add the printer name.
        //
        str = (PWSTR)((PBYTE)cachedData + sizeof(RDPDR_PRINTER_UPDATE_CACHEDATA));
        wcscpy(str, printerName);

        //
        //  Add the config info.
        //
        pData = (PBYTE)str + printerSz;
        memcpy(pData, pConfigInfo, ConfigInfoSize);

        //
        //  Send the message to the client.
        //
        result = UMRDPDR_SendMessageToClient(
                                    cachedDataPacket,
                                    cachedDataPacketSize
                                    );

        // Release the buffer.
        FREEMEM(cachedDataPacket);
    }
    else {
        DBGMSG(DBG_ERROR, ("UMRDPPRN: Can't allocate cached data packet.\n"));
    }

    return result;
}

DWORD
GetPrinterConfigInfo(
    LPCWSTR printerName,
    LPBYTE * ppBuffer,
    LPDWORD pdwBufSize
    )
/*++

Routine Description:

    Gets the Printer configuration Information from PrintUI.

Arguments:

    printerName         - Name of the printer.
    ppBuffer            - A place holder for a buffer pointer.
                          This functions allocates memory and sends it out through this argument
                          The caller should free this memory.
    pdwBufSize          - size of allocated memory.

Return Value:

    Returns ERROR_SUCCESS if successful.

--*/
{
    WCHAR fileName[MAX_PATH];
    WCHAR tempPath[MAX_PATH];

    HANDLE hFile = INVALID_HANDLE_VALUE;

    DWORD dwResult;
    DWORD dwBytes;
    DWORD dwBytesRead;
    BOOL fImpersonated = FALSE;

    ASSERT(ppBuffer && pdwBufSize);
    *pdwBufSize = 0;

    //
    // Get Temp Folder
    // Impersonate first, so the file has the proper acls on it
    // Ignore the error, the worst case is caching will not be possible, as we create it with system acls
    // No security hole here
    //
    DBGMSG(DBG_TRACE, ("UMRDPPRN:GetPrinterConfigInfo entered.\n"));

    fImpersonated = ImpersonateLoggedOnUser(UMRPDPPRN_TokenForLoggedOnUser);
    
    dwResult = GetTempPathW(MAX_PATH, tempPath);
    if (dwResult > 0 && dwResult <= MAX_PATH) {
        GetTempFileNameW(tempPath, TEMP_FILE_PREFIX, 0, fileName);
    }
    else {
        GetTempFileNameW(L".", TEMP_FILE_PREFIX, 0, fileName);
    }

    DBGMSG(DBG_TRACE, ("UMRDPPRN:Temp File Name is %ws.\n", fileName));

    //
    //  While impersonating the logged on user, fetch the settings.
    //
    if (fImpersonated) {

        dwResult = CallPrintUiPersistFunc(printerName, fileName, 
                                          CMDLINE_FOR_STORING_CONFIGINFO_IMPERSONATE);
        RevertToSelf();

        if (dwResult != ERROR_SUCCESS) {
            DBGMSG(DBG_TRACE, ("UMRDPPRN:CallPrintUiPersistFunc failed with code: %ld\n", dwResult));
            goto Cleanup;
        }
    }
    else {
        dwResult = GetLastError();
        DBGMSG(DBG_TRACE, ("UMRDPPRN:ImpersonateLoggedOnUser: %ld\n", dwResult));
        goto Cleanup;
    }

    //
    // Open the file and read the contents to the buffer
    //

    hFile = CreateFileW(
        fileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );

    if (hFile == INVALID_HANDLE_VALUE) {
        dwResult = GetLastError();
        DBGMSG(DBG_TRACE, ("UMRDPPRN:CreateFileW failed with code: %ld\n", dwResult));
        goto Cleanup;
    }

    dwBytes = GetFileSize(hFile, NULL);

    *ppBuffer = (LPBYTE) ALLOCMEM(dwBytes);
    if (*ppBuffer == NULL) {
        dwResult = GetLastError();
        DBGMSG(DBG_TRACE, ("UMRDPPRN:AllocMem failed with code: %ld\n", dwResult));
        goto Cleanup;
    }

    if (!ReadFile(
            hFile,
            *ppBuffer,
            dwBytes,
            &dwBytesRead,
            NULL
            )) {
        dwResult = GetLastError();
        DBGMSG(DBG_TRACE, ("UMRDPPRN:ReadFile failed with code: %ld\n", dwResult));
        goto Cleanup;
    }

    * pdwBufSize = dwBytesRead;
    dwResult = ERROR_SUCCESS;

Cleanup:

    //
    // Close the file and delete it
    //

    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);

        DeleteFileW(fileName);
    }

    return dwResult;

}
DWORD
SetPrinterConfigInfo(
    LPCWSTR printerName,
    LPVOID lpBuffer,
    DWORD dwBufSize
    )
/*++

Routine Description:

    Sets the Printer configuration Information from the cache data.

Arguments:

    printerName         - Name of the printer.
    lpBuffer            - Cache data.
    pdwBufSize          - Size of Cache data.

Return Value:

    Returns ERROR_SUCCESS if successful.

--*/
{
    WCHAR fileName[MAX_PATH] = L"";
    WCHAR tempPath[MAX_PATH] = L"";

    HANDLE hFile = INVALID_HANDLE_VALUE;

    DWORD dwResult;
    DWORD dwBytes;
    BOOL fImpersonated = FALSE;

    DBGMSG(DBG_TRACE, ("UMRDPPRN:SetPrinterConfigInfo entered.\n"));
    DBGMSG(DBG_TRACE, ("UMRDPPRN:printerName is %ws.\n", printerName));
    DBGMSG(DBG_TRACE, ("UMRDPPRN:bufsize is %ld.\n", dwBufSize));

    //
    // Get Temp Folder
    // Impersonate first, so the file has the proper acls on it
    // Ignore the error, the worst case is caching will not be possible, as we create it with system acls
    // No security hole here
    //
    fImpersonated = ImpersonateLoggedOnUser(UMRPDPPRN_TokenForLoggedOnUser);

    if (!fImpersonated) {
        DBGMSG(DBG_TRACE, ("UMRDPPRN:SetPrinterConfigInfo Impersonation failed. Creating temp file in the context of system\n"));
    }

    dwResult = GetTempPathW(MAX_PATH, tempPath);
    if (dwResult > 0 && dwResult <= MAX_PATH) {
        dwResult = GetTempFileNameW(tempPath, TEMP_FILE_PREFIX, 0, fileName);
    }
    else {
        dwResult = GetTempFileNameW(L".", TEMP_FILE_PREFIX, 0, fileName);
    }

    if( dwResult == 0 ) {
        dwResult = GetLastError();
        DBGMSG(DBG_TRACE, ("UMRDPPRN:GetTempFileNameW failed with code: %ld\n", dwResult));
        goto Cleanup;
    }

    //
    // Save the contents to the file
    //

    hFile = CreateFileW(
        fileName,
        GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );

    if (hFile == INVALID_HANDLE_VALUE) {
        dwResult = GetLastError();
        DBGMSG(DBG_TRACE, ("UMRDPPRN:CreateFileW failed with code: %ld\n", dwResult));
        goto Cleanup;
    }

    if ((!WriteFile(
            hFile,
            lpBuffer,
            dwBufSize,
            &dwBytes,
            NULL
            )) ||
        (dwBytes < dwBufSize)) {
        dwResult = GetLastError();
        CloseHandle(hFile);
        DBGMSG(DBG_TRACE, ("UMRDPPRN:WriteFile failed with code: %ld\n", dwResult));
        goto Cleanup;
    }

    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }

    DBGMSG(DBG_TRACE, ("UMRDPPRN:fileName is %ws.\n", fileName));
    
    if (fImpersonated) {
        fImpersonated = !(RevertToSelf());
        DBGMSG(DBG_TRACE, ("UMRDPPRN:RevertToSelf %s\n", fImpersonated?"Failed":"Passed"));
    }

    //
    //  Call printui the first time as system.  We do this twice because
    //  some settings require that we be running as system vs. user.
    //
    dwResult = CallPrintUiPersistFunc(printerName, fileName, 
                                    CMDLINE_FOR_RESTORING_CONFIGINFO_NOIMPERSONATE);
    if (dwResult != ERROR_SUCCESS) {
        goto Cleanup;
    }

    //
    //  Call printui the second time as the logged on user.  
    //
    if (ImpersonateLoggedOnUser(UMRPDPPRN_TokenForLoggedOnUser)) {
        dwResult = CallPrintUiPersistFunc(printerName, fileName, 
                                    CMDLINE_FOR_RESTORING_CONFIGINFO_IMPERSONATE);
        RevertToSelf();
        if (dwResult != ERROR_SUCCESS) {
            goto Cleanup;
        }
    }
    else {
        dwResult = GetLastError();
        DBGMSG(DBG_ERROR, ("UMRDPPRN:  ImpersonateLoggedOnUser:  %08X\n", 
                dwResult));
    }

Cleanup:
    if (fImpersonated) {
        RevertToSelf();
    }

    if (hFile != INVALID_HANDLE_VALUE) {
        DeleteFileW(fileName);
    }

    return dwResult;
}

DWORD
CallPrintUiPersistFunc(
    LPCWSTR printerName,
    LPCWSTR fileName,
    LPCWSTR formatString
    )
/*++

Routine Description:

    Calls the PrintUI function for storing or restoring printer config info.

Arguments:

    printerName         - Name of the printer.
    fileName            - Name of the temp file.
    formatString        - PrintUI save/restore format string.

Return Value:

    Returns ERROR_SUCCESS if successful.

--*/
{
    WCHAR cmdLine[3 * MAX_PATH + (sizeof(CMDLINE_FOR_RESTORING_CONFIGINFO_NOIMPERSONATE)/sizeof(WCHAR)) + 2];
    WCHAR formattedPrinterName[(MAX_PATH+1)*2];
    WCHAR * pSource, * pDest;

    DWORD dwResult = ERROR_SUCCESS;

    DBGMSG(DBG_TRACE, ("UMRDPPRN:CallPrintUiPersistFunc Entered.\n"));

    ASSERT(PrintUIEntryFunc != NULL);
    ASSERT(printerName != NULL);
    ASSERT(fileName != NULL);

    //
    // Format the printer name
    //

    pSource = (WCHAR *)printerName;
    pDest = formattedPrinterName;

    while (*pSource) {
            if (*pSource == L'\"' || *pSource == L'@') {
                    *pDest++ = L'\\';
            }
            *pDest++ = *pSource++;
            //
            // pDest may have buffer overflow. Check for it.
            //
            if ((pDest - formattedPrinterName) >= 
                (sizeof(formattedPrinterName)/sizeof(formattedPrinterName[0]) - 1)) {
                return STATUS_BUFFER_OVERFLOW;
            }
    }
    *pDest = L'\0';

    //
    // Format the command line to be passed to PrintUI function
    //

    swprintf(cmdLine, formatString, formattedPrinterName, fileName);

    DBGMSG(DBG_TRACE, ("UMRDPPRN:cmdLine is: %ws\n", cmdLine));

    dwResult = (DWORD)PrintUIEntryFunc(
                NULL,           // Window handle
                PrintUILibHndl, // Handle to DLL instance.
                cmdLine,        // Command Line
                TRUE
                );

    DBGMSG(DBG_TRACE, ("UMRDPPRN:PrintUiEntryFunc returned: %ld\n", dwResult));

    return dwResult;
}

void
WaitableTimerSignaled(
    HANDLE waitableObject,
    PVOID clientData
    )
/*++

Routine Description:

    Goes through the device list checking if the config info has changed
    for any of the printers. If so, sends the config info to the client.

Arguments:

    waitableObject  -   Associated waitable object.
    clientData      -   Ignored.

Return Value:

    NONE.

--*/
{
    DWORD dwResult = ERROR_SUCCESS;
    DWORD i;
    BOOL fImpersonated;
    LARGE_INTEGER li;
    DBGMSG(DBG_TRACE, ("UMRDPPRN: WaitableTimerSignaled Entered.\n"));

    //
    // Compute as large number as possible, but do not overflow.
    //
    li.QuadPart = Int32x32To64(INFINITE_WAIT_PERIOD, INFINITE_WAIT_PERIOD);
    li.QuadPart *= -1; //relative time
    //
    // Reset the waitable timer to a non-signaled state.
    // We don't want it signaled until we do a TriggerConfigChangeTimer.
    // So, set the time interval to a very large number.
    //
    ASSERT(g_fTimerSet);
    ASSERT(waitableObject == WaitableTimer);
    
    if (!SetWaitableTimer(waitableObject,
                          &li,
                          0,
                          NULL,
                          NULL,
                          FALSE)) {
        DBGMSG(DBG_TRACE, ("UMRDPPRN:SetWaitableTimer Failed."
                "Error: %ld.\n", GetLastError()));
    }
    //
    // Now, kill the timer
    // TODO: Do we really need this?
    //
    if (!CancelWaitableTimer(waitableObject)) {
        DBGMSG(DBG_ERROR, ("UMRDPPRN: CancelWaitableTimer failed."
                "Error: %ld\n", GetLastError()));
    }
    g_fTimerSet = FALSE;
    //
    // Iterate the Devices List to see if config Info has changed for any
    //

    for (i = 0; i < DeviceList->deviceCount; i++) {
        if (DeviceList->devices[i].fConfigInfoChanged) {

            LPBYTE pConfigData = NULL;
            DWORD size = 0;

            //
            // reset error code in order to process next item
            //
            dwResult = ERROR_SUCCESS;

            // Reset the flag
            DeviceList->devices[i].fConfigInfoChanged = FALSE;

            DBGMSG(DBG_INFO, ("UMRDPPRN: Trying to Get ConfigInfo for the printer %ws\n",
                DeviceList->devices[i].serverDeviceName));

            //
            // Get the printer config info.
            //
            if (dwResult == ERROR_SUCCESS) {
                dwResult = GetPrinterConfigInfo(
                    DeviceList->devices[i].serverDeviceName,
                    &pConfigData, &size);
            }

            if (dwResult == ERROR_SUCCESS) {

                // Send this info to the client
                SendPrinterConfigInfoToClient(
                    DeviceList->devices[i].clientDeviceName,
                    pConfigData,
                    size
                    );
            }

            if (pConfigData) {
                FREEMEM(pConfigData);
            }
        }
    }

    DBGMSG(DBG_TRACE, ("UMRDPPRN: Leaving WaitableTimerSignaled.\n"));
}

BOOL
SendPrinterRenameToClient(
    IN PCWSTR oldprinterName,
    IN PCWSTR newprinterName
    )
/*++

Routine Description:

    Send a printer update cache data message to the client.

Arguments:

    oldprinterName -   Old Name of printer.
    newprinterName -   New Name of printer.

Return Value:

    Return TRUE on success.  FALSE, otherwise.

--*/
{
    PRDPDR_PRINTER_CACHEDATA_PACKET cachedDataPacket;
    DWORD cachedDataPacketSize;
    PRDPDR_PRINTER_RENAME_CACHEDATA cachedData;
    BOOL result;
    DWORD oldNameLen, newNameLen;
    PWSTR str;

    DBGMSG(DBG_TRACE, ("UMRDPPRN: SendPrinterRenameToClient entered.\n"));
    DBGMSG(DBG_TRACE, ("UMRDPPRN:SendPrinterRenameToClient Old printer name is %ws.\n",
            oldprinterName));
    DBGMSG(DBG_TRACE, ("UMRDPPRN:SendPrinterRenameToClient New printer name is %ws.\n",
            newprinterName));

    //
    //  Calculate the message size.
    //
    oldNameLen = (oldprinterName) ? ((wcslen(oldprinterName) + 1) * sizeof(WCHAR)) : 0;
    newNameLen = (newprinterName) ? ((wcslen(newprinterName) + 1) * sizeof(WCHAR)) : 0;

    if (!(oldNameLen && newNameLen)) {
        DBGMSG(DBG_TRACE, ("UMRDPPRN: Printer name is empty. Returning FALSE\n"));
        return FALSE;
    }

    cachedDataPacketSize =  sizeof(RDPDR_PRINTER_CACHEDATA_PACKET) +
                            sizeof(RDPDR_PRINTER_RENAME_CACHEDATA) +
                            oldNameLen + newNameLen;

    //
    //  Allocate the message.
    //
    cachedDataPacket = (PRDPDR_PRINTER_CACHEDATA_PACKET)ALLOCMEM(
                                                    cachedDataPacketSize
                                                    );
    result = (cachedDataPacket != NULL);
    if (result) {
        //
        //  Set up the packet.
        //
        cachedDataPacket->Header.PacketId = DR_PRN_CACHE_DATA;
        cachedDataPacket->Header.Component = RDPDR_CTYP_PRN;
        cachedDataPacket->EventId = RDPDR_RENAME_PRINTER_EVENT;

        //
        //  Set up the cached data.
        //
        cachedData = (PRDPDR_PRINTER_RENAME_CACHEDATA)(
                            (PBYTE)cachedDataPacket +
                            sizeof(RDPDR_PRINTER_CACHEDATA_PACKET)
                            );
        cachedData->OldPrinterNameLen = oldNameLen;
        cachedData->NewPrinterNameLen = newNameLen;

        //
        //  Add the printer names.
        //
        str = (PWSTR)((PBYTE)cachedData + sizeof(RDPDR_PRINTER_RENAME_CACHEDATA));
        wcscpy(str, oldprinterName);

        str = (PWSTR)((PBYTE)str + oldNameLen);
        wcscpy(str, newprinterName);

        //
        //  Send the message to the client.
        //
        result = UMRDPDR_SendMessageToClient(
                                    cachedDataPacket,
                                    cachedDataPacketSize
                                    );

        // Release the buffer.
        FREEMEM(cachedDataPacket);
    }

    DBGMSG(DBG_TRACE, ("UMRDPPRN: SendPrinterRenameToClient Leaving.\n"));

    return result;
}

VOID LoadConfigurableValues()
/*++

Routine Description:

    Load configurable values out of the registry.

Arguments:

Return Value:

--*/
{
    LONG status;
    HKEY regKey;
    LONG sz;
    BOOL fetchResult;
    LONG s;

    DBGMSG(DBG_TRACE, ("UMRDPPRN: LoadConfigurableValues entered.\n"));

    //
    //  Open the top level reg key for configurable resources.
    //
    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, CONFIGREGKEY, 0,
                          KEY_READ, &regKey);

    //
    //  Read the configurable threshold for delta between printer installation
    //  time and forwarding of first user-initiated configuration change data
    //  to the client.  The units for this value is in seconds.
    //
    if (status == ERROR_SUCCESS) {
        sz = sizeof(ConfigSendThreshold);
        s = RegQueryValueEx(regKey, CONFIGTHRESHOLDREGVALUE, NULL,
                                NULL, (PBYTE)&ConfigSendThreshold, &sz);
        if (s != ERROR_SUCCESS) {
            ConfigSendThreshold = CONFIGTHRESHOLDDEFAULT;
            DBGMSG(DBG_WARN,
                ("UMRDPPRN: LoadConfigurableValues can't read config threshold:  %ld.\n", s));
        }
    }
    else {
        regKey = NULL;
    }

    DBGMSG(DBG_TRACE,
        ("UMRDPPRN:Config. change threshold is %ld.\n",
        ConfigSendThreshold)
        );

    //
    //  Read the location of the user-configurable Client Driver Name Mapping INF.
    //
    ASSERT(UserDefinedMappingINFName == NULL);
    ASSERT(UserDefinedMappingINFSection == NULL);
    fetchResult = FALSE;
    if (status == ERROR_SUCCESS) {
        fetchResult = TSNUTL_FetchRegistryValue(
                                            regKey,
                                            CONFIGUSERDEFINEDMAPPINGINFNAMEVALUE,
                                            (PBYTE *)&UserDefinedMappingINFName
                                            );
    }

    //
    //  Read the section name of the user-configurable Client Driver Name Mapping INF.
    //
    if ((status == ERROR_SUCCESS) && fetchResult) {
        fetchResult = TSNUTL_FetchRegistryValue(
                                regKey,
                                CONFIGUSERDEFINEDMAPPINGINFSECTIONVALUE,
                                (PBYTE *)&UserDefinedMappingINFSection
                                );
        if (!fetchResult) {
            ASSERT(UserDefinedMappingINFSection == NULL);
            FREEMEM(UserDefinedMappingINFName);
            UserDefinedMappingINFName = NULL;
        }
    }


    //
    //  Close the parent reg key.
    //
    if (regKey != NULL) {
        RegCloseKey(regKey);
    }

    DBGMSG(DBG_TRACE, ("UMRDPPRN: LoadConfigurableValues exiting.\n"));
}

HANDLE
RegisterForPrinterPrefNotify()
/*++

Routine Description:

    Register for changes to one of this session's printers' Printing
    Preferences.

Arguments:

Return Value:

    Handle to an event that will be signaled when the printing preferences
    change for one of this session's printers.  NULL is returned on error.

--*/
{
    LONG ret;
    HANDLE hEvent;
    BOOL impersonated=FALSE;
    NTSTATUS status;
    HANDLE hKeyCurrentUser=INVALID_HANDLE_VALUE;

    DBGMSG(DBG_TRACE, ("UMRDPPRN: RegisterForPrinterPrefNotify entered.\n"));

    //
    //  Open the event.
    //
    hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (hEvent == NULL) {
        DBGMSG(DBG_ERROR,
            ("UMRDPPRN: can't create event:  %ld.\n",
            GetLastError()));
    }

    //
    //  Need to impersonate the logged in user so we can get to the right
    //  dev mode.
    //
    if (hEvent != NULL) {
        if ((UMRPDPPRN_TokenForLoggedOnUser == INVALID_HANDLE_VALUE) ||
            !ImpersonateLoggedOnUser(UMRPDPPRN_TokenForLoggedOnUser)) {
                DBGMSG(DBG_ERROR, ("UMRDPPRN: can't impersonate user %ld.\n",
                    GetLastError()));
            CloseHandle(hEvent);
            hEvent = NULL;
            impersonated = FALSE;
        }
        else {
            impersonated = TRUE;
        }
    }

    //
    //  Attempt to open the the HKEY_CURRENT_USER predefined handle.
    //
    if (hEvent != NULL) {
        status = RtlOpenCurrentUser(KEY_ALL_ACCESS, &hKeyCurrentUser);
        if (!NT_SUCCESS(status)) {
            DBGMSG(DBG_ERROR, ("UMRDPPRN: can't open HKCU:  %08X.\n",status));
            CloseHandle(hEvent);
            hEvent = NULL;
        }
    }

    //
    //  Open the printing system dev mode for this user.  If it doesn't exist,
    //  it will be created. This key is changed when a user modifies their printing
    //  preferences.
    //
    if (hEvent != NULL) {
        ASSERT(DevModeHKey == INVALID_HANDLE_VALUE);
        ret = RegCreateKeyEx(
                        hKeyCurrentUser,                    // handle to an open key
                        TEXT("Printers\\DevModePerUser"),   // address of subkey name
                        0,                                  // reserved
                        NULL,                               // address of class string
                        REG_OPTION_NON_VOLATILE,            // special options flag
                        KEY_ALL_ACCESS,                     // desired security access
                        NULL,                               // key security structure
                        &DevModeHKey,                       // buffer for opened handle
                        NULL                                // disposition value buffer
                        );

        if (ret != ERROR_SUCCESS) {
            DBGMSG(DBG_ERROR,
                ("UMRDPPRN: can't open printing dev mode:  %ld.\n", ret)
                );
            CloseHandle(hEvent);
            hEvent = NULL;
            DevModeHKey = INVALID_HANDLE_VALUE;
        }
    }

    //
    //  Revert back to the system user.
    //
    if (impersonated) {
        RevertToSelf();
    }

    //
    //  Register for notification on this key.
    //
    if (hEvent != NULL) {
        ret = RegNotifyChangeKeyValue(
                              DevModeHKey,
                              TRUE,
                              REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,
                              hEvent,
                              TRUE
                              );
        if (ret != ERROR_SUCCESS) {
            DBGMSG(DBG_ERROR,
                ("UMRDPPRN: can't register for registry key change event:  %ld.\n",
                ret));
            CloseHandle(hEvent);
            hEvent = NULL;
        }
    }

    //
    //  Close the handle to HKCU.
    //
    if (hKeyCurrentUser != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKeyCurrentUser);
    }

    //
    //  Log an event on error.
    //
    if (hEvent == NULL) {
        TsLogError(
            EVENT_NOTIFY_FAILEDTOREGFOR_SETTING_NOTIFY,
            EVENTLOG_ERROR_TYPE,
            0,
            NULL,
            __LINE__
            );
    }

    DBGMSG(DBG_TRACE, ("UMRDPPRN: RegisterForPrinterPrefNotify done.\n"));

    return hEvent;
}

/*++

Routine Description:

    Check if a specific printer driver already installed.

Arguments:

    clientDriver            -   Client Driver Name.

Return Values:

    ERROR_SUCCESS if driver already installed.
    ERROR_FILE_NOT_FOUND if driver is not installed.
    or other error code

--*/
DWORD PrinterDriverInstalled(
    IN PCWSTR clientDriver
    )
{
    PDRIVER_INFO_1 pDrivers = NULL;
    DWORD cbNeeded;
    DWORD cbAllocated;
    DWORD cbReturned;
    DWORD dwStatus = ERROR_FILE_NOT_FOUND;
    BOOL bSuccess;
    DWORD i;

    DBGMSG(DBG_TRACE, ("UMRDPPRN: PrinterDriverInstalled looking for %ws.\n", clientDriver));

    //
    //  Return immediately if the DLL is trying to shut down.  This
    //  is to help prevent us from getting stuck in a system call.
    //
    if( ShutdownFlag ) {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    bSuccess = EnumPrinterDrivers(
                            NULL,
                            NULL,
                            1,          // we only need a list of driver name
                            (LPBYTE) pDrivers,
                            0,
                            &cbNeeded,
                            &cbReturned
                        );

    if( TRUE == bSuccess || ( dwStatus = GetLastError() ) == ERROR_INSUFFICIENT_BUFFER ) {

        //
        //  Return immediately if the DLL is trying to shut down.  This
        //  is to help prevent us from getting stuck in a system call.
        //
        if( ShutdownFlag ) {
            dwStatus = ERROR_SHUTDOWN_IN_PROGRESS;
        }
        else {

            pDrivers = (PDRIVER_INFO_1)ALLOCMEM( cbAllocated = cbNeeded );

            if( NULL != pDrivers ) {
                bSuccess = EnumPrinterDrivers(
                                    NULL,
                                    NULL,
                                    1,          // we only need a list of driver name
                                    (LPBYTE)pDrivers,
                                    cbAllocated,
                                    &cbNeeded,
                                    &cbReturned
                                );

                if( TRUE == bSuccess ) {
                    //
                    // loop thru entire list to find out if interested driver
                    // exists on local machine.
                    // Return immediately if the DLL is trying to shut down.  This
                    // is to help prevent us from getting stuck in a system call.
                    //
                    dwStatus = ERROR_FILE_NOT_FOUND;

                    for( i=0; FALSE == ShutdownFlag && i < cbReturned; i++ ) {
                        if( 0 == _wcsicmp( pDrivers[i].pName, clientDriver ) ) {
                            dwStatus = ERROR_SUCCESS;
                            break;
                        }
                    }

                    if( ShutdownFlag ) {
                        dwStatus = ERROR_SHUTDOWN_IN_PROGRESS;
                    }
                }
                else {
                    dwStatus = GetLastError();
                }

                FREEMEM( pDrivers );

            }
            else {
                dwStatus = GetLastError();
            }
        }
    }

    DBGMSG(DBG_TRACE, ("UMRDPPRN: PrinterDriverInstalled done with %ld.\n", dwStatus));

    return dwStatus;
}

/*++

Routine Description:

    Map a client printer driver name to a server printer driver name,
    if a mapping is defined in ntprint.inf or the inf that is available
    to the end-user.

Arguments:

    clientDriver            -   Client driver name.
    mappedName              -   Pointer to mapped driver name buffer.  Should
                                be released if the mapping is successful.
    mappedNameBufSize       -   Returned size of mapped driver name buffer.

Return Value:

    TRUE if the client driver name was mapped.

--*/
BOOL MapClientPrintDriverName(
    IN  PCWSTR clientDriver,
    IN OUT PWSTR *mappedName,
    IN OUT DWORD *mappedNameBufSize
    )
{
    BOOL clientDriverMapped = FALSE;
    ULONG requiredSize;
    USHORT nNumPrintSections;

    DBGMSG(DBG_TRACE, ("UMRDPPRN: MapClientPrintDriverName with %ws.\n", clientDriver));


    //
    //  First, check the user-defined INF section if it is so configured.
    //
    if ((UserDefinedMappingINFName != NULL) &&
        (UserDefinedMappingINFSection != NULL)) {
        while (!(clientDriverMapped =
            RDPDRUTL_MapPrintDriverName(
                    clientDriver, UserDefinedMappingINFName,
                    UserDefinedMappingINFSection, 0, 1,
                    *mappedName,
                    (*mappedNameBufSize) / sizeof(WCHAR),
                    &requiredSize
                    )) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
            if (!UMRDPDR_ResizeBuffer(&MappedDriverNameBuf, requiredSize * sizeof(WCHAR),
                                &MappedDriverNameBufSize)) {
                break;
            }
        }
    }

    if( clientDriverMapped ) {
        goto Done;
    }

    //
    // Client does not send over platform info (NT4, Win9x...) so try both
    // upgrade file
    //

    //
    // printupg.inf contain block driver and its mapping to inbox driver which
    // is not in ntprint.inf.
    //
    
    nNumPrintSections = 0;
    
    while( (NULL != prgwszPrinterSectionNames[nNumPrintSections]) &&
           !(clientDriverMapped =
            RDPDRUTL_MapPrintDriverName(
                    clientDriver,
                    L"printupg.inf",
                    prgwszPrinterSectionNames[nNumPrintSections++], 
                    0, 
                    1,
                    *mappedName,
                    (*mappedNameBufSize) / sizeof(WCHAR),
                    &requiredSize
                    ))&& 
           (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        if (!UMRDPDR_ResizeBuffer(&MappedDriverNameBuf, requiredSize * sizeof(WCHAR),
                            &MappedDriverNameBufSize)) {
            break;
        }
    }




    if( clientDriverMapped ) {
        goto Done;
    }

    //
    // if still can't find a mapping, try using prtupg9x.inf
    //

    while( !(clientDriverMapped =
            RDPDRUTL_MapPrintDriverName(
                    clientDriver,
                    L"prtupg9x.inf",
                    L"Printer Driver Mapping", 0, 1,
                    *mappedName,
                    (*mappedNameBufSize) / sizeof(WCHAR),
                    &requiredSize
                    )) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER) ) {
        if (!UMRDPDR_ResizeBuffer(&MappedDriverNameBuf, requiredSize * sizeof(WCHAR),
                            &MappedDriverNameBufSize)) {
            break;
        }
    }

    if( clientDriverMapped ) {
        goto Done;
    }

    //
    //  If we didn't get a match, then check the "Previous Names" section
    //  of ntprint.inf.  Source and destination fields are kind of backwards
    //  in ntprint.inf.
    //
    if (!clientDriverMapped) {
        while (!(clientDriverMapped =
            RDPDRUTL_MapPrintDriverName(
                    clientDriver, L"ntprint.inf",
                    L"Previous Names", 1, 0,
                    *mappedName,
                    (*mappedNameBufSize) / sizeof(WCHAR),
                    &requiredSize
                    )) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
            if (!UMRDPDR_ResizeBuffer(&MappedDriverNameBuf, requiredSize * sizeof(WCHAR),
                                &MappedDriverNameBufSize)) {
                break;
            }
        }
    }

Done:

    if(clientDriverMapped) {
        DBGMSG(DBG_TRACE, ("UMRDPPRN: MapClientPrintDriverName returns %ws.\n", *mappedName));
    }

    return clientDriverMapped;
}

BOOL
GetPrinterPortName(
    IN  HANDLE hPrinter,
    OUT PWSTR *portName
    )
/*++

Routine Description:

    Get the port name for an open printer.

Arguments:

    hPrinter    -   Open printer handle.
    portName    -   Port name

Return Value:

    Return TRUE on success.  FALSE, otherwise.

--*/
{
    BOOL result;
    DWORD sz;

    //
    //  Size our printer info level 2 buffer.
    //
    result = !GetPrinter(hPrinter, 2, NULL, 0, &sz) &&
                    (GetLastError() == ERROR_INSUFFICIENT_BUFFER);
    if (result) {
        result = UMRDPDR_ResizeBuffer(
                            &PrinterInfo2Buf,
                            sz, &PrinterInfo2BufSize
                            );
    }

    //
    //  Get printer info level 2 for the new printer.
    //
    if (result) {
        result = GetPrinter(hPrinter, 2, (char *)PrinterInfo2Buf,
                            PrinterInfo2BufSize, &sz);
    }

    if (result) {
        *portName = &PrinterInfo2Buf->pPortName[0];
    }
    else {
        DBGMSG(DBG_ERROR, ("UMRDPDR:Error fetching printer port name."));
    }
    return result;
}

BOOL
SaveDefaultPrinterContext(PCWSTR currentlyInstallingPrinterName)
/*++

Routine Description:

    Save current contextual information for the active user's default
    printer, so it can be restored on printer deletion.

Arguments:

Return Value:

    TRUE is returned on success.  Otherwise, FALSE is returned and
    GetLastError() can be used for retrieving extended error information.

--*/
{
    BOOL result;
    DWORD bufSize;
    DWORD status = ERROR_SUCCESS;
    BOOL fImpersonated = FALSE;


    DBGMSG(DBG_TRACE, ("UMRDPPRN: SaveDefaultPrinterContext entered.\n"));

    //
    //  Save the name of the current default printer, in RAM.
    //
    bufSize = sizeof(SavedDefaultPrinterName) / sizeof(SavedDefaultPrinterName[0]);

    //
    //impersonate first
    //

    if (!(fImpersonated = ImpersonateLoggedOnUser(UMRPDPPRN_TokenForLoggedOnUser))) {
            DBGMSG(DBG_TRACE, ("UMRDPDR:ImpersonateLoggedOnUser failed. Error:%ld.\n", GetLastError()));
    }

    if (!(result = GetDefaultPrinter(SavedDefaultPrinterName, &bufSize))) {
        status = GetLastError();
    }

    if (fImpersonated && !RevertToSelf()) {
        DBGMSG(DBG_TRACE, ("UMRDPDR:RevertToSelf failed. Error:%ld.\n", GetLastError()));
        result = FALSE;
    }
    //
    // 645988:Check if the just installed TS printer is the default printer.
    // Since we haven't set it as a TS printer yet, the RDPDRUTL_PrinterIsTs()
    // function will return false and we save this as global default.
    // That will cause problems later when we try to
    // restore the default printer context.
    //
    if (_wcsicmp(currentlyInstallingPrinterName, SavedDefaultPrinterName) == 0) {
        //
        // Clear the default printer name to 
        // indicate we haven't found any yet.
        //
        wcscpy(SavedDefaultPrinterName, L"");
        result = FALSE;
        goto Exit;
    }
    
    //
    //  If the current default printer is a non-TS printer, store its
    //  name in a global reg. key for this user.  That way, it can be
    //  saved when this session or some other session for this user
    //  disconnects/logs out.
    //
    if (result) {
        if (!RDPDRUTL_PrinterIsTS(SavedDefaultPrinterName)) {
            result = SavePrinterNameAsGlobalDefault(SavedDefaultPrinterName);
        }
    }
    else {
        DBGMSG(DBG_ERROR, ("UMRDPPRN: Error fetching def printer:  %ld.\n",
            status));
    }

    DBGMSG(DBG_TRACE, ("UMRDPPRN: SaveDefaultPrinterContext exiting.\n"));
Exit:
    return result;
}

BOOL
SavePrinterNameAsGlobalDefault(
    IN PCWSTR printerName
 )
/*++

Routine Description:

    Save the specified printer in the registry so it is visible to all
    other sessions for this user as the last known default printer.

Arguments:

    printerName -   Printer name.

Return Value:

    TRUE is returned on success.  Otherwise, FALSE is returned and
    GetLastError() can be used for retrieving extended error information.

--*/
{
    BOOL result;
    WCHAR *sidAsText = NULL;
    HKEY regKey = NULL;
    DWORD sz;
    PSID pSid;
    DWORD status;

    DBGMSG(DBG_TRACE, ("UMRDPPRN: SavePrinterNameAsGlobalDefault entered.\n"));

    //
    //  Get the user's SID.  This is how we uniquely identify the user.
    //
    pSid = TSNUTL_GetUserSid(UMRPDPPRN_TokenForLoggedOnUser);
    result = pSid != NULL;

    //
    //  Get a textual representation of the session user's SID.
    //
    if (result) {
        sz = 0;
        result = TSNUTL_GetTextualSid(pSid, NULL, &sz);
        ASSERT(!result);
        if (!result && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
            sidAsText = (WCHAR *)ALLOCMEM(sz);
            if (sidAsText != NULL) {
                result = TSNUTL_GetTextualSid(pSid, sidAsText, &sz);
            }
        }
    }

    //
    //  Open the reg key.
    //
    if (result) {
        status = RegCreateKey(
                            HKEY_LOCAL_MACHINE, USERDEFAULTPRNREGKEY,
                            &regKey
                            );
        result = status == ERROR_SUCCESS;
        if (!result) {
            DBGMSG(DBG_ERROR, ("UMRDPPRN:  RegCreateKey failed for %s:  %ld.\n",
                    USERDEFAULTPRNREGKEY, status));
        }
    }

    //
    //  Write the value for the default printer.
    //
    if (result) {
        sz = (wcslen(printerName) + 1) * sizeof(WCHAR);
        status = RegSetValueEx(regKey, sidAsText, 0, REG_SZ, (PBYTE)printerName, sz);
        result = status == ERROR_SUCCESS;
        if (!result) {
            DBGMSG(DBG_ERROR, ("UMRDPPRN:  RegSetValueEx failed for %s:  %ld.\n",
                    sidAsText, status));
        }
    }

    //
    //  Clean up.
    //
    if (sidAsText != NULL)  FREEMEM(sidAsText);
    if (regKey != NULL)     RegCloseKey(regKey);
    if (pSid != NULL)       FREEMEM(pSid);

    DBGMSG(DBG_TRACE, ("UMRDPPRN: SavePrinterNameAsGlobalDefault exiting.\n"));

    return result;
}

BOOL
RestoreDefaultPrinterContext()
/*++

Routine Description:

    Restore the most recent default printer context, as saved via a call to
    SaveDefaultPrinterContext.

Arguments:

Return Value:

    TRUE is returned on success.  Otherwise, FALSE is returned and
    GetLastError() can be used for retrieving extended error information.

--*/
{
    BOOL result;
    HANDLE hPrinter;
    PRINTER_DEFAULTS printerDefaults = {NULL, NULL, PRINTER_ACCESS_USE};

    WCHAR *sidAsText = NULL;
    HKEY regKey = NULL;
    DWORD sz;
    PSID pSid = NULL;
    DWORD status;

    WCHAR savedDefaultPrinter[MAX_PATH];

    WCHAR *nameToRestore = NULL;

    DBGMSG(DBG_TRACE, ("UMRDPPRN: RestoreDefaultPrinterContext entered.\n"));

    //
    //  Assume that we will succeed.
    //
    result = TRUE;

    //
    //  Restore the default printer name stored in RAM, if it exists.
    //
    if (wcscmp(SavedDefaultPrinterName, L"") &&
            OpenPrinter(SavedDefaultPrinterName, &hPrinter, &printerDefaults)) {
        ClosePrinter(hPrinter);
        nameToRestore = &SavedDefaultPrinterName[0];
    }

    //
    //  If the default printer name saved in RAM does not exist, then we need
    //  to save the one that is saved in the registry, if it exists.
    //
    if (nameToRestore == NULL) {

        BOOL intermediateResult;

        //
        //  Get the user's SID.  This is how we uniquely identify the user.
        //
        pSid = TSNUTL_GetUserSid(UMRPDPPRN_TokenForLoggedOnUser);
        intermediateResult = pSid != NULL;

        //
        //  Get a textual representation of the session user's SID.
        //
        if (intermediateResult) {
            sz = 0;
            intermediateResult = TSNUTL_GetTextualSid(pSid, NULL, &sz);
            ASSERT(!intermediateResult);
            if (!intermediateResult && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
                sidAsText = (WCHAR *)ALLOCMEM(sz);
                if (sidAsText != NULL) {
                    intermediateResult = TSNUTL_GetTextualSid(pSid, sidAsText, &sz);
                }
            }
        }

        //
        //  Open the reg key.
        //
        if (intermediateResult) {
            status = RegCreateKey(
                                HKEY_LOCAL_MACHINE, USERDEFAULTPRNREGKEY,
                                &regKey
                                );
            intermediateResult = status == ERROR_SUCCESS;
            if (!intermediateResult) {
                DBGMSG(DBG_ERROR, ("UMRDPPRN:  RegCreateKey failed for %s:  %ld.\n",
                        USERDEFAULTPRNREGKEY, status));
            }
        }

        //
        //  Read the value.
        //
        if (intermediateResult) {
            DWORD type;
            DWORD sz = sizeof(savedDefaultPrinter);
            status = RegQueryValueEx(
                            regKey, sidAsText, 0,
                            &type, (PBYTE)savedDefaultPrinter, &sz
                            );
            if (status == ERROR_SUCCESS) {
                intermediateResult = TRUE;
                ASSERT(type == REG_SZ);
                nameToRestore = savedDefaultPrinter;
            }
        }

        //
        //  If we got a value, then that means we will be restoring the
        //  one from the registry.  That also means that we should whack the
        //  registry value to be a good citizen.
        //
        if (intermediateResult) {
            status = RegDeleteValue(regKey, sidAsText);
            if (status != ERROR_SUCCESS) {
                DBGMSG(DBG_ERROR, ("UMRDPPRN:  Can't delete reg value %s:  %ld\n",
                        sidAsText, status));
            }
        }
    }

    //
    //  If we have a name to restore, then do so.
    //
    if (nameToRestore != NULL) {
        
        BOOL fImpersonated = FALSE;
        
        //
        //impersonate before setting the default printer as the api
        //accesses hkcu. If the impersonation fails, the api will fail
        //and we will log an error. But, before logging an error, we will
        //need to revert to self.
        //
        if (!(fImpersonated = ImpersonateLoggedOnUser(UMRPDPPRN_TokenForLoggedOnUser))) {
            DBGMSG(DBG_TRACE, ("UMRDPDR:ImpersonateLoggedOnUser failed. Error:%ld.\n", GetLastError()));
        }

        result = SetDefaultPrinter(nameToRestore);

        //
        //if revert to self fails, consider it fatal
        //
        if (fImpersonated && !RevertToSelf()) {
            DBGMSG(DBG_TRACE, ("UMRDPDR:RevertToSelf failed. Error:%ld.\n", GetLastError()));
            result = FALSE;
        }


        if (!result) {
            WCHAR * param = nameToRestore;
            TsLogError(EVENT_NOTIFY_SETDEFAULTPRINTER_FAILED,
                EVENTLOG_ERROR_TYPE,
                1,
                &param,
                __LINE__);
        }
    }

    //
    //  If we don't have a name to restore of the restore failed, then
    //  just restore the first printer we find.
    //
    if (nameToRestore == NULL) {

        //
        //  If we still don't have a printer name to restore, then we should
        //  just restore the first printer we find.
        //
        result = SetDefaultPrinterToFirstFound(TRUE);
    }

    //
    //  Clean up.
    //
    if (sidAsText != NULL) FREEMEM(sidAsText);
    if (regKey != NULL)    RegCloseKey(regKey);
    if (pSid != NULL)      FREEMEM(pSid);

    DBGMSG(DBG_TRACE, ("UMRDPPRN: RestoreDefaultPrinterContext exiting.\n"));

    return result;
}


BOOL SplitName(
    IN OUT LPTSTR pszFullName,
       OUT LPCTSTR *ppszServer,
       OUT LPCTSTR *ppszPrinter,
    IN     BOOL    bCheckDoubleSlash)

/*++

    Splits a fully qualified printer connection name into server and
    printer name parts. If the function fails then none of the OUT
    parameters are modified.

Arguments:

    pszFullName - Input name of a printer.  If it is a printer
        connection (\\server\printer), then we will split it.

    ppszServer - Receives pointer to the server string.

    ppszPrinter - Receives a pointer to the printer string.

    bCheckDoubleSlash - if TRUE check that the name begins with "\\".
        If FALSE, the first character is the first character of the server.

Return Value: TRUE if everything is found as expected. FALSE otherwise.

--*/

{
    LPTSTR pszPrinter;
    LPTSTR pszTmp;

    if (bCheckDoubleSlash) {

        if (pszFullName[0] == TEXT('!') && pszFullName[1] == TEXT('!')) {

            pszTmp = pszFullName + 2;

        } else {

            return FALSE;
        }

    } else {

        pszTmp = pszFullName;
    }

    pszPrinter = wcschr(pszTmp, TEXT('!'));

    if (pszPrinter)
    {
        //
        // We found the backslash; null terminate the previous
        // name.
        //
        *pszPrinter++ = 0;

        *ppszServer = pszTmp;
        *ppszPrinter = pszPrinter;

        return TRUE;
    }

    return FALSE;
}

void FormatPrinterName(
    PWSTR pszNewNameBuf,
    ULONG ulBufLen,
    ULONG ulFlags,
    PTS_PRINTER_NAMES pPrinterNames)
{

    WCHAR   szSessionId[MAXSESSIONIDCHARS];
    PWSTR   pszRet  = NULL;
    PWSTR   pszFormat;
    DWORD   dwBytes = 0;
    const WCHAR * pStrings[4];

    lstrcpyn(pPrinterNames->szTemp, pPrinterNames->pszFullName, pPrinterNames->ulTempLen);

    // TS and network printer: \\Server\Client\Printer
    // non TS network printer: \\Server\Printer
    // TS non network printer: \\Client\Printer

    if (ulFlags & RDPDR_PRINTER_ANNOUNCE_FLAG_NETWORKPRINTER) {

        if (SplitName(pPrinterNames->szTemp,
                      &(pPrinterNames->pszServer),
                      &(pPrinterNames->pszPrinter),
                      TRUE)) {

            // We found a Server name, in any case we'll have
            // something like "Printer on Server (from...)".
            pszFormat = g_szOnFromFormat;

            if (ulFlags & RDPDR_PRINTER_ANNOUNCE_FLAG_TSPRINTER ) {

                if(!SplitName((PWSTR)(pPrinterNames->pszPrinter),
                              &(pPrinterNames->pszClient),
                              &(pPrinterNames->pszPrinter),
                              FALSE)) {

                    // The original client name could not be found,
                    // use the curent one.
                    pPrinterNames->pszClient = pPrinterNames->pszCurrentClient;
                }

            } else {

                pPrinterNames->pszClient = pPrinterNames->pszCurrentClient;
            }

        } else {

            // The name of the server could not be found!
            // Use the original name.
            pszFormat = g_szFromFormat;
            pPrinterNames->pszPrinter = pPrinterNames->pszFullName;
            pPrinterNames->pszClient = pPrinterNames->pszCurrentClient;
        }

    } else {

        // It's not a network printer, so we'll have
        // something like "Printer (from Client)".
        pszFormat = g_szFromFormat;

        if (ulFlags & RDPDR_PRINTER_ANNOUNCE_FLAG_TSPRINTER ) {

            if(!SplitName(pPrinterNames->szTemp,
                          &(pPrinterNames->pszClient),
                          &(pPrinterNames->pszPrinter),
                          TRUE)) {

                pPrinterNames->pszPrinter = pPrinterNames->pszFullName;
                pPrinterNames->pszClient = pPrinterNames->pszCurrentClient;
            }

        } else {

            pPrinterNames->pszPrinter = pPrinterNames->pszFullName;
            pPrinterNames->pszClient = pPrinterNames->pszCurrentClient;
        }
    }


    pStrings[0] = pPrinterNames->pszPrinter;
    pStrings[1] = pPrinterNames->pszServer;
    pStrings[2] = pPrinterNames->pszClient;

    if (g_fIsPTS) {
        pStrings[3] = NULL;
    } else {
        wsprintf(szSessionId, L"%ld", GETTHESESSIONID());
        pStrings[3] = szSessionId;
    }


    if (*pszFormat) {
        DBGMSG(DBG_TRACE, ("UMRDPPRN:formating %ws, %ws and %ws\n", pStrings[0], pStrings[1],
            pStrings[2]?pStrings[2]:L""));

        dwBytes = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                FORMAT_MESSAGE_FROM_STRING |
                                FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                pszFormat,
                                0,
                                0,
                                (LPTSTR)&pszRet,
                                0,
                                (va_list*)pStrings);

        DBGMSG(DBG_TRACE, ("UMRDPPRN:formated %ws\n", pszRet));
    }

    //
    // Copy the new name.
    //
    if ( dwBytes && pszRet ) {
        wcsncpy(pszNewNameBuf, pszRet, ulBufLen);
    } else {
        wcsncpy(pszNewNameBuf, pPrinterNames->pszFullName, ulBufLen);
    }

    pszNewNameBuf[ulBufLen] = L'\0';

    //
    // Release the formated string.
    //
    if( pszRet ) {
        LocalFree(pszRet);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\umrdpdr.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name :
	
    umrdpdr.h

Abstract:

    User-Mode Component for RDP Device Management that Handles Printing Device-
    Specific tasks.

    This is a supporting module.  The main module is umrdpdr.c.
    
Author:

    TadB

Revision History:
--*/

#ifndef _UMRDPDR_
#define _UMRDPDR_

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

///////////////////////////////////////////////////////////////
//
//      Defines
//

//  Invalid server-assigned device ID.
#define UMRDPDR_INVALIDSERVERDEVICEID     -1

    
///////////////////////////////////////////////////////////////
//
//      Prototypes
//

//  Initialize function for this module.  This function spawns a background
//  thread that does most of the work.
BOOL UMRDPDR_Initialize(
    IN HANDLE hTokenForLoggedOnUser
    );

//  Close down this module.  Right now, we just need to shut down the
//  background thread.
BOOL UMRDPDR_Shutdown();

//  Make sure a buffer is large enough.
BOOL UMRDPDR_ResizeBuffer(
    IN OUT void    **buffer,
    IN DWORD        bytesRequired,
    IN OUT DWORD    *bufferSize
    );

//  Send a message to the TS client corresponding to this session, via the 
//  kernel mode component.
BOOL UMRDPDR_SendMessageToClient(
    IN PVOID    msg, 
    IN DWORD    msgSize
    );

//  Return the AutoInstallPrinters user settings flag.
BOOL UMRDPDR_fAutoInstallPrinters();

//  Return the default printers user settings flag.
BOOL UMRDPDR_fSetClientPrinterDefault();

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _UMRDPDR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\umrdpdrv.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name :
    
    umrdpdrv.c

Abstract:

    User-Mode Component for RDP Device Management that Handles Drive Device-
    Specific tasks.

    This is a supporting module.  The main module is umrdpdr.c.
    
Author:

    Joy Chik    2/1/2000

Revision History:
--*/

#include "precomp.h"

#include <rdpdr.h>
#include <winnetwk.h>

#include "umrdpdr.h"
#include "drdevlst.h"
#include "umrdpdrv.h"
#include "drdbg.h"

//  Global debug flag.
extern DWORD GLOBAL_DEBUG_FLAGS;
extern WCHAR ProviderName[MAX_PATH];

BOOL 
UMRDPDRV_HandleDriveAnnounceEvent(
    IN PDRDEVLST installedDevices,
    IN PRDPDR_DRIVEDEVICE_SUB pDriveAnnounce,
    HANDLE TokenForLoggedOnUser
    )
/*++

Routine Description:

    Handle a drive device announce event from the "dr" by  
    adding a record for the device to the list of installed devices.

Arguments:

    installedDevices -  Comprehensive device list.
    pDriveAnnounce -    Drive device announce event.
    TokenForLoggedOnUser - user token
    
Return Value:
    
    Return TRUE on success.  FALSE, otherwise.      

--*/
{
    DWORD status;
    BOOL  fImpersonated;
    BOOL  result;
    DWORD offset;
    LPNETRESOURCEW NetResource;
    WCHAR RemoteName[RDPDR_MAX_COMPUTER_NAME_LENGTH + 4 + RDPDR_MAX_DOSNAMELEN];

    DBGMSG(DBG_TRACE, ("UMRDPDRV:UMRDPDRV_HandleDriveAnnounceEvent with clientName %ws.\n", 
                        pDriveAnnounce->clientName));
    DBGMSG(DBG_TRACE, ("UMRDPDRV:UMRDPDRV_HandleDriveAnnounceEvent with drive %ws.\n", 
                        pDriveAnnounce->driveName));
    DBGMSG(DBG_TRACE, ("UMRDPDRV:Preferred DOS name is %s.\n", 
                        pDriveAnnounce->deviceFields.PreferredDosName));

    ASSERT((pDriveAnnounce->deviceFields.DeviceType == RDPDR_DTYP_FILESYSTEM));
    ASSERT(TokenForLoggedOnUser != NULL);
    ASSERT(ProviderName[0] != L'\0');

    // We need to impersonate the logged on user 
    fImpersonated = ImpersonateLoggedOnUser(TokenForLoggedOnUser);

    if (fImpersonated) {
        DBGMSG(DBG_TRACE, ("UMRDPDRV:UMRDPDRV_HandleDriveAnnounceEvent userToken: %p fImpersonated : %d.\n", 
                            TokenForLoggedOnUser, fImpersonated));
    
        // Set up remote name in the format of \\clientname\drivename 
        // Note: We don't want : for the drivename
        wcscpy(RemoteName, L"\\\\");
        wcscat(RemoteName, pDriveAnnounce->clientName);
        wcscat(RemoteName, L"\\");
        wcscat(RemoteName, pDriveAnnounce->driveName);
        if (RemoteName[wcslen(RemoteName) - 1] == L':') {
            RemoteName[wcslen(RemoteName) - 1] = L'\0';
        }
    
        // Allocate the net resource struct
        NetResource = (LPNETRESOURCEW) LocalAlloc(LPTR, sizeof(NETRESOURCEW));
    
        if (NetResource) {
            NetResource->dwScope = 0;
            NetResource->lpLocalName = NULL;
            NetResource->lpRemoteName = RemoteName;
            NetResource->lpProvider = ProviderName;
    
            status = WNetAddConnection2(NetResource, NULL, NULL, 0); 
    
            if ( status == NO_ERROR) {
                DBGMSG(DBG_TRACE, ("UMRDPDRV:Added drive connection %ws\n", 
                                   RemoteName));
                result = TRUE;            
            }
            else {
                DBGMSG(DBG_TRACE, ("UMRDPDRV:Failed to add drive connection %ws: %x\n",
                                   RemoteName, status));
                result = FALSE;            
            }
    
            LocalFree(NetResource);
        }
        else {
            DBGMSG(DBG_ERROR, ("UMRDPDRV:Failed to allocate NetResource\n"));
            result = FALSE;        
        }
    
        if (result) {
            // Record the drive devices so that we can remove the connection
            // on disconnect/logoff
            result = DRDEVLST_Add(installedDevices, 
                                  pDriveAnnounce->deviceFields.DeviceId, 
                                  UMRDPDR_INVALIDSERVERDEVICEID,
                                  pDriveAnnounce->deviceFields.DeviceType, 
                                  RemoteName,
                                  pDriveAnnounce->driveName,
                                  pDriveAnnounce->deviceFields.PreferredDosName
                                  );
                
            if (result) {
                // Find the drive device in the devlist
                result = DRDEVLST_FindByClientDeviceIDAndDeviceType(installedDevices, 
                        pDriveAnnounce->deviceFields.DeviceId, pDriveAnnounce->deviceFields.DeviceType, &offset);
    
                if (result) {
                    DBGMSG(DBG_TRACE, ("UMRDPDRV:Create shell reg folder for %ws\n", RemoteName));
    
                    // Create shell reg folder for the drive connection
                    CreateDriveFolder(RemoteName, pDriveAnnounce->clientDisplayName,
                                      &(installedDevices->devices[offset]));                
                }
                else {
                    DBGMSG(DBG_ERROR, ("UMRDPDRV:Failed to find the device %ws in the devlist\n",
                                     pDriveAnnounce->driveName));
                    WNetCancelConnection2(RemoteName, 0, TRUE); 
                }
            }
            else {
                DBGMSG(DBG_ERROR, ("UMRDPDRV:Failed to add the device %ws to the devlist\n", 
                                 pDriveAnnounce->driveName));
                WNetCancelConnection2(RemoteName, 0, TRUE); 
            }
        }
    
        // Revert the thread token to self
        RevertToSelf();
    }
    else {
        DBGMSG(DBG_TRACE, ("UMRDPDRV:UMRDPDRV_HandleDriveAnnounceEvent, impersonation failed\n"));
        result = FALSE;
    }

    return result;
}


BOOL
UMRDPDRV_DeleteDriveConnection(
    IN PDRDEVLSTENTRY deviceEntry,
    HANDLE TokenForLoggedOnUser
    )
/*++

Routine Description:

    Delete drive device connection on disconnect / logoff
  
Arguments:

    deviceEntry - Drive Device to be deleted

Return Value:
    
    Return TRUE on success.  FALSE, otherwise.      

--*/

{
    DWORD status;
    BOOL result;
    BOOL  fImpersonated;
    WCHAR *szGuid;

    DBGMSG(DBG_TRACE, ("UMRDPDRV:Delete client drive connection %ws\n", 
            deviceEntry->serverDeviceName));

    // We need to impersonate the logged on user 
    fImpersonated = ImpersonateLoggedOnUser(TokenForLoggedOnUser);

    if (fImpersonated) {
        DBGMSG(DBG_TRACE, ("UMRDPDRV:UMRDPDRV_DeleteDriveConnection userToken: %p fImpersonated : %d.\n", 
                            TokenForLoggedOnUser, fImpersonated));
    
        // Remove the drive UNC connection
        status = WNetCancelConnection2(deviceEntry->serverDeviceName, 0, TRUE); 
        
        // Remove the shell reg folder
        DeleteDriveFolder(deviceEntry);
        
        if (status == NO_ERROR) {
            DBGMSG(DBG_TRACE, ("UMRDPDRV: Deleted client drive connection %ws\n",
                               deviceEntry->serverDeviceName));
            result = TRUE;
        }
        else {
            DBGMSG(DBG_ERROR, ("UMRDPDRV: Failed to delete client drive connection %ws: %x\n",
                   deviceEntry->serverDeviceName, status));        
            result = FALSE;
        }

        // Revert the thread token to self
        RevertToSelf();
    }
    else
    {
        DBGMSG(DBG_TRACE, ("UMRDPDRV:UMRDPDRV_DeleteDriveConnection, impersonation failed\n"));
        result = FALSE;
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\wtblobj.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name :
    
    wtblobj.h

Abstract:

    Manage a list of waitable objects and associated callbacks.

Author:

    TadB

Revision History:
--*/

#ifndef _WTBLOBJ_
#define _WTBLOBJ_

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

typedef VOID (*WTBLOBJ_ClientFunc)(HANDLE waitableObject, PVOID clientData);
typedef VOID *WTBLOBJMGR;

WTBLOBJMGR WTBLOBJ_CreateWaitableObjectMgr();

VOID WTBLOBJ_DeleteWaitableObjectMgr(WTBLOBJMGR mgr);

DWORD WTBLOBJ_AddWaitableObject(WTBLOBJMGR mgr, PVOID clientData, 
                               HANDLE waitableObject,
                               IN WTBLOBJ_ClientFunc func);

VOID WTBLOBJ_RemoveWaitableObject(WTBLOBJMGR mgr, 
                                HANDLE waitableObject);

DWORD WTBLOBJ_PollWaitableObjects(WTBLOBJMGR mgr);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif //#ifndef _WTBLOBJ_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\notify\wtblobj.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name :
    
    wtblobj.c

Abstract:

    Manage a list of waitable objects and associated callbacks.

Author:

    TadB

Revision History:
--*/

#include <precomp.h>
#pragma hdrstop
#include "drdbg.h"
#include "errorlog.h"
#include "tsnutl.h"
#include "wtblobj.h"


////////////////////////////////////////////////////////
//      
//      Define 
//

#define WTBLOBJMGR_MAGICNO  0x57575757


////////////////////////////////////////////////////////
//      
//      Local Typedefs
//

typedef struct tagWAITABLEOBJECTMGR
{
#if DBG
    DWORD                magicNo;
#endif
    WTBLOBJ_ClientFunc   funcs[MAXIMUM_WAIT_OBJECTS];
    HANDLE               objects[MAXIMUM_WAIT_OBJECTS];
    PVOID                clientData[MAXIMUM_WAIT_OBJECTS];
    ULONG                objectCount;
} WAITABLEOBJECTMGR, *PWAITABLEOBJECTMGR;


////////////////////////////////////////////////////////
//      
//      Globals
//

extern DWORD GLOBAL_DEBUG_FLAGS;



WTBLOBJMGR 
WTBLOBJ_CreateWaitableObjectMgr()
/*++

Routine Description:

    Create a new instance of the Waitable Object Manager.

Arguments:

Return Value:

    NULL on error.  Otherwise, a new Waitable Object Manager is 
    returned.

--*/
{
    PWAITABLEOBJECTMGR objMgr;

    DBGMSG(DBG_TRACE, ("WTBLOBJ_CreateWaitableObjectMgr:  Start.\n"));

    objMgr = ALLOCMEM(sizeof(WAITABLEOBJECTMGR));
    if (objMgr != NULL) {
#if DBG    
        objMgr->magicNo = WTBLOBJMGR_MAGICNO;
#endif        
        objMgr->objectCount = 0;
        memset(&objMgr->objects[0], 0, sizeof(objMgr->objects));
        memset(&objMgr->funcs[0], 0, sizeof(objMgr->funcs));
        memset(&objMgr->clientData[0], 0, sizeof(objMgr->clientData));
    }
    else {
        DBGMSG(DBG_ERROR, 
            ("WTBLOBJ_CreateWaitableObjectMgr:  Error in memory allocation.\n")
            );
    }

    DBGMSG(DBG_TRACE, ("WTBLOBJ_CreateWaitableObjectMgr:  Finish.\n"));

    return objMgr;
}

VOID 
WTBLOBJ_DeleteWaitableObjectMgr(
     IN WTBLOBJMGR mgr
     )
/*++

Routine Description:

    Release an instance of the Waitable Object Manager that was
    created via a call to WTBLOBJ_CreateWaitableObjectMgr.

Arguments:

    mgr     -   Waitable object manager.

Return Value:

    NULL on error.  Otherwise, a new Waitable Object Manager is 
    returned.

--*/
{
    PWAITABLEOBJECTMGR objMgr = (PWAITABLEOBJECTMGR)mgr;

    DBGMSG(DBG_TRACE, ("WTBLOBJ_DeleteWaitableObjectMgr:  Start.\n"));

    ASSERT(objMgr->magicNo == WTBLOBJMGR_MAGICNO);
    ASSERT(objMgr->objectCount == 0);
#if DBG
    objMgr->magicNo = 0xcccccccc;
#endif

    FREEMEM(objMgr);

    DBGMSG(DBG_TRACE, ("WTBLOBJ_DeleteWaitableObjectMgr:  Finish.\n"));
}

DWORD 
WTBLOBJ_AddWaitableObject(
    IN WTBLOBJMGR mgr,
    IN PVOID clientData, 
    IN HANDLE waitableObject,
    IN WTBLOBJ_ClientFunc func
    )
/*++

Routine Description:

    Add a new waitable object to an existing Waitable Object Manager.

Arguments:

    mgr             -   Waitable object manager.
    clientData      -   Associated client data.
    waitableObject  -   Associated waitable object.
    func            -   Completion callback function.

Return Value:

    ERROR_SUCCESS on success.  Otherwise, a Windows error code is
    returned.

--*/
{
    ULONG objectCount;
    DWORD retCode = ERROR_SUCCESS;
    PWAITABLEOBJECTMGR objMgr = (PWAITABLEOBJECTMGR)mgr;

    DBGMSG(DBG_TRACE, ("WTBLOBJ_AddWaitableObject:  Start.\n"));

    ASSERT(objMgr->magicNo == WTBLOBJMGR_MAGICNO);

    objectCount = objMgr->objectCount;

    //
    //  Make sure we don't run out of waitable objects.  This version
    //  only supports MAXIMUM_WAIT_OBJECTS waitable objects.
    //
    if (objectCount < MAXIMUM_WAIT_OBJECTS) {
        ASSERT(objMgr->objects[objectCount] == NULL);
        objMgr->funcs[objectCount]      = func;
        objMgr->objects[objectCount]    = waitableObject;
        objMgr->clientData[objectCount] = clientData;
        objMgr->objectCount++;
    }
    else {
        ASSERT(FALSE);
        retCode = ERROR_INSUFFICIENT_BUFFER;
    }

    DBGMSG(DBG_TRACE, ("WTBLOBJ_AddWaitableObject:  Finish.\n"));

    return retCode;
}

VOID 
WTBLOBJ_RemoveWaitableObject(
    IN WTBLOBJMGR mgr,
    IN HANDLE waitableObject
    )
/*++

Routine Description:

    Remove a waitable object via a call to WTBLOBJ_AddWaitableObject.

Arguments:

    mgr             -   Waitable object manager.
    waitableObject  -   Associated waitable object.

Return Value:

    NA

--*/
{
    ULONG offset;

    PWAITABLEOBJECTMGR objMgr = (PWAITABLEOBJECTMGR)mgr;

    DBGMSG(DBG_TRACE, ("WTBLOBJ_RemoveWaitableObject:  Start.\n"));

    ASSERT(objMgr->magicNo == WTBLOBJMGR_MAGICNO);

    //
    //  Find the waitable object in the list, using a linear search.
    //
    for (offset=0; offset<objMgr->objectCount; offset++) {
        if (objMgr->objects[offset] == waitableObject) {
            break;
        }
    }

    if (offset < objMgr->objectCount) {
        //
        //  Move the last items to the now vacant spot and decrement the count.
        //
        objMgr->objects[offset]    = objMgr->objects[objMgr->objectCount - 1];
        objMgr->funcs[offset]      = objMgr->funcs[objMgr->objectCount - 1];
        objMgr->clientData[offset] = objMgr->clientData[objMgr->objectCount - 1];

        //
        //  Clear the unused spot.
        //
        objMgr->objects[objMgr->objectCount - 1]      = NULL;
        objMgr->funcs[objMgr->objectCount - 1]        = NULL;
        objMgr->clientData[objMgr->objectCount - 1]   = NULL;
        objMgr->objectCount--;
    }

    DBGMSG(DBG_TRACE, ("WTBLOBJ_RemoveWaitableObject:  Finish.\n"));
}

DWORD
WTBLOBJ_PollWaitableObjects(
    WTBLOBJMGR mgr
    )
/*++

Routine Description:

    Poll the list of waitable objects associated with a 
    Waitable Object manager, until the next waitable object
    is signaled.

Arguments:

    waitableObject  -   Associated waitable object.

Return Value:

    ERROR_SUCCESS on success.  Otherwise, a Windows error status
    is returned.

--*/
{
    DWORD waitResult, objectOffset;
    DWORD ret = ERROR_SUCCESS;
    HANDLE obj;
    WTBLOBJ_ClientFunc func;
    PVOID clientData;

    PWAITABLEOBJECTMGR objMgr = (PWAITABLEOBJECTMGR)mgr;

    DBGMSG(DBG_TRACE, ("WTBLOBJ_PollWaitableObjects:  Start.\n"));

    ASSERT(objMgr->magicNo == WTBLOBJMGR_MAGICNO);

    //
    //  Wait for all the waitable objects.
    //
    waitResult = WaitForMultipleObjectsEx(
                                objMgr->objectCount,
                                objMgr->objects,
                                FALSE,
                                INFINITE,
                                FALSE
                                );
    if (waitResult != WAIT_FAILED) {
        objectOffset = waitResult - WAIT_OBJECT_0;

        ASSERT(objectOffset < objMgr->objectCount);

        //
        //  Call the associated callback.
        //
        clientData = objMgr->clientData[objectOffset];
        func       = objMgr->funcs[objectOffset];
        obj        = objMgr->objects[objectOffset];
        func(obj, clientData);
    }
    else {
        ret = GetLastError();
        DBGMSG(DBG_ERROR, 
            ("WTBLOBJ_PollWaitableObjects:  WaitForMult failed: %ld\n", 
            ret));
    }

    DBGMSG(DBG_TRACE, ("WTBLOBJ_PollWaitableObjects:  Finish.\n"));

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\perfts\datats.c ===
/*++ 

Copyright (c) 1997-1998 Microsoft Corporation

Module Name:

    datats.c

Abstract:
       
    Constant data structures used by the Performance Monitor data for the
    Terminal Server User and WinStation performance data objects

Created:

    Erik Mavrinac  25-Nov-1998

Revision History:

    30-Mar-1998 - Last revision of original Terminal Server 4.0
                  counter code base.

--*/

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "datats.h"


// Dummy variables for field sizing.
static PROCESS_COUNTER_DATA pcd;
static WINSTATION_COUNTER_DATA wsd;


//
// We need to define our own counter for ThinWire display.
//

#define PERF_COUNTER_TS_PERCENT        \
            (PERF_SIZE_DWORD | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL |\
             PERF_DISPLAY_NO_SUFFIX)


// Default TS scaling factor for the raw counts.
#define TS_SCALE_FACTOR   (-10000)


#define FIELDSIZE(type, field)   (sizeof(((type *)1)->field))
#define FIELDOFFSET(type, field) ((UINT_PTR)(&((type *)0)->field))


// Note that we set the counter names and descriptions as the offset counters
// from tslabels.h. Later when we load we will read the registry start offset
// and add it into each of the slots below to create the resulting
// real indices. See tslbl009.ini for descriptions.
WINSTATION_DATA_DEFINITION WinStationDataDefinition =
{
    {   sizeof(WINSTATION_DATA_DEFINITION) + sizeof(WINSTATION_COUNTER_DATA),
        sizeof(WINSTATION_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        WINSTATION_OBJECT,
        0,
        WINSTATION_OBJECT + 1,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(WINSTATION_DATA_DEFINITION) - sizeof(PERF_OBJECT_TYPE)) / 
            sizeof(PERF_COUNTER_DEFINITION),
        0,
        0,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {10000000L,0L}
    },

    // Process counters totaled on a per-WinStation basis.
    {   sizeof(PERF_COUNTER_DEFINITION),
        6,
        0,
        189,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_100NSEC_TIMER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.ProcessorTime),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.ProcessorTime)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        142,
        0,
        157,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.UserTime),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.UserTime)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        144,
        0,
        159,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.KernelTime),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.KernelTime)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        172,
        0,
        173,
        0,
        -6,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_LARGE_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.PeakVirtualSize),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.PeakVirtualSize)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        174,
        0,
        175,
        0,
        -6,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_LARGE_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.VirtualSize),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.VirtualSize)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        28,
        0,
        177,
        0,
        -1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.PageFaults),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.PageFaults)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        178,
        0,
        179,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.PeakWorkingSet),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.PeakWorkingSet)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        180,
        0,
        181,
        0,
        -5,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_LARGE_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.TotalWorkingSet),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.TotalWorkingSet)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        182,
        0,
        183,
        0,
        -6,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.PeakPageFile),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.PeakPageFile)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        184,
        0,
        185,
        0,
        -6,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.PageFile),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.PageFile)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        186,
        0,
        187,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.PrivatePages),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.PrivatePages)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        680,
        0,
        681,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.ThreadCount),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.ThreadCount)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        56,
        0,
        57,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.PagedPool),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.PagedPool)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        58,
        0,
        59,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.NonPagedPool),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.NonPagedPool)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        952,
        0,
        953,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.HandleCount),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.HandleCount)
    },


    // Input counters for WinStation protocols

    {   sizeof(PERF_COUNTER_DEFINITION),
        INWDBYTES,
        0,
        INWDBYTES + 1,
        0,
        -2,  // scale
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.WdBytes),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Input.WdBytes),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        INWDFRAMES,
        0,
        INWDFRAMES + 1,
        0,
        0, // no scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.WdFrames),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Input.WdFrames),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        INWAITFOROUTBUF,
        0,
        INWAITFOROUTBUF + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.WaitForOutBuf),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Input.WaitForOutBuf),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        INFRAMES,
        0,
        INFRAMES + 1,
        0,
        0, // no scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.Frames),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Input.Frames),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        INBYTES,
        0,
        INBYTES + 1,
        0,
        -2,  // scale
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.Bytes),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Input.Bytes),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        INCOMPBYTES,
        0,
        INCOMPBYTES + 1,
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.CompressedBytes),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA,
            Input.CompressedBytes),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        INCOMPFLUSHES,
        0,
        INCOMPFLUSHES + 1,
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.CompressFlushes),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA,
            Input.CompressFlushes),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        INERRORS,
        0,
        INERRORS + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.Errors),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Input.Errors),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        INTIMEOUTS,
        0,
        INTIMEOUTS + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.Timeouts),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Input.Timeouts),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        INASYNCFRAMEERR,
        0,
        INASYNCFRAMEERR + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.AsyncFramingError),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Input.AsyncFramingError),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        INASYNCOVERRUN,
        0,
        INASYNCOVERRUN + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.AsyncOverrunError),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Input.AsyncOverrunError),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        INASYNCOVERFLOW,
        0,
        INASYNCOVERFLOW + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.AsyncOverflowError),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Input.AsyncOverflowError),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        INASYNCPARITY,
        0,
        INASYNCPARITY + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.AsyncParityError),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Input.AsyncParityError),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        INTDERRORS,
        0,
        INTDERRORS + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.TdErrors),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Input.TdErrors),
    },


    // Output counters for WinStation protocols

    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTWDBYTES,
        0,
        OUTWDBYTES + 1,
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.WdBytes),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.WdBytes),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTWDFRAMES,
        0,
        OUTWDFRAMES + 1,
        0,
        0, // no scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.WdFrames),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.WdFrames),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTWAITFOROUTBUF,
        0,
        OUTWAITFOROUTBUF + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.WaitForOutBuf),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.WaitForOutBuf),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTFRAMES,
        0,
        OUTFRAMES + 1,
        0,
        0, // no scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.Frames),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.Frames),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTBYTES,
        0,
        OUTBYTES + 1,
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.Bytes),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.Bytes),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTCOMPBYTES,
        0,
        OUTCOMPBYTES + 1,
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.CompressedBytes),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.CompressedBytes),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTCOMPFLUSHES,
        0,
        OUTCOMPFLUSHES + 1,
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.CompressFlushes),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.CompressFlushes),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTERRORS,
        0,
        OUTERRORS + 1,
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.Errors),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.Errors),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTTIMEOUTS,
        0,
        OUTTIMEOUTS + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.Timeouts),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.Timeouts),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTASYNCFRAMEERR,
        0,
        OUTASYNCFRAMEERR + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.AsyncFramingError),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.AsyncFramingError),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTASYNCOVERRUN,
        0,
        OUTASYNCOVERRUN + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.AsyncOverrunError),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.AsyncOverrunError),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTASYNCOVERFLOW,
        0,
        OUTASYNCOVERFLOW + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.AsyncOverflowError),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.AsyncOverflowError),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTASYNCPARITY,
        0,
        OUTASYNCPARITY + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.AsyncParityError),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.AsyncParityError),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTTDERRORS,
        0,
        OUTTDERRORS + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.TdErrors),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.TdErrors),
    },


    // Totals counters

    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALWDBYTES,
        0,
        TOTALWDBYTES + 1,
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.WdBytes),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.WdBytes),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALWDFRAMES,
        0,
        TOTALWDFRAMES + 1,
        0,
        0, // no scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.WdFrames),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.WdFrames),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALWAITFOROUTBUF,
        0,
        TOTALWAITFOROUTBUF + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.WaitForOutBuf),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.WaitForOutBuf),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALFRAMES,
        0,
        TOTALFRAMES + 1,
        0,
        0, // no scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.Frames),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.Frames),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALBYTES,
        0,
        TOTALBYTES + 1,
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.Bytes),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.Bytes),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALCOMPBYTES,
        0,
        TOTALCOMPBYTES + 1,
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.CompressedBytes),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.CompressedBytes),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALCOMPFLUSHES,
        0,
        TOTALCOMPFLUSHES + 1,
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.CompressFlushes),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.CompressFlushes),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALERRORS,
        0,
        TOTALERRORS + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.Errors),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.Errors),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALTIMEOUTS,
        0,
        TOTALTIMEOUTS + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.Timeouts),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.Timeouts),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALASYNCFRAMEERR,
        0,
        TOTALASYNCFRAMEERR + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.AsyncFramingError),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.AsyncFramingError),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALASYNCOVERRUN,
        0,
        TOTALASYNCOVERRUN + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.AsyncOverrunError),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.AsyncOverrunError),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALASYNCOVERFLOW,
        0,
        TOTALASYNCOVERFLOW + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.AsyncOverflowError),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.AsyncOverflowError),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALASYNCPARITY,
        0,
        TOTALASYNCPARITY + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.AsyncParityError),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.AsyncParityError),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALTDERRORS,
        0,
        TOTALTDERRORS + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.TdErrors),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.TdErrors),
    },


    // Display driver statistics -- these are set up the same way for
    // both ICA and RDP.
    {   sizeof(PERF_COUNTER_DEFINITION),
        DDCACHEREAD,
        0,
        DDCACHEREAD + 1,
        0,
        TS_SCALE_FACTOR,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDTotal.CacheReads),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDTotal.CacheReads),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        DDCACHEHIT,
        0,
        DDCACHEHIT + 1,
        0,
        TS_SCALE_FACTOR,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDTotal.CacheHits),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDTotal.CacheHits),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        DDCACHEPERCENT,
        0,
        DDCACHEPERCENT + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_TS_PERCENT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDTotal.HitRatio),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDTotal.HitRatio),
    },


    // Bitmap cache

    {   sizeof(PERF_COUNTER_DEFINITION),
        DDBITMAPCACHEREAD,
        0,
        DDBITMAPCACHEREAD + 1,
        0,
        TS_SCALE_FACTOR,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDBitmap.CacheReads),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDBitmap.CacheReads),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        DDBITMAPCACHEHIT,
        0,
        DDBITMAPCACHEHIT + 1,
        0,
        TS_SCALE_FACTOR,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDBitmap.CacheHits),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDBitmap.CacheHits),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        DDBITMAPCACHEPERCENT,
        0,
        DDBITMAPCACHEPERCENT + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_TS_PERCENT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDBitmap.HitRatio),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDBitmap.HitRatio),
    },

    // Glyph cache

    {   sizeof(PERF_COUNTER_DEFINITION),
        DDGLYPHCACHEREAD,
        0,
        DDGLYPHCACHEREAD + 1,
        0,
        TS_SCALE_FACTOR,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDGlyph.CacheReads),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDGlyph.CacheReads),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        DDGLYPHCACHEHIT,
        0,
        DDGLYPHCACHEHIT + 1,
        0,
        TS_SCALE_FACTOR,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDGlyph.CacheHits),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDGlyph.CacheHits),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        DDGLYPHCACHEPERCENT,
        0,
        DDGLYPHCACHEPERCENT + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_TS_PERCENT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDGlyph.HitRatio),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDGlyph.HitRatio),
    },

    // Brush cache

    {   sizeof(PERF_COUNTER_DEFINITION),
        DDBRUSHCACHEREAD,
        0,
        DDBRUSHCACHEREAD + 1,
        0,
        TS_SCALE_FACTOR,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDBrush.CacheReads),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDBrush.CacheReads),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        DDBRUSHCACHEHIT,
        0,
        DDBRUSHCACHEHIT + 1,
        0,
        TS_SCALE_FACTOR,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDBrush.CacheHits),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDBrush.CacheHits),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        DDBRUSHCACHEPERCENT,
        0,
        DDBRUSHCACHEPERCENT + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_TS_PERCENT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDBrush.HitRatio),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDBrush.HitRatio),
    },

    // Save screen bitmap cache

    {   sizeof(PERF_COUNTER_DEFINITION),
        DDSAVESCRCACHEREAD,
        0,
        DDSAVESCRCACHEREAD + 1,
        0,
        TS_SCALE_FACTOR,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDSaveScr.CacheReads),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDSaveScr.CacheReads),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        DDSAVESCRCACHEHIT,
        0,
        DDSAVESCRCACHEHIT + 1,
        0,
        TS_SCALE_FACTOR,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDSaveScr.CacheHits),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDSaveScr.CacheHits),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        DDSAVESCRCACHEPERCENT,
        0,
        DDSAVESCRCACHEPERCENT + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_TS_PERCENT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDSaveScr.HitRatio),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDSaveScr.HitRatio),
    },


    // Compression ratios

    {   sizeof(PERF_COUNTER_DEFINITION),
        INCOMPRESS_PERCENT,
        0,
        INCOMPRESS_PERCENT + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_TS_PERCENT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, InputCompressionRatio),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, InputCompressionRatio),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTCOMPRESS_PERCENT,
        0,
        OUTCOMPRESS_PERCENT + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_TS_PERCENT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, OutputCompressionRatio),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, OutputCompressionRatio),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALCOMPRESS_PERCENT,
        0,
        TOTALCOMPRESS_PERCENT + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_TS_PERCENT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, TotalCompressionRatio),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, TotalCompressionRatio),
    },
};



// Counter descriptions for overall data.
TERMSERVER_DATA_DEFINITION TermServerDataDefinition =
{
    {   sizeof(TERMSERVER_DATA_DEFINITION) + sizeof(TERMSERVER_COUNTER_DATA),
        sizeof(TERMSERVER_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        TERMSERVER_OBJECT,
        0,
        TERMSERVER_OBJECT + 1,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(TERMSERVER_DATA_DEFINITION) - sizeof(PERF_OBJECT_TYPE)) / 
            sizeof(PERF_COUNTER_DEFINITION),
        0,
        -1,  // No instances
        UNICODE_CODE_PAGE,
        {0L,0L},
        {10000000L,0L}
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        NUMSESSIONS,
        0,
        NUMSESSIONS + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(TERMSERVER_COUNTER_DATA, NumSessions),
        (DWORD)FIELDOFFSET(TERMSERVER_COUNTER_DATA, NumSessions),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        NUMACTIVESESSIONS,
        0,
        NUMACTIVESESSIONS + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(TERMSERVER_COUNTER_DATA, NumActiveSessions),
        (DWORD)FIELDOFFSET(TERMSERVER_COUNTER_DATA, NumActiveSessions),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        NUMINACTIVESESSIONS,
        0,
        NUMINACTIVESESSIONS + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(TERMSERVER_COUNTER_DATA, NumInactiveSessions),
        (DWORD)FIELDOFFSET(TERMSERVER_COUNTER_DATA, NumInactiveSessions),
    },
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\perfts\dataproc.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATAPROC.h

Abstract:

    Header file for the Windows NT Processor Process counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/
#ifndef _DATAPROC_H_
#define _DATAPROC_H_

#ifdef	_DATAPROC_PRIVATE_WS_
#undef	_DATAPROC_PRIVATE_WS_
#endif

//
//  Process data object definitions.
//
//
//  This is the counter structure presently returned by NT.  The
//  Performance Monitor MUST *NOT* USE THESE STRUCTURES!
//

typedef struct _PROCESS_DATA_DEFINITION {
    PERF_OBJECT_TYPE		    ProcessObjectType;
    PERF_COUNTER_DEFINITION	    cdProcessorTime;
    PERF_COUNTER_DEFINITION	    cdUserTime;
    PERF_COUNTER_DEFINITION	    cdKernelTime;
    PERF_COUNTER_DEFINITION	    cdPeakVirtualSize;
    PERF_COUNTER_DEFINITION	    cdVirtualSize;
    PERF_COUNTER_DEFINITION	    cdPageFaults;
    PERF_COUNTER_DEFINITION	    cdPeakWorkingSet;
    PERF_COUNTER_DEFINITION	    cdTotalWorkingSet;
#ifdef _DATAPROC_PRIVATE_WS_
	PERF_COUNTER_DEFINITION		cdPrivateWorkingSet;
	PERF_COUNTER_DEFINITION		cdSharedWorkingSet;
#endif
	PERF_COUNTER_DEFINITION	    cdPeakPageFile;
    PERF_COUNTER_DEFINITION	    cdPageFile;
    PERF_COUNTER_DEFINITION	    cdPrivatePages;
    PERF_COUNTER_DEFINITION     cdThreadCount;
    PERF_COUNTER_DEFINITION     cdBasePriority;
    PERF_COUNTER_DEFINITION     cdElapsedTime;
    PERF_COUNTER_DEFINITION     cdProcessId;
    PERF_COUNTER_DEFINITION     cdCreatorProcessId;
    PERF_COUNTER_DEFINITION     cdPagedPool;
    PERF_COUNTER_DEFINITION     cdNonPagedPool;
    PERF_COUNTER_DEFINITION     cdHandleCount;
    PERF_COUNTER_DEFINITION     cdReadOperationCount;
    PERF_COUNTER_DEFINITION     cdWriteOperationCount;
    PERF_COUNTER_DEFINITION     cdDataOperationCount;
    PERF_COUNTER_DEFINITION     cdOtherOperationCount;
    PERF_COUNTER_DEFINITION     cdReadTransferCount;
    PERF_COUNTER_DEFINITION     cdWriteTransferCount;
    PERF_COUNTER_DEFINITION     cdDataTransferCount;
    PERF_COUNTER_DEFINITION     cdOtherTransferCount;
} PROCESS_DATA_DEFINITION, * PPROCESS_DATA_DEFINITION;

typedef struct _PROCESS_COUNTER_DATA {
    PERF_COUNTER_BLOCK          CounterBlock;
    DWORD                  	    PageFaults;
    LONGLONG                    ProcessorTime;
    LONGLONG                    UserTime;
    LONGLONG                    KernelTime;
    LONGLONG              	    PeakVirtualSize;
    LONGLONG                    VirtualSize;
    LONGLONG               	    PeakWorkingSet;
    LONGLONG               	    TotalWorkingSet;
#ifdef _DATAPROC_PRIVATE_WS_
	LONGLONG			        PrivateWorkingSet;
	LONGLONG			        SharedWorkingSet;
#endif
    LONGLONG                    PeakPageFile;
    LONGLONG                    PageFile;
    LONGLONG                    PrivatePages;
    DWORD                       ThreadCount;
    DWORD                       BasePriority;
    LONGLONG                    ElapsedTime;
    DWORD                       ProcessId;
    DWORD                       CreatorProcessId;
    DWORD                       PagedPool;
    DWORD                       NonPagedPool;
    DWORD                       HandleCount;
    DWORD                       Reserved;   // for alignment
    LONGLONG                    ReadOperationCount;
    LONGLONG                    WriteOperationCount;
    LONGLONG                    DataOperationCount;
    LONGLONG                    OtherOperationCount;
    LONGLONG                    ReadTransferCount;
    LONGLONG                    WriteTransferCount;
    LONGLONG                    DataTransferCount;
    LONGLONG                    OtherTransferCount;
} PROCESS_COUNTER_DATA, * PPROCESS_COUNTER_DATA;

extern PROCESS_DATA_DEFINITION ProcessDataDefinition;

#endif // _DATAPROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\perfts\datats.h ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation

Module Name:

      datats.h

Abstract:

    Header file for the Windows NT Terminal Server performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry. Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Erik Mavrinac 25-Nov-1998

Revision History:

    30-Mar-1998 - Last revision of original Terminal Server 4.0
                  counter code base.

--*/

#ifndef __DATATS_H
#define __DATATS_H

#include <winsta.h>

#include "tslabels.h"

#include "dataproc.h"


// The WinStation data object shows the system resource usage of a
// given WinStation instance (SessionID).
//
// A Terminal Server WinStation instance is a CSRSS process and its
// client applications and subsystems. It represents a unique session
// on the Terminal Server system, and is addressed by a SessionID.
typedef struct _WINSTATION_DATA_DEFINITION
{
    PERF_OBJECT_TYPE            WinStationObjectType;

    // Summation of Process information for all WinStation processes
    PERF_COUNTER_DEFINITION     ProcessorTime;
    PERF_COUNTER_DEFINITION     UserTime;
    PERF_COUNTER_DEFINITION     KernelTime;
    PERF_COUNTER_DEFINITION     PeakVirtualSize;
    PERF_COUNTER_DEFINITION     VirtualSize;
    PERF_COUNTER_DEFINITION     PageFaults;
    PERF_COUNTER_DEFINITION     PeakWorkingSet;
    PERF_COUNTER_DEFINITION     WorkingSet;
    PERF_COUNTER_DEFINITION     PeakPageFile;
    PERF_COUNTER_DEFINITION     PageFile;
    PERF_COUNTER_DEFINITION     PrivatePages;
    PERF_COUNTER_DEFINITION     ThreadCount;
    PERF_COUNTER_DEFINITION     PagedPool;
    PERF_COUNTER_DEFINITION     NonPagedPool;
    PERF_COUNTER_DEFINITION     HandleCount;

    // Input counters for WinStation protocols
    PERF_COUNTER_DEFINITION     InputWdBytes;
    PERF_COUNTER_DEFINITION     InputWdFrames;
    PERF_COUNTER_DEFINITION     InputWaitForOutBuf;
    PERF_COUNTER_DEFINITION     InputFrames;
    PERF_COUNTER_DEFINITION     InputBytes;
    PERF_COUNTER_DEFINITION     InputCompressedBytes;
    PERF_COUNTER_DEFINITION     InputCompressedFlushes;
    PERF_COUNTER_DEFINITION     InputErrors;
    PERF_COUNTER_DEFINITION     InputTimeouts;
    PERF_COUNTER_DEFINITION     InputAsyncFramingError;
    PERF_COUNTER_DEFINITION     InputAsyncOverrunError;
    PERF_COUNTER_DEFINITION     InputAsyncOverFlowError;
    PERF_COUNTER_DEFINITION     InputAsyncParityError;
    PERF_COUNTER_DEFINITION     InputTdErrors;

    // Output counters for WinStation protocols
    PERF_COUNTER_DEFINITION     OutputWdBytes;
    PERF_COUNTER_DEFINITION     OutputWdFrames;
    PERF_COUNTER_DEFINITION     OutputWaitForOutBuf;
    PERF_COUNTER_DEFINITION     OutputFrames;
    PERF_COUNTER_DEFINITION     OutputBytes;
    PERF_COUNTER_DEFINITION     OutputCompressedBytes;
    PERF_COUNTER_DEFINITION     OutputCompressedFlushes;
    PERF_COUNTER_DEFINITION     OutputErrors;
    PERF_COUNTER_DEFINITION     OutputTimeouts;
    PERF_COUNTER_DEFINITION     OutputAsyncFramingError;
    PERF_COUNTER_DEFINITION     OutputAsyncOverrunError;
    PERF_COUNTER_DEFINITION     OutputAsyncOverFlowError;
    PERF_COUNTER_DEFINITION     OutputAsyncParityError;
    PERF_COUNTER_DEFINITION     OutputTdErrors;

    // Totals counters for WinStation protocols
    PERF_COUNTER_DEFINITION     TotalWdBytes;
    PERF_COUNTER_DEFINITION     TotalWdFrames;
    PERF_COUNTER_DEFINITION     TotalWaitForOutBuf;
    PERF_COUNTER_DEFINITION     TotalFrames;
    PERF_COUNTER_DEFINITION     TotalBytes;
    PERF_COUNTER_DEFINITION     TotalCompressedBytes;
    PERF_COUNTER_DEFINITION     TotalCompressedFlushes;
    PERF_COUNTER_DEFINITION     TotalErrors;
    PERF_COUNTER_DEFINITION     TotalTimeouts;
    PERF_COUNTER_DEFINITION     TotalAsyncFramingError;
    PERF_COUNTER_DEFINITION     TotalAsyncOverrunError;
    PERF_COUNTER_DEFINITION     TotalAsyncOverFlowError;
    PERF_COUNTER_DEFINITION     TotalAsyncParityError;
    PERF_COUNTER_DEFINITION     TotalTdErrors;

    // Cumulative display driver cache stats.
    PERF_COUNTER_DEFINITION     DDCacheReadsTotal;
    PERF_COUNTER_DEFINITION     DDCacheHitsTotal;
    PERF_COUNTER_DEFINITION     DDCachePercentTotal;

    PERF_COUNTER_DEFINITION     DDBitmapCacheReads;
    PERF_COUNTER_DEFINITION     DDBitmapCacheHits;
    PERF_COUNTER_DEFINITION     DDBitmapCachePercent;

    PERF_COUNTER_DEFINITION     DDGlyphCacheReads;
    PERF_COUNTER_DEFINITION     DDGlyphCacheHits;
    PERF_COUNTER_DEFINITION     DDGlyphCachePercent;

    PERF_COUNTER_DEFINITION     DDBrushCacheReads;
    PERF_COUNTER_DEFINITION     DDBrushCacheHits;
    PERF_COUNTER_DEFINITION     DDBrushCachePercent;

    PERF_COUNTER_DEFINITION     DDSaveBitmapCacheReads;
    PERF_COUNTER_DEFINITION     DDSaveBitmapCacheHits;
    PERF_COUNTER_DEFINITION     DDSaveBitmapCachePercent;

    // Compression percentage on compression PD.
    PERF_COUNTER_DEFINITION     InputCompressPercent;
    PERF_COUNTER_DEFINITION     OutputCompressPercent;
    PERF_COUNTER_DEFINITION     TotalCompressPercent;
} WINSTATION_DATA_DEFINITION, *PWINSTATION_DATA_DEFINITION;


typedef struct {
    ULONG CacheReads;
    ULONG CacheHits;
    ULONG HitRatio;
} DisplayDriverCacheInfo;

typedef struct _WINSTATION_COUNTER_DATA
{
    // From ..\process\dataproc.h. Contains a PERF_COUNTER_BLOCK header.
    // NOTE: Needs to be first for the COUNTER_BLOCK to be first.
    PROCESS_COUNTER_DATA pcd;

    // From winsta.h
    PROTOCOLCOUNTERS Input;
    PROTOCOLCOUNTERS Output;
    PROTOCOLCOUNTERS Total;

    // Cache statistics.
    DisplayDriverCacheInfo DDTotal;
    DisplayDriverCacheInfo DDBitmap;
    DisplayDriverCacheInfo DDGlyph;
    DisplayDriverCacheInfo DDBrush;
    DisplayDriverCacheInfo DDSaveScr;

    // Protocol statistics.
    ULONG InputCompressionRatio;
    ULONG OutputCompressionRatio;
    ULONG TotalCompressionRatio;
} WINSTATION_COUNTER_DATA, *PWINSTATION_COUNTER_DATA;



// Overall data for Terminal Services.
typedef struct _TERMSERVER_DATA_DEFINITION
{
    PERF_OBJECT_TYPE            TermServerObjectType;

    PERF_COUNTER_DEFINITION     NumSessions;
    PERF_COUNTER_DEFINITION     NumActiveSessions;
    PERF_COUNTER_DEFINITION     NumInactiveSessions;
} TERMSERVER_DATA_DEFINITION, *PTERMSERVER_DATA_DEFINITION;

typedef struct
{
    PERF_COUNTER_BLOCK CounterBlock;
    DWORD NumSessions;
    DWORD NumActiveSessions;
    DWORD NumInactiveSessions;
} TERMSERVER_COUNTER_DATA;


// Other defines.
#define MAX_PROCESS_NAME_LENGTH    (MAX_PATH * sizeof(WCHAR))
#define MAX_USER_NAME_LENGTH       MAX_PROCESS_NAME_LENGTH
#define MAX_WINSTATION_NAME_LENGTH MAX_PROCESS_NAME_LENGTH


// Externs
extern WINSTATION_DATA_DEFINITION WinStationDataDefinition;
extern TERMSERVER_DATA_DEFINITION TermServerDataDefinition;



#endif // __DATATS_H


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\perfts\perfmsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1995 Microsoft Corporation

Module Name:

    perfmsg.h  

Abstract:

    This file provides the macros and definitions used by the extensible
    counters for reporting events to the event logging facility

Author:

    Bob Watson  28-Jul-1995

Revision History:


--*/
#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_
//
// Report error message ID's for Counters
//

#define APP_NAME    (TEXT("Perflib"))

//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//    Levels:  LOG_NONE = No event log messages ever
//             LOG_USER = User event log messages (e.g. errors)
//             LOG_DEBUG = Minimum Debugging 
//             LOG_VERBOSE = Maximum Debugging 
//

#define  LOG_NONE     0
#define  LOG_USER     1
#define  LOG_DEBUG    2
#define  LOG_VERBOSE  3

#define  MESSAGE_LEVEL_DEFAULT  LOG_USER

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//    REPORT_xxx (message_value, message_level)
//       where:   
//          xxx is the severity to be displayed in the event log
//          message_value is the numeric ID from above
//          message_level is the "filtering" level of error reporting
//             using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the 
// 
//    REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//

//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could 
// (should) be changed  in the future
//


#define REPORT_SUCCESS(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_WARNING(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_ERROR(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_WARNING_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_ERROR_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

// External Variables

extern HANDLE hEventLog;   // handle to event log
extern DWORD  dwLogUsers;  // counter of event log using routines
extern DWORD  MESSAGE_LEVEL; // event logging detail level

#endif //_PERFMSG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\perfts\perfutil.c ===
/*++

Copyright (c) 1995-6  Microsoft Corporation

Module Name:

    perfutil.c

Abstract:

    This file implements the utility routines used to construct the
    common parts of a PERF_INSTANCE_DEFINITION (see winperf.h) and
    perform event logging functions.

Created:

    Bob Watson  28-Jul-1995

Revision History:

--*/
//
//  include files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <string.h>
#include <winperf.h>
#include "perfutil.h"
#include "perfmsg.h"

//
// Global data definitions.
//

ULONG ulInfoBufferSize = 0;

extern HANDLE hEventLog;      // event log handle for reporting events
                              // initialized in Open... routines
DWORD  dwLogUsers = 0;        // count of functions using event log

DWORD MESSAGE_LEVEL = 0;

const WCHAR GLOBAL_STRING[] = L"Global";
const WCHAR FOREIGN_STRING[] = L"Foreign";
const WCHAR COSTLY_STRING[] = L"Costly";

const WCHAR NULL_STRING[] = L"\0";    // pointer to null string

const WCHAR  szTotalValue[] = L"TotalInstanceName";
const WCHAR  szDefaultTotalString[] = L"_Total";

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


LONG
GetPerflibKeyValue (
    LPCWSTR szItem,
    DWORD   dwRegType,
    DWORD   dwMaxSize,      // ... of pReturnBuffer in bytes
    LPVOID  pReturnBuffer,
    DWORD   dwDefaultSize,  // ... of pDefault in bytes
    LPVOID  pDefault
)
/*++

    read and return the current value of the specified value
    under the Perflib registry key. If unable to read the value
    return the default value from the argument list.

    the value is returned in the pReturnBuffer.

--*/
{

    HKEY                    hPerflibKey;
    OBJECT_ATTRIBUTES       Obja;
    NTSTATUS                Status;
    UNICODE_STRING          PerflibSubKeyString;
    UNICODE_STRING          ValueNameString;
    LONG                    lReturn;
    PKEY_VALUE_PARTIAL_INFORMATION  pValueInformation;
    PKEY_VALUE_PARTIAL_INFORMATION  pNewValueInformation;
    DWORD                   ValueBufferLength;
    DWORD                   ResultLength;
    BOOL                    bUseDefault = TRUE;

    // initialize UNICODE_STRING structures used in this function

    RtlInitUnicodeString (
        &PerflibSubKeyString,
        L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib");

    RtlInitUnicodeString (
        &ValueNameString,
        (LPWSTR)szItem);

    //
    // Initialize the OBJECT_ATTRIBUTES structure and open the key.
    //
    InitializeObjectAttributes(
            &Obja,
            &PerflibSubKeyString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

    Status = NtOpenKey(
                &hPerflibKey,
                KEY_READ,
                &Obja
                );

    if (NT_SUCCESS( Status )) {
        // read value of desired entry

        ValueBufferLength = ResultLength = 1024;
        pValueInformation = ALLOCMEM(RtlProcessHeap(), 0, ResultLength);

        if (pValueInformation != NULL) {
            while ( (Status = NtQueryValueKey(hPerflibKey,
                                            &ValueNameString,
                                            KeyValuePartialInformation,
                                            pValueInformation,
                                            ValueBufferLength,
                                            &ResultLength))
                    == STATUS_BUFFER_OVERFLOW ) {

                pNewValueInformation = REALLOCMEM(RtlProcessHeap(), 0,
                                                        pValueInformation,
                                                        ResultLength);
                if ( pNewValueInformation == NULL) {
                    FREEMEM(RtlProcessHeap(), 0, pValueInformation);
                    pValueInformation = NULL;
                    Status = STATUS_NO_MEMORY;
                    break;
                } else {
                    pValueInformation = pNewValueInformation;
                    ValueBufferLength = ResultLength;
                }
            }

            if (NT_SUCCESS(Status)) {
                // check to see if it's the desired type
                if (pValueInformation->Type == dwRegType) {
                    // see if it will fit
                    if (pValueInformation->DataLength <= dwMaxSize) {
                        memcpy (pReturnBuffer, &pValueInformation->Data[0],
                            pValueInformation->DataLength);
                        bUseDefault = FALSE;
                        lReturn = STATUS_SUCCESS;
                    }
                }
            } else {
                // return the default value
                lReturn = Status;
            }

            // Release temp buffer. Check pValueInfo again since
            // the realloc may have failed above.
            if (pValueInformation != NULL) {
                FREEMEM (RtlProcessHeap(), 0, pValueInformation);
            }
        } else {
            // unable to allocate memory for this operation so
            // just return the default value
        }

        // close the registry key
        NtClose(hPerflibKey);
    } else {
        // return default value
    }

    if (bUseDefault) {
        memcpy (pReturnBuffer, pDefault, dwDefaultSize);
        lReturn = STATUS_SUCCESS;
    }

    return lReturn;
}


HANDLE
MonOpenEventLog (
    IN  LPWSTR  szAppName
)
/*++

Routine Description:

    Reads the level of event logging from the registry and opens the
        channel to the event logger for subsequent event log entries.

Arguments:

      None

Return Value:

    Handle to the event log for reporting events.
    NULL if open not successful.

--*/
{
    HKEY hAppKey;
    TCHAR LogLevelKeyName[] = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib");
    TCHAR LogLevelValueName[] = TEXT("EventLogLevel");

    LONG lStatus;

    DWORD dwLogLevel;
    DWORD dwValueType;
    DWORD dwValueSize;

    // if global value of the logging level not initialized or is disabled,
    //  check the registry to see if it should be updated.

    if (!MESSAGE_LEVEL) {

       lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                               LogLevelKeyName,
                               0,
                               KEY_READ,
                               &hAppKey);

       dwValueSize = sizeof (dwLogLevel);

       if (lStatus == ERROR_SUCCESS) {
            lStatus = RegQueryValueEx (hAppKey,
                               LogLevelValueName,
                               (LPDWORD)NULL,
                               &dwValueType,
                               (LPBYTE)&dwLogLevel,
                               &dwValueSize);

            if (lStatus == ERROR_SUCCESS) {
               MESSAGE_LEVEL = dwLogLevel;
            } else {
               MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
            }
            RegCloseKey (hAppKey);
       } else {
         MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
       }
    }

    if (hEventLog == NULL){
         hEventLog = RegisterEventSourceW (
            (LPWSTR)NULL,            // Use Local Machine
            szAppName);               // event log app name to find in registry
    }

    if (hEventLog != NULL) {
         dwLogUsers++;           // increment count of perfctr log users
    }
    return (hEventLog);
}


VOID
MonCloseEventLog (
)
/*++

Routine Description:

      Closes the handle to the event logger if this is the last caller

Arguments:

      None

Return Value:

      None

--*/
{
    if (hEventLog != NULL) {
        dwLogUsers--;         // decrement usage
        if (dwLogUsers <= 0) {    // and if we're the last, then close up log
            DeregisterEventSource (hEventLog);
        }
    }
}

DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = (LPWSTR)GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = (LPWSTR)FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = (LPWSTR)COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }
    return FALSE;
}   // IsNumberInUnicodeList


BOOL
MonBuildInstanceDefinition(
    PERF_INSTANCE_DEFINITION *pBuffer,
    PVOID *pBufferNext,
    DWORD ParentObjectTitleIndex,
    DWORD ParentObjectInstance,
    DWORD UniqueID,
    LPWSTR Name
    )
/*++

    MonBuildInstanceDefinition  -   Build an instance of an object

        Inputs:

            pBuffer         -   pointer to buffer where instance is to
                                be constructed

            pBufferNext     -   pointer to a pointer which will contain
                                next available location, DWORD aligned

            ParentObjectTitleIndex
                            -   Title Index of parent object type; 0 if
                                no parent object

            ParentObjectInstance
                            -   Index into instances of parent object
                                type, starting at 0, for this instances
                                parent object instance

            UniqueID        -   a unique identifier which should be used
                                instead of the Name for identifying
                                this instance

            Name            -   Name of this instance
--*/
{
    DWORD NameLength;
    LPWSTR pName;
    //
    //  Include trailing null in name size
    //

    NameLength = (lstrlenW(Name) + 1) * sizeof(WCHAR);

    pBuffer->ByteLength = sizeof(PERF_INSTANCE_DEFINITION) +
                            NameLength;

    pBuffer->ParentObjectTitleIndex = ParentObjectTitleIndex;
    pBuffer->ParentObjectInstance = ParentObjectInstance;
    pBuffer->UniqueID = UniqueID;
    pBuffer->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
    pBuffer->NameLength = NameLength;

    // copy name to name buffer
    pName = (LPWSTR)&pBuffer[1];
    memcpy(pName,Name,NameLength);

    // update "next byte" pointer
    *pBufferNext = (PVOID) ((PCHAR) pBuffer + pBuffer->ByteLength);

    // round up to put next buffer on a QUADWORD boundry
    *pBufferNext = ALIGN_ON_QWORD (*pBufferNext);
    // adjust length value to match new length
    pBuffer->ByteLength = (ULONG)((ULONG_PTR)*pBufferNext - (ULONG_PTR)pBuffer);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\perfts\tslabels.h ===
/* (C) 1997-1998 Microsoft Corp.
 *
 * tslabels.h
 *
 * PerfMon Lodctr utility offsets for TS perf objects.
 */

// TS defined counter names and explain text defines
#define WINSTATION_OBJECT             0

// Input
#define INWDBYTES                     2
#define INWDFRAMES                    4
#define INWAITFOROUTBUF               6
#define INFRAMES                      8
#define INBYTES                       10
#define INCOMPBYTES                   12
#define INCOMPFLUSHES                 14
#define INERRORS                      16
#define INTIMEOUTS                    18
#define INASYNCFRAMEERR               20
#define INASYNCOVERRUN                22
#define INASYNCOVERFLOW               24
#define INASYNCPARITY                 26
#define INTDERRORS                    28

// Output
#define OUTWDBYTES                    30
#define OUTWDFRAMES                   32
#define OUTWAITFOROUTBUF              34
#define OUTFRAMES                     36
#define OUTBYTES                      38
#define OUTCOMPBYTES                  40
#define OUTCOMPFLUSHES                42
#define OUTERRORS                     44
#define OUTTIMEOUTS                   46
#define OUTASYNCFRAMEERR              48
#define OUTASYNCOVERRUN               50
#define OUTASYNCOVERFLOW              52
#define OUTASYNCPARITY                54
#define OUTTDERRORS                   56

// Totals
#define TOTALWDBYTES                  58
#define TOTALWDFRAMES                 60
#define TOTALWAITFOROUTBUF            62
#define TOTALFRAMES                   64
#define TOTALBYTES                    66
#define TOTALCOMPBYTES                68
#define TOTALCOMPFLUSHES              70
#define TOTALERRORS                   72
#define TOTALTIMEOUTS                 74
#define TOTALASYNCFRAMEERR            76
#define TOTALASYNCOVERRUN             78
#define TOTALASYNCOVERFLOW            80
#define TOTALASYNCPARITY              82
#define TOTALTDERRORS                 84

// Display driver cache counter entries
// Totals
#define DDCACHEREAD                   86
#define DDCACHEHIT                    88
#define DDCACHEPERCENT                90

// Bitmap cache
#define DDBITMAPCACHEREAD             92
#define DDBITMAPCACHEHIT              94
#define DDBITMAPCACHEPERCENT          96

// Glyph cache
#define DDGLYPHCACHEREAD              98
#define DDGLYPHCACHEHIT               100
#define DDGLYPHCACHEPERCENT           102

// Brush cache
#define DDBRUSHCACHEREAD              104
#define DDBRUSHCACHEHIT               106
#define DDBRUSHCACHEPERCENT           108

// Save screen bitmap cache
#define DDSAVESCRCACHEREAD            110
#define DDSAVESCRCACHEHIT             112
#define DDSAVESCRCACHEPERCENT         114

// Compression PD ratio
#define INCOMPRESS_PERCENT            116
#define OUTCOMPRESS_PERCENT           118
#define TOTALCOMPRESS_PERCENT         120

#define LAST_WINSTATION_COUNTER_OFFSET TOTALCOMPRESS_PERCENT



// TermServer object definitions.
#define TERMSERVER_OBJECT             122
#define NUMSESSIONS                   124
#define NUMACTIVESESSIONS             126
#define NUMINACTIVESESSIONS           128

#define LAST_TERMSERVER_COUNTER_OFFSET NUMINACTIVESESSIONS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\perfts\perfts.c ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation

Module Name:

    perfts.c

Description:
    DLL entry point and support code for Terminal Server performance counters.

Author:

    Erik Mavrinac  24-Nov-1998

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>

#include <winsta.h>
#include <utildll.h>

#include <stdlib.h>

#include "datats.h"


#if DBG
#define DBGPRINT(x) DbgPrint x
#else
#define DBGPRINT(x)
#endif


#define MAX_SESSION_NAME_LENGTH 50


typedef struct _WinStationInfo
{
    LIST_ENTRY HashBucketList;
    LIST_ENTRY UsedList;
    ULONG SessionID;
    WINSTATIONSTATECLASS LastState;
    void *pInstanceInfo;
    WINSTATIONNAMEW WinStationName;
} WinStationInfo;


/****************************************************************************/
// Globals
/****************************************************************************/

// Default hash bucket list to remove having to check for
// pWinStationHashBuckets == NULL on perf path. This array contains the
// default number for one WinStationInfo.
#define NumDefaultWinStationHashBuckets 4
LIST_ENTRY DefaultWinStationHashBuckets[NumDefaultWinStationHashBuckets];

HANDLE hEventLog = NULL;
HANDLE hLibHeap = NULL;
PBYTE pProcessBuffer = NULL;

static DWORD dwOpenCount = 0;
static DWORD ProcessBufSize = LARGE_BUFFER_SIZE;
static DWORD NumberOfCPUs = 0;
static DWORD FirstCounterIndex = 0;

LIST_ENTRY UsedList;
LIST_ENTRY UnusedList;
LIST_ENTRY *pWinStationHashBuckets = DefaultWinStationHashBuckets;
unsigned NumWinStationHashBuckets = NumDefaultWinStationHashBuckets;
ULONG WinStationHashMask = 0x3;
unsigned NumCachedWinStations = 0;

SYSTEM_TIMEOFDAY_INFORMATION SysTimeInfo = {{0,0},{0,0},{0,0},0,0};



/****************************************************************************/
// Prototypes
/****************************************************************************/
BOOL DllProcessAttach(void);
BOOL DllProcessDetach(void);
DWORD GetNumberOfCPUs(void);
NTSTATUS GetDescriptionOffset(void);
void SetupCounterIndices(void);

DWORD APIENTRY OpenWinStationObject(LPWSTR);
DWORD APIENTRY CloseWinStationObject(void);
DWORD APIENTRY CollectWinStationObjectData(IN LPWSTR, IN OUT LPVOID *,
        IN OUT LPDWORD, OUT LPDWORD);

DWORD GetSystemProcessData(void);
void SetupWinStationCounterBlock(WINSTATION_COUNTER_DATA *,
        PWINSTATIONINFORMATIONW);
void UpdateWSProcessCounterBlock(WINSTATION_COUNTER_DATA *,
        PSYSTEM_PROCESS_INFORMATION);

void CreateNewHashBuckets(unsigned);


// Declares these exported functions as PerfMon entry points.
PM_OPEN_PROC    OpenTSObject;
PM_COLLECT_PROC CollectTSObjectData;
PM_CLOSE_PROC   CloseTSObject;



/****************************************************************************/
// DLL system load/unload entry point.
/****************************************************************************/
BOOL __stdcall DllInit(
    IN HANDLE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused)
{
    ReservedAndUnused;

    // This will prevent the DLL from getting
    // the DLL_THREAD_* messages
    DisableThreadLibraryCalls(DLLHandle);

    switch(Reason) {
        case DLL_PROCESS_ATTACH:
            return DllProcessAttach();

        case DLL_PROCESS_DETACH:
            return DllProcessDetach();

        default:
            return TRUE;
    }
}


/****************************************************************************/
// DLL instance load time initialization.
/****************************************************************************/
BOOL DllProcessAttach(void)
{
    unsigned i;
    NTSTATUS Status;

//    DBGPRINT(("PerfTS: ProcessAttach\n"));

    // Create the local heap
    hLibHeap = HeapCreate(0, 1, 0);
    if (hLibHeap == NULL)
        return FALSE;

    // Open handle to the event log
    if (hEventLog == NULL) {
        hEventLog = MonOpenEventLog(L"PerfTS");
        if (hEventLog == NULL)
            goto PostCreateHeap;
    }

    // Get the counter index value and init the WinStationDataDefinition
    // counter values.
    Status = GetDescriptionOffset();
    if (!NT_SUCCESS(Status))
        goto PostOpenEventLog;
    SetupCounterIndices();

    // Pre-determine the number of system CPUs.
    NumberOfCPUs = GetNumberOfCPUs();

    // UsedList is used as a skip-list through all valid entries in the
    // hash table to allow us to iterate all entries without having to have
    // a second, low-performance loop that looks through each hash bucket
    // list.
    InitializeListHead(&UsedList);
    InitializeListHead(&UnusedList);
    for (i = 0; i < NumDefaultWinStationHashBuckets; i++)
        InitializeListHead(&DefaultWinStationHashBuckets[i]);
        
    return TRUE;


// Error handling.

PostOpenEventLog:
    MonCloseEventLog();
    hEventLog = NULL;

PostCreateHeap:
    HeapDestroy(hLibHeap);
    hLibHeap = NULL;

    return FALSE;
}


/****************************************************************************/
// DLL unload cleanup.
/****************************************************************************/
BOOL DllProcessDetach(void)
{
//    DBGPRINT(("PerfTS: ProcessDetach\n"));

    if (dwOpenCount > 0) {
        // the Library is being unloaded before it was
        // closed so close it now as this is the last
        // chance to do it before the library is tossed.
        // if the value of dwOpenCount is > 1, set it to
        // one to insure everything will be closed when
        // the close function is called.
        if (dwOpenCount > 1)
            dwOpenCount = 1;
        CloseTSObject();
    }

    if (hEventLog != NULL) {
        MonCloseEventLog();
        hEventLog = NULL;
    }

    if (hLibHeap != NULL && HeapDestroy(hLibHeap))
        hLibHeap = NULL;

    return TRUE;
}


/****************************************************************************/
// Utility function used at startup.
/****************************************************************************/
DWORD GetNumberOfCPUs(void)
{
    NTSTATUS Status;
    DWORD ReturnLen;
    SYSTEM_BASIC_INFORMATION Info;

    Status = NtQuerySystemInformation(
                 SystemBasicInformation,
                 &Info,
                 sizeof(Info),
                 &ReturnLen
                 );

    if (NT_SUCCESS(Status)) {
        return Info.NumberOfProcessors;
    }
    else {
        DBGPRINT(("GetNumberOfCPUs Error 0x%x returning CPU count\n",Status));
        // Return 1 CPU
        return 1;
    }
}


/****************************************************************************/
// Gets the offset index of the first text description from the
// TermService\Performance key. This value was created by Lodctr /
// LoadPerfCounterTextStrings() during setup.
/****************************************************************************/
NTSTATUS GetDescriptionOffset(void)
{
    HKEY              hTermServiceKey;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS          Status;
    UNICODE_STRING    TermServiceSubKeyString;
    UNICODE_STRING    ValueNameString;
    LONG              ResultLength;
    PKEY_VALUE_PARTIAL_INFORMATION pValueInformation;
    BYTE ValueInfo[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD) - 1];

    // Initialize UNICODE_STRING structures used in this function
    RtlInitUnicodeString(&TermServiceSubKeyString,
            L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\TermService\\Performance");
    RtlInitUnicodeString(&ValueNameString, L"First Counter");

    // Initialize the OBJECT_ATTRIBUTES structure and open the key.
    InitializeObjectAttributes(&Obja, &TermServiceSubKeyString,
            OBJ_CASE_INSENSITIVE, NULL, NULL);
    Status = NtOpenKey(&hTermServiceKey, KEY_READ, &Obja);

    if (NT_SUCCESS(Status)) {
        // read value of desired entry

        pValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)ValueInfo;
        ResultLength = sizeof(ValueInfo);

        Status = NtQueryValueKey(hTermServiceKey, &ValueNameString,
                KeyValuePartialInformation, pValueInformation,
                sizeof(ValueInfo), &ResultLength);

        if (NT_SUCCESS(Status)) {
            // Check to see if it's a DWORD.
            if (pValueInformation->DataLength == sizeof(DWORD) &&
                   pValueInformation->Type == REG_DWORD) {
                FirstCounterIndex = *((DWORD *)(pValueInformation->Data));
            }
            else {
                DBGPRINT(("PerfTS: Len %u not right or type %u not DWORD\n",
                        pValueInformation->DataLength,
                        pValueInformation->Type));
            }
        }
        else {
            DBGPRINT(("PerfTS: Could not read counter value (status=%X)\n",
                    Status));
        }

        // close the registry key
        NtClose(hTermServiceKey);
    }
    else {
        DBGPRINT(("PerfTS: Unable to open TermService\\Performance key "
                "(status=%x)\n", Status));
    }

    return Status;
}


/****************************************************************************/
// Initializes the WinStation and TermServer counter descriptions with the
// loaded counter index offset.
/****************************************************************************/
void SetupCounterIndices(void)
{
    unsigned i;
    unsigned NumCounterDefs;
    PERF_COUNTER_DEFINITION *pCounterDef;

    // First index goes to the WinStation object description and help.
    WinStationDataDefinition.WinStationObjectType.ObjectNameTitleIndex +=
            FirstCounterIndex;
    WinStationDataDefinition.WinStationObjectType.ObjectHelpTitleIndex +=
            FirstCounterIndex;

    // We need to add the FirstCounterIndex value directly into the
    // description and help indices in the WinStation counters in
    // WinStationDataDefinition.
    pCounterDef = &WinStationDataDefinition.InputWdBytes;
    NumCounterDefs = (sizeof(WinStationDataDefinition) -
            (unsigned)((BYTE *)pCounterDef -
            (BYTE *)&WinStationDataDefinition)) /
            sizeof(PERF_COUNTER_DEFINITION);

    for (i = 0; i < NumCounterDefs; i++) {
        pCounterDef->CounterNameTitleIndex += FirstCounterIndex;
        pCounterDef->CounterHelpTitleIndex += FirstCounterIndex;
        pCounterDef++;
    }

    // We need to add the FirstCounterIndex value directly into the
    // description and help indices in the TermServer counters.
    TermServerDataDefinition.TermServerObjectType.ObjectNameTitleIndex +=
            FirstCounterIndex;
    TermServerDataDefinition.TermServerObjectType.ObjectHelpTitleIndex +=
            FirstCounterIndex;
    pCounterDef = &TermServerDataDefinition.NumSessions;
    NumCounterDefs = (sizeof(TermServerDataDefinition) -
            (unsigned)((BYTE *)pCounterDef -
            (BYTE *)&TermServerDataDefinition)) /
            sizeof(PERF_COUNTER_DEFINITION);
    for (i = 0; i < NumCounterDefs; i++) {
        pCounterDef->CounterNameTitleIndex += FirstCounterIndex;
        pCounterDef->CounterHelpTitleIndex += FirstCounterIndex;
        pCounterDef++;
    }
}


/****************************************************************************/
// PerfMon open entry point.
// DeviceNames is ptr to object ID of each device to be opened.
/****************************************************************************/
DWORD APIENTRY OpenTSObject(LPWSTR DeviceNames)
{
//    DBGPRINT(("PerfTS: Open() called\n"));

    dwOpenCount++;

    // Allocate the first process info buffer.
    if (pProcessBuffer == NULL) {
        pProcessBuffer = ALLOCMEM(hLibHeap, HEAP_ZERO_MEMORY, ProcessBufSize);
        if (pProcessBuffer == NULL)
            return ERROR_OUTOFMEMORY;
    }

    return ERROR_SUCCESS;
}


/****************************************************************************/
// PerfMon close entry point.
/****************************************************************************/
DWORD APIENTRY CloseTSObject(void)
{
    PLIST_ENTRY pEntry;
    WinStationInfo *pWSI;

//    DBGPRINT(("PerfTS: Close() called\n"));

    if (--dwOpenCount == 0) {
        if (hLibHeap != NULL) {
            // Free the WinStation cache entries.
            pEntry = UsedList.Flink;
            while (!IsListEmpty(&UsedList)) {
                pEntry = RemoveHeadList(&UsedList);
                pWSI = CONTAINING_RECORD(pEntry, WinStationInfo, UsedList);
                RemoveEntryList(&pWSI->HashBucketList);
                FREEMEM(hLibHeap, 0, pWSI);
            }
            if (pWinStationHashBuckets != DefaultWinStationHashBuckets) {
                FREEMEM(hLibHeap, 0, pWinStationHashBuckets);
                pWinStationHashBuckets = DefaultWinStationHashBuckets;
                NumWinStationHashBuckets = NumDefaultWinStationHashBuckets;
            }

            // Free the proc info buffer.
            if (pProcessBuffer != NULL) {
                FREEMEM(hLibHeap, 0, pProcessBuffer);
                pProcessBuffer = NULL;
            }
        }
    }

    return ERROR_SUCCESS;
}


/****************************************************************************/
// Grabs system process information into global buffer.
/****************************************************************************/
__inline DWORD GetSystemProcessData(void)
{
    DWORD dwReturnedBufferSize;
    NTSTATUS Status;

    // Get process data from system.
    while ((Status = NtQuerySystemInformation(SystemProcessInformation,
            pProcessBuffer, ProcessBufSize, &dwReturnedBufferSize)) ==
            STATUS_INFO_LENGTH_MISMATCH) {
        BYTE *pNewProcessBuffer;

        // Expand buffer & retry. ReAlloc does not free the original mem
        // on error, so alloc into a temp pointer.
        ProcessBufSize += INCREMENT_BUFFER_SIZE;
        pNewProcessBuffer = REALLOCMEM(hLibHeap, 0, pProcessBuffer,
                ProcessBufSize);

        if (pNewProcessBuffer != NULL)
            pProcessBuffer = pNewProcessBuffer;
        else
            return ERROR_OUTOFMEMORY;
    }

    if (NT_SUCCESS(Status)) {
        // Get system time.
        Status = NtQuerySystemInformation(SystemTimeOfDayInformation,
                &SysTimeInfo, sizeof(SysTimeInfo), &dwReturnedBufferSize);
        if (!NT_SUCCESS(Status))
            Status = (DWORD)RtlNtStatusToDosError(Status);
    }
    else {
        // Convert to Win32 error.
        Status = (DWORD)RtlNtStatusToDosError(Status);
    }

    return Status;
}


/****************************************************************************/
// Creates a WinStation name based on the WinStation state.
// Assumes the cache lock is held.
/****************************************************************************/
void ConstructSessionName(
        WinStationInfo *pWSI,
        WINSTATIONINFORMATIONW *pQueryData)
{
    WCHAR *SrcName, *DstName;
    LPCTSTR pState = NULL;

    // Update active/inactive counts and create UI names for sessions.
    if (pQueryData->WinStationName[0] != '\0') {
        // We have a problem with WinStation names --
        // the '#' sign is not allowed. So, replace them
        // with spaces during name copy.
        SrcName = pQueryData->WinStationName;
        DstName = pWSI->WinStationName;
        while (*SrcName != L'\0') {
            if (*SrcName != L'#')
                *DstName = *SrcName;
            else
                *DstName = L' ';
            SrcName++;
            DstName++;
        }
        *DstName = L'\0';
    }
    else {
        // Create a fake session name based on the session ID and
        // an indication of the session state.
        _ltow(pWSI->SessionID, pWSI->WinStationName, 10);
        wcsncat(pWSI->WinStationName, L" ",1);
        pState = StrConnectState(pQueryData->ConnectState, TRUE);
        if(pState)
        {
            wcsncat(pWSI->WinStationName, (const wchar_t *)pState,    
                    (MAX_SESSION_NAME_LENGTH - 1) -
                    wcslen(pWSI->WinStationName));
        }
    }
}


/****************************************************************************/
// Adds a WinStationInfo block (with session ID already filled out) into
// the cache.
// Assumes the cache lock is held.
/****************************************************************************/
void AddWinStationInfoToCache(WinStationInfo *pWSI)
{
    unsigned i;
    unsigned Temp, NumHashBuckets;

    // Add to the hash table.
    InsertHeadList(&pWinStationHashBuckets[pWSI->SessionID &
            WinStationHashMask], &pWSI->HashBucketList);
    NumCachedWinStations++;

    // Check to see if we need to increase the hash table size.
    // If so, allocate a new one and populate it.
    // Hash table size is the number of entries * 4 rounded down
    // to the next lower power of 2, for easy key masking and higher
    // probability of having a low hash bucket list count.
    Temp = 4 * NumCachedWinStations;

    // Find the highest bit set in the hash bucket value.
    for (i = 0; Temp > 1; i++)
        Temp >>= 1;
    NumHashBuckets = 1 << i;
    if (NumWinStationHashBuckets < NumHashBuckets)
        CreateNewHashBuckets(NumHashBuckets);
}


/****************************************************************************/
// Common code for Add and RemoveWinStationInfo.
// Assumes the cache lock is held.
/****************************************************************************/
void CreateNewHashBuckets(unsigned NumHashBuckets)
{
    unsigned i, HashMask;
    PLIST_ENTRY pLI, pEntry, pTempEntry;
    WinStationInfo *pTempWSI;

    if (NumHashBuckets != NumDefaultWinStationHashBuckets)
        pLI = ALLOCMEM(hLibHeap, 0, NumHashBuckets * sizeof(LIST_ENTRY));
    else
        pLI = DefaultWinStationHashBuckets;

    if (pLI != NULL) {
        for (i = 0; i < NumHashBuckets; i++)
            InitializeListHead(&pLI[i]);

        HashMask = NumHashBuckets - 1;

        // Move the old hash table entries into the new table.
        // Have to enumerate all entries in used and unused lists
        // since we are likely to have entries scattered in both places.
        pEntry = UsedList.Flink;
        while (pEntry != &UsedList) {
            pTempWSI = CONTAINING_RECORD(pEntry, WinStationInfo,
                    UsedList);
            InsertHeadList(&pLI[pTempWSI->SessionID &
                    HashMask], &pTempWSI->HashBucketList);
            pEntry = pEntry->Flink;
        }
        pEntry = UnusedList.Flink;
        while (pEntry != &UnusedList) {
            pTempWSI = CONTAINING_RECORD(pEntry, WinStationInfo,
                    UsedList);
            InsertHeadList(&pLI[pTempWSI->SessionID &
                    HashMask], &pTempWSI->HashBucketList);
            pEntry = pEntry->Flink;
        }

        if (pWinStationHashBuckets != DefaultWinStationHashBuckets)
            FREEMEM(hLibHeap, 0, pWinStationHashBuckets);

        NumWinStationHashBuckets = NumHashBuckets;
        WinStationHashMask = HashMask;
        pWinStationHashBuckets = pLI;
    }
    else {
        // On failure, we just leave the hash table alone until next time.
        DBGPRINT(("PerfTS: Could not alloc new hash buckets\n"));
    }
}


/****************************************************************************/
// Removes a WSI from the hash table.
// Assumes the cache lock is held.
/****************************************************************************/
void RemoveWinStationInfoFromCache(WinStationInfo *pWSI)
{
    unsigned i;
    unsigned Temp, NumHashBuckets, HashMask;

    // Remove from the hash table.
    RemoveEntryList(&pWSI->HashBucketList);
    NumCachedWinStations--;

    // Check to see if we need to decrease the hash table size.
    // If so, allocate a new one and populate it.
    // Hash table size is the number of entries * 4 rounded down
    // to the next lower power of 2, for easy key masking and higher
    // probability of having a low hash bucket list count.
    Temp = 4 * NumCachedWinStations;

    // Find the highest bit set in the hash bucket value.
    for (i = 0; Temp > 1; i++)
        Temp >>= 1;
    NumHashBuckets = 1 << i;
    if (NumWinStationHashBuckets < NumHashBuckets &&
            NumWinStationHashBuckets >= 4)
        CreateNewHashBuckets(NumHashBuckets);
}


/****************************************************************************/
// PerfMon collect entry point.
// Args:
//   ValueName: Registry name.
//   ppData: Passes in pointer to the address of the buffer to receive the
//       completed PerfDataBlock and subordinate structures. This routine will
//       append its data to the buffer starting at the point referenced by
//       *ppData. Passes out pointer to the first byte after the data structure
//       added by this routine.
//   pTotalBytes: Passes in ptr to size in bytes of the buf at *ppdata. Passes
//       out number of bytes added if *ppData is changed.
//   pNumObjectTypes: Passes out the number of objects added by this routine.
//
//   Returns: Win32 error code.
/****************************************************************************/
#define WinStationInstanceSize (sizeof(PERF_INSTANCE_DEFINITION) +  \
        (MAX_WINSTATION_NAME_LENGTH + 1) * sizeof(WCHAR) +  \
        2 * sizeof(DWORD) +  /* Allow for QWORD alignment space. */  \
        sizeof(WINSTATION_COUNTER_DATA))

DWORD APIENTRY CollectTSObjectData(
        IN     LPWSTR  ValueName,
        IN OUT LPVOID  *ppData,
        IN OUT LPDWORD pTotalBytes,
        OUT    LPDWORD pNumObjectTypes)
{
    DWORD Result;
    DWORD TotalLen;  //  Length of the total return block
    PERF_INSTANCE_DEFINITION *pPerfInstanceDefinition;
    PSYSTEM_PROCESS_INFORMATION pProcessInfo;
    ULONG NumWinStationInstances;
    NTSTATUS Status;
    ULONG ProcessBufferOffset;
    WINSTATION_DATA_DEFINITION UNALIGNED* pWinStationDataDefinition;
    WINSTATION_COUNTER_DATA *pWSC;
    TERMSERVER_DATA_DEFINITION *pTermServerDataDefinition;
    TERMSERVER_COUNTER_DATA *pTSC;
    ULONG SessionId;
    WinStationInfo *pWSI = NULL;
    LIST_ENTRY *pEntry;
    unsigned i;
    unsigned ActiveWS, InactiveWS;
    WCHAR *InstanceName;
    ULONG AmountRet;
    WCHAR StringBuf[MAX_SESSION_NAME_LENGTH];
    WINSTATIONINFORMATIONW *pPassedQueryBuf;
    WINSTATIONINFORMATIONW QueryBuffer;
    LPCTSTR pState = NULL;

#ifdef COLLECT_TIME
    DWORD StartTick = GetTickCount();
#endif

//    DBGPRINT(("PerfTS: Collect() called\n"));

    pWinStationDataDefinition = (WINSTATION_DATA_DEFINITION UNALIGNED*)*ppData;

    // Check for sufficient space for base WinStation object info and
    // as many instances as we currently have in our WinStation database.
    // Add in DWORD sizes for potential QWORD alignments.
    TotalLen = sizeof(WINSTATION_DATA_DEFINITION) + sizeof(DWORD) +
            sizeof(TERMSERVER_DATA_DEFINITION) +
            sizeof(TERMSERVER_COUNTER_DATA) + sizeof(DWORD) +
            NumCachedWinStations * WinStationInstanceSize;
    if (*pTotalBytes >= TotalLen) {
        // Grab the latest system process information.
        Result = GetSystemProcessData();
        if (Result == ERROR_SUCCESS) {
            // Copy WinStation counter definitions.
            memcpy(pWinStationDataDefinition, &WinStationDataDefinition,
                    sizeof(WINSTATION_DATA_DEFINITION));
            pWinStationDataDefinition->WinStationObjectType.PerfTime =
                    SysTimeInfo.CurrentTime;
        }
        else {
            DBGPRINT(("PerfTS: Failed to get process data\n"));
            goto ErrorExit;
        }
    }
    else {
        DBGPRINT(("PerfTS: Not enough space for base WinStation information\n"));
        Result = ERROR_MORE_DATA;
        goto ErrorExit;
    }

    // Before we start, we have to transfer each WinStationInfo in the
    // cache from the used list into an unused list to detect closed
    // WinStations. Also, we need to zero each WSI's pInstanceInfo to detect
    // whether we have retrieved the current I/O data for the WinStation.
    pEntry = UsedList.Blink;
    (UsedList.Flink)->Blink = &UnusedList;  // Patch up head links to UnusedList.
    pEntry->Flink = &UnusedList;
    UnusedList = UsedList;
    InitializeListHead(&UsedList);
    pEntry = UnusedList.Flink;
    while (pEntry != &UnusedList) {
        pWSI = CONTAINING_RECORD(pEntry, WinStationInfo, UsedList);
        pWSI->pInstanceInfo = NULL;
        pEntry = pEntry->Flink;
    }

    // Now collect data for each process, summing it for each unique SessionId.
    ActiveWS = InactiveWS = 0;
    NumWinStationInstances = 0;
    ProcessBufferOffset = 0;
    pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pProcessBuffer;
    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
            &pWinStationDataDefinition[1];

    while (TRUE) {
        // Check for live process (having a name, one or more threads, or
        // not the Idle process (PID==0)). For WinStations we don't want to
        // charge the Idle process to the console (session ID == 0).
        if (pProcessInfo->ImageName.Buffer != NULL &&
                pProcessInfo->NumberOfThreads > 0 &&
                pProcessInfo->UniqueProcessId != 0) {
            // Get the session ID from the process. This is the same as the
            // LogonID in TS4.
            SessionId = pProcessInfo->SessionId;

            // Find the session ID in the cache.
            // We sum all processes seen for a given SessionId into the
            // same WinStation instance data block.
            pEntry = pWinStationHashBuckets[SessionId & WinStationHashMask].
                    Flink;
            while (pEntry != &pWinStationHashBuckets[SessionId &
                    WinStationHashMask]) {
                pWSI = CONTAINING_RECORD(pEntry, WinStationInfo,
                        HashBucketList);
                if (pWSI->SessionID == SessionId) {
                    // Found it. Now check that we've retrieved the WS info.
                    if (pWSI->pInstanceInfo != NULL) {
                        // Context is the WINSTATION_COUNTER_DATA entry
                        // for this SessionId.
                        pWSC = (WINSTATION_COUNTER_DATA *)pWSI->pInstanceInfo;

                        // Now add the values to the existing counter block.
                        UpdateWSProcessCounterBlock(pWSC, pProcessInfo);
                        goto NextProcess;
                    }
                    break;
                }
                else {
                    pEntry = pEntry->Flink;
                }
            }

            // We have a new entry or one for which we have not gathered
            // current information. First grab the info.
            if (WinStationQueryInformationW(SERVERNAME_CURRENT, SessionId,
                    WinStationInformation, &QueryBuffer,
                    sizeof(QueryBuffer), &AmountRet)) {
                if (QueryBuffer.ConnectState == State_Active)
                    ActiveWS++;
                else
                    InactiveWS++;

                // Check for a pre-cached WSI with no stats.
                if (pEntry != &pWinStationHashBuckets[SessionId &
                        WinStationHashMask]) {
                    // Verify the cached state (and thereby the name).
                    if (pWSI->LastState != QueryBuffer.ConnectState) {
                        pWSI->LastState = QueryBuffer.ConnectState;

                        ConstructSessionName(pWSI, &QueryBuffer);
                    }

                    // Remove the entry from the unused list, place on the
                    // used list.
                    RemoveEntryList(&pWSI->UsedList);
                    InsertHeadList(&UsedList, &pWSI->UsedList);
                }
                else {
                    // Alloc a new entry.
                    pWSI = ALLOCMEM(hLibHeap, 0, sizeof(WinStationInfo));
                    if (pWSI != NULL) {
                        pWSI->SessionID = SessionId;
                        pWSI->LastState = QueryBuffer.ConnectState;
                        pWSI->pInstanceInfo = NULL;
                        ConstructSessionName(pWSI, &QueryBuffer);

                        // Add to the used list.
                        InsertHeadList(&UsedList, &pWSI->UsedList);

                        // Add new entry. We may have to increase the
                        // number of hash buckets.
                        AddWinStationInfoToCache(pWSI);
                    }
                    else {
                        DBGPRINT(("PerfTS: Could not alloc new "
                                "WinStationInfo\n"));
                        goto NextProcess;
                    }
                }

                InstanceName = pWSI->WinStationName;
                pPassedQueryBuf = &QueryBuffer;
            }
            else {
                // We have a WinStation Query problem.
                DBGPRINT(("PerfTS: Failed WSQueryInfo(SessID=%u), error=%u\n",
                        SessionId, GetLastError()));

                // We could not open this WinStation, so we will identify
                // it as "ID Unknown" using -1 to StrConnectState.
                _ltow(SessionId, StringBuf, 10);
                wcsncat(StringBuf, L" ", 1);
                pState = StrConnectState(-1, TRUE);
                if (pState) {
                    wcsncat(StringBuf, (const wchar_t *)pState,
                            (MAX_SESSION_NAME_LENGTH - 1) - wcslen(StringBuf));
                }

                // Alloc a new entry.
                pWSI = ALLOCMEM(hLibHeap, 0, sizeof(WinStationInfo));
                if (pWSI != NULL) {
                    pWSI->SessionID = SessionId;
                    
                    // We don't know the last state so we'll use -1
                    pWSI->LastState = -1;
                    pWSI->pInstanceInfo = NULL;
                    
                    // Since we don't know the WinstationName, we'll use the
                    // one we generated above
                    wcsncpy(pWSI->WinStationName, 
                            StringBuf, 
                            WINSTATIONNAME_LENGTH);

                    // Add to the used list.
                    InsertHeadList(&UsedList, &pWSI->UsedList);

                    // Add new entry. We may have to increase the
                    // number of hash buckets.
                    AddWinStationInfoToCache(pWSI);
                }
                else {
                    DBGPRINT(("PerfTS: Could not alloc new "
                            "WinStationInfo\n"));
                    goto NextProcess;
                }

                InstanceName = StringBuf;
                pPassedQueryBuf = NULL;
            }

            // Add space for new instance header, name, and set of counters
            // to TotalLen and see if this instance will fit.
            TotalLen += WinStationInstanceSize;
            if (*pTotalBytes >= TotalLen) {
                NumWinStationInstances++;
            }
            else {
                DBGPRINT(("PerfTS: Not enough space for a new instance "
                        "(cur inst = %u)\n", NumWinStationInstances));
                Result = ERROR_MORE_DATA;
                goto ErrorExitFixupUsedList;
            }

            // MonBuildInstanceDefinition will create an instance of
            // the given supplied name inside of the callers buffer
            // supplied in pPerfInstanceDefinition. Our counter location
            // (the next memory after the instance header and name) is
            // returned in pWSC.
            // By remembering this pointer, and its counter size, we
            // can revisit it to add to the counters.
            MonBuildInstanceDefinition(pPerfInstanceDefinition,
                    (PVOID *)&pWSC, 0, 0, (DWORD)-1, InstanceName);

            // Initialize the new counter block.
            SetupWinStationCounterBlock(pWSC, pPassedQueryBuf);

            // Now set the Context to this counter block so if we
            // see any more processes with this SessionId we
            // can add to the existing counter block.
            pWSI->pInstanceInfo = pWSC;

            // Now load the values into the counter block
            UpdateWSProcessCounterBlock(pWSC, pProcessInfo);

            // set perfdata pointer to next byte if its a new entry
            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)(pWSC + 1);
        }

NextProcess:
        // Exit if this was the last process in list
        if (pProcessInfo->NextEntryOffset != 0) {
            // point to next buffer in list
            ProcessBufferOffset += pProcessInfo->NextEntryOffset;
            pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
                    &pProcessBuffer[ProcessBufferOffset];
        }
        else {
            break;
        }
    }

    // Check for unused WinStations and remove.
    while (!IsListEmpty(&UnusedList)) {
        pEntry = RemoveHeadList(&UnusedList);
        pWSI = CONTAINING_RECORD(pEntry, WinStationInfo, UsedList);
        RemoveWinStationInfoFromCache(pWSI);
        FREEMEM(hLibHeap, 0, pWSI);
    }

    // Note number of WinStation instances.
    pWinStationDataDefinition->WinStationObjectType.NumInstances =
            NumWinStationInstances;

    // Now we know how large an area we used for the
    // WinStation definition, so we can update the offset
    // to the next object definition. Align size on QWORD.
    pTermServerDataDefinition = (TERMSERVER_DATA_DEFINITION *)(
            ALIGN_ON_QWORD(pPerfInstanceDefinition));
    pWinStationDataDefinition->WinStationObjectType.TotalByteLength =
            (DWORD)((PCHAR)pTermServerDataDefinition -
            (PCHAR)pWinStationDataDefinition);

    // Now we set up and fill in the data for the TermServer object,
    // starting at the end of the WinStation instances.
    // No instances here, just fill in headers.
    memcpy(pTermServerDataDefinition, &TermServerDataDefinition,
            sizeof(TERMSERVER_DATA_DEFINITION));
    pTermServerDataDefinition->TermServerObjectType.PerfTime =
            SysTimeInfo.CurrentTime;
    pTSC = (TERMSERVER_COUNTER_DATA *)(pTermServerDataDefinition + 1);
    pTSC->CounterBlock.ByteLength = sizeof(TERMSERVER_COUNTER_DATA);
    pTSC->NumActiveSessions = ActiveWS;
    pTSC->NumInactiveSessions = InactiveWS;
    pTSC->NumSessions = ActiveWS + InactiveWS;

    // Return final sizes. Align final address on a QWORD size.
    *ppData = ALIGN_ON_QWORD((LPVOID)(pTSC + 1));
    pTermServerDataDefinition->TermServerObjectType.TotalByteLength =
            (DWORD)((PBYTE)*ppData - (PBYTE)pTermServerDataDefinition);
    *pTotalBytes = (DWORD)((PBYTE)*ppData - (PBYTE)pWinStationDataDefinition);
    *pNumObjectTypes = 2;

#if DBG
    if (*pTotalBytes > TotalLen)
        DbgPrint ("PerfTS: Perf ctr. instance size underestimated: "
                "Est.=%u, Actual=%u", TotalLen, *pTotalBytes);
#endif


#ifdef COLLECT_TIME
    DbgPrint("*** Elapsed msec=%u\n", GetTickCount() - StartTick);
#endif

    return ERROR_SUCCESS;


// Error handling.

ErrorExitFixupUsedList:
    // We have to return the UnusedList entries to the used list and exit the
    // cache lock.
    while (!IsListEmpty(&UnusedList)) {
        pEntry = RemoveHeadList(&UnusedList);
        InsertHeadList(&UsedList, pEntry);
    }

ErrorExit:
    *pNumObjectTypes = 0;
    *pTotalBytes = 0;
    return Result;
}


#define CalculatePercent(count, hits) ((count) ? (hits) * 100 / (count) : 0)

/****************************************************************************/
// SetupWinStationCounterBlock
//
// Initializes a new WinStation counter block.
//
// Args:
//   pCounters (input)
//     pointer to WinStation performance counter block
//
//   pInfo (input)
//     Pointer to WINSTATIONINFORMATION structure to extract counters from
//
//   pNextByte (output)
//     Returns the pointer to the byte beyound the end of the buffer.
/****************************************************************************/
void SetupWinStationCounterBlock(
        WINSTATION_COUNTER_DATA *pCounters,
        PWINSTATIONINFORMATIONW pInfo)
{
    // Fill in the WinStation information if available.
    if (pInfo != NULL) {
        PPROTOCOLCOUNTERS pi, po;
        PTHINWIRECACHE    p;
        ULONG TotalReads = 0, TotalHits = 0;
        int i;

        // Set all members of pCounters->pcd to zero since we are not going to
        // init at this time. Then set the included PERF_COUNTER_BLOCK
        // byte length.
        memset(&pCounters->pcd, 0, sizeof(pCounters->pcd));
        pCounters->pcd.CounterBlock.ByteLength = sizeof(
                WINSTATION_COUNTER_DATA);

        pi = &pInfo->Status.Input;
        po = &pInfo->Status.Output;

        // Copy input and output counters.
        memcpy(&pCounters->Input, pi, sizeof(PROTOCOLCOUNTERS));
        memcpy(&pCounters->Output, po, sizeof(PROTOCOLCOUNTERS));

        // Calculate I/O totals.
        pCounters->Total.WdBytes = pi->WdBytes + po->WdBytes;
        pCounters->Total.WdFrames = pi->WdFrames + po->WdFrames;
        pCounters->Total.Frames = pi->Frames + po->Frames;
        pCounters->Total.Bytes = pi->Bytes + po->Bytes;
        pCounters->Total.CompressedBytes = pi->CompressedBytes +
                po->CompressedBytes;
        pCounters->Total.CompressFlushes = pi->CompressFlushes +
                po->CompressFlushes;
        pCounters->Total.Errors = pi->Errors + po->Errors;
        pCounters->Total.Timeouts = pi->Timeouts + po->Timeouts;
        pCounters->Total.AsyncFramingError = pi->AsyncFramingError +
                po->AsyncFramingError;
        pCounters->Total.AsyncOverrunError = pi->AsyncOverrunError +
                po->AsyncOverrunError;
        pCounters->Total.AsyncOverflowError = pi->AsyncOverflowError +
                po->AsyncOverflowError;
        pCounters->Total.AsyncParityError = pi->AsyncParityError +
                po->AsyncParityError;
        pCounters->Total.TdErrors = pi->TdErrors + po->TdErrors;

        // Display driver cache info.

        // Bitmap cache.
        p = &pInfo->Status.Cache.Specific.IcaCacheStats.ThinWireCache[0];
        pCounters->DDBitmap.CacheReads = p->CacheReads;
        pCounters->DDBitmap.CacheHits = p->CacheHits;
        pCounters->DDBitmap.HitRatio = CalculatePercent(p->CacheReads,
                p->CacheHits);
        TotalReads += p->CacheReads;
        TotalHits += p->CacheHits;

        // Glyph cache.
        p = &pInfo->Status.Cache.Specific.IcaCacheStats.ThinWireCache[1];
        pCounters->DDGlyph.CacheReads = p->CacheReads;
        pCounters->DDGlyph.CacheHits = p->CacheHits;
        pCounters->DDGlyph.HitRatio = CalculatePercent(p->CacheReads,
                p->CacheHits);
        TotalReads += p->CacheReads;
        TotalHits += p->CacheHits;

        // Brush cache.
        p = &pInfo->Status.Cache.Specific.IcaCacheStats.ThinWireCache[2];
        pCounters->DDBrush.CacheReads = p->CacheReads;
        pCounters->DDBrush.CacheHits = p->CacheHits;
        pCounters->DDBrush.HitRatio = CalculatePercent(p->CacheReads,
                p->CacheHits);
        TotalReads += p->CacheReads;
        TotalHits += p->CacheHits;

        // Save screen bitmap cache.
        p = &pInfo->Status.Cache.Specific.IcaCacheStats.ThinWireCache[3];
        pCounters->DDSaveScr.CacheReads = p->CacheReads;
        pCounters->DDSaveScr.CacheHits = p->CacheHits;
        pCounters->DDSaveScr.HitRatio = CalculatePercent(p->CacheReads,
                p->CacheHits);
        TotalReads += p->CacheReads;
        TotalHits += p->CacheHits;

        // Cache totals.
        pCounters->DDTotal.CacheReads = TotalReads;
        pCounters->DDTotal.CacheHits = TotalHits;
        pCounters->DDTotal.HitRatio = CalculatePercent(TotalReads,
                TotalHits);

        // Compression PD ratios
        pCounters->InputCompressionRatio = CalculatePercent(
                pi->CompressedBytes, pi->Bytes);
        pCounters->OutputCompressionRatio = CalculatePercent(
                po->CompressedBytes, po->Bytes);
        pCounters->TotalCompressionRatio = CalculatePercent(
                pi->CompressedBytes + po->CompressedBytes,
                pi->Bytes + po->Bytes);
    }
    else {
        // Set all the counters to zero and then the perf block length.
        memset(pCounters, 0, sizeof(*pCounters));
        pCounters->pcd.CounterBlock.ByteLength = sizeof(
                WINSTATION_COUNTER_DATA);
    }
}


/****************************************************************************/
// UpdateWSProcessCounterBlock
//
// Add the entries for the given process to the supplied counter block
//
// Args:
//   pCounters (input)
//     pointer to WS performance counter block
//
//   ProcessInfo (input)
//     pointer to an NT SYSTEM_PROCESS_INFORMATION block
/****************************************************************************/
void UpdateWSProcessCounterBlock(
        WINSTATION_COUNTER_DATA *pCounters,
        PSYSTEM_PROCESS_INFORMATION pProcessInfo)
{
    pCounters->pcd.PageFaults += pProcessInfo->PageFaultCount;

    // User, Kernel and Processor Time counters need to be scaled by the
    // number of processors.
    pCounters->pcd.ProcessorTime += (pProcessInfo->KernelTime.QuadPart +
            pProcessInfo->UserTime.QuadPart) / NumberOfCPUs;
    pCounters->pcd.UserTime += pProcessInfo->UserTime.QuadPart /
            NumberOfCPUs;
    pCounters->pcd.KernelTime += pProcessInfo->KernelTime.QuadPart /
            NumberOfCPUs;

    pCounters->pcd.PeakVirtualSize += pProcessInfo->PeakVirtualSize;
    pCounters->pcd.VirtualSize += pProcessInfo->VirtualSize;
    pCounters->pcd.PeakWorkingSet += pProcessInfo->PeakWorkingSetSize;
    pCounters->pcd.TotalWorkingSet += pProcessInfo->WorkingSetSize;
    pCounters->pcd.PeakPageFile += pProcessInfo->PeakPagefileUsage;
    pCounters->pcd.PageFile += pProcessInfo->PagefileUsage;
    pCounters->pcd.PrivatePages += pProcessInfo->PrivatePageCount;
    pCounters->pcd.ThreadCount += pProcessInfo->NumberOfThreads;
    // BasePriority, ElapsedTime, ProcessId, CreatorProcessId not totaled.
    pCounters->pcd.PagedPool += (DWORD)pProcessInfo->QuotaPagedPoolUsage;
    pCounters->pcd.NonPagedPool += (DWORD)pProcessInfo->QuotaNonPagedPoolUsage;
    pCounters->pcd.HandleCount += (DWORD)pProcessInfo->HandleCount;
    // I/O counts not totaled at this time.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\perfts\perfutil.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1995 Microsoft Corporation

Module Name:

    perfutil.h  

Abstract:

    This file supports routines used to parse and
    create Performance Monitor Data Structures.
    It actually supports Performance Object types with
    multiple instances

Author:

    Bob Watson  28-Jul-1995

Revision History:


--*/
#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

#include <windows.h>
#include <winperf.h>

#define MAX_INSTANCE_NAME   32
#define SMALL_BUFFER_SIZE   ((DWORD)4096)
#define MEDIUM_BUFFER_SIZE  ((DWORD)(4096*8))
#define LARGE_BUFFER_SIZE   ((DWORD)(4096*16))
#define INCREMENT_BUFFER_SIZE ((DWORD)(4096*2))

#define MAX_VALUE_NAME_LENGTH 256*sizeof(WCHAR)
#define MAX_VALUE_DATA_LENGTH 256*sizeof(WCHAR)
//
//  Until USER supports Unicode, we have to work in ASCII:
//

#define DEFAULT_NT_CODE_PAGE 437
#define UNICODE_CODE_PAGE      0

// enable this define to log process heap data to the event log
#ifdef PROBE_HEAP_USAGE
#undef PROBE_HEAP_USAGE
#endif
//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//
#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))
#define QWORD_MULTIPLE(x) (((x+sizeof(LONGLONG)-1)/sizeof(LONGLONG))*sizeof(LONGLONG))

#define ALIGN_ON_DWORD(x) ((VOID *) (((ULONG_PTR) (x) + 3) & ~0x3))
#define ALIGN_ON_QWORD(x) ((VOID *) (((ULONG_PTR) (x) + 7) & ~0x7))

extern const    WCHAR  GLOBAL_STRING[];      // Global command (get all local ctrs)
extern const    WCHAR  FOREIGN_STRING[];           // get data from foreign computers
extern const    WCHAR  COSTLY_STRING[];      
extern const    WCHAR  NULL_STRING[];

extern const    WCHAR  szTotalValue[];
extern const    WCHAR  szDefaultTotalString[];
#define DEFAULT_TOTAL_STRING_LEN    14

extern DWORD  MESSAGE_LEVEL;

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

// function prototypes for data collection routines
typedef DWORD (APIENTRY PM_LOCAL_COLLECT_PROC) (LPVOID *, LPDWORD, LPDWORD);

typedef struct _POS_FUNCTION_INFO {
    DWORD   dwObjectId;
    DWORD   dwCollectFunctionBit;
    DWORD   dwDataFunctionBit;
    PM_LOCAL_COLLECT_PROC *pCollectFunction;
} POS_FUNCTION_INFO, * PPOS_FUNCTION_INFO;

//
// The definition of the only routine of perfutil.c, It builds part of a 
// performance data instance (PERF_INSTANCE_DEFINITION) as described in 
// winperf.h
//

HANDLE MonOpenEventLog (IN LPWSTR);
VOID MonCloseEventLog ();
DWORD GetQueryType (IN LPWSTR);
BOOL IsNumberInUnicodeList (DWORD, LPWSTR);

BOOL
MonBuildInstanceDefinition(
    PERF_INSTANCE_DEFINITION *pBuffer,
    PVOID *pBufferNext,
    DWORD ParentObjectTitleIndex,
    DWORD ParentObjectInstance,
    DWORD UniqueID,
    LPWSTR Name
    );

LONG
GetPerflibKeyValue (
    LPCWSTR szItem,
    DWORD   dwRegType,
    DWORD   dwMaxSize,      // ... of pReturnBuffer in bytes
    LPVOID  pReturnBuffer,
    DWORD   dwDefaultSize,  // ... of pDefault in bytes
    LPVOID  pDefault
);

//
//  Memory Probe macro
//
#ifdef PROBE_HEAP_USAGE

typedef struct _LOCAL_HEAP_INFO_BLOCK {
    DWORD   AllocatedEntries;
    DWORD   AllocatedBytes;
    DWORD   FreeEntries;
    DWORD   FreeBytes;
} LOCAL_HEAP_INFO, *PLOCAL_HEAP_INFO;

#define HEAP_PROBE()    { \
    DWORD   dwHeapStatus[5]; \
    NTSTATUS CallStatus; \
    dwHeapStatus[4] = __LINE__; \
    if (!(CallStatus = memprobe (dwHeapStatus, 16L, NULL))) { \
        REPORT_INFORMATION_DATA (TCP_HEAP_STATUS, LOG_DEBUG,    \
            &dwHeapStatus, sizeof(dwHeapStatus));  \
    } else {  \
        REPORT_ERROR_DATA (TCP_HEAP_STATUS_ERROR, LOG_DEBUG, \
            &CallStatus, sizeof (DWORD)); \
    } \
}

#else

#define HEAP_PROBE()    ;

#endif


#define ALLOCMEM(heap, flags, size)     HeapAlloc (heap, flags, size)
#define REALLOCMEM(heap, flags, pointer, newsize) \
                                    HeapReAlloc (heap, flags, pointer, newsize)
#define FREEMEM(heap, flags, pointer)   HeapFree (heap, flags, pointer)

#endif  //_PERFUTIL_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdfilter\unittest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by unittest.rc
//
#define ID_QUIT                         3
#define IDD_DISABLEDIALOG               101
#define IDC_DISABLEBACKGROUND           1000
#define ID_APPLYFILTER                  1001
#define ID_REMOVEFILTER                 1002
#define IDC_CHECK6                      1008
#define IDC_DISABLETHEMES               1008
#define IDC_DISABLEFULLWINDOWDRAG       1009
#define IDC_DISABLEMENUFADEANDSLIDE     1010
#define IDC_STATIC1                     1011
#define IDC_STATIC2                     1012
#define IDC_STATIC3                     1013
#define IDC_STATIC4                     1014

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdfilter\rdfilter.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RDFilter

Abstract:

    API's for filtering desktop visual elements for remote connections of
    varying connection speeds for performance reasons.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#include <windows.h>
#include <windowsx.h>
#include <winuser.h>
#include <winuserp.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <ocidl.h>
#include <uxthemep.h>
#include "rdfilter.h"

#if DBG
#include <stdio.h>
#include <stdarg.h>
#include <tchar.h>
#endif

//
//  Toggle Unit-Test
//
//#define UNIT_TEST

#ifdef UNIT_TEST
#include <winsta.h>
#endif

#ifdef UNIT_TEST
#include "resource.h"
#endif

//
//  Internal Defines
//
#define REFRESHTHEMESFORTS_ORDINAL  36
#define NUM_TSPERFFLAGS             10
#define BLINK_OFF                   TEXT("-1")

////////////////////////////////////////////////////////////
//
//  SystemParametersInfo UserPreferences manipulation macros
//  stolen from userk.h.
//
#define UPBOOLIndex(uSetting) \
    (((uSetting) - SPI_STARTBOOLRANGE) / 2)
#define UPBOOLPointer(pdw, uSetting)    \
    (pdw + (UPBOOLIndex(uSetting) / 32))
#define UPBOOLMask(uSetting)    \
    (1 << (UPBOOLIndex(uSetting) - ((UPBOOLIndex(uSetting) / 32) * 32)))
#define ClearUPBOOL(pdw, uSetting)    \
    (*UPBOOLPointer(pdw, uSetting) &= ~(UPBOOLMask(uSetting)))


////////////////////////////////////////////////////////////
//
//  Debugging
//

#if DBG
extern "C" ULONG DbgPrint(PCH Format, ...);
#define DBGMSG(MsgAndArgs) \
{                                   \
    DbgPrint MsgAndArgs;      \
}
#else
#define DBGMSG
#endif

//
//  Route ASSERT.
//
#undef ASSERT
#if DBG
#define ASSERT(expr) if (!(expr)) \
    { DBGMSG(("Failure at Line %d in %s\n",__LINE__, TEXT##(__FILE__)));  \
    DebugBreak(); }
#else
#define ASSERT(expr)
#endif

//
//  Internal Prototypes
//
DWORD NotifyThemes();
DWORD NotifyGdiPlus();
DWORD CreateSystemSid(PSID *ppSystemSid);
DWORD SetRegKeyAcls(HANDLE hTokenForLoggedOnUser, HKEY hKey);

//
//  Internal Types
//
typedef struct
{
    BOOL pfEnabled;
    LPCTSTR pszRegKey;
    LPCTSTR pszRegValue;
    LPCTSTR pszRegData;
    DWORD cbSize;
    DWORD dwType;
} TSPERFFLAG;

//
//  Globals
//
const LPTSTR g_ActiveDesktopKey = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Remote\\%d");
const LPTSTR g_ThemesKey        = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\ThemeManager\\Remote\\%d");
const LPTSTR g_UserKey          = TEXT("Remote\\%d\\Control Panel\\Desktop");
const LPTSTR g_GdiPlusKey       = TEXT("Remote\\%d\\GdiPlus");

UINT g_GdiPlusNotifyMsg = 0;

const LPTSTR g_GdiPlusNotifyMsgStr = TS_GDIPLUS_NOTIFYMSG_STR;

static const DWORD g_dwZeroValue = 0;

static const DWORD g_dwFontTypeStandard = 1; //Cleartype is 2

DWORD 
SetPerfFlagInReg(
    HANDLE hTokenForLoggedOnUser, 
    HKEY userHiveKey,
    DWORD sessionID,
    LPCTSTR pszRegKey, 
    LPCTSTR pszRegValue, 
    DWORD dwType, 
    void * pData, 
    DWORD cbSize, 
    BOOL fEnable
    )
/*++

Routine Description:


    Set a single perf flag, if enabled.

Arguments:

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    TCHAR szRegKey[MAX_PATH+64]; // 64 characters for the session ID, just to be safe.
    DWORD result = ERROR_SUCCESS;
    HKEY hKey = NULL;
    DWORD disposition;

    if (!fEnable) {
        goto CLEANUPANDEXIT;
    }

    //
    //  Create or open the key.
    //
    wsprintf(szRegKey, pszRegKey, sessionID);
    result = RegCreateKeyEx(userHiveKey, szRegKey, 0, L"",
                            REG_OPTION_VOLATILE, KEY_ALL_ACCESS, NULL, 
                            &hKey, &disposition);
    if (result != ERROR_SUCCESS) {
        DBGMSG(("RegCreateKeyEx:  %08X\n", result));
        goto CLEANUPANDEXIT;
    }

#ifdef UNIT_TEST
    goto CLEANUPANDEXIT;
#endif

    //
    //  Make it available to SYSTEM, only.
    //
    if (disposition == REG_CREATED_NEW_KEY) {
        result = SetRegKeyAcls(hTokenForLoggedOnUser, hKey);
        if (result != ERROR_SUCCESS) {
	    DBGMSG(("RegAcls:  %08X\n", result));
            goto CLEANUPANDEXIT;
        }
    }

    //
    //  Set the reg value.
    //
    result = RegSetValueEx(hKey, pszRegValue, 0, dwType, (PBYTE)pData, cbSize);
    if (result != ERROR_SUCCESS) {
        DBGMSG(("RegSetValue:  %08X\n", result));
    }

CLEANUPANDEXIT:

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return result;
}

DWORD 
SetPerfFlags(
    HANDLE hTokenForLoggedOnUser,
    HKEY userHiveKey,
    DWORD sessionID,
    DWORD filter,
    TSPERFFLAG flags[],
    DWORD count
    )
/*++

Routine Description:

    Set all perf flags.

Arguments:

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    DWORD nIndex;
    DWORD result = ERROR_SUCCESS;

    for (nIndex = 0; (result==ERROR_SUCCESS) && (nIndex<count); nIndex++) {
        result = SetPerfFlagInReg(
                            hTokenForLoggedOnUser,
                            userHiveKey,
                            sessionID,
                            flags[nIndex].pszRegKey, flags[nIndex].pszRegValue, 
                            flags[nIndex].dwType, (void *) flags[nIndex].pszRegData, 
                            flags[nIndex].cbSize, flags[nIndex].pfEnabled
                            );
    }

    return result;
}

DWORD 
BuildPerfFlagArray(
    HKEY hkcu,
    DWORD filter,
    OUT TSPERFFLAG **flagArray,
    OUT DWORD *count,
    DWORD **userPreferencesMask
    )
/*++

Routine Description:

    Generate the perf flag array from the filter.

Arguments:

    hkcu                 -   Logged on user's HKCU.
    filter               -   Filter
    flagArray            -   Array returned here.  Should be free'd with LocalFree
    count                -   Number of elements in returned array.
    userPreferencesMask  -   User preferences mask buffer.

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    DWORD result = ERROR_SUCCESS;
    DWORD ofs;
    HKEY hkey = NULL;
    DWORD sz;

    ofs = 0;

    // 
    //  Need to increase this if any new elements are added!
    //
    *flagArray = (TSPERFFLAG *)LocalAlloc(LPTR, sizeof(TSPERFFLAG) * NUM_TSPERFFLAGS);
    if (*flagArray == NULL) {
        result = GetLastError();
        DBGMSG(("LocalAlloc:  %08X\n", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Active Desktop
    //
    (*flagArray)[ofs].pfEnabled    = filter & TS_PERF_DISABLE_WALLPAPER;
    (*flagArray)[ofs].pszRegKey    = g_ActiveDesktopKey;
    (*flagArray)[ofs].pszRegValue  = TEXT("ActiveDesktop");
    (*flagArray)[ofs].pszRegData   = TEXT("Force Blank");  
    (*flagArray)[ofs].cbSize       = sizeof(TEXT("Force Blank"));
    (*flagArray)[ofs].dwType       = REG_SZ; ofs++;

    //
    //  TaskbarAnimations
    //
    (*flagArray)[ofs].pfEnabled    = filter & TS_PERF_DISABLE_MENUANIMATIONS;
    (*flagArray)[ofs].pszRegKey    = g_ActiveDesktopKey;
    (*flagArray)[ofs].pszRegValue  = TEXT("TaskbarAnimations");
    (*flagArray)[ofs].pszRegData   = (LPWSTR)&g_dwZeroValue;
    (*flagArray)[ofs].cbSize       = sizeof(DWORD);
    (*flagArray)[ofs].dwType       = REG_DWORD; ofs++;
    
    //
    //  Wallpaper
    //
    (*flagArray)[ofs].pfEnabled    = filter & TS_PERF_DISABLE_WALLPAPER;
    (*flagArray)[ofs].pszRegKey    = g_UserKey;
    (*flagArray)[ofs].pszRegValue  = TEXT("Wallpaper");
    (*flagArray)[ofs].pszRegData   = TEXT("");  
    (*flagArray)[ofs].cbSize       = sizeof(TEXT(""));
    (*flagArray)[ofs].dwType       = REG_SZ; ofs++;

    //
    //  Themes
    //
    (*flagArray)[ofs].pfEnabled    = filter & TS_PERF_DISABLE_THEMING;
    (*flagArray)[ofs].pszRegKey    = g_ThemesKey;
    (*flagArray)[ofs].pszRegValue  = TEXT("ThemeActive");
    (*flagArray)[ofs].pszRegData   = TEXT("0");  
    (*flagArray)[ofs].cbSize       = sizeof(TEXT("0"));
    (*flagArray)[ofs].dwType       = REG_SZ; ofs++;

    //
    //  Full Window Drag
    //
    (*flagArray)[ofs].pfEnabled    = filter & TS_PERF_DISABLE_FULLWINDOWDRAG;
    (*flagArray)[ofs].pszRegKey    = g_UserKey;
    (*flagArray)[ofs].pszRegValue  = TEXT("DragFullWindows");
    (*flagArray)[ofs].pszRegData   = TEXT("0");  
    (*flagArray)[ofs].cbSize       = sizeof(TEXT("0"));
    (*flagArray)[ofs].dwType       = REG_SZ; ofs++;

    //
    //  Smooth Scroll
    //
    (*flagArray)[ofs].pfEnabled    = filter & TS_PERF_DISABLE_MENUANIMATIONS;
    (*flagArray)[ofs].pszRegKey    = g_UserKey;
    (*flagArray)[ofs].pszRegValue  = TEXT("SmoothScroll");
    (*flagArray)[ofs].pszRegData   = TEXT("No");  
    (*flagArray)[ofs].cbSize       = sizeof(TEXT("No"));
    (*flagArray)[ofs].dwType       = REG_SZ; ofs++;


    //
    //  Cursor Blinking
    //
    (*flagArray)[ofs].pfEnabled    = filter & TS_PERF_DISABLE_CURSORSETTINGS;
    (*flagArray)[ofs].pszRegKey    = g_UserKey;
    (*flagArray)[ofs].pszRegValue  = TEXT("CursorBlinkRate");
    (*flagArray)[ofs].pszRegData   = BLINK_OFF;  
    (*flagArray)[ofs].cbSize       = sizeof(BLINK_OFF);
    (*flagArray)[ofs].dwType       = REG_SZ; ofs++;

    //
    //  Font smoothing type
    //
    (*flagArray)[ofs].pfEnabled    = filter & TS_PERF_DISABLE_CURSOR_SHADOW;
    (*flagArray)[ofs].pszRegKey    = g_UserKey;
    (*flagArray)[ofs].pszRegValue  = TEXT("FontSmoothingType");
    (*flagArray)[ofs].pszRegData   = (LPWSTR)&g_dwFontTypeStandard;  
    (*flagArray)[ofs].cbSize       = sizeof(DWORD);
    (*flagArray)[ofs].dwType       = REG_DWORD; ofs++;



    //
    //  Enhanced graphics rendering
    //
    (*flagArray)[ofs].pfEnabled    = filter & TS_PERF_ENABLE_ENHANCED_GRAPHICS;
    (*flagArray)[ofs].pszRegKey    = g_GdiPlusKey;
    (*flagArray)[ofs].pszRegValue  = TEXT("HighQualityRender");
    (*flagArray)[ofs].pszRegData   = TEXT("Yes");  
    (*flagArray)[ofs].cbSize       = sizeof(TEXT("Yes"));
    (*flagArray)[ofs].dwType       = REG_SZ; ofs++;
    
    //
    //  Set the User Preference Mask
    //  (We won't consider any failures to read reg keys, etc. below to be fatal.)
    //
    if ((filter & TS_PERF_DISABLE_MENUANIMATIONS) || (filter & TS_PERF_DISABLE_CURSOR_SHADOW)) {
        DWORD err = RegOpenKey(
                        hkcu, 
                        TEXT("Control Panel\\Desktop"),
                        &hkey
                        );
        if (err != ERROR_SUCCESS) {
            DBGMSG(("RegOpenKey:  %08X\n", err));
            goto CLEANUPANDEXIT;
        }

        //
        //  Get the size of the UserPreferences mask
        //
        err = RegQueryValueEx(
                        hkey,
                        TEXT("UserPreferencesMask"),
                        NULL,
                        NULL,
                        NULL,
                        &sz
                        );
        if (err != ERROR_SUCCESS) {
            DBGMSG(("RegQueryValue:  %08X\n", err));
            goto CLEANUPANDEXIT;
        }

        //
        //  Allocate the mask.
        //
        *userPreferencesMask = (DWORD *)LocalAlloc(LPTR, sz);
        if (*userPreferencesMask == NULL) {
            err = GetLastError();
            DBGMSG(("LocalAlloc:  %08X\n", result));
            goto CLEANUPANDEXIT;
        }

        //
        //  Fetch it.
        //
        err = RegQueryValueEx(
                        hkey,
                        TEXT("UserPreferencesMask"),
                        NULL,
                        NULL,
                        (LPBYTE)*userPreferencesMask,
                        &sz
                        );
        if (err != ERROR_SUCCESS) {
            DBGMSG(("RegQueryValue:  %08X\n", err));
            goto CLEANUPANDEXIT;
        }

        //
        //  Modify the existing User Preference Mask
        //
        if (filter & TS_PERF_DISABLE_CURSOR_SHADOW) {
            ClearUPBOOL(*userPreferencesMask, SPI_GETCURSORSHADOW);
            ClearUPBOOL(*userPreferencesMask, SPI_SETCURSORSHADOW);
        }
        
        if (filter & TS_PERF_DISABLE_MENUANIMATIONS) {
            ClearUPBOOL(*userPreferencesMask, SPI_GETMENUANIMATION);
            ClearUPBOOL(*userPreferencesMask, SPI_SETMENUANIMATION);
            ClearUPBOOL(*userPreferencesMask, SPI_GETMENUFADE);
            ClearUPBOOL(*userPreferencesMask, SPI_SETMENUFADE);
            ClearUPBOOL(*userPreferencesMask, SPI_GETTOOLTIPANIMATION);
            ClearUPBOOL(*userPreferencesMask, SPI_SETTOOLTIPANIMATION);
            ClearUPBOOL(*userPreferencesMask, SPI_GETTOOLTIPFADE);
            ClearUPBOOL(*userPreferencesMask, SPI_SETTOOLTIPFADE);
            ClearUPBOOL(*userPreferencesMask, SPI_GETCOMBOBOXANIMATION);
            ClearUPBOOL(*userPreferencesMask, SPI_SETCOMBOBOXANIMATION);
            ClearUPBOOL(*userPreferencesMask, SPI_GETLISTBOXSMOOTHSCROLLING);
            ClearUPBOOL(*userPreferencesMask, SPI_SETLISTBOXSMOOTHSCROLLING);
        }

        (*flagArray)[ofs].pfEnabled    = TRUE;
        (*flagArray)[ofs].pszRegKey    = g_UserKey;
        (*flagArray)[ofs].pszRegValue  = TEXT("UserPreferencesMask");
        (*flagArray)[ofs].pszRegData   = (LPWSTR)*userPreferencesMask;  
        (*flagArray)[ofs].cbSize       = sz;
        (*flagArray)[ofs].dwType       = REG_BINARY; ofs++;
    }


CLEANUPANDEXIT:

    if (hkey != NULL) {
        RegCloseKey(hkey);
    }

    *count = ofs;

    return result;    
}

DWORD
RDFilter_ApplyRemoteFilter(
    HANDLE hLoggedOnUserToken,
    DWORD filter,
    BOOL userLoggingOn,
    DWORD flags
    )
/*++

Routine Description:


    Applies specified filter for the active TS session by adjusting visual 
    desktop settings.  Also notifies shell, etc. that a remote filter is in place.  
    Any previous filter settings will be destroyed and overwritten.

    The context for this call should be that of the logged on user and the call
    should be made within the session for which the filter is intended to be 
    applied.

Arguments:

    hLoggedOnUserToken  -   Token for the logged on user.
    filter              -   Visual desktop filter bits as defined in tsperf.h
    userLoggingOn       -   True if this being called in the context of a user
                            logging on to a session.
    flags               -   Flags

Return Value:

    ERROR_SUCCESS on success.

 --*/
{
    DWORD result = ERROR_SUCCESS;
    HRESULT hr;
    DWORD ourSessionID;
    IPropertyBag *propBag = NULL;
    VARIANT vbool;
    DWORD tmp;
    TSPERFFLAG *flagArray = NULL;
    DWORD flagCount;
    TCHAR szRegKey[MAX_PATH + 64]; // For the session ID ... to be safe.
    HKEY hParentKey = NULL;
    BOOL impersonated = FALSE;
    DWORD *userPreferencesMask = NULL;

    HRESULT hrCoInit = CoInitialize(0);

    //
    //  Get our session ID.
    //
    if (!ProcessIdToSessionId(GetCurrentProcessId(), &ourSessionID)) {
        result = GetLastError();
        DBGMSG(("ProcessIdToSessionId:  %08X\n", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Impersonate the logged on user.
    //
    if (!ImpersonateLoggedOnUser(hLoggedOnUserToken)) {
        result = GetLastError();
        DBGMSG(("ImpersonateUser1:  %08X.\n", result));
        goto CLEANUPANDEXIT;
    }
    impersonated = TRUE;

    //
    //  Open the current user's reg key.
    //
    result = RegOpenCurrentUser(KEY_ALL_ACCESS, &hParentKey);
    RevertToSelf();
    impersonated = FALSE;
    if (result != ERROR_SUCCESS) {
        DBGMSG(("RegOpenCurrentUser:  %08X\n", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Delete all existing filters for our session.
    //
    wsprintf(szRegKey, g_ActiveDesktopKey, ourSessionID);
    RegDeleteKey(hParentKey, szRegKey);
    wsprintf(szRegKey, g_ThemesKey, ourSessionID);
    RegDeleteKey(hParentKey, szRegKey);
    wsprintf(szRegKey, g_UserKey, ourSessionID);
    RegDeleteKey(hParentKey, szRegKey);
    wsprintf(szRegKey, g_GdiPlusKey, ourSessionID);
    RegDeleteKey(hParentKey, szRegKey);

    

    //
    //  Skip setting the reg keys if there is no filter, as an optimization.
    //
    if (filter) {
        //
        //  Convert the filter into reg keys and reg settings.
        //
        result = BuildPerfFlagArray(hParentKey, filter, &flagArray, &flagCount, &userPreferencesMask);
        if (result != ERROR_SUCCESS) {
            goto CLEANUPANDEXIT;
        }

        //
        //  Apply it.
        //
        result = SetPerfFlags(hLoggedOnUserToken, hParentKey, ourSessionID, 
			      filter, flagArray, flagCount);
        if (result != ERROR_SUCCESS) {
            goto CLEANUPANDEXIT;
        }
    }

    //
    //  Impersonate the logged on user.
    //
    if (!ImpersonateLoggedOnUser(hLoggedOnUserToken)) {
        result = GetLastError();
        DBGMSG(("ImpersonateUser2:  %08X.\n", result));
        goto CLEANUPANDEXIT;
    }
    impersonated = TRUE;

    //
    //  Notify USER that we are remote.
    //
    if (!(flags & RDFILTER_SKIPUSERREFRESH)) {
        DWORD userFlags = UPUSP_REMOTESETTINGS;
        if (userLoggingOn) {
            //  USER needs to refresh all settings.
            userFlags|= UPUSP_USERLOGGEDON;
        }
        else {
            //  USER should avoid a complete refresh.
            userFlags |= UPUSP_POLICYCHANGE;
        }
        if (!UpdatePerUserSystemParameters(NULL, userFlags)) {
            result = GetLastError();
            DBGMSG(("UpdatePerUserSystemParameters1:  %08X\n", result));
            goto CLEANUPANDEXIT;
        }
    }

    //
    //  Notify Themes that we are remote.
    //
    if (!(flags & RDFILTER_SKIPTHEMESREFRESH)) {
        result = NotifyThemes();
        if (result != ERROR_SUCCESS) {
            goto CLEANUPANDEXIT;
        }
    }

    //
    //  Notify Active Desktop that we are remote.
    //
    if (!(flags & RDFILTER_SKIPSHELLREFRESH)) {
        hr = CoCreateInstance(
                        CLSID_ActiveDesktop, NULL, 
                        CLSCTX_ALL, IID_IPropertyBag, 
                        (LPVOID*)&propBag
                        );
        if (hr != S_OK) {
            DBGMSG(("CoCreateInstance:  %08X\n", hr));
            DBGMSG(("Probably didn't call CoInitialize.\n"));
            result = HRESULT_CODE(hr);
            goto CLEANUPANDEXIT;
        }
        vbool.vt = VT_BOOL;
        vbool.boolVal = VARIANT_TRUE;
        hr = propBag->Write(L"TSConnectEvent", &vbool);
        if (hr != S_OK) {
            DBGMSG(("propBag->Write:  %08X\n", hr));
            result = HRESULT_CODE(hr);
            goto CLEANUPANDEXIT;
        }
    }

CLEANUPANDEXIT:

    if (impersonated) {
        RevertToSelf();
    }

    if (propBag != NULL) {
        propBag->Release();
    }

    if (flagArray != NULL) {
        LocalFree(flagArray);
    }

    if (hParentKey != NULL) {
        RegCloseKey(hParentKey);
    }

    if (userPreferencesMask != NULL) {
        LocalFree(userPreferencesMask);
    }

    //
    //  On failure, we need to clear any remote filter settings that may
    //  have succeeded.
    //
    if (result != ERROR_SUCCESS) {
        RDFilter_ClearRemoteFilter(hLoggedOnUserToken, userLoggingOn, flags);
    }

    if ((hrCoInit == S_OK) || (hrCoInit == S_FALSE)) {
        CoUninitialize();
    }

    return result;
}

VOID 
RDFilter_ClearRemoteFilter(
    HANDLE hLoggedOnUserToken,
    BOOL userLoggingOn,
    DWORD flags
    )
/*++

Routine Description:

    Removes existing remote filter settings and notifies shell, etc. that
    a remote filter is no longer in place for the active TS session.  

    The context for this call should be that of the session for which the 
    filter is intended to be applied.

Arguments:

    hLoggedOnUserToken  -   Token for logged fon user.
    userLoggingOn       -   True if the user is actively logging on.

Return Value:

    This function will continuing attempting to clear the filter for 
    all associated components even on failure cases, so we cannot 
    say definitively whether we have failed or succeeded to clear the 
    filter.

 --*/
{
    DWORD result = ERROR_SUCCESS;
    HRESULT hr;
    IPropertyBag *propBag = NULL;
    VARIANT vbool;
    DWORD ourSessionID;
    TCHAR szRegKey[MAX_PATH + 64]; // +64 for the session ID to be safe.
    HKEY hParentKey = NULL;
    HANDLE hImp = NULL;
    BOOL impersonated = FALSE;

    HRESULT hrCoInit = CoInitialize(0);



    //
    //  Get our session ID.
    //
    if (!ProcessIdToSessionId(GetCurrentProcessId(), &ourSessionID)) {
        result = GetLastError();
        DBGMSG(("ProcessIdToSessionId:  %08X\n", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Impersonate the logged on user.
    //
    if (!ImpersonateLoggedOnUser(hLoggedOnUserToken)) {
        result = GetLastError();
        DBGMSG(("ImpersonateUser3:  %08X.\n", result));
        goto CLEANUPANDEXIT;
    }
    impersonated = TRUE;


    //
    //  Open the current user's reg key.
    //
    result = RegOpenCurrentUser(KEY_ALL_ACCESS, &hParentKey);
    RevertToSelf();
    impersonated = FALSE;
    if (result != ERROR_SUCCESS) {
        DBGMSG(("RegOpenCurrentUser:  %08X\n", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Whack the relevant remote key.
    //
    wsprintf(szRegKey, g_ActiveDesktopKey, ourSessionID);
    RegDeleteKey(hParentKey, szRegKey);
    wsprintf(szRegKey, g_ThemesKey, ourSessionID);
    RegDeleteKey(hParentKey, szRegKey);
    wsprintf(szRegKey, g_UserKey, ourSessionID);
    RegDeleteKey(hParentKey, szRegKey);
    wsprintf(szRegKey, g_GdiPlusKey, ourSessionID);
    RegDeleteKey(hParentKey, szRegKey);


    //
    //  Impersonate the logged on user.
    //
    if (!ImpersonateLoggedOnUser(hLoggedOnUserToken)) {
        result = GetLastError();
        DBGMSG(("ImpersonateUser4:  %08X.\n", result));
        goto CLEANUPANDEXIT;
    }
    impersonated = TRUE;

    //
    //  Notify USER that we are not remote.  The Policy Change flag indicates that
    //  a complete refresh should not be performed.  
    //
    if (!(flags & RDFILTER_SKIPUSERREFRESH)) {
        DWORD userFlags = UPUSP_REMOTESETTINGS;
        if (userLoggingOn) {
            //  USER needs to refresh all settings.
            userFlags |= UPUSP_USERLOGGEDON;
        }
        else {
            //  USER should avoid a complete refresh.
            userFlags |= UPUSP_POLICYCHANGE;
        }
        if (!UpdatePerUserSystemParameters(NULL, userFlags)) {
            result = GetLastError();
            DBGMSG(("UpdatePerUserSystemParameters2:  %08X\n", result));
        }
    }

    //
    //  Notify Themes that we are not remote.
    //
    if (!(flags & RDFILTER_SKIPTHEMESREFRESH)) {
        NotifyThemes();
    }

    //
    //  Notify Active Desktop that we are not remote.
    //
    if (!(flags & RDFILTER_SKIPSHELLREFRESH)) {
        hr = CoCreateInstance(
                        CLSID_ActiveDesktop, NULL, 
                        CLSCTX_ALL, IID_IPropertyBag, 
                        (LPVOID*)&propBag
                        );
        if (hr != S_OK) {
            DBGMSG(("CoCreateInstance:  %08X\n", hr));
            DBGMSG(("Probably didn't call CoInitialize.\n"));
            result = HRESULT_CODE(hr);
            goto CLEANUPANDEXIT;
        }
        vbool.vt = VT_BOOL;
        vbool.boolVal = VARIANT_FALSE;
        hr = propBag->Write(L"TSConnectEvent", &vbool);
        if (hr != S_OK) {
            DBGMSG(("propBag->Write:  %08X\n", hr));
        }
    }
    
CLEANUPANDEXIT:

    if (impersonated) {
        RevertToSelf();
    }

    if (propBag != NULL) {
        propBag->Release();
    }

    if (hParentKey != NULL) {
        RegCloseKey(hParentKey);
    }

    if ((hrCoInit == S_OK) || (hrCoInit == S_FALSE)) {
        CoUninitialize();
    }
}

DWORD
NotifyThemes()
/*++

Routine Description:

    Notify themes that our remote state has changed.

Arguments:

Return Value:

 --*/
{
    HMODULE uxthemeLibHandle = NULL;
    FARPROC func;
    DWORD result = ERROR_SUCCESS;
    HRESULT hr;
    LPSTR procAddress;

    uxthemeLibHandle = LoadLibrary(L"uxtheme.dll");
    if (uxthemeLibHandle == NULL) {
        result = GetLastError();
        DBGMSG(("LoadLibrary:  %08X\n", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Pass the RefreshThemeForTS func id as an ordinal since it's private.
    //
    procAddress = (LPSTR)REFRESHTHEMESFORTS_ORDINAL;
    func = GetProcAddress(uxthemeLibHandle, (LPCSTR)procAddress);
    if (func != NULL) {
        hr = (HRESULT) func();
        if (hr != S_OK) {
            DBGMSG(("RefreshThemeForTS:  %08X\n", hr));
            result = HRESULT_CODE(hr);
        }   
    }
    else {
        result = GetLastError();
        DBGMSG(("GetProcAddress:  %08X\n", result));              
    }
    FreeLibrary(uxthemeLibHandle);

CLEANUPANDEXIT:

    return result;
}

DWORD
NotifyGdiPlus()
/*++

Routine Description:

    Notify GdiPlus that our remote state has changed.

Arguments:

    filter  -   

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    DWORD result = ERROR_SUCCESS;
    
    if (g_GdiPlusNotifyMsg != 0) {
        g_GdiPlusNotifyMsg = RegisterWindowMessage(g_GdiPlusNotifyMsgStr);
    }

    if (g_GdiPlusNotifyMsg != 0) {
        PostMessage(HWND_BROADCAST, g_GdiPlusNotifyMsg, 0, 0);
    }
    else {
        result = GetLastError();
    }

    return result;
}

PSID
GetUserSid(
    IN HANDLE hTokenForLoggedOnUser
    )
{
/*++

Routine Description:

    Allocates memory for psid and returns the psid for the current user
    The caller should call FREEMEM to free the memory.

Arguments:

    Access Token for the User

Return Value:

    if successful, returns the PSID
    else, returns NULL

--*/
    TOKEN_USER * ptu = NULL;
    BOOL bResult;
    PSID psid = NULL;

    DWORD defaultSize = sizeof(TOKEN_USER);
    DWORD Size;
    DWORD dwResult;

    ptu = (TOKEN_USER *)LocalAlloc(LPTR, defaultSize);
    if (ptu == NULL) {
        goto CLEANUPANDEXIT;
    }

    bResult = GetTokenInformation(
                    hTokenForLoggedOnUser,  // Handle to Token
                    TokenUser,              // Token Information Class
                    ptu,                    // Buffer for Token Information
                    defaultSize,            // Size of Buffer
                    &Size);                 // Return length

    if (bResult == FALSE) {
        dwResult = GetLastError();
        if (dwResult == ERROR_INSUFFICIENT_BUFFER) {

            //
            //Allocate required memory
            //
            LocalFree(ptu);
            ptu = (TOKEN_USER *)LocalAlloc(LPTR, Size);

            if (ptu == NULL) {
                goto CLEANUPANDEXIT;
            }
            else {
                defaultSize = Size;
                bResult = GetTokenInformation(
                                hTokenForLoggedOnUser,
                                TokenUser,
                                ptu,
                                defaultSize,
                                &Size);

                if (bResult == FALSE) {  //Still failed
                    DBGMSG(("UMRDPDR:GetTokenInformation Failed, Error: %ld\n", GetLastError()));
                    goto CLEANUPANDEXIT;
                }
            }
        }
        else {
            DBGMSG(("UMRDPDR:GetTokenInformation Failed, Error: %ld\n", dwResult));
            goto CLEANUPANDEXIT;
        }
    }

    Size = GetLengthSid(ptu->User.Sid);

    //
    // Allocate memory. This will be freed by the caller.
    //

    psid = (PSID) LocalAlloc(LPTR, Size);

    if (psid != NULL) {         // Make sure the allocation succeeded
        CopySid(Size, psid, ptu->User.Sid);
    }

CLEANUPANDEXIT:
    if (ptu != NULL)
        LocalFree(ptu);

    return psid;
}

DWORD
CreateSystemSid(
    PSID *ppSystemSid
    )
/*++

Routine Description:

    Create a SYSTEM SID.

Arguments:

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    PSID pSid;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;

    if(AllocateAndInitializeSid(
            &SidAuthority,
            1,
            SECURITY_LOCAL_SYSTEM_RID,
            0, 0, 0, 0, 0, 0, 0,
            &pSid)) {
        *ppSystemSid = pSid;
    }
    else {
        dwStatus = GetLastError();
    }
    return dwStatus;
}

DWORD 
SetRegKeyAcls(
    HANDLE hTokenForLoggedOnUser,
    HKEY hKey
    )
/*++

Routine Description:

    Set a reg key so that only SYSTEM can modify.

Arguments:

    hTokenForLoggedOnUser   -   Logged on use token.
    hKey    -   Key to set.

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    PACL pAcl=NULL;
    DWORD result = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    DWORD cbAcl = 0;
    PSID  pSidSystem = NULL;
    PSID  pUserSid = NULL;

    pSecurityDescriptor = (PSECURITY_DESCRIPTOR)LocalAlloc(
                                            LPTR, sizeof(SECURITY_DESCRIPTOR)
                                            );
    if (pSecurityDescriptor == NULL) {
        DBGMSG(("Can't alloc memory for SECURITY_DESCRIPTOR\n"));
        result = GetLastError();
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the security descriptor.
    //
    if (!InitializeSecurityDescriptor(
                    pSecurityDescriptor,
                    SECURITY_DESCRIPTOR_REVISION
                    )) {
        result = GetLastError();
        DBGMSG(("InitializeSecurityDescriptor:  %08X\n", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Create the system SID.
    //
    result = CreateSystemSid(&pSidSystem);
    if (result != ERROR_SUCCESS) {
        DBGMSG(("CreateSystemSid:  %08X\n", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Get the user's SID.
    //
    pUserSid = GetUserSid(hTokenForLoggedOnUser);
    if (pUserSid == NULL) {
        goto CLEANUPANDEXIT;
    }

    //
    //  Get size of memory needed for new DACL.
    //
    cbAcl = sizeof(ACL);
    cbAcl += 1 * (sizeof(ACCESS_ALLOWED_ACE) -          // For SYSTEM ACE
            sizeof(DWORD) + GetLengthSid(pSidSystem));
    cbAcl += 1 * (sizeof(ACCESS_ALLOWED_ACE) -          // For User ACE
            sizeof(DWORD) + GetLengthSid(pUserSid));
    pAcl = (PACL) LocalAlloc(LPTR, cbAcl);
    if (pAcl == NULL) {
        DBGMSG(("Can't alloc memory for ACL\n"));
        result = GetLastError();
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the ACL.
    //
    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        result = GetLastError();
        DBGMSG(("InitializeAcl():  %08X\n", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Add the ACE's.
    //
    if (!AddAccessAllowedAceEx(pAcl,
                        ACL_REVISION,
                        //INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
                        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
                        GENERIC_READ | GENERIC_WRITE | GENERIC_ALL,
                        pSidSystem
                        )) {
        result = GetLastError();
        DBGMSG(("AddAccessAllowedAce:  %08X\n", result));
        goto CLEANUPANDEXIT;
    }
    if (!AddAccessAllowedAceEx(pAcl,
                        ACL_REVISION,
                        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
                        KEY_READ,
                        pUserSid
                        )) {
        result = GetLastError();
        DBGMSG(("AddAccessAllowedAce2:  %08X\n", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Add the DACL to the SD
    //
    if (!SetSecurityDescriptorDacl(pSecurityDescriptor,
                                  TRUE, pAcl, FALSE)) {
        result = GetLastError();
        DBGMSG(("SetSecurityDescriptorDacl:  %08X\n", result));
        goto CLEANUPANDEXIT;
    }   


    //
    // Set the registry DACL
    //
    result = RegSetKeySecurity(
                            hKey,
                            DACL_SECURITY_INFORMATION, 
                            pSecurityDescriptor
                        );
    if (result != ERROR_SUCCESS) {
        DBGMSG(("RegSetKeySecurity:  %08X\n", result));
        goto CLEANUPANDEXIT;

    }

CLEANUPANDEXIT:

    if (pUserSid != NULL) {
        LocalFree(pUserSid);
    }

    if (pSidSystem != NULL) {
        FreeSid(pSidSystem);
    }

    if (pAcl != NULL) {
        LocalFree(pAcl);
    }

    if (pSecurityDescriptor != NULL) {
        LocalFree(pSecurityDescriptor);
    }

    return result;
}

#if DBG
ULONG
DbgPrint(
    LPTSTR Format,
    ...
    )
{
    va_list arglist;
    WCHAR Buffer[512];
    INT cb;

    //
    // Format the output into a buffer and then print it.
    //

    va_start(arglist, Format);

    cb = _vsntprintf(Buffer, sizeof(Buffer), Format, arglist);
    if (cb == -1) {             // detect buffer overflow
        Buffer[sizeof(Buffer) - 3] = 0;
    }

    wcscat(Buffer, L"\r\n");

    OutputDebugString(Buffer);

    va_end(arglist);

    return 0;
}
#endif

////////////////////////////////////////////////////////////////////////////////
//
//  Unit-Test
//

#ifdef UNIT_TEST

BOOL 
GetCheckBox(
    HWND hwndDlg, 
    UINT idControl
    )
{
    return (BST_CHECKED == SendMessage((HWND)GetDlgItem(hwndDlg, idControl), BM_GETCHECK, 0, 0));
}

INT_PTR OnCommand(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = FALSE;   // Not handled
    UINT idControl = LOWORD(wParam);
    UINT idAction = HIWORD(wParam);
    DWORD result;
    DWORD filter;
    static HANDLE tokenHandle = NULL;

    if (tokenHandle == NULL) {
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, 
                            &tokenHandle)) {
            ASSERT(FALSE);
            return FALSE;
        }
    }

    switch(idControl)
    {
    case ID_QUIT:
        RDFilter_ClearRemoteFilter(tokenHandle, FALSE);
        EndDialog(hDlg, 0);
        break;

    case ID_APPLYFILTER:
        filter = 0;
        if (GetCheckBox(hDlg, IDC_DISABLEBACKGROUND)) {
            filter |= TS_PERF_DISABLE_WALLPAPER;
        }
        if (GetCheckBox(hDlg, IDC_DISABLEFULLWINDOWDRAG)) {
            filter |= TS_PERF_DISABLE_FULLWINDOWDRAG;
        }
        if (GetCheckBox(hDlg, IDC_DISABLEMENUFADEANDSLIDE)) {
            filter |= TS_PERF_DISABLE_MENUANIMATIONS;
        }
        if (GetCheckBox(hDlg, IDC_DISABLETHEMES)) {
            filter |= TS_PERF_DISABLE_THEMING;
        }
        result = RDFilter_ApplyRemoteFilter(tokenHandle, filter, FALSE);
        ASSERT(result == ERROR_SUCCESS);
        break;

    case ID_REMOVEFILTER:
        RDFilter_ClearRemoteFilter(tokenHandle, FALSE);
        break;

    default:
        break;
    }

    return fHandled;
}


INT_PTR 
TSPerfDialogProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    INT_PTR fHandled = TRUE;   // handled
    DWORD result;
    static HANDLE tokenHandle = NULL;

    if (tokenHandle == NULL) {
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, 
                            &tokenHandle)) {
            ASSERT(FALSE);
            return FALSE;
        }
    }


    switch (wMsg)
    {
    case WM_INITDIALOG:
        break;

    case WM_COMMAND:
        fHandled = OnCommand(hDlg, wMsg, wParam, lParam);
        break;

    case WM_CLOSE:
        RDFilter_ClearRemoteFilter(tokenHandle, FALSE);
        EndDialog(hDlg, 0);
        fHandled = TRUE;
        break;

    default:
        fHandled = FALSE;   // Not handled
        break;
    }

    return fHandled;
}

int PASCAL WinMain(
    HINSTANCE hInstCurrent, 
    HINSTANCE hInstPrev, 
    LPSTR pszCmdLine, 
    int nCmdShow
    )
{
    WINSTATIONCLIENT ClientData;
    DWORD Length;
    DWORD result;
    WCHAR buf[MAX_PATH];

    //
    //  Get the Remote Desktop (TS) visual filter, if it is defined.
    //
    if (!WinStationQueryInformationW(
                       SERVERNAME_CURRENT,
                       LOGONID_CURRENT,
                       WinStationClient,
                       &ClientData,
                       sizeof(ClientData),
                       &Length)) {
        MessageBox(NULL, L"WinStationQueryInformation failed.", L"Message", MB_OK);
    }
    else {
        wsprintf(buf, L"Filter for this TS session is:  %08X", ClientData.PerformanceFlags);
        MessageBox(NULL, buf, L"Message", MB_OK);
    }


    INT_PTR nResult = DialogBox(hInstCurrent, 
                            MAKEINTRESOURCE(IDD_DISABLEDIALOG), 
                            NULL, TSPerfDialogProc);

    return 0;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpclip\adcg.h ===
/**INC+**********************************************************************/
/* Header:    adcg.h                                                        */
/*                                                                          */
/* Purpose:   Precompiled header                                            */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1998                                  */
/*                                                                          */
/**INC-**********************************************************************/
#include <adcgbase.h>
#define STRSAFE_NO_DEPRECATE 1
#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\publish\makefile.inc ===
$(PROJECT_INC_PATH)\tschannl.h : $(O)\tschannl.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\tschannl.h : inc\tschannl.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\rdpdr.h : $(O)\rdpdr.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\rdpdr.h : inc\rdpdr.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\utildll.h : $(O)\utildll.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\utildll.h : inc\utildll.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\verall.h : $(O)\verall.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\verall.h : inc\verall.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\versome.h : $(O)\versome.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\versome.h : inc\versome.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\wfregupg.h : $(O)\wfregupg.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\wfregupg.h : inc\wfregupg.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\winddits.h : $(O)\winddits.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\winddits.h : inc\winddits.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\winsta.h : $(O)\winsta.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\winsta.h : inc\winsta.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\winstaw.h : $(O)\winstaw.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\winstaw.h : inc\winstaw.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\wstmsg.h : $(O)\wstmsg.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\wstmsg.h : inc\wstmsg.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\allproc.h : $(O)\allproc.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\allproc.h : inc\allproc.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\cchannel.h : $(O)\cchannel.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\cchannel.h : inc\cchannel.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\cdtapi.h : $(O)\cdtapi.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\cdtapi.h : inc\cdtapi.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\ctxdd.h : $(O)\ctxdd.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\ctxdd.h : inc\ctxdd.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\ctxdef.h : $(O)\ctxdef.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\ctxdef.h : inc\ctxdef.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\ctxver.h : $(O)\ctxver.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\ctxver.h : inc\ctxver.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\cxmsgsvc.h : $(O)\cxmsgsvc.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\cxmsgsvc.h : inc\cxmsgsvc.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\execsrv.h : $(O)\execsrv.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\execsrv.h : inc\execsrv.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\hydrix.h : $(O)\hydrix.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\hydrix.h : inc\hydrix.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\icaapi.h : $(O)\icaapi.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\icaapi.h : inc\icaapi.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\icadd.h : $(O)\icadd.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\icadd.h : inc\icadd.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\icaipx.h : $(O)\icaipx.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\icaipx.h : inc\icaipx.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\oemtdapi.h : $(O)\oemtdapi.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\oemtdapi.h : inc\oemtdapi.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\pchannel.h : $(O)\pchannel.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\pchannel.h : inc\pchannel.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\regapi.h : $(O)\regapi.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\regapi.h : inc\regapi.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\regsam.h : $(O)\regsam.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\regsam.h : inc\regsam.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\syslib.h : $(O)\syslib.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\syslib.h : inc\syslib.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\tscfgex.h : $(O)\tscfgex.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\tscfgex.h : inc\tscfgex.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\tsappcmp.h : $(O)\tsappcmp.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\tsappcmp.h : inc\tsappcmp.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\tserrs.h : $(O)\tserrs.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\tserrs.h : inc\tserrs.w
    $(CLEANSE_PUBLISHED_HDR) $? $@
    
$(PROJECT_INC_PATH)\tsperf.h : $(O)\tsperf.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\tsperf.h : inc\tsperf.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\rdfilter.h : $(O)\rdfilter.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\rdfilter.h : inc\rdfilter.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(SDK_INC_PATH)\wtsapi32.h : $(O)\wtsapi32.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\wtsapi32.h : inc\wtsapi32.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\tsqpublic.h : $(O)\tsqpublic.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\tsqpublic.h : inc\tsqpublic.w
    $(CLEANSE_PUBLISHED_HDR) $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpclip\common.inc ===
!IF 0

Copyright (c) 1989-98  Microsoft Corporation

Module Name:

    common.inc - Generic (TShare Clipboard Monitor) build definitions

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:

    Martin Richards - March 18th 1998

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

!if "$(FREEBUILD)" != "0"
! if "$(FREEBUILD)" != "1"
!error  FREEBUILD must be defined as 0 or 1 in makefile.def
! endif
!endif

#
# Disable perf by default.
# Set this to 1 to enable perf.
#
BUILD_PRF = 0

#
# Set common options
#

#
# Defining this allows windows.h to include other headers
#
NOT_LEAN_AND_MEAN = 1

UMTYPE = windows

#
# Lego options
#
!if defined(NTBBT)

NTPROFILEINPUT = 1
!endif

#
# Additional compiler flags
#
!  if defined(USE_UNICODE)
C_DEFINES = $(C_DEFINES) -DUNICODE -D_UNICODE
!  endif

!if "$(FREEBUILD)" == "0"
C_DEFINES = $(C_DEFINES) -D_DEBUG -DDEBUG
#DEBUG_CRTS = 1
#NTDEBUG = ntsd
#NTDEBUGTYPE = windbg
!endif

#
# Get all maps and syms
#
#USE_MAPSYM = 1

#
# Prevent bldnt pulling in various libraries
#
LIBC_LIB =
NO_NTDLL = 1

#
# Common compiler flags
#
C_DEFINES = $(C_DEFINES) -DSTRICT -DOS_WINDOWS $(CLIENT_SECURITY)

NTPROFILEINPUT=1
MSC_WARNING_LEVEL= $(C_WARNINGS)
# Use /WX to change warnings into errors

!if "$(FREEBUILD)" == "1"
!if "$(BUILD_PRF)"=="1"
C_DEFINES=$(C_DEFINES) -DTRC_COMPILE_LEVEL=5
!else
C_DEFINES=$(C_DEFINES) -DDC_NO_PERFORMANCE_MONITOR -DTRC_COMPILE_LEVEL=5
!endif
!else
DEBUG_DEFINE=DC_DEBUG
C_DEFINES=$(C_DEFINES) -DTRC_COMPILE_LEVEL=5 -D$(DEBUG_DEFINE) \
                       -DDC_NO_PERFORMANCE_MONITOR
!endif

!if "$(BUILD_HIPROF)"=="1"
C_DEFINES=$(C_DEFINES) -DHIPROF
!endif

!IF "$(NO_NET_DCL)" != "1"
C_DEFINES = $(C_DEFINES) -DVER_NET_DCL
!ENDIF

!IF "$(PROCESSOR_ARCHITECTURE)" == "x86" || "$(PROCESSOR_ARCHITECTURE)" == "PPC"
C_DEFINES = $(C_DEFINES) -DVER_NET_MCS
!ENDIF

# DC_NO_UNALIGNED should be set for any processor which does not allow
# non-aligned memory access
!IF "$(PROCESSOR_ARCHITECTURE)" != "x86"
C_DEFINES = $(C_DEFINES) -DDC_NO_UNALIGNED
!ENDIF

!if "$(BUILD_HIPROF)"=="1"
LINKER_FLAGS = $(LINKER_FLAGS) -FIXED:NO
!endif

NTDBGFILES=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpclip\dumpcod.c ===
#include    <windows.h>
#include    <stdlib.h>
#include    <mmsystem.h>
#include    <mmreg.h>
#include    <msacm.h>

#include    <stdlib.h>
#include    <stdio.h>

#define TSSND_NATIVE_BITSPERSAMPLE  16
#define TSSND_NATIVE_CHANNELS       2
#define TSSND_NATIVE_SAMPLERATE     22050
#define TSSND_NATIVE_BLOCKALIGN     ((TSSND_NATIVE_BITSPERSAMPLE * \
                                    TSSND_NATIVE_CHANNELS) / 8)
#define TSSND_NATIVE_AVGBYTESPERSEC (TSSND_NATIVE_BLOCKALIGN * \
                                    TSSND_NATIVE_SAMPLERATE)

#define TSSND_SAMPLESPERBLOCK       8192
//
//  Defines
//
#undef  ASSERT
#ifdef  DBG
#define TRC     _DebugMessage
#define ASSERT(_x_)     if (!(_x_)) \
                        {  TRC(FATAL, "ASSERT failed, line %d, file %s\n", \
                        __LINE__, __FILE__); DebugBreak(); }
#else   // !DBG
#define TRC
#define ASSERT
#endif  // !DBG

#define TSMALLOC( _x_ ) malloc( _x_ )
#define TSFREE( _x_ )   free( _x_ )

#ifndef G723MAGICWORD1
#define G723MAGICWORD1 0xf7329ace
#endif

#ifndef G723MAGICWORD2
#define G723MAGICWORD2 0xacdeaea2
#endif

#ifndef VOXWARE_KEY
#define VOXWARE_KEY "35243410-F7340C0668-CD78867B74DAD857-AC71429AD8CAFCB5-E4E1A99E7FFD-371"
#endif

#ifndef WMAUDIO_KEY
#define WMAUDIO_KEY "F6DC9830-BC79-11d2-A9D0-006097926036"
#endif

#ifndef WMAUDIO_DEC_KEY
#define WMAUDIO_DEC_KEY "1A0F78F0-EC8A-11d2-BBBE-006008320064"
#endif

#define WAVE_FORMAT_WMAUDIO2    0x161

const CHAR  *ALV =   "TSSNDD::ALV - ";
const CHAR  *INF =   "TSSNDD::INF - ";
const CHAR  *WRN =   "TSSNDD::WRN - ";
const CHAR  *ERR =   "TSSNDD::ERR - ";
const CHAR  *FATAL = "TSSNDD::FATAL - ";

typedef struct _VCSNDFORMATLIST {
    struct  _VCSNDFORMATLIST    *pNext;
    HACMDRIVERID    hacmDriverId;
    WAVEFORMATEX    Format;
//  additional data for the format
} VCSNDFORMATLIST, *PVCSNDFORMATLIST;

#ifdef _WIN32
#include <pshpack1.h>
#else
#ifndef RC_INVOKED
#pragma pack(1)
#endif
#endif

typedef struct wmaudio2waveformat_tag {
    WAVEFORMATEX wfx;
    DWORD        dwSamplesPerBlock; // only counting "new" samples "= half of what will be used due to overlapping
    WORD         wEncodeOptions;
    DWORD        dwSuperBlockAlign; // the big size...  should be multiples of wfx.nBlockAlign.
} WMAUDIO2WAVEFORMAT;

typedef struct msg723waveformat_tag {
    WAVEFORMATEX wfx;
    WORD         wConfigWord;
    DWORD        dwCodeword1;
    DWORD        dwCodeword2;
} MSG723WAVEFORMAT;

typedef struct intelg723waveformat_tag {
    WAVEFORMATEX wfx;
    WORD         wConfigWord;
    DWORD        dwCodeword1;
    DWORD        dwCodeword2;
} INTELG723WAVEFORMAT;

typedef struct tagVOXACM_WAVEFORMATEX 
{
    WAVEFORMATEX    wfx;
    DWORD           dwCodecId;
    DWORD           dwMode;
    char            szKey[72];
} VOXACM_WAVEFORMATEX, *PVOXACM_WAVEFORMATEX, FAR *LPVOXACM_WAVEFORMATEX;

#ifdef _WIN32
#include <poppack.h>
#else
#ifndef RC_INVOKED
#pragma pack()
#endif
#endif

/////////////////////////////////////////////////////////////////////
//
//  Tracing
//
/////////////////////////////////////////////////////////////////////

VOID
_cdecl
_DebugMessage(
    LPCSTR  szLevel,
    LPCSTR  szFormat,
    ...
    )
{
    CHAR szBuffer[256];
    va_list     arglist;

    if (szLevel == ALV)
        return;

    va_start (arglist, szFormat);
    _vsnprintf (szBuffer, sizeof(szBuffer), szFormat, arglist);
    va_end (arglist);

//    printf( "%s:%s", szLevel, szBuffer );
    OutputDebugStringA(szLevel);
    OutputDebugStringA(szBuffer);
}

/*
 *  Function:
 *      _VCSmdFindSuggestedConverter
 *
 *  Description:
 *      Searches for intermidiate converter
 *
 */
BOOL
_VCSndFindSuggestedConverter(
    HACMDRIVERID    hadid,
    LPWAVEFORMATEX  pDestFormat,
    LPWAVEFORMATEX  pInterrimFmt
    )
{
    BOOL            rv = FALSE;
    MMRESULT        mmres;
    HACMDRIVER      hacmDriver = NULL;
    HACMSTREAM      hacmStream = NULL;

    ASSERT( NULL != pDestFormat );
    ASSERT( NULL != hadid );
    ASSERT( NULL != pInterrimFmt );

    //
    //  first, open the destination acm driver
    //
    mmres = acmDriverOpen(&hacmDriver, hadid, 0);
    if ( MMSYSERR_NOERROR != mmres )
    {
        TRC(ERR, "_VCSndFindSuggestedConverter: can't "
                 "open the acm driver: %d\n",
                mmres);
        goto exitpt;
    }

    //
    //  first probe with the native format
    //  if it passes, we don't need intermidiate
    //  format converter
    //

    pInterrimFmt->wFormatTag         = WAVE_FORMAT_PCM;
    pInterrimFmt->nChannels          = TSSND_NATIVE_CHANNELS;
    pInterrimFmt->nSamplesPerSec     = TSSND_NATIVE_SAMPLERATE;
    pInterrimFmt->nAvgBytesPerSec    = TSSND_NATIVE_AVGBYTESPERSEC;
    pInterrimFmt->nBlockAlign        = TSSND_NATIVE_BLOCKALIGN;
    pInterrimFmt->wBitsPerSample     = TSSND_NATIVE_BITSPERSAMPLE;
    pInterrimFmt->cbSize             = 0;

    mmres = acmStreamOpen(
                &hacmStream,
                hacmDriver,
                pInterrimFmt,
                pDestFormat,
                NULL,           // filter
                0,              // callback
                0,              // dwinstance
                ACM_STREAMOPENF_NONREALTIME
            );

    if ( MMSYSERR_NOERROR == mmres )
    {
    //
    // format is supported
    //
        rv = TRUE;
        goto exitpt;
    } else {
        TRC(ALV, "_VCSndFindSuggestedConverter: format is not supported\n");
    }

    //
    //  find a suggested intermidiate PCM format
    //
    mmres = acmFormatSuggest(
                    hacmDriver,
                    pDestFormat,
                    pInterrimFmt,
                    sizeof( *pInterrimFmt ),
                    ACM_FORMATSUGGESTF_WFORMATTAG 
            );

    if ( MMSYSERR_NOERROR != mmres )
    {
        TRC(ALV, "_VCSndFindSuggestedConverter: can't find "
                 "interrim format: %d\n",
            mmres);
        goto exitpt;
    }

    if ( 16 != pInterrimFmt->wBitsPerSample ||
         ( 1 != pInterrimFmt->nChannels &&
           2 != pInterrimFmt->nChannels) ||
         ( 8000 != pInterrimFmt->nSamplesPerSec &&
           11025 != pInterrimFmt->nSamplesPerSec &&
           12000 != pInterrimFmt->nSamplesPerSec &&
           16000 != pInterrimFmt->nSamplesPerSec &&
           22050 != pInterrimFmt->nSamplesPerSec)
        )
    {
        TRC(ALV, "_VCSndFindSuggestedConverter: not supported "
                 "interrim format. Details:\n");
        TRC(ALV, "Channels - %d\n",         pInterrimFmt->nChannels);
        TRC(ALV, "SamplesPerSec - %d\n",    pInterrimFmt->nSamplesPerSec);
        TRC(ALV, "AvgBytesPerSec - %d\n",   pInterrimFmt->nAvgBytesPerSec);
        TRC(ALV, "BlockAlign - %d\n",       pInterrimFmt->nBlockAlign);
        TRC(ALV, "BitsPerSample - %d\n",    pInterrimFmt->wBitsPerSample);
        goto exitpt;
    }

    if ( 1 == pInterrimFmt->nChannels )
    {
        switch ( pInterrimFmt->nSamplesPerSec )
        {
        case  8000: 
        case 11025: 
        case 12000: 
        case 16000: 
        case 22050: 
            break;
        default:
            ASSERT( 0 );
        }
    } else {
        switch ( pInterrimFmt->nSamplesPerSec )
        {
        case  8000: 
        case 11025: 
        case 12000: 
        case 16000: 
        case 22050: 
            break;
        default:
            ASSERT( 0 );
        }
    }

    //
    //  probe with this format
    //
    mmres = acmStreamOpen(
                &hacmStream,
                hacmDriver,
                pInterrimFmt,
                pDestFormat,
                NULL,           // filter
                0,              // callback
                0,              // dwinstance
                ACM_STREAMOPENF_NONREALTIME
            );

    if ( MMSYSERR_NOERROR != mmres )
    {
        TRC(ALV, "_VCSndFindSuggestedConverter: probing the suggested "
                 "format failed: %d\n",
            mmres);
        goto exitpt;
    }

    TRC(ALV, "_VCSndFindSuggestedConverter: found intermidiate PCM format\n");
    TRC(ALV, "Channels - %d\n",         pInterrimFmt->nChannels);
    TRC(ALV, "SamplesPerSec - %d\n",    pInterrimFmt->nSamplesPerSec);
    TRC(ALV, "AvgBytesPerSec - %d\n",   pInterrimFmt->nAvgBytesPerSec);
    TRC(ALV, "BlockAlign - %d\n",       pInterrimFmt->nBlockAlign);
    TRC(ALV, "BitsPerSample - %d\n",    pInterrimFmt->wBitsPerSample);

    rv = TRUE;

exitpt:
    if ( NULL != hacmStream )
        acmStreamClose( hacmStream, 0 );

    if ( NULL != hacmDriver )
        acmDriverClose( hacmDriver, 0 );

    return rv;
}

/*
 *  Function:
 *      _VCSndOrderFormatList
 *
 *  Description:
 *      Order all formats in descendant order
 *
 */
VOID
_VCSndOrderFormatList(
    PVCSNDFORMATLIST    *ppFormatList,
    DWORD               *pdwNum
    )
{
    PVCSNDFORMATLIST    pFormatList;
    PVCSNDFORMATLIST    pLessThan;
    PVCSNDFORMATLIST    pPrev;
    PVCSNDFORMATLIST    pNext;
    PVCSNDFORMATLIST    pIter;
    PVCSNDFORMATLIST    pIter2;
    DWORD               dwNum = 0;

    ASSERT ( NULL != ppFormatList );

    pFormatList = *ppFormatList;
    pLessThan   = NULL;

    //
    //  fill both lists
    //
    pIter = pFormatList;
    while ( NULL != pIter )
    {
        pNext = pIter->pNext;
        pIter->pNext = NULL;

        //
        //  descending order
        //
        pIter2 = pLessThan;
        pPrev  = NULL;
        while ( NULL != pIter2 &&
                pIter2->Format.nAvgBytesPerSec >
                    pIter->Format.nAvgBytesPerSec )
        {
            pPrev  = pIter2;
            pIter2 = pIter2->pNext;
        }

        pIter->pNext = pIter2;
        if ( NULL == pPrev )
            pLessThan = pIter;
        else
            pPrev->pNext = pIter;

        pIter = pNext;
        dwNum ++;
    }

    *ppFormatList = pLessThan;

    if ( NULL != pdwNum )
        *pdwNum = dwNum;
}

//
//  puts code licensing codes into the header
//
BOOL
_VCSndFixHeader(
    PWAVEFORMATEX   pFmt,
    PWAVEFORMATEX   *ppNewFmt
    )
{
    BOOL rv = FALSE;

    *ppNewFmt = NULL;
    switch (pFmt->wFormatTag)
    {
        case WAVE_FORMAT_MSG723:
            ASSERT(pFmt->cbSize == 10);
            ((MSG723WAVEFORMAT *) pFmt)->dwCodeword1 = G723MAGICWORD1;
            ((MSG723WAVEFORMAT *) pFmt)->dwCodeword2 = G723MAGICWORD2;

            rv = TRUE;
            break;

        case WAVE_FORMAT_MSRT24:
            //
            // assume call control will take care of the other
            // params ?
            //
            ASSERT(pFmt->cbSize == 80);
            strncpy(((VOXACM_WAVEFORMATEX *) pFmt)->szKey, VOXWARE_KEY, 80);

            rv = TRUE;
            break;

        case WAVE_FORMAT_WMAUDIO2:
            if ( ((WMAUDIO2WAVEFORMAT *)pFmt)->dwSamplesPerBlock > TSSND_SAMPLESPERBLOCK )
            {
                //
                // block is too big, too high latency
                //
                break;
            }
            ASSERT( pFmt->cbSize == sizeof( WMAUDIO2WAVEFORMAT ) - sizeof( WAVEFORMATEX ));
            *ppNewFmt = TSMALLOC( sizeof( WMAUDIO2WAVEFORMAT ) + sizeof( WMAUDIO_KEY ));
            if ( NULL == *ppNewFmt )
            {
                break;
            }
            memcpy( *ppNewFmt, pFmt, sizeof( WMAUDIO2WAVEFORMAT ));
            strncpy((CHAR *)(((WMAUDIO2WAVEFORMAT *) *ppNewFmt) + 1), WMAUDIO_KEY, sizeof( WMAUDIO_KEY ));
            (*ppNewFmt)->cbSize += sizeof( WMAUDIO_KEY );
            rv = TRUE;
        break;
        default:
            rv = TRUE;
    }

    return rv;

}


/*
 *  Function:
 *      acmFormatEnumCallback
 *
 *  Description:
 *      All formats enumerator
 *
 */
BOOL
CALLBACK
acmFormatEnumCallback(
    HACMDRIVERID        hadid,       
    LPACMFORMATDETAILS  pAcmFormatDetails,  
    DWORD_PTR           dwInstance,         
    DWORD               fdwSupport          
    )
{
    PVCSNDFORMATLIST    *ppFormatList;
    PWAVEFORMATEX       pEntry, pFixedEntry = NULL;

    ASSERT(0 != dwInstance);
    ASSERT(NULL != pAcmFormatDetails);
    ASSERT(NULL != pAcmFormatDetails->pwfx);

    if ( 0 == dwInstance ||
         NULL == pAcmFormatDetails ||
         NULL == pAcmFormatDetails->pwfx )
    {

        TRC( ERR, "acmFormatEnumCallback: Invalid parameters\n" );
        goto exitpt;
    }

    ppFormatList = (PVCSNDFORMATLIST *)dwInstance;

    if (( 0 != ( fdwSupport & ACMDRIVERDETAILS_SUPPORTF_CODEC ) ||
          0 != ( fdwSupport & ACMDRIVERDETAILS_SUPPORTF_CONVERTER )) && 
         pAcmFormatDetails->pwfx->nAvgBytesPerSec < TSSND_NATIVE_AVGBYTESPERSEC
        )
    {
    //
    //  this codec should be good, save it in the list
    //  keep the list sorted in descended order
    //
        PVCSNDFORMATLIST    pIter;
        PVCSNDFORMATLIST    pPrev;
        PVCSNDFORMATLIST    pNewEntry;
        WAVEFORMATEX        WaveFormat;     // dummy parameter
        DWORD               itemsize;

        if (
            WAVE_FORMAT_PCM == pAcmFormatDetails->pwfx->wFormatTag ||
            !_VCSndFixHeader(pAcmFormatDetails->pwfx, &pFixedEntry )
            )
        {
            TRC(ALV, "acmFormatEnumCallback: unsupported format, "
                     "don't use it\n");
            goto exitpt;
        }

        pEntry = ( NULL == pFixedEntry )?pAcmFormatDetails->pwfx:pFixedEntry;

        if (!_VCSndFindSuggestedConverter(
                hadid,
                pEntry,
                &WaveFormat
            ))
        {
            TRC(ALV, "acmFormatEnumCallback: unsupported format, "
                     "don't use it\n");
            goto exitpt;
        }

        TRC(ALV, "acmFormatEnumCallback: codec found %S (%d b/s)\n",
                pAcmFormatDetails->szFormat,
                pEntry->nAvgBytesPerSec);

        itemsize = sizeof( *pNewEntry ) + pEntry->cbSize;
        pNewEntry = (PVCSNDFORMATLIST) TSMALLOC( itemsize );

        if (NULL == pNewEntry)
        {
            TRC(ERR, "acmFormatEnumCallback: can't allocate %d bytes\n",
                    itemsize);
            goto exitpt;
        }

        memcpy( &pNewEntry->Format, pEntry, 
                sizeof (pNewEntry->Format) + pEntry->cbSize );
        pNewEntry->hacmDriverId = hadid;

        pNewEntry->pNext = *ppFormatList;
        *ppFormatList = pNewEntry;

    }

exitpt:

    if ( NULL != pFixedEntry )
    {
        TSFREE( pFixedEntry );
    }

    return TRUE;
}


//
//  returns true if this codec is shipped with windows
//  because we are testing only the these
//
BOOL
AllowThisCodec( 
    HACMDRIVERID hadid 
    )
{
    ACMDRIVERDETAILS Details;
    BOOL rv = FALSE;

    static DWORD AllowedCodecs[][2] = 
                              { MM_INTEL,     503,
                                MM_MICROSOFT, MM_MSFT_ACM_IMAADPCM,
                                MM_FRAUNHOFER_IIS, 12,
                                MM_MICROSOFT, 90,
                                MM_MICROSOFT, MM_MSFT_ACM_MSADPCM,
                                MM_MICROSOFT, 39,
                                MM_MICROSOFT, MM_MSFT_ACM_G711,
                                MM_MICROSOFT, 82,
                                MM_MICROSOFT, MM_MSFT_ACM_GSM610,
                                MM_SIPROLAB,  1,
                                MM_DSP_GROUP, 1,
                                MM_MICROSOFT, MM_MSFT_ACM_PCM };


    RtlZeroMemory( &Details, sizeof( Details ));
    Details.cbStruct = sizeof( Details );

    if ( MMSYSERR_NOERROR == 
         acmDriverDetails( hadid, &Details, 0 ))
    {
        //
        //  Is this one known
        //
        DWORD count;

        for ( count = 0; count < sizeof( AllowedCodecs ) / (2 * sizeof( DWORD )); count ++ )
        {
            if ( Details.wMid == AllowedCodecs[count][0] &&
                 Details.wPid == AllowedCodecs[count][1] )
            {
                rv = TRUE;
                goto exitpt;
            }
        }
    }

exitpt:
    if ( rv )
        TRC( ALV, "ACMDRV: +++++++++++++++++++++ CODEC ALLOWED +++++++++++++++++++++++\n" );
    else
        TRC( ALV, "ACMDRV: ------------------- CODEC DISALLOWED ----------------------\n" );

    TRC( ALV, "ACMDRV: Mid: %d\n", Details.wMid );
    TRC( ALV, "ACMDRV: Pid: %d\n", Details.wPid );
    TRC( ALV, "ACMDRV: ShortName: %S\n", Details.szShortName );
    TRC( ALV, "ACMDRV: LongName: %S\n", Details.szLongName );
    TRC( ALV, "ACMDRV: Copyright: %S\n", Details.szLicensing );
    TRC( ALV, "ACMDRV: Features: %S\n", Details.szFeatures );

    return rv;
}
/*
 *  Function:
 *      acmDriverEnumCallback
 *
 *  Description:
 *      All drivers enumerator
 *
 */
BOOL
CALLBACK
acmDriverEnumCallback(
    HACMDRIVERID    hadid,  
    DWORD_PTR       dwInstance,    
    DWORD           fdwSupport     
    )
{
    PVCSNDFORMATLIST    *ppFormatList;
    MMRESULT            mmres;

    ASSERT(dwInstance);

    ppFormatList = (PVCSNDFORMATLIST *)dwInstance;

    if ( (0 != ( fdwSupport & ACMDRIVERDETAILS_SUPPORTF_CODEC ) ||
          0 != ( fdwSupport & ACMDRIVERDETAILS_SUPPORTF_CONVERTER )) &&
          AllowThisCodec(hadid) )
    {
    //
    //  a codec found
    //
        HACMDRIVER had;

        mmres = acmDriverOpen(&had, hadid, 0);
        if (MMSYSERR_NOERROR == mmres)
        {
            PWAVEFORMATEX       pWaveFormat;
            ACMFORMATDETAILS    AcmFormatDetails;
            DWORD               dwMaxFormatSize;

            //
            //  first find the max size for the format
            //
            mmres = acmMetrics( (HACMOBJ)had, 
                                ACM_METRIC_MAX_SIZE_FORMAT, 
                                (LPVOID)&dwMaxFormatSize);

            if (MMSYSERR_NOERROR != mmres ||
                dwMaxFormatSize < sizeof( *pWaveFormat ))

                dwMaxFormatSize = sizeof( *pWaveFormat );

            //
            //  Allocate the format structure
            //
            __try {
                pWaveFormat = (PWAVEFORMATEX) _alloca ( dwMaxFormatSize );
            } __except ( EXCEPTION_EXECUTE_HANDLER )
            {
                pWaveFormat = NULL;
            }

            if ( NULL == pWaveFormat )
            {
                TRC(ERR, "acmDriverEnumCallback: alloca failed for %d bytes\n",
                    dwMaxFormatSize);
                goto close_acm_driver;
            }

            //  
            //  clear the extra format data
            //
            memset( pWaveFormat + 1, 0, dwMaxFormatSize - sizeof( *pWaveFormat ));
            //
            //  create the format to convert from
            //
            pWaveFormat->wFormatTag         = WAVE_FORMAT_PCM;
            pWaveFormat->nChannels          = TSSND_NATIVE_CHANNELS;
            pWaveFormat->nSamplesPerSec     = TSSND_NATIVE_SAMPLERATE;
            pWaveFormat->nAvgBytesPerSec    = TSSND_NATIVE_AVGBYTESPERSEC;
            pWaveFormat->nBlockAlign        = TSSND_NATIVE_BLOCKALIGN;
            pWaveFormat->wBitsPerSample     = TSSND_NATIVE_BITSPERSAMPLE;
            pWaveFormat->cbSize             = 0;

            AcmFormatDetails.cbStruct     = sizeof( AcmFormatDetails );
            AcmFormatDetails.dwFormatIndex= 0;
            AcmFormatDetails.dwFormatTag  = WAVE_FORMAT_PCM;
            AcmFormatDetails.fdwSupport   = 0;
            AcmFormatDetails.pwfx         = pWaveFormat;
            AcmFormatDetails.cbwfx        = dwMaxFormatSize;

            //
            //  enum all formats supported by this driver
            //
            mmres = acmFormatEnum(
                        had,
                        &AcmFormatDetails,
                        acmFormatEnumCallback,
                        (DWORD_PTR)ppFormatList,
                        0   //ACM_FORMATENUMF_CONVERT
                        );

            if (MMSYSERR_NOERROR != mmres)
            {
                TRC(ERR, "acmDriverEnumCallback: acmFormatEnum failed %d\n",
                    mmres);
            }

close_acm_driver:
            acmDriverClose(had, 0);
        } else
            TRC(ALV, "acmDriverEnumCallback: acmDriverOpen failed: %d\n",
                        mmres);
    }

    //
    //  continue to the next driver
    //
    return TRUE;
}


/*
 *  Function:
 *      VCSndEnumAllCodecFormats
 *
 *  Description:
 *      Creates a list of all codecs/formats
 *
 */
BOOL
VCSndEnumAllCodecFormats(
    PVCSNDFORMATLIST *ppFormatList,
    DWORD            *pdwNumberOfFormats
    )
{
    BOOL             rv = FALSE;
    PVCSNDFORMATLIST pIter;
    PVCSNDFORMATLIST pPrev;
    PVCSNDFORMATLIST pNext;
    MMRESULT         mmres;
    DWORD            dwNum = 0;

    ASSERT( ppFormatList );
    ASSERT( pdwNumberOfFormats );

    *ppFormatList = NULL;

    mmres = acmDriverEnum(
        acmDriverEnumCallback,
        (DWORD_PTR)ppFormatList,
        0
        );

    if (NULL == *ppFormatList)
    {
        TRC(WRN, "VCSndEnumAllCodecFormats: acmDriverEnum failed: %d\n",
                    mmres);

        goto exitpt;
    }

    _VCSndOrderFormatList( ppFormatList, &dwNum );

    pIter = *ppFormatList;
    //
    //  number of formats is passed as UINT16, delete all after those
    //
    if ( dwNum > 0xffff )
    {
        DWORD dwLimit = 0xfffe;

        while ( 0 != dwLimit )
        {
            pIter = pIter->pNext;
            dwLimit --;
        }

        pNext = pIter->pNext;
        pIter->pNext = NULL;
        pIter = pNext;
        while( NULL != pIter )
        {
            pNext = pIter->pNext;
            TSFREE( pNext );
            pIter = pNext;
        }

        dwNum = 0xffff;
    }

    rv = TRUE;

exitpt:
    if (!rv)
    {
        //
        //  in case of error free the allocated list of formats
        //
        pIter = *ppFormatList;
        while( NULL != pIter )
        {
            PVCSNDFORMATLIST pNext = pIter->pNext;

            TSFREE( pIter );

            pIter = pNext;
        }

        *ppFormatList = NULL;

    }

    *pdwNumberOfFormats = dwNum;

    return rv;
}


int
_cdecl
wmain( void )
{
    PVCSNDFORMATLIST pFormatList = NULL;
    DWORD            dwNumberOfFormats = 0;

    printf( "// use dumpcod.c to generate this table\n" );
    printf( "//\n" );
    printf( "// FormatTag |   Channels | SamplesPerSec | AvgBytesPerSec | BlockAlign | BitsPerSamepl | ExtraInfo\n" );
    printf( "// ================================================================================================\n" );
    printf( "//\n" );
    printf( "BYTE KnownFormats[] = {\n" );

    VCSndEnumAllCodecFormats( &pFormatList, &dwNumberOfFormats );
    for ( ;pFormatList != NULL; pFormatList = pFormatList->pNext )
    {
        PWAVEFORMATEX pSndFmt = &(pFormatList->Format);
        UINT i;


        printf( "// %.3d, %.2d, %.5d, %.5d, %.3d, %.2d\n",
                    pSndFmt->wFormatTag,
                    pSndFmt->nChannels,
                    pSndFmt->nSamplesPerSec,
                    pSndFmt->nAvgBytesPerSec,
                    pSndFmt->nBlockAlign,
                    pSndFmt->wBitsPerSample);

        for ( i = 0; i < sizeof( WAVEFORMATEX ); i ++ )
        {
            printf( "0x%02x", ((PBYTE)pSndFmt)[i]);
            if ( i + 1 < sizeof( WAVEFORMATEX ) || pSndFmt->cbSize )
            {
                printf( ", " );
            }
        }
        for ( i = 0; i < pSndFmt->cbSize; i++ )
        {
            printf( "0x%02x", (((PBYTE)pSndFmt) + sizeof( WAVEFORMATEX ))[i]);
            if ( i + 1 < pSndFmt->cbSize )
            {
                printf( ", " );
            }
        }
        if ( NULL != pFormatList->pNext )
        {
            printf ( ",\n" );
        } else {
            printf( " };\n" );
        }
    }

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpclip\sclipids.h ===
//
// FILE: 
// 
// sclipids.h
//
// AUTHOR: 
//
// Elton Saul (eltons)
//
// PURPOSE: 
//
// Identifiers for the rdpclip.rc file.
//
// Copyright (c) Microsoft Corporation
//

// ------------------------------------------------------------------------------------------------

//
// String IDs
//

#define IDS_PASTE_PROGRESS_STRING 100

// ------------------------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpclip\sclip.cpp ===
/**MOD+**********************************************************************/
/* Module:    sclip.cpp                                                       */
/*                                                                          */
/* Purpose:   Server-side shared clipboard support                          */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1998-1999                             */
/*                                                                          */
/**MOD-**********************************************************************/

#include <adcg.h>

#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "sclip"
#include <atrcapi.h>

#include <pclip.h>
#include <sclip.h>
#include <winsta.h>
#include <pchannel.h>
#include <shlobj.h>
#include <wtsapi32.h>
#include <sclipids.h>

BOOL TSSNDD_Init( VOID );
BOOL TSSNDD_Loop( HINSTANCE );
VOID TSSNDD_Term( VOID );
LRESULT TSSNDD_PowerMessage( WPARAM, LPARAM );

#ifdef CLIP_TRANSITION_RECORDING

UINT g_rguiDbgLastClipState[DBG_RECORD_SIZE];
UINT g_rguiDbgLastClipEvent[DBG_RECORD_SIZE];
LONG g_uiDbgPosition = -1;

#endif // CLIP_TRANSITION_RECORDING

/****************************************************************************/
/* Global data                                                              */
/****************************************************************************/
#define DC_DEFINE_GLOBAL_DATA
#include <sclipdat.h>
#undef  DC_DEFINE_GLOBAL_DATA

/**PROC+*********************************************************************/
/* Name:      WinMain                                                       */
/*                                                                          */
/* Purpose:   Main procedure                                                */
/*                                                                          */
/* Returns:   See Windows documentation                                     */
/*                                                                          */
/**PROC-*********************************************************************/
int WINAPI WinMain(HINSTANCE hInstance,
                   HINSTANCE hPrevInstance,
                   LPSTR     lpszCmdParam,
                   int       unusedParam2)
{
    int wParam = 0;
    TRC_CONFIG trcConfig;
    WINSTATIONCONFIG config;
    BOOLEAN          fSuccess;
    ULONG            returnedLength;


    DC_BEGIN_FN("WinMain");

    DC_IGNORE_PARAMETER(hPrevInstance);
    DC_IGNORE_PARAMETER(lpszCmdParam);
    DC_IGNORE_PARAMETER(unusedParam2);

    /************************************************************************/
    /* Exit immediately if more than one copy is running                    */
    /************************************************************************/
    CBM.hMutex = CreateMutex(NULL, FALSE, TEXT("RDPCLIP is already running"));
    if (CBM.hMutex == NULL)
    {
        // An error (like out of memory) has occurred.
        TRC_ERR((TB, _T("Unable to create already running mutex!")));
        DC_QUIT;
    }
    if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        TRC_ERR((TB, _T("Second copy!")));
        DC_QUIT;
    }

    //
    // Initialize Random number generator
    //
    TSRNG_Initialize();

#ifdef DC_DEBUG
    /************************************************************************/
    /* Call trace's DLLMain, since it's directly built into RDPCLIP         */
    /************************************************************************/
    DllMain(hInstance, DLL_PROCESS_ATTACH, NULL);

    /************************************************************************/
    /* Switch off trace to file                                             */
    /************************************************************************/
    TRC_GetConfig(&trcConfig, sizeof(trcConfig));
    CLEAR_FLAG(trcConfig.flags, TRC_OPT_FILE_OUTPUT);
    TRC_SetConfig(&trcConfig, sizeof(trcConfig));
#endif

    /************************************************************************/
    /* Get WinStation configuration                                         */
    /************************************************************************/
    fSuccess = WinStationQueryInformation(NULL, LOGONID_CURRENT,
                    WinStationConfiguration, &config,
                    sizeof(config), &returnedLength);
    if (!fSuccess)
    {
        TRC_ERR((TB, _T("Failed to get WinStation config, %d"), GetLastError()));
        goto exitme;
    }


    if ( !config.User.fDisableCam )
        TSSNDD_Init();

    if ( !config.User.fDisableClip )
        wParam = CBM_Main(hInstance);
    else
    {
        //
        //  we need some window to handle the close event
        //
        if ( !config.User.fDisableCam )
            wParam = TSSNDD_Loop(hInstance);
    }

    if ( !config.User.fDisableCam )
        TSSNDD_Term();

    //
    // Terminate Random number generator
    //
    TSRNG_Shutdown();


exitme:

#ifdef DC_DEBUG
/****************************************************************************/
/* Tell trace we're terminating                                             */
/****************************************************************************/
    DllMain(hInstance, DLL_PROCESS_DETACH, NULL);
#endif

DC_EXIT_POINT:
    /************************************************************************/
    /* Release the run once mutex                                           */
    /************************************************************************/
    if (CBM.hMutex != NULL) {
        TRC_NRM((TB, _T("Closing already running mutex")));
        CloseHandle(CBM.hMutex);
    }

    DC_END_FN();
    return(wParam);
}


/****************************************************************************/
/* CBM_Main                                                                 */
/****************************************************************************/
DCINT DCAPI CBM_Main(HINSTANCE hInstance)
{
    ATOM             registerClassRc = 0;
    DCUINT32         threadID;
    MSG              msg;
    HANDLE           hEvent;
    DCTCHAR          eventName[64];
    DWORD            dwResult;
    HRESULT          hr ;
    INT              iRet;
    INT              cbWritten;
    
    DC_BEGIN_FN("CBM_Main");

    /************************************************************************/
    // Clear global memory
    /************************************************************************/
    DC_MEMSET(&CBM, 0, sizeof(CBM));

    //
    // Load the paste information string.
    //

    iRet = LoadStringW(
        hInstance,
        IDS_PASTE_PROGRESS_STRING,
        CBM.szPasteInfoStringW,
        PASTE_PROGRESS_STRING_LENGTH);

    if (iRet == 0) {
        TRC_SYSTEM_ERROR("LoadString");
        CBM.szPasteInfoStringW[0] = NULL;
    }

    cbWritten = WideCharToMultiByte(
        CP_ACP,
        0,
        CBM.szPasteInfoStringW,
        -1,
        CBM.szPasteInfoStringA,
        sizeof(CBM.szPasteInfoStringA),
        NULL,
        NULL);

    if (cbWritten == 0) {
        TRC_ERR((TB, _T("Failed to load ANSI paste progress string: %s")));
        CBM.szPasteInfoStringA[0] = NULL;
    }

    //
    // Initialize the data transfer object that contains the IDataObject,
    // and then initialize Ole
    CBM.pClipData = new CClipData();
    if (CBM.pClipData == NULL) {
        TRC_ERR((TB, _T("Failed to allocate memory for CClipData")));
        DC_QUIT;
    }
    else
    {
        CBM.pClipData->AddRef();
    }

    hr = OleInitialize(NULL);
    if (FAILED(hr)) {
        TRC_ERR((TB, _T("Failed to initialize OLE")));
        DC_QUIT;
    }
    
    /************************************************************************/
    // Get session information
    /************************************************************************/
    if (!ProcessIdToSessionId(GetCurrentProcessId(), &CBM.logonId))
    {
        dwResult = GetLastError();
        TRC_ERR((TB, _T("Failed to get Session Id info, %d"), dwResult));
        DC_QUIT;
    }
    TRC_NRM((TB, _T("Logon ID %d"), CBM.logonId));

    //
    // Create DataSync events
    //
    CBM.GetDataSync[TS_BLOCK_RECEIVED] = CreateEvent(NULL, FALSE, FALSE, NULL) ;
    CBM.GetDataSync[TS_RECEIVE_COMPLETED] = CreateEvent(NULL, FALSE, FALSE, NULL) ;
    CBM.GetDataSync[TS_DISCONNECT_EVENT] = CreateEvent(NULL, TRUE, FALSE, NULL) ;
    CBM.GetDataSync[TS_RESET_EVENT] = CreateEvent(NULL, TRUE, FALSE, NULL) ;

    if (!CBM.GetDataSync[TS_BLOCK_RECEIVED] || !CBM.GetDataSync[TS_RECEIVE_COMPLETED] || 
        !CBM.GetDataSync[TS_RESET_EVENT] || !CBM.GetDataSync[TS_DISCONNECT_EVENT]) {
        TRC_ERR((TB, _T("CreateEvent Failed; a GetDataSync is NULL"))) ;
        DC_QUIT;
    }

    /************************************************************************/
    /* Create read and write completion events                              */
    /************************************************************************/
    CBM.readOL.hEvent = CreateEvent(NULL,    // no security attribute
                                    TRUE,    // manual-reset event
                                    FALSE,   // initial state = not signaled
                                    NULL);   // unnamed event object
    if (CBM.readOL.hEvent == NULL)
    {
        dwResult = GetLastError();
        TRC_ERR((TB, _T("Failed to create read completion event, %d"),
                dwResult));
        DC_QUIT;
    }
    CBM.hEvent[CLIP_EVENT_READ] = CBM.readOL.hEvent;

    CBM.writeOL.hEvent = CreateEvent(NULL,    // no security attribute
                                     TRUE,    // manual-reset event
                                     FALSE,   // initial state = not signaled
                                     NULL);   // unnamed event object
    if (CBM.writeOL.hEvent == NULL)
    {
        dwResult = GetLastError();
        TRC_ERR((TB, _T("Failed to create write completion event, %d"),
                dwResult));
        DC_QUIT;
    }

    /************************************************************************/
    /* Create disconnect & reconnect events                                 */
    /************************************************************************/
    DC_TSTRCPY(eventName, 
        _T("RDPClip-Disconnect"));

    hEvent = CreateEvent(NULL, FALSE, FALSE, eventName);
    if (hEvent == NULL)
    {
        dwResult = GetLastError();
        TRC_ERR((TB, _T("Failed to create event %s, %d"),
                eventName, dwResult));
        DC_QUIT;
    }
    CBM.hEvent[CLIP_EVENT_DISCONNECT] = hEvent;
    TRC_NRM((TB, _T("Created event %s, %p"), eventName, hEvent));

    DC_TSTRCPY(eventName, 
        _T("RDPClip-Reconnect"));    
    
    hEvent = CreateEvent(NULL, FALSE, FALSE, eventName);
    if (hEvent == NULL)
    {
        dwResult = GetLastError();
        TRC_ERR((TB, _T("Failed to create event %s, %d"),
                eventName, dwResult));
        DC_QUIT;
    }
    CBM.hEvent[CLIP_EVENT_RECONNECT] = hEvent;
    TRC_NRM((TB, _T("Created event %s, %p"), eventName, hEvent));

    TRC_NRM((TB, _T("Created events: Read %p, Write %p, Disc %p, Reco %p"),
        CBM.hEvent[CLIP_EVENT_READ], CBM.writeOL.hEvent,
        CBM.hEvent[CLIP_EVENT_DISCONNECT], CBM.hEvent[CLIP_EVENT_RECONNECT]));

    CBM.fFileCutCopyOn = FALSE;

    /************************************************************************/
    /* Create our (invisible) window which we will register as a clipboard  */
    /* viewer                                                               */
    /************************************************************************/
    TRC_NRM((TB, _T("Register Main Window class")));
    CBM.viewerWindowClass.style         = 0;
    CBM.viewerWindowClass.lpfnWndProc   = CBMWndProc;
    CBM.viewerWindowClass.cbClsExtra    = 0;
    CBM.viewerWindowClass.cbWndExtra    = 0;
    CBM.viewerWindowClass.hInstance     = hInstance;
    CBM.viewerWindowClass.hIcon         = NULL;
    CBM.viewerWindowClass.hCursor       = NULL;
    CBM.viewerWindowClass.hbrBackground = (HBRUSH) GetStockObject(HOLLOW_BRUSH);
    CBM.viewerWindowClass.lpszMenuName  = NULL;
    CBM.viewerWindowClass.lpszClassName = CBM_VIEWER_CLASS;

    registerClassRc = RegisterClass (&(CBM.viewerWindowClass));

    if (registerClassRc == 0)
    {
        /********************************************************************/
        /* Failed to register CB viewer class                               */
        /********************************************************************/
        TRC_ERR((TB, _T("Failed to register Cb Viewer class")));
        DC_QUIT;
    }

    TRC_DBG((TB, _T("Create main window")));
    CBM.viewerWindow =
       CreateWindow(CBM_VIEWER_CLASS,           /* window class name        */
                    _T("CB Monitor Window"),    /* window caption           */
                    WS_OVERLAPPEDWINDOW,        /* window style             */
                    0,                          /* initial x position       */
                    0,                          /* initial y position       */
                    100,                        /* initial x size           */
                    100,                        /* initial y size           */
                    NULL,                       /* parent window            */
                    NULL,                       /* window menu handle       */
                    hInstance,                  /* program inst handle      */
                    NULL);                      /* creation parameters      */

    /************************************************************************/
    /* Check we created the window OK                                       */
    /************************************************************************/
    if (CBM.viewerWindow == NULL)
    {
        TRC_ERR((TB, _T("Failed to create CB Viewer Window")));
        DC_QUIT;
    }
    TRC_DBG((TB, _T("Viewer Window handle %x"), CBM.viewerWindow));

    /************************************************************************/
    /* Register a message for communication between the two threads         */
    /************************************************************************/
    CBM.regMsg = RegisterWindowMessage(_T("Clip Message"));
    if (CBM.regMsg == 0)
    {
        /********************************************************************/
        /* Failed to register a message - use a WM_USER message instead     */
        /********************************************************************/
        TRC_ERR((TB, _T("Failed to register a window message")));
        CBM.regMsg = WM_USER_DD_KICK;
    }
    TRC_NRM((TB, _T("Registered window message %x"), CBM.regMsg));
    
    /************************************************************************/
    /* we're now finished with creating things                              */
    /************************************************************************/
    CBM_SET_STATE(CBM_STATE_INITIALIZED, CBM_EVENT_CBM_MAIN);

    /************************************************************************/
    /* Do (re)connection stuff                                              */
    /************************************************************************/
    CBMReconnect();

    /************************************************************************/
    /* set up the second thread                                             */
    /************************************************************************/
    TRC_DBG((TB, _T("Start second thread")));
    CBM.runThread = TRUE;
    CBM.hDataThread = CreateThread
          ( NULL,                  // pointer to thread security attribs
            0,                     // initial thread stack size, in bytes
            CBMDataThreadProc,     // pointer to thread function
            NULL,                  // argument for new thread
            0,                     // creation flags
            &threadID);            // pointer to returned thread id

    if (CBM.hDataThread == NULL)
    {
        /********************************************************************/
        /* thread creation failed - oh dear!                                */
        /********************************************************************/
        TRC_ERR((TB, _T("Failed to create second thread - quit")));
        DC_QUIT;
    }

    TRC_DBG((TB,_T("Entering message loop")));
    while (GetMessage (&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    TRC_DBG((TB,_T("Exiting message loop")));

DC_EXIT_POINT:
    /************************************************************************/
    /* Do the tidy up...                                                    */
    /*                                                                      */
    /* Start by stopping the second thread (if any!) and removing the       */
    /* event.                                                               */
    /************************************************************************/
    CBMTerm();

    /************************************************************************/
    /* Destroy the window                                                   */
    /************************************************************************/
    if (CBM.viewerWindow)
    {
        TRC_DBG((TB, _T("destroying window %p"), CBM.viewerWindow));
        if (!DestroyWindow(CBM.viewerWindow))
        {
            TRC_SYSTEM_ERROR("DestroyWindow");
        }
    }

    /************************************************************************/
    /* Unregister the class                                                 */
    /************************************************************************/
    if (registerClassRc != 0)
    {
        TRC_NRM((TB, _T("Unregister window class")));
        if (!UnregisterClass(CBM_VIEWER_CLASS, hInstance))
        {
            TRC_SYSTEM_ERROR("UnregisterClass");
        }
    }

    DC_END_FN();
    return(0);
} /* CBM_Main */

/****************************************************************************/
/* CBMRemoteFormatFromLocalID                                               */
/****************************************************************************/
DCUINT DCINTERNAL CBMRemoteFormatFromLocalID(DCUINT id)
{
    DCUINT i ;
    DCUINT retID = 0;

    DC_BEGIN_FN("CBMRemoteFormatFromLocalID");

    for (i = 0; i < CB_MAX_FORMATS; i++)
    {
        if (CBM.idMap[i].serverID == id)
        {
            retID = CBM.idMap[i].clientID;
            break;
        }
    }

    //TRC_ASSERT((retID != 0), (TB, _T("0 client id for server id %d"), id));
    DC_END_FN();
    return(retID);
}


/****************************************************************************/
/* CBMCheckState                                                            */
/****************************************************************************/
DCUINT DCINTERNAL CBMCheckState(DCUINT event)
{
    DCUINT tableVal = cbmStateTable[event][CBM.state];

    DC_BEGIN_FN("CBMCheckState");

    TRC_DBG((TB, _T("Test event %d (%s) in state %d (%s), result = %d (%s)"),
                event, cbmEvent[event],
                CBM.state, cbmState[CBM.state],
                tableVal, tableVal == CBM_TABLE_OK   ? _T("OK") :
                          tableVal == CBM_TABLE_WARN ? _T("Warn") :
                                                       _T("Error") ));

    if (tableVal != CBM_TABLE_OK)
    {
        if (tableVal == CBM_TABLE_WARN)
        {
            TRC_ALT((TB, _T("Unusual event %s in state %s"),
                      cbmEvent[event], cbmState[CBM.state]));
        }
        else
        {
            TRC_ABORT((TB, _T("Invalid event %s in state %s"),
                      cbmEvent[event], cbmState[CBM.state]));
        }
    }

    DC_END_FN();
    return(tableVal);
}

/****************************************************************************/
/* CB window proc                                                           */
/****************************************************************************/
LRESULT CALLBACK CBMWndProc(HWND   hwnd,
                            UINT   message,
                            WPARAM wParam,
                            LPARAM lParam)
{
    LRESULT         rc = 0;
    DCBOOL          drawRc;
    PTS_CLIP_PDU    pClipPDU;
    ULONG_PTR       size;
#ifdef DC_DEBUG
    HDC             hdc;
    PAINTSTRUCT     ps;
    RECT            rect;
#endif

    DC_BEGIN_FN("CBMWndProc");

    /************************************************************************/
    /* First of all, handle messages from the 2nd thread                    */
    /************************************************************************/
    if (message == CBM.regMsg)
    {
        TRC_NRM((TB, _T("Message from second thread")));

        /********************************************************************/
        /* Handle 0-length messages (lParam = event)                        */
        /********************************************************************/
        if (wParam == 0)
        {
            TRC_NRM((TB, _T("0-length")));
            if (lParam == CLIP_EVENT_DISCONNECT)
            {
                TRC_NRM((TB, _T("Disconnected indication")));
                CBMDisconnect();
            }
            else if (lParam == CLIP_EVENT_RECONNECT)
            {
                TRC_NRM((TB, _T("Reconnected indication")));
                CBMReconnect();
            }
            else
            {
                TRC_ERR((TB, _T("Unknown event %d"), lParam));
            }
            DC_QUIT;
        }

        /********************************************************************/
        /* Handle real messages (lParam = PDU)                              */
        /********************************************************************/
        size = (ULONG_PTR)wParam;
        pClipPDU = (PTS_CLIP_PDU)lParam;       

        switch (pClipPDU->msgType)
        {
            case TS_CB_FORMAT_LIST:
            {
                // Validate a full TS_CLIP_PDU can be read
                if (FIELDOFFSET(TS_CLIP_PDU, data) > size) {
                    TRC_ERR((TB,_T("TS_CB_FORMAT_LIST Not enough header ")
                        _T("data [needed=%u got=%u]"), 
                        FIELDOFFSET(TS_CLIP_PDU, data), size));
                    break;
                }

                // Validate there is as much data as the packet advertises
                if (FIELDOFFSET(TS_CLIP_PDU,data) + pClipPDU->dataLen > size) {
                    TRC_ERR((TB,_T("TS_CB_FORMAT_LIST Not enough packet ")
                        _T("data [needed=%u got=%u]"), 
                        FIELDOFFSET(TS_CLIP_PDU, data) + pClipPDU->dataLen, 
                        size));                    
                    break;
                }   
                
                TRC_NRM((TB, _T("TS_CB_FORMAT_LIST received")));
                CBMOnFormatList(pClipPDU);
            }
            break;

            case TS_CB_MONITOR_READY:
            {
                TRC_ERR((TB, _T("Unexpected Monitor ready event!")));
            }
            break;

            default:
            {
                TRC_ERR((TB, _T("Unknown event %d"), pClipPDU->msgType));
            }
            break;
        }

        TRC_NRM((TB, _T("Freeing processed PDU")));
        LocalFree(pClipPDU);

        DC_QUIT;
    }

    /************************************************************************/
    /* Now process constant messages                                        */
    /************************************************************************/
    switch (message)
    {
        case WM_CREATE:
        {           
            /****************************************************************/
            /* We've been created - check the state                         */
            /****************************************************************/
            CBM_CHECK_STATE(CBM_EVENT_WM_CREATE);

            TRC_NRM((TB, _T("Event CBM_EVENT_WM_CREATE OK")));
            /****************************************************************/
            /* Add the window to the clipboard viewer chain.                */
            /****************************************************************/
            TRC_NRM((TB, _T("SetClipboardViewer")));
            CBM.nextViewer = SetClipboardViewer(hwnd);
            CBM.fInClipboardChain = TRUE;
            TRC_NRM((TB,_T("CBM.fInClipboardChain=%d"),
                CBM.fInClipboardChain ? 1 : 0 ));                            
            TRC_NRM((TB, _T("Back from SetClipboardViewer")));

            /************************************************************************/
            /* Register for TS session notifications                                */
            /************************************************************************/
            CBM.fRegisteredForSessNotif = WTSRegisterSessionNotification(hwnd, NOTIFY_FOR_THIS_SESSION);
            if (0 == CBM.fRegisteredForSessNotif) {
                TRC_ERR((TB,_T("Failed to register for session notifications")));
            }
        }
        break;

#ifdef DC_DEBUG
        case WM_PAINT:
        {
            /****************************************************************/
            /* paint the window!                                            */
            /****************************************************************/
            hdc = BeginPaint(hwnd, &ps);
            GetClientRect(hwnd, &rect);
            FillRect(hdc, &rect, WHITE_BRUSH);
            EndPaint(hwnd, &ps);
        }
        break;
#endif

        case WM_DESTROY:
        {
            /****************************************************************/
            /* We're being destroyed - check the state                      */
            /****************************************************************/
            CBM_CHECK_STATE(CBM_EVENT_WM_DESTROY);
            TRC_NRM((TB, _T("WM_DESTROY")));

            /****************************************************************/
            /* Remove ourselves from the CB Chain                           */
            /****************************************************************/
            if (CBM.fInClipboardChain) {
                if (!ChangeClipboardChain(hwnd, CBM.nextViewer))
                {
                    TRC_SYSTEM_ERROR("ChangeClipboardChain");
                }
                CBM.nextViewer = NULL;
                CBM.fInClipboardChain = FALSE;
                TRC_NRM((TB,_T("CBM.fInClipboardChain=%d"),
                    CBM.fInClipboardChain ? 1 : 0 ));
            }

            if (CBM.fRegisteredForSessNotif) {
                WTSUnRegisterSessionNotification(hwnd);
                CBM.fRegisteredForSessNotif = FALSE;
            }
            
            /****************************************************************/
            /* and quit                                                     */
            /****************************************************************/
            PostQuitMessage(0);
        }
        break;

        case WM_CLOSE:
        {           
            /****************************************************************/
            /* We're closing down.  If this is not happening cleanly, then  */
            /* make sure we disconnect first                                */
            /****************************************************************/
            CBM_CHECK_STATE(CBM_EVENT_WM_CLOSE);
            TRC_NRM((TB, _T("WM_CLOSE")));
            if (CBM.state != CBM_STATE_INITIALIZED)
            {
                TRC_ALT((TB, _T("Close when not already back to state Init")));
                CBMDisconnect();
            }

            /****************************************************************/
            /* and having done that, its safe to finish.                    */
            /****************************************************************/
            DestroyWindow(CBM.viewerWindow);
        }
        break;

        case WM_CHANGECBCHAIN:
        {            
            /****************************************************************/
            /* The CB viewer chain is chainging - check the state           */
            /****************************************************************/
            CBM_CHECK_STATE(CBM_EVENT_WM_CHANGECBCHAIN);

            /****************************************************************/
            /* If the next window is closing, repair the chain.             */
            /****************************************************************/
            if ((HWND)wParam == CBM.nextViewer)
            {
                CBM.nextViewer = (HWND) lParam;
            }
            else if (CBM.nextViewer != NULL)
            {
                /************************************************************/
                /* pass the message to the next link.                       */
                /************************************************************/
                PostMessage(CBM.nextViewer, message, wParam, lParam);
            }

        }
        break;

        case WM_DRAWCLIPBOARD:
        {
            LPDATAOBJECT pIDataObject = NULL;
            HRESULT hr ;

            /****************************************************************/
            /* The local clipboard contents have been changed.  Check the   */
            /* state                                                        */
            /****************************************************************/
            if (CBMCheckState(CBM_EVENT_WM_DRAWCLIPBOARD) != CBM_TABLE_OK)
            {
                /************************************************************/
                /* We're not interested at the moment - pass the message to */
                /* the next link                                            */
                /************************************************************/
                if (CBM.nextViewer != NULL)
                {
                    TRC_NRM((TB, _T("Tell next viewer anyway")));
                    PostMessage(CBM.nextViewer, message, wParam, lParam);
                }
                break;
            }

            /****************************************************************/
            /* If it wasn't us that generated this change, then tell the    */
            /* client                                                       */
            /****************************************************************/
            drawRc = FALSE;
            
            CBM.pClipData->QueryInterface(IID_IDataObject, (PPVOID) &pIDataObject) ;
            hr = OleIsCurrentClipboard(pIDataObject) ;

            if ((S_FALSE == hr))
            {
                TRC_NRM((TB, _T("...and it wasn't us"))) ;
                drawRc = CBMDrawClipboard() ;
            }
            else
            {
                TRC_NRM((TB, _T("CB contents changed by us - ignoring")));
            }

            /****************************************************************/
            /* If the draw processing failed, or it was us that changed the */
            /* CB, pass the message to the next window in the chain (if     */
            /* any)                                                         */
            /****************************************************************/
            if (!drawRc)
            {               
                if (CBM.nextViewer != NULL)
                {
                    /********************************************************/
                    /* pass the message to the next link.                   */
                    /********************************************************/
                    TRC_NRM((TB, _T("Tell next viewer")));
                    PostMessage(CBM.nextViewer, message, wParam, lParam);
                }
            }
            
            if (pIDataObject)
            {
                pIDataObject->Release();
                pIDataObject = NULL;
            }
        }
        break;

        case WM_POWERBROADCAST:
            rc = TSSNDD_PowerMessage( wParam, lParam );
        break;

        case WM_ENDSESSION:
        {
            /****************************************************************/
            /* The session is ending.  Clean up here - we don't get a       */
            /* WM_QUIT, so we can't clean up in the normal place.  We must  */
            /* clean up however, otherwise we generate a                    */
            /* SESSION_HAS_VALID_PAGES fault.                               */
            /****************************************************************/
            /****************************************************************/
            /* Remove ourselves from the CB Chain                           */
            /****************************************************************/
            if (CBM.fInClipboardChain) {
                if (!ChangeClipboardChain(hwnd, CBM.nextViewer))
                {
                    TRC_SYSTEM_ERROR("ChangeClipboardChain");
                }
                CBM.nextViewer = NULL;
                CBM.fInClipboardChain = FALSE;
                TRC_NRM((TB,_T("CBM.fInClipboardChain=%d"),
                    CBM.fInClipboardChain ? 1 : 0 ));                
            }

            TRC_NRM((TB,_T("WM_ENDSESSION")));
                        
            CBMTerm();
            TSSNDD_Term();
        }
        break;

        case WM_WTSSESSION_CHANGE:
        {
            switch(wParam) {
                case WTS_REMOTE_CONNECT: //A session was connected to the remote session. 
                {
                    TRC_NRM((TB,_T("WM_WTSSESSION_CHANGE WTS_REMOTE_CONNECT")));

                    if (FALSE == CBM.fInClipboardChain) {

                        /****************************************************************/
                        /* Add the window to the clipboard viewer chain.                */
                        /****************************************************************/
                        TRC_NRM((TB, _T("SetClipboardViewer")));
                        
                        // Check to see that the first clipboard viewer in the chain is 
                        // not this process. This helps to partially address RAID 
                        // Bug #646295. A better fix would be to have a reliable means of
                        // removing ourselves from the clipboard viewer chain, but that
                        // does not currently exist with the current set of clipboard
                        // functions.
            
                        if (CBM.viewerWindow != GetClipboardViewer()) {
                            TRC_ERR((TB, _T("RDPClip already in clipboard chain.")));
                            CBM.nextViewer = SetClipboardViewer(hwnd);
                        }
                        
                        CBM.fInClipboardChain = TRUE;
                    }
                    TRC_NRM((TB,_T("CBM.fInClipboardChain=%d"),
                        CBM.fInClipboardChain ? 1 : 0 ));                            
                    TRC_NRM((TB, _T("Back from SetClipboardViewer")));
                    break;
                }               
                case WTS_REMOTE_DISCONNECT: //A session was disconnected from the remote session. 
                {
                    TRC_NRM((TB,_T("WM_WTSSESSION_CHANGE WTS_REMOTE_DISCONNECT")));

                    /****************************************************************/
                    /* Remove ourselves from the CB Chain                           */
                    /****************************************************************/
                    if (CBM.fInClipboardChain) {
                        if (!ChangeClipboardChain(hwnd, CBM.nextViewer))
                        {
                            TRC_SYSTEM_ERROR("ChangeClipboardChain");
                        }
                        CBM.nextViewer = NULL;
                        CBM.fInClipboardChain = FALSE;
                        TRC_NRM((TB,_T("CBM.fInClipboardChain=%d"),
                            CBM.fInClipboardChain ? 1 : 0 ));                
                    }
                    break;
                }
                    
                default:
                    TRC_NRM((TB,_T("WM_WTSSESSION_CHANGE wParam=0x%x"), wParam));
                    break;
            }
            break;
        }

        default:
        {
            /****************************************************************/
            /* Ignore all other messages.                                   */
            /****************************************************************/
            rc = DefWindowProc(hwnd, message, wParam, lParam);
        }
        break;
    }

DC_EXIT_POINT:
    DC_END_FN();

    return(rc);

} /* CBMWndProc */

/****************************************************************************/
/* CBMDrawClipboard - send the local formats to the remote                  */
/****************************************************************************/
DCBOOL DCINTERNAL CBMDrawClipboard(DCVOID)
{
    DCUINT          numFormats;
    DCUINT          formatCount;
    DCUINT          formatID;
    PTS_CLIP_FORMAT formatList;
    PTS_CLIP_PDU    pClipRsp = NULL;
    TS_CLIP_PDU     clipRsp;
    DCUINT          nameLen;
    DCUINT          pduLen;
    DCUINT32        dataLen = 0;
    DCINT           rc1;
    DCTCHAR         formatName[TS_FORMAT_NAME_LEN + 1] = { 0 };

    DCBOOL          rc = TRUE;
    DCBOOL          fHdrop = FALSE ;
    wchar_t         tempDirW[MAX_PATH] ;
    
    DC_BEGIN_FN("CBMDrawClipboard");

    CBM.dropEffect = FO_COPY ;
    CBM.fAlreadyCopied = FALSE ;

    CBM_CHECK_STATE(CBM_EVENT_WM_DRAWCLIPBOARD);

    /************************************************************************/
    /* @@@ what tidy up is needed here if state is unusual?                 */
    /************************************************************************/

    /************************************************************************/
    /* First we open the clipboard                                          */
    /************************************************************************/
    if (!CBM.open)
    {
        if (!OpenClipboard(CBM.viewerWindow))
        {
            TRC_SYSTEM_ERROR("OpenCB");
            rc = FALSE;
            DC_QUIT;
        }
    }

    /************************************************************************/
    /* It was/is open                                                       */
    /************************************************************************/
    TRC_NRM((TB, _T("CB opened")));
    CBM.open = TRUE;

    /************************************************************************/
    /* Count the formats available, checking we don't blow our limit        */
    /************************************************************************/
    numFormats = CountClipboardFormats();
    if (numFormats == 0)
    {
        /********************************************************************/
        /* clipboard has been emptied - send an empty list                  */
        /********************************************************************/
        pClipRsp = &clipRsp;
        pduLen = sizeof(clipRsp);
        dataLen = 0;
        TRC_NRM((TB, _T("CB emptied")));
    }
    else
    {
        /********************************************************************/
        /* build the format list                                            */
        /********************************************************************/
        if (numFormats > CB_MAX_FORMATS)
        {
            TRC_ALT((TB, _T("Num formats %d too large - limit to %d"),
                     numFormats, CB_MAX_FORMATS));
            numFormats = CB_MAX_FORMATS;
        }
        TRC_DBG((TB, _T("found %d formats"), numFormats));

        /********************************************************************/
        /* We need some memory for the format list - how much?              */
        /********************************************************************/
        dataLen = numFormats * sizeof(TS_CLIP_FORMAT);
        pduLen  = dataLen + sizeof(TS_CLIP_PDU);

        /********************************************************************/
        /* and make sure that's not too big!                                */
        /********************************************************************/
        if (pduLen > CHANNEL_CHUNK_LENGTH)
        {
            /****************************************************************/
            /* we'll have to limit the number of formats.  How many will    */
            /* fit in the max buffer size?                                  */
            /****************************************************************/
            pduLen     = CHANNEL_CHUNK_LENGTH;
            dataLen    = pduLen - sizeof(TS_CLIP_PDU);
            numFormats = dataLen / sizeof(TS_CLIP_FORMAT);

            /****************************************************************/
            /* no point in having empty space for the last fractional       */
            /* format!                                                      */
            /****************************************************************/
            dataLen = numFormats * sizeof(TS_CLIP_FORMAT);
            pduLen  = dataLen + sizeof(TS_CLIP_PDU);

            TRC_ALT((TB, _T("Too many formats!  Limited to %d"), numFormats));
        }

        /********************************************************************/
        /* now get the buffer                                               */
        /********************************************************************/
        pClipRsp = (PTS_CLIP_PDU)GlobalAlloc(GPTR, pduLen);
        if (pClipRsp == NULL)
        {
            /****************************************************************/
            /* If we supplied the last format list, we can no longer        */
            /* satisfy any requests, so empty the remote clipboard even     */
            /* though we can't send the new list                            */
            /****************************************************************/
            TRC_ERR((TB, _T("Failed to get format list mem - emptying remote")));
            pClipRsp = &clipRsp;
            pduLen = sizeof(clipRsp);
            dataLen = 0;
        }
        else
        {
            /****************************************************************/
            /* enumerate the formats                                        */
            /****************************************************************/
            TRC_NRM((TB, _T("Building list...")));
            formatList = (PTS_CLIP_FORMAT)pClipRsp->data;
            formatCount = 0;
            formatID = EnumClipboardFormats(0); /* 0 starts enumeration     */

            while ((formatID != 0) && (formatCount < numFormats))
            {
                if ((CF_HDROP == formatID) && (CBM.fFileCutCopyOn))
                {
                    fHdrop = TRUE ;
                }
            
                /************************************************************/
                /* look for formats we don't send                           */
                /************************************************************/
                if ((formatID == CF_BITMAP)         ||
                    (formatID == CF_DSPBITMAP)      ||
                    (formatID == CF_ENHMETAFILE)    ||
                    (formatID == CF_OWNERDISPLAY)   ||
                    ((formatID == CF_HDROP) && (!CBM.fFileCutCopyOn)))
                {
                    // We send DIB not bitmap to avoid potential palette 
                    // problems - this is a Windows recommendation.  The 
                    // remote Windows CB will provide the conversion to 
                    // CF_BITMAP 
                    // 
                    // Similarly we drop enhanced metafile formats, since 
                    // the local CB will provide conversion where supported 
                    // 
                    // Ownerdisplay just isn't going to work since the two 
                    // windows are on different machines!
                    //
                    // And if File Cut/Copy is off, we can't do HDROP
                    TRC_NRM((TB, _T("Dropping format ID %d"), formatID));
                    goto CONTINUE_FORMAT_ENUM;
                }

                /************************************************************/
                /* find the name for the format                             */
                /************************************************************/
                nameLen = GetClipboardFormatName(formatID,
                                                 formatName,
                                                 TS_FORMAT_NAME_LEN);

                if (nameLen == 0)
                {
                    /********************************************************/
                    /* predefined formats have no name                      */
                    /********************************************************/
                    TRC_NRM((TB, _T("predefined format %d - "), formatID));
                    formatList[formatCount].formatID = formatID;
                    *(formatList[formatCount].formatName) = '\0';
                }
                else if (CBMIsExcludedFormat(formatName))
                {
                    /********************************************************/
                    /* We drop the various DDE formats, again because they  */
                    /* just won't work where the apps are running on        */
                    /* different machines                                   */
                    /********************************************************/
                    TRC_NRM((TB, _T("Dropping format '%s'"), formatName));
                    goto CONTINUE_FORMAT_ENUM;
                }
                else
                {
                    /********************************************************/
                    /* its got a name and its not excluded!                 */
                    /********************************************************/
                    formatList[formatCount].formatID = formatID;

                    /********************************************************/
                    /* Convert the name to Ascii?                           */
                    /********************************************************/
                    if (CBM.fUseAsciiNames)
                    {
                        /****************************************************/
                        /* Convert over to the ANSI codepage.  Set no flags */
                        /* to maximise the speed of the conversion Set      */
                        /* length to -1 since null-terminated.  Set default */
                        /* chars to NULL to maximise speed.                 */
                        /****************************************************/
                        TRC_DBG((TB, _T("Converting to Ascii")));
                        rc1 = WideCharToMultiByte(
                                    CP_ACP,
                                    0,
                                    (LPCWSTR)formatName,
                                    -1,
                                    (LPSTR)formatList[formatCount].formatName,
                                    TS_FORMAT_NAME_LEN,
                                    NULL,
                                    NULL);
                        TRC_ASSERT((0 != rc1),
                                     (TB, _T("Wide char conversion failed")));

                        TRC_DATA_DBG("Ascii name",
                                     formatList[formatCount].formatName,
                                     TS_FORMAT_NAME_LEN);
                    }
                    /********************************************************/
                    /* just copy the name                                   */
                    /********************************************************/
                    else
                    {
                        //
                        // There is no explicit NULL termination at this 
                        // point if the format name is more than 32 bytes. 
                        // This will be rectified in Longhorn when we
                        // eliminate truncation of format names.
                        // 

                        TRC_DBG((TB, _T("copying Unicode name")));
                        DC_TSTRNCPY(
                               (PDCTCHAR)(formatList[formatCount].formatName),
                               formatName,
                               TS_FORMAT_NAME_LEN / sizeof(WCHAR));
                    }

                }

                TRC_DBG((TB, _T("found format id %d, name '%s'"),
                                formatList[formatCount].formatID,
                                formatList[formatCount].formatName));

                /************************************************************/
                /* update the count and move on                             */
                /************************************************************/
                formatCount++;

CONTINUE_FORMAT_ENUM:
                /************************************************************/
                /* get the next format                                      */
                /************************************************************/
                formatID = EnumClipboardFormats(formatID);
            }

            /****************************************************************/
            /* Update the PDU len - we may have dropped some formats along  */
            /* the way                                                      */
            /****************************************************************/
            dataLen = formatCount * sizeof(TS_CLIP_FORMAT);
            pduLen  = dataLen + sizeof(TS_CLIP_PDU);
            TRC_NRM((TB, _T("Final count: %d formats in data len %d"),
                                                       formatCount, dataLen));

        }
    }

    /************************************************************************/
    /* Close the Clipboard now                                              */
    /************************************************************************/
    if (CBM.open)
    {
        TRC_NRM((TB, _T("Close clipboard")));
        if (!CloseClipboard())
        {
            TRC_SYSTEM_ERROR("CloseClipboard");
        }
        CBM.open = FALSE;
    }
    // Only if we got an HDROP should we make a new temp directory
    if (fHdrop)
    {
        if (GetTempFileNameW(CBM.baseTempDirW, L"_TS", 0, CBM.tempDirW)) {
            DeleteFile(CBM.tempDirW) ;
            CreateDirectoryW(CBM.tempDirW, NULL) ;
            if (CBMConvertToClientPathW(CBM.tempDirW, tempDirW, 
                sizeof(tempDirW)) == S_OK) {
                wcscpy(CBM.tempDirW, tempDirW) ;
                WideCharToMultiByte(CP_ACP, NULL, CBM.tempDirW, -1, 
                              CBM.tempDirA, wcslen(CBM.tempDirW), NULL, NULL) ;
            }
            else {
                CBM.tempDirW[0] = L'\0';
                CBM.tempDirA[0] = '\0';
            }
            
        }
        else {
            CBM.tempDirW[0] = L'\0';
            CBM.tempDirA[0] = '\0';
        }
    }
    
    /************************************************************************/
    /* Update the state                                                     */
    /************************************************************************/
    CBM_SET_STATE(CBM_STATE_PENDING_FORMAT_LIST_RSP, CBM_EVENT_WM_DRAWCLIPBOARD);

    /************************************************************************/
    /* Complete the PDU                                                     */
    /************************************************************************/
    pClipRsp->msgType = TS_CB_FORMAT_LIST;
    pClipRsp->msgFlags = 0;
    pClipRsp->dataLen = dataLen;

    /************************************************************************/
    /* and send it to the Client                                            */
    /************************************************************************/
    CBM.formatResponseCount++;
    TRC_NRM((TB, _T("Pass format data to Client - %d response(s) pending"),
            CBM.formatResponseCount));
    CBMSendToClient(pClipRsp, pduLen);

DC_EXIT_POINT:
    /************************************************************************/
    /* free any memory we got                                               */
    /************************************************************************/
    if ((pClipRsp != NULL) && (pClipRsp != &clipRsp))
    {
        GlobalFree(pClipRsp);
    }

    DC_END_FN();
    return(rc);
} /* CBMDrawClipboard */

/****************************************************************************/
/* CBMOnFormatList                                                          */
/*  Caller must have validated that the PDU contained enough data for the   */
/*  length specified in pClipPDU->dataLen                                   */
/****************************************************************************/
DCVOID DCINTERNAL CBMOnFormatList(PTS_CLIP_PDU pClipPDU)
{
    DCUINT16        response = TS_CB_RESPONSE_OK;
    DCUINT          numFormats;
    PTS_CLIP_FORMAT fmtList;
    DCUINT          i;
    DCTCHAR         formatName[TS_FORMAT_NAME_LEN + 1] = { 0 };
    TS_CLIP_PDU     clipRsp;
    DCBOOL          fSuccess;
    LPDATAOBJECT    pIDataObject = NULL;
    LPFORMATETC     pFormatEtc = NULL;
    HRESULT         hr ;    
    
    DC_BEGIN_FN("CBMOnFormatList");

    /************************************************************************/
    /* The client has sent us some new formats                              */
    /************************************************************************/
    TRC_NRM((TB, _T("Received FORMAT_LIST")));
    CBM_CHECK_STATE(CBM_EVENT_FORMAT_LIST);

    /************************************************************************/
    /* This may arrive just after we've sent the client a format list -     */
    /* since the client always wins, we must accept the list                */
    /************************************************************************/
    if (CBM.state == CBM_STATE_PENDING_FORMAT_LIST_RSP)
    {
        TRC_ALT((TB, _T("Got list while pending list response")));

        /********************************************************************/
        /* close the local CB - if it's open - and tell the next viewer     */
        /* about the updated list                                           */
        /********************************************************************/
        if (CBM.open)
        {
            TRC_NRM((TB, _T("Close clipboard")));
            if (!CloseClipboard())
            {
                TRC_SYSTEM_ERROR("CloseClipboard");
            }
            CBM.open = FALSE;
        }

        if (CBM.nextViewer != NULL)
        {
            PostMessage(CBM.nextViewer, WM_DRAWCLIPBOARD,0,0);
        }
    }

    CBM.formatResponseCount = 0;

    /********************************************************************/
    /* empty the CB and the client/server mapping table                 */
    /********************************************************************/
    //OleSetClipboard(NULL) ;
    
    DC_MEMSET(CBM.idMap, 0, sizeof(CBM.idMap));

    /********************************************************************/
    /* See if we must use ASCII format names                            */
    /********************************************************************/
    CBM.fUseAsciiNames = (pClipPDU->msgFlags & TS_CB_ASCII_NAMES) ?
                                                             TRUE : FALSE;

    /********************************************************************/
    /* work out how many formats we got                                 */
    /********************************************************************/
    numFormats = (pClipPDU->dataLen) / sizeof(TS_CLIP_FORMAT);
    TRC_ASSERT(numFormats < CB_MAX_FORMATS,
               (TB,_T("Too many formats recevied %d"),
                numFormats));
    TRC_NRM((TB, _T("PDU contains %d formats"), numFormats));
    hr = CBM.pClipData->SetNumFormats(numFormats + 5) ; // Add 5 extra format slots
    
    if (SUCCEEDED(hr)) {
        hr = CBM.pClipData->QueryInterface(IID_IDataObject, (PPVOID) &pIDataObject);
        if (FAILED(hr)) {           
            TRC_ERR((TB,_T("Error getting pointer to an IDataObject"))) ;
            pIDataObject = NULL;
        }
    }
    
    if (SUCCEEDED(hr)) {    
        /********************************************************************/
        /* and add them to the clipboard                                    */
        /********************************************************************/
        fmtList = (PTS_CLIP_FORMAT)pClipPDU->data;
        for (i = 0; i < numFormats; i++)
        {
            TRC_DBG((TB, _T("format number %d, client id %d"),
                                  i, fmtList[i].formatID));
            /****************************************************************/
            /* If we got a name...                                          */
            /****************************************************************/
            if (fmtList[i].formatName[0] != 0)
            {
                /************************************************************/
                /* clear out any garbage                                    */
                /************************************************************/
                DC_MEMSET(formatName, 0, TS_FORMAT_NAME_LEN + 1);
    
                /************************************************************/
                /* Convert from Ascii?                                      */
                /************************************************************/
                if (CBM.fUseAsciiNames)
                {
                    TRC_NRM((TB, _T("Converting to Unicode")));
                    MultiByteToWideChar(
                                CP_ACP,
                                MB_ERR_INVALID_CHARS,
                                (LPCSTR)fmtList[i].formatName,
                                -1,
                                (LPWSTR)formatName,
                                TS_FORMAT_NAME_LEN);
                }
                else
                {
                    /********************************************************/
                    /* just copy it                                         */
                    /********************************************************/
                    //
                    // fmtList[i].formatName is not NULL terminated so 
                    // explicity do a byte count copy
                    //
                    StringCbCopy(formatName, TS_FORMAT_NAME_LEN + sizeof(TCHAR),
                                  (PDCTCHAR)(fmtList[i].formatName));
                }
    
                /************************************************************/
                /* Check for excluded formats                               */
                /************************************************************/
                if (CBMIsExcludedFormat(formatName))
                {
                    TRC_NRM((TB, _T("Dropped format '%s'"), formatName));
                    continue;
                }
    
                /************************************************************/
                /* name is sorted                                           */
                /************************************************************/
                TRC_NRM((TB, _T("Got name '%s'"), formatName));
            }
            else
            {
                DC_MEMSET(formatName, 0, TS_FORMAT_NAME_LEN);
            }
    
            /****************************************************************/
            /* store the client id                                          */
            /****************************************************************/
            CBM.idMap[i].clientID = fmtList[i].formatID;
            TRC_NRM((TB, _T("client id %d"), CBM.idMap[i].clientID));
    
            /****************************************************************/
            /* get local name (if needed)                                   */
            /****************************************************************/
            if (formatName[0] != 0)
            {
                CBM.idMap[i].serverID = RegisterClipboardFormat(formatName);
            }
            else
            {
                /************************************************************/
                /* it's a predefined format so we can just use the ID       */
                /************************************************************/
                CBM.idMap[i].serverID = CBM.idMap[i].clientID;
            }
    
            /****************************************************************/
            /* and add the format to the local CB                           */
            /****************************************************************/
            TRC_DBG((TB, _T("Adding format '%s', client ID %d, server ID %d"),
                         formatName,
                         CBM.idMap[i].clientID,
                         CBM.idMap[i].serverID));

            if (CBM.idMap[i].serverID != 0) {
                pFormatEtc = new FORMATETC ;
                if (pFormatEtc) {
                    pFormatEtc->cfFormat = (CLIPFORMAT) CBM.idMap[i].serverID ;
                    pFormatEtc->dwAspect = DVASPECT_CONTENT ;
                    pFormatEtc->ptd = NULL ;
                    pFormatEtc->lindex = -1 ;
                    pFormatEtc->tymed = TYMED_HGLOBAL ;
                
                    pIDataObject->SetData(pFormatEtc, NULL, TRUE) ;
                    delete pFormatEtc;
                }
            }
            else {
                TRC_NRM((TB,_T("Invalid format dropped"))) ;
            }
        }    
    }

    hr =  OleSetClipboard(pIDataObject) ;
    if (pIDataObject)
    {
        pIDataObject->Release();
        pIDataObject = NULL ;
    }        

    if (FAILED(hr)) {
        response = TS_CB_RESPONSE_FAIL;
    }
    CBM.open = FALSE ;

    /************************************************************************/
    // Now we can pass the response to the client
    /************************************************************************/
    clipRsp.msgType  = TS_CB_FORMAT_LIST_RESPONSE;
    clipRsp.msgFlags = response;
    clipRsp.dataLen  = 0;
    fSuccess = CBMSendToClient(&clipRsp, sizeof(clipRsp));
    TRC_NRM((TB, _T("Write to Client %s"), fSuccess ? _T("OK") : _T("failed")));

    /************************************************************************/
    /* Update the state according to how we got on                          */
    /************************************************************************/
    if (response == TS_CB_RESPONSE_OK)
    {
        CBM_SET_STATE(CBM_STATE_LOCAL_CB_OWNER, CBM_EVENT_FORMAT_LIST);
    }
    else
    {
        CBM_SET_STATE(CBM_STATE_CONNECTED, CBM_EVENT_FORMAT_LIST);
    }

DC_EXIT_POINT:
    DC_END_FN();
    return;
} /* CBMOnFormatList */


/****************************************************************************/
/* CBMDisconnect - either the client has disconnected, or we have been      */
/* closed                                                                   */
/****************************************************************************/
DCVOID DCINTERNAL CBMDisconnect(DCVOID)
{
    DC_BEGIN_FN("CBMDisconnect");

    /************************************************************************/
    /* If we are the local clipboard owner, then we must empty it - once    */
    /* disconnected, we won't be able to satisfy any further format         */
    /* requests.  Note that we are still the local CB owner even if we are  */
    /* waiting on some data from the client                                 */
    /************************************************************************/
    if ((CBM.state == CBM_STATE_LOCAL_CB_OWNER) ||
        (CBM.state == CBM_STATE_PENDING_FORMAT_DATA_RSP))
    {
        TRC_NRM((TB, _T("Disable received while local CB owner")));

        /********************************************************************/
        /* Open the clipboard if needed                                     */
        /********************************************************************/
        if (!CBM.open)
        {
            if (!OpenClipboard(CBM.viewerWindow))
            {
                TRC_SYSTEM_ERROR("OpenCB");
                DC_QUIT;
            }
            CBM.open = TRUE;
        }

        /****************************************************************/
        /* It was/is open                                               */
        /****************************************************************/
        TRC_NRM((TB, _T("CB opened")));
        CBM.open = TRUE;

        /****************************************************************/
        /* Empty it                                                     */
        /****************************************************************/
        if (!EmptyClipboard())
        {
            TRC_SYSTEM_ERROR("EmptyClipboard");
        }
        else
        {
            TRC_NRM((TB, _T("Clipboard emptied")));
        }
    }

    /************************************************************************/
    /* Ensure that we close the local CB                                    */
    /************************************************************************/
    if (CBM.open)
    {
        if (!CloseClipboard())
        {
            TRC_SYSTEM_ERROR("CloseClipboard");
        }
        CBM.open = FALSE;
        TRC_NRM((TB, _T("CB closed")));
    }

    /************************************************************************/
    /* Virtual channel has been closed                                      */
    /************************************************************************/
    CloseHandle(CBM.vcHandle);
    CBM.vcHandle = NULL;

    //
    // Switch off the file clipboard redirection flag, otherwise if a client
    // with drive redirection disabled connects, we will still attempt to 
    // send file copy formats.
    //

    CBM.fFileCutCopyOn = FALSE;

DC_EXIT_POINT:
    /************************************************************************/
    /* Update our state                                                     */
    /************************************************************************/
    CBM_SET_STATE(CBM_STATE_INITIALIZED, CBM_EVENT_DISCONNECT);

    DC_END_FN();
    return;
} /* CBMDisconnect */


/****************************************************************************/
/* CBMReconnect                                                             */
/****************************************************************************/
DCVOID DCINTERNAL CBMReconnect(DCVOID)
{
    TS_CLIP_PDU clipRsp;

    DC_BEGIN_FN("CBMReconnect");

    SetEvent(CBM.GetDataSync[TS_RESET_EVENT]) ;
    CBM_CHECK_STATE(CBM_EVENT_CONNECT);

    CBM.vcHandle = NULL;

    /************************************************************************/
    /* Open our virtual channel                                             */
    /************************************************************************/
    CBM.vcHandle = WinStationVirtualOpen(NULL, LOGONID_CURRENT, CLIP_CHANNEL);
    if (CBM.vcHandle == NULL)
    {
        TRC_ERR((TB, _T("Failed to open virtual channel %S"), CLIP_CHANNEL));
        DC_QUIT;
    }

    /************************************************************************/
    /* Send the Monitor Ready message to the Client                         */
    /************************************************************************/
    clipRsp.msgType = TS_CB_MONITOR_READY;
    clipRsp.msgFlags = 0;
    clipRsp.dataLen = 0;
    if (!CBMSendToClient(&clipRsp, sizeof(clipRsp)))
    {
        /********************************************************************/
        /* Failed to send the Monitor Ready message.  Clip redirection is   */
        /* not available.                                                   */
        /********************************************************************/
        TRC_ERR((TB, _T("Failed to send MONITOR_READY to Client - Exit")));
        CloseHandle(CBM.vcHandle);
        CBM.vcHandle = NULL;
        DC_QUIT;
    }
    TRC_NRM((TB, _T("Sent MONITOR_READY to Client")));

    /************************************************************************/
    /* Client support is enabled - we're all set                            */
    /************************************************************************/
    CBM_SET_STATE(CBM_STATE_CONNECTED, CBM_EVENT_CONNECT);

DC_EXIT_POINT:
    DC_END_FN();
    return;
} /* CBMReconnect */


/****************************************************************************/
/* CBMTerm - terminate the Clipboard Monitor                                */
/**PROC-*********************************************************************/
DCVOID DCINTERNAL CBMTerm(DCVOID)
{
    HRESULT hr ;
    DC_BEGIN_FN("CBMTerm");

    /************************************************************************/
    /* Tell the second thread to end                                        */
    /************************************************************************/
    if (CBM.readOL.hEvent)
    {
        TRC_NRM((TB, _T("Signalling thread to stop")));
        CBM.runThread = FALSE;
        SetEvent(CBM.readOL.hEvent);

        /********************************************************************/
        /* Give the second thread a chance to finish                        */
        /********************************************************************/
        TRC_NRM((TB, _T("Wait a sec ...")));
        if ( NULL != CBM.hDataThread )
        {
            WaitForSingleObject( CBM.hDataThread, INFINITE );
            CloseHandle( CBM.hDataThread );
            CBM.hDataThread = NULL;
        }

    }

    /************************************************************************/
    /* Destroy the events                                                   */
    /************************************************************************/
    if (CBM.readOL.hEvent)
    {
        TRC_NRM((TB, _T("destroying read event %p"), CBM.readOL.hEvent));
        if (!CloseHandle(CBM.readOL.hEvent))
        {
            TRC_SYSTEM_ERROR("CloseHandle");
        }
        CBM.readOL.hEvent = NULL;
    }
    if (CBM.writeOL.hEvent)
    {
        TRC_NRM((TB, _T("destroying write event %p"), CBM.writeOL.hEvent));
        if (!CloseHandle(CBM.writeOL.hEvent))
        {
            TRC_SYSTEM_ERROR("CloseHandle");
        }
        CBM.writeOL.hEvent = NULL;
    }

    /************************************************************************/
    /* Empty the clipboard if we own its contents                           */
    /************************************************************************/
    if (CBM.viewerWindow && (GetClipboardOwner() == CBM.viewerWindow))
    {
        TRC_NRM((TB, _T("We own the clipboard - empty it")));
        
        hr = OleSetClipboard(NULL) ;
        
        if (FAILED(hr)) {
            TRC_SYSTEM_ERROR("Unable to clear clipboard") ;
        }
    }
    if (CBM.pClipData)
    {
        CBM.pClipData->Release() ;
        CBM.pClipData = NULL;
    }

    /************************************************************************/
    /* Close thc clipboard if we have it open                               */
    /************************************************************************/
    if (CBM.open)
    {
        TRC_NRM((TB, _T("Close clipboard")));
        if (!CloseClipboard())
        {
            TRC_SYSTEM_ERROR("CloseClipboard");
        }
        CBM.open = FALSE;
    }
DC_EXIT_POINT:
    DC_END_FN();
    return;
} /* CBMTerm */

/****************************************************************************/
// CBMIsExcludedFormat - test to see if the suplied format is on our
// "banned list"
/****************************************************************************/
DCBOOL DCINTERNAL CBMIsExcludedFormat(PDCTCHAR formatName)
{
    DCBOOL  rc = FALSE;
    DCINT   i;

    DC_BEGIN_FN("CBMIsExcludedFormat");

    /************************************************************************/
    /* check there is a format name - all banned formats have one!          */
    /************************************************************************/
    if (*formatName == _T('\0'))
    {
        TRC_ALT((TB, _T("No format name supplied!")));
        DC_QUIT;
    }

    /************************************************************************/
    /* search the banned format list for the supplied format name           */
    /************************************************************************/
    TRC_DBG((TB, _T("Looking at format '%s'"), formatName));
    TRC_DATA_DBG("Format name data", formatName, TS_FORMAT_NAME_LEN);
    if (CBM.fFileCutCopyOn)
    {
        for (i = 0; i < CBM_EXCLUDED_FORMAT_COUNT; i++)
        {
            TRC_DBG((TB, _T("comparing with '%s'"), cbmExcludedFormatList[i]));
            if (DC_WSTRCMP((PDCWCHAR)formatName,
                                         (PDCWCHAR)cbmExcludedFormatList[i]) == 0)
            {
                TRC_NRM((TB, _T("Found excluded format '%s'"), formatName));
                rc = TRUE;
                break;
            }
        }
    }
    else
    {
        for (i = 0; i < CBM_EXCLUDED_FORMAT_COUNT_NO_RD; i++)
        {
            TRC_DBG((TB, _T("comparing with '%s'"), cbmExcludedFormatList_NO_RD[i]));
            if (DC_WSTRCMP((PDCWCHAR)formatName,
                                         (PDCWCHAR)cbmExcludedFormatList[i]) == 0)
            {
                TRC_NRM((TB, _T("Found excluded format '%s'"), formatName));
                rc = TRUE;
                break;
            }
        }
    }


DC_EXIT_POINT:
    DC_END_FN();

    return(rc);
} /* CBMIsExcludedFormat */

//
// CBMConvertToServerPath, CBMConvertToServerPathA, CBMConvertToServerPathW
// - Arguments:
//       pOldData = Buffer containing the original file path
//       pData    = Buffer receiving the new file path
// - Returns S_OK if pOldData was a drive path
//           E_FAIL if it failed
// - Given a file path with a colon, this function will strip out the old path,
//   and prepend it with TS_PREPEND_STRING; otherwise, we just copy it over
//   because we can already understand it
HRESULT CBMConvertToServerPath(PVOID pOldData, PVOID pData, size_t cbDest, BOOL wide)
{
    HRESULT result ;
    
    DC_BEGIN_FN("CBMConvertToServerPath") ;
    if (!pOldData)
    {
        TRC_ERR((TB, _T("Original string pointer is NULL"))) ;
        result = E_FAIL ;
        DC_QUIT ;
    }
    if (!pData)
    {
        TRC_ERR((TB, _T("Destination string pointer is NULL"))) ;
        result = E_FAIL ;
        DC_QUIT ;
    }
    if (wide)
        result = CBMConvertToServerPathW(pOldData, pData, cbDest) ;
    else
        result = CBMConvertToServerPathA(pOldData, pData, cbDest) ;
        
DC_EXIT_POINT:
    DC_END_FN() ;    
    return result ;

}

HRESULT CBMConvertToServerPathW(PVOID pOldData, PVOID pData, size_t cbDest)
{
    wchar_t*         filePath ;
    wchar_t*         driveLetter ;
    size_t             driveLetterLength ;
    HRESULT          result = E_FAIL ;

    DC_BEGIN_FN("CBMConvertToServerPathW") ;

    // if this is a filepath with a drive letter
    filePath = wcschr((wchar_t*)pOldData, L':') ;
    if (filePath)
    {
        driveLetter = (wchar_t*)pOldData ;
        result = StringCbCopyW( (wchar_t*)pData, cbDest, LTS_PREPEND_STRING) ;
        DC_QUIT_ON_FAIL(result);
        // Since there is actually a constant for the max
        // drive letter length, we can't assume it will
        // always be 1 character
        driveLetterLength = (BYTE*)filePath - (BYTE*)driveLetter;
        result = StringCbCatNW( (wchar_t*)pData, cbDest, driveLetter, 
            driveLetterLength);
        DC_QUIT_ON_FAIL(result);
        filePath = (wchar_t*) filePath + 1 ; // character after the ':'
        result = StringCbCatW( (wchar_t*)pData, cbDest, filePath);
        DC_QUIT_ON_FAIL(result);
        TRC_NRM((TB,_T("New filename = %ls"), (wchar_t*)pData)) ;
        result = S_OK ;
    }
    else
    {
        TRC_ERR((TB, _T("Not a filepath with drive letter.  Nothing converted"))) ;
        result = StringCbCopyW((wchar_t*)pData, cbDest, (wchar_t*)pOldData);
        DC_QUIT_ON_FAIL(result);
        result = E_FAIL ;
        DC_QUIT ;
    }
    
DC_EXIT_POINT:

    if (FAILED(result)) {
        TRC_ERR((TB,_T("Returning failure; hr=0x%x"), result));
    }
    
    DC_END_FN() ;
    return result  ;
}

HRESULT CBMConvertToServerPathA(PVOID pOldData, PVOID pData, size_t cbDest)
{
    char*         filePath ;
    char*         driveLetter ;
    size_t             driveLetterLength ;
    HRESULT       result = E_FAIL ;

    DC_BEGIN_FN("CBMConvertToServerPathW") ;

    // if this is a filepath with a drive letter
    filePath = strchr((char*)pOldData, ':') ;
    if (filePath)
    {
        driveLetter = (char*)pOldData ;
        result = StringCbCopyA( (char*)pData, cbDest, TS_PREPEND_STRING) ;
        DC_QUIT_ON_FAIL(result);
        // Since there is actually a constant for the max
        // drive letter length, we can't assume it will
        // always be 1 character
        driveLetterLength = (BYTE*)filePath - (BYTE*)driveLetter;
        result = StringCbCatNA( (char*)pData, cbDest, driveLetter, 
            driveLetterLength);
        DC_QUIT_ON_FAIL(result);
        filePath = (char*) filePath + 1 ; // character after the ':'
        result = StringCbCatA( (char*)pData, cbDest, filePath);
        DC_QUIT_ON_FAIL(result);
        result = S_OK ;
    }
    else
    {
        TRC_ERR((TB, _T("Not a filepath with drive letter.  Nothing converted"))) ;
        result = StringCbCopyA((char*)pData, cbDest, (char*)pOldData);
        DC_QUIT_ON_FAIL(result);
        result = E_FAIL ;
    }

DC_EXIT_POINT:

    if (FAILED(result)) {
        TRC_ERR((TB,_T("Returning failure; 0x%x"), result));
    }
    
    DC_END_FN() ;
    return result ;
}

//
// CBMGetNewDropfilesSizeForServer, 
// CBMGetNewDropfilesSizeForServerW, 
// CBMGetNewDropfilesSizeForServerA
// - Arguments:
//       pData    = Buffer containing a DROPFILES struct 
//       oldSize   = The size of the DROPFILES struct
//       wide     = Wide or Ansi (TRUE if wide, FALSE if ansi)
// - Returns new size of the drop file
//           0 if it fails
// - Given a file path with drive letter, this function will calculate
//   the needed space for the new string, when changed to \\tsclient
//   format
//
//
//   ***** NOTE *****
// - Currently, if the path is a network path, and not a drive path (C:\path)
//   it simply fails
//

ULONG CBMGetNewDropfilesSizeForServer(PVOID pData, ULONG oldSize, BOOL wide)
{
    DC_BEGIN_FN("CBMGetNewDropfilesSizeForServer") ;
    if (wide)
        return CBMGetNewDropfilesSizeForServerW(pData, oldSize) ;
    else
        return CBMGetNewDropfilesSizeForServerA(pData, oldSize) ;
    DC_END_FN() ;
}

ULONG CBMGetNewDropfilesSizeForServerW(PVOID pData, ULONG oldSize)
{
    ULONG            newSize = oldSize ;
    wchar_t*         filenameW ;
    wchar_t*         filePathW ;
    byte             charSize ;

    DC_BEGIN_FN("CBMGetNewDropfilesSizeForServerW") ;
    charSize = sizeof(wchar_t) ;
    if (!pData)
    {
        TRC_ERR((TB,_T("Pointer to dropfile is NULL"))) ;
        return 0 ;
    }

    // The start of the first filename
    filenameW = (wchar_t*) ((byte*) pData + ((DROPFILES*) pData)->pFiles) ;
    
    while (L'\0' != filenameW[0])
    {
        TRC_NRM((TB,_T("First filename = %ls"), filenameW)) ;
        filePathW = wcschr(filenameW, L':') ;
        // If the file path has a colon in it, then it's a drive path
        if (filePathW)
        {
            // we add space for (TS_PREPEND_LENGTH - 1) characters because
            // although we are adding TS_PREPEND_LENGTH characters, we are
            // stripping out the colon from the filepath
            newSize = newSize + (TS_PREPEND_LENGTH - 1) * charSize ;
            // going from c:\foo.txt -> \\tsclient\c\foo.txt adds
            // \\tsclient\ and subtracts :
        }
        else
        {
            TRC_ERR((TB,_T("Bad path"))) ;
            return 0 ;
        }
        filenameW = filenameW + (wcslen((wchar_t*)filenameW) + 1) ;
    }
    
    DC_END_FN() ;
    return newSize ;
}

ULONG CBMGetNewDropfilesSizeForServerA(PVOID pData, ULONG oldSize)
{
    ULONG            newSize = oldSize ;
    char*            filename ;
    char*            filePath ;
    byte             charSize ;

    DC_BEGIN_FN("CBMGetNewDropfilesSizeForServerW") ;

    charSize = sizeof(wchar_t) ;
    if (!pData)
    {
        TRC_ERR((TB,_T("Pointer to dropfile is NULL"))) ;
        return 0 ;
    }

    // The start of the first filename
    filename = (char*) ((byte*) pData + ((DROPFILES*) pData)->pFiles) ;

    while ('\0' != filename[0])
    {
        filePath = strchr(filename, ':') ;
        // If the file path has a colon in it, then its a drive path
        if (filePath)
        {
            // we add space for (TS_PREPEND_LENGTH - 1) characters because
            // although we are adding TS_PREPEND_LENGTH characters, we are
            // stripping out the colon from the filepath
            newSize = newSize + (TS_PREPEND_LENGTH - 1) * charSize ;
            // going from c:\foo.txt -> \\tsclient\c\foo.txt adds
            // \\tsclient\ and subtracts :
        }
        else
        {
            TRC_ERR((TB,_T("Bad path"))) ;
            return 0 ;
        }
        filename = filename + (strlen(filename) + 1) ;
    }
    
    DC_END_FN() ;
    return newSize ;
}

DCINT DCAPI CBMGetData (DCUINT cfFormat)
{
    PTS_CLIP_PDU    pClipPDU = NULL;
    DCUINT32        pduLen;
    DCUINT32        dataLen;
    PDCUINT32       pFormatID;    
    DCUINT8         clipRsp[sizeof(TS_CLIP_PDU) + sizeof(DCUINT32)];
    BOOL            success = 0 ;
    
    DC_BEGIN_FN("ClipGetData");
    
    CBM_CHECK_STATE(CBM_EVENT_WM_RENDERFORMAT);
       
    // Record the requested format
    CBM.pendingServerID = cfFormat ;
    CBM.pendingClientID = CBMRemoteFormatFromLocalID(CBM.pendingServerID);

    // if we don't get a valid client ID, then fail
    if (!CBM.pendingClientID)
    {
        TRC_NRM((TB, _T("Server format %d not supported/found.  Failing"), CBM.pendingServerID)) ;
        DC_QUIT ;
    }    

    TRC_NRM((TB, _T("Render format received for %d (client ID %d)"),
                             CBM.pendingServerID, CBM.pendingClientID));
    
    dataLen = sizeof(DCUINT32);
    pduLen  = sizeof(TS_CLIP_PDU) + dataLen;
    
    // We can use the permanent send buffer for this
    TRC_NRM((TB, _T("Get perm TX buffer"))) ;
    
    pClipPDU = (PTS_CLIP_PDU)(&clipRsp) ;
    
    DC_MEMSET(pClipPDU, 0, sizeof(*pClipPDU)) ;
    pClipPDU->msgType  = TS_CB_FORMAT_DATA_REQUEST ;
    pClipPDU->dataLen  = dataLen ;
    pFormatID = (PDCUINT32)(pClipPDU->data) ;
    *pFormatID = (DCUINT32)CBM.pendingClientID ;
    
    // Reset the TS_RECEIVE_COMPLETED event since we expect it to be signaled
    // if any data is received from the client.
    
    ResetEvent(CBM.GetDataSync[TS_RECEIVE_COMPLETED]);

    // Send the PDU
    TRC_NRM((TB, _T("Sending format data request"))) ;
    success = CBMSendToClient(pClipPDU, sizeof(TS_CLIP_PDU) + sizeof(DCUINT32)) ;    
    
DC_EXIT_POINT:
    // Update the state if successful
    if (success)
       CBM_SET_STATE(CBM_STATE_PENDING_FORMAT_DATA_RSP, CBM_EVENT_WM_RENDERFORMAT) ;

    DC_END_FN() ;
    return success ;    
}

CClipData::CClipData()
{
    DC_BEGIN_FN("CClipData") ;
    _cRef = 0 ;
    _pImpIDataObject = NULL ;
    DC_END_FN();
}

CClipData::~CClipData(void)
{
    DC_BEGIN_FN("~CClipData");

    if (_pImpIDataObject != NULL)
    {
        _pImpIDataObject->Release();
        _pImpIDataObject = NULL;
    }

    DC_END_FN();
}

HRESULT DCINTERNAL CClipData::SetNumFormats(ULONG numFormats)
{
    DC_BEGIN_FN("SetNumFormats");
    HRESULT hr = S_OK;
    
    if (_pImpIDataObject)
    {
        _pImpIDataObject->Release();
        _pImpIDataObject = NULL;
    }
    _pImpIDataObject = new CImpIDataObject(this) ;
    if (_pImpIDataObject != NULL) {
        _pImpIDataObject->AddRef() ;    

        hr = _pImpIDataObject->Init(numFormats) ;
        DC_QUIT_ON_FAIL(hr);
    }
    else {
        TRC_ERR((TB,_T("Unable to create IDataObject")));
        hr = E_OUTOFMEMORY;
        DC_QUIT;
    }

DC_EXIT_POINT:    
    DC_END_FN();
    return hr;
}

DCVOID CClipData::SetClipData(HGLOBAL hGlobal, DCUINT clipType)
{
    DC_BEGIN_FN("SetClipData");

    if (_pImpIDataObject != NULL) {
        _pImpIDataObject->SetClipData(hGlobal, clipType) ;
    }
    DC_END_FN();
}

STDMETHODIMP CClipData::QueryInterface(REFIID riid, PPVOID ppv)
{
    DC_BEGIN_FN("QueryInterface");

    //set ppv to NULL just in case the interface isn't found
    *ppv=NULL;

    if (IID_IUnknown==riid)
        *ppv=this;

    if (IID_IDataObject==riid)
        *ppv=_pImpIDataObject ;
    
    if (NULL==*ppv)
        return ResultFromScode(E_NOINTERFACE);

    //AddRef any interface we'll return.
    ((LPUNKNOWN)*ppv)->AddRef();
    DC_END_FN();
    return NOERROR;
}

STDMETHODIMP_(ULONG) CClipData::AddRef(void)
{
    LONG cRef;
    DC_BEGIN_FN("AddRef");

    cRef = InterlockedIncrement(&_cRef) ;

    DC_END_FN();
    return cRef ;
}

STDMETHODIMP_(ULONG) CClipData::Release(void)
{
    LONG cRef;

    DC_BEGIN_FN("CClipData::Release");

    cRef = InterlockedDecrement(&_cRef);
    if (cRef == 0)
    {   
        delete this;
    }
    
    DC_END_FN();    
    return cRef;
}

CImpIDataObject::CImpIDataObject(LPUNKNOWN lpUnk)
{
    DC_BEGIN_FN("CImplDataObject") ;
    _numFormats = 0 ;
    _maxNumFormats = 0 ;
    _cRef = 0 ;
    _pUnkOuter = lpUnk ;
    if (_pUnkOuter)
    {
        _pUnkOuter->AddRef();
    }
    _pFormats = NULL ;
    _pSTGMEDIUM = NULL ;
    _lastFormatRequested = 0 ;
    _dropEffect = FO_COPY ;
    _cfDropEffect = (CLIPFORMAT) RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT) ;
    _fAlreadyCopied = FALSE ;
    DC_END_FN();
}

HRESULT CImpIDataObject::Init(ULONG numFormats)
{
    DC_BEGIN_FN("Init");

    HRESULT hr = S_OK;

    _maxNumFormats = numFormats ;
    
    // Allocate space for the formats only
    if (_pFormats) {
        LocalFree(_pFormats);
    }
    _pFormats = (LPFORMATETC) LocalAlloc(LPTR, _maxNumFormats*sizeof(FORMATETC)) ;
    if (NULL == _pFormats) {
        TRC_ERR((TB,_T("Failed to allocate _pFormats")));
        hr = E_OUTOFMEMORY;
        DC_QUIT;
    }
    
    if (_pSTGMEDIUM) {
        LocalFree(_pSTGMEDIUM);
    }
    _pSTGMEDIUM = (STGMEDIUM*) LocalAlloc(LPTR, sizeof(STGMEDIUM)) ;
    if (NULL == _pFormats) {
        TRC_ERR((TB,_T("Failed to allocate STGMEDIUM")));
        hr = E_OUTOFMEMORY;
        DC_QUIT;
    }

    if (_pSTGMEDIUM != NULL) {
        _pSTGMEDIUM->tymed = TYMED_HGLOBAL ;
        _pSTGMEDIUM->pUnkForRelease = NULL ;
        _pSTGMEDIUM->hGlobal = NULL ;
    }
    _uiSTGType = 0;

DC_EXIT_POINT:    
    if (FAILED(hr)) {
        _maxNumFormats = 0;
    }
    
    DC_END_FN() ;
    return hr;
}

DCVOID CImpIDataObject::SetClipData(HGLOBAL hGlobal, DCUINT clipType)
{
    DC_BEGIN_FN("SetClipData");
    if (!_pSTGMEDIUM)    
        _pSTGMEDIUM = (STGMEDIUM*) LocalAlloc(LPTR, sizeof(STGMEDIUM)) ;

    if (_pSTGMEDIUM)
    {
        if (CF_PALETTE == clipType) {
            _pSTGMEDIUM->tymed = TYMED_GDI ;
        }
        else if (CF_METAFILEPICT == clipType) {
            _pSTGMEDIUM->tymed = TYMED_MFPICT;
        }
        else {
            _pSTGMEDIUM->tymed = TYMED_HGLOBAL ;
        }
        _pSTGMEDIUM->pUnkForRelease = NULL ;
        FreeSTGMEDIUM();
        _pSTGMEDIUM->hGlobal = hGlobal ;
        _uiSTGType = clipType;
    }

    DC_END_FN();
}

DCVOID
CImpIDataObject::FreeSTGMEDIUM(void)
{
    if ( NULL == _pSTGMEDIUM->hGlobal )
    {
        return;
    }

    switch( _uiSTGType )
    {
    case CF_PALETTE:
        DeleteObject( _pSTGMEDIUM->hGlobal );
    break;
    case CF_METAFILEPICT:
    {
        LPMETAFILEPICT pMFPict = (LPMETAFILEPICT)GlobalLock( _pSTGMEDIUM->hGlobal );
        if ( NULL != pMFPict )
        {
            if ( NULL != pMFPict->hMF )
            {
                DeleteMetaFile( pMFPict->hMF );
            }
            GlobalUnlock( _pSTGMEDIUM->hGlobal );
        }
        GlobalFree( _pSTGMEDIUM->hGlobal );
    }
    break;
    default:
        GlobalFree( _pSTGMEDIUM->hGlobal );
    }
    _pSTGMEDIUM->hGlobal = NULL;
}

CImpIDataObject::~CImpIDataObject(void)
{
    DC_BEGIN_FN("~CImplDataObject") ;

    if (_pFormats)
        LocalFree(_pFormats) ;

    if (_pSTGMEDIUM)
    {
        FreeSTGMEDIUM();
        LocalFree(_pSTGMEDIUM) ;
    }

    if (_pUnkOuter)
    {
        _pUnkOuter->Release();
        _pUnkOuter = NULL;
    }
    DC_END_FN();
}

// IUnknown members
// - Delegate to "outer" IUnknown 
STDMETHODIMP CImpIDataObject::QueryInterface(REFIID riid, PPVOID ppv)
{
    DC_BEGIN_FN("QueryInterface");
    DC_END_FN();
    return _pUnkOuter->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG) CImpIDataObject::AddRef(void)
{
    DC_BEGIN_FN("AddRef");
    InterlockedIncrement(&_cRef);
    DC_END_FN();
    return _pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CImpIDataObject::Release(void)
{
    LONG cRef;

    DC_BEGIN_FN("CImpIDataObject::Release");

    _pUnkOuter->Release();

    cRef = InterlockedDecrement(&_cRef) ;

    if (cRef == 0)
    {
        delete this;
    }

    DC_END_FN() ;
    return 0;
}

// IDataObject members
// ***************************************************************************
// CImpIDataObject::GetData
// - Here, we have to wait for the data to actually get here before we return.  
// ***************************************************************************
STDMETHODIMP CImpIDataObject::GetData(LPFORMATETC pFE, LPSTGMEDIUM pSTM)
{
    HRESULT          result = E_FAIL; // Assume we fail until we know we haven't
    TCHAR            formatName[TS_FORMAT_NAME_LEN] ;
    HGLOBAL          hData = NULL ;    
    HPDCVOID         pData ;
    HPDCVOID         pOldData ;
    HPDCVOID         pFilename ;
    HPDCVOID         pOldFilename ;    
    ULONG            oldSize ;
    ULONG            newSize ;
    byte             charSize ;
    DWORD            eventSignaled ;
    BOOL             wide ;
    DWORD*           pDropEffect ;
    DROPFILES        tempDropfile ;
    char*            fileList ;
    wchar_t*         fileListW ;
    HRESULT          hr;
    
    DC_BEGIN_FN("GetData");

    if (!_pSTGMEDIUM)
    {
        TRC_ERR((TB, _T("Transfer medium (STGMEDIUM) is NULL"))) ;
        DC_QUIT ;
    }
    
    if (!_pSTGMEDIUM->hGlobal || (pFE->cfFormat != _lastFormatRequested))
    {
        ResetEvent(CBM.GetDataSync[TS_RESET_EVENT]) ;
        ResetEvent(CBM.GetDataSync[TS_DISCONNECT_EVENT]) ;
        
        if (!CBMGetData(pFE->cfFormat))
            DC_QUIT ;
        
        do {
            eventSignaled = WaitForMultipleObjects(
                                TS_NUM_EVENTS, 
                                CBM.GetDataSync,
                                FALSE,
                                INFINITE);
        } while (eventSignaled == (WAIT_OBJECT_0)) ;

        TRC_NRM((TB, _T("EventSignaled = %d; GetLastError = %d"), eventSignaled, GetLastError())) ;

        if ((WAIT_OBJECT_0 + TS_RESET_EVENT) == eventSignaled)
        {
            ResetEvent(CBM.GetDataSync[TS_RESET_EVENT]) ;
            result = E_FAIL ;
            DC_QUIT ;
        } else if ((WAIT_OBJECT_0 + TS_DISCONNECT_EVENT) == eventSignaled) {
            ResetEvent(CBM.GetDataSync[TS_DISCONNECT_EVENT]) ;
            CBM_SET_STATE(CBM_STATE_INITIALIZED, CBM_EVENT_DISCONNECT);
            result = E_FAIL ;
            DC_QUIT ;
        }

        // Make sure that we actually got data from the client.
        
        if (_pSTGMEDIUM->hGlobal == NULL) {
            TRC_ERR((TB, _T("No format data received from client!")));
            result = E_FAIL;
            DC_QUIT;
        }

        // We check the dropeffect format, because we strip out 
        // shortcuts/links, and store the dropeffects.  The dropeffect is
        // what some apps (explorer) use to decide if they should copy, move
        // or link
        if (_cfDropEffect == pFE->cfFormat)
        {
            if (GlobalSize(_pSTGMEDIUM->hGlobal) < sizeof(DWORD)) {
                TRC_ERR((TB, _T("Unexpected global memory size!")));
                result = E_FAIL;
                DC_QUIT;
            }

            pDropEffect = (DWORD*) GlobalLock(_pSTGMEDIUM->hGlobal) ;
            
            if (!pDropEffect)
            {
                TRC_ERR((TB, _T("Unable to lock %p"), _pSTGMEDIUM->hGlobal)) ;
                _pSTGMEDIUM->hGlobal = NULL ;
                DC_QUIT ;
            }

            // We strip shortcuts and moves this way
            *pDropEffect = *pDropEffect ^ DROPEFFECT_LINK ;
            *pDropEffect = *pDropEffect ^ DROPEFFECT_MOVE ;
            CBM.dropEffect = *pDropEffect ;
            
            GlobalUnlock(_pSTGMEDIUM->hGlobal) ;
            
            pSTM->tymed = _pSTGMEDIUM->tymed ;
            pSTM->hGlobal = _pSTGMEDIUM->hGlobal ;
            // bugbug
            _pSTGMEDIUM->hGlobal = NULL;
            // bugbug: end
            pSTM->pUnkForRelease = _pSTGMEDIUM->pUnkForRelease ;
            
            result = S_OK ;
            DC_QUIT ;
        }
        else if (CF_HDROP == pFE->cfFormat)
        {
            BYTE *pbLastByte, *pbStartByte, *pbLastPossibleNullStart, charSize;
            BOOL fTrailingFileNamesValid;
            SIZE_T cbDropFiles;

            //
            // Make sure that we have at least a DROPFILES structure in
            // memory. 

            cbDropFiles = GlobalSize(_pSTGMEDIUM->hGlobal);
            if (cbDropFiles < sizeof(DROPFILES)) {
                TRC_ERR((TB, _T("Unexpected global memory size!")));
                result = E_FAIL;
                DC_QUIT;
            }
            
            pOldData = GlobalLock(_pSTGMEDIUM->hGlobal) ;
            
            if (!pOldData)
            {
                TRC_ERR((TB, _T("Unable to lock %p"), _pSTGMEDIUM->hGlobal)) ;
                _pSTGMEDIUM->hGlobal = NULL ;
                DC_QUIT ;
            }
            
            wide = ((DROPFILES*) pOldData)->fWide ;

            //
            // Check that the data behind the DROPFILES data structure
            // pointed to by pDropFiles is valid. Every drop file list
            // is terminated by two NULL characters. So, simply scan 
            // through the memory after the DROPFILES structure and make sure
            // that there is a double NULL before the last byte.
            //

            if (((DROPFILES*) pOldData)->pFiles < sizeof(DROPFILES) 
                || ((DROPFILES*) pOldData)->pFiles > cbDropFiles) {
                TRC_ERR((TB,_T("File name offset invalid!"))) ;
                result = E_FAIL;
                DC_QUIT;
            }

            pbStartByte = (BYTE*) pOldData + ((DROPFILES*) pOldData)->pFiles;
            pbLastByte = (BYTE*) pOldData + cbDropFiles - 1;
            fTrailingFileNamesValid = FALSE;
            charSize = wide ? sizeof(WCHAR) : sizeof(CHAR);
            
            //
            // Make pbLastPossibleNullStart point to the last place where a 
            // double NULL could possibly start.
            //
            // Examples: Assume pbLastByte = 9
            // Then for ASCII: pbLastPossibleNullStart = 8 (9 - 2 * 1 + 1)
            // And for UNICODE: pbLastPossibleNullStart = 6 (9 - 2 * 2 + 1)
            // 

            pbLastPossibleNullStart = pbLastByte - (2 * charSize) + 1;
            
            if (wide) {
                for (WCHAR* pwch = (WCHAR*) pbStartByte; (BYTE*) pwch <= pbLastPossibleNullStart; pwch++) {
                    if (*pwch == NULL && *(pwch + 1) == NULL) {
                        fTrailingFileNamesValid = TRUE;
                    }
                }
            } else {
                for (BYTE* pch = pbStartByte; pch <= pbLastPossibleNullStart; pch++) {
                    if (*pch == NULL && *(pch + 1) == NULL) {
                        fTrailingFileNamesValid = TRUE;
                    }
                }
            }

            if (!fTrailingFileNamesValid) {
                TRC_ERR((TB,_T("DROPFILES structure invalid!"))) ;
                result = E_FAIL;
                DC_QUIT;
            }

            //
            // DROPFILES are valid so we can continue.
            //

            oldSize = (ULONG) GlobalSize(_pSTGMEDIUM->hGlobal) ;
            newSize = CBMGetNewDropfilesSizeForServer(pOldData, oldSize, wide) ;
            if (!newSize)
            {
                TRC_ERR((TB, _T("Unable to parse DROPFILES"))) ;
            }
            else
            {
                TRC_NRM((TB, _T("DROPFILES Old size= %d New size = %d"),
                        GlobalSize(_pSTGMEDIUM->hGlobal), newSize)) ;
            }    
    
            hData = GlobalAlloc(GMEM_DISCARDABLE | GMEM_MOVEABLE,
                            newSize) ;
            if (!hData)
            {
                TRC_ERR((TB, _T("Failed to alloc %ld bytes"),
                        hData, newSize));
                GlobalFree(hData);
                hData = NULL;
                return E_FAIL ;
            }
            pData = GlobalLock(hData) ;
            if (!pData)
            {
                TRC_ERR((TB, _T("Failed to lock %p (%ld bytes)"),
                        pData, newSize));
                return E_FAIL ;
            }
            ((DROPFILES*) pData)->pFiles = ((DROPFILES*) pOldData)->pFiles ;
            ((DROPFILES*) pData)->pt = ((DROPFILES*) pOldData)->pt ;
            ((DROPFILES*) pData)->fNC = ((DROPFILES*) pOldData)->fNC ;
            ((DROPFILES*) pData)->fWide = ((DROPFILES*) pOldData)->fWide ;
            
            pOldFilename = (byte*) pOldData + ((DROPFILES*) pOldData)->pFiles ;
            pFilename = (byte*) pData + ((DROPFILES*) pData)->pFiles ;
            // We keep looping until the current 
            if (wide)
            {
                while (L'\0' != ((wchar_t*) pOldFilename)[0])
                {
                    if ( (ULONG)((BYTE*)pFilename - (BYTE*)pData) > newSize) {
                        TRC_ERR((TB,_T("Out of space, failed to convert")));
                        result = E_FAIL;
                        GlobalUnlock(hData) ;
                        GlobalUnlock(_pSTGMEDIUM->hGlobal) ;
                        DC_QUIT;
                    }
                    
                    if (S_OK != CBMConvertToServerPath(pOldFilename, pFilename, 
                        newSize - ((BYTE*)pFilename - (BYTE*)pData), wide))
                    {
                        TRC_ERR((TB, _T("Failed conversion"))) ;
                        result = E_FAIL ;
                        GlobalUnlock(hData) ;
                        GlobalUnlock(_pSTGMEDIUM->hGlobal) ;                        
                        DC_QUIT ;
                    }

                    TRC_NRM((TB,_T("oldname %ls; newname %ls"), (wchar_t*)pOldFilename, (wchar_t*)pFilename)) ;
                    pOldFilename = (byte*) pOldFilename + (wcslen((wchar_t*)pOldFilename) + 1) * sizeof(wchar_t) ;
                    pFilename = (byte*) pFilename + (wcslen((wchar_t*)pFilename) + 1) * sizeof(wchar_t) ;                
                }
            }
            else
            {
                while ('\0' != ((char*) pOldFilename)[0])
                {
                    if ( (ULONG)((BYTE*)pFilename - (BYTE*)pData) > newSize) {
                        TRC_ERR((TB,_T("Out of space, failed to convert")));
                        result = E_FAIL;
                        GlobalUnlock(hData) ;
                        GlobalUnlock(_pSTGMEDIUM->hGlobal) ;
                        DC_QUIT;
                    }
                    
                    if (S_OK != CBMConvertToServerPath(pOldFilename, pFilename, 
                        newSize - ((BYTE*)pFilename - (BYTE*)pData), wide))
                    {
                        TRC_ERR((TB, _T("Failed conversion"))) ;
                        result = E_FAIL ;
                        GlobalUnlock(hData) ;
                        GlobalUnlock(_pSTGMEDIUM->hGlobal) ;
                        DC_QUIT ;
                    }

                    TRC_NRM((TB,_T("oldname %hs; newname %hs"), (char*)pOldFilename, (char*)pFilename)) ;
                    pOldFilename = (byte*) pOldFilename + (strlen((char*)pOldFilename) + 1) * sizeof(char) ;
                    pFilename = (byte*) pFilename + (strlen((char*)pFilename) + 1) * sizeof(char) ;
                }
            }

            if (wide)
            {
                (((wchar_t*) pFilename)[0]) = L'\0';
            }
            else
            {
                (((char*) pFilename)[0]) = '\0';
            }
            
            GlobalUnlock(hData) ;
            GlobalUnlock(_pSTGMEDIUM->hGlobal) ;
            
            pSTM->tymed = _pSTGMEDIUM->tymed ;
            pSTM->hGlobal = hData ;
            pSTM->pUnkForRelease = _pSTGMEDIUM->pUnkForRelease ;
            
            result = S_OK ;
            DC_QUIT ;
        }
        else
        {
            DC_MEMSET(formatName, 0, TS_FORMAT_NAME_LEN*sizeof(TCHAR));

            if (0 != GetClipboardFormatName(pFE->cfFormat, formatName,
                                                 TS_FORMAT_NAME_LEN))
            {
                // if the remote system is requesting a filename, then we 
                // must translate the path from Driveletter:\path to 
                // \\tsclient\Driveletter\path before we hand this off        
                if ((0 == _tcscmp(formatName, TEXT("FileName"))) ||
                    (0 == _tcscmp(formatName, TEXT("FileNameW"))))
                {
                    if (0 == _tcscmp(formatName, TEXT("FileNameW")))
                    {
                        wide = TRUE ;
                        charSize = sizeof(wchar_t);
                    }
                    else
                    {
                        wide = FALSE ;
                        charSize = sizeof(char);
                    }
                    
                    pOldFilename = GlobalLock(_pSTGMEDIUM->hGlobal) ;
                    
                    if (pOldFilename != NULL)
                    {
                        //
                        // Check that pOldFilename is NULL terminated.
                        //
                        
                        size_t cbMaxOldFileName, cbOldFileName;
                        
                        cbMaxOldFileName = (ULONG) GlobalSize(_pSTGMEDIUM->hGlobal);

                        if (wide) {
                            hr = StringCbLengthW((WCHAR*) pOldFilename, 
                                                 cbMaxOldFileName, 
                                                 &cbOldFileName);
                        } else {
                            hr = StringCbLengthA((CHAR*) pOldFilename, 
                                                 cbMaxOldFileName, 
                                                 &cbOldFileName);
                        }

                        if (FAILED(hr)) {
                            TRC_ERR((TB, _T("File name not NULL terminated!")));
                            result = E_FAIL;
                            DC_QUIT;
                        }

                        //
                        // We are now assured that pOldFilename is NULL terminated
                        // and can continue.
                        //
                        
                        newSize = cbMaxOldFileName + (TS_PREPEND_LENGTH - 1) * charSize;
                        hData = GlobalAlloc(GMEM_DISCARDABLE | GMEM_MOVEABLE, newSize);
    
                        if (hData != NULL)
                        {
                            pFilename = GlobalLock(hData);
                            if (pFilename != NULL)
                            {
                                if (S_OK != CBMConvertToServerPath(pOldFilename, 
                                    pFilename, newSize, wide))
                                {
                                    TRC_ERR((TB, _T("Failed filename conversion"))) ;
                                }
                                GlobalUnlock(hData) ;
                                GlobalFree(_pSTGMEDIUM->hGlobal) ;
                                _pSTGMEDIUM->hGlobal = hData ;
                            }
                            else
                            {
                                TRC_ERR((TB, _T("Failed to lock %p (%ld bytes)"),
                                        hData, newSize));
                                GlobalFree(hData);
                                hData = NULL;
                                return E_FAIL ;
                            }
                        }
                        else
                        {
                            TRC_ERR((TB, _T("Failed to alloc %ld bytes"), newSize));
                            return E_FAIL;
                        }
                    }
                    else
                    {
                        TRC_ERR((TB, _T("Failed to lock %p"),
                                 _pSTGMEDIUM->hGlobal)) ;
                        return E_FAIL ;
                    }
                }                
            }    
            else {
                TRC_NRM((TB,_T("Requested format %d"), pFE->cfFormat)) ;
            }

            pSTM->tymed = _pSTGMEDIUM->tymed ;
            pSTM->hGlobal = _pSTGMEDIUM->hGlobal ;            
            // bugbug
            _pSTGMEDIUM->hGlobal = NULL;
            // bugbug: end
            pSTM->pUnkForRelease = _pSTGMEDIUM->pUnkForRelease ;
            result = S_OK ;
        }              
    }
    else
    {
        pSTM->tymed = _pSTGMEDIUM->tymed ;
        pSTM->hGlobal = GlobalAlloc(GMEM_DISCARDABLE | GMEM_MOVEABLE,
                  GlobalSize(_pSTGMEDIUM->hGlobal)) ;
        
        pData = GlobalLock(pSTM->hGlobal) ;
        pOldData = GlobalLock(_pSTGMEDIUM->hGlobal) ;
        
        if (!pData || !pOldData) {
            return E_FAIL ;
        }

        DC_MEMCPY(pData, pOldData, GlobalSize(_pSTGMEDIUM->hGlobal)) ;
        GlobalUnlock(pSTM->hGlobal) ;
        GlobalUnlock(_pSTGMEDIUM->hGlobal) ;
        
        pSTM->pUnkForRelease = _pSTGMEDIUM->pUnkForRelease ;   
    }
    
#if bugbug
    if (!_pSTGMEDIUM->hGlobal)
#else
    if (!pSTM->hGlobal)
#endif // bugbug
    {
        TRC_NRM((TB, _T("Clipboard data request failed"))) ;
        return E_FAIL ;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return result ;
}

STDMETHODIMP CImpIDataObject::GetDataHere(LPFORMATETC pFE, LPSTGMEDIUM pSTM)
{
    DC_BEGIN_FN("GetDataHere") ;
    DC_END_FN();
    return ResultFromScode(E_NOTIMPL) ;
}

STDMETHODIMP CImpIDataObject::QueryGetData(LPFORMATETC pFE)
{
    ULONG i = 0 ;
    HRESULT hr = DV_E_CLIPFORMAT ;
    
    DC_BEGIN_FN("QueryGetData") ;
    
    TRC_NRM((TB, _T("Format ID %d requested"), pFE->cfFormat)) ;    
    
    while (i < _numFormats)
    {
        if (_pFormats[i].cfFormat == pFE->cfFormat) {
            hr = S_OK ;
            break ;
        }
        i++ ;
    }    
    DC_END_FN();
    return hr ;
}

STDMETHODIMP CImpIDataObject::GetCanonicalFormatEtc(LPFORMATETC pFEIn, LPFORMATETC pFEOut)
{
    DC_BEGIN_FN("GetCanonicalFormatEtc") ;
    DC_END_FN();
    return ResultFromScode(E_NOTIMPL) ;
}

// ***************************************************************************
// CImpIDataObject::SetData
// - Due to the fact that the RDP only passes the simple clipboard format, and
//   the fact that we obtain all of our clipboard data from memory later, pSTM
//   is really ignored at this point.  It isn't until GetData is called that
//   the remote clipboard data is received, and a valid global memory handle
//   is generated.
// - Thus, pSTM and fRelease are ignored.
// - So our _pSTGMEDIUM is generated using generic values
// ***************************************************************************

STDMETHODIMP CImpIDataObject::SetData(LPFORMATETC pFE, LPSTGMEDIUM pSTM, BOOL fRelease)
{
    TCHAR formatName[TS_FORMAT_NAME_LEN] = {0} ;
    unsigned i ;
    DC_BEGIN_FN("SetData");

    DC_IGNORE_PARAMETER(pSTM) ;
    
     // Reset the the last format requested to 0
    _lastFormatRequested = 0 ;

    TRC_NRM((TB,_T("Adding format %d to IDataObject"), pFE->cfFormat)) ;
    
    if (_numFormats < _maxNumFormats)
    {
        for (i = 0; i < _numFormats; i++)
        {
            if (pFE->cfFormat == _pFormats[i].cfFormat)
            {
                TRC_NRM((TB,_T("Duplicate format.  Discarded"))) ;
                return DV_E_FORMATETC ;
            }
        }
        _pFormats[_numFormats] = *pFE ;        
        _numFormats++ ;
    }
    else
    {
        TRC_ERR((TB,_T("Cannot add any more formats"))) ;
        return E_FAIL ;
    }

    DC_END_FN();
    return S_OK ;
}

STDMETHODIMP CImpIDataObject::EnumFormatEtc(DWORD dwDir, LPENUMFORMATETC *ppEnum)
{
    PCEnumFormatEtc pEnum;

    DC_BEGIN_FN("CImpIDataObject::EnumFormatEtc");    
    
    *ppEnum=NULL;

    /*
     * From an external point of view there are no SET formats,
     * because we want to allow the user of this component object
     * to be able to stuff ANY format in via Set.  Only external
     * users will call EnumFormatEtc and they can only Get.
     */

    switch (dwDir)
    {
        case DATADIR_GET:
             pEnum=new CEnumFormatEtc(_pUnkOuter);
             break;

        case DATADIR_SET:
        default:
             pEnum=new CEnumFormatEtc(_pUnkOuter);
             break;
    }

    if (NULL==pEnum)
    {
        return ResultFromScode(E_FAIL);
    }
    else
    {
        //Let the enumerator copy our format list.
        pEnum->Init(_pFormats, _numFormats) ;

        pEnum->AddRef();
    }

    *ppEnum=pEnum;    
    return NO_ERROR ;
    DC_END_FN() ;
}

STDMETHODIMP CImpIDataObject::DAdvise(LPFORMATETC pFE, DWORD dwFlags, 
                     LPADVISESINK pIAdviseSink, LPDWORD pdwConn)
{
    DC_BEGIN_FN("CImpIDataObject::DAdvise");
    DC_END_FN() ;
    return ResultFromScode(E_NOTIMPL) ;
}

STDMETHODIMP CImpIDataObject::DUnadvise(DWORD dwConn)
{
    DC_BEGIN_FN("CImpIDataObject::DUnadvise");
    DC_END_FN() ;
    return ResultFromScode(E_NOTIMPL) ;
}

STDMETHODIMP CImpIDataObject::EnumDAdvise(LPENUMSTATDATA *ppEnum)
{
    DC_BEGIN_FN("CImpIDataObject::EnumDAdvise");
    DC_END_FN() ;
    return ResultFromScode(E_NOTIMPL) ;
}

CEnumFormatEtc::CEnumFormatEtc(LPUNKNOWN pUnkRef)
{
    DC_BEGIN_FN("CEnumFormatEtc::CEnumFormatEtc");
    _cRef = 0 ;
    _pUnkRef = pUnkRef ;
    if (_pUnkRef)
    {
        _pUnkRef->AddRef();
    }
    _iCur = 0;
    DC_END_FN() ;
}

DCVOID CEnumFormatEtc::Init(LPFORMATETC pFormats, ULONG numFormats)
{
    DC_BEGIN_FN("CEnumFormatEtc::Init");
    _cItems = numFormats;
    _pFormats = (LPFORMATETC) LocalAlloc(LPTR, _cItems*sizeof(FORMATETC)) ;
    if (_pFormats)
    {
        memcpy(_pFormats, pFormats, _cItems*sizeof(FORMATETC)) ;
    }
    else
    {
        TRC_ERR((TB, _T("Unable to allocate memory for formats"))) ;
    }
    DC_END_FN() ;
}

CEnumFormatEtc::~CEnumFormatEtc()
{
    DC_BEGIN_FN("CEnumFormatEtc::~CEnumFormatEtc");
    if (NULL != _pFormats)
        LocalFree(_pFormats) ;
    if (_pUnkRef)
    {
        _pUnkRef->Release();
        _pUnkRef = NULL;
    }
    DC_END_FN() ;
}

STDMETHODIMP CEnumFormatEtc::QueryInterface(REFIID riid, PPVOID ppv)
{
    DC_BEGIN_FN("CEnumFormatEtc::QueryInterface");
    *ppv=NULL;

    /*
     * Enumerators are separate objects, not the data object, so
     * we only need to support out IUnknown and IEnumFORMATETC
     * interfaces here with no concern for aggregation.
     */
    if (IID_IUnknown==riid || IID_IEnumFORMATETC==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    DC_END_FN() ;
    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CEnumFormatEtc::AddRef(void)
{
    LONG cRef;
    cRef = InterlockedIncrement(&_cRef) ;
    // should return UnkRef's RefCount?
    _pUnkRef->AddRef();

    return cRef;
}

STDMETHODIMP_(ULONG) CEnumFormatEtc::Release(void)
{
    LONG cRef;

    DC_BEGIN_FN("CEnumFormatEtc::Release");

    _pUnkRef->Release();

    cRef = InterlockedDecrement(&_cRef) ;

    if (cRef == 0)
    {
        delete this;
    }
    
    DC_END_FN() ;
    return 0;
}

STDMETHODIMP CEnumFormatEtc::Next(ULONG cFE, LPFORMATETC pFE, ULONG *pulFE)
{
    ULONG cReturn=0L;

    if (NULL == _pFormats)
        return ResultFromScode(S_FALSE);

    if (NULL == pulFE)
    {
        if (1L != cFE)
            return ResultFromScode(E_POINTER);
    }
    else
        *pulFE=0L;

    if (NULL == pFE || _iCur >= _cItems)
        return ResultFromScode(S_FALSE);

    while (_iCur < _cItems && cFE > 0)
    {
        *pFE = _pFormats[_iCur];
        pFE++;
        _iCur++;
        cReturn++;
        cFE--;
    }

    if (NULL!=pulFE)
        *pulFE=cReturn;

    return NOERROR;
}

STDMETHODIMP CEnumFormatEtc::Skip(ULONG cSkip)
{
    if ((_iCur+cSkip) >= _cItems)
        return ResultFromScode(S_FALSE);

    _iCur+=cSkip;
    return NOERROR;
}


STDMETHODIMP CEnumFormatEtc::Reset(void)
{
    _iCur=0;
    return NOERROR;
}


STDMETHODIMP CEnumFormatEtc::Clone(LPENUMFORMATETC *ppEnum)
{
    PCEnumFormatEtc     pNew = NULL;
    LPMALLOC            pIMalloc;
    LPFORMATETC         prgfe;
    BOOL                fRet=TRUE;
    ULONG               cb;

    *ppEnum=NULL;

    //Copy the memory for the list.
    if (FAILED(CoGetMalloc(MEMCTX_TASK, &pIMalloc)))
        return ResultFromScode(E_OUTOFMEMORY);

    cb=_cItems*sizeof(FORMATETC);
    prgfe=(LPFORMATETC)pIMalloc->Alloc(cb);

    if (NULL!=prgfe)
    {
        //Copy the formats
        memcpy(prgfe, _pFormats, (int)cb);

        //Create the clone
        pNew=new CEnumFormatEtc(_pUnkRef);

        if (NULL!=pNew)
        {
            pNew->_iCur=_iCur;
            pNew->_pFormats=prgfe;
            pNew->AddRef();
            fRet=TRUE;
        }
    }

    pIMalloc->Release();

    *ppEnum=pNew;
    return fRet ? NOERROR : ResultFromScode(E_OUTOFMEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpclip\scliptrc.c ===
#include <atrcdata.c>
#undef TRC_FILE
#include <atrcapi.c>
#undef TRC_FILE
#include <atrcint.c>
#undef TRC_FILE
#include <wtrcapi.c>
#undef TRC_FILE
#include <wtrcint.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpclip\rdpstrm.h ===
/////////////////////////////////////////////////////////////////////
//
//      Module:     tsstream.h
//
//      Purpose:    Sound redirection shared data definitions
//
//      Copyright(C) Microsoft Corporation 2000
//
//      History:    4-10-2000  vladimis [created]
//
/////////////////////////////////////////////////////////////////////

#ifndef _TSSTREAM_H
#define _TSSTREAM_H

#include    "rdpsndp.h"

#define TSSND_MAX_BLOCKS        2
#define TSSND_TOTALSTREAMSIZE   (TSSND_MAX_BLOCKS * TSSND_BLOCKSIZE)

#define TSSND_STREAMNAME            L"Local\\RDPSoundStream"
#define TSSND_DATAREADYEVENT        L"Local\\RDPSoundDataReadyEvent"
#define TSSND_STREAMISEMPTYEVENT    L"Local\\RDPSoundStreamIsEmptyEvent"
#define TSSND_STREAMMUTEX           L"Local\\RDPSoundStreamMutex"
#define TSSND_WAITTOINIT            L"Local\\RDPSoundWaitInit"

#define _NEG_IDX                    ((((BYTE)-1) >> 1) + 1)

#define TSSNDFLAGS_MUTE             1

typedef struct {
    //
    //  commands
    //
    BOOL    bNewVolume;
    BOOL    bNewPitch;
    //
    //  sound cap data
    //
    DWORD   dwSoundCaps;
    DWORD   dwSoundFlags;
    DWORD   dwVolume;
    DWORD   dwPitch;
    //
    //  data control
    //
    BYTE    cLastBlockQueued;
    BYTE    cLastBlockSent;
    BYTE    cLastBlockConfirmed;
    //
    //  data block
    //
    //  See the PVOID... DON'T TOUCH IT
    //  it has to be before pSndData, otherwise
    //  it won't be aligned and will crash on WIN64
    //  ( and all other RISC platforms )
#ifdef  _WIN64
    PVOID   pPad;
#else
    //
    //  align with 64bit version of the stream
    //  needed for wow64 to work smootly
    //
    DWORD   dwPad1;
    DWORD   dwPad2;
#endif  // !_WIN64

    BYTE    pSndData[TSSND_MAX_BLOCKS * TSSND_BLOCKSIZE];

} SNDSTREAM, *PSNDSTREAM;

#endif  // !_TSSTREAM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpclip\sclip2.cpp ===
/**MOD+**********************************************************************/
/* Module:    sclip2.cpp                                                    */
/*                                                                          */
/* Purpose:   Second thread                                                 */
/*            Receives RDP clipboard messages                               */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1998                                  */
/*                                                                          */
/**MOD-**********************************************************************/

#include <adcg.h>

#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "sclip2"
#include <atrcapi.h>

#include <pclip.h>
#include <sclip.h>
#include <pchannel.h>

#include <shlobj.h>

/****************************************************************************/
/* Global data                                                              */
/****************************************************************************/
#include <sclipdat.h>

//
// CBMConvertToClientPath, CBMConvertToClientPathA, CBMConvertToClientPathW
// - Arguments:
//       pOldData = Buffer containing the original file path
//       pData    = Buffer receiving the new file path
// - Returns S_OK if pOldData was a drive path
//           E_FAIL if it failed
// - Given a file path with drive letter, this function will strip out the
//   colon, and prepend the UNC prefix defined by TS_PREPEND_STRING
//
//
//     ***** NOTE *****
// - Currently, if the path is a network path, and not a drive path (C:\path)
//   it simply fails
//
HRESULT CBMConvertToClientPath(PVOID pOldData, PVOID pData, size_t cbDest, 
    BOOL fWide)
{
    DC_BEGIN_FN("CBMConvertToClientPath") ;
    if (!pOldData)
    {
        TRC_ERR((TB, _T("Original string pointer is NULL"))) ;
        return E_FAIL ;
    }
    if (!pData)
    {
        TRC_ERR((TB, _T("Destination string pointer is NULL"))) ;
        return E_FAIL ;
    }
    
    if (fWide)
        return CBMConvertToClientPathW(pOldData, pData, cbDest) ;
    else
        return CBMConvertToClientPathA(pOldData, pData, cbDest) ;

    DC_END_FN() ;
}

HRESULT CBMConvertToClientPathW(PVOID pOldData, PVOID pData, size_t cbDest)
{
    wchar_t*         filePath ;
    wchar_t*         driveLetter ;
    size_t            driveLetterLength ;
    HRESULT          hr;

    DC_BEGIN_FN("CBMConvertToClientPathW") ;

    // if this is a filepath with a drive letter, we strip the colon, and
    // prefix the path with the temp Directory
    filePath = wcschr((wchar_t*)pOldData, L':') ;
    if (filePath)
    {
        hr = StringCbCopyW((wchar_t*)pData, cbDest, CBM.tempDirW);
        DC_QUIT_ON_FAIL(hr);
        
        // Now, we start from after the colon in the drive path, and
        // find the last '\\' so we have just "\filename"
        filePath = wcsrchr(filePath + 1, L'\\');

        // Add the leftover "\filename"
        if (filePath != NULL) {
            hr = StringCbCatW((wchar_t*)pData, cbDest, filePath);
            DC_QUIT_ON_FAIL(hr);
        }
        TRC_DBG((TB,_T("New filename = %s"), (wchar_t*)pData)) ;
    }
    // else if this is a UNC path beginning with a "\\"
    else if (((wchar_t*) pOldData)[0] == L'\\' &&
             ((wchar_t*) pOldData)[1] == L'\\')
    {
        // if we receive a path beginning with the TS_PREPEND_STRING then
        // we should be smart and convert it back to a path with drive letter
        if (0 == _wcsnicmp ((wchar_t *) pOldData,
                            LTS_PREPEND_STRING, TS_PREPEND_LENGTH))
        {
            // Skip TS_PREPEND_STRING
            driveLetter = ((wchar_t*) pOldData)+TS_PREPEND_LENGTH ;
            driveLetterLength = (BYTE*)wcschr(driveLetter, L'\\') - 
                (BYTE*)driveLetter;
            hr = StringCbCopyNW((wchar_t*)pData, cbDest, driveLetter, 
                driveLetterLength);
            DC_QUIT_ON_FAIL(hr);
            ((wchar_t*)pData)[driveLetterLength] = L'\0' ;
            hr = StringCbCatW((wchar_t*)pData, cbDest, L":");
            DC_QUIT_ON_FAIL(hr);

            filePath = wcschr(driveLetter, L'\\');

            if (filePath != NULL) {
                hr = StringCbCatW((wchar_t*)pData, cbDest, filePath);
                DC_QUIT_ON_FAIL(hr);
            }
        }
        // otherwise, we just got a regular UNC path.
        else
        {
            // Stary by prepending the new file path with the temp directory
            hr = StringCbCopyW((wchar_t*) pData, cbDest, CBM.tempDirW) ;
            DC_QUIT_ON_FAIL(hr);
            // Now, we start from the beginning of the original path, 
            // find the last '\\' so we have just "\filename"
            filePath = wcsrchr((wchar_t*)pOldData, L'\\');

            if (filePath != NULL) {
                hr = StringCbCatW((wchar_t*) pData, cbDest, filePath) ;
                DC_QUIT_ON_FAIL(hr);
            }
        }
    }
    else
    {
        TRC_ERR((TB, _T("Bad path"))) ;
        hr = E_FAIL; ;
    }

DC_EXIT_POINT:   

    if (FAILED(hr)) {
        TRC_ERR((TB,_T("returning failure; hr=0x%x"), hr));
    }
    
    DC_END_FN() ;
    return hr ;
}

HRESULT CBMConvertToClientPathA(PVOID pOldData, PVOID pData, size_t cbDest)
{
    char*         filePath ;
    char*         driveLetter ;
    char*         tempPath ;
    size_t          driveLetterLength ;
    HRESULT         hr;

    DC_BEGIN_FN("CBMConvertToClientPathA") ;

    // if this is a filepath with a drive letter, we strip the colon, and
    // prefix the path with the temp Directory
    filePath = strchr((char*)pOldData, ':') ;
    if (filePath)
    {
        hr = StringCbCopyA( (char*)pData, cbDest, CBM.tempDirA) ;
        DC_QUIT_ON_FAIL(hr);
        // Now, we start from after the colon in the drive path, and
        // find the last '\\' so we have just "\filename"
        filePath = strrchr(filePath + 1, '\\');

        // Add the leftover "\filename"
        if (filePath != NULL) {
            hr = StringCbCatA((char*)pData, cbDest, filePath) ;
            DC_QUIT_ON_FAIL(hr);
        }
    }
    // else if this is a UNC path beginning with a "\\"
    else if (((char*) pOldData)[0] == '\\' &&
             ((char*) pOldData)[1] == '\\')
    {
        // if this we receive a path beginning with the TS_PREPEND_STRING then
        // we should be smart and convert it back to a path with drive letter
        if (0 == _strnicmp ((char*)pOldData,
                            TS_PREPEND_STRING, TS_PREPEND_LENGTH))
        {
            // Skip TS_PREPEND_STRING
            driveLetter = ((char*) pOldData) + TS_PREPEND_LENGTH ;
            driveLetterLength = (BYTE*)strchr(driveLetter, '\\') - 
                (BYTE*)driveLetter;

            hr = StringCbCopyNA((char*)pData, cbDest, driveLetter, 
                driveLetterLength) ;
            DC_QUIT_ON_FAIL(hr);
            ((char*)pData)[driveLetterLength] = '\0' ;

            hr = StringCbCatA((char*)pData, cbDest, ":") ;
            DC_QUIT_ON_FAIL(hr);
            
            filePath = strchr(driveLetter, '\\');
            
            if (filePath != NULL) {
                hr = StringCbCatA((char*)pData, cbDest, filePath) ;
                DC_QUIT_ON_FAIL(hr);
            }
        }
        // otherwise, we just got a regular UNC path.
        else
        {
            // Stary by prepending the new file path with the temp directory
            hr = StringCbCopyA((char*) pData, cbDest, CBM.tempDirA) ;
            DC_QUIT_ON_FAIL(hr);
            
            // Now, we start from the beginning of the original path, 
            // find the last '\\' so we have just "\filename"
            filePath = strrchr((char*)pOldData, L'\\');

            if (filePath != NULL) {
                hr = StringCbCatA((char*) pData, cbDest, filePath) ;
                DC_QUIT_ON_FAIL(hr);
            }
        }
    }
    else
    {
        TRC_ERR((TB, _T("Bad path"))) ;
        hr = E_FAIL ;
    }

DC_EXIT_POINT:   

    if (FAILED(hr)) {
        TRC_ERR((TB,_T("returning failure; hr=0x%x"), hr));
    }
    
    DC_END_FN() ;
    return hr;
}

//
// CBMGetNewFilePathLengthForClient
// - Arguments:
//       pData    = Buffer containing a filepath
//       fWide    = Wide or Ansi (TRUE if wide, FALSE if ansi)
// - Returns the size (in bytes) required to convert the path to a client path
//           0 if it fails
//

UINT CBMGetNewFilePathLengthForClient(PVOID pData, BOOL fWide)
{
    UINT result ;
    DC_BEGIN_FN("CBMGetNewFilePathLengthForClient") ;
    if (!pData)
    {
        TRC_ERR((TB, _T("Filename is NULL"))) ;
        result = 0 ;
    }
    if (fWide)
        result = CBMGetNewFilePathLengthForClientW((WCHAR*)pData) ;
    else
        result = CBMGetNewFilePathLengthForClientA((char*)pData) ;
DC_EXIT_POINT:
    DC_END_FN() ;

    return result ;
}

UINT CBMGetNewFilePathLengthForClientW(WCHAR* wszOldFilepath)
{
    UINT oldLength = wcslen(wszOldFilepath) ;
    UINT newLength ;
    UINT remainingLength = oldLength ;
    byte charSize = sizeof(WCHAR) ;
    DC_BEGIN_FN("CBMGetNewFilePathLengthForClientW") ;

    // if the old filename didn't even have space for "c:\" (with NULL),
    // then its probably invalid
    if (4 > oldLength)
    {
        newLength = 0 ;
        DC_QUIT ;
    }
    // We check to see if the filepath is prefixed by the TS_PREPEND_STRING
    // If so, we should be smart, and return the size of it with the prepend
    // string removed, and the colon added.
    if (0 == _wcsnicmp(wszOldFilepath,
                       LTS_PREPEND_STRING, TS_PREPEND_LENGTH))
    {
        newLength = oldLength - TS_PREPEND_LENGTH + 1 ; // +1 is for the colon
        DC_QUIT ;
    }
    
    while ((0 != remainingLength) && (L'\\' != wszOldFilepath[remainingLength]))
    {
        remainingLength-- ;
    }

    // Add the length of the temp directory path, and subtract the
    // path preceeding the filename ("path\filename" -> "\filename")
    // (\\server\sharename\path\morepath\filename
    newLength = oldLength - remainingLength + wcslen(CBM.tempDirW) + 1;

DC_EXIT_POINT:
    DC_END_FN() ;
    return newLength * charSize ;
}

UINT CBMGetNewFilePathLengthForClientA(char* szOldFilepath)
{
    UINT oldLength = strlen(szOldFilepath) ;
    UINT newLength ;
    UINT remainingLength = oldLength ;
    byte charSize = sizeof(char) ;
    DC_BEGIN_FN("CBMGetNewFilePathLengthForClientA") ;

    // if the old filename didn't even have space for "c:\" (with NULL),
    // then its probably invalid
    if (4 > oldLength)
    {
        newLength = 0 ;
        DC_QUIT ;
    }
    // We check to see if the filepath is prefixed by the TS_PREPEND_STRING
    // If so, we should be smart, and return the size of it with the prepend
    // string removed, and the colon added.
    if (0 == _strnicmp(szOldFilepath,
                       TS_PREPEND_STRING, TS_PREPEND_LENGTH))
    {
        newLength = oldLength - TS_PREPEND_LENGTH + 1 ; // +1 is for the colon
        DC_QUIT ;
    }
    
    while ((0 != remainingLength) && ('\\' != szOldFilepath[remainingLength]))
    {
        remainingLength-- ;
    }

    // Add the length of the temp directory path, and subtract the
    // path preceeding the filename ("path\filename" -> "\filename")
    // (\\server\sharename\path\morepath\filename
    newLength = oldLength - remainingLength + strlen(CBM.tempDirA) + 1;

DC_EXIT_POINT:
    DC_END_FN() ;
    return newLength * charSize ;
}

//
// CBMGetNewDropfilesSizeForClientSize
// - Arguments:
//       pData    = Buffer containing a DROPFILES struct 
//       oldSize   = The size of the DROPFILES struct
//       fWide     = Wide or Ansi (TRUE if wide, FALSE if ansi)
// - Returns the size required for a conversion of the paths to client paths
//           0 if it fails
//

ULONG CBMGetNewDropfilesSizeForClient(PVOID pData, ULONG oldSize, BOOL fWide)
{
    DC_BEGIN_FN("CBMGetNewDropfilesSizeForClientSize") ;
    if (fWide)
        return CBMGetNewDropfilesSizeForClientW(pData, oldSize) ;
    else
        return CBMGetNewDropfilesSizeForClientA(pData, oldSize) ;
    DC_END_FN() ;
}

ULONG CBMGetNewDropfilesSizeForClientW(PVOID pData, ULONG oldSize)
{
    ULONG            newSize = oldSize ;
    wchar_t*         filenameW ;
    wchar_t*         filePathW ;
    wchar_t*         fullFilePathW ;
    byte             charSize ;

    DC_BEGIN_FN("CBMGetNewDropfilesSizeForClientSizeW") ;
    charSize = sizeof(wchar_t) ;
    if (!pData)
    {
        TRC_ERR((TB,_T("Pointer to dropfile is NULL"))) ;
        return 0 ;
    }

    // The start of the first filename
    fullFilePathW = (wchar_t*) ((byte*) pData + ((DROPFILES*) pData)->pFiles) ;
    
    while (L'\0' != fullFilePathW[0])
    {
        filePathW = wcschr(fullFilePathW, L':') ;
        // If the file path has a colon in it, then it's a valid drive path
        if (filePathW)
        {
            // we add space for (strlen(tempDir)-1+1) characters because
            // although we are adding strlen(tempDir) characters, we are
            // stripping out the colon from the filepath; however, we add
            // an extra "\" to the string because the tempDir does not have
            // a trailing "\"
            filenameW = wcsrchr(filePathW, L'\\');

            // Add the length of the temp directory path, and subtract the
            // path preceeding the filename ("path\filename" -> "\filename")
            // (\\server\sharename\path\morepath\filename
            newSize +=  (wcslen(CBM.tempDirW) + (filenameW - fullFilePathW))
                    * charSize ;
        }
        // Otherwise, it is a UNC path
        else if (fullFilePathW[0] == L'\\' &&
                 fullFilePathW[1] == L'\\')
        {
            // if we receive a path beginning with the TS_PREPEND_STRING then
            // we should be smart and convert it back to a path with drive letter
            if (0 == _wcsnicmp(fullFilePathW,
                               LTS_PREPEND_STRING, TS_PREPEND_LENGTH))
            {
                newSize = newSize - (TS_PREPEND_LENGTH - 1) * charSize ;
            }
            else
            {
                filenameW = wcsrchr(fullFilePathW, L'\\');

                // Add the length of the temp directory path, and subtract the
                // path preceeding the filename ("path\filename" -> "\filename")
                // (\\server\sharename\path\morepath\filename
                newSize += (wcslen(CBM.tempDirW) - (filenameW - fullFilePathW))
                            * charSize ;
            }
        }
        else
        {
            TRC_ERR((TB,_T("Bad path"))) ;
            return 0 ;
        }
        fullFilePathW = fullFilePathW + (wcslen(fullFilePathW) + 1) ;
    }
    // Add space for extra null character
    newSize += charSize ;
    
    DC_END_FN() ;
    return newSize ;
}

ULONG CBMGetNewDropfilesSizeForClientA(PVOID pData, ULONG oldSize)
{
    ULONG            newSize = oldSize ;
    char*            filename ;
    char*            filePath ;
    char*            fullFilePath ;
    byte             charSize ;

    DC_BEGIN_FN("CBMGetNewDropfilesSizeForClientSizeW") ;
    charSize = sizeof(char) ;

    if (!pData)
    {
        TRC_ERR((TB,_T("Pointer to dropfile is NULL"))) ;
        return 0 ;
    }

    // The start of the first filename
    fullFilePath = (char*) ((byte*) pData + ((DROPFILES*) pData)->pFiles) ;
    
    while ('\0' != fullFilePath[0])
    {
        filePath = strchr(fullFilePath, ':') ;
        // If the file path has a colon in it, then its a valid drive path
        if (filePath)
        {
            // we add space for (strlen(tempDir)-1+1) characters because
            // although we are adding strlen(tempDir) characters, we are
            // stripping out the colon from the filepath; however, we add
            // an extra "\" to the string because the tempDir does not have
            // a trailing "\"
            filename = strrchr(filePath, '\\');
            
            // Add the length of the temp directory path, and subtract the
            // path preceeding the filename ("path\filename" -> "\filename")
            // (\\server\sharename\path\morepath\filename
            newSize += (strlen(CBM.tempDirA) + (filename - fullFilePath))
                    * charSize ;
        }
        // Otherwise, it is a UNC path
        else if (fullFilePath[0] == '\\' &&
                 fullFilePath[1] == '\\')
        {
            // if we receive a path beginning with the TS_PREPEND_STRING then
            // we should be smart and convert it back to a path with drive letter
            if (0 == _strnicmp(fullFilePath,
                               TS_PREPEND_STRING, TS_PREPEND_LENGTH))
            {
                newSize = newSize - (TS_PREPEND_LENGTH - 1) * charSize ;
            }
            else
            {
                filename = strrchr(fullFilePath, '\\');

                // Add the length of the temp directory path, and subtract the
                // path preceeding the filename ("path\filename" -> "\filename")
                // (\\server\sharename\path\morepath\filename
                newSize += (strlen(CBM.tempDirA) + (filename - fullFilePath))
                            * charSize ;
            }
        }
        else
        {
            TRC_ERR((TB,_T("Bad path"))) ;
            return 0 ;
        }

        fullFilePath = fullFilePath + (strlen(fullFilePath) + 1) ;
    }
    // Add space for extra null character
    newSize += charSize ;
    
    DC_END_FN() ;
    return newSize ;
}

//
// ClipConvertToTempPath, ClipConvertToTempPathA, ClipConvertToTempPathW
// - Arguments:
//       pSrcFiles = buffer containing the names/path of the files to be copied
// - Returns 0 if successful
//           nonzero if failed
// - Given a list of file names/paths, this function will attempt to copy them
//   to the temp directory
//
int CBMCopyToTempDirectory(PVOID pSrcFiles, BOOL fWide)
{
    int result ;
    if (fWide)
        result = CBMCopyToTempDirectoryW(pSrcFiles) ;
    else
        result = CBMCopyToTempDirectoryA(pSrcFiles) ;

    return result ;
        
}

int CBMCopyToTempDirectoryW(PVOID pSrcFiles)
{
    DC_BEGIN_FN("CBMCopyToTempDirectoryW") ;
    
    SHFILEOPSTRUCTW fileOpStructW ;
    int result ;
    HRESULT hr;
    // these are the temp, "temp directories"; they are used because we cannot
    // directly perform a conversion to client path CBM.tempDir*, because they
    // are used within the conversion routines!
    wchar_t          tempDirW[MAX_PATH] ;
    
    hr = CBMConvertToServerPath(CBM.tempDirW, tempDirW, sizeof(tempDirW), 1) ;
    if (FAILED(hr)) {
        TRC_ERR((TB,_T("CBMConvertToServerPath failed hr=0x%x"), hr));
        result = hr;
        DC_QUIT;
    }
    fileOpStructW.pFrom = (WCHAR*) pSrcFiles ;
    fileOpStructW.pTo = tempDirW ;
    fileOpStructW.hwnd = NULL ;
    fileOpStructW.wFunc = CBM.dropEffect ;
    fileOpStructW.fFlags = FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR | 
            FOF_SIMPLEPROGRESS  | FOF_ALLOWUNDO ;
    fileOpStructW.hNameMappings = NULL ;
    fileOpStructW.lpszProgressTitle = CBM.szPasteInfoStringW;
  
    result = SHFileOperationW(&fileOpStructW) ;

DC_EXIT_POINT:
    DC_END_FN();
    return result ;
}

int CBMCopyToTempDirectoryA(PVOID pSrcFiles)
{
    DC_BEGIN_FN("CBMCopyToTempDirectoryA") ;
    
    SHFILEOPSTRUCTA fileOpStructA ;
    int result ;
    HRESULT hr;
    char             tempDirA[MAX_PATH] ;

    hr = CBMConvertToServerPath(CBM.tempDirA, tempDirA, sizeof(tempDirA), 0) ;
    if (FAILED(hr)) {
        TRC_ERR((TB,_T("CBMConvertToServerPath failed hr=0x%x"), hr));
        result = hr;
        DC_QUIT;
    }
    
    fileOpStructA.pFrom = (char*) pSrcFiles ;
    fileOpStructA.pTo = tempDirA ;
    fileOpStructA.hwnd = NULL ;
    fileOpStructA.wFunc = CBM.dropEffect ;
    fileOpStructA.fFlags = FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR | 
            FOF_SIMPLEPROGRESS  | FOF_ALLOWUNDO ;
    fileOpStructA.hNameMappings = NULL ;
    fileOpStructA.lpszProgressTitle = CBM.szPasteInfoStringA;

    result = SHFileOperationA(&fileOpStructA) ;

DC_EXIT_POINT:
    DC_END_FN();    
    return result ;
}

/****************************************************************************/
/* CBMOnDataReceived - handle incoming data                                 */
/****************************************************************************/
DCVOID DCINTERNAL CBMOnDataReceived(PDCUINT8 pBuffer, DCUINT cbBytes)
{
    PCHANNEL_PDU_HEADER pHdr;
    PDCUINT8 pData;
    DCUINT copyLen;
    DCBOOL freeTheBuffer = FALSE;
    PTS_CLIP_PDU    pClipPDU;
    
    DC_BEGIN_FN("CBMOnDataReceived");
    SetEvent(CBM.GetDataSync[TS_BLOCK_RECEIVED]) ;
    pHdr = (PCHANNEL_PDU_HEADER)pBuffer;
    pData = (PDCUINT8)(pHdr + 1);
    TRC_DBG((TB, _T("Header at %p: flags %#x, length %d"),
            pHdr, pHdr->flags, pHdr->length));

    // Check to be sure we have at least a header worth of data
    if (sizeof(CHANNEL_PDU_HEADER) > cbBytes) {
        TRC_ERR((TB,_T("Packet not large enough to contain header; cbBytes=%u"),
            cbBytes));
        freeTheBuffer = TRUE;
        DC_QUIT;
    }

    /************************************************************************/
    /* First chunk - allocate memory to hold the entire message             */
    /************************************************************************/
    if (pHdr->flags & CHANNEL_FLAG_FIRST)
    {
        TRC_NRM((TB, _T("First chunk - %d of %d"), cbBytes, pHdr->length));
        CBM.rxpBuffer = (PDCUINT8) LocalAlloc(LMEM_FIXED, pHdr->length);
        if (CBM.rxpBuffer)
        {
            CBM.rxpNext = CBM.rxpBuffer;
            CBM.rxSize = pHdr->length;
            CBM.rxLeft = pHdr->length;
        }
        else
        {
            TRC_ERR((TB, _T("Failed to alloc %d bytes for rx buffer"),
                    pHdr->length));
            DC_QUIT;
        }
    }

    /************************************************************************/
    /* Check that we have a buffer available                                */
    /************************************************************************/
    if (!CBM.rxpBuffer)
    {
        TRC_ERR((TB, _T("No rx buffer")));
        DC_QUIT;
    }

    /************************************************************************/
    /* Check there's enough space left                                      */
    /************************************************************************/
    copyLen = cbBytes - sizeof(*pHdr);
    if (CBM.rxLeft < copyLen)
    {
        TRC_ERR((TB, _T("Not enough space in rx buffer: need/got %d/%d"),
                copyLen, CBM.rxLeft));
        freeTheBuffer = TRUE;
        DC_QUIT;
    }

    /************************************************************************/
    /* Copy the data                                                        */
    /************************************************************************/
    TRC_DBG((TB, _T("Copy %d bytes to %p"), copyLen, CBM.rxpNext));
    DC_MEMCPY(CBM.rxpNext, pData, copyLen);
    CBM.rxpNext += copyLen;
    CBM.rxLeft -= copyLen;

    /************************************************************************/
    /* If we have a complete buffer, tell the main thread                   */
    /************************************************************************/
    if (pHdr->flags & CHANNEL_FLAG_LAST)
    {
        /********************************************************************/
        /* Check that we received all the data                              */
        /********************************************************************/
        if (CBM.rxLeft != 0)
        {
            TRC_ERR((TB, _T("Didn't receive all the data: expect/got: %d/%d"),
                    CBM.rxSize, CBM.rxSize - CBM.rxLeft));
            freeTheBuffer = TRUE;
            DC_QUIT;
        }

        // Check that we received at least a TS_CLIP_PDU in length
        if (FIELDOFFSET(TS_CLIP_PDU, data) > CBM.rxSize) {
            TRC_ERR((TB,_T("Assembled buffer to short for TS_CLIP_PDU ")
                _T(" [need=%u got=%u]"), FIELDOFFSET(TS_CLIP_PDU, data),
                CBM.rxSize));
            freeTheBuffer = TRUE;
            DC_QUIT;
        }

        /********************************************************************/
        // If this message contains a response to our format list, a request
        // for clipboard data or the clipboard data that we requested
        //    handle it in this thread (it will not block us for long)
        // Otherwise, 
        //    Tell the main thread.  The main thread will free the buffer when
        //    it's done with this message.                                     
        /********************************************************************/
        pClipPDU = (PTS_CLIP_PDU) CBM.rxpBuffer ;

        // Validate that there is enough data to read whatever is advertised
        // in the pClipPDU->dataLen
        if (pClipPDU->dataLen + FIELDOFFSET(TS_CLIP_PDU, data) > CBM.rxSize) {
            TRC_ERR((TB,_T("TS_CLIP_PDU.dataLen field too large")));
            freeTheBuffer = TRUE;
            DC_QUIT;
        }
        
        switch (pClipPDU->msgType)
        {        
            case TS_CB_FORMAT_LIST_RESPONSE:
            {
                TRC_NRM((TB, _T("TS_CB_FORMAT_LIST_RESPONSE received")));
                CBMOnFormatListResponse(pClipPDU);
                LocalFree(pClipPDU);
            }
            break;

            case TS_CB_FORMAT_DATA_REQUEST:
            {
                TRC_NRM((TB, _T("TS_CB_FORMAT_DATA_REQUEST received")));
                CBMOnFormatDataRequest(pClipPDU);
                LocalFree(pClipPDU);
            }
            break;

            case TS_CB_FORMAT_DATA_RESPONSE:
            {
                TRC_NRM((TB, _T("TS_CB_FORMAT_DATA_RESPONSE received")));
                CBMOnFormatDataResponse(pClipPDU);
                LocalFree(pClipPDU);
            }
            break;

            case TS_CB_TEMP_DIRECTORY:
            {
                TRC_NRM((TB, _T("TS_CB_TEMP_DIRECTORY received")));
                CBM.fFileCutCopyOn = CBMOnReceivedTempDirectory(pClipPDU);
                LocalFree(pClipPDU);
            }
            break;

            default:
            {
                // Free the Clipboard thread, if locked
                if (TS_CB_FORMAT_LIST == pClipPDU->msgType)
                {
                    SetEvent(CBM.GetDataSync[TS_RESET_EVENT]) ;
                    TRC_NRM((TB,_T("Reset state; free clipboard if locked"))) ;
                }
            
                TRC_NRM((TB, _T("Pass %d bytes to main thread"), CBM.rxSize));
                PostMessage(CBM.viewerWindow,
                            CBM.regMsg,
                            CBM.rxSize,
                            (LPARAM)CBM.rxpBuffer);
            }
            break;
            
        }
    }

DC_EXIT_POINT:
    /************************************************************************/
    /* Free the buffer if necessary                                         */
    /************************************************************************/
    if (freeTheBuffer && CBM.rxpBuffer)
    {
        TRC_DBG((TB, _T("Free rx buffer")));
        LocalFree(CBM.rxpBuffer);
        CBM.rxpBuffer = NULL;
    }

    DC_END_FN();
    return;
} /* CBMOnDataReceived */


/****************************************************************************/
/* the second thread procedure                                              */
/****************************************************************************/
DWORD WINAPI CBMDataThreadProc( LPVOID pParam )
{
    DWORD waitRc = 0;
    BOOL fSuccess;
    DWORD dwResult;
    DCUINT8 readBuffer[CHANNEL_PDU_LENGTH];
    DWORD cbBytes = 0;
    DCBOOL dataRead;
    DCBOOL tryToDoRead;

    DC_BEGIN_FN("CBMDataThreadProc");

    DC_IGNORE_PARAMETER(pParam);

    /************************************************************************/
    /* loop until we're told to stop                                        */
    /************************************************************************/
    while (CBM.runThread)
    {
        dataRead = FALSE;
        tryToDoRead = (CBM.vcHandle != NULL) ? TRUE : FALSE;

        if (tryToDoRead)
        {
            /****************************************************************/
            /* Issue a read                                                 */
            /****************************************************************/
            cbBytes = sizeof(readBuffer);
            TRC_DBG((TB, _T("Issue the read")));
            fSuccess = ReadFile(CBM.vcHandle,
                                readBuffer,
                                sizeof(readBuffer),
                                &cbBytes,
                                &CBM.readOL);
            if (fSuccess)
            {
                TRC_NRM((TB, _T("Data read instantly")));
                dataRead = TRUE;
            }
            else
            {
                dwResult = GetLastError();
                TRC_DBG((TB, _T("Read failed, %d"), dwResult));
                if (dwResult != ERROR_IO_PENDING)
                {
                    /********************************************************/
                    /* The read failed.  Treat this like a disconnection -  */
                    /* stick around and wait to be reconnected.             */
                    /********************************************************/
                    TRC_ERR((TB, _T("Read failed, %d"), dwResult));
                    tryToDoRead = FALSE;
                }
            }
        }

        /********************************************************************/
        /* If we haven't read any data, wait for something to happen now    */
        /********************************************************************/
        if (!dataRead)
        {
            waitRc = WaitForMultipleObjects(CLIP_EVENT_COUNT,
                                            CBM.hEvent,
                                            FALSE,
                                            INFINITE);
            switch (waitRc)
            {
                /************************************************************/
                /* Handle Disconnect and Reconnect synchronously, so that   */
                /* all state changes are complete on return.                */
                /************************************************************/
                case WAIT_OBJECT_0 + CLIP_EVENT_DISCONNECT:
                {
                    TRC_NRM((TB, _T("Session disconnected")));
                    
                    // Make sure that if the other rdpclip thread is waiting 
                    // for a response in GetData() it is notified of the 
                    // disconnection.
                    
                    if (CBM.GetDataSync[TS_DISCONNECT_EVENT]) {
                        SetEvent(CBM.GetDataSync[TS_DISCONNECT_EVENT]);
                    }
                    
                    ResetEvent(CBM.hEvent[CLIP_EVENT_DISCONNECT]);
                    SendMessage(CBM.viewerWindow,
                                CBM.regMsg,
                                0,
                                CLIP_EVENT_DISCONNECT);
                    tryToDoRead = FALSE;
                }
                break;

                case WAIT_OBJECT_0 + CLIP_EVENT_RECONNECT:
                {
                    TRC_NRM((TB, _T("Session reconnected")));
                    ResetEvent(CBM.hEvent[CLIP_EVENT_RECONNECT]);
                    SendMessage(CBM.viewerWindow,
                                CBM.regMsg,
                                0,
                                CLIP_EVENT_RECONNECT);
                    tryToDoRead = TRUE;
                }
                break;

                /************************************************************/
                /* Data received                                            */
                /************************************************************/
                case WAIT_OBJECT_0 + CLIP_EVENT_READ:
                {
                    TRC_DBG((TB, _T("Read complete")));
                    fSuccess = GetOverlappedResult(CBM.vcHandle,
                                                   &CBM.readOL,
                                                   &cbBytes,
                                                   FALSE);
                    if (fSuccess)
                    {
                        dataRead = TRUE;
                    }
                    else
                    {
                        dwResult = GetLastError();
                        TRC_ERR((TB, _T("GetOverlappedResult failed %d"),
                            dwResult));
                        tryToDoRead = FALSE;
                    }

                    /********************************************************/
                    /* Reset the event, otherwise we can come straight back */
                    /* in here if we don't retry the read.                  */
                    /********************************************************/
                    ResetEvent(CBM.hEvent[CLIP_EVENT_READ]);
                }
                break;

                /************************************************************/
                /* Error occurred - treat as disconnect                     */
                /************************************************************/
                case WAIT_FAILED:
                default:
                {
                    dwResult = GetLastError();
                    TRC_ERR((TB, _T("Wait failed, result %d"), dwResult));
                    tryToDoRead = FALSE;
                }
                break;
            }
        }

        /********************************************************************/
        /* Once we get here, the read is complete - see what we got         */
        /********************************************************************/
        if (dataRead && CBM.runThread)
        {
            TRC_NRM((TB, _T("%d bytes of data received"), cbBytes));
            TRC_DATA_DBG("Data received", readBuffer, cbBytes);
            CBMOnDataReceived(readBuffer, cbBytes);
        }

    } /* while */

    TRC_NRM((TB, _T("Thread ending")));

DC_EXIT_POINT:
    DC_END_FN();
    ExitThread(waitRc);
    return(waitRc);
}

/****************************************************************************/
/* CBMOnReceivedTempDirectory                                               */
/*  Caller must have validated that the PDU contained enough data for the   */
/*  length specified in pClipPDU->dataLen                                   */
/****************************************************************************/
DCBOOL DCINTERNAL CBMOnReceivedTempDirectory(PTS_CLIP_PDU pClipPDU)
{
    DCBOOL fSuccess = FALSE ;
    WCHAR tempDirW[MAX_PATH] ;
    UINT  pathLength = pClipPDU->dataLen / sizeof(WCHAR) ;
    HRESULT hr;
    wchar_t *pDummy;
    size_t cbDummy;
    DC_BEGIN_FN("CBMOnReceivedTempDirectory");
   
    if (pathLength > MAX_PATH)
    {
        TRC_ERR((TB, _T("Path too big for us.  Failing"))) ;
        fSuccess = FALSE ;
        DC_QUIT ;
    }

    if (sizeof(WCHAR) > pClipPDU->dataLen) {
        TRC_ERR((TB,_T("Not enough data to read anything from buffer")));
        fSuccess = FALSE;
        DC_QUIT;
    }

    // The incoming data is not necessarily NULL terminated
    hr = StringCbCopyNExW(tempDirW, sizeof(tempDirW), (WCHAR*) pClipPDU->data,
        pClipPDU->dataLen, &pDummy, &cbDummy, 0 ); 
    if (FAILED(hr)) {
        fSuccess = FALSE;
        DC_QUIT;
    }

    // Check that the string is NULL terminated
    hr = StringCbLengthW(tempDirW, sizeof(tempDirW), &cbDummy);
    if (FAILED(hr)) {
        fSuccess = FALSE;
        DC_QUIT;
    }    
    
    hr = CBMConvertToServerPath(tempDirW, CBM.baseTempDirW, 
        sizeof(CBM.baseTempDirW), 1) ;
    if (FAILED(hr)) {
        TRC_ERR((TB,_T("CBMConvertToServerPath failed hr=0x%x"), hr ));
        fSuccess = FALSE;
        DC_QUIT;
    }
    
    fSuccess = TRUE ;
DC_EXIT_POINT:
    DC_END_FN() ;
    return fSuccess ;
}


/****************************************************************************/
/* CBMOnFormatListResponse                                                  */
/*  Caller must have validated that the PDU contained enough data for the   */
/*  length specified in pClipPDU->dataLen                                   */
/****************************************************************************/
DCVOID DCINTERNAL CBMOnFormatListResponse(PTS_CLIP_PDU pClipPDU)
{
    DC_BEGIN_FN("CBMOnFormatListResponse");

    /************************************************************************/
    /* The client has received our format list                              */
    /************************************************************************/
    TRC_NRM((TB, _T("Received FORMAT_LIST_REPSONSE")));
    CBM_CHECK_STATE(CBM_EVENT_FORMAT_LIST_RSP);

    /************************************************************************/
    /* This may arrive just after we've sent the client a format list -     */
    /* since the client always wins, we must accept the list                */
    /************************************************************************/
    if (CBM.state != CBM_STATE_PENDING_FORMAT_LIST_RSP)
    {
        TRC_ALT((TB, _T("Got unexpected list response")));
        CBM.formatResponseCount = 0;
    }
    else
    {
        /********************************************************************/
        /* update our state according to the result                         */
        /********************************************************************/
        CBM.formatResponseCount--;
        TRC_NRM((TB, _T("Waiting for %d format response(s)"),
                CBM.formatResponseCount));
        if (CBM.formatResponseCount <= 0)
        {
            if (pClipPDU->msgFlags == TS_CB_RESPONSE_OK)
            {
                TRC_DBG((TB, _T("Fmt list response OK")));
                CBM_SET_STATE(CBM_STATE_SHARED_CB_OWNER, CBM_EVENT_FORMAT_LIST_RSP);
            }
            else
            {
                TRC_ALT((TB, _T("Fmt list rsp failed")));
                CBM_SET_STATE(CBM_STATE_CONNECTED, CBM_EVENT_FORMAT_LIST_RSP);
            }
            CBM.formatResponseCount = 0;
        }

        /********************************************************************/
        /* close the local CB - if it's open - and tell the next viewer     */
        /* about the updated list                                           */
        /********************************************************************/
        if (CBM.open)
        {
            TRC_NRM((TB, _T("Close clipboard - didn't expect that")));
            if (!CloseClipboard())
            {
                TRC_SYSTEM_ERROR("CloseClipboard");
            }
            CBM.open = FALSE;
        }

        if (CBM.nextViewer != NULL)
        {
            PostMessage(CBM.nextViewer, WM_DRAWCLIPBOARD,0,0);
        }
    }

DC_EXIT_POINT:
    DC_END_FN();
    return;
} /* CBMOnFormatListResponse */


//
// CBMOnFormatDataRequest                                                   
// - Sends client format data it requested
/*  Caller must have validated that the PDU contained enough data for the   */
/*  length specified in pClipPDU->dataLen                                   */
//

DCVOID DCINTERNAL CBMOnFormatDataRequest(PTS_CLIP_PDU pClipPDU)
{
    DCUINT16         response = TS_CB_RESPONSE_OK;
    HANDLE           hData = NULL;
    PDCVOID          pData;
    PDCVOID          pNewData;    
    HANDLE           hNewData = NULL;
    HANDLE           hDropData = NULL;
    HANDLE           hTempData = NULL;    
    DCINT32          numEntries;
    DCUINT32         dataLen = 0;
    DCUINT32         pduLen;
    DCUINT           formatID;
    LOGPALETTE    *  pLogPalette = NULL;
    PTS_CLIP_PDU     pClipRsp;
    TS_CLIP_PDU      clipRsp;
    DCBOOL           fSuccess = TRUE ;
    BOOL             fWide ;
    byte             charSize ;
    DROPFILES*       pDropFiles ;
    BOOL             fDrivePath ;
    ULONG            newSize, oldSize ;
    HPDCVOID         pFileList ;
    HPDCVOID         pFilename ;
    HPDCVOID         pOldFilename ;    
    SHFILEOPSTRUCTA  fileOpStructA ;
    SHFILEOPSTRUCTW  fileOpStructW ;
    wchar_t          tempDirW[MAX_PATH] ;
    char             tempDir[MAX_PATH] ;
    DCTCHAR          formatName[TS_FORMAT_NAME_LEN] ;
    
    DC_BEGIN_FN("CBMOnFormatDataRequest");

    // The client wants a format from us
    TRC_NRM((TB, _T("Received FORMAT_DATA_REQUEST")));

    // This may arrive just after we've sent the client a format list -
    // since the client has not confirmed our list, this request is out-of-
    // date.  Fail it.
    if (CBMCheckState(CBM_EVENT_FORMAT_DATA_RQ) != CBM_TABLE_OK)
    {
        TRC_ALT((TB, _T("Unexpected format data rq")));

        // close the local CB - if it's open - and tell the next viewer
        // about the updated list
        if (CBM.open)
        {
            TRC_NRM((TB, _T("Close clipboard")));
            if (!CloseClipboard())
            {
                TRC_SYSTEM_ERROR("CloseClipboard");
            }
            CBM.open = FALSE;
        }

        if (CBM.nextViewer != NULL)
        {
            PostMessage(CBM.nextViewer, WM_DRAWCLIPBOARD,0,0);
        }

        //
        // Fail the data request
        //
        response = TS_CB_RESPONSE_FAIL;
        goto CB_SEND_RESPONSE;
    }

    if (sizeof(DCUINT) > pClipPDU->dataLen) {
        TRC_ERR((TB,_T("Not enough data to read format [need=%u got=%u]"),
            sizeof(DCUINT), pClipPDU->dataLen ));
        response = TS_CB_RESPONSE_FAIL;
        goto CB_SEND_RESPONSE;        
    }

    formatID = *((PDCUINT)(pClipPDU->data));
    TRC_NRM((TB, _T("format ID %d"), formatID));

    /************************************************************************/
    /* Open the local clipboard                                             */
    /************************************************************************/
    if (!CBM.open)
    {
        if (!OpenClipboard(CBM.viewerWindow))
        {
            TRC_SYSTEM_ERROR("OpenCB");
            response = TS_CB_RESPONSE_FAIL;
            goto CB_SEND_RESPONSE;
        }
    }

    /************************************************************************/
    /* It was/is open                                                       */
    /************************************************************************/
    TRC_NRM((TB, _T("CB opened")));
    CBM.open = TRUE;

    /************************************************************************/
    /* Get a handle to the data                                             */
    /************************************************************************/
    hData = GetClipboardData(formatID);
    if (hData == NULL)
    {
        /********************************************************************/
        /* Oops!                                                            */
        /********************************************************************/
        TRC_ERR((TB, _T("Failed to get format %d"),formatID));
        response = TS_CB_RESPONSE_FAIL;
        dataLen  = 0;
        goto CB_SEND_RESPONSE;
    }

    /************************************************************************/
    /* Got handle, now what happens next depends on the flavour of data     */
    /* we're looking at...                                                  */
    /************************************************************************/
    if (formatID == CF_PALETTE)
    {
        DCUINT16 entries;

        TRC_DBG((TB, _T("CF_PALETTE requested")));
        /********************************************************************/
        /* Find out how many entries there are in the palette and allocate  */
        /* enough memory to hold them all.                                  */
        /********************************************************************/
        if (GetObject(hData, sizeof(DCUINT16), &entries) == 0)
        {
            TRC_DBG((TB, _T("Failed count of palette entries")));
            entries = 256;
        }

        numEntries = entries;

        TRC_DBG((TB, _T("Need mem for %d palette entries"), numEntries));

        dataLen = sizeof(LOGPALETTE) +
                                    ((numEntries - 1) * sizeof(PALETTEENTRY));

        hNewData = GlobalAlloc(GHND, dataLen);
        if (hNewData == 0)
        {
            TRC_ERR((TB, _T("Failed to get %d bytes for palette"), dataLen));
            response = TS_CB_RESPONSE_FAIL;
            dataLen  = 0;
        }
        else
        {
            hDropData = hNewData;
            /****************************************************************/
            /* now get the palette entries into the new buffer              */
            /****************************************************************/
            pData = GlobalLock(hNewData);
            numEntries = GetPaletteEntries((HPALETTE)hData,
                                           0,
                                           numEntries,
                                           (PALETTEENTRY*)pData);
            GlobalUnlock(hNewData);
            TRC_DBG((TB, _T("Got %d pal entries"), numEntries));
            if (numEntries == 0)
            {
                TRC_ERR((TB, _T("Failed to get any pal entries")));
                response = TS_CB_RESPONSE_FAIL;
                dataLen  = 0;
            }
            dataLen = numEntries * sizeof(PALETTEENTRY);

            /****************************************************************/
            /* all ok - set up hData to point to the new data               */
            /****************************************************************/
            //GlobalFree(hData);
            hData = hNewData;
        }
    }
    else if (formatID == CF_METAFILEPICT)
    {
        TRC_NRM((TB, _T("Metafile data to get")));
        /********************************************************************/
        /* Metafiles are copied as Handles - we need to send across the     */
        /* actual bits                                                      */
        /********************************************************************/
        hNewData = CBMGetMFData(hData, &dataLen);
        if (!hNewData)
        {
            TRC_ERR((TB, _T("Failed to set MF data")));
            response = TS_CB_RESPONSE_FAIL;
            dataLen  = 0;
        }
        else
        {
            hDropData = hNewData;
            /****************************************************************/
            /* all ok - set up hData to point to the new data               */
            /****************************************************************/
            hData = hNewData;
        }
    }
    else if (formatID == CF_HDROP)
    {
        TRC_NRM((TB,_T("HDROP requested"))) ;
        
        pDropFiles = (DROPFILES*) GlobalLock(hData) ;
        fWide = pDropFiles->fWide ;
        charSize = fWide ? sizeof(wchar_t) : sizeof(char) ;

        if (!CBM.fAlreadyCopied)
        {
            // if its not a drive path, then copy to a temp directory
            pFileList = (byte*) pDropFiles + pDropFiles->pFiles ;
            // CBMCopyToTempDirectory returns 0 if successful
            if (0 != CBMCopyToTempDirectory(pFileList, fWide))
            {
                TRC_ERR((TB,_T("Copy to tmp directory failed"))) ;
                response = TS_CB_RESPONSE_FAIL;
                dataLen  = 0;
                CBM.fAlreadyCopied = TRUE ;
                goto CB_SEND_RESPONSE;
            }
            CBM.fAlreadyCopied = TRUE ;
        }
        // Now that we copied the files, we want to convert the file
        // paths to something the client will understand

        // Allocate space for new filepaths
        oldSize = (ULONG) GlobalSize(hData) ;
        newSize = CBMGetNewDropfilesSizeForClient(pDropFiles, oldSize, fWide) ;
        hNewData = GlobalAlloc(GMEM_DISCARDABLE | GMEM_MOVEABLE, newSize) ;                
        if (hNewData == NULL)
        {
            TRC_ERR((TB, _T("Failed to get %ld bytes for HDROP"),
                    newSize));
            response = TS_CB_RESPONSE_FAIL;
            dataLen  = 0;
            goto CB_SEND_RESPONSE;
        }
        hDropData = hNewData;
        
        pNewData = GlobalLock(hNewData) ;

        if (pNewData == NULL)
        {
            TRC_ERR((TB, _T("Failed to get lock %p for HDROP"),
                    hNewData));
            response = TS_CB_RESPONSE_FAIL;
            dataLen  = 0;
            goto CB_SEND_RESPONSE;
        }

        // Just copy the old DROPFILES data members (unchanged)
        ((DROPFILES*) pNewData)->pFiles = pDropFiles->pFiles ;
        ((DROPFILES*) pNewData)->pt     = pDropFiles->pt ;
        ((DROPFILES*) pNewData)->fNC    = pDropFiles->fNC ;
        ((DROPFILES*) pNewData)->fWide  = pDropFiles->fWide ;

        // The first filename in a DROPFILES data structure begins
        // DROPFILES.pFiles bytes away from the head of the DROPFILES
        pOldFilename = (byte*) pDropFiles + pDropFiles->pFiles ;
        pFilename = (byte*) pNewData + ((DROPFILES*) pNewData)->pFiles ;        
        while (fWide ? (L'\0' != ((wchar_t*) pOldFilename)[0]) : ('\0' != ((char*) pOldFilename)[0]))
        {
            if ((ULONG)((BYTE*)pFilename-(BYTE*)pNewData) > newSize) {
                TRC_ERR((TB,_T("Failed filename conversion, not enough data")));
            }
            else {
                if (!SUCCEEDED(CBMConvertToClientPath(pOldFilename, pFilename, 
                    newSize - ((BYTE*)pFilename-(BYTE*)pNewData), fWide)))
                {
                    TRC_ERR((TB, _T("Failed conversion"))) ;
                }
                else
                {
                    if (fWide)
                    {
                        TRC_NRM((TB,_T("oldname %ls; newname %ls"), (wchar_t*)pOldFilename, (wchar_t*)pFilename)) ;
                    }
                    else
                    {
                        TRC_NRM((TB,_T("oldname %hs; newname %hs"), (char*)pOldFilename, (char*)pFilename)) ;
                    }
                }
            }
            
            if (fWide)
            {
                pOldFilename = (byte*) pOldFilename + (wcslen((wchar_t*)pOldFilename) + 1) * sizeof(wchar_t) ;
                pFilename = (byte*) pFilename + (wcslen((wchar_t*)pFilename) + 1) * sizeof(wchar_t) ;                
            }
            else
            {
                pOldFilename = (byte*) pOldFilename + (strlen((char*)pOldFilename) + 1) * sizeof(char) ;
                pFilename = (byte*) pFilename + (strlen((char*)pFilename) + 1) * sizeof(char) ;
            }                        
        }
        if (fWide)
            ((wchar_t*)pFilename)[0] = L'\0' ;
        else
            ((char*)pFilename)[0] = '\0' ;

        GlobalUnlock(hNewData) ;
        hData = hNewData ;
        dataLen = (DWORD) GlobalSize(hData) ;
    }
    else
    {
        // Check to see if we are processing the FileName/FileNameW
        // OLE 1 formats; if so, we convert the filenames
        if (0 != GetClipboardFormatName(formatID, formatName, TS_FORMAT_NAME_LEN))
        {
            if ((0 == _tcscmp(formatName, TEXT("FileName"))) ||
                (0 == _tcscmp(formatName, TEXT("FileNameW"))))
            {
                if (0 == _tcscmp(formatName, TEXT("FileNameW")))
                {
                   fWide = TRUE ;
                   charSize = sizeof(WCHAR) ;
                }
                else
                {
                   fWide = FALSE ;
                   charSize = 1 ;
                }
                pOldFilename = GlobalLock(hData) ;
                if (!pOldFilename)
                {
                    TRC_ERR((TB, _T("No filename/Unable to lock %p"),
                            hData));
                    response = TS_CB_RESPONSE_FAIL;
                    dataLen = 0;
                    goto CB_SEND_RESPONSE;
                }

                oldSize = (ULONG)GlobalSize(hData) ;
                if (!CBM.fAlreadyCopied)
                {
                    // if its not a drive path, then copy to a temp
                    // directory.  We have to copy over the filename to
                    // string that is one character larger, because we
                    // need to add an extra NULL for the SHFileOperation
                    pFileList = (char*) LocalAlloc(LPTR, oldSize + charSize) ;
                    if (fWide)
                    {
                        wcscpy((WCHAR*)pFileList, (WCHAR*)pOldFilename) ;
                        fDrivePath = (0 != wcschr((WCHAR*) pFileList, L':')) ;
                    }
                    else
                    {
                        strcpy((char*)pFileList, (char*)pOldFilename) ;
                        fDrivePath = (0 != strchr((char*) pFileList, ':')) ;
                    }
       
                    // CBMCopyToTempDirectory returns 0 if successful
                    if (0 != CBMCopyToTempDirectory(pFileList, fWide))
                    {
                        TRC_ERR((TB,_T("Copy to tmp directory failed"))) ;
                        response = TS_CB_RESPONSE_FAIL;
                        dataLen  = 0;
                        CBM.fAlreadyCopied = TRUE ;
                        goto CB_SEND_RESPONSE;
                    }
                    CBM.fAlreadyCopied = TRUE ;
                }
                newSize = CBMGetNewFilePathLengthForClient(pOldFilename, fWide) ;
                hNewData = GlobalAlloc(GMEM_DISCARDABLE | GMEM_MOVEABLE, newSize) ;
                if (!hNewData)
                {
                    TRC_ERR((TB, _T("Failed to get %ld bytes for FileName(W)"),
                            newSize));
                    response = TS_CB_RESPONSE_FAIL;
                    dataLen  = 0;
                    goto CB_SEND_RESPONSE;
                }
                hDropData = hNewData;
                pFilename= GlobalLock(hNewData) ;
                if (!pFilename)
                {
                    TRC_ERR((TB, _T("Failed to get lock %p for FileName(W)"),
                            hNewData));
                    response = TS_CB_RESPONSE_FAIL;
                    dataLen  = 0;
                    goto CB_SEND_RESPONSE;
                }
                if (FAILED(CBMConvertToClientPath(pOldFilename, pFilename, 
                    newSize, fWide)))
                {
                    response = TS_CB_RESPONSE_FAIL;
                    dataLen  = 0;
                    goto CB_SEND_RESPONSE;
                }
                GlobalUnlock(hNewData) ;
                response = TS_CB_RESPONSE_OK;
                hData = hNewData ;
                dataLen = newSize ;                        
                goto CB_SEND_RESPONSE ;
            }
        }
        /********************************************************************/
        /* just get the length of the block                                 */
        /********************************************************************/
        dataLen = (DCUINT32)GlobalSize(hData);
        TRC_DBG((TB, _T("Got data len %d"), dataLen));
    }

CB_SEND_RESPONSE:
    
    /************************************************************************/
    /* Get some memory for a message to send to the Client if necessary     */
    /************************************************************************/
    if (hData && (dataLen != 0))
    {
        pduLen = dataLen + sizeof(TS_CLIP_PDU);
        pClipRsp = (PTS_CLIP_PDU) LocalAlloc(LMEM_FIXED, pduLen);
        if (pClipRsp == NULL)
        {
            TRC_ERR((TB, _T("Failed to alloc %d bytes"), pduLen));
            response = TS_CB_RESPONSE_FAIL;
            dataLen = 0;
            pClipRsp = &clipRsp;
            pduLen = sizeof(clipRsp);
        }
    }
    else
    {
        TRC_DBG((TB, _T("No data to send")));
        pClipRsp = &clipRsp;
        pduLen = sizeof(clipRsp);
    }

    /************************************************************************/
    /* Build the PDU                                                        */
    /************************************************************************/
    pClipRsp->msgType = TS_CB_FORMAT_DATA_RESPONSE;
    pClipRsp->msgFlags = response;
    pClipRsp->dataLen = dataLen;

    /************************************************************************/
    /* copy the data if necessary                                           */
    /************************************************************************/
    if (dataLen != 0)
    {
        TRC_DBG((TB, _T("Copy %d bytes of data"), dataLen));
        pData = GlobalLock(hData);
        DC_MEMCPY(pClipRsp->data, pData, dataLen);
        GlobalUnlock(hData);
    }

    /************************************************************************/
    /* Close the CB if open                                                 */
    /************************************************************************/
    TRC_DBG((TB, _T("Closing CB")));
    if (!CloseClipboard())
    {
        TRC_SYSTEM_ERROR("CloseClipboard");
    }
    CBM.open = FALSE;

    /************************************************************************/
    /* Send the data to the Client                                          */
    /************************************************************************/
    CBMSendToClient(pClipRsp, pduLen);

    /************************************************************************/
    /* Free the PDU, if any                                                 */
    /************************************************************************/
    if (pClipRsp != &clipRsp)
    {
        TRC_DBG((TB, _T("Free the clip PDU")));
        LocalFree(pClipRsp);
    }

DC_EXIT_POINT:
    if ( NULL != hDropData )
    {
        GlobalFree( hDropData );
    }
    DC_END_FN();
    return;
} /* CBMOnFormatDataRequest */


//
// CBMOnFormatDataRespons
// - Client response to our request for data
/*  Caller must have validated that the PDU contained enough data for the   */
/*  length specified in pClipPDU->dataLen                                   */
//
DCVOID DCINTERNAL CBMOnFormatDataResponse(PTS_CLIP_PDU pClipPDU)
{
    HANDLE          hData = NULL;
    HPDCVOID        pData;
    LOGPALETTE    * pLogPalette = NULL;
    DCUINT32        numEntries;
    DCUINT32        memLen;

    HRESULT       hr ;

    DC_BEGIN_FN("CBMOnFormatDataResponse");

    /************************************************************************/
    /* check the response                                                   */
    /************************************************************************/
    if (!(pClipPDU->msgFlags & TS_CB_RESPONSE_OK))
    {
        TRC_ALT((TB, _T("Got fmt data rsp failed for %d"), CBM.pendingClientID));
        DC_QUIT;
    }

    /************************************************************************/
    /* Got the data                                                         */
    /************************************************************************/
    TRC_NRM((TB, _T("Got OK fmt data rsp for %d"), CBM.pendingClientID));

    /************************************************************************/
    /* For some formats we still need to do some work                       */
    /************************************************************************/
    if (CBM.pendingClientID == CF_METAFILEPICT)
    {
        /********************************************************************/
        /* Metafile format - create a metafile from the data                */
        /********************************************************************/
        TRC_NRM((TB, _T("Rx data is for metafile")));
        hData = CBMSetMFData(pClipPDU->dataLen, pClipPDU->data);
        if (hData == NULL)
        {
            TRC_ERR((TB, _T("Failed to set MF data")));
        }

    }
    else if (CBM.pendingClientID == CF_PALETTE)
    {
        /********************************************************************/
        /* Palette format - create a palette from the data                  */
        /********************************************************************/

        /********************************************************************/
        /* Allocate memory for a LOGPALETTE structure large enough to hold  */
        /* all the PALETTE ENTRY structures, and fill it in.                */
        /********************************************************************/
        TRC_NRM((TB, _T("Rx data is for palette")));
        numEntries = (pClipPDU->dataLen / sizeof(PALETTEENTRY));
        memLen     = (sizeof(LOGPALETTE) +
                                   ((numEntries - 1) * sizeof(PALETTEENTRY)));
        TRC_DBG((TB, _T("%ld palette entries, allocate %ld bytes"),
                                                         numEntries, memLen));
        pLogPalette = (LOGPALETTE*) GlobalAlloc(GPTR, memLen);
        if (pLogPalette != NULL)
        {
            pLogPalette->palVersion    = 0x300;
            pLogPalette->palNumEntries = (WORD)numEntries;

            DC_MEMCPY(pLogPalette->palPalEntry,
                       pClipPDU->data,
                       pClipPDU->dataLen);

            /****************************************************************/
            /* now create a palette                                         */
            /****************************************************************/
            hData = CreatePalette(pLogPalette);
            if (hData == NULL)
            {
                TRC_SYSTEM_ERROR("CreatePalette");
            }
        }
        else
        {
            TRC_ERR((TB, _T("Failed to get %ld bytes"), memLen));
        }
    }
    else
    {
        TRC_NRM((TB, _T("Rx data can just go on CB")));
        /********************************************************************/
        /* We need to copy the data, as the receive buffer will be freed on */
        /* return from this function.                                       */
        /********************************************************************/
        hData = GlobalAlloc(GMEM_DISCARDABLE | GMEM_MOVEABLE,
                            pClipPDU->dataLen);
        if (hData != NULL)
        {
            pData = GlobalLock(hData);
            if (pData != NULL)
            {
                TRC_NRM((TB, _T("Copy %ld bytes from %p to %p"),
                        pClipPDU->dataLen, pClipPDU->data, pData));
                DC_MEMCPY(pData, pClipPDU->data, pClipPDU->dataLen);
                GlobalUnlock(hData);
            }
            else
            {
                TRC_ERR((TB, _T("Failed to lock %p (%ld bytes)"),
                        hData, pClipPDU->dataLen));
                GlobalFree(hData);
                hData = NULL;
            }
        }
        else
        {
            TRC_ERR((TB, _T("Failed to alloc %ld bytes"), pClipPDU->dataLen));
        }
    }


DC_EXIT_POINT:
    /************************************************************************/
    /* Set the state, and we're done.  Note that this is done when we get a */
    /* failure response too.                                                */
    /************************************************************************/
    CBM_SET_STATE(CBM_STATE_LOCAL_CB_OWNER, CBM_EVENT_FORMAT_DATA_RSP);
    CBM.pClipData->SetClipData(hData, CBM.pendingClientID ) ;    
    SetEvent(CBM.GetDataSync[TS_RECEIVE_COMPLETED]) ;

    /************************************************************************/
    /* tidy up                                                              */
    /************************************************************************/
    if (pLogPalette)
    {
        TRC_NRM((TB, _T("Free pLogPalette %p"), pLogPalette));
        GlobalFree(pLogPalette);
    }

    DC_END_FN();
    return;
} /* CBMOnFormatDataResponse */


/****************************************************************************/
/* CBMSendToClient                                                          */
/****************************************************************************/
DCBOOL DCINTERNAL CBMSendToClient(PTS_CLIP_PDU pClipRsp, DCUINT size)
{
    BOOL fSuccess;
    DWORD dwResult;
    DWORD cbBytes;

    DC_BEGIN_FN("CBMSendToClient");

    cbBytes = size;
    fSuccess = WriteFile(CBM.vcHandle,
                         pClipRsp,
                         size,
                         &cbBytes,
                         &CBM.writeOL);
    if (!fSuccess)
    {
        dwResult = GetLastError();
        if (ERROR_IO_PENDING == dwResult)
        {
            TRC_DBG((TB, _T("Asynchronous write")));
            fSuccess = GetOverlappedResult(CBM.vcHandle,
                                           &CBM.writeOL,
                                           &cbBytes,
                                           TRUE);
            if (fSuccess)
            {
                TRC_DATA_DBG("Data sent", pClipRsp, size);
            }
            else
            {
                TRC_SYSTEM_ERROR("GetOverlappedResult failed");
            }
        }
        else
        {
            TRC_ERR((TB, _T("Write failed, %#x"), dwResult));
        }
    }
    else
    {
        TRC_DATA_DBG("Data sent immediately", pClipRsp, size);
    }

    DC_END_FN();
    return(fSuccess);
} /* CBMSendToClient  */


/****************************************************************************/
/* CBMGetMFData                                                             */
/****************************************************************************/
HANDLE DCINTERNAL CBMGetMFData(HANDLE hData, PDCUINT32 pDataLen)
{
    DCUINT32        lenMFBits = 0;
    DCBOOL          rc        = FALSE;
    LPMETAFILEPICT  pMFP      = NULL;
    HDC             hMFDC     = NULL;
    HMETAFILE       hMF       = NULL;
    HGLOBAL         hMFBits   = NULL;
    HANDLE          hNewData  = NULL;
    PDCUINT8        pNewData  = NULL;
    PDCVOID         pBits     = NULL;

    DC_BEGIN_FN("CBMGetMFData");

    TRC_NRM((TB, _T("Getting MF data")));
    /************************************************************************/
    /* Lock the memory to get a pointer to a METAFILEPICT header structure  */
    /* and create a METAFILEPICT DC.                                        */
    /************************************************************************/
    pMFP = (LPMETAFILEPICT)GlobalLock(hData);
    if (pMFP == NULL)
    {
        TRC_SYSTEM_ERROR("GlobalLock");
        DC_QUIT;
    }

    hMFDC = CreateMetaFile(NULL);
    if (hMFDC == NULL)
    {
        TRC_SYSTEM_ERROR("CreateMetaFile");
        DC_QUIT;
    }

    /************************************************************************/
    /* Copy the MFP by playing it into the DC and closing it.               */
    /************************************************************************/
    if (!PlayMetaFile(hMFDC, pMFP->hMF))
    {
        TRC_SYSTEM_ERROR("PlayMetaFile");
        CloseMetaFile(hMFDC);
        DC_QUIT;
    }
    hMF = CloseMetaFile(hMFDC);
    if (hMF == NULL)
    {
        TRC_SYSTEM_ERROR("CloseMetaFile");
        DC_QUIT;
    }

    /************************************************************************/
    /* Get the MF bits and determine how long they are.                     */
    /************************************************************************/
    lenMFBits = GetMetaFileBitsEx(hMF, 0, NULL);
    if (lenMFBits == 0)
    {
        TRC_SYSTEM_ERROR("GetMetaFileBitsEx");
        DC_QUIT;
    }
    TRC_DBG((TB, _T("length MF bits %ld"), lenMFBits));

    /************************************************************************/
    /* Work out how much memory we need and get a buffer                    */
    /************************************************************************/
    *pDataLen = sizeof(TS_CLIP_MFPICT) + lenMFBits;
    hNewData = GlobalAlloc(GHND, *pDataLen);
    if (hNewData == NULL)
    {
        TRC_ERR((TB, _T("Failed to get MF buffer")));
        DC_QUIT;
    }
    pNewData = (PDCUINT8) GlobalLock(hNewData);
    TRC_DBG((TB, _T("Got data to send len %ld"), *pDataLen));

    /************************************************************************/
    /* Copy the MF header and bits into the buffer.                         */
    /************************************************************************/
    ((PTS_CLIP_MFPICT)pNewData)->mm   = pMFP->mm;
    ((PTS_CLIP_MFPICT)pNewData)->xExt = pMFP->xExt;
    ((PTS_CLIP_MFPICT)pNewData)->yExt = pMFP->yExt;

    lenMFBits = GetMetaFileBitsEx(hMF, lenMFBits,
                                  (pNewData + sizeof(TS_CLIP_MFPICT)));
    if (lenMFBits == 0)
    {
        TRC_SYSTEM_ERROR("GetMetaFileBitsEx");
        DC_QUIT;
    }

    /************************************************************************/
    /* all OK                                                               */
    /************************************************************************/
    TRC_NRM((TB, _T("Got %d bits of MF data"), lenMFBits));
    TRC_DATA_DBG("MF bits", (pNewData + sizeof(TS_CLIP_MFPICT)), lenMFBits);
    rc = TRUE;

DC_EXIT_POINT:
    /************************************************************************/
    /* Unlock any global mem.                                               */
    /************************************************************************/
    if (pMFP)
    {
        GlobalUnlock(hData);
    }
    if (pNewData)
    {
        GlobalUnlock(hNewData);
    }
    if (hMF)
    {
        DeleteMetaFile(hMF);
    }

    /************************************************************************/
    /* if things went wrong, then free the new data                         */
    /************************************************************************/
    if ((rc == FALSE) && (hNewData != NULL))
    {
        GlobalFree(hNewData);
        hNewData = NULL;
    }

    DC_END_FN();
    return(hNewData);

}  /* CBMGetMFData */


/****************************************************************************/
/* CBMSetMFData                                                             */
/****************************************************************************/
HANDLE DCINTERNAL CBMSetMFData(DCUINT32 dataLen, PDCVOID pData)
{
    DCBOOL         rc           = FALSE;
    HGLOBAL        hMFBits      = NULL;
    PDCVOID        pMFMem       = NULL;
    HMETAFILE      hMF          = NULL;
    HGLOBAL        hMFPict      = NULL;
    LPMETAFILEPICT pMFPict      = NULL;

    DC_BEGIN_FN("CBMSetMFData");

    TRC_DATA_DBG("Received MF data", pData, dataLen);

    /************************************************************************/
    /* Allocate memory to hold the MF bits (we need the handle to pass to   */
    /* SetMetaFileBits).                                                    */
    /************************************************************************/
    hMFBits = (PDCVOID)GlobalAlloc(GHND, dataLen - sizeof(TS_CLIP_MFPICT));
    if (hMFBits == NULL)
    {
        TRC_SYSTEM_ERROR("GlobalAlloc");
        DC_QUIT;
    }

    /************************************************************************/
    /* Lock the handle and copy in the MF header.                           */
    /************************************************************************/
    pMFMem = GlobalLock(hMFBits);
    if (pMFMem == NULL)
    {
        TRC_ERR((TB, _T("Failed to lock MF mem")));
        DC_QUIT;
    }

    TRC_DBG((TB, _T("copying %d MF bits"), dataLen - sizeof(TS_CLIP_MFPICT) ));
    DC_MEMCPY(pMFMem,
              (PDCVOID)((PDCUINT8)pData + sizeof(TS_CLIP_MFPICT)),
              dataLen - sizeof(TS_CLIP_MFPICT) );

    GlobalUnlock(pMFMem);

    /************************************************************************/
    /* Now use the copied MF bits to create the actual MF bits and get a    */
    /* handle to the MF.                                                    */
    /************************************************************************/
    hMF = SetMetaFileBitsEx(dataLen - sizeof(TS_CLIP_MFPICT), (byte *) pMFMem);
    if (hMF == NULL)
    {
        TRC_SYSTEM_ERROR("SetMetaFileBits");
        DC_QUIT;
    }

    /************************************************************************/
    /* Allocate a new METAFILEPICT structure, and use the data from the     */
    /* sent header.                                                         */
    /************************************************************************/
    hMFPict = GlobalAlloc(GHND, sizeof(METAFILEPICT));
    pMFPict = (LPMETAFILEPICT)GlobalLock(hMFPict);
    if (!pMFPict)
    {
        TRC_ERR((TB, _T("Couldn't allocate METAFILEPICT")));
        DC_QUIT;
    }

    pMFPict->mm   = (long)((PTS_CLIP_MFPICT)pData)->mm;
    pMFPict->xExt = (long)((PTS_CLIP_MFPICT)pData)->xExt;
    pMFPict->yExt = (long)((PTS_CLIP_MFPICT)pData)->yExt;
    pMFPict->hMF  = hMF;

    TRC_DBG((TB, _T("Created MF size %d, %d"), pMFPict->xExt, pMFPict->yExt ));

    GlobalUnlock(hMFPict);

    rc = TRUE;

DC_EXIT_POINT:
    /************************************************************************/
    /* tidy up                                                              */
    /************************************************************************/
    if (rc == FALSE)
    {
        if (hMFPict)
        {
            GlobalFree(hMFPict);
        }
    }

    if (hMFBits)
    {
        GlobalFree(hMFBits);
    }

    DC_END_FN();
    return(hMFPict);

} /* CBMSetMFData */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpclip\sclip.h ===
/**INC+**********************************************************************/
/* Header:    sclip.h                                                       */
/*                                                                          */
/* Purpose:   Clipboard Monitor internal function prototypes.               */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1998 - 2001                           */
/*                                                                          */
/**INC-**********************************************************************/

#ifndef _H_ACBMINT
#define _H_ACBMINT

#ifdef DC_DEBUG
#define CLIP_TRANSITION_RECORDING
#endif // DC_DEBUG

#ifdef CLIP_TRANSITION_RECORDING

#define DBG_RECORD_SIZE 128

extern UINT g_rguiDbgLastClipState[DBG_RECORD_SIZE];
extern UINT g_rguiDbgLastClipEvent[DBG_RECORD_SIZE];
extern LONG g_uiDbgPosition;

#endif // CLIP_TRANSITION_RECORDING

/****************************************************************************/
/* Client global data macros.                                               */
/****************************************************************************/
#ifndef DC_DEFINE_GLOBAL_DATA
#define DC_GL_EXT extern
#else
#define DC_GL_EXT
#endif

/****************************************************************************/
/* Clip structures                                                          */
/****************************************************************************/

/****************************************************************************/
/* Format mapping structure                                                 */
/****************************************************************************/
typedef struct tagCB_FORMAT_MAP
{
    DCUINT  clientID;
    DCUINT  serverID;
} CB_FORMAT_MAP, FAR * PCB_FORMAT_MAP;

/****************************************************************************/
/* Maximum number of formats we support                                     */
/****************************************************************************/
#define CB_MAX_FORMATS  100

/****************************************************************************/
/* CB Monitor window class                                                  */
/****************************************************************************/
#define CBM_VIEWER_CLASS       _T("CBMonitorClass")

/****************************************************************************/
/* Shared event name                                                        */
/****************************************************************************/
#define CBM_EVENT_NAME         _T("CBMonitorEvent")

/****************************************************************************/
/* Our user event                                                           */
/****************************************************************************/
#define WM_USER_DD_KICK     (WM_USER + 42)

/****************************************************************************/
/* Number of excluded formats                                               */
/****************************************************************************/
#define CBM_EXCLUDED_FORMAT_COUNT   10
#define CBM_EXCLUDED_FORMAT_COUNT_NO_RD   17


/****************************************************************************/
/* CB Internal functions                                                    */
/****************************************************************************/

DCUINT DCINTERNAL CBMRemoteFormatFromLocalID(DCUINT id);
DCUINT DCINTERNAL CBMCheckState(DCUINT event);
DCVOID DCINTERNAL CBMOnDataReceived(PDCUINT8 pBuffer, DCUINT cbBytes);
DCBOOL DCINTERNAL CBMSendToClient(PTS_CLIP_PDU pClipRsp, DCUINT size);
DCBOOL DCINTERNAL CBMDrawClipboard(DCVOID);
DCBOOL DCINTERNAL CBMOnReceivedTempDirectory(PTS_CLIP_PDU pClipPDU) ;
DCVOID DCINTERNAL CBMOnFormatList(PTS_CLIP_PDU pClipPDU);
DCVOID DCINTERNAL CBMOnFormatListResponse(PTS_CLIP_PDU pClipPDU);
DCVOID DCINTERNAL CBMOnFormatDataRequest(PTS_CLIP_PDU pClipPDU);
DCVOID DCINTERNAL CBMOnFormatDataResponse(PTS_CLIP_PDU pClipPDU);
DCVOID DCINTERNAL CBMDisconnect(DCVOID);
DCVOID DCINTERNAL CBMReconnect(DCVOID);
DCVOID DCINTERNAL CBMTerm(DCVOID);
DCBOOL DCINTERNAL CBMIsExcludedFormat(PDCTCHAR formatName);
HANDLE DCINTERNAL CBMGetMFData(HANDLE hData, PDCUINT32 pDataLen);
HANDLE DCINTERNAL CBMSetMFData(DCUINT32 dataLen, PDCVOID pData);

LRESULT CALLBACK CBMWndProc(HWND   hwnd,
                            UINT   message,
                            WPARAM wParam,
                            LPARAM lParam);
DWORD WINAPI CBMDataThreadProc( LPVOID pParam );
DWORD WINAPI CBMEventThreadProc( LPVOID pParam );
DCINT DCAPI CBM_Main(HINSTANCE hInstance);
DCINT DCAPI CBMGetData (DCUINT cfFormat) ;

int APIENTRY DllMain(HANDLE hModule,
                     DWORD  reasonForCall,
                     LPVOID lpReserved);

/****************************************************************************/
/*                                                                          */
/* CB states                                                                */
/*                                                                          */
/****************************************************************************/
#define CBM_STATE_NOT_INIT                  0
#define CBM_STATE_INITIALIZED               1
#define CBM_STATE_CONNECTED                 2
#define CBM_STATE_LOCAL_CB_OWNER            3
#define CBM_STATE_SHARED_CB_OWNER           4
#define CBM_STATE_PENDING_FORMAT_LIST_RSP   5
#define CBM_STATE_PENDING_FORMAT_DATA_RSP   6

#define CBM_NUMSTATES                       7

/****************************************************************************/
/*                                                                          */
/* CB events                                                                */
/*                                                                          */
/****************************************************************************/
#define CBM_EVENT_CBM_MAIN                0

#define CBM_EVENT_WM_CLOSE                1
#define CBM_EVENT_WM_CREATE               2
#define CBM_EVENT_WM_DESTROY              3
#define CBM_EVENT_WM_CHANGECBCHAIN        4
#define CBM_EVENT_WM_DRAWCLIPBOARD        5
#define CBM_EVENT_WM_RENDERFORMAT         6

#define CBM_EVENT_CONNECT                 7
#define CBM_EVENT_DISCONNECT              8
#define CBM_EVENT_FORMAT_LIST             9
#define CBM_EVENT_FORMAT_LIST_RSP         10
#define CBM_EVENT_FORMAT_DATA_RQ          11
#define CBM_EVENT_FORMAT_DATA_RSP         12

#define CBM_NUMEVENTS                     13

/****************************************************************************/
/* Values in the state table                                                */
/****************************************************************************/
#define CBM_TABLE_OK                      0
#define CBM_TABLE_WARN                    1
#define CBM_TABLE_ERROR                   2

/****************************************************************************/
/* Macros                                                                   */
/****************************************************************************/

/****************************************************************************/
/* CBM_CHECK_STATE - macro version with DC_QUIT                             */
/****************************************************************************/
#define CBM_CHECK_STATE(event)                                               \
    {                                                                        \
        if (CBMCheckState(event) != CBM_TABLE_OK)                            \
        {                                                                    \
            DC_QUIT;                                                         \
        }                                                                    \
    }                                                                        \


/****************************************************************************/
/* CBM_SET_STATE - set the CB state                                         */
/****************************************************************************/
#ifndef CLIP_TRANSITION_RECORDING

#define CBM_SET_STATE(newstate, event)                                      \
{                                                                           \
    TRC_NRM((TB, _T("Set state from %s to %s"),                             \
            cbmState[CBM.state], cbmState[newstate]));                      \
    CBM.state = newstate;                                                   \
}

#else

#define CBM_SET_STATE(newstate, event)                                      \
{                                                                           \
    LONG lIncIndex;                                                         \
                                                                            \
    CBM.state = newstate;                                                   \
                                                                            \
    lIncIndex = InterlockedIncrement(&g_uiDbgPosition);                     \
    g_rguiDbgLastClipState[lIncIndex % DBG_RECORD_SIZE] = newstate;         \
    g_rguiDbgLastClipEvent[lIncIndex % DBG_RECORD_SIZE] = event;            \
}

#endif // CLIP_TRANSITION_RECORDING


#endif /* _H_ACBMINT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpclip\sclipdat.h ===
/**INC+**********************************************************************/
/* Header:    sclipdata.h                                                    */
/*                                                                          */
/* Purpose:   Clipboard Monitor global data definition                      */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1998                                  */
/*                                                                          */
/**INC-**********************************************************************/

#ifndef _H_ACBMDATA
#define _H_ACBMDATA

#ifndef INITGUID
#define INITGUID
#include <initguid.h>
#endif

#include <oleguid.h>

#ifndef PPVOID
typedef LPVOID * PPVOID;
#endif  //PPVOID

#ifndef TS_STRING_FUNCS
#define TS_STRING_FUNCS

#define TS_PREPEND_STRING "\\\\tsclient\\"
#define LTS_PREPEND_STRING L"\\\\tsclient\\"
// TS_PREPEND_LENGTH is the number of characters in TS_PREPEND_STRING,
// not counting the terminating '\0'
#define TS_PREPEND_LENGTH (sizeof(TS_PREPEND_STRING) - sizeof(TS_PREPEND_STRING[0]))
#endif // ifndef TS_STRING_FUNCS

// GetDataSync EVENTS
#define TS_BLOCK_RECEIVED 0
#define TS_RECEIVE_COMPLETED 1
#define TS_RESET_EVENT 2
#define TS_DISCONNECT_EVENT 3
#define TS_NUM_EVENTS 4


// String length for the paste information string.

#define PASTE_PROGRESS_STRING_LENGTH 128

HRESULT CBMConvertToServerPathW(PVOID pOldData, PVOID pData, size_t cbDest) ;
HRESULT CBMConvertToServerPathA(PVOID pOldData, PVOID pData, size_t cbDest) ;
HRESULT CBMConvertToServerPath(PVOID pOldData, PVOID pData, size_t cbDest, 
    BOOL fWide) ;
ULONG CBMGetNewDropfilesSizeForServerW(PVOID pData, ULONG oldSize) ;
ULONG CBMGetNewDropfilesSizeForServerA(PVOID pData, ULONG oldSize) ;
ULONG CBMGetNewDropfilesSizeForServer(PVOID pData, ULONG oldSize, BOOL fWide) ;

HRESULT CBMConvertToClientPathW(PVOID pOldData, PVOID pData, size_t cbDest) ;
HRESULT CBMConvertToClientPathA(PVOID pOldData, PVOID pData, size_t cbDest) ;
HRESULT CBMConvertToClientPath(PVOID pOldData, PVOID pData, size_t cbDest, 
    BOOL fWide) ;
UINT CBMGetNewFilePathLengthForClient(PVOID pData, BOOL fWide) ;
UINT CBMGetNewFilePathLengthForClientW(WCHAR* szOldFilepath) ;
UINT CBMGetNewFilePathLengthForClientA(char* szOldFilepath) ;
ULONG CBMGetNewDropfilesSizeForClientW(PVOID pData, ULONG oldSize) ;
ULONG CBMGetNewDropfilesSizeForClientA(PVOID pData, ULONG oldSize) ;
ULONG CBMGetNewDropfilesSizeForClient(PVOID pData, ULONG oldSize, BOOL fWide) ;

int CBMCopyToTempDirectory(PVOID pSrcFiles, BOOL fWide) ;
int CBMCopyToTempDirectoryW(PVOID pSrcFiles) ;
int CBMCopyToTempDirectoryA(PVOID pSrcFiles) ;


class CImpIDataObject ;
typedef CImpIDataObject *PCImpIDataObject ;

class CEnumFormatEtc ;

class CClipData : public IUnknown
{
friend CImpIDataObject ;
friend CEnumFormatEtc ;

private:
    LONG    _cRef ;
    TS_CLIP_PDU     _ClipPDU ;
    PCImpIDataObject    _pImpIDataObject ;
    
public:
    CClipData();
    ~CClipData(void);

    HRESULT DCINTERNAL SetNumFormats(ULONG);
    DCVOID SetClipData(HGLOBAL, DCUINT) ;

    //IUnknown members that delegate to _pUnkOuter.
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
} ;

typedef CClipData *PCClipData ;

class CImpIDataObject : public IDataObject
{
private:
    LONG           _cRef;
    LPUNKNOWN       _pUnkOuter;
    ULONG           _maxNumFormats ;
    // Current number of formats in IDataObject
    ULONG           _numFormats ;
    // Buffer of _maxNumFormats FORMATETC's
    LPFORMATETC     _pFormats ;
    LPSTGMEDIUM     _pSTGMEDIUM ; // Our fixed STGMEDIUM (always an HGLOBAL)
    DCUINT          _uiSTGType;
    // _lastFormatRequested is used to see if we can avoid re-requesting the
    // same data twice over the wire.
    CLIPFORMAT      _lastFormatRequested ;
    CLIPFORMAT      _cfDropEffect ;
    BOOL            _fAlreadyCopied ;
    DWORD            _dropEffect ; // We currently only support FO_COPY and FO_MOVE
    LPVOID           _fileName ;
        
    DCVOID FreeSTGMEDIUM( void );

public:
    PTS_CLIP_PDU    _pClipPDU ;
    CImpIDataObject(LPUNKNOWN);
    ~CImpIDataObject(void);
    HRESULT Init(ULONG) ;
    DCVOID SetClipData(HGLOBAL, DCUINT) ;

public:
    //IUnknown members that delegate to _pUnkOuter.
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IDataObject members
    STDMETHODIMP GetData(LPFORMATETC, LPSTGMEDIUM);
    STDMETHODIMP GetDataHere(LPFORMATETC, LPSTGMEDIUM);
    STDMETHODIMP QueryGetData(LPFORMATETC);
    STDMETHODIMP GetCanonicalFormatEtc(LPFORMATETC, LPFORMATETC);
    STDMETHODIMP SetData(LPFORMATETC, LPSTGMEDIUM, BOOL);
    STDMETHODIMP EnumFormatEtc(DWORD, LPENUMFORMATETC *);
    STDMETHODIMP DAdvise(LPFORMATETC, DWORD
                 ,  LPADVISESINK, DWORD *);
    STDMETHODIMP DUnadvise(DWORD);
    STDMETHODIMP EnumDAdvise(LPENUMSTATDATA *);
};

class CEnumFormatEtc : public IEnumFORMATETC
{
private:
    LONG           _cRef;
    LPUNKNOWN       _pUnkRef;
    LPFORMATETC     _pFormats;
    ULONG           _iCur;
    ULONG           _cItems;

public:
    CEnumFormatEtc(LPUNKNOWN);
    ~CEnumFormatEtc(void);
    DCVOID Init(LPFORMATETC, ULONG) ;

    //IUnknown members that delegate to _pUnkOuter.
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IEnumFORMATETC members
    STDMETHODIMP Next(ULONG, LPFORMATETC, ULONG *);
    STDMETHODIMP Skip(ULONG);
    STDMETHODIMP Reset(void);
    STDMETHODIMP Clone(IEnumFORMATETC **);
};

typedef CEnumFormatEtc *PCEnumFormatEtc;

/**STRUCT+*******************************************************************/
/* Structure: CBM_GLOBAL_DATA                                               */
/*                                                                          */
/* Description: Clipboard Monitor global data                               */
/****************************************************************************/
typedef struct tagCBM_GLOBAL_DATA
{
    /************************************************************************/
    /* Clipboard viewer chain information                                   */
    /************************************************************************/
    HWND            viewerWindow;
    WNDCLASS        viewerWindowClass;
    HWND            nextViewer;
    DCBOOL          notifyNextViewer;

    /************************************************************************/
    /* Our state information                                                */
    /************************************************************************/
    DCUINT          state;
    DCBOOL          open;

    /************************************************************************/
    /* Client uses ascii for format names                                   */
    /************************************************************************/
    DCBOOL          fUseAsciiNames;

    /************************************************************************/
    /* Server/client format ID map                                          */
    /************************************************************************/
    CB_FORMAT_MAP   idMap[CB_MAX_FORMATS];

    /************************************************************************/
    /* The registered message used to communicate between the two threads   */
    /* of the Clipboard Monitor                                             */
    /************************************************************************/
    UINT            regMsg;

    /************************************************************************/
    /* thread info                                                          */
    /************************************************************************/
    DCBOOL          runThread;
    HANDLE          hDataThread;

    /************************************************************************/
    /* other useful data                                                    */
    /************************************************************************/
    DCUINT          pendingClientID;
    DCUINT          pendingServerID;
    ULONG           logonId;
    INT             formatResponseCount;

    /************************************************************************/
    /* Virtual channel stuff                                                */
    /************************************************************************/
    HANDLE          vcHandle;
    OVERLAPPED      writeOL;
    OVERLAPPED      readOL;
    PDCUINT8        rxpBuffer;
    PDCUINT8        rxpNext;
    DCUINT          rxSize;
    DCUINT          rxLeft;

    /************************************************************************/
    /* Array of events                                                      */
    /************************************************************************/
    #define CLIP_EVENT_DISCONNECT   0
    #define CLIP_EVENT_RECONNECT    1
    #define CLIP_EVENT_READ         2
    #define CLIP_EVENT_COUNT        3
    HANDLE          hEvent[CLIP_EVENT_COUNT];

    /************************************************************************/
    /* Already running mutex                                                */
    /************************************************************************/
    HANDLE          hMutex;

    // GetDataSync is an array of event handles used to synchronize the
    // transmission of data from the remote and local clipboard via the
    // IDataObject::GetData interface function
	
    // GetDataSync[TS_BLOCK_RECEIVED] is signaled if a datapacket arrives
    // GetDataSync[TS_RECEIVE_COMPLETED] is signaled when the data stream is done sending data	
    // GetDataSync[TS_RESET_EVENT] is signaled when we need to reset/stop waiting
    // GetDataSync[TS_DISCONNECT_EVENT] is signaled when a disconnect event occurs
    HANDLE  GetDataSync[TS_NUM_EVENTS] ; 
    // CClipData is the data object that encapsulates the IDataObject
    PCClipData           pClipData ;

    // locatation where temp files will go; the +1 is for an extra NULL char
    // that may be needed for the SHFileOperation
    char             tempDirA[MAX_PATH+1] ;
    wchar_t          tempDirW[MAX_PATH+1] ;
    char             baseTempDirA[MAX_PATH+1] ;
    wchar_t          baseTempDirW[MAX_PATH+1] ;

    DWORD            dropEffect ;
    BOOL             fFileCutCopyOn ;
    BOOL             fAlreadyCopied ;

    BOOL             fRegisteredForSessNotif;
    BOOL             fInClipboardChain;

    WCHAR            szPasteInfoStringW[PASTE_PROGRESS_STRING_LENGTH];
    CHAR             szPasteInfoStringA[PASTE_PROGRESS_STRING_LENGTH];
} CBM_GLOBAL_DATA;
/**STRUCT-*******************************************************************/

DC_GL_EXT CBM_GLOBAL_DATA CBM

#ifdef DC_DEFINE_GLOBAL_DATA
    = { 0 }
#endif
;

/****************************************************************************/
/* CBM State Table                                                          */
/****************************************************************************/
DC_GL_EXT DCUINT cbmStateTable[CBM_NUMEVENTS][CBM_NUMSTATES]

#ifdef DC_DEFINE_GLOBAL_DATA
    = {

        /********************************************************************/
        /* This is not a state table in the strict sense.  It simply shows  */
        /* which events are valid in which states.  It is not used to drive */
        /* CB.                                                              */
        /*                                                                  */
        /* Values mean                                                      */
        /* - 0 event OK in this state.                                      */
        /* - 1 warning - event should not occur in this state, but does in  */
        /*     some race conditions - ignore it.                            */
        /* - 2 error - event should not occur in ths state at all.          */
        /*                                                                  */
        /* These values are hard-coded here in order to make the table      */
        /* readable.  They correspond to the constants CBM_TABLE_OK,        */
        /* CBM_TABLE_WARN & CBM_TABLE_ERROR.                                */
        /*                                                                  */
        /*  Uninitialized                                                   */
        /*  |   Initialized                                                 */
        /*  |   |   Connected                                               */
        /*  |   |   |   Local CB owner                                      */
        /*  |   |   |   |   Shared CB owner                                 */
        /*  |   |   |   |   |   Pending format list rsp                     */
        /*  |   |   |   |   |   |   Pending format data rsp                 */
        /*  |   |   |   |   |   |   |                                       */
        /********************************************************************/
/* Start up */
        {   0,  2,  2,  2,  2,  2,  2},     /* CBM_MAIN                     */

/* local Window messages */
        {   2,  0,  0,  0,  0,  0,  0},     /* WM_CLOSE                     */
        {   0,  2,  2,  2,  2,  2,  2},     /* WM_CREATE                    */
        {   2,  0,  2,  2,  2,  2,  2},     /* WM_DESTROY                   */
        {   2,  0,  0,  0,  0,  0,  0},     /* WM_CHANGECBCHAIN             */
        {   1,  1,  0,  0,  0,  0,  2},     /* WM_DRAWCLIPBOARD             */
        {   2,  2,  0,  0,  2,  2,  2},     /* WM_RENDERFORMAT              */

/* shared CB messages */
        {   2,  0,  1,  0,  2,  2,  2},     /* Connect                      */
        {   1,  1,  0,  0,  0,  0,  0},     /* Disconnect                   */
        {   2,  2,  0,  0,  0,  0,  0},     /* Format list                  */
        {   2,  2,  2,  2,  2,  0,  2},     /* Format list rsp              */
        {   2,  2,  1,  1,  0,  1,  2},     /* Format data rq               */
        {   2,  2,  2,  2,  2,  2,  0}      /* Format data rsp              */
    }
#endif /* DC_DEFINE_GLOBAL_DATA */
;

#ifdef DC_DEBUG
/****************************************************************************/
/* State and event descriptions (debug build only)                          */
/****************************************************************************/
DC_GL_EXT const DCTCHAR cbmState[CBM_NUMSTATES][35]
#ifdef DC_DEFINE_GLOBAL_DATA
    = {
        _T("CBM_STATE_NOT_INIT"),
        _T("CBM_STATE_INITIALIZED"),
        _T("CBM_STATE_CONNECTED"),
        _T("CBM_STATE_LOCAL_CB_OWNER"),
        _T("CBM_STATE_SHARED_CB_OWNER"),
        _T("CBM_STATE_PENDING_FORMAT_LIST_RSP"),
        _T("CBM_STATE_PENDING_FORMAT_DATA_RSP")
    }
#endif /* DC_DEFINE_GLOBAL_DATA */
;

DC_GL_EXT const DCTCHAR cbmEvent[CBM_NUMEVENTS][35]
#ifdef DC_DEFINE_GLOBAL_DATA
    = {
        _T("CBM_EVENT_CBM_MAIN"),
        _T("CBM_EVENT_WM_CLOSE"),
        _T("CBM_EVENT_WM_CREATE"),
        _T("CBM_EVENT_WM_DESTROY"),
        _T("CBM_EVENT_WM_CHANGECBCHAIN"),
        _T("CBM_EVENT_WM_DRAWCLIPBOARD"),
        _T("CBM_EVENT_WM_RENDERFORMAT"),
        _T("CBM_EVENT_CONNECT"),
        _T("CBM_EVENT_DISCONNECT"),
        _T("CBM_EVENT_FORMAT_LIST"),
        _T("CBM_EVENT_FORMAT_LIST_RSP"),
        _T("CBM_EVENT_FORMAT_DATA_RQ"),
        _T("CBM_EVENT_FORMAT_DATA_RSP")
    }
#endif /* DC_DEFINE_GLOBAL_DATA */
;

#endif /* DC_DEBUG */

/****************************************************************************/
/* Excluded formats                                                         */
/****************************************************************************/
const DCTCHAR cbmExcludedFormatList[CBM_EXCLUDED_FORMAT_COUNT]
                                       [TS_FORMAT_NAME_LEN]
    = {
        _T("Link"                  ),
        _T("OwnerLink"             ),
        _T("ObjectLink"            ),
        _T("Link Source"           ),
        _T("Link Source Descriptor"),
        
        _T("Embed Source"          ),
        _T("Embedded Object"       )
//        _T("Ole Private Data"      ),
//        _T("DataObject"            ),
//        _T("Object Descriptor"     ),
//        _T("Shell IDList Array"    ),
//        _T("Shell Object Offsets"  ),
//        _T("FileName"              ),
//        _T("FileNameW"             ),
        _T("FileContents"          ),
        _T("FileGroupDescriptor"   ),
        _T("FileGroupDescriptorW"  ),
    } ;

const DCTCHAR cbmExcludedFormatList_NO_RD[CBM_EXCLUDED_FORMAT_COUNT_NO_RD]
                                       [TS_FORMAT_NAME_LEN]
    = {
        _T("Link"                  ),
        _T("OwnerLink"             ),
        _T("ObjectLink"            ),
        _T("Link Source"           ),
        _T("Link Source Descriptor"),
        
        _T("Embed Source"          ),
        _T("Embedded Object"       )
        _T("Ole Private Data"      ),
        _T("DataObject"            ),
        _T("Object Descriptor"     ),
        _T("Shell IDList Array"    ),
        _T("Shell Object Offsets"  ),
        _T("FileName"              ),
        _T("FileNameW"             ),
        _T("FileContents"          ),
        _T("FileGroupDescriptor"   ),
        _T("FileGroupDescriptorW"  ),
    } ;


#endif /* _H_ACBMDATA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpclip\sndknown.h ===
// use dumpcod.c to generate this table
//
// FormatTag |   Channels | SamplesPerSec | AvgBytesPerSec | BlockAlign | BitsPerSamepl | ExtraInfo
// ================================================================================================
//
BYTE KnownFormats[] = {
#ifndef _WIN64
// 006, 02, 22050, 44100, 002, 08
0x06, 0x00, 0x02, 0x00, 0x22, 0x56, 0x00, 0x00, 0x44, 0xac, 0x00, 0x00, 0x02, 0x00, 0x08, 0x00, 0x00, 0x00,
// 007, 02, 22050, 44100, 002, 08
0x07, 0x00, 0x02, 0x00, 0x22, 0x56, 0x00, 0x00, 0x44, 0xac, 0x00, 0x00, 0x02, 0x00, 0x08, 0x00, 0x00, 0x00,
#endif
// 002, 02, 22050, 22311, 1024, 04
0x02, 0x00, 0x02, 0x00, 0x22, 0x56, 0x00, 0x00, 0x27, 0x57, 0x00, 0x00, 0x00, 0x04, 0x04, 0x00, 0x20, 0x00, 0xf4, 0x03, 0x07, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x40, 0x00, 0xf0, 0x00, 0x00, 0x00, 0xcc, 0x01, 0x30, 0xff, 0x88, 0x01, 0x18, 0xff,
// 017, 02, 22050, 22201, 1024, 04
0x11, 0x00, 0x02, 0x00, 0x22, 0x56, 0x00, 0x00, 0xb9, 0x56, 0x00, 0x00, 0x00, 0x04, 0x04, 0x00, 0x02, 0x00, 0xf9, 0x03,
#ifndef _WIN64
// 006, 02, 11025, 22050, 002, 08
0x06, 0x00, 0x02, 0x00, 0x11, 0x2b, 0x00, 0x00, 0x22, 0x56, 0x00, 0x00, 0x02, 0x00, 0x08, 0x00, 0x00, 0x00,
// 006, 01, 22050, 22050, 001, 08
0x06, 0x00, 0x01, 0x00, 0x22, 0x56, 0x00, 0x00, 0x22, 0x56, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00,
// 007, 02, 11025, 22050, 002, 08
0x07, 0x00, 0x02, 0x00, 0x11, 0x2b, 0x00, 0x00, 0x22, 0x56, 0x00, 0x00, 0x02, 0x00, 0x08, 0x00, 0x00, 0x00,
// 007, 01, 22050, 22050, 001, 08
0x07, 0x00, 0x01, 0x00, 0x22, 0x56, 0x00, 0x00, 0x22, 0x56, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00,
// 006, 02, 08000, 16000, 002, 08
0x06, 0x00, 0x02, 0x00, 0x40, 0x1f, 0x00, 0x00, 0x80, 0x3e, 0x00, 0x00, 0x02, 0x00, 0x08, 0x00, 0x00, 0x00,
// 007, 02, 08000, 16000, 002, 08
0x07, 0x00, 0x02, 0x00, 0x40, 0x1f, 0x00, 0x00, 0x80, 0x3e, 0x00, 0x00, 0x02, 0x00, 0x08, 0x00, 0x00, 0x00,
#endif
// 002, 02, 11025, 11289, 512, 04
0x02, 0x00, 0x02, 0x00, 0x11, 0x2b, 0x00, 0x00, 0x19, 0x2c, 0x00, 0x00, 0x00, 0x02, 0x04, 0x00, 0x20, 0x00, 0xf4, 0x01, 0x07, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x40, 0x00, 0xf0, 0x00, 0x00, 0x00, 0xcc, 0x01, 0x30, 0xff, 0x88, 0x01, 0x18, 0xff,
// 017, 02, 11025, 11177, 512, 04
0x11, 0x00, 0x02, 0x00, 0x11, 0x2b, 0x00, 0x00, 0xa9, 0x2b, 0x00, 0x00, 0x00, 0x02, 0x04, 0x00, 0x02, 0x00, 0xf9, 0x01,
// 002, 01, 22050, 11155, 512, 04
0x02, 0x00, 0x01, 0x00, 0x22, 0x56, 0x00, 0x00, 0x93, 0x2b, 0x00, 0x00, 0x00, 0x02, 0x04, 0x00, 0x20, 0x00, 0xf4, 0x03, 0x07, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x40, 0x00, 0xf0, 0x00, 0x00, 0x00, 0xcc, 0x01, 0x30, 0xff, 0x88, 0x01, 0x18, 0xff,
// 017, 01, 22050, 11100, 512, 04
0x11, 0x00, 0x01, 0x00, 0x22, 0x56, 0x00, 0x00, 0x5c, 0x2b, 0x00, 0x00, 0x00, 0x02, 0x04, 0x00, 0x02, 0x00, 0xf9, 0x03,
#ifndef _WIN64
// 006, 01, 11025, 11025, 001, 08
0x06, 0x00, 0x01, 0x00, 0x11, 0x2b, 0x00, 0x00, 0x11, 0x2b, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00,
// 007, 01, 11025, 11025, 001, 08
0x07, 0x00, 0x01, 0x00, 0x11, 0x2b, 0x00, 0x00, 0x11, 0x2b, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00,
#endif
// 002, 02, 08000, 08192, 512, 04
0x02, 0x00, 0x02, 0x00, 0x40, 0x1f, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x02, 0x04, 0x00, 0x20, 0x00, 0xf4, 0x01, 0x07, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x40, 0x00, 0xf0, 0x00, 0x00, 0x00, 0xcc, 0x01, 0x30, 0xff, 0x88, 0x01, 0x18, 0xff,
// 017, 02, 08000, 08110, 512, 04
0x11, 0x00, 0x02, 0x00, 0x40, 0x1f, 0x00, 0x00, 0xae, 0x1f, 0x00, 0x00, 0x00, 0x02, 0x04, 0x00, 0x02, 0x00, 0xf9, 0x01,
#ifndef _WIN64
// 006, 01, 08000, 08000, 001, 08
0x06, 0x00, 0x01, 0x00, 0x40, 0x1f, 0x00, 0x00, 0x40, 0x1f, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00,
// 007, 01, 08000, 08000, 001, 08
0x07, 0x00, 0x01, 0x00, 0x40, 0x1f, 0x00, 0x00, 0x40, 0x1f, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00,
// 085, 02, 22050, 07000, 001, 00
0x55, 0x00, 0x02, 0x00, 0x22, 0x56, 0x00, 0x00, 0x58, 0x1b, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0xb6, 0x00, 0x01, 0x00, 0x71, 0x05,
// 085, 02, 16000, 07000, 001, 00
0x55, 0x00, 0x02, 0x00, 0x80, 0x3e, 0x00, 0x00, 0x58, 0x1b, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x01, 0x00, 0x71, 0x05,
// 085, 02, 22050, 06000, 001, 00
0x55, 0x00, 0x02, 0x00, 0x22, 0x56, 0x00, 0x00, 0x70, 0x17, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x9c, 0x00, 0x01, 0x00, 0x71, 0x05,
// 085, 02, 16000, 06000, 001, 00
0x55, 0x00, 0x02, 0x00, 0x80, 0x3e, 0x00, 0x00, 0x70, 0x17, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0xd8, 0x00, 0x01, 0x00, 0x71, 0x05,
#endif
// 002, 01, 11025, 05644, 256, 04
0x02, 0x00, 0x01, 0x00, 0x11, 0x2b, 0x00, 0x00, 0x0c, 0x16, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x20, 0x00, 0xf4, 0x01, 0x07, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x40, 0x00, 0xf0, 0x00, 0x00, 0x00, 0xcc, 0x01, 0x30, 0xff, 0x88, 0x01, 0x18, 0xff,
// 017, 01, 11025, 05588, 256, 04
0x11, 0x00, 0x01, 0x00, 0x11, 0x2b, 0x00, 0x00, 0xd4, 0x15, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x02, 0x00, 0xf9, 0x01,
#ifndef _WIN64
// 085, 02, 22050, 05000, 001, 00
0x55, 0x00, 0x02, 0x00, 0x22, 0x56, 0x00, 0x00, 0x88, 0x13, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x82, 0x00, 0x01, 0x00, 0x71, 0x05,
// 085, 02, 16000, 05000, 001, 00
0x55, 0x00, 0x02, 0x00, 0x80, 0x3e, 0x00, 0x00, 0x88, 0x13, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0xb4, 0x00, 0x01, 0x00, 0x71, 0x05,
#endif
// 049, 01, 22050, 04478, 065, 00
0x31, 0x00, 0x01, 0x00, 0x22, 0x56, 0x00, 0x00, 0x7e, 0x11, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x02, 0x00, 0x40, 0x01,
// 002, 01, 08000, 04096, 256, 04
0x02, 0x00, 0x01, 0x00, 0x40, 0x1f, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x20, 0x00, 0xf4, 0x01, 0x07, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x40, 0x00, 0xf0, 0x00, 0x00, 0x00, 0xcc, 0x01, 0x30, 0xff, 0x88, 0x01, 0x18, 0xff,
// 017, 01, 08000, 04055, 256, 04
0x11, 0x00, 0x01, 0x00, 0x40, 0x1f, 0x00, 0x00, 0xd7, 0x0f, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x02, 0x00, 0xf9, 0x01,
#ifndef _WIN64
// 353, 02, 22050, 04005, 186, 16
0x61, 0x01, 0x02, 0x00, 0x22, 0x56, 0x00, 0x00, 0xa5, 0x0f, 0x00, 0x00, 0xba, 0x00, 0x10, 0x00, 0x2f, 0x00, 0x00, 0x04, 0x00, 0x00, 0x01, 0x00, 0xba, 0x00, 0x00, 0x00, 0x46, 0x36, 0x44, 0x43, 0x39, 0x38, 0x33, 0x30, 0x2d, 0x42, 0x43, 0x37, 0x39, 0x2d, 0x31, 0x31, 0x64, 0x32, 0x2d, 0x41, 0x39, 0x44, 0x30, 0x2d, 0x30, 0x30, 0x36, 0x30, 0x39, 0x37, 0x39, 0x32, 0x36, 0x30, 0x33, 0x36, 0x00,
// 085, 02, 16000, 04000, 001, 00
0x55, 0x00, 0x02, 0x00, 0x80, 0x3e, 0x00, 0x00, 0xa0, 0x0f, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x90, 0x00, 0x01, 0x00, 0x71, 0x05,
// 085, 02, 12000, 04000, 001, 00
0x55, 0x00, 0x02, 0x00, 0xe0, 0x2e, 0x00, 0x00, 0xa0, 0x0f, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x01, 0x00, 0x71, 0x05,
// 085, 02, 11025, 04000, 001, 00
0x55, 0x00, 0x02, 0x00, 0x11, 0x2b, 0x00, 0x00, 0xa0, 0x0f, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0xd0, 0x00, 0x01, 0x00, 0x71, 0x05,
// 085, 02, 08000, 04000, 001, 00
0x55, 0x00, 0x02, 0x00, 0x40, 0x1f, 0x00, 0x00, 0xa0, 0x0f, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x20, 0x01, 0x01, 0x00, 0x71, 0x05,
// 085, 01, 22050, 04000, 001, 00
0x55, 0x00, 0x01, 0x00, 0x22, 0x56, 0x00, 0x00, 0xa0, 0x0f, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x68, 0x00, 0x01, 0x00, 0x71, 0x05,
// 085, 01, 16000, 04000, 001, 00
0x55, 0x00, 0x01, 0x00, 0x80, 0x3e, 0x00, 0x00, 0xa0, 0x0f, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x90, 0x00, 0x01, 0x00, 0x71, 0x05,
// 085, 02, 12000, 03000, 001, 00
0x55, 0x00, 0x02, 0x00, 0xe0, 0x2e, 0x00, 0x00, 0xb8, 0x0b, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x90, 0x00, 0x01, 0x00, 0x71, 0x05,
// 085, 02, 11025, 03000, 001, 00
0x55, 0x00, 0x02, 0x00, 0x11, 0x2b, 0x00, 0x00, 0xb8, 0x0b, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x9c, 0x00, 0x01, 0x00, 0x71, 0x05,
// 085, 02, 08000, 03000, 001, 00
0x55, 0x00, 0x02, 0x00, 0x40, 0x1f, 0x00, 0x00, 0xb8, 0x0b, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0xd8, 0x00, 0x01, 0x00, 0x71, 0x05,
// 085, 01, 22050, 03000, 001, 00
0x55, 0x00, 0x01, 0x00, 0x22, 0x56, 0x00, 0x00, 0xb8, 0x0b, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x4e, 0x00, 0x01, 0x00, 0x71, 0x05,
// 085, 01, 16000, 03000, 001, 00
0x55, 0x00, 0x01, 0x00, 0x80, 0x3e, 0x00, 0x00, 0xb8, 0x0b, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x6c, 0x00, 0x01, 0x00, 0x71, 0x05,
// 353, 01, 22050, 02519, 117, 16
0x61, 0x01, 0x01, 0x00, 0x22, 0x56, 0x00, 0x00, 0xd7, 0x09, 0x00, 0x00, 0x75, 0x00, 0x10, 0x00, 0x2f, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 0x46, 0x36, 0x44, 0x43, 0x39, 0x38, 0x33, 0x30, 0x2d, 0x42, 0x43, 0x37, 0x39, 0x2d, 0x31, 0x31, 0x64, 0x32, 0x2d, 0x41, 0x39, 0x44, 0x30, 0x2d, 0x30, 0x30, 0x36, 0x30, 0x39, 0x37, 0x39, 0x32, 0x36, 0x30, 0x33, 0x36, 0x00,
// 353, 02, 22050, 02519, 117, 16
0x61, 0x01, 0x02, 0x00, 0x22, 0x56, 0x00, 0x00, 0xd7, 0x09, 0x00, 0x00, 0x75, 0x00, 0x10, 0x00, 0x2f, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 0x46, 0x36, 0x44, 0x43, 0x39, 0x38, 0x33, 0x30, 0x2d, 0x42, 0x43, 0x37, 0x39, 0x2d, 0x31, 0x31, 0x64, 0x32, 0x2d, 0x41, 0x39, 0x44, 0x30, 0x2d, 0x30, 0x30, 0x36, 0x30, 0x39, 0x37, 0x39, 0x32, 0x36, 0x30, 0x33, 0x36, 0x00,
#if 0
// 115, 01, 08000, 02687, 043, 16
0x73, 0x00, 0x01, 0x00, 0x40, 0x1f, 0x00, 0x00, 0x7f, 0x0a, 0x00, 0x00, 0x2b, 0x00, 0x10, 0x00, 0x00, 0x00,
#endif
// 085, 02, 12000, 02500, 001, 00
0x55, 0x00, 0x02, 0x00, 0xe0, 0x2e, 0x00, 0x00, 0xc4, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x02, 0x00, 0x71, 0x05,
// 085, 02, 11025, 02500, 001, 00
0x55, 0x00, 0x02, 0x00, 0x11, 0x2b, 0x00, 0x00, 0xc4, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x01, 0x02, 0x00, 0x71, 0x05,
// 085, 02, 08000, 02500, 001, 00
0x55, 0x00, 0x02, 0x00, 0x40, 0x1f, 0x00, 0x00, 0xc4, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x68, 0x01, 0x02, 0x00, 0x71, 0x05,
// 085, 01, 16000, 02500, 001, 00
0x55, 0x00, 0x01, 0x00, 0x80, 0x3e, 0x00, 0x00, 0xc4, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0xb4, 0x00, 0x02, 0x00, 0x71, 0x05,
// 085, 01, 12000, 02500, 001, 00
0x55, 0x00, 0x01, 0x00, 0xe0, 0x2e, 0x00, 0x00, 0xc4, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x02, 0x00, 0x71, 0x05,
// 085, 01, 11025, 02500, 001, 00
0x55, 0x00, 0x01, 0x00, 0x11, 0x2b, 0x00, 0x00, 0xc4, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x01, 0x02, 0x00, 0x71, 0x05,
#if 0
// 114, 01, 08000, 02312, 037, 16
0x72, 0x00, 0x01, 0x00, 0x40, 0x1f, 0x00, 0x00, 0x08, 0x09, 0x00, 0x00, 0x25, 0x00, 0x10, 0x00, 0x00, 0x00,
#endif
// 085, 02, 12000, 02250, 001, 00
0x55, 0x00, 0x02, 0x00, 0xe0, 0x2e, 0x00, 0x00, 0xca, 0x08, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0xb0, 0x01, 0x04, 0x00, 0x71, 0x05,
// 085, 02, 11025, 02250, 001, 00
0x55, 0x00, 0x02, 0x00, 0x11, 0x2b, 0x00, 0x00, 0xca, 0x08, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0xd4, 0x01, 0x04, 0x00, 0x71, 0x05,
// 085, 02, 08000, 02250, 001, 00
0x55, 0x00, 0x02, 0x00, 0x40, 0x1f, 0x00, 0x00, 0xca, 0x08, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x88, 0x02, 0x04, 0x00, 0x71, 0x05,
// 085, 01, 16000, 02250, 001, 00
0x55, 0x00, 0x01, 0x00, 0x80, 0x3e, 0x00, 0x00, 0xca, 0x08, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x44, 0x01, 0x04, 0x00, 0x71, 0x05,
// 085, 01, 12000, 02250, 001, 00
0x55, 0x00, 0x01, 0x00, 0xe0, 0x2e, 0x00, 0x00, 0xca, 0x08, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0xb0, 0x01, 0x04, 0x00, 0x71, 0x05,
// 085, 01, 11025, 02250, 001, 00
0x55, 0x00, 0x01, 0x00, 0x11, 0x2b, 0x00, 0x00, 0xca, 0x08, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0xd4, 0x01, 0x04, 0x00, 0x71, 0x05,
#endif
// 049, 01, 11025, 02239, 065, 00
0x31, 0x00, 0x01, 0x00, 0x11, 0x2b, 0x00, 0x00, 0xbf, 0x08, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x02, 0x00, 0x40, 0x01,
#ifndef _WIN64
// 353, 01, 16000, 02000, 064, 16
0x61, 0x01, 0x01, 0x00, 0x80, 0x3e, 0x00, 0x00, 0xd0, 0x07, 0x00, 0x00, 0x40, 0x00, 0x10, 0x00, 0x2f, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x46, 0x36, 0x44, 0x43, 0x39, 0x38, 0x33, 0x30, 0x2d, 0x42, 0x43, 0x37, 0x39, 0x2d, 0x31, 0x31, 0x64, 0x32, 0x2d, 0x41, 0x39, 0x44, 0x30, 0x2d, 0x30, 0x30, 0x36, 0x30, 0x39, 0x37, 0x39, 0x32, 0x36, 0x30, 0x33, 0x36, 0x00,
// 085, 01, 16000, 02000, 001, 00
0x55, 0x00, 0x01, 0x00, 0x80, 0x3e, 0x00, 0x00, 0xd0, 0x07, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x48, 0x00, 0x01, 0x00, 0x71, 0x05,
// 085, 01, 12000, 02000, 001, 00
0x55, 0x00, 0x01, 0x00, 0xe0, 0x2e, 0x00, 0x00, 0xd0, 0x07, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x60, 0x00, 0x01, 0x00, 0x71, 0x05,
// 085, 01, 11025, 02000, 001, 00
0x55, 0x00, 0x01, 0x00, 0x11, 0x2b, 0x00, 0x00, 0xd0, 0x07, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x68, 0x00, 0x01, 0x00, 0x71, 0x05,
// 085, 01, 08000, 02000, 001, 00
0x55, 0x00, 0x01, 0x00, 0x40, 0x1f, 0x00, 0x00, 0xd0, 0x07, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x90, 0x00, 0x01, 0x00, 0x71, 0x05,
#if 0
// 113, 01, 08000, 01850, 037, 16
0x71, 0x00, 0x01, 0x00, 0x40, 0x1f, 0x00, 0x00, 0x3a, 0x07, 0x00, 0x00, 0x25, 0x00, 0x10, 0x00, 0x00, 0x00,
#endif
#endif
// 049, 01, 08000, 01625, 065, 00
0x31, 0x00, 0x01, 0x00, 0x40, 0x1f, 0x00, 0x00, 0x59, 0x06, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x02, 0x00, 0x40, 0x01,
#ifndef _WIN64
// 353, 02, 08000, 01500, 096, 16
0x61, 0x01, 0x02, 0x00, 0x40, 0x1f, 0x00, 0x00, 0xdc, 0x05, 0x00, 0x00, 0x60, 0x00, 0x10, 0x00, 0x2f, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x46, 0x36, 0x44, 0x43, 0x39, 0x38, 0x33, 0x30, 0x2d, 0x42, 0x43, 0x37, 0x39, 0x2d, 0x31, 0x31, 0x64, 0x32, 0x2d, 0x41, 0x39, 0x44, 0x30, 0x2d, 0x30, 0x30, 0x36, 0x30, 0x39, 0x37, 0x39, 0x32, 0x36, 0x30, 0x33, 0x36, 0x00,
// 353, 01, 11025, 01249, 058, 16
0x61, 0x01, 0x01, 0x00, 0x11, 0x2b, 0x00, 0x00, 0xe1, 0x04, 0x00, 0x00, 0x3a, 0x00, 0x10, 0x00, 0x2f, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x3a, 0x00, 0x00, 0x00, 0x46, 0x36, 0x44, 0x43, 0x39, 0x38, 0x33, 0x30, 0x2d, 0x42, 0x43, 0x37, 0x39, 0x2d, 0x31, 0x31, 0x64, 0x32, 0x2d, 0x41, 0x39, 0x44, 0x30, 0x2d, 0x30, 0x30, 0x36, 0x30, 0x39, 0x37, 0x39, 0x32, 0x36, 0x30, 0x33, 0x36, 0x00,
#endif // !_WIN64
// 034, 01, 08000, 01067, 032, 01
0x22, 0x00, 0x01, 0x00, 0x40, 0x1f, 0x00, 0x00, 0x2b, 0x04, 0x00, 0x00, 0x20, 0x00, 0x01, 0x00, 0x20, 0x00, 0x01, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
#ifndef _WIN64
// 353, 01, 11025, 01012, 047, 16
0x61, 0x01, 0x01, 0x00, 0x11, 0x2b, 0x00, 0x00, 0xf4, 0x03, 0x00, 0x00, 0x2f, 0x00, 0x10, 0x00, 0x2f, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x46, 0x36, 0x44, 0x43, 0x39, 0x38, 0x33, 0x30, 0x2d, 0x42, 0x43, 0x37, 0x39, 0x2d, 0x31, 0x31, 0x64, 0x32, 0x2d, 0x41, 0x39, 0x44, 0x30, 0x2d, 0x30, 0x30, 0x36, 0x30, 0x39, 0x37, 0x39, 0x32, 0x36, 0x30, 0x33, 0x36, 0x00,
// 353, 01, 08000, 01000, 064, 16
0x61, 0x01, 0x01, 0x00, 0x40, 0x1f, 0x00, 0x00, 0xe8, 0x03, 0x00, 0x00, 0x40, 0x00, 0x10, 0x00, 0x2f, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x46, 0x36, 0x44, 0x43, 0x39, 0x38, 0x33, 0x30, 0x2d, 0x42, 0x43, 0x37, 0x39, 0x2d, 0x31, 0x31, 0x64, 0x32, 0x2d, 0x41, 0x39, 0x44, 0x30, 0x2d, 0x30, 0x30, 0x36, 0x30, 0x39, 0x37, 0x39, 0x32, 0x36, 0x30, 0x33, 0x36, 0x00,
// 085, 01, 12000, 01000, 001, 00
0x55, 0x00, 0x01, 0x00, 0xe0, 0x2e, 0x00, 0x00, 0xe8, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x30, 0x00, 0x01, 0x00, 0x71, 0x05,
// 085, 01, 11025, 01000, 001, 00
0x55, 0x00, 0x01, 0x00, 0x11, 0x2b, 0x00, 0x00, 0xe8, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x34, 0x00, 0x01, 0x00, 0x71, 0x05,
// 085, 01, 08000, 01000, 001, 00
0x55, 0x00, 0x01, 0x00, 0x40, 0x1f, 0x00, 0x00, 0xe8, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x48, 0x00, 0x01, 0x00, 0x71, 0x05,
// 066, 01, 08000, 00800, 024, 00
0x42, 0x00, 0x01, 0x00, 0x40, 0x1f, 0x00, 0x00, 0x20, 0x03, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x02, 0x00, 0xce, 0x9a, 0x32, 0xf7, 0xa2, 0xae, 0xde, 0xac,
// 353, 01, 08000, 00750, 048, 16
0x61, 0x01, 0x01, 0x00, 0x40, 0x1f, 0x00, 0x00, 0xee, 0x02, 0x00, 0x00, 0x30, 0x00, 0x10, 0x00, 0x2f, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x46, 0x36, 0x44, 0x43, 0x39, 0x38, 0x33, 0x30, 0x2d, 0x42, 0x43, 0x37, 0x39, 0x2d, 0x31, 0x31, 0x64, 0x32, 0x2d, 0x41, 0x39, 0x44, 0x30, 0x2d, 0x30, 0x30, 0x36, 0x30, 0x39, 0x37, 0x39, 0x32, 0x36, 0x30, 0x33, 0x36, 0x00,
// 066, 01, 08000, 00666, 020, 00
0x42, 0x00, 0x01, 0x00, 0x40, 0x1f, 0x00, 0x00, 0x9a, 0x02, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x03, 0x00, 0xce, 0x9a, 0x32, 0xf7, 0xa2, 0xae, 0xde, 0xac,
#if 0
// 112, 01, 08000, 00600, 012, 16
0x70, 0x00, 0x01, 0x00, 0x40, 0x1f, 0x00, 0x00, 0x58, 0x02, 0x00, 0x00, 0x0c, 0x00, 0x10, 0x00, 0x00, 0x00 
#endif
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpclip\sndchan.h ===
/////////////////////////////////////////////////////////////////////
//
//      Module:     sndchan.h
//
//      Purpose:    Server-side audio redirection communication
//                  module
//
//      Copyright(C) Microsoft Corporation 2000
//
//      History:    4-10-2000  vladimis [created]
//
/////////////////////////////////////////////////////////////////////

#ifndef _SNDCHAN_H
#define _SNDCHAN_H

//
//  Defines
//
#undef  ASSERT
#ifdef  DBG
#define TRC     _DebugMessage
#define ASSERT(_x_)     if (!(_x_)) \
                        {  TRC(FATAL, "ASSERT failed, line %d, file %s\n", \
                        __LINE__, __FILE__); DebugBreak(); }
#else   // !DBG
#define TRC
#define ASSERT
#endif  // !DBG

#define TSMALLOC(_x_)   malloc(_x_)
#define TSREALLOC(_p_, _x_) \
                        realloc(_p_, _x_)
#define TSFREE(_p_)     free(_p_)

//
//  Constants
//
extern const CHAR  *ALV;
extern const CHAR  *INF;
extern const CHAR  *WRN;
extern const CHAR  *ERR;
extern const CHAR  *FATAL;

//
//  Trace
//
VOID
_cdecl
_DebugMessage(
    LPCSTR  szLevel,
    LPCSTR  szFormat,
    ...
    );

#endif  // !_SNDCHAN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpclip\sndchan.cpp ===
/////////////////////////////////////////////////////////////////////
//
//      Module:     sndchan.c
//
//      Purpose:    Server-side audio redirection communication
//                  module
//
//      Copyright(C) Microsoft Corporation 2000
//
//      History:    4-10-2000  vladimis [created]
//
/////////////////////////////////////////////////////////////////////

#include    <windef.h>
#include    <winsta.h>
#include    <wtsapi32.h>
#include    <pchannel.h>
#include    <malloc.h>
#include    <stdio.h>
#include    <stdlib.h>
#include    <winsock2.h>

#include    <mmsystem.h>
#include    <mmreg.h>
#include    <msacm.h>
#include    <aclapi.h>
#include    <sha.h>
#include    <rc4.h>

#include    <rdpstrm.h>
//
// Include security headers for RNG functions
//
#define NO_INCLUDE_LICENSING 1
#include    <tssec.h>
#include    "sndchan.h"
#include    "sndknown.h"

#define TSSND_REG_MAXBANDWIDTH_KEY  L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32\\Terminal Server\\RDP"

#define TSSND_REG_MAXBANDWIDTH_VAL  L"MaxBandwidth"
#define TSSND_REG_MINBANDWIDTH_VAL  L"MinBandwidth"
#define TSSND_REG_DISABLEDGRAM_VAL  L"DisableDGram"
#define TSSND_REG_ENABLEMP3_VAL     L"EnableMP3Codec"
#define TSSND_REG_ALLOWCODECS       L"AllowCodecs"
#define TSSND_REG_MAXDGRAM          L"MaxDGram"

#define DEFAULT_RESPONSE_TIMEOUT    5000

#define TSSND_TRAINING_BLOCKSIZE    1024

//
//      --- READ THIS IF YOU ARE ADDING FEATURES ---
//  right now the encryption works only from server to client
//  there's no data send from server to client
//  if you read this in the future and you are planning to add
//  data stream from client to server, PLEASE ENCRYPT IT !!! 
//  use SL_Encrypt function for that
//
#define MIN_ENCRYPT_LEVEL           2

#define STAT_COUNT                  32
#define STAT_COUNT_INIT             (STAT_COUNT - 8)

#define READ_EVENT              0
#define DISCONNECT_EVENT        1
#define RECONNECT_EVENT         2
#define DATAREADY_EVENT         3
#define DGRAM_EVENT             4
#define POWERWAKEUP_EVENT       5
#define POWERSUSPEND_EVENT      6
#define TOTAL_EVENTS            7

#define NEW_CODEC_COVER         90  // minimum percentage a new codec has to cover
                                    // i.e if we are at 7kbps and the new meassurement is
                                    // for 10kbps we are not switching to codec which
                                    // does have more than NEW_CODEC_COVER * 10k / 100 bandwith
                                    // requirement

//
//  Data for enabling private codecs
//  BUGBUG 
//  Legal issue ?!
//
#ifndef G723MAGICWORD1
#define G723MAGICWORD1 0xf7329ace
#endif

#ifndef G723MAGICWORD2
#define G723MAGICWORD2 0xacdeaea2
#endif

#ifndef VOXWARE_KEY
#define VOXWARE_KEY "35243410-F7340C0668-CD78867B74DAD857-AC71429AD8CAFCB5-E4E1A99E7FFD-371"
#endif

#define _RDPSNDWNDCLASS             L"RDPSound window"

#ifdef _WIN32
#include <pshpack1.h>
#else
#ifndef RC_INVOKED
#pragma pack(1)
#endif
#endif

typedef struct msg723waveformat_tag {
    WAVEFORMATEX wfx;
    WORD         wConfigWord;
    DWORD        dwCodeword1;
    DWORD        dwCodeword2;
} MSG723WAVEFORMAT;

typedef struct intelg723waveformat_tag {
    WAVEFORMATEX wfx;
    WORD         wConfigWord;
    DWORD        dwCodeword1;
    DWORD        dwCodeword2;
} INTELG723WAVEFORMAT;

typedef struct tagVOXACM_WAVEFORMATEX 
{
    WAVEFORMATEX    wfx;
    DWORD           dwCodecId;
    DWORD           dwMode;
    char            szKey[72];
} VOXACM_WAVEFORMATEX, *PVOXACM_WAVEFORMATEX, FAR *LPVOXACM_WAVEFORMATEX;

#define WAVE_FORMAT_WMAUDIO2    0x161

#ifdef _WIN32
#include <poppack.h>
#else
#ifndef RC_INVOKED
#pragma pack()
#endif
#endif

typedef struct {
    SNDPROLOG   Prolog;
    UINT        uiPrologReceived;
    PVOID       pBody;
    UINT        uiBodyAllocated;
    UINT        uiBodyReceived;
} SNDMESSAGE, *PSNDMESSAGE;


typedef struct _VCSNDFORMATLIST {
    struct  _VCSNDFORMATLIST    *pNext;
    HACMDRIVERID    hacmDriverId;
    WAVEFORMATEX    Format;
//  additional data for the format
} VCSNDFORMATLIST, *PVCSNDFORMATLIST;

typedef VOID (*PFNCONVERTER)( INT16 *, DWORD, DWORD * );

static HANDLE      g_hVC               = NULL;  // virtual channel handle

BYTE        g_Buffer[CHANNEL_CHUNK_LENGTH];     // receive buffer
UINT        g_uiBytesInBuffer   = 0;            //
UINT        g_uiBufferOffset    = 0;
OVERLAPPED  g_OverlappedRead;                   // overlapped structure

HANDLE      g_hDataReadyEvent   = NULL;         // set by the client apps
HANDLE      g_hStreamIsEmptyEvent = NULL;       // set by this code
HANDLE      g_hStreamMutex      = NULL;         // guard the stream data
HANDLE      g_hStream           = NULL;         // stream handle
HANDLE      g_hDisconnectEvent  = NULL;         // set for this VC
PSNDSTREAM  g_Stream;                           // stream data pointer

BOOL        g_bRunning          = TRUE;         // TRUE if running
BOOL        g_bDeviceOpened     = FALSE;        // TRUE if device opened
BOOL        g_bDisconnected     = FALSE;        // TRUE if disconnected
DWORD       g_dwLineBandwidth   = 0;            // current bandwidth
DWORD       g_dwCodecChangeThreshold = 10;      // how mach the bandwith has to change in order
                                                // to change the codec ( in percents )
                                                // this number changes up to 50%
PSNDFORMATITEM  *g_ppNegotiatedFormats = NULL;  // list of formats
DWORD           g_dwNegotiatedFormats  = 0;     // number of formats
DWORD           g_dwCurrentFormat      = 0;     // current format Id
HACMDRIVERID    g_hacmDriverId  = NULL;         // codec handles
HACMDRIVER      g_hacmDriver    = NULL;
HACMSTREAM      g_hacmStream    = NULL;

PFNCONVERTER    g_pfnConverter  = NULL;         // intermidiate converter

DWORD       g_dwDataRemain = 0;
BYTE        g_pCnvPrevData[ TSSND_BLOCKSIZE ];

PVCSNDFORMATLIST g_pAllCodecsFormatList = NULL; // all available codecs
DWORD            g_dwAllCodecsNumber = 0;

DWORD   g_dwMaxBandwidth        = (DWORD) -1;   // options
DWORD   g_dwMinBandwidth        = 0;
DWORD   g_dwDisableDGram        = 0;
DWORD   g_dwEnableMP3Codec      = 0;

DWORD   *g_AllowCodecs    = NULL;
DWORD   g_AllowCodecsSize = 0;

DWORD   g_dwStatPing            = 0;            // statistics
DWORD   g_dwStatLatency         = 0;
DWORD   g_dwBlocksOnTheNet      = TSSND_BLOCKSONTHENET;
DWORD   g_dwStatCount           = STAT_COUNT_INIT;
DWORD   g_dwPacketSize          = 0;


HANDLE      g_hPowerWakeUpEvent = NULL;         // power events
HANDLE      g_hPowerSuspendEvent = NULL;
BOOL        g_bSuspended        = FALSE;
BOOL        g_bDeviceFailed     = FALSE;

//
//  datagram control
//
SOCKET  g_hDGramSocket = INVALID_SOCKET;
DWORD   g_dwDGramPort = 0;
DWORD   g_dwDGramSize = 1460;   // number good which is ok for LAN
u_long  g_ulDGramAddress = 0;
DWORD   g_EncryptionLevel = 3;
DWORD   g_wClientVersion = 0;
DWORD   g_HiBlockNo = 0;
BYTE    g_EncryptKey[RANDOM_KEY_LENGTH + 4];

WSABUF  g_wsabuf;
BYTE    g_pDGramRecvData[128];

WSAOVERLAPPED g_WSAOverlapped;

const CHAR  *ALV =   "TSSNDD::ALV - ";
const CHAR  *INF =   "TSSNDD::INF - ";
const CHAR  *WRN =   "TSSNDD::WRN - ";
const CHAR  *ERR =   "TSSNDD::ERR - ";
const CHAR  *FATAL = "TSSNDD::FATAL - ";

static  HANDLE      g_hThread = NULL;

//
//  internal functions
//

BOOL
ChannelBlockWrite(
    PVOID   pBlock,
    ULONG   ulBlockSize
    );

BOOL
VCSndAcquireStream(
    VOID
    );

BOOL
VCSndReleaseStream(
    VOID
    );

BOOL
_VCSndOpenConverter(
    VOID
    );

VOID
_VCSndCloseConverter(
    VOID
    );

VOID
_VCSndOrderFormatList(
    PVCSNDFORMATLIST    *ppFormatList,
    DWORD               *pdwNum
    );

DWORD
_VCSndChooseProperFormat(
    DWORD   dwBandwidth
    );

BOOL
_VCSndGetACMDriverId( 
    PSNDFORMATITEM pSndFmt 
    );

VOID
DGramRead(
    HANDLE hDGramEvent,
    PVOID  *ppBuff,
    DWORD  *pdwRecvd
    );

VOID
DGramReadComplete(
    PVOID  *ppBuff,
    DWORD  *pdwRecvd
    );

#if !( TSSND_NATIVE_SAMPLERATE - 22050 )
//
// converters
// convert to the native format
//
#define CONVERTFROMNATIVETOMONO(_speed_) \
VOID \
_Convert##_speed_##Mono( \
    INT16  *pSrc, \
    DWORD dwSrcSize, \
    DWORD *pdwDstSize ) \
{ \
    DWORD dwDstSize; \
    DWORD i; \
    DWORD dwLeap; \
    INT16 *pDest = pSrc; \
\
    ASSERT( TSSND_NATIVE_SAMPLERATE >= _speed_ ); \
    ASSERT( TSSND_NATIVE_CHANNELS  == 2 ); \
\
    dwDstSize = dwSrcSize * _speed_ / \
                ( TSSND_NATIVE_BLOCKALIGN * TSSND_NATIVE_SAMPLERATE ); \
\
    for (i = 0, dwLeap = 0; \
         i < dwDstSize; \
         i ++) \
    { \
        INT sum; \
\
        sum = pSrc[0] + pSrc[1]; \
\
        if (sum > 0x7FFF) \
            sum = 0x7FFF; \
        if (sum < -0x8000) \
            sum = -0x8000; \
\
        pDest[0] = (INT16)sum; \
        pDest ++; \
\
        dwLeap += 2 * TSSND_NATIVE_SAMPLERATE; \
        pSrc += dwLeap / _speed_; \
        dwLeap %= _speed_; \
    } \
\
    *pdwDstSize = dwDstSize * 2; \
}

#define CONVERTFROMNATIVETOSTEREO(_speed_) \
VOID \
_Convert##_speed_##Stereo( \
    INT16 *pSrc, \
    DWORD dwSrcSize, \
    DWORD *pdwDstSize ) \
{ \
    DWORD dwDstSize; \
    DWORD i; \
    DWORD dwLeap; \
    INT16  *pDest = pSrc; \
\
    ASSERT( TSSND_NATIVE_SAMPLERATE >= _speed_ ); \
\
    dwDstSize = dwSrcSize * _speed_ / \
                ( TSSND_NATIVE_BLOCKALIGN * TSSND_NATIVE_SAMPLERATE ); \
    for (i = 0, dwLeap = 0; \
         i < dwDstSize; \
         i ++) \
    { \
        INT sum; \
\
        pDest[0] = pSrc[0]; \
        pDest ++; \
        pDest[0] = pSrc[1]; \
        pDest ++; \
\
        dwLeap += 2 * TSSND_NATIVE_SAMPLERATE; \
        pSrc += dwLeap / _speed_; \
        dwLeap %= _speed_; \
    } \
\
    *pdwDstSize = dwDstSize * 4; \
}

VOID
_Convert11025Mono( 
    INT16 *pSrc, 
    DWORD dwSrcSize, 
    DWORD *pdwDstSize )
{
    DWORD dwDstSize;
    INT16  *pDest = pSrc;

    ASSERT( TSSND_NATIVE_SAMPLERATE >= 11025 );

    dwDstSize = dwSrcSize / ( TSSND_NATIVE_BLOCKALIGN * 2 );

    *pdwDstSize = 2 * dwDstSize;

    for (; dwDstSize; dwDstSize --)
    {
        INT sum = pSrc[0] + pSrc[1];

        if (sum > 0x7FFF)
            sum = 0x7FFF;
        if (sum < -0x8000)
            sum = -0x8000;

        pDest[0] = (INT16)sum;
        pDest ++;

        pSrc += 4;
    }
}

VOID
_Convert22050Mono( 
    INT16 *pSrc, 
    DWORD dwSrcSize, 
    DWORD *pdwDstSize )
{
    DWORD dwDstSize;
    INT16  *pDest = pSrc;

    ASSERT( TSSND_NATIVE_SAMPLERATE >= 22050 );

    dwDstSize = dwSrcSize / ( TSSND_NATIVE_BLOCKALIGN );

    *pdwDstSize = 2 * dwDstSize;

    for (; dwDstSize; dwDstSize --)
    {
        INT sum = pSrc[0] + pSrc[1];

        if (sum > 0x7FFF)
            sum = 0x7FFF;
        if (sum < -0x8000)
            sum = -0x8000;

        pDest[0] = (INT16)sum;
        pDest ++;

        pSrc += 2;
    }
}

VOID
_Convert11025Stereo( 
    INT16 *pSrc, 
    DWORD dwSrcSize, 
    DWORD *pdwDstSize )
{
    DWORD dwDstSize;
    INT16  *pDest = pSrc;

    ASSERT( TSSND_NATIVE_SAMPLERATE >= 22050 );

    dwDstSize = dwSrcSize / ( TSSND_NATIVE_BLOCKALIGN * 2 );

    *pdwDstSize = 4 * dwDstSize;

    for (; dwDstSize; dwDstSize --)
    {
        pDest[0] = pSrc[0];
        pSrc  ++;
        pDest ++;
        pDest[0] = pSrc[0];
        pDest ++;
        pSrc  ++;

        pSrc += 2;
    }

}

//
// Make the actual code
//
CONVERTFROMNATIVETOMONO( 8000 )
CONVERTFROMNATIVETOMONO( 12000 )
CONVERTFROMNATIVETOMONO( 16000 )

CONVERTFROMNATIVETOSTEREO( 8000 )
CONVERTFROMNATIVETOSTEREO( 12000 )
CONVERTFROMNATIVETOSTEREO( 16000 )

#else
#pragma error
#endif

u_long
inet_addrW(
    LPCWSTR     szAddressW
    ) 
{

    CHAR szAddressA[32];

    *szAddressA = 0;
    WideCharToMultiByte(
        CP_ACP,
        0,
        szAddressW,
        -1,
        szAddressA,
        sizeof(szAddressA),
        NULL, NULL);

    return inet_addr(szAddressA);
}

/*
 *  create signature bits
 */
VOID
SL_Signature(
    PBYTE pSig,
    DWORD dwBlockNo
    )
{
    BYTE  ShaBits[A_SHA_DIGEST_LEN];
    A_SHA_CTX SHACtx;

    ASSERT( A_SHA_DIGEST_LEN > RDPSND_SIGNATURE_SIZE );

    A_SHAInit(&SHACtx);
    *((DWORD *)(g_EncryptKey + RANDOM_KEY_LENGTH)) = dwBlockNo;
    A_SHAUpdate(&SHACtx, (PBYTE)g_EncryptKey, sizeof(g_EncryptKey));
    A_SHAFinal(&SHACtx, ShaBits);
    memcpy( pSig, ShaBits, RDPSND_SIGNATURE_SIZE );
}

/*
 *  signature which verifies the audio bits
 */
VOID
SL_AudioSignature(
    PBYTE pSig,
    DWORD dwBlockNo,
    PBYTE pData,
    DWORD dwDataSize
    )
{
    BYTE ShaBits[A_SHA_DIGEST_LEN];
    A_SHA_CTX SHACtx;

    A_SHAInit(&SHACtx);
    *((DWORD *)(g_EncryptKey + RANDOM_KEY_LENGTH)) = dwBlockNo;
    A_SHAUpdate(&SHACtx, (PBYTE)g_EncryptKey, sizeof(g_EncryptKey));
    A_SHAUpdate(&SHACtx, pData, dwDataSize );
    A_SHAFinal(&SHACtx, ShaBits);
    memcpy( pSig, ShaBits, RDPSND_SIGNATURE_SIZE );
}

/*
 *  encrypt/decrypt a block of data
 *
 */
BOOL
SL_Encrypt( PBYTE pBits, DWORD BlockNo, DWORD dwBitsLen )
{
    BYTE  ShaBits[A_SHA_DIGEST_LEN];
    RC4_KEYSTRUCT rc4key;
    DWORD i;
    PBYTE pbBuffer;
    A_SHA_CTX SHACtx;
    DWORD   dw;
    DWORD_PTR   *pdwBits;

    A_SHAInit(&SHACtx);

    // SHA the bits
    *((DWORD *)(g_EncryptKey + RANDOM_KEY_LENGTH)) = BlockNo;
    A_SHAUpdate(&SHACtx, (PBYTE)g_EncryptKey, sizeof(g_EncryptKey));

    A_SHAFinal(&SHACtx, ShaBits);

    rc4_key(&rc4key, A_SHA_DIGEST_LEN, ShaBits);
    rc4(&rc4key, dwBitsLen, pBits);

    return TRUE;
}

BOOL
SL_SendKey( VOID )
{
    SNDCRYPTKEY Key;

    Key.Prolog.Type = SNDC_CRYPTKEY;
    Key.Prolog.BodySize = sizeof( Key ) - sizeof( Key.Prolog );
    Key.Reserved = 0;
    memcpy( Key.Seed, g_EncryptKey, sizeof( Key.Seed ));
    return ChannelBlockWrite( &Key, sizeof( Key ));
}

/*
 *  Function:
 *      _StatsCollect
 *
 *  Description:
 *      Collects statistics for the line quality
 *
 */
VOID
_StatsCollect(
    DWORD   dwTimeStamp
    )
{
    DWORD dwTimeDiff;

#if _DBG_STATS
    TRC(INF, "_StatsCollect: time now=%x, stamp=%x\n",
                GetTickCount() & 0xffff, 
                dwTimeStamp);
#endif

    dwTimeDiff = (( GetTickCount() & 0xffff ) - dwTimeStamp ) & 0xffff;
    
    //  it is possible to receive time stamp 
    // with time before the packet was sent,
    // this is because the client does adjusments to the time stamp
    // i.e. subtracts the time when the packet was played
    // catch and ignore this case
    //
    if ( dwTimeDiff > 0xf000 )
    {
        dwTimeDiff = 1;
    }

    if ( 0 == dwTimeDiff )
        dwTimeDiff = 1;

    if ( 0 == g_dwStatLatency )
        g_dwStatLatency = dwTimeDiff;
    else {
        //
        //  increase by 30%
        //
        g_dwStatLatency = (( 7 * g_dwStatLatency ) + ( 3 * dwTimeDiff )) / 10;
    }

    g_dwStatCount ++;
}

/*
 *  Function:
 *      _StatsSendPing
 *
 *  Description:
 *      Sends a ping packet to the client
 *
 */
VOID
_StatSendPing(
    VOID
    )
{
//
// send a ping request
//
    SNDTRAINING SndTraining;

    SndTraining.Prolog.Type = SNDC_TRAINING;
    SndTraining.Prolog.BodySize    = sizeof( SndTraining ) - 
                                        sizeof( SndTraining.Prolog );
    SndTraining.wTimeStamp   = (UINT16)GetTickCount();
    SndTraining.wPackSize    = 0;

    if ( INVALID_SOCKET != g_hDGramSocket &&
         0 != g_dwDGramPort &&
         0 != g_ulDGramAddress
        )
    {
        struct sockaddr_in sin;
        INT rc;

        sin.sin_family = PF_INET;
        sin.sin_port  = (u_short)g_dwDGramPort;
        sin.sin_addr.s_addr = g_ulDGramAddress;

        rc = sendto(
                g_hDGramSocket,
                (LPSTR)&SndTraining,
                sizeof( SndTraining ),
                0,
                (struct sockaddr *)&sin,           // to address
                sizeof(sin)
            );

        if (SOCKET_ERROR == rc)
        {
            TRC(ERR, "_StatsSendPing: sendto failed: %d\n",
                    WSAGetLastError());
        }
    } else {
        BOOL bSuccess;

        bSuccess = ChannelBlockWrite( &SndTraining, sizeof( SndTraining ));
        if (!bSuccess)
        {
            TRC(ERR, "_StatSendPing: ChannelBlockWrite failed: %d\n",
                GetLastError());
        }
    }
}

/*
 *  Function:
 *      _StatsCheckResample
 *
 *  Description:
 *      Looks in the statistics and eventually changes the current
 *      codec
 */
BOOL
_StatsCheckResample(
    VOID
    )
{
    BOOL  rv = FALSE;
    DWORD dwNewFmt;
    DWORD dwNewLatency;
    DWORD dwNewBandwidth;
    DWORD dwLatDiff;
    DWORD dwMsPerBlock;
    DWORD dwBlocksOnTheNet;
    DWORD dwCurrBandwith;

    if (( g_dwStatCount % STAT_COUNT ) == STAT_COUNT / 2 )
        _StatSendPing();

    if ( g_dwStatCount < STAT_COUNT )
        goto exitpt;

    if ( g_dwStatPing >= g_dwStatLatency )
        g_dwStatPing = g_dwStatLatency - 1;

    dwNewLatency = ( g_dwStatLatency - g_dwStatPing / 2 );

    if ( 0 == g_dwPacketSize )
    {
        TRC(INF, "_StatsCheckResample: invalid packet size\n");
        goto resetpt;
    }

    dwNewBandwidth = g_dwPacketSize * 1000 / dwNewLatency;

    if ( 0 == dwNewBandwidth )
    {
        TRC(INF, "_StatsCheckResample: invalid bandwidth\n");
        goto resetpt;
    }

    TRC(INF, "_StatsCheckResample: latency=%d, bandwidth=%d\n",
            dwNewLatency, dwNewBandwidth );
    //
    //  g_dwBlocksOnTheNet is the latency in number of blocks
    //
    dwMsPerBlock = TSSND_BLOCKSIZE * 1000 / TSSND_NATIVE_AVGBYTESPERSEC;
    dwBlocksOnTheNet = ((g_dwStatLatency + dwMsPerBlock / 2) / dwMsPerBlock + 2);
    if ( dwBlocksOnTheNet > TSSND_BLOCKSONTHENET )
    {
        g_dwBlocksOnTheNet = TSSND_BLOCKSONTHENET;
    } else {
        g_dwBlocksOnTheNet = dwBlocksOnTheNet;
    }
    TRC( INF, "BlocksOnTheNet=%d\n", g_dwBlocksOnTheNet );

    //
    //  check for at least 10% difference in the bandwidth
    //
    if ( dwNewBandwidth > g_dwMaxBandwidth )
        dwNewBandwidth = g_dwMaxBandwidth;

    if ( dwNewBandwidth < g_dwMinBandwidth )
        dwNewBandwidth = g_dwMinBandwidth;

    dwCurrBandwith = ( NULL != g_ppNegotiatedFormats[ g_dwCurrentFormat ] )?
                        g_ppNegotiatedFormats[ g_dwCurrentFormat ]->nAvgBytesPerSec:
                        g_dwLineBandwidth;

    if ( dwCurrBandwith > dwNewBandwidth )
        dwLatDiff = dwCurrBandwith - dwNewBandwidth;
    else
        dwLatDiff = dwNewBandwidth - dwCurrBandwith;

    if ( dwLatDiff < g_dwCodecChangeThreshold * dwCurrBandwith / 100 )
        goto resetpt;

    //
    //  increment the threshold up to 50%
    //
    if ( g_dwCodecChangeThreshold < 50 )
    {
        g_dwCodecChangeThreshold += 5;
    }
    //
    //  try to choose another format
    //
    dwNewFmt = _VCSndChooseProperFormat( dwNewBandwidth );

    if ( (DWORD)-1 != dwNewFmt &&
         dwNewFmt  != g_dwCurrentFormat )
    {
        INT   step;
        DWORD dwNextFmt;
        //
        //  don't jump directly to the new format, just move
        //  towards it
        //
        step = ( dwNewFmt > g_dwCurrentFormat )?1:-1;
        dwNextFmt = g_dwCurrentFormat + step;
        while( dwNextFmt != dwNewFmt &&
               NULL == g_ppNegotiatedFormats[dwNextFmt] )
        {
            dwNextFmt += step;
        }
        dwNewFmt = dwNextFmt;
    }

    if ( dwNewFmt == (DWORD)-1 ||
         dwNewFmt == g_dwCurrentFormat )
        goto resetpt;

    TRC(INF, "_StatsCheckResample: new bandwidth=%d resampling\n",
            dwNewBandwidth);

    //
    //  resample, NOW
    //
    _VCSndCloseConverter();

    if ( _VCSndGetACMDriverId( g_ppNegotiatedFormats[dwNewFmt] ))
    {

        g_dwLineBandwidth = dwNewBandwidth;
        g_dwCurrentFormat = dwNewFmt;

        g_dwDataRemain = 0;
    }
    _VCSndOpenConverter();

    rv = TRUE;

resetpt:
    g_dwStatLatency  = 0;
    g_dwStatCount    = 0;

exitpt:
    return rv;
}

/*
 *  Function:
 *      _StatReset
 *
 *  Description:
 *      Resets the statistics
 *
 */
VOID
_StatReset(
    VOID
    )
{
    g_dwStatLatency = 0;
    g_dwStatPing    = 0;
    g_dwStatCount   = STAT_COUNT_INIT;
}

/*
 *  Function:
 *      ChannelOpen
 *
 *  Description:
 *      Opens the virtual channel
 *
 *
 */
BOOL
ChannelOpen(
    VOID
    )
{
    BOOL    rv = FALSE;

    
    if (!g_hVC)
        g_hVC = WinStationVirtualOpen(
                    NULL,
                    LOGONID_CURRENT,
                    _SNDVC_NAME
                );

    rv = (g_hVC != NULL);

    return rv;

}

/*
 *  Function:
 *      ChannelClose
 *
 *  Description:
 *      Closes the virtual channel
 */
VOID
ChannelClose(
    VOID
    )
{

    if (g_hVC)
    {
        CloseHandle(g_hVC);
        g_hVC = NULL;
    }

    g_uiBytesInBuffer   = 0;
    g_uiBufferOffset    = 0;
}

/*
 *  Function:
 *      ChannelBlockWrite
 *
 *  Description:
 *      Writes a block thru the virtual channel
 *
 */
BOOL
ChannelBlockWrite(
    PVOID   pBlock,
    ULONG   ulBlockSize
    )
{
    BOOL    bSuccess = TRUE;
    PCHAR   pData = (PCHAR) pBlock;
    ULONG   ulBytesWritten;
    ULONG   ulBytesToWrite = ulBlockSize;
    HANDLE  hVC;

    hVC = g_hVC;
    if (!hVC)
    {
        TRC(ERR, "ChannelBlockWrite: vc handle is NULL\n");
        bSuccess = FALSE;
        goto exitpt;
    }

    while (bSuccess && ulBytesToWrite)
    {
        OVERLAPPED  Overlapped;

        Overlapped.hEvent = NULL;
        Overlapped.Offset = 0;
        Overlapped.OffsetHigh = 0;

        bSuccess = WriteFile(
                        hVC,
                        pData,
                        ulBytesToWrite,
                        &ulBytesWritten,
                        &Overlapped
                    );

        if (!bSuccess && ERROR_IO_PENDING == GetLastError())
            bSuccess = GetOverlappedResult(
                                    hVC,
                                    &Overlapped,
                                    &ulBytesWritten,
                                    TRUE);

        if (bSuccess)
        {
            TRC(ALV, "VirtualChannelWrite: Wrote %d bytes\n",
                     ulBytesWritten);
            ulBytesToWrite -= ulBytesWritten;
            pData       += ulBytesWritten;
        } else {
            TRC(ERR, "VirtualChannelWrite failed, GetLastError=%d\n",
                     GetLastError());
        }
    }

exitpt:

    return bSuccess;
}

/*
 *  Function:
 *      ChannelMessageWrite
 *
 *  Description:
 *      Writes a two pieces message as a single one (uses ChannelBlockWrite)
 *
 */
BOOL
ChannelMessageWrite(
    PVOID   pProlog,
    ULONG   ulPrologSize,
    PVOID   pBody,
    ULONG   ulBodySize
    )
{
    BOOL rv = FALSE;

    if ( 0 != ulBodySize )
    {
        //
        //  create a new prolog message
        //  in which a UINT32 word is added at the end
        //  this word is the same as the first word of the prolog
        //  the client is aware of this and will reconstruct
        //  to the correct messages
        //
        PVOID pNewProlog;


        __try {
            pNewProlog = alloca( ulPrologSize + sizeof(UINT32) );
        } __except((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
                    EXCEPTION_EXECUTE_HANDLER :
                    EXCEPTION_CONTINUE_SEARCH)

        {
            _resetstkoflw();
            pNewProlog = NULL;
        }

        if ( NULL == pNewProlog )
        {
            TRC(ERR, "ChannelMessageWrite: alloca failed for %d bytes\n",
                ulPrologSize + sizeof(UINT32) );
            goto exitpt;
        }

        memcpy(pNewProlog, pProlog, ulPrologSize);

        // replace the word, put SNDC_NONE in the body
        //
        ASSERT( ulBodySize >= sizeof(UINT32));

        *(DWORD *)(((LPSTR)pNewProlog) + ulPrologSize) =
                *(DWORD *)pBody;
        *(DWORD *)pBody = SNDC_NONE;

        pProlog = pNewProlog;
        ulPrologSize += sizeof(UINT32);
    }

    rv = ChannelBlockWrite(
            pProlog,
            ulPrologSize
        );
    
    if (!rv)
    {
        TRC(ERR, "ChannelMessageWrite: failed while sending the prolog\n");
        goto exitpt;
    }

    rv = ChannelBlockWrite(
            pBody,
            ulBodySize
        );

    if (!rv)
    {
        TRC(ERR, "ChannelMessageWrite: failed while sending the body\n");
    }
exitpt:

    return rv;
}

/*
 *  Function:
 *      ChannelBlockRead
 *
 *  Description:
 *      Read a block, as much as possible
 *
 */
BOOL
ChannelBlockRead(
    PVOID   pBlock,
    ULONG   ulBlockSize,
    ULONG   *pulBytesRead,
    ULONG   ulTimeout,
    HANDLE  hEvent
    )
{
    BOOL    bSuccess = FALSE;
    PCHAR   pData = (PCHAR) pBlock;
    ULONG   ulBytesRead = 0;
    HANDLE  hVC;

    hVC = g_hVC;

    if (NULL == hVC)
    {
        TRC(ERR, "ChannelBlockRead: vc handle is invalid(NULL)\n");
        goto exitpt;
    }

    if (NULL == pulBytesRead)
    {
        TRC(ERR, "ChannelBlockRead: pulBytesRead is NULL\n");
        goto exitpt;
    }

    if (!g_uiBytesInBuffer)
    {

        g_OverlappedRead.hEvent = hEvent;
        g_OverlappedRead.Offset = 0;
        g_OverlappedRead.OffsetHigh = 0;

        bSuccess = ReadFile(
                        hVC,
                        g_Buffer,
                        sizeof(g_Buffer),
                        (LPDWORD) &g_uiBytesInBuffer,
                        &g_OverlappedRead
                    );
                        
        if (ERROR_IO_PENDING == GetLastError())
        {
            bSuccess = FALSE;
            goto exitpt;
        }

        if (!bSuccess)
        {

            TRC(ERR, "VirtualChannelRead failed, "
                     "GetLastError=%d\n", 
                     GetLastError());
            g_uiBytesInBuffer = 0;
        } else {

            TRC(ALV, "VirtualChannelRead: read %d bytes\n", 
                     g_uiBytesInBuffer);


            SetLastError(ERROR_SUCCESS);
        }
    }

    if (g_uiBytesInBuffer)
    {
        ulBytesRead = (g_uiBytesInBuffer < ulBlockSize)
                        ?   g_uiBytesInBuffer :   ulBlockSize;

        memcpy(pData, g_Buffer + g_uiBufferOffset, ulBytesRead);
        g_uiBufferOffset += ulBytesRead;
        g_uiBytesInBuffer -= ulBytesRead;

        bSuccess = TRUE;
    }

    // if the buffer is completed, zero the offset
    //
    if (0 == g_uiBytesInBuffer)
        g_uiBufferOffset = 0;

    TRC(ALV, "ChannelBlockRead: block size %d was read\n", ulBlockSize);

exitpt:
    if (NULL != pulBytesRead)
        *pulBytesRead = ulBytesRead;

    return bSuccess;
}

/*
 *  Function:
 *      ChannelBlockReadComplete
 *
 *  Description:
 *      Read completion
 *
 */
BOOL
ChannelBlockReadComplete(
    VOID
    )
{
    BOOL bSuccess = FALSE;

    if (!g_hVC)
    {
        TRC(ERR, "ChannelBlockReadComplete: vc handle is invalid(NULL)\n");
        goto exitpt;
    }

    
    bSuccess = GetOverlappedResult(
            g_hVC, 
            &g_OverlappedRead, 
            (LPDWORD) &g_uiBytesInBuffer,
            FALSE
    );

    if (bSuccess)
    {
        TRC(ALV, "VirtualChannelRead: read %d bytes\n",
            g_uiBytesInBuffer);
        ;
    } else {
        TRC(ERR, "GetOverlappedResult failed, "
            "GetLastError=%d\n",
            GetLastError());
    }

exitpt:
    return bSuccess;
}

/*
 *  Function:
 *      ChannelCancelIo
 *
 *  Description:
 *      Cancel the current IO
 *
 */
BOOL
ChannelCancelIo(
    VOID
    )
{
    BOOL rv = FALSE;

    if (!g_hVC)
    {
        TRC(ERR, "ChannelCancelIo: vc handle is invalid(NULL)\n");
        goto exitpt;
    }

    rv = CancelIo(g_hVC);
    if (rv)
        SetLastError(ERROR_IO_INCOMPLETE);

exitpt:
    return rv;
}

/*
 *  Function:
 *      ChannelReceiveMessage
 *
 *  Description:
 *      Attempts to read two piece message,
 *      returns TRUE if the whole message is received
 *
 */
BOOL
ChannelReceiveMessage(
    PSNDMESSAGE pSndMessage, 
    HANDLE hReadEvent
    )
{
    BOOL    rv = FALSE;
    HANDLE  hVC = g_hVC;
    UINT    uiBytesReceived = 0;

    ASSERT( NULL != pSndMessage );
    ASSERT( NULL != hReadEvent );

    if (NULL == hVC)
    {
        TRC(ERR, "ChannelReceiveMessage: VC is NULL\n");
        goto exitpt;
    }

    //
    //  loop until PENDING or message is received
    //
    do {
        if (pSndMessage->uiPrologReceived < sizeof(pSndMessage->Prolog))
        {
            if (ChannelBlockRead(
                    ((LPSTR)(&pSndMessage->Prolog)) + 
                        pSndMessage->uiPrologReceived,
                    sizeof(pSndMessage->Prolog) - 
                        pSndMessage->uiPrologReceived,
                    (ULONG*) &uiBytesReceived,
                    DEFAULT_VC_TIMEOUT,
                    hReadEvent
                    ))
            {
                pSndMessage->uiPrologReceived += uiBytesReceived;
            }
            else
            {
                if (ERROR_IO_PENDING != GetLastError())
                {
            //  Perform cleanup
            //
                   pSndMessage->uiPrologReceived = 0;
                }
                goto exitpt;
            }
        }

        //  Reallocate a new body if needed
        //
        if (pSndMessage->uiBodyAllocated < pSndMessage->Prolog.BodySize)
        {
            PVOID pBody;

            pBody = (NULL == pSndMessage->pBody)?
                    TSMALLOC(pSndMessage->Prolog.BodySize):
                    TSREALLOC(pSndMessage->pBody, 
                              pSndMessage->Prolog.BodySize);

            if ( NULL == pBody  && NULL != pSndMessage->pBody )
            {
                TSFREE( pSndMessage->pBody );
            }
            pSndMessage->pBody = pBody;

            if (!pSndMessage->pBody)
            {
                TRC(ERR, "ChannelMessageRead: can't allocate %d bytes\n",
                        pSndMessage->Prolog.BodySize);
                pSndMessage->uiBodyAllocated = 0;
                goto exitpt;
            } else
                pSndMessage->uiBodyAllocated = pSndMessage->Prolog.BodySize;
        }

        //  Receive the body
        //
        if (pSndMessage->uiBodyReceived < pSndMessage->Prolog.BodySize)
        {
            if (ChannelBlockRead(
                ((LPSTR)(pSndMessage->pBody)) + pSndMessage->uiBodyReceived,
                pSndMessage->Prolog.BodySize - pSndMessage->uiBodyReceived,
                (ULONG*) &uiBytesReceived,
                DEFAULT_VC_TIMEOUT,
                hReadEvent
                ))
            {
                pSndMessage->uiBodyReceived += uiBytesReceived;
            }
            else
            {
                if (ERROR_IO_PENDING != GetLastError())
                {
                //  Perform cleanup
                //
                    pSndMessage->uiPrologReceived = 0;
                    pSndMessage->uiBodyReceived = 0;
                }
                goto exitpt;
            }
        }

        // check if the message is received
        //
    } while (pSndMessage->uiBodyReceived != pSndMessage->Prolog.BodySize);

    rv = TRUE;

exitpt:
    return rv;
}

/*
 *  Function:
 *      VCSndDataArrived
 *
 *  Description:
 *      Arrived message demultiplexer
 *
 */
VOID
VCSndDataArrived(
    PSNDMESSAGE pSndMessage
    )
{
    if (pSndMessage->Prolog.BodySize &&
        NULL == pSndMessage->pBody)
    {
        TRC(ERR, "_VCSndDataArrived: pBody is NULL\n");
        goto exitpt;
    }

    // first, get the stream
    //
    if (!VCSndAcquireStream())
        {
            TRC(FATAL, "VCSndDataArrived: somebody is holding the "
                       "Stream mutext for too long\n");
            ASSERT(0);
            goto exitpt;
        }

    switch (pSndMessage->Prolog.Type)
    {

    case SNDC_WAVECONFIRM:
    {
        PSNDWAVECONFIRM pSndConfirm;

        if ( pSndMessage->Prolog.BodySize <
             sizeof( *pSndConfirm ) - sizeof( SNDPROLOG ))
        {
            TRC( ERR, "VCSndDataArrived: Invalid confirmation received\n" );
            break;
        }

        pSndConfirm = (PSNDWAVECONFIRM)
                        (((LPSTR)pSndMessage->pBody) - 
                            sizeof(pSndMessage->Prolog));

        _StatsCollect( pSndConfirm->wTimeStamp );

        TRC(ALV, "VCSndDataArrived: SNDC_WAVECONFIRM, block no %d\n",
                pSndConfirm->cConfirmedBlockNo);

        if ( (BYTE)(g_Stream->cLastBlockSent -
                pSndConfirm->cConfirmedBlockNo) > TSSND_BLOCKSONTHENET )
        {
            TRC(WRN, "VCSndDataArrived: confirmation for block #%d "
                     "which wasn't sent. Last sent=%d. DROPPING !!!\n",
                    pSndConfirm->cConfirmedBlockNo,
                    g_Stream->cLastBlockSent);
            break;
        }

        if ( (BYTE)(pSndConfirm->cConfirmedBlockNo -
                g_Stream->cLastBlockConfirmed) < TSSND_BLOCKSONTHENET )
        {

            // move the mark
            //
            g_Stream->cLastBlockConfirmed = pSndConfirm->cConfirmedBlockNo + 1;
        } else {
            TRC(WRN, "VCSndDataArrived: difference in confirmed blocks "
                    "last=%d, this one=%d\n",
                    g_Stream->cLastBlockConfirmed,
                    pSndConfirm->cConfirmedBlockNo
                    );
        }

        PulseEvent(g_hStreamIsEmptyEvent);
    }
    break;

    case SNDC_TRAINING:
    {
        PSNDTRAINING pSndTraining;
        DWORD        dwLatency;

        if ( pSndMessage->Prolog.BodySize < 
                sizeof ( *pSndTraining ) - sizeof ( pSndTraining->Prolog ))
        {
            TRC(ERR, "VCSndDataArrived: SNDC_TRAINING invalid length "
                     "for the body=%d\n",
                    pSndMessage->Prolog.BodySize );
            break;
        }

        pSndTraining = (PSNDTRAINING)
                        (((LPSTR)pSndMessage->pBody) -
                            sizeof(pSndMessage->Prolog));

        if ( 0 != pSndTraining->wPackSize )
        {
            TRC(INF, "VCSndDataArrived: SNDC_TRAINING received (ignoring)\n");
            //
            //  these type of messages are handled
            //  in _VCSndLineVCTraining(), bail out
            //
            break;
        }
        dwLatency = (GetTickCount() & 0xffff) - pSndTraining->wTimeStamp;

        TRC(INF, "VCSndDataArrived: SNDC_TRAINING Latency=%d\n",
            dwLatency );

        //
        //  increase by 30%
        //
        if ( 0 == g_dwStatPing )
            g_dwStatPing = dwLatency;
        else
            g_dwStatPing = (( 7 * g_dwStatPing ) + ( 3 * dwLatency )) / 10;
    }
    break;

    case SNDC_FORMATS:
        //
        //  this is handled in VCSndNegotiateWaveFormat()
        //
        TRC(INF, "VCSndDataArrived: SNDC_FORMATS reveived (ignoring)\n");
    break;

    default:
        {
            TRC(ERR, "_VCSndDataArrived: unknow message received: %d\n",
                pSndMessage->Prolog.Type);
            ASSERT(0);
        }
    }

    VCSndReleaseStream();

exitpt:
    ;
}

/*
 *  Function:
 *      VCSndAcquireStream
 *
 *  Description:
 *      Locks the stream
 *
 */
BOOL
VCSndAcquireStream(
    VOID
    )
{
    BOOL    rv = FALSE;
    DWORD   dwres;

    if (NULL == g_hStream ||
        NULL == g_Stream)
    {
        TRC(FATAL, "VCSndAcquireStream: the stream handle is NULL\n");
        goto exitpt;
    }

    if (NULL == g_hStreamMutex)
    {
        TRC(FATAL, "VCSndAcquireStream: the stream mutex is NULL\n");
        goto exitpt;
    }

    dwres = WaitForSingleObject(g_hStreamMutex, DEFAULT_VC_TIMEOUT);
    if (WAIT_TIMEOUT == dwres ||
         WAIT_ABANDONED == dwres )
    {
        TRC(ERR, "VCSndAcquireStream: "
                 "timed out waiting for the stream mutex or owner crashed=%d\n", dwres );
        //
        // possible app crash
        //
        ASSERT(0);
        goto exitpt;
    }

    rv = TRUE;

exitpt:
    return rv;
}

/*
 *  Function:
 *      VCSndReleaseStream
 *
 *  Description:
 *      Release the stream data
 *
 */
BOOL
VCSndReleaseStream(
    VOID
    )
{
    BOOL rv = TRUE;

    ASSERT(NULL != g_hStream);
    ASSERT(NULL != g_Stream);
    ASSERT(NULL != g_hStreamMutex);

    if (!ReleaseMutex(g_hStreamMutex))
        rv = FALSE;

    return rv;
}

/*
 *  Function:
 *      _DGramOpen
 *
 *  Description:
 *      Opens a datagram socket
 *
 */
VOID
_DGramOpen(
    VOID
    )
{
    // create a datagram socket if needed
    //
    if (INVALID_SOCKET == g_hDGramSocket)
    {
        g_hDGramSocket = socket(AF_INET, SOCK_DGRAM, 0);

        if (INVALID_SOCKET == g_hDGramSocket)
            TRC(ERR, "_DGramOpen: failed to crate dgram socket: %d\n",
                WSAGetLastError());
        else
            TRC(ALV, "_DGramOpen: datagram socket created\n");
    }

    // get the max datagram size
    //
    if (INVALID_SOCKET != g_hDGramSocket)
    {
        UINT optval = 0;
        UINT optlen = sizeof(optval);

        getsockopt(g_hDGramSocket, 
                   SOL_SOCKET,
                   SO_MAX_MSG_SIZE,
                   (LPSTR)(&optval),
                   (int *) &optlen);

        TRC(ALV, "_DGramOpen: max allowed datagram: %d\n",
                optval);

        optval = (optval < TSSND_BLOCKSIZE)?optval:TSSND_BLOCKSIZE;

        // align the dgram to DWORD
        //
        optval /= sizeof(DWORD);
        optval *= sizeof(DWORD);

        if ( optval < RDPSND_MIN_FRAG_SIZE )
        {
            g_dwDGramSize = 0;
        } else if ( optval < g_dwDGramSize )
        {
            g_dwDGramSize = optval;
            TRC( INF, "DGram size downgraded to %d\n", g_dwDGramSize );
        }

        TRC(ALV, "_DGramOpen: max datagram size: %d\n",
                optval);

        // get client's ip address
        //
        {
            WINSTATIONCLIENT ClientData;
            ULONG            ulReturnLength;
            BOOL             rc;
            u_long           ulDGramClientAddress;

            rc = WinStationQueryInformation(
                        SERVERNAME_CURRENT,
                        LOGONID_CURRENT,
                        WinStationClient,
                        &ClientData,
                        sizeof(ClientData),
                        &ulReturnLength);
            if (rc)
            {
                g_EncryptionLevel = ClientData.EncryptionLevel;
                if (PF_INET == ClientData.ClientAddressFamily)
                {
                    TRC(ALV, "_VCSndSendOpenDevice: client address is: %S\n",
                            ClientData.ClientAddress);

                    ulDGramClientAddress = inet_addrW(ClientData.ClientAddress);
                    if (INADDR_NONE != ulDGramClientAddress)
                        g_ulDGramAddress = ulDGramClientAddress;
                    else
                        TRC(ERR, "_VCSndSendOpenDevice: client address is NONE\n");
                }
                else
                    TRC(ERR, "_VCSndSendOpenDevice: "
                             "Invalid address family: %d\n",
                                ClientData.ClientAddressFamily);

            } else
                TRC(ERR, "_VCSndSendOpenDevice: "
                         "WinStationQueryInformation failed. %d\n",
                        GetLastError());
        }
    }

}

VOID
_FillWithGarbage(
    PVOID   pBuff,
    DWORD   dwSize
    )
{
    PBYTE pbBuff = (PBYTE)pBuff;

    for ( ; dwSize; pbBuff++, dwSize-- )
    {
        pbBuff[0] = (BYTE)rand();
    }
}

/*
 *  Function:
 *      _VCSndReadRegistry
 *
 *  Description:
 *      Reads current options
 */
VOID
_VCSndReadRegistry(
    VOID
    )
{
    DWORD rv = (DWORD) -1;
    DWORD sysrc;
    HKEY  hkey = NULL;
    DWORD dwKeyType;
    DWORD dwKeyLen;
    WINSTATIONCONFIG config;
    ULONG Length = 0;
    DWORD dw;

    sysrc = RegOpenKeyEx(  HKEY_LOCAL_MACHINE,
                           TSSND_REG_MAXBANDWIDTH_KEY,
                           0,       // reserved
                           KEY_READ,
                           &hkey);

    if ( ERROR_SUCCESS != sysrc )
    {
        TRC(WRN, "_VCSndReadRegistry: "
                 "RegOpenKeyEx failed: %d\n", 
                sysrc );
        goto exitpt;
    }

    dwKeyType = REG_DWORD;
    dwKeyLen  = sizeof( rv );
    sysrc = RegQueryValueEx( hkey,
                             TSSND_REG_MAXBANDWIDTH_VAL,
                             NULL,      // reserved
                             &dwKeyType,
                             (LPBYTE)&rv,
                             &dwKeyLen);

    if ( ERROR_SUCCESS != sysrc )
    {
        TRC(WRN, "_VCSndReadRegistry: "
                 "RegQueryValueEx failed: %d\n",
                    sysrc );
    } else {
        g_dwMaxBandwidth = rv;
    }

    sysrc = RegQueryValueEx( hkey,
                             TSSND_REG_MINBANDWIDTH_VAL,
                             NULL,      // reserved
                             &dwKeyType,
                             (LPBYTE)&rv,
                             &dwKeyLen);

    if ( ERROR_SUCCESS != sysrc )
    {
        TRC(ALV, "_VCSndReadRegistry: "
                 "RegQueryValueEx failed: %d\n",
                    sysrc );
    } else {
        g_dwMinBandwidth = rv;
    }

    sysrc = RegQueryValueEx( hkey,
                             TSSND_REG_DISABLEDGRAM_VAL,
                             NULL,      // reserved
                             &dwKeyType,
                             (LPBYTE)&rv,
                             &dwKeyLen);

    if ( ERROR_SUCCESS != sysrc )
    {
        TRC(ALV, "_VCSndReadRegistry: "
                 "RegQueryValueEx failed: %d\n",
                    sysrc );
    } else {
        g_dwDisableDGram = rv;
    }

    sysrc = RegQueryValueEx( hkey,
                             TSSND_REG_ENABLEMP3_VAL,
                             NULL,      // reserved
                             &dwKeyType,
                             (LPBYTE)&rv,
                             &dwKeyLen);

    if ( ERROR_SUCCESS != sysrc )
    {
        TRC(WRN, "_VCSndReadRegistry: "
                 "RegQueryValueEx failed: %d\n",
                    sysrc );
    } else {
        g_dwEnableMP3Codec = rv;
    }

    sysrc = RegQueryValueEx( hkey,
                             TSSND_REG_MAXDGRAM,
                             NULL,
                             &dwKeyType,
                             (LPBYTE)&rv,
                             &dwKeyLen );
    if ( ERROR_SUCCESS != sysrc )
    {
        TRC( WRN, "_VCSndReadRegistry: "
                  "RegQueryValueEx failed for \"%s\": %d\n",
                    TSSND_REG_MAXDGRAM, sysrc );
    } else {
        if ( rv < g_dwDGramSize && rv >= RDPSND_MIN_FRAG_SIZE )
        {
            g_dwDGramSize = rv;
            TRC( INF, "DGram size forced to %d\n", g_dwDGramSize );
        }
    }

    dwKeyLen  = 0;
    sysrc = RegQueryValueEx( hkey,
                             TSSND_REG_ALLOWCODECS,
                             NULL,
                             &dwKeyType,
                             NULL,
                             &dwKeyLen );
    if ( ERROR_MORE_DATA != sysrc || REG_BINARY != dwKeyType )
    {
        TRC( ALV, "_VCSndReadRegistry: "
                  "RegQueryValueEx failed for AllowCodecs: %d\n",
                  sysrc );
    } else {
        if ( NULL != g_AllowCodecs )
            TSFREE( g_AllowCodecs );
        g_AllowCodecs = (DWORD *)TSMALLOC( dwKeyLen );
        if ( NULL == g_AllowCodecs )
        {
            TRC( WRN, "_VCSndReadRegistry: "
                      "malloc failed for %d bytes\n",
                      dwKeyLen );
        } else {
            sysrc = RegQueryValueEx( hkey,
                                     TSSND_REG_ALLOWCODECS,
                                     NULL,
                                     &dwKeyType,
                                     (LPBYTE)g_AllowCodecs,
                                     &dwKeyLen );
            if ( ERROR_SUCCESS != sysrc )
            {
                TRC( WRN, "_VCSndReadRegistry: "
                          "RegQueryValueEx failed: %d\n",
                          sysrc );
                TSFREE( g_AllowCodecs );
                g_AllowCodecs = NULL;
                g_AllowCodecsSize = 0;
            } else {
                g_AllowCodecsSize = dwKeyLen;
            }
        }
    }

exitpt:
    if ( NULL != hkey )
        RegCloseKey( hkey );

}

/*
 *  Function:
 *      _VCSndLineVCTraining
 *
 *  Description:
 *      Meassures the line speed thru the virtual channel
 *
 */
DWORD
_VCSndLineVCTraining(
    HANDLE  hReadEvent
    )
{
    PSNDTRAINING        pSndTraining;
    SNDMESSAGE          SndMessage;
    DWORD               dwSuggestedBaudRate;
    DWORD               dwLatency;
    PSNDTRAINING        pSndTrainingResp;


    memset(&SndMessage, 0, sizeof(SndMessage));

    dwLatency = 0;

    if (NULL == hReadEvent)
    {
        TRC(ERR, "_VCSndLineVCTraining: hReadEvent is NULL\n");
        goto exitpt;
    }

    __try
    {
        pSndTraining = (PSNDTRAINING) alloca( TSSND_TRAINING_BLOCKSIZE );
    } __except((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
                    EXCEPTION_EXECUTE_HANDLER :
                    EXCEPTION_CONTINUE_SEARCH)
    {
        _resetstkoflw();
        pSndTraining = NULL;
    }

    if (NULL == pSndTraining)
    {
        TRC(ERR, "_VCSndLineVCTraining: can't alloca %d bytes\n",
            TSSND_TRAINING_BLOCKSIZE);
        goto exitpt;
    }

    _FillWithGarbage( pSndTraining, TSSND_TRAINING_BLOCKSIZE);
    pSndTraining->Prolog.Type = SNDC_TRAINING;
    pSndTraining->Prolog.BodySize = TSSND_TRAINING_BLOCKSIZE -
                                    sizeof (pSndTraining->Prolog);

    pSndTraining->wTimeStamp = (UINT16)GetTickCount();
    pSndTraining->wPackSize  = (UINT16)TSSND_TRAINING_BLOCKSIZE;

    //
    //  send the packet
    //
    if (!ChannelBlockWrite(pSndTraining, TSSND_TRAINING_BLOCKSIZE))
    {
        TRC(ERR, "_VCSndLineVCTraining: failed to send a block: %d\n",
                GetLastError());
        goto exitpt;
    }

    //
    // wait for response to arrive
    //
    do {
        SndMessage.uiPrologReceived = 0;
        SndMessage.uiBodyReceived = 0;

        while(!ChannelReceiveMessage(&SndMessage, hReadEvent))
        {
            if (ERROR_IO_PENDING == GetLastError())
            {
                DWORD dwres;
                HANDLE ahEvents[2];

                ahEvents[0] = hReadEvent;
                ahEvents[1] = g_hDisconnectEvent;
                dwres = WaitForMultipleObjects( 
                            sizeof(ahEvents)/sizeof(ahEvents[0]), // count
                            ahEvents,                             // events
                            FALSE,                                // wait all
                            DEFAULT_RESPONSE_TIMEOUT);

                if (WAIT_TIMEOUT == dwres ||
                    WAIT_OBJECT_0 + 1 == dwres)
                {
                    TRC(WRN, "_VCSndLineVCTraining: timeout "
                             "waiting for response\n");
                    ChannelCancelIo();
                    ResetEvent(hReadEvent);
                    goto exitpt;
                }

                ChannelBlockReadComplete();
                ResetEvent(hReadEvent);
            } else
            if (ERROR_SUCCESS != GetLastError())
            {
                TRC(ERR, "_VCSndLineVCTraining: "
                         "ChannelReceiveMessage failed: %d\n",
                    GetLastError());
                goto exitpt;
            }
        }
    } while ( SNDC_TRAINING != SndMessage.Prolog.Type ||
              sizeof(SNDTRAINING) - sizeof(SNDPROLOG) <
              SndMessage.Prolog.BodySize);

    TRC(ALV, "_VCSndLineVCTraining: response received\n");

    pSndTrainingResp = (PSNDTRAINING)
                    (((LPSTR)SndMessage.pBody) -
                        sizeof(SndMessage.Prolog));

    //
    // calculate latency (nonzero)
    //
    dwLatency = ((WORD)GetTickCount()) - pSndTrainingResp->wTimeStamp + 1;

exitpt:

    TRC(INF, "_VCSndLineVCTraining: dwLatency = %d\n",
                dwLatency);

    if (0 != dwLatency)
    {
        //
        // the latency is in miliseconds, so compute it bytes per seconds
        // and get nonzero result
        //
        dwSuggestedBaudRate = 1 + (1000 * ( pSndTrainingResp->wPackSize +
                                        sizeof( *pSndTraining ))
                                  / dwLatency);
    }
    else
        dwSuggestedBaudRate = 0;

    TRC(INF, "_VCSndLineVCTraining: dwSuggestedBaudRate = %d\n",
                dwSuggestedBaudRate);

    if (NULL != SndMessage.pBody)
        TSFREE(SndMessage.pBody);

    return dwSuggestedBaudRate;
}

/*
 *  Function:
 *      _VCSndLineDGramTraining
 *
 *  Description:
 *      Meassures the line speed thru UDP channel
 *
 */
DWORD
_VCSndLineDGramTraining(
    HANDLE  hDGramEvent
    )
{
    PSNDTRAINING        pSndTraining;
    PSNDTRAINING        pSndTrainingResp;
    struct sockaddr_in  sin;
    DWORD               dwRetries;
    DWORD               dwSuggestedBaudRate;
    DWORD               dwDGramLatency = 0;
    INT                 sendres;
    DWORD               dwPackSize;
    DWORD               dwRespSize;

    dwDGramLatency = 0;

    if (NULL == hDGramEvent)
    {
        TRC(ERR, "_VCSndLineDGramTraining: hDGramEvent is NULL\n");
        goto exitpt;
    }

    if (INVALID_SOCKET == g_hDGramSocket ||
        0 == g_dwDGramPort ||
        g_dwDGramSize < sizeof(*pSndTraining) ||
        0 == g_ulDGramAddress)
    {
        TRC(ERR, "_VCSndLineDGramTraining: no dgram support. Can't train the line\n");
        goto exitpt;
    }

    dwPackSize = ( g_dwDGramSize < TSSND_TRAINING_BLOCKSIZE )?
                    g_dwDGramSize:
                    TSSND_TRAINING_BLOCKSIZE;
    __try 
    {
        pSndTraining = (PSNDTRAINING) alloca( dwPackSize );
    } __except((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
                    EXCEPTION_EXECUTE_HANDLER :
                    EXCEPTION_CONTINUE_SEARCH)
    {
        _resetstkoflw();
        pSndTraining = NULL;
    }

    if (NULL == pSndTraining)
    {
        TRC(ERR, "_VCSndLineDGramTraining: can't alloca %d bytes\n",
            dwPackSize);
        goto exitpt;
    }

    _FillWithGarbage( pSndTraining, dwPackSize );

    //
    //  send a block and measure the time when it will arrive
    //

    // prepare the to address
    //
    sin.sin_family = PF_INET;
    sin.sin_port = (u_short)g_dwDGramPort;
    sin.sin_addr.s_addr = g_ulDGramAddress;

    pSndTraining->Prolog.Type = SNDC_TRAINING;
    pSndTraining->Prolog.BodySize = (UINT16)( dwPackSize -
                                        sizeof (pSndTraining->Prolog));
    pSndTraining->wPackSize  = (UINT16)TSSND_TRAINING_BLOCKSIZE;

    dwRetries = 2 * DEFAULT_RESPONSE_TIMEOUT / 1000;
    do {

        pSndTraining->wTimeStamp = (WORD)GetTickCount();

        //
        //  send the datagram
        //  the type is SNDC_WAVE but the structure is of SNDWAVE
        //  wTimeStamp contains the sending time
        //
        sendres = sendto(
                     g_hDGramSocket,
                     (LPSTR)pSndTraining,
                     dwPackSize,
                     0,                                 // flags
                     (struct sockaddr *)&sin,           // to address
                     sizeof(sin)
                );

        if (SOCKET_ERROR == sendres)
        {
            TRC(ERR, "_VCSndLineDGramTraining: sendto failed: %d\n",
                    WSAGetLastError());
            goto exitpt;
        }

        //
        //  wait for a response
        //
        do {
            pSndTrainingResp = NULL;
            dwRespSize       = 0;

            DGramRead( hDGramEvent, (PVOID*) &pSndTrainingResp, &dwRespSize );

            if ( NULL == pSndTrainingResp )
            {
                DWORD dwres;
                HANDLE ahEvents[2];

                ahEvents[0] = hDGramEvent;
                ahEvents[1] = g_hDisconnectEvent;
                dwres = WaitForMultipleObjects(
                        sizeof(ahEvents)/sizeof(ahEvents[0]), // count
                        ahEvents,                             // events
                        FALSE,                                // wait all
                        1000);


                if ( WAIT_OBJECT_0 + 1 == dwres )
                {
                    TRC(WRN, "_VCSndLineDGramTraining: disconnected\n");
                    goto exitpt;
                }

                if (WAIT_TIMEOUT == dwres)
                {
                    TRC(WRN, "_VCSndLineDGramTraining: timeout "
                             "waiting for response\n");
                    goto try_again;
                }

                DGramReadComplete( (PVOID*) &pSndTrainingResp, &dwRespSize );
            }

        } while ( NULL == pSndTrainingResp ||
                  sizeof( *pSndTrainingResp ) != dwRespSize ||
                  SNDC_TRAINING != pSndTrainingResp->Prolog.Type ||
                  sizeof(SNDTRAINING) - sizeof(SNDPROLOG) <
                  pSndTrainingResp->Prolog.BodySize );

        TRC(ALV, "_VCSndLineDGramTraining: response received\n");
        break;

try_again:
        dwRetries --;
    } while (0 != dwRetries);

    if (0 != dwRetries)
    {
        //
        // calculate latency (nonzero)
        //
        dwDGramLatency = ((WORD)GetTickCount()) - 
                        pSndTrainingResp->wTimeStamp + 1;
    }

exitpt:
    TRC(INF, "_VCSndLineDGramTraining: dwDGramLatency = %d\n",
                dwDGramLatency);

    if (0 != dwDGramLatency)
    {
        //
        // the latency is in miliseconds, so compute it bytes per seconds
        // and get nonzero result
        //
        dwSuggestedBaudRate = 1 + (1000 * ( pSndTrainingResp->wPackSize +
                                    sizeof( *pSndTrainingResp ))
                                  / dwDGramLatency);
    }
    else
        dwSuggestedBaudRate = 0;

    TRC(INF, "_VCSndLineDGramTraining: dwSuggestedBaudRate = %d\n",
                dwSuggestedBaudRate);


    return dwSuggestedBaudRate;
}

//
//  puts code licensing codes into the header
//
BOOL
_VCSndFixHeader(
    PWAVEFORMATEX   pFmt
    )
{
    BOOL rv = FALSE;

    switch (pFmt->wFormatTag)
    {
        case WAVE_FORMAT_MSG723:
            ASSERT(pFmt->cbSize == 10);
            if ( pFmt->cbSize == 10 )
            {
                ((MSG723WAVEFORMAT *) pFmt)->dwCodeword1 = G723MAGICWORD1;
                ((MSG723WAVEFORMAT *) pFmt)->dwCodeword2 = G723MAGICWORD2;

                rv = TRUE;
            }
            break;

        case WAVE_FORMAT_MSRT24:
            //
            // assume call control will take care of the other
            // params ?
            //
            ASSERT(pFmt->cbSize == sizeof( VOXACM_WAVEFORMATEX ) - sizeof( WAVEFORMATEX ) );
            if ( sizeof( VOXACM_WAVEFORMATEX ) - sizeof( WAVEFORMATEX ) == pFmt->cbSize )
            {
                VOXACM_WAVEFORMATEX *pVOX = (VOXACM_WAVEFORMATEX *)pFmt;

                ASSERT( strlen( VOXWARE_KEY ) + 1 == sizeof( pVOX->szKey ));
                strncpy( pVOX->szKey, VOXWARE_KEY, sizeof( pVOX->szKey ));

                rv = TRUE;
            }
            break;

        // this format eats too much from the CPU
        //
        case WAVE_FORMAT_MPEGLAYER3:
            if ( g_dwEnableMP3Codec )
                rv = TRUE;
            break;

        case WAVE_FORMAT_WMAUDIO2:
            if ( g_dwEnableMP3Codec )
            {
                rv = TRUE;
            }
            break;

        default:
            rv = TRUE;
    }

    return rv;
}

/*
 *  Function:
 *      _VCSndFindSuggestedConverter
 *
 *  Description:
 *      Searches for intermidiate converter
 *
 */
BOOL
_VCSndFindSuggestedConverter(
    HACMDRIVERID    hadid,
    LPWAVEFORMATEX  pDestFormat,
    LPWAVEFORMATEX  pInterrimFmt,
    PFNCONVERTER    *ppfnConverter
    )
{
    BOOL            rv = FALSE;
    MMRESULT        mmres;
    HACMDRIVER      hacmDriver = NULL;
    PFNCONVERTER    pfnConverter = NULL;
    HACMSTREAM      hacmStream = NULL;

    ASSERT( NULL != pDestFormat );
    ASSERT( NULL != hadid );
    ASSERT( NULL != pInterrimFmt );

    *ppfnConverter = NULL;
    //
    //  first, open the destination acm driver
    //
    mmres = acmDriverOpen(&hacmDriver, hadid, 0);
    if ( MMSYSERR_NOERROR != mmres )
    {
        TRC(ERR, "_VCSndFindSuggestedConverter: can't "
                 "open the acm driver: %d\n",
                mmres);
        goto exitpt;
    }

    //
    //  first probe with the native format
    //  if it passes, we don't need intermidiate
    //  format converter
    //

    pInterrimFmt->wFormatTag         = WAVE_FORMAT_PCM;
    pInterrimFmt->nChannels          = TSSND_NATIVE_CHANNELS;
    pInterrimFmt->nSamplesPerSec     = TSSND_NATIVE_SAMPLERATE;
    pInterrimFmt->nAvgBytesPerSec    = TSSND_NATIVE_AVGBYTESPERSEC;
    pInterrimFmt->nBlockAlign        = TSSND_NATIVE_BLOCKALIGN;
    pInterrimFmt->wBitsPerSample     = TSSND_NATIVE_BITSPERSAMPLE;
    pInterrimFmt->cbSize             = 0;

    mmres = acmStreamOpen(
                &hacmStream,
                hacmDriver,
                pInterrimFmt,
                pDestFormat,
                NULL,           // filter
                0,              // callback
                0,              // dwinstance
                ACM_STREAMOPENF_NONREALTIME
            );

    if ( MMSYSERR_NOERROR == mmres )
    {
    //
    // format is supported
    //
        rv = TRUE;
        goto exitpt;
    } else {
        TRC(ALV, "_VCSndFindSuggestedConverter: format is not supported\n");
    }

    //
    //  find a suggested intermidiate PCM format
    //
    mmres = acmFormatSuggest(
                    hacmDriver,
                    pDestFormat,
                    pInterrimFmt,
                    sizeof( *pInterrimFmt ),
                    ACM_FORMATSUGGESTF_WFORMATTAG 
            );

    if ( MMSYSERR_NOERROR != mmres )
    {
        TRC(ALV, "_VCSndFindSuggestedConverter: can't find "
                 "interrim format: %d\n",
            mmres);
        goto exitpt;
    }

    if ( 16 != pInterrimFmt->wBitsPerSample ||
         ( 1 != pInterrimFmt->nChannels &&
           2 != pInterrimFmt->nChannels) ||
         ( 8000 != pInterrimFmt->nSamplesPerSec &&
           11025 != pInterrimFmt->nSamplesPerSec &&
           12000 != pInterrimFmt->nSamplesPerSec &&
           16000 != pInterrimFmt->nSamplesPerSec &&
           22050 != pInterrimFmt->nSamplesPerSec)
        )
    {
        TRC(ALV, "_VCSndFindSuggestedConverter: not supported "
                 "interrim format. Details:\n");
        TRC(ALV, "Channels - %d\n",         pInterrimFmt->nChannels);
        TRC(ALV, "SamplesPerSec - %d\n",    pInterrimFmt->nSamplesPerSec);
        TRC(ALV, "AvgBytesPerSec - %d\n",   pInterrimFmt->nAvgBytesPerSec);
        TRC(ALV, "BlockAlign - %d\n",       pInterrimFmt->nBlockAlign);
        TRC(ALV, "BitsPerSample - %d\n",    pInterrimFmt->wBitsPerSample);
        goto exitpt;
    }

    if ( 1 == pInterrimFmt->nChannels )
    {
        switch ( pInterrimFmt->nSamplesPerSec )
        {
        case  8000: pfnConverter = _Convert8000Mono; break;
        case 11025: pfnConverter = _Convert11025Mono; break;
        case 12000: pfnConverter = _Convert12000Mono; break;
        case 16000: pfnConverter = _Convert16000Mono; break;
        case 22050: pfnConverter = _Convert22050Mono; break;
        default:
            ASSERT( 0 );
        }
    } else {
        switch ( pInterrimFmt->nSamplesPerSec )
        {
        case  8000: pfnConverter = _Convert8000Stereo;  break;
        case 11025: pfnConverter = _Convert11025Stereo; break;
        case 12000: pfnConverter = _Convert12000Stereo; break;
        case 16000: pfnConverter = _Convert16000Stereo; break;
        case 22050: pfnConverter = NULL;                break;
        default:
            ASSERT( 0 );
        }
    }

    //
    //  probe with this format
    //
    mmres = acmStreamOpen(
                &hacmStream,
                hacmDriver,
                pInterrimFmt,
                pDestFormat,
                NULL,           // filter
                0,              // callback
                0,              // dwinstance
                ACM_STREAMOPENF_NONREALTIME
            );

    if ( MMSYSERR_NOERROR != mmres )
    {
        TRC(ALV, "_VCSndFindSuggestedConverter: probing the suggested "
                 "format failed: %d\n",
            mmres);
        goto exitpt;
    }

    TRC(ALV, "_VCSndFindSuggestedConverter: found intermidiate PCM format\n");
    TRC(ALV, "Channels - %d\n",         pInterrimFmt->nChannels);
    TRC(ALV, "SamplesPerSec - %d\n",    pInterrimFmt->nSamplesPerSec);
    TRC(ALV, "AvgBytesPerSec - %d\n",   pInterrimFmt->nAvgBytesPerSec);
    TRC(ALV, "BlockAlign - %d\n",       pInterrimFmt->nBlockAlign);
    TRC(ALV, "BitsPerSample - %d\n",    pInterrimFmt->wBitsPerSample);

    rv = TRUE;

exitpt:
    if ( NULL != hacmStream )
        acmStreamClose( hacmStream, 0 );

    if ( NULL != hacmDriver )
        acmDriverClose( hacmDriver, 0 );

    *ppfnConverter = pfnConverter;

    return rv;
}

/*
 *  Function:
 *      VCSndEnumAllCodecFormats
 *
 *  Description:
 *      Creates a list of all codecs/formats
 *
 */
BOOL
VCSndEnumAllCodecFormats(
    PVCSNDFORMATLIST *ppFormatList,
    DWORD            *pdwNumberOfFormats
    )
{
    BOOL             rv = FALSE;
    PVCSNDFORMATLIST pIter;
    PVCSNDFORMATLIST pPrev;
    PVCSNDFORMATLIST pNext;
    MMRESULT         mmres;
    DWORD            dwNum = 0;
    UINT             count, codecsize;

    ASSERT( ppFormatList );
    ASSERT( pdwNumberOfFormats );

    *ppFormatList = NULL;

    //
    //  convert the known format list to a linked list
    //
    for ( count = 0, codecsize = 0; count < sizeof( KnownFormats ); count += codecsize )
    {
        PWAVEFORMATEX pSndFmt = (PWAVEFORMATEX)(KnownFormats + count);
        codecsize = sizeof( WAVEFORMATEX ) + pSndFmt->cbSize;

        //
        //  skip mp3s if disabled
        //
        if (( WAVE_FORMAT_MPEGLAYER3 == pSndFmt->wFormatTag ||
              WAVE_FORMAT_WMAUDIO2 == pSndFmt->wFormatTag ) &&
             !g_dwEnableMP3Codec )
        {
            continue;
        }

        UINT entrysize = sizeof( VCSNDFORMATLIST ) + pSndFmt->cbSize;
        PVCSNDFORMATLIST pNewEntry;

        pNewEntry = (PVCSNDFORMATLIST) TSMALLOC( entrysize );
        if ( NULL != pNewEntry )
        {
            memcpy( &pNewEntry->Format, pSndFmt, codecsize );
            pNewEntry->hacmDriverId = NULL;
            pNewEntry->pNext = *ppFormatList;
            *ppFormatList = pNewEntry;
        }
    }

    //
    //  additional codecs
    //  these are codecs not included initially, it reads them from the registry
    //  see AllowCodecs initialization
    //
    for ( count = 0, codecsize = 0; count < g_AllowCodecsSize ; count += codecsize )
    {
        PWAVEFORMATEX pSndFmt = (PWAVEFORMATEX)(((PBYTE)g_AllowCodecs) + count);
        codecsize = sizeof( WAVEFORMATEX ) + pSndFmt->cbSize;

        if ( codecsize + count > g_AllowCodecsSize )
        {
            TRC( ERR, "Invalid size of additional codec\n" );
            break;
        }

        //
        //  skip mp3s if disabled
        //
        if (( WAVE_FORMAT_MPEGLAYER3 == pSndFmt->wFormatTag ||
              WAVE_FORMAT_WMAUDIO2 == pSndFmt->wFormatTag ) &&
             !g_dwEnableMP3Codec )
        {
            continue;
        }

        UINT entrysize = sizeof( VCSNDFORMATLIST ) + pSndFmt->cbSize;
        PVCSNDFORMATLIST pNewEntry;

        pNewEntry = (PVCSNDFORMATLIST) TSMALLOC( entrysize );
        if ( NULL != pNewEntry )
        {
            memcpy( &pNewEntry->Format, pSndFmt, codecsize );
            pNewEntry->hacmDriverId = NULL;
            pNewEntry->pNext = *ppFormatList;
            *ppFormatList = pNewEntry;
        }
    }

    //
    //  add the native format
    //
    pIter = (PVCSNDFORMATLIST) TSMALLOC( sizeof( *pIter ) );
    if ( NULL != pIter )
    {
        pIter->Format.wFormatTag        = WAVE_FORMAT_PCM;
        pIter->Format.nChannels         = TSSND_NATIVE_CHANNELS;
        pIter->Format.nSamplesPerSec    = TSSND_NATIVE_SAMPLERATE;
        pIter->Format.nAvgBytesPerSec   = TSSND_NATIVE_AVGBYTESPERSEC;
        pIter->Format.nBlockAlign       = TSSND_NATIVE_BLOCKALIGN;
        pIter->Format.wBitsPerSample    = TSSND_NATIVE_BITSPERSAMPLE;
        pIter->Format.cbSize            = 0;
        pIter->hacmDriverId             = NULL;

        pIter->pNext = *ppFormatList;
        *ppFormatList = pIter;
    }

    if (NULL == *ppFormatList)
    {
        TRC(WRN, "VCSndEnumAllCodecFormats: failed to add formats\n");

        goto exitpt;
    }


    _VCSndOrderFormatList( ppFormatList, &dwNum );

    //
    //  number of formats is passed as UINT16, delete all after those
    //
    if ( dwNum > 0xffff )
    {
        DWORD dwLimit = 0xfffe;

        pIter = *ppFormatList;
        while ( 0 != dwLimit )
        {
            pIter = pIter->pNext;
            dwLimit --;
        }

        pNext = pIter->pNext;
        pIter->pNext = NULL;
        pIter = pNext;
        while( NULL != pIter )
        {
            pNext = pIter->pNext;
            TSFREE( pNext );
            pIter = pNext;
        }

        dwNum = 0xffff;
    }

    rv = TRUE;

exitpt:

    if (!rv)
    {
        //
        //  in case of error free the allocated list of formats
        //
        pIter = *ppFormatList;
        while( NULL != pIter )
        {
            PVCSNDFORMATLIST pNext = pIter->pNext;

            TSFREE( pIter );

            pIter = pNext;
        }

        *ppFormatList = NULL;

    }

    *pdwNumberOfFormats = dwNum;

    return rv;
}

BOOL
CALLBACK
acmDriverEnumCallbackGetACM(
    HACMDRIVERID    hadid,
    DWORD_PTR       dwInstance,
    DWORD           fdwSupport
    )
{
    BOOL                rv = TRUE;
    MMRESULT            mmres;

    ASSERT(dwInstance);

    ASSERT( NULL != hadid );

    if ( (0 != ( fdwSupport & ACMDRIVERDETAILS_SUPPORTF_CODEC ) ||
          0 != ( fdwSupport & ACMDRIVERDETAILS_SUPPORTF_CONVERTER )))
    {
    //
    //  a codec found
    //
        ACMFORMATTAGDETAILS fdwDetails;
        PVCSNDFORMATLIST pFmt = (PVCSNDFORMATLIST)dwInstance;

        fdwDetails.cbStruct = sizeof( fdwDetails );
        fdwDetails.fdwSupport = 0;
        fdwDetails.dwFormatTag = pFmt->Format.wFormatTag;

        mmres = acmFormatTagDetails( (HACMDRIVER)hadid, &fdwDetails, ACM_FORMATTAGDETAILSF_FORMATTAG );
        if ( MMSYSERR_NOERROR == mmres )
        {

            WAVEFORMATEX        WaveFormat;     // dummy parameter
            PFNCONVERTER        pfnConverter;   // dummy parameter

            if ( _VCSndFindSuggestedConverter(
                (HACMDRIVERID)hadid,
                &(pFmt->Format),
                &WaveFormat,
                &pfnConverter ))
            {
                pFmt->hacmDriverId = hadid;
                rv = FALSE;
            }
        }
    }

    //
    //  continue to the next driver
    //
    return rv;
}

BOOL
_VCSndGetACMDriverId( PSNDFORMATITEM pSndFmt )
{
    DWORD   rv = FALSE;
    PVCSNDFORMATLIST pIter;
    //
    //  Find the acm format id
    //
    for( pIter = g_pAllCodecsFormatList; NULL != pIter; pIter = pIter->pNext )
    {
        if (pIter->Format.wFormatTag == pSndFmt->wFormatTag &&
            pIter->Format.nChannels  == pSndFmt->nChannels &&
            pIter->Format.nSamplesPerSec == pSndFmt->nSamplesPerSec &&
            pIter->Format.nAvgBytesPerSec == pSndFmt->nAvgBytesPerSec &&
            pIter->Format.nBlockAlign == pSndFmt->nBlockAlign &&
            pIter->Format.wBitsPerSample == pSndFmt->wBitsPerSample &&
            pIter->Format.cbSize == pSndFmt->cbSize &&
            0 == memcmp((&pIter->Format) + 1, pSndFmt + 1, pIter->Format.cbSize))
        {
            //
            //  format is found
            //
            DWORD_PTR dwp = (DWORD_PTR)pIter;
            MMRESULT mmres;

            if ( NULL != pIter->hacmDriverId )
            {
                //  found already
                rv = TRUE;
                break;
            }

            mmres = acmDriverEnum(
                acmDriverEnumCallbackGetACM,
                (DWORD_PTR)dwp,
                0
            );

            if ( MMSYSERR_NOERROR == mmres )
            {
                if ( NULL != pIter->hacmDriverId )
                {

                rv = TRUE;
                } else {
                    ASSERT( 0 );
                }
            }
            break;
        }
    }

    return rv;
}

/*
 *  Function:
 *      _VCSndChooseProperFormat
 *
 *  Description:
 *      Chooses the closest format to a given bandwidth
 *
 */
DWORD
_VCSndChooseProperFormat(
    DWORD dwBandwidth
    )
{
    // choose a format from the list
    // closest to the measured bandwidth
    //
    DWORD           i;
    DWORD           fmt = (DWORD)-1;
    DWORD           lastgood = (DWORD)-1;

    if ( NULL == g_ppNegotiatedFormats )
    {
        TRC(ERR, "_VCSndChooseProperFormat: no negotiated formats\n");
        goto exitpt;
    }

    for( i = 0; i < g_dwNegotiatedFormats; i++ )
    {
        if ( NULL == g_ppNegotiatedFormats[i] )
        {
            continue;
        }
        lastgood = i;
        if ( dwBandwidth != g_dwLineBandwidth )
        {
            //
            //  we are looking for new codec here, make sure we cover at least 90%
            //  of the requested bandwith
            //
            if ( g_ppNegotiatedFormats[i]->nAvgBytesPerSec <= dwBandwidth * NEW_CODEC_COVER / 100 )
            {
                fmt = i;
                break;
            }
        } else if ( g_ppNegotiatedFormats[i]->nAvgBytesPerSec <= dwBandwidth )
        {
            fmt = i;
            break;
        }
    }

    //
    //  get the last format inc case that all format are not
    //  suitable for our bandwidth
    //
    if ( (DWORD)-1 == fmt && 0 != g_dwNegotiatedFormats )
    {
        fmt = lastgood;
    }

    ASSERT( fmt != (DWORD)-1 );

exitpt:
    return fmt;
}

/*
 *  Function:
 *      _VCSndOrderFormatList
 *
 *  Description:
 *      Order all formats in descendant order
 *
 */
VOID
_VCSndOrderFormatList(
    PVCSNDFORMATLIST    *ppFormatList,
    DWORD               *pdwNum
    )
{
    PVCSNDFORMATLIST    pFormatList;
    PVCSNDFORMATLIST    pLessThan;
    PVCSNDFORMATLIST    pPrev;
    PVCSNDFORMATLIST    pNext;
    PVCSNDFORMATLIST    pIter;
    PVCSNDFORMATLIST    pIter2;
    DWORD               dwNum = 0;

    ASSERT ( NULL != ppFormatList );

    pFormatList = *ppFormatList;
    pLessThan   = NULL;

    //
    //  fill both lists
    //
    pIter = pFormatList;
    while ( NULL != pIter )
    {
        pNext = pIter->pNext;
        pIter->pNext = NULL;

        //
        //  descending order
        //
        pIter2 = pLessThan;
        pPrev  = NULL;
        while ( NULL != pIter2 &&
                pIter2->Format.nAvgBytesPerSec >
                    pIter->Format.nAvgBytesPerSec )
        {
            pPrev  = pIter2;
            pIter2 = pIter2->pNext;
        }

        pIter->pNext = pIter2;
        if ( NULL == pPrev )
            pLessThan = pIter;
        else
            pPrev->pNext = pIter;

        pIter = pNext;
        dwNum ++;
    }

    *ppFormatList = pLessThan;

    if ( NULL != pdwNum )
        *pdwNum = dwNum;
}

/*
 *  Function:
 *      _VCSndLineTraining
 *
 *  Description:
 *      Meassures the line bandwidth
 *
 */
BOOL
_VCSndLineTraining(
    HANDLE  hReadEvent,
    HANDLE  hDGramEvent
    )
{
    BOOL rv = FALSE;
    DWORD   dwLineBandwidth = 0;

    _DGramOpen();

    //
    //  test this line while it's hot
    //
    if ( !g_dwDisableDGram )
    {
        dwLineBandwidth = _VCSndLineDGramTraining( hDGramEvent );
    }

    if (0 == dwLineBandwidth || g_dwDisableDGram)
    {
        TRC(WRN, "_VCSndLineTraining: no bandwidth trough UDP\n");
        g_ulDGramAddress = 0;
        g_dwDGramPort    = 0;

        g_EncryptionLevel = 0;
        dwLineBandwidth = _VCSndLineVCTraining( hReadEvent );

        if (0 == dwLineBandwidth)
        {
            TRC(WRN, "_VCSndLineTraining: no bandwidth "
                     "trough VC either. GIVING up\n");
            goto exitpt;
        }
    } else {
        if ( g_wClientVersion == 1 )
             g_EncryptionLevel = 0;
    }

    //
    //  check for encryption
    //
    if ( g_EncryptionLevel >= MIN_ENCRYPT_LEVEL )
    {
        TRC( INF, "Encryption enabled\n" );
        if ( TSRNG_GenerateRandomBits( g_EncryptKey, RANDOM_KEY_LENGTH))
        {
            SL_SendKey();
        } else {
            TRC( ERR, "_VCSndLineTraining: failing to generate random numbers. GIVING up\n" );
            goto exitpt;
        }
    }

    //
    //  check for limitations
    //
    if ((DWORD)-1 != g_dwMaxBandwidth && 
        dwLineBandwidth > g_dwMaxBandwidth )
    {
        dwLineBandwidth = g_dwMaxBandwidth;

        TRC(INF, "Bandwidth limited up to %d\n",
            dwLineBandwidth );
    }

    if ( dwLineBandwidth < g_dwMinBandwidth )
    {
        dwLineBandwidth = g_dwMinBandwidth;
        TRC(INF, "Bandwidth limited to at least %d\n",
            dwLineBandwidth );
    }

    rv = TRUE;

exitpt:

    g_dwLineBandwidth = dwLineBandwidth;

    return rv;
}

/*
 *  Function:
 *      VCSndNegotiateWaveFormat
 *
 *  Description:
 *      Requests the client for a list of supported formats
 *
 */
BOOL
VCSndNegotiateWaveFormat(
    HANDLE  hReadEvent,
    HANDLE  hDGramEvent
    )
{
    BOOL                rv = FALSE;
    PVCSNDFORMATLIST    pIter;
    BOOL                bSuccess;
    PSNDFORMATMSG       pSndFormats;
    PSNDFORMATMSG       pSndResp;
    PSNDFORMATITEM      pSndFmt;
    SNDMESSAGE          SndMessage;
    DWORD               msgsize;
    DWORD               maxsize;
    DWORD               i;
    DWORD               dwNewFmt;
    DWORD               dwSoundCaps = 0;
    DWORD               dwVolume;
    DWORD               dwPitch;
    DWORD               BestChannels;
    DWORD               BestSamplesPerSec;
    DWORD               BestBitsPerSample;
    DWORD               dwPacketSize;
    BOOL                bWMADetected = FALSE;

    //
    // clean the previously negotiated format
    //
    if (NULL != g_ppNegotiatedFormats)
    {
        DWORD i;

        for ( i = 0; i < g_dwNegotiatedFormats; i++ )
        {
            if ( NULL != g_ppNegotiatedFormats[i] )
                TSFREE( g_ppNegotiatedFormats[i] );
        }
        TSFREE( g_ppNegotiatedFormats );
        g_ppNegotiatedFormats = NULL;
        g_dwNegotiatedFormats = 0;
        g_hacmDriverId        = NULL;

    }

    memset( &SndMessage, 0, sizeof( SndMessage ));

    //
    //  get the list of all codec formats
    //
    if ( NULL == g_pAllCodecsFormatList )
    {
        bSuccess = VCSndEnumAllCodecFormats( 
                    &g_pAllCodecsFormatList, 
                    &g_dwAllCodecsNumber 
                    );
        if (!bSuccess)
            goto exitpt;
    }

    //
    //  create a packet huge enough to hold all formats
    //
    msgsize = sizeof( *pSndFormats ) +
              sizeof( SNDFORMATITEM ) * g_dwAllCodecsNumber;
    //
    //  calculate the extra data needed by all format
    //
    for( maxsize = 0, pIter = g_pAllCodecsFormatList; 
         NULL != pIter; 
         pIter = pIter->pNext )
    {
        msgsize += pIter->Format.cbSize;
        if (maxsize < pIter->Format.cbSize)
            maxsize = pIter->Format.cbSize;
    }

    __try {

        pSndFormats = (PSNDFORMATMSG) alloca( msgsize );

    } __except((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
                    EXCEPTION_EXECUTE_HANDLER :
                    EXCEPTION_CONTINUE_SEARCH)
    {
        _resetstkoflw();
        pSndFormats = NULL;

    }

    if ( NULL == pSndFormats )
    {
        TRC(ERR, "VCSndNegotiateWaveFormat: alloca failed for %d bytes\n",
                    msgsize);
        goto exitpt;                
    }

    pSndFormats->Prolog.Type        = SNDC_FORMATS;
    pSndFormats->Prolog.BodySize    = (UINT16)( msgsize - sizeof( pSndFormats->Prolog ));
    pSndFormats->wNumberOfFormats   = (UINT16)g_dwAllCodecsNumber;
    pSndFormats->cLastBlockConfirmed = g_Stream->cLastBlockConfirmed;
    pSndFormats->wVersion           = RDPSND_PROTOCOL_VERSION;

    for ( i = 0, pSndFmt = (PSNDFORMATITEM) (pSndFormats + 1), 
                pIter = g_pAllCodecsFormatList;
          i < g_dwAllCodecsNumber; 
          i++, 
                pSndFmt = (PSNDFORMATITEM)
                    (((LPSTR)pSndFmt) + 
                    sizeof( *pSndFmt ) + pSndFmt->cbSize), 
                pIter = pIter->pNext )
    {
        ASSERT(NULL != pIter);

        pSndFmt->wFormatTag         = pIter->Format.wFormatTag;
        pSndFmt->nChannels          = pIter->Format.nChannels;
        pSndFmt->nSamplesPerSec     = pIter->Format.nSamplesPerSec;
        pSndFmt->nAvgBytesPerSec    = pIter->Format.nAvgBytesPerSec;
        pSndFmt->nBlockAlign        = pIter->Format.nBlockAlign;
        pSndFmt->wBitsPerSample     = pIter->Format.wBitsPerSample;
        pSndFmt->cbSize             = pIter->Format.cbSize;
        //
        //  copy the rest of the format data
        //
        memcpy( pSndFmt + 1, (&pIter->Format) + 1, pSndFmt->cbSize );
    }

    bSuccess = ChannelBlockWrite( pSndFormats, msgsize );
    if (!bSuccess)
    {
        TRC(ERR, "VCSndNegotiateWaveFormat: ChannelBlockWrite failed: %d\n",
                GetLastError());
        goto exitpt;
    }

    do {
    //
    //  Wait for response with a valid message
    //
        SndMessage.uiPrologReceived = 0;
        SndMessage.uiBodyReceived = 0;

        while(!ChannelReceiveMessage(&SndMessage, hReadEvent))
        {

            if (ERROR_IO_PENDING == GetLastError())
            {
                DWORD dwres;
                HANDLE ahEvents[2];

                ahEvents[0] = hReadEvent;
                ahEvents[1] = g_hDisconnectEvent;
                dwres = WaitForMultipleObjects(
                            sizeof(ahEvents)/sizeof(ahEvents[0]), // count
                            ahEvents,                             // events
                            FALSE,                                // wait all
                            DEFAULT_VC_TIMEOUT);

                if (WAIT_TIMEOUT == dwres ||
                    WAIT_OBJECT_0 + 1 == dwres)
                {
                    TRC(WRN, "VCSndNegotiateWaveFormat: timeout "
                             "waiting for response\n");
                    ChannelCancelIo();
                    ResetEvent(hReadEvent);
                    goto exitpt;
                }

                ChannelBlockReadComplete();
                ResetEvent(hReadEvent);
            } else 
            if (ERROR_SUCCESS != GetLastError())
            {
                TRC(ERR, "VCSndNegotiateWaveFormat: "
                         "ChannelReceiveMessage failed: %d\n",
                    GetLastError());
                goto exitpt;
            }
        }

    } while (SNDC_FORMATS != SndMessage.Prolog.Type);

    if (SndMessage.Prolog.BodySize <
        sizeof( SNDFORMATMSG ) - sizeof( SNDPROLOG ))
    {
        TRC(ERR, "VCSndNegotiateWaveFormat: SNDC_FORMAT message "
                "invalid body size: %d\n",
                SndMessage.Prolog.BodySize );
    }

    pSndResp = (PSNDFORMATMSG)
                (((LPSTR)SndMessage.pBody) - sizeof( SNDPROLOG ));
    //  save the capabilities
    //
    dwSoundCaps = pSndResp->dwFlags;
    dwVolume    = pSndResp->dwVolume;
    dwPitch     = pSndResp->dwPitch;
    g_dwDGramPort = pSndResp->wDGramPort;
    g_wClientVersion = pSndResp->wVersion;

    //
    //  Expect at least one format returned
    //
    if (SndMessage.Prolog.BodySize <
        sizeof( SNDFORMATITEM ) + 
        sizeof( SNDFORMATMSG ) - sizeof( SNDPROLOG ))
    {
        TRC(ERR, "VCSndNegotiateWaveFormat: SNDC_FORMAT message "
                 "w/ invalid size (%d). No supported formats\n",
                SndMessage.Prolog.BodySize );
        goto exitpt;
    }

    //
    //  train this line
    //
    if ( 0 != ( dwSoundCaps & TSSNDCAPS_ALIVE ))
    {
        if (!_VCSndLineTraining( hReadEvent, hDGramEvent ))
        {
            TRC( WRN, "VCSndIo: can't talk to the client, go silent\n" );
            dwSoundCaps = 0;
        }
    }

    //
    //  allocate a new list
    //
    g_dwNegotiatedFormats = pSndResp->wNumberOfFormats;

    g_ppNegotiatedFormats = (PSNDFORMATITEM*) TSMALLOC( sizeof( g_ppNegotiatedFormats[0] ) *
                                        g_dwNegotiatedFormats );
    memset( g_ppNegotiatedFormats, 0,
            sizeof( g_ppNegotiatedFormats[0] ) * g_dwNegotiatedFormats );

    if ( NULL == g_ppNegotiatedFormats )
    {
        TRC(ERR, "VCSndNegotiateWaveFormat: can't allocate %d bytes\n",
                sizeof( g_ppNegotiatedFormats[0] ) * g_dwNegotiatedFormats);
        goto exitpt;
    }

    //
    //  allocate space for each entry in the list
    //
    for ( i = 0; i < g_dwNegotiatedFormats; i ++ )
    {
        g_ppNegotiatedFormats[i] = (PSNDFORMATITEM) TSMALLOC( sizeof( **g_ppNegotiatedFormats ) +
                                        maxsize);

        if ( NULL == g_ppNegotiatedFormats[i] )
        {
            TRC(ERR, "VCSndNegotiateWaveFormat: can't allocate %d bytes\n",
                    sizeof( **g_ppNegotiatedFormats ) + maxsize );
            goto exitpt;
        }
    }

    //
    //  Fill in the global list
    //
    pSndFmt = (PSNDFORMATITEM)(pSndResp + 1);
    dwPacketSize = sizeof( SNDPROLOG ) + SndMessage.Prolog.BodySize - sizeof( *pSndResp );

    for( i = 0; i < g_dwNegotiatedFormats; i++)
    {
        DWORD adv = sizeof( *pSndFmt ) + pSndFmt->cbSize;

        if ( adv > dwPacketSize )
        {
            TRC( ERR, "VCSndNegotiateWaveFormat: invalid response packet size\n" );
            ASSERT( 0 );
            goto exitpt;
        }

        if ( pSndFmt->cbSize > maxsize )
        {
            TRC(ERR, "VCSndNegotiateWaveFormat: invalid format size\n" );
            ASSERT( 0 );
            goto exitpt;
        }

        memcpy( g_ppNegotiatedFormats[i], 
                pSndFmt,
                sizeof( *g_ppNegotiatedFormats[0] ) + pSndFmt->cbSize );

        //
        //  advance to the next format
        //
        pSndFmt = (PSNDFORMATITEM)(((LPSTR)pSndFmt) + adv);
        dwPacketSize -= adv;
    }
    ASSERT( 0 == dwPacketSize );

    //
    //  prune the formats
    //  ie, don't allow 8khZ mono codec to be between
    //  22kHz and 11kHz stereo
    //  This is the order of imporatnce: frquency, channels, bits, bytes/s
    //
#if DBG
    TRC( INF, "======== Pruning formats =========. num=%d\n\n", g_dwNegotiatedFormats );
#endif
    BestSamplesPerSec = 0;
    BestChannels      = 0;
    BestBitsPerSample = 0;
    for( i = g_dwNegotiatedFormats; i > 0; i-- )
    {
        PSNDFORMATITEM pDest = g_ppNegotiatedFormats[i - 1];

        if ( WAVE_FORMAT_MPEGLAYER3 == pDest->wFormatTag && bWMADetected )
        {
            goto bad_codec;
        }
        if ( WAVE_FORMAT_WMAUDIO2 == pDest->wFormatTag )
        {
            bWMADetected = TRUE;
        }

        //
        //  a complex check for the order
        //
        if ( BestSamplesPerSec > pDest->nSamplesPerSec )
        {
            goto bad_codec;
        } else if ( BestSamplesPerSec == pDest->nSamplesPerSec )
        {
            if ( BestChannels > pDest->nChannels )
            {
                goto bad_codec;
#if 0
            } else if ( BestChannels == pDest->nChannels )
            {
                if ( BestBitsPerSample > pDest->wBitsPerSample )
                {
                    goto bad_codec;
                }
#endif
            }
        }


        //
        //  good codec, keep it
        //
        BestChannels = pDest->nChannels;
        BestBitsPerSample = pDest->wBitsPerSample;
        BestSamplesPerSec = pDest->nSamplesPerSec;
#if 0
        TRC(INF, "GOOD ag=%d chans=%d rate=%d, bps=%d, bpsamp=%d\n",
            pDest->wFormatTag, pDest->nChannels, pDest->nSamplesPerSec, pDest->nAvgBytesPerSec, pDest->wBitsPerSample
        );
#endif
        continue;

bad_codec:
        //
        //  bad codec, delete
        //
#if 0
        TRC(INF, "BAD ag=%d chans=%d rate=%d, bps=%d, bpsamp=%d\n",
            pDest->wFormatTag, pDest->nChannels, pDest->nSamplesPerSec, pDest->nAvgBytesPerSec, pDest->wBitsPerSample
        );
#endif
        TSFREE( pDest );
        g_ppNegotiatedFormats[i - 1] = NULL;

    }

    //
    //  choose the first format as a default
    //
    dwNewFmt = _VCSndChooseProperFormat( g_dwLineBandwidth );
    if (dwNewFmt != (DWORD) -1)
    {
        //
        //  get a valid driver id
        //
        _VCSndGetACMDriverId( g_ppNegotiatedFormats[ dwNewFmt ] );

        g_dwCurrentFormat = dwNewFmt;
        //
        //  correct the new bandwidth
        //
        g_dwLineBandwidth = g_ppNegotiatedFormats[ dwNewFmt ]->nAvgBytesPerSec;
    }

    //
    //  remember the stream settings
    //
    if ( 0 != dwSoundCaps )
    {
        //
        // set the remote sound caps
        //
        if (VCSndAcquireStream())
        {

            g_Stream->dwSoundCaps = dwSoundCaps;
            g_Stream->dwVolume    = dwVolume;
            g_Stream->dwPitch     = dwPitch;

            VCSndReleaseStream();
        }
    }

    rv = TRUE;

exitpt:

    //  don't forget to free the body of the eventually received message
    //
    if ( NULL != SndMessage.pBody )
        TSFREE( SndMessage.pBody );

    //
    //  in case of error cleanup the negotiated format
    //
    if ( !rv && NULL != g_ppNegotiatedFormats )
    {
        for ( i = 0; i < g_dwNegotiatedFormats; i++ )
        {
            if ( NULL != g_ppNegotiatedFormats[i] )
                TSFREE( g_ppNegotiatedFormats[i] );
        }
        TSFREE( g_ppNegotiatedFormats );
        g_ppNegotiatedFormats = NULL;
        g_dwNegotiatedFormats = 0;
        g_hacmDriverId        = NULL;
    }

    return rv;
}

/*
 *  Function:
 *      _VCSndFindNativeFormat
 *
 *  Description:
 *      returns the ID of the native format ( no codecs available )
 *
 */
DWORD
_VCSndFindNativeFormat(
    VOID
    )
{
    PSNDFORMATITEM pIter;
    DWORD          rv = 0;

    if ( NULL == g_ppNegotiatedFormats )
    {
        TRC(ERR, "_VCSndFindNativeFormat: no format cache\n");
        goto exitpt;
    }

    for( rv  = 0; rv < g_dwNegotiatedFormats; rv++ )
    {
        pIter = g_ppNegotiatedFormats[ rv ];
        if (pIter->wFormatTag == WAVE_FORMAT_PCM &&
            pIter->nChannels  == TSSND_NATIVE_CHANNELS &&
            pIter->nSamplesPerSec == TSSND_NATIVE_SAMPLERATE &&
            pIter->nAvgBytesPerSec == TSSND_NATIVE_AVGBYTESPERSEC &&
            pIter->nBlockAlign == TSSND_NATIVE_BLOCKALIGN &&
            pIter->wBitsPerSample == TSSND_NATIVE_BITSPERSAMPLE &&
            pIter->cbSize == 0)
            //
            //  format is found
            //
            break;
    }

    ASSERT( rv < g_dwNegotiatedFormats );

exitpt:

    return rv;
}

/*
 *  Function:
 *      _VCSndOpenConverter
 *
 *  Description:
 *      Opens a codec
 *
 */
BOOL
_VCSndOpenConverter(
    VOID
    )
{
    BOOL            rv = FALSE;
    MMRESULT        mmres;
    WAVEFORMATEX    NativeFormat;
    PSNDFORMATITEM  pSndFmt;
    PVCSNDFORMATLIST  pIter;
    BOOL            bSucc;

    //
    //  assert that these wasn't opened before
    //
    ASSERT(NULL == g_hacmDriver);
    ASSERT(NULL == g_hacmStream);

    if ( NULL == g_ppNegotiatedFormats )
    {
        TRC(INF, "_VCSndOpenConverter: no acm format specified\n");
        goto exitpt;
    }

    //
    //  Find the acm format id
    //
    pSndFmt = g_ppNegotiatedFormats[ g_dwCurrentFormat ];
    for( pIter = g_pAllCodecsFormatList; NULL != pIter; pIter = pIter->pNext )
    {
        if (pIter->Format.wFormatTag == pSndFmt->wFormatTag &&
            pIter->Format.nChannels  == pSndFmt->nChannels &&
            pIter->Format.nSamplesPerSec == pSndFmt->nSamplesPerSec &&
            pIter->Format.nAvgBytesPerSec == pSndFmt->nAvgBytesPerSec &&
            pIter->Format.nBlockAlign == pSndFmt->nBlockAlign &&
            pIter->Format.wBitsPerSample == pSndFmt->wBitsPerSample &&
            pIter->Format.cbSize == pSndFmt->cbSize &&
            0 == memcmp((&pIter->Format) + 1, pSndFmt + 1, pIter->Format.cbSize)
)
        {
            //
            //  format is found
            //
            g_hacmDriverId = pIter->hacmDriverId;
            break;
        }
    }

    if (NULL == g_hacmDriverId)
    {
        TRC(ERR, "_VCSndOpenConverter: acm driver id was not found\n");
        goto exitpt;
    }

    TRC(INF, "_VCSndOpenConverter: format received is:\n");
    TRC(INF, "FormatTag - %d\n",        pSndFmt->wFormatTag);
    TRC(INF, "Channels - %d\n",         pSndFmt->nChannels);
    TRC(INF, "SamplesPerSec - %d\n",    pSndFmt->nSamplesPerSec);
    TRC(INF, "AvgBytesPerSec - %d\n",   pSndFmt->nAvgBytesPerSec);
    TRC(INF, "BlockAlign - %d\n",       pSndFmt->nBlockAlign);
    TRC(INF, "BitsPerSample - %d\n",    pSndFmt->wBitsPerSample);
    TRC(INF, "cbSize        - %d\n",    pSndFmt->cbSize);
    TRC(INF, "acmFormatId   - %p\n",    g_hacmDriverId);

    mmres = acmDriverOpen(
                    &g_hacmDriver,
                    g_hacmDriverId,
                    0
                );

    if (MMSYSERR_NOERROR != mmres)
    {
        TRC(ERR, "_VCSndOpenConverter: unable to open acm driver: %d\n",
                mmres);
        goto exitpt;
    }

    TRC(ALV, "_VCSndOpenConverter: Driver is open, DriverId = %p\n",
            g_hacmDriverId);

    //
    //  first, find a suggested format for this converter
    //
    pSndFmt = g_ppNegotiatedFormats[ g_dwCurrentFormat ];

    if ( WAVE_FORMAT_PCM == pSndFmt->wFormatTag &&
         TSSND_NATIVE_CHANNELS == pSndFmt->nChannels &&
         TSSND_NATIVE_SAMPLERATE == pSndFmt->nSamplesPerSec &&
         TSSND_NATIVE_AVGBYTESPERSEC == pSndFmt->nAvgBytesPerSec &&
         TSSND_NATIVE_BLOCKALIGN == pSndFmt->nBlockAlign &&
         TSSND_NATIVE_BITSPERSAMPLE == pSndFmt->wBitsPerSample &&
         0 == pSndFmt->cbSize )
    {
        TRC(INF, "_VCSndOpenConverter: opening native format, no converter\n");
        goto exitpt;
    }

    bSucc = _VCSndFindSuggestedConverter(
            g_hacmDriverId,
            (LPWAVEFORMATEX)pSndFmt,
            &NativeFormat,
            &g_pfnConverter);

    if (!bSucc)
    {
        TRC(FATAL, "_VCSndOpenConverter: can't find a suggested format\n");
        goto exitpt;
    }

    TRC(ALV, "_VCSndOpenConverter: SOURCE format is:\n");
    TRC(ALV, "FormatTag - %d\n",        NativeFormat.wFormatTag);
    TRC(ALV, "Channels - %d\n",         NativeFormat.nChannels);
    TRC(ALV, "SamplesPerSec - %d\n",    NativeFormat.nSamplesPerSec);
    TRC(ALV, "AvgBytesPerSec - %d\n",   NativeFormat.nAvgBytesPerSec);
    TRC(ALV, "BlockAlign - %d\n",       NativeFormat.nBlockAlign);
    TRC(ALV, "BitsPerSample - %d\n",    NativeFormat.wBitsPerSample);
    TRC(ALV, "cbSize        - %d\n",    NativeFormat.cbSize);

    TRC(ALV, "_VCSndOpenConverter: DESTINATION format is:\n");
    TRC(ALV, "FormatTag - %d\n",        pSndFmt->wFormatTag);
    TRC(ALV, "Channels - %d\n",         pSndFmt->nChannels);
    TRC(ALV, "SamplesPerSec - %d\n",    pSndFmt->nSamplesPerSec);
    TRC(ALV, "AvgBytesPerSec - %d\n",   pSndFmt->nAvgBytesPerSec);
    TRC(ALV, "BlockAlign - %d\n",       pSndFmt->nBlockAlign);
    TRC(ALV, "BitsPerSample - %d\n",    pSndFmt->wBitsPerSample);
    TRC(ALV, "cbSize        - %d\n",    pSndFmt->cbSize);

    mmres = acmStreamOpen(
                &g_hacmStream,
                g_hacmDriver,
                &NativeFormat,
                (LPWAVEFORMATEX)pSndFmt,
                NULL,       // no filter
                0,          // no callback
                0,          // no callback instance
                ACM_STREAMOPENF_NONREALTIME
            );

    if (MMSYSERR_NOERROR != mmres)
    {
        TRC(ERR, "_VCSndOpenConverter: unable to open acm stream: %d\n",
                mmres);
        goto exitpt;
    }

    g_dwDataRemain = 0;

    rv = TRUE;

exitpt:
    if (!rv)
    {
        _VCSndCloseConverter();
        g_dwCurrentFormat = _VCSndFindNativeFormat();
    }

    return rv;
}

/*
 *  Function:
 *      _VCSndCloseConverter
 *
 *  Description:
 *      Closes the codec
 *
 */
VOID
_VCSndCloseConverter(
    VOID
    )
{
    if (g_hacmStream)
    {
        acmStreamClose( g_hacmStream, 0 );
        g_hacmStream = NULL;
    }

    if (g_hacmDriver)
    {
        acmDriverClose( g_hacmDriver, 0 );
        g_hacmDriver = NULL;
    }
}

/*
 *  Function:
 *      _VCSndConvert
 *
 *  Description:
 *      Convert a block
 *
 */
BOOL
_VCSndConvert( 
    PBYTE   pSrc, 
    DWORD   dwSrcSize, 
    PBYTE   pDest, 
    DWORD   *pdwDestSize )
{
    BOOL            rv = FALSE;
    ACMSTREAMHEADER acmStreamHdr;
    MMRESULT        mmres, mmres2;
    DWORD           dwDestSize = 0;
    DWORD           dwSrcBlockAlign = 0;
    DWORD           dwNewDestSize = 0;

    PBYTE           pbRemDst;
    DWORD           dwRemDstLength;

    ASSERT( NULL != g_hacmStream );
    ASSERT( NULL != pdwDestSize );

    //
    // check if we have interrim converter
    // use it, if so
    //
    if ( NULL != g_pfnConverter )
    {
        DWORD   dwInterrimSize;
        g_pfnConverter( (INT16 *)pSrc, 
                        dwSrcSize, 
                        &dwInterrimSize );
        dwSrcSize = dwInterrimSize;
    }

    //
    //  compute the destination size
    //
    mmres = acmStreamSize(
                g_hacmStream,
                dwSrcSize,
                &dwNewDestSize,
                ACM_STREAMSIZEF_SOURCE
            );
    if ( MMSYSERR_NOERROR != mmres )
    {
        TRC(ERR, "_VCSndConvert: acmStreamSize failed: %d\n",
                    mmres);
        g_dwDataRemain = 0;
        goto go_convert;
    }

    //
    //  align the source to a block of the destination
    //  the remainder put in a buffer for consequentive use
    //
    mmres = acmStreamSize(
                g_hacmStream,
                g_ppNegotiatedFormats[ g_dwCurrentFormat ]->nBlockAlign,
                &dwSrcBlockAlign,
                ACM_STREAMSIZEF_DESTINATION
            );

    if ( MMSYSERR_NOERROR != mmres )
    {

        TRC(ALV, "_VCSndConvert: acmStreamSize failed for dst len: %d\n",
                    mmres);
        g_dwDataRemain = 0;
        goto go_convert;
    }

    dwNewDestSize += g_ppNegotiatedFormats[ g_dwCurrentFormat ]->nBlockAlign;
    if ( dwNewDestSize > *pdwDestSize )
    {
        TRC( FATAL, "_VCSndConvert: dest size(%d) "
                    "bigger than passed buffer(%d)\n",
            dwNewDestSize,
            *pdwDestSize);
        goto exitpt;
    }
    *pdwDestSize = dwNewDestSize;

    if ( dwSrcBlockAlign <= g_dwDataRemain )
        g_dwDataRemain = 0;

go_convert:
    //
    //  prepare the acm stream header
    //
    memset( &acmStreamHdr, 0, sizeof( acmStreamHdr ));
    acmStreamHdr.cbStruct       = sizeof( acmStreamHdr );
    acmStreamHdr.pbDst          = pDest;
    acmStreamHdr.cbDstLength    = *pdwDestSize;

    //
    //  first convert the remainding data from the previous call
    //  add the data needed to complete one block
    //
    if ( 0 != g_dwDataRemain)
    {
        DWORD dwDataToCopy = dwSrcBlockAlign - g_dwDataRemain;

        memcpy( g_pCnvPrevData + g_dwDataRemain, 
                pSrc,
                dwDataToCopy);

        pSrc += dwDataToCopy;

        ASSERT( dwSrcSize > dwDataToCopy );
        dwSrcSize -= dwDataToCopy;

        acmStreamHdr.pbSrc          = g_pCnvPrevData;
        acmStreamHdr.cbSrcLength    = dwSrcBlockAlign;

        mmres = acmStreamPrepareHeader(
                g_hacmStream,
                &acmStreamHdr,
                0
            );
        if ( MMSYSERR_NOERROR != mmres )
        {
            TRC(ERR, "_VCSndConvert: acmStreamPrepareHeader failed: %d\n",
                    mmres);
            goto exitpt;
        }

        mmres = acmStreamConvert(
                g_hacmStream,
                &acmStreamHdr,
                ACM_STREAMCONVERTF_BLOCKALIGN
            );

        mmres2 = acmStreamUnprepareHeader(
                    g_hacmStream,
                    &acmStreamHdr,
                    0
                );

        ASSERT( mmres == MMSYSERR_NOERROR );

        if ( MMSYSERR_NOERROR != mmres )
        {
            TRC(ERR, "_VCSndConvert: acmStreamConvert failed: %d\n",
                    mmres );
        } else {
            dwDestSize += acmStreamHdr.cbDstLengthUsed;

            acmStreamHdr.cbSrcLengthUsed= 0;
            acmStreamHdr.pbDst          += acmStreamHdr.cbDstLengthUsed;
            acmStreamHdr.cbDstLength    -= acmStreamHdr.cbDstLengthUsed;
            acmStreamHdr.cbDstLengthUsed= 0;
        }

    }

    //
    //  if we don't have fully aligned block
    //  skip this conversion, but don't forget to save
    //  this block
    //
    if (dwSrcSize < dwSrcBlockAlign)
    {
        g_dwDataRemain = dwSrcSize;
        memcpy( g_pCnvPrevData, pSrc, g_dwDataRemain );
        rv = TRUE;
        goto exitpt;
    }

    pbRemDst                    = acmStreamHdr.pbDst;
    dwRemDstLength              = acmStreamHdr.cbDstLength;

    acmStreamHdr.pbSrc          = pSrc;
    acmStreamHdr.cbSrcLength    = dwSrcSize;
    acmStreamHdr.fdwStatus      = 0;

    mmres = acmStreamPrepareHeader(
                g_hacmStream,
                &acmStreamHdr,
                0
            );
    if ( MMSYSERR_NOERROR != mmres )
    {
        TRC(ERR, "_VCSndConvert: can't prepare header: %d\n",
                mmres);
        goto exitpt;
    }

    while (acmStreamHdr.cbSrcLength > dwSrcBlockAlign)
    {
        mmres = acmStreamConvert(
                    g_hacmStream,
                    &acmStreamHdr,
                    ACM_STREAMCONVERTF_BLOCKALIGN
                );

        if ( MMSYSERR_NOERROR != mmres )
        {
            TRC(ERR, "_VCSndConvert: acmStreamConvert failed: %d\n",
                    mmres);
            goto exitpt;
        }

        //
        //  advance the buffer positions
        //
        acmStreamHdr.pbSrc          += acmStreamHdr.cbSrcLengthUsed;
        acmStreamHdr.pbDst          += acmStreamHdr.cbDstLengthUsed;
        acmStreamHdr.cbSrcLength    -= acmStreamHdr.cbSrcLengthUsed;
        acmStreamHdr.cbDstLength    -= acmStreamHdr.cbDstLengthUsed;

        dwDestSize += acmStreamHdr.cbDstLengthUsed;

        acmStreamHdr.cbSrcLengthUsed= 0;
        acmStreamHdr.cbDstLengthUsed= 0;

    }

    rv = TRUE;

    //
    //  save the unaligned data
    //
    if ( 0 != dwSrcBlockAlign )
    {
        g_dwDataRemain = acmStreamHdr.cbSrcLength;
        memcpy( g_pCnvPrevData, acmStreamHdr.pbSrc, g_dwDataRemain );
    }

    //
    // restore the header and unprepare
    //
    acmStreamHdr.pbSrc          = pSrc;
    acmStreamHdr.pbDst          = pbRemDst;
    acmStreamHdr.cbSrcLength    = dwSrcSize;
    acmStreamHdr.cbSrcLengthUsed= 0;
    acmStreamHdr.cbDstLength    = dwRemDstLength;
    acmStreamHdr.cbDstLengthUsed= 0;

    mmres = acmStreamUnprepareHeader(
                g_hacmStream,
                &acmStreamHdr,
                0
            );

    ASSERT( mmres == MMSYSERR_NOERROR );

exitpt:

    *pdwDestSize = dwDestSize;

    return rv;    
}

/*
 *  Function:
 *      _VCSndCheckDevice
 *
 *  Description:
 *      Initializes capabilities negotiations with the client
 *
 */
VOID
_VCSndCheckDevice(
    HANDLE  hReadEvent,
    HANDLE  hDGramEvent
    )
{
    SNDPROLOG       Prolog;
    BOOL            bSuccess;

    //
    //  no sound caps yet
    //
    g_Stream->dwSoundCaps = 0;

    //
    //  find the best compression for this audio line
    //
    if ( !VCSndNegotiateWaveFormat( hReadEvent, hDGramEvent ))
    {
        ChannelClose();
    }

}

/*
 *  Function:
 *      _VCSndCloseDevice
 *
 *  Description:
 *      Closes the remote device
 *
 */
VOID
_VCSndCloseDevice(
    VOID
    )
{
    if (!VCSndAcquireStream())
    {
        TRC(FATAL, "_VCSndCloseDevice: Can't acquire stream mutex. exit\n");
        goto exitpt;
    }

    //  disable the local audio
    //
    g_Stream->dwSoundCaps = 0;
    g_bDeviceOpened = FALSE;
    g_dwLineBandwidth = 0;

    VCSndReleaseStream();

exitpt:
    ;
}

/*
 *  Function:
 *      _VCSndSendWave
 *
 *  Description:
 *      Sends a wave data to the client using UDP
 *
 */
BOOL
_VCSndSendWaveDGram(
    BYTE  cBlockNo,
    PVOID pData,
    DWORD dwDataSize
    ) 
{
    BOOL    bSucc = FALSE;
    struct sockaddr_in  sin;
    INT                 sendres;
    PSNDWAVE            pSndWave;


    //
    //  encrypt the packet if necessary
    //
    if ( g_EncryptionLevel >= MIN_ENCRYPT_LEVEL )
         if ( !SL_Encrypt( (PBYTE)pData, ( g_HiBlockNo << 8 ) + cBlockNo, dwDataSize ))
            goto exitpt;

    __try {
        pSndWave = (PSNDWAVE) alloca(g_dwDGramSize);
    } __except((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
                    EXCEPTION_EXECUTE_HANDLER :
                    EXCEPTION_CONTINUE_SEARCH)
    {
        _resetstkoflw();
        pSndWave = NULL;
        TRC(ERR, "_VCSndSendWaveDGram: alloca generate exception: %d\n",
                GetExceptionCode());
    }

    if (NULL == pSndWave)
        goto exitpt;

    pSndWave->Prolog.Type = (g_EncryptionLevel >= MIN_ENCRYPT_LEVEL)?SNDC_WAVEENCRYPT:SNDC_WAVE;
    pSndWave->wFormatNo   = (UINT16)g_dwCurrentFormat;
    pSndWave->wTimeStamp  = (UINT16)GetTickCount();
    pSndWave->dwBlockNo   = (g_HiBlockNo << 8) + cBlockNo;

    // prepare the to address
    //
    sin.sin_family = PF_INET;
    sin.sin_port = (u_short)g_dwDGramPort;
    sin.sin_addr.s_addr = g_ulDGramAddress;

    //  Send the block in chunks of dwDGramSize
    //
    while (dwDataSize)
    {
        DWORD dwWaveDataLen;

        dwWaveDataLen = (dwDataSize + sizeof(*pSndWave)
                            < g_dwDGramSize)
                        ?
                        dwDataSize:
                        g_dwDGramSize - sizeof(*pSndWave);

        pSndWave->Prolog.BodySize = (UINT16)
                                    ( sizeof(*pSndWave) - 
                                    sizeof(pSndWave->Prolog) +
                                    dwWaveDataLen );

        memcpy(pSndWave + 1, pData, dwWaveDataLen);

        sendres = sendto(g_hDGramSocket,
                         (LPSTR)pSndWave,
                         sizeof(*pSndWave) + dwWaveDataLen,
                         0,                                 // flags
                         (struct sockaddr *)&sin,           // to address
                         sizeof(sin));

        if (SOCKET_ERROR == sendres)
        {
            TRC(ERR, "_VCSndSendWaveDGram: sendto failed: %d\n",
                WSAGetLastError());
            goto exitpt;
        }

        g_dwPacketSize = sizeof(*pSndWave) + dwWaveDataLen;

        dwDataSize -= dwWaveDataLen;
        pData = ((LPSTR)(pData)) + dwWaveDataLen;
    }

    bSucc = TRUE;

exitpt:
    return bSucc;
}

BOOL
_VCSndSendWaveDGramInFrags(
    BYTE  cBlockNo,
    PVOID pData,
    DWORD dwDataSize
    )
{
    BOOL    bSucc = FALSE;
    struct sockaddr_in  sin;
    INT     sendres;
    PSNDUDPWAVE pWave;
    PSNDUDPWAVELAST pLast;
    PBYTE   pSource;
    PBYTE   pEnd;
    DWORD   dwFragSize;
    DWORD   dwNumFrags;
    DWORD   count;
    DWORD   dwSize;
    PVOID   pBuffer;
    UINT16  wStartTime;

    ASSERT( CanUDPFragment( g_wClientVersion ) && dwDataSize <= 0x8000 + RDPSND_SIGNATURE_SIZE );

    __try {
        pBuffer = _alloca( g_dwDGramSize );
    } __except((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
                    EXCEPTION_EXECUTE_HANDLER :
                    EXCEPTION_CONTINUE_SEARCH)
    {
        _resetstkoflw();
        pBuffer = 0;
    }
    if ( NULL == pBuffer )
    {
        goto exitpt;
    }
    //
    //  calculate number of frags etc
    //
    dwFragSize = g_dwDGramSize - sizeof( *pLast );
    dwNumFrags = dwDataSize / dwFragSize;
    pSource = (PBYTE)pData;
    pEnd = pSource + dwDataSize;
    wStartTime = (UINT16)GetTickCount();

    // prepare the to address
    //
    sin.sin_family = PF_INET;
    sin.sin_port = (u_short)g_dwDGramPort;
    sin.sin_addr.s_addr = g_ulDGramAddress;

    //
    //  make sure we can fit all the frag counters
    //
    ASSERT( dwNumFrags < 0x7fff );

    if ( 0 != dwNumFrags )
    {
        pWave = (PSNDUDPWAVE)pBuffer;
        pWave->Type = SNDC_UDPWAVE;
        pWave->cBlockNo = cBlockNo;
        for( count = 0; count < dwNumFrags; count++ )
        {
            PBYTE pDest = (PBYTE)(&pWave->cFragNo);
            dwSize = sizeof( *pWave ) + dwFragSize;

            if ( count >= RDPSND_FRAGNO_EXT )
            {
                *pDest = (BYTE)(((count >> 8) & (~RDPSND_FRAGNO_EXT)) | RDPSND_FRAGNO_EXT);
                pDest++;
                *pDest = (BYTE)(count & 0xff);
                dwSize++;
            } else {
                *pDest = (BYTE)count;
            }
            pDest++;
            memcpy( pDest, pSource, dwFragSize );

            sendres = sendto(
                    g_hDGramSocket,
                    (LPSTR)pWave,
                    dwSize,
                    0,                                 // flags
                    (struct sockaddr *)&sin,           // to address
                    sizeof(sin));

            if (SOCKET_ERROR == sendres)
            {
                TRC(ERR, "_VCSndSendWaveDGramInFrags: sendto failed: %d\n",
                    WSAGetLastError());
                goto exitpt;
            }
            pSource += dwFragSize;
        }
    }

    ASSERT( pSource <= pEnd );
    //
    //  send the last fragment with all the extra info
    //
    pLast = (PSNDUDPWAVELAST)pBuffer;
    pLast->Type = SNDC_UDPWAVELAST;
    pLast->wTotalSize   = (UINT16)dwDataSize;
    pLast->wTimeStamp   = wStartTime;
    pLast->wFormatNo    = (UINT16)g_dwCurrentFormat;
    pLast->dwBlockNo    = (g_HiBlockNo << 8) + cBlockNo;
    dwSize = PtrToLong( (PVOID)( pEnd - pSource ));
    memcpy( pLast + 1, pSource, dwSize );
    sendres = sendto(
                g_hDGramSocket,
                (LPSTR)pLast,
                dwSize + sizeof( *pLast ),
                0,
                (struct sockaddr *)&sin,
                sizeof(sin)
            );

    if (SOCKET_ERROR == sendres)
    {
        TRC(ERR, "_VCSndSendWaveDGramInFrags: sendto failed: %d\n",
            WSAGetLastError());
        goto exitpt;
    }
    g_dwPacketSize = dwNumFrags * sizeof( *pWave ) + sizeof( *pLast ) + dwDataSize;

    bSucc = TRUE;

exitpt:
    return bSucc;
}

BOOL
_VCSndSendWaveVC(
    BYTE  cBlockNo,
    PVOID pData,
    DWORD dwDataSize
    )
{
    BOOL    bSucc = FALSE;
    SNDWAVE Wave;
    //
    // send this block through the virtual channel
    //
    TRC(ALV, "_VCSndSendWave: sending through VC\n");

    Wave.Prolog.Type = SNDC_WAVE;
    Wave.cBlockNo    = cBlockNo;
    Wave.wFormatNo   = (UINT16)g_dwCurrentFormat;
    Wave.wTimeStamp  = (UINT16)GetTickCount();
    Wave.Prolog.BodySize = (UINT16)( sizeof(Wave) - sizeof(Wave.Prolog) +
                            dwDataSize );

    bSucc = ChannelMessageWrite(
                &Wave,
                sizeof(Wave),
                pData,
                dwDataSize
    );

    g_dwPacketSize = sizeof(Wave) + Wave.Prolog.BodySize;

    if (!bSucc)
    {
        TRC(ERR, "_VCSndSendWave: failed to send wave: %d\n",
            GetLastError());
    }

    return bSucc;
}

/*
 *  Function:
 *      _VCSndSendWave
 *
 *  Description:
 *      Sends a wave data to the client
 *
 */
BOOL
_VCSndSendWave(
    BYTE  cBlockNo,
    PVOID pData,
    DWORD dwDataSize
    ) 
{
    BOOL    bSucc = FALSE;
    static BYTE    s_pDest[ TSSND_BLOCKSIZE + RDPSND_SIGNATURE_SIZE ];
    PBYTE   pDest = s_pDest + RDPSND_SIGNATURE_SIZE;

#if _SIM_RESAMPLE
    //
    //  resample randomly
    //
    if ( NULL != g_ppNegotiatedFormats && 0 == (cBlockNo % 32) )
    {
        _VCSndCloseConverter();

        g_dwCurrentFormat = rand() % g_dwNegotiatedFormats;
        g_dwDataRemain = 0;

        _VCSndOpenConverter();
    }
#endif
    _StatsCheckResample();

    if ( NULL != g_hacmStream )
    {
        DWORD dwDestSize = TSSND_BLOCKSIZE;
        if (!_VCSndConvert( (PBYTE) pData, dwDataSize, pDest, &dwDestSize ))
        {
            TRC(ERR, "_VCSndSendWave: conversion failed\n");
            goto exitpt;
        } else {
            pData = pDest;
            dwDataSize = dwDestSize;
        }
    } else {
        //
        // no conversion
        // use the data as it is
        // copy it in the s_pDest buffer
        //
        ASSERT( dwDataSize <= TSSND_BLOCKSIZE );
        memcpy( pDest, pData, dwDataSize );
    }

    if (
        INVALID_SOCKET != g_hDGramSocket &&
        0 != g_dwDGramPort &&
        0 != g_dwDGramSize &&
        0 != g_ulDGramAddress &&
        0 != g_dwLineBandwidth         // if this is 0, we don't have UDP
        )
    {
    //  Send a datagram
    //
        if ( !CanUDPFragment( g_wClientVersion ) &&
             dwDataSize + sizeof( SNDWAVE ) + RDPSND_SIGNATURE_SIZE > g_dwDGramSize )
        {
        //
        //  if the wave doesn't fit in the UDP packet use VCs
        //
            bSucc = _VCSndSendWaveVC( cBlockNo, pData, dwDataSize );
        } else {
            //
            //  add signature if necessary
            //
            if ( IsDGramWaveSigned( g_wClientVersion ))
            {
                if ( !IsDGramWaveAudioSigned( g_wClientVersion ))
                {
                    SL_Signature( s_pDest, (g_HiBlockNo << 8) + cBlockNo );
                } else {
                    SL_AudioSignature( s_pDest, (g_HiBlockNo << 8) + cBlockNo, 
                                       (PBYTE)pData, dwDataSize );
                }
                pData = s_pDest;
                dwDataSize += RDPSND_SIGNATURE_SIZE;
            }

            if ( CanUDPFragment( g_wClientVersion ) &&
                 dwDataSize + sizeof( SNDWAVE ) > g_dwDGramSize )
            {
                bSucc = _VCSndSendWaveDGramInFrags( cBlockNo, pData, dwDataSize );
            } else {
                bSucc = _VCSndSendWaveDGram( cBlockNo, pData, dwDataSize );
            }
        }
    } else {
        bSucc = _VCSndSendWaveVC( cBlockNo, pData, dwDataSize );
    }

    TRC(ALV, "_VCSndSendWave: BlockNo: %d sent\n", cBlockNo);

exitpt:

    return bSucc;
}


INT
WSInit(
    VOID
    )
{
    WORD    versionRequested;
    WSADATA wsaData;
    int     intRC;

    versionRequested = MAKEWORD(1, 1);

    intRC = WSAStartup(versionRequested, &wsaData);

    if (intRC != 0)
    {
        TRC(ERR, "Failed to initialize WinSock rc:%d\n", intRC);
    }
    return intRC;
}

/*
 *  Function:
 *      DGramRead
 *
 *  Description:
 *      Reads an UDP message (datagram)
 *
 */
VOID
DGramRead(
    HANDLE hDGramEvent,
    PVOID  *ppBuff,
    DWORD  *pdwSize
    )
{
    DWORD   dwRecvd;
    DWORD   dwFlags;
    INT     rc;

    if ( INVALID_SOCKET == g_hDGramSocket )
        goto exitpt;

    ASSERT( NULL != hDGramEvent );

    do {
        memset(&g_WSAOverlapped, 0, sizeof(g_WSAOverlapped));
        g_WSAOverlapped.hEvent = hDGramEvent;

        dwRecvd = 0;
        dwFlags = 0;

        g_wsabuf.len = sizeof( g_pDGramRecvData );
        g_wsabuf.buf = (char *) g_pDGramRecvData;

        rc = WSARecvFrom(
                g_hDGramSocket,
                &g_wsabuf,
                1,
                &dwRecvd,
                &dwFlags,
                NULL,       // no from address
                NULL,
                &g_WSAOverlapped,
                NULL);      // no completion routine

        if ( 0 == rc )
        {
        //
        //  data received
        //
            SNDMESSAGE SndMsg;

            if ( NULL != ppBuff && NULL != pdwSize )
            {
            //
            //  pass the data to the caller
            //
                *ppBuff  = g_pDGramRecvData;
                *pdwSize = dwRecvd;
                goto exitpt;
            }


            if ( dwRecvd < sizeof( SNDPROLOG ))
            {
                TRC(WRN, "DGramRead: invalid message received: len=%d\n",
                    dwRecvd );
                continue;
            }
            
            memcpy( &SndMsg.Prolog, g_pDGramRecvData, sizeof( SNDPROLOG ));
            SndMsg.pBody = g_pDGramRecvData + sizeof( SNDPROLOG );

            TRC(ALV, "DGramRead: data received\n");

            //  parse this packet
            //
                VCSndDataArrived( &SndMsg );
        }
    }
    while ( SOCKET_ERROR != rc );

exitpt:
    ;
}

/*
 *  Function:
 *      DGramReadCompletion
 *
 *  Description:
 *      Datagram read completion
 *
 */
VOID
DGramReadComplete(
    PVOID  *ppBuff,
    DWORD  *pdwSize
    )
{
    BOOL        rc;
    SNDMESSAGE  SndMsg;
    DWORD       dwFlags = 0;
    DWORD       dwRecvd = 0;

    ASSERT( INVALID_SOCKET != g_hDGramSocket );

    rc = WSAGetOverlappedResult(
            g_hDGramSocket,
            &g_WSAOverlapped,
            &dwRecvd,
            FALSE,
            &dwFlags
        );

    if ( !rc )
    {
        TRC(ERR, "DGramReadComplete: WSAGetOverlappedResult failed=%d\n",
                WSAGetLastError());
        goto exitpt;
    }

    //
    //  data received
    //

    if ( dwRecvd < sizeof( SNDPROLOG ))
    {
        TRC(WRN, "DGramReadComplete: invalid message received: len=%d\n",
            dwRecvd );
        goto exitpt;
    }

    if ( NULL != ppBuff && NULL != pdwSize )
    {
    //
    //  pass the data to the caller
    //
        *ppBuff  = g_pDGramRecvData;
        *pdwSize = dwRecvd;
        goto exitpt;
    }

    memcpy( &SndMsg.Prolog, g_pDGramRecvData, sizeof( SNDPROLOG ));
    SndMsg.pBody = g_pDGramRecvData + sizeof( SNDPROLOG );

    TRC(ALV, "DGramReadComplete: data received\n");

    //  parse this packet
    //
    VCSndDataArrived( &SndMsg );

exitpt:
    ;
}

/*
 *  Add an ACE to object security descriptor
 */
DWORD 
AddAceToObjectsSecurityDescriptor (
    HANDLE hObject,             // handle to object
    SE_OBJECT_TYPE ObjectType,  // type of object
    LPTSTR pszTrustee,          // trustee for new ACE
    TRUSTEE_FORM TrusteeForm,   // format of TRUSTEE structure
    DWORD dwAccessRights,       // access mask for new ACE
    ACCESS_MODE AccessMode,     // type of ACE
    DWORD dwInheritance         // inheritance flags for new ACE
) 
{
    DWORD dwRes;
    PACL pOldDACL = NULL, pNewDACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    EXPLICIT_ACCESS ea;

    if (NULL == hObject) 
        return ERROR_INVALID_PARAMETER;

    // Get a pointer to the existing DACL.

    dwRes = GetSecurityInfo(hObject, ObjectType, 
          DACL_SECURITY_INFORMATION,
          NULL, NULL, &pOldDACL, NULL, &pSD);

    if (ERROR_SUCCESS != dwRes) 
    {
        TRC( ERR, "GetSecurityInfo Error %u\n", dwRes );
        goto exitpt; 
    }  

    // Initialize an EXPLICIT_ACCESS structure for the new ACE. 

    ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
    ea.grfAccessPermissions = dwAccessRights;
    ea.grfAccessMode = AccessMode;
    ea.grfInheritance= dwInheritance;
    ea.Trustee.TrusteeForm = TrusteeForm;
    ea.Trustee.ptstrName = pszTrustee;

    // Create a new ACL that merges the new ACE
    // into the existing DACL.

    dwRes = SetEntriesInAcl(1, &ea, pOldDACL, &pNewDACL);
    if (ERROR_SUCCESS != dwRes)  
    {
        TRC( ERR, "SetEntriesInAcl Error %u\n", dwRes );
        goto exitpt; 
    }  

    // Attach the new ACL as the object's DACL.

    dwRes = SetSecurityInfo(hObject, ObjectType, 
          DACL_SECURITY_INFORMATION,
          NULL, NULL, pNewDACL, NULL);

    if (ERROR_SUCCESS != dwRes)  
    {
        TRC( ERR, "SetSecurityInfo Error %u\n", dwRes );
        goto exitpt; 
    }  

exitpt:

    if(pSD != NULL) 
        LocalFree((HLOCAL) pSD); 
    if(pNewDACL != NULL) 
        LocalFree((HLOCAL) pNewDACL); 

    return dwRes;
}

/*
 *  Add "system" account with full control over this handle
 *
 */
BOOL
_ObjectAllowSystem(
    HANDLE h
    )
{
    BOOL rv = FALSE;
    PSID pSidSystem;
    SID_IDENTIFIER_AUTHORITY AuthorityNt = SECURITY_NT_AUTHORITY;
    DWORD dw;

    if (!AllocateAndInitializeSid(&AuthorityNt, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &pSidSystem))
    {
        TRC( ERR, "AllocateAndInitializeSid failed: %d\n",
                  GetLastError() );
        goto exitpt;
    }

    ASSERT(IsValidSid(pSidSystem));

    dw = AddAceToObjectsSecurityDescriptor (
        h,                           // handle to object
        SE_KERNEL_OBJECT,            // type of object
        (LPTSTR)pSidSystem,          // trustee for new ACE
        TRUSTEE_IS_SID,              // format of TRUSTEE structure
        GENERIC_ALL,                 // access mask for new ACE
        GRANT_ACCESS,                // type of ACE
        0                            // inheritance flags for new ACE
    );

    if ( ERROR_SUCCESS != dw )
    {

        TRC( ERR, "AddAceToObjectsSecurityDescriptor failed=%d\n", dw );
        goto exitpt;
    }

    rv = TRUE;
exitpt:

    return rv;
}

VOID
_SignalInitializeDone(
    VOID
    )
{
    HANDLE hInitEvent = OpenEvent( EVENT_MODIFY_STATE,
                                   FALSE,
                                   TSSND_WAITTOINIT );

    g_Stream->dwSoundCaps |= TSSNDCAPS_INITIALIZED;

    if ( NULL != hInitEvent )
    {
        PulseEvent( hInitEvent );
        CloseHandle( hInitEvent );
    }

    TRC( INF, "Audio host is ready!\n" );
}

/*
 *  Function:
 *      VCSndIoThread
 *
 *  Description:
 *      Main entry pint for this thread
 *
 */
INT
WINAPI
VCSndIoThread(
    PVOID pParam
    )
{
    HANDLE          ahEvents[TOTAL_EVENTS];
    HANDLE          hReadEvent = NULL;
    HANDLE          hDGramEvent = NULL;
    SNDMESSAGE      SndMessage;
    DWORD           dwres;
    ULONG           logonId;
    HANDLE          hReconnectEvent = NULL;
    WCHAR           szEvName[64];
    BYTE            i;

    _VCSndReadRegistry();

    memset (&SndMessage, 0, sizeof(SndMessage));

    WSInit();


    // create the global/local events
    //
    g_hDataReadyEvent = CreateEvent(NULL,
                                    FALSE, 
                                    FALSE, 
                                    TSSND_DATAREADYEVENT);
    g_hStreamIsEmptyEvent = CreateEvent(NULL, 
                                        FALSE, 
                                        TRUE, 
                                        TSSND_STREAMISEMPTYEVENT);

    g_hStreamMutex = CreateMutex(NULL, FALSE, TSSND_STREAMMUTEX);

    hReadEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    hDGramEvent = WSACreateEvent();

    if (NULL == g_hDataReadyEvent ||
        NULL == g_hStreamIsEmptyEvent ||
        NULL == g_hStreamMutex ||
        NULL == hReadEvent ||
        NULL == hDGramEvent)
    {
        TRC(FATAL, "VCSndIoThread: no events\n");
        goto exitpt;
    }

    //  adjust privileges on the events
    //
    if (!_ObjectAllowSystem( g_hDataReadyEvent ))
        goto exitpt;
    if (!_ObjectAllowSystem( g_hStreamIsEmptyEvent ))
        goto exitpt;
    if (!_ObjectAllowSystem( g_hStreamMutex ))
        goto exitpt;

    //  create the stream
    //
    g_hStream = CreateFileMapping(
                    INVALID_HANDLE_VALUE,   //PG.SYS
                    NULL,                    // security
                    PAGE_READWRITE,
                    0,                      // Size high
                    sizeof(*g_Stream),      // Size low
                    TSSND_STREAMNAME        // mapping name
                    );

    if (NULL == g_hStream)
    {
        TRC(FATAL, "DllInstanceInit: failed to create mapping: %d\n",
                    GetLastError());
        goto exitpt;
    }

    if (!_ObjectAllowSystem( g_hStream ))
        goto exitpt;

    g_Stream = (PSNDSTREAM) MapViewOfFile(
                    g_hStream,
                    FILE_MAP_ALL_ACCESS,
                    0, 0,       // offset
                    sizeof(*g_Stream)
                    );

    if (NULL == g_Stream)
    {
        TRC(ERR, "VCSndIoThread: "
                 "can't map the stream view: %d\n",
                 GetLastError());
        goto exitpt;
    }

    //  Initialize the stream
    //
    if (VCSndAcquireStream())
    {
        memset(g_Stream, 0, sizeof(*g_Stream) - sizeof(g_Stream->pSndData));
        memset(g_Stream->pSndData, 0x00000000, sizeof(g_Stream->pSndData));
        g_Stream->cLastBlockConfirmed   = g_Stream->cLastBlockSent - 1;

        //
        // no socket created, so far
        //
        g_hDGramSocket = INVALID_SOCKET;

        VCSndReleaseStream();

    } else {
    
        TRC(FATAL, "VCSndIoThread, can't map the stream: %d, aborting\n",
                   GetLastError());
        goto exitpt;
    }

    if (!ProcessIdToSessionId(GetCurrentProcessId(), &logonId))
    {
        TRC(FATAL, "VCSndIoThread: failed to het session Id. %d\n",
            GetLastError());
        goto exitpt;
    }

    //  create disconnect/reconnect events
    //
    wcsncpy(szEvName, L"RDPSound-Disconnect", sizeof(szEvName)/sizeof(szEvName[0]));

    g_hDisconnectEvent = CreateEvent(NULL, FALSE, FALSE, szEvName);
    if (NULL == g_hDisconnectEvent)
    {
        TRC(FATAL, "VCSndIoThread: can't create disconnect event. %d\n",
            GetLastError());
        goto exitpt;
    }

    wcsncpy(szEvName, L"RDPSound-Reconnect", sizeof(szEvName)/sizeof(szEvName[0]));

    hReconnectEvent = CreateEvent(NULL, FALSE, FALSE, szEvName);
    if (NULL == hReconnectEvent)
    {
        TRC(FATAL, "VCSndIoThread: can't create reconnect event. %d\n",
            GetLastError());
        goto exitpt;
    }

    if (!ChannelOpen())
    {
        TRC(FATAL, "VCSndIoThread: unable to open virtual channel\n");
        goto exitpt;
    }

    ahEvents[READ_EVENT]         = hReadEvent;
    ahEvents[DISCONNECT_EVENT]   = g_hDisconnectEvent;
    ahEvents[RECONNECT_EVENT]    = hReconnectEvent;
    ahEvents[DATAREADY_EVENT]    = g_hDataReadyEvent;
    ahEvents[DGRAM_EVENT]        = hDGramEvent;
    ahEvents[POWERWAKEUP_EVENT]  = g_hPowerWakeUpEvent;
    ahEvents[POWERSUSPEND_EVENT] = g_hPowerSuspendEvent;

    _VCSndCheckDevice( hReadEvent, hDGramEvent );

    //  Check the channel for data
    //
    while (ChannelReceiveMessage(&SndMessage, hReadEvent))
    {
        VCSndDataArrived(&SndMessage);
        SndMessage.uiPrologReceived = 0;
        SndMessage.uiBodyReceived = 0;
    }

    DGramRead( hDGramEvent, NULL, NULL );

    //
    //  signal all workers waiting for initialize
    //
    _SignalInitializeDone();

    // main loop
    //
    while (g_bRunning)
    {
        DWORD dwNumEvents = sizeof(ahEvents)/sizeof(ahEvents[0]);

        dwres = WaitForMultipleObjectsEx(
                              dwNumEvents,                  // count
                              ahEvents,                     // events
                              FALSE,                        // wait all
                              DEFAULT_RESPONSE_TIMEOUT,
                              FALSE                         // non alertable
                            );

        if (!g_bRunning)
            TRC(ALV, "VCSndIoThread: time to exit\n");

        if (WAIT_TIMEOUT != dwres)
            TRC(ALV, "VCSndIoThread: an event was fired\n");

        if (READ_EVENT == dwres)
        //
        //  data is ready to read
        //
        {
            ChannelBlockReadComplete();
            ResetEvent(ahEvents[0]);

            //  Check the channel for data
            //
            while (ChannelReceiveMessage(&SndMessage, hReadEvent))
            {
                VCSndDataArrived(&SndMessage);
                SndMessage.uiPrologReceived = 0;
                SndMessage.uiBodyReceived = 0;
            }

        } else if (( DISCONNECT_EVENT == dwres ) ||    // disconnect event
                   ( POWERSUSPEND_EVENT == dwres ))         // suspend event
        {
        //  disconnect event
        //
            TRC(INF, "VCSndIoThread: DISCONNECTED\n");
            _VCSndCloseDevice();
            _VCSndCloseConverter();
            ChannelClose();
            _StatReset();
            if ( DISCONNECT_EVENT == dwres )
            {
                g_bDisconnected = TRUE;
            } else {
                g_bSuspended = TRUE;
            }
            continue;

        } else if (( RECONNECT_EVENT == dwres ) ||     // reconnect event
                   ( POWERWAKEUP_EVENT == dwres )) 
        {
        //  reconnect event
        //
            if ( POWERWAKEUP_EVENT == dwres )
            {
            // power wakeup event
            // here, we may have not received suspend event, but in that case we
            // had failed to send, so check the g_bDeviceFailed flag and act only if it is on
                if ( g_bDisconnected )
                {
                // no reason to process power wake up if we are not remote
                //
                    g_bSuspended = FALSE;
                    continue;
                }
                if ( !g_bSuspended && !g_bDeviceFailed )
                {
                // if neither of these happend
                // then we don't care
                    continue;
                }
            }

            TRC(INF, "VCSndIoThread: RECONNECTED\n");
            if (!ChannelOpen())
            {
                TRC(FATAL, "VCSndIoThread: unable to open virtual channel\n");
            } else {
                _VCSndCheckDevice( hReadEvent, hDGramEvent );
                //
                //  start the receive loop again
                //
                if (ChannelReceiveMessage(&SndMessage, hReadEvent))
                {
                    VCSndDataArrived(&SndMessage);
                    SndMessage.uiPrologReceived = 0;
                    SndMessage.uiBodyReceived = 0;
                }

                if ( RECONNECT_EVENT == dwres )
                {
                    g_bDisconnected = FALSE;
                } else {
                    g_bSuspended = FALSE;
                }
                g_bDeviceFailed = FALSE;

                // kick the player
                //
                PulseEvent( g_hStreamIsEmptyEvent );
                _SignalInitializeDone();
            }
        } else if ( DGRAM_EVENT == dwres )
        {
        //
        //  DGram ready  
        //
            DGramReadComplete( NULL, NULL );
            //
            //  atttempt more read
            //
            DGramRead( hDGramEvent, NULL, NULL );
        }

        //  Check for data available from the apps
        //
        if (!VCSndAcquireStream())
        {
            TRC(FATAL, "VCSndIoThread: somebody is holding the "
                       "Stream mutext for too long\n");
            continue;
        }

        //  if this was a reconnect
        //  roll back to the last block sent
        //
        if ( RECONNECT_EVENT == dwres)
        {
            //
            // clean this chunk for the next mix
            //
            memset( g_Stream->pSndData, 0, TSSND_MAX_BLOCKS * TSSND_BLOCKSIZE );

            g_Stream->cLastBlockConfirmed = g_Stream->cLastBlockSent;
        }

        //
        //  if we have not received confirmation
        //  for the packets sent, just give up and continue
        //
        if (WAIT_TIMEOUT == dwres &&
            g_bDeviceOpened &&
            g_Stream->cLastBlockSent != g_Stream->cLastBlockConfirmed)
        {
            BYTE cCounter;

            TRC(WRN, "VCSndIoThread: not received confirmation for blocks "
                     "between %d and %d\n",
                      g_Stream->cLastBlockConfirmed,
                      g_Stream->cLastBlockSent);

            for ( cCounter = g_Stream->cLastBlockConfirmed;
                 cCounter != (BYTE)(g_Stream->cLastBlockSent + 1);
                 cCounter++)
            {
                _StatsCollect(( GetTickCount() - DEFAULT_RESPONSE_TIMEOUT ) &
                                0xffff );
            }
            //
            // end of the loop
            //
            g_Stream->cLastBlockConfirmed = g_Stream->cLastBlockSent;
            //
            //  kick the player
            //
            PulseEvent(g_hStreamIsEmptyEvent);
        }

        // Check for control commands
        //
        // Volume
        //
        if ( g_bDeviceOpened && g_Stream->bNewVolume &&
            0 != (g_Stream->dwSoundCaps & TSSNDCAPS_VOLUME))
        {
            SNDSETVOLUME SetVolume;

            TRC(ALV, "VCSndIoThread: new volume\n");

            SetVolume.Prolog.Type = SNDC_SETVOLUME;
            SetVolume.Prolog.BodySize = sizeof(SetVolume) - sizeof(SetVolume.Prolog);
            SetVolume.dwVolume = g_Stream->dwVolume;

            ChannelBlockWrite(
                    &SetVolume,
                    sizeof(SetVolume)
                );

            g_Stream->bNewVolume = FALSE;
        }

        //  Pitch
        //
        if ( g_bDeviceOpened && g_Stream->bNewPitch &&
            0 != (g_Stream->dwSoundCaps & TSSNDCAPS_PITCH))
        {
            SNDSETPITCH SetPitch;

            TRC(ALV, "VCSndIoThread: new pitch\n");

            SetPitch.Prolog.Type = SNDC_SETPITCH;
            SetPitch.Prolog.BodySize = sizeof(SetPitch) - sizeof(SetPitch.Prolog);
            SetPitch.dwPitch = g_Stream->dwPitch;

            ChannelBlockWrite(
                    &SetPitch,
                    sizeof(SetPitch)
                );

            g_Stream->bNewPitch = FALSE;
        }

        //  Check for data available from the apps
        //
        if (g_Stream->cLastBlockSent != g_Stream->cLastBlockQueued &&
            (BYTE)(g_Stream->cLastBlockSent - g_Stream->cLastBlockConfirmed) <
                g_dwBlocksOnTheNet
            )
        {
        //  Aha, here's some data to send
        //

            TRC(ALV, "VCSndIoThread: will send some data\n");

            if (g_bDisconnected || g_bSuspended || g_bDeviceFailed)
            {
                TRC(ALV, "Device is disconnected. ignore the packets\n");
                g_Stream->cLastBlockSent = g_Stream->cLastBlockQueued;
                g_Stream->cLastBlockConfirmed = g_Stream->cLastBlockSent - 1;

                PulseEvent( g_hStreamIsEmptyEvent );
            } else
            if (!g_bDeviceOpened)
            {
            // send an "open device" command
            //
                SNDPROLOG Prolog;

                    //
                    //  first, try to open the acm converter
                    //
                    _VCSndOpenConverter();
                    //
                    // if we failed width the converter will
                    // send in native format
                    //
                    g_bDeviceOpened = TRUE;
            }

            for (i = g_Stream->cLastBlockSent; 
                 i != g_Stream->cLastBlockQueued &&
                    (BYTE)(g_Stream->cLastBlockSent - 
                        g_Stream->cLastBlockConfirmed) <
                    g_dwBlocksOnTheNet;
                 i++)
            {
                BOOL bSucc;

//                TRC( INF, "Sending block # %d, last conf=%d, last queued=%d\n", i, g_Stream->cLastBlockConfirmed, g_Stream->cLastBlockSent );
                bSucc = _VCSndSendWave(
                            i,              // block no
                            ((LPSTR)g_Stream->pSndData) +
                                ((i % TSSND_MAX_BLOCKS) * TSSND_BLOCKSIZE),
                            TSSND_BLOCKSIZE
                );

                //
                // clean this chunk for the next mix
                //
                memset(g_Stream->pSndData +
                        (i % TSSND_MAX_BLOCKS) *
                        TSSND_BLOCKSIZE,
                        0x00000000,
                        TSSND_BLOCKSIZE);

                if ( 0xff == i )
                    g_HiBlockNo++;

                if (bSucc)
                {
                    g_Stream->cLastBlockSent = i + 1;
                }
                else
                {
                    TRC(WRN, "VCSndIoThread: failed to send, "
                             "disabling the device\n");
                    //
                    //  act the same way as DISCONNECT
                    //
                    _VCSndCloseDevice();
                    _VCSndCloseConverter();
                    ChannelClose();

                    g_Stream->cLastBlockConfirmed =
                        g_Stream->cLastBlockSent = g_Stream->cLastBlockQueued;
                    _StatReset();

                    g_bDeviceFailed = TRUE;
                    //
                    //  Break this loop
                    //
                    break;
                }
            }
        }

        //  Check if there's no more data
        //  if so, close the remote device
        //
        if (g_bDeviceOpened &&
            g_Stream->cLastBlockQueued == g_Stream->cLastBlockSent &&
            g_Stream->cLastBlockSent == g_Stream->cLastBlockConfirmed)
        {
            SNDPROLOG Prolog;

            TRC(ALV, "VCSndIoThread: no more data, closing the device\n");

            _VCSndCloseConverter();

            Prolog.Type = SNDC_CLOSE;
            Prolog.BodySize = 0;

            ChannelBlockWrite(&Prolog, sizeof(Prolog));

            g_bDeviceOpened = FALSE;
            
        }

        VCSndReleaseStream();

    }

exitpt:
    ChannelClose();
    if (NULL != hReadEvent)
        CloseHandle(hReadEvent);

    if (NULL != hDGramEvent)
        WSACloseEvent( hDGramEvent );

    if (SndMessage.pBody)
        TSFREE(SndMessage.pBody);

    if (NULL != hReconnectEvent)
        CloseHandle(hReconnectEvent);

    if (NULL != g_hDisconnectEvent)
        CloseHandle(g_hDisconnectEvent);

    if (NULL != g_hStreamIsEmptyEvent)
        CloseHandle(g_hStreamIsEmptyEvent);

    if (VCSndAcquireStream())
    {
        //
        //  mark the device dead
        //
        g_Stream->dwSoundCaps = TSSNDCAPS_TERMINATED;

        VCSndReleaseStream();

        _SignalInitializeDone();
    }

    if (NULL != g_Stream)
    {
        if (INVALID_SOCKET != g_hDGramSocket)
            closesocket(g_hDGramSocket);

        UnmapViewOfFile(g_Stream);
    }

    if (NULL != g_hStream)
        CloseHandle(g_hStream);

    if (NULL != g_hStreamMutex)
        CloseHandle(g_hStreamMutex);

    // clean the previously negotiated format
    //
    if (NULL != g_ppNegotiatedFormats)
    {
        DWORD i;
        for ( i = 0; i < g_dwNegotiatedFormats; i++ )
        {
            if ( NULL != g_ppNegotiatedFormats[i] )
                TSFREE( g_ppNegotiatedFormats[i] );
        }
        TSFREE( g_ppNegotiatedFormats );

    }

    //
    //  cleanup the format list
    //
    if ( NULL != g_pAllCodecsFormatList )
    {
        PVCSNDFORMATLIST pIter;

        pIter = g_pAllCodecsFormatList;
        while( NULL != pIter )
        {
            PVCSNDFORMATLIST pNext = pIter->pNext;

            TSFREE( pIter );

            pIter = pNext;
        }
    }

    if ( NULL != g_AllowCodecs )
    {
        TSFREE( g_AllowCodecs );
        g_AllowCodecs = NULL;
        g_AllowCodecsSize = 0;
    }

    WSACleanup();

    TRC(INF, "VCSndIoThread: EXIT !\n");

    return 0;
}

/////////////////////////////////////////////////////////////////////
//
//  Startup code
//
/////////////////////////////////////////////////////////////////////


VOID
TSSNDD_Term(
    VOID
    )
{

    if ( NULL == g_hThread )
        return;

    g_bRunning = FALSE;
    //
    //  kick the io thread
    //
    if (NULL != g_hDataReadyEvent)
        SetEvent(g_hDataReadyEvent);

    if ( NULL != g_hThread )
    {
        WaitForSingleObject(g_hThread, DEFAULT_VC_TIMEOUT);
        CloseHandle(g_hThread);
        g_hThread = NULL;
    }

    if (NULL != g_hDataReadyEvent)
    {
        CloseHandle(g_hDataReadyEvent);
        g_hDataReadyEvent = NULL;
    }

    if ( NULL != g_hPowerWakeUpEvent )
    {
        CloseHandle( g_hPowerWakeUpEvent );
        g_hPowerWakeUpEvent = NULL;
    }
    if ( NULL != g_hPowerSuspendEvent )
    {
        CloseHandle( g_hPowerSuspendEvent );
        g_hPowerSuspendEvent = NULL;
    }
}

LRESULT
TSSNDD_PowerMessage(
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch( wParam )
    {
    case PBT_APMSUSPEND:
        //
        //  signal only if connected
        //
        if ( NULL != g_hPowerSuspendEvent )
        {
            SetEvent( g_hPowerSuspendEvent );
        }
    break;
    case PBT_APMRESUMEAUTOMATIC:
    case PBT_APMRESUMECRITICAL:
    case PBT_APMRESUMESUSPEND:
        //
        //  signal only if not connected
        //
        if ( NULL != g_hPowerWakeUpEvent )
        {
            SetEvent( g_hPowerWakeUpEvent );
        }
    break;
    }

    return TRUE;
}

LRESULT
CALLBACK
_VCSndWndProc(
    HWND hwnd,
    UINT uiMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LRESULT rv = 0;

    switch( uiMessage )
    {
    case WM_CREATE:
    break;

    case WM_CLOSE:
        DestroyWindow(hwnd);
    break;

    case WM_DESTROY:
        PostQuitMessage(0);
    break;

    case WM_ENDSESSION:
        TSSNDD_Term();
    break;

    case WM_POWERBROADCAST:
        rv = TSSNDD_PowerMessage( wParam, lParam );
    break;

    default:
        rv = DefWindowProc(hwnd, uiMessage, wParam, lParam);
    }

    return rv;
}

BOOL
TSSNDD_Loop(
    HINSTANCE   hInstance 
    )
{
    BOOL        rv = FALSE;
    WNDCLASS    wc;
    DWORD       dwLastErr;
    HWND        hWnd = NULL;
    MSG         msg;

    memset(&wc, 0, sizeof(wc));

    wc.lpfnWndProc      = _VCSndWndProc;
    wc.hInstance        = hInstance;
    wc.hbrBackground    = (HBRUSH)GetStockObject(HOLLOW_BRUSH);
    wc.lpszClassName    = _RDPSNDWNDCLASS;

    if (!RegisterClass (&wc) &&
        (dwLastErr = GetLastError()) &&
         dwLastErr != ERROR_CLASS_ALREADY_EXISTS)
    {
        TRC(ERR,
              "TSSNDD_Loop: Can't register class. GetLastError=%d\n",
              GetLastError());
        goto exitpt;
    }


    hWnd = CreateWindow(
                       _RDPSNDWNDCLASS,
                       _RDPSNDWNDCLASS,         // Window name
                       WS_OVERLAPPEDWINDOW,     // dwStyle
                       0,            // x
                       0,            // y
                       100,          // nWidth
                       100,          // nHeight
                       NULL,         // hWndParent
                       NULL,         // hMenu
                       hInstance,
                       NULL);        // lpParam

    if (!hWnd)
    {
        TRC(ERR, "TSSNDD_Loop: Failed to create message window: %d\n",
                GetLastError());
        goto exitpt;
    }

    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    rv = TRUE;

exitpt:
    return rv;
}

BOOL
TSSNDD_Init(
    )
{
    BOOL    rv = FALSE;

    DWORD   dwThreadId;

    g_bRunning = TRUE;

    if ( NULL == g_hPowerWakeUpEvent )
    {
        g_hPowerWakeUpEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
        if ( NULL == g_hPowerWakeUpEvent )
        {
            TRC( FATAL, "TSSNDD_Init: failed to create power wakeup notification message: %d\n", GetLastError() );
            goto exitpt;
        }
    }
    if ( NULL == g_hPowerSuspendEvent )
    {
        g_hPowerSuspendEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
        if ( NULL == g_hPowerSuspendEvent )
        {
            TRC( FATAL, "TSSNDD_Init: failed to create power suspend notification message: %d\n", GetLastError() );
            goto exitpt;
        }
    }

    g_hThread = CreateThread(
                        NULL,
                        0,
                        (LPTHREAD_START_ROUTINE)VCSndIoThread,
                        NULL,
                        0,
                        &dwThreadId
                        );

    if (NULL == g_hThread)
    {
        TRC(FATAL, "WinMain: can't create thread: %d. Aborting\n",
            GetLastError());
        goto exitpt;
    }

    rv = TRUE;

exitpt:
    return rv;
}

/////////////////////////////////////////////////////////////////////
//
//  Tracing
//
/////////////////////////////////////////////////////////////////////

VOID
_cdecl
_DebugMessage(
    LPCSTR  szLevel,
    LPCSTR  szFormat,
    ...
    )
{
    CHAR szBuffer[256];
    va_list     arglist;

    if (szLevel == ALV)
        return;

    va_start (arglist, szFormat);
    _vsnprintf (szBuffer, RTL_NUMBER_OF(szBuffer), szFormat, arglist);
    va_end (arglist);
    szBuffer[ RTL_NUMBER_OF( szBuffer ) - 1 ] = 0;

    OutputDebugStringA(szLevel);
    OutputDebugStringA(szBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpclip\win32com.inc ===
!IF 0

Copyright (c) 1989-98  Microsoft Corporation

Module Name:

    common.inc - Win32 specific (TShare Clipboard Monitor) build definitions

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Martin Richards - March 18th 1998

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF


SDK_LIB_PATH = $(BASEDIR)\public\sdk\lib\*
CRT_LIB_PATH = $(BASEDIR)\public\sdk\lib\*
SDK_INC_PATH = $(BASEDIR)\public\sdk\inc
CRT_INC_PATH = $(SDK_INC_PATH)\crt

#
# Set common options
#

#
# Use Multi-threaded static library by default.
#
!if $(386)
USE_LIBCMT = 1
!endif

#
# Insure that we will work on Win 95
#
#CHICAGO_PROJECT = 1
#CHICAGO_PRODUCT = 1

CBSTRING = -cbstring
P5_FDIV_FIX = /QIfdiv-
P5_0F_FIX = /QIf
C_INCREMENTAL_FLAG = /Gi- /Gm-
EH_FLAGS = /GX- /GR-
FRAME_PTR_ON = /Oy
FRAME_PTR_OFF = /Oy-
CL_TARGET_SPEC = /Yl$(TARGETNAME)

#
# Library files, referenced by <component>.inc file, eg client.inc
#
CLIENT_LIB_EXE = \
   $(SDK_LIB_PATH)\kernel32.lib \
   $(SDK_LIB_PATH)\advapi32.lib \
   $(SDK_LIB_PATH)\user32.lib   \
   $(SDK_LIB_PATH)\gdi32.lib    \
   $(SDK_LIB_PATH)\imagehlp.lib \
   $(SDK_LIB_PATH)\shell32.lib  \

#
# Additional compiler flags
#
WIN32_DEFINE = -DWIN32=200 -D_CHICAGO_=200 -D_WIN32_WINDOWS=0x040a -D_WIN32_WINNT=0x0400
C_DEFINES  = $(C_DEFINES) -DWIN32 -D_WIN32 -DWIN_95_32_BIT
C_DEFS_UNICODE  = -DUNICODE -D_UNICODE

#
# File name prefix for 32-bit
#
PLATFORM_PREFIX = n

C_DEFINES=$(C_DEFINES) -DOS_WIN32 -DOS_WINNT -DSECURITY_WIN32

#
# Setup MSC_OPTIMIZATION for debug and retail
#
!if "$(FREEBUILD)" == "0"
MSC_OPTIMIZATION=/Odi
!else
MSC_OPTIMIZATION=/Oxs
!endif

386_WARNING_LEVEL=/W3

!ifdef ICACAP_BUILD

MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Gh
PERFLIBS=$(SDK_LIB_PATH)\icap.lib
LINKLIBS=$(LINKLIBS) $(PERFLIBS)

!endif // ICACAP_BUILD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\common\tshrutil.cxx ===
/*++

Copyright (c) 1994-1997  Microsoft Corporation

Module Name:

    tshrutil.cxx

Abstract:

    Contains the class implementation of UTILITY classes and other utility
    functions.

Author:

    Madan Appiah (madana)  25-Aug-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#include <tshrcom.hxx>     
#include <ctype.h>

//
// alloc globals here.
//

#define INITIAL_HEAP_SIZE   0xFFFF  // 64K

HANDLE  g_hTShareHeap;

//*************************************************************
//
//  TSUtilInit()
//
//  Purpose:    Creates util objects
//
//  History:    09-10-97    BrianTa     Reworked
//
//*************************************************************

DWORD
TSUtilInit(VOID)
{
    DWORD       dwError;
    NTSTATUS    ntStatus;

    dwError = ERROR_SUCCESS;


    g_hTShareHeap = HeapCreate(0, INITIAL_HEAP_SIZE, 0);

    if (g_hTShareHeap == NULL)
        dwError = GetLastError();

    return (dwError);
}


//*************************************************************
//
//  TSUtilCleanup()
//
//  Purpose:    Deletes the util objects
//
//  History:    09-10-97    BrianTa     Reworked
//
//*************************************************************

VOID
TSUtilCleanup(VOID)
{
    HeapDestroy(g_hTShareHeap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpsnd\rdpwave.c ===
/////////////////////////////////////////////////////////////////////
//
//      Module:     tswave.c
//
//      Purpose:    User-mode driver for terminal server
//                  sound redirection
//
//      Copyright(C) Microsoft Corporation 2000
//
//      History:    4-10-2000  vladimis [created]
//
/////////////////////////////////////////////////////////////////////

#include    "rdpsnd.h"
#include    <winsta.h>

#define TSSND_NATIVE_XLATERATE       ( TSSND_NATIVE_BLOCKALIGN * TSSND_NATIVE_SAMPLERATE )
#define MIXER_OBJECTF_TYPEMASK       0xF0000000L     // internal
enum {
RDP_MXDID_MUTE = 0,
RDP_MXDID_VOLUME,
RDP_MXDID_LAST
};

#define ENTER_CRIT  EnterCriticalSection(&g_cs);
#define LEAVE_CRIT  LeaveCriticalSection(&g_cs);

//
//  Global queue containing all queued wave headers
//  guarded by ENTER_CRIT LEAVE_CRIT macros
//
PWAVEOUTCTX         g_pAllWaveOut       = NULL;
HANDLE              g_hMixerEvent       = NULL;
CRITICAL_SECTION    g_cs;
MIXERCTX            g_Mixer;

//
//  Stream data
//
HANDLE      g_hWaitToInitialize         = NULL;
HANDLE      g_hDataReadyEvent           = NULL;
HANDLE      g_hStreamIsEmptyEvent       = NULL;
HANDLE      g_hStreamMutex              = NULL;
HANDLE      g_hStream                   = NULL;
PSNDSTREAM  g_Stream                    = NULL;
BOOL        g_bMixerRunning             = TRUE;

DWORD
waveRestart(
    PWAVEOUTCTX pWaveOut
    );

BOOL
_waveCheckSoundAlive(
    VOID
    );

BOOL
_waveAcquireStream(
    VOID
    );

BOOL
_waveReleaseStream(
    VOID
    );

VOID Place8kHz8Mono(PVOID pDest, PVOID pSrc, DWORD dwSize);
VOID Place8kHz8Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize);
VOID Place8kHz16Mono(PVOID pDest, PVOID pSrc, DWORD dwSize);
VOID Place8kHz16Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize);

VOID Place11kHz8Mono(PVOID pDest, PVOID pSrc, DWORD dwSize);
VOID Place22kHz8Mono(PVOID pDest, PVOID pSrc, DWORD dwSize);
VOID Place44kHz8Mono(PVOID pDest, PVOID pSrc, DWORD dwSize);
VOID Place11kHz16Mono(PVOID pDest, PVOID pSrc, DWORD dwSize);
VOID Place22kHz16Mono(PVOID pDest, PVOID pSrc, DWORD dwSize);
VOID Place44kHz16Mono(PVOID pDest, PVOID pSrc, DWORD dwSize);
VOID Place11kHz8Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize);
VOID Place22kHz8Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize);
VOID Place44kHz8Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize);
VOID Place11kHz16Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize);
VOID Place22kHz16Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize);
VOID Place44kHz16Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize);

VOID Place48kHz8Mono(PVOID pDest, PVOID pSrc, DWORD dwSize);
VOID Place48kHz8Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize);
VOID Place48kHz16Mono(PVOID pDest, PVOID pSrc, DWORD dwSize);
VOID Place48kHz16Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize);

/*
 *  Function:
 *      waveCallback
 *
 *  Description:
 *      Fire a user specified callback      
 *
 */
VOID
waveCallback(
    PWAVEOUTCTX pWaveOut,
    DWORD       msg,
    DWORD_PTR   dwParam1
    )
{
    if (pWaveOut && pWaveOut->dwCallback)
        DriverCallback(pWaveOut->dwCallback,        // user's callback DWORD
                       HIWORD(pWaveOut->dwOpenFlags),   // callback flags
                       (HDRVR)pWaveOut->hWave,      // wave device handle
                       msg,                         // the message
                       pWaveOut->dwInstance,        // user's instance data
                       dwParam1,                    // first DWORD
                       0L);                         // second DWORD
}

/*
 *  Function:
 *      waveOpen
 *
 *  Description:
 *      The user request a device open
 *
 *  Parameters:
 *      ppWaveOut   - pointer to a context
 *      pWaveOpenDesc- requested formats
 *      dwFlags     - and flags ( see MSDN )
 *
 */
DWORD
waveOpen(
    PWAVEOUTCTX     *ppWaveOut,
    LPWAVEOPENDESC  pWaveOpenDesc, 
    DWORD_PTR       dwFlags
    )
{
    DWORD           rv = MMSYSERR_ERROR;
    DWORD           dwProbe;
    PWAVEOUTCTX     pWaveOut = NULL;
    LPWAVEFORMATEX  lpFormat = NULL;
    VOID            (*pPlaceFn)(PVOID, PVOID, DWORD);
    DWORD           dwBytesPerXLate;

    //  Parameters check
    //
    if (NULL == ppWaveOut || NULL == pWaveOpenDesc)
    {
        TRC(ERR, "waveOpen: either ppWaveOut or pWaveOpenDesc are NULL\n");
        rv = MMSYSERR_INVALPARAM;
        goto exitpt;
    }

    //  Check the requested format
    //
    lpFormat = (LPWAVEFORMATEX)(pWaveOpenDesc->lpFormat);
    if (NULL == lpFormat)
    {
        TRC(ERR, "waveOpen: pWaveOpenDesc->lpFormat is NULL\n");
        rv = MMSYSERR_INVALPARAM;
        goto exitpt;
    }

    if (WAVE_FORMAT_PCM != lpFormat->wFormatTag)    // PCM format only
    {
        TRC(ALV, "waveOpen: non PCM format required, tag=%d\n",
                lpFormat->wFormatTag);
        rv = WAVERR_BADFORMAT;
        goto exitpt;
    }

    // 8kHz 8 bit mono
    //
    if (1 == lpFormat->nChannels &&
        8000 == lpFormat->nSamplesPerSec &&
        8000 == lpFormat->nAvgBytesPerSec &&
        1 == lpFormat->nBlockAlign &&
        8 == lpFormat->wBitsPerSample)
    {
        pPlaceFn = Place8kHz8Mono;
        dwBytesPerXLate = 8000;
    } else
    // 8kHz 8 bit stereo
    //
    if (2 == lpFormat->nChannels &&
        8000 == lpFormat->nSamplesPerSec &&
        16000 == lpFormat->nAvgBytesPerSec &&
        2 == lpFormat->nBlockAlign &&
        8 == lpFormat->wBitsPerSample)
    {
        pPlaceFn = Place8kHz8Stereo;
        dwBytesPerXLate = 2 * 8000;
    } else
    // 8kHz 16 bit mono
    //
    if (1 == lpFormat->nChannels &&
        8000 == lpFormat->nSamplesPerSec &&
        16000 == lpFormat->nAvgBytesPerSec &&
        2 == lpFormat->nBlockAlign &&
        16 == lpFormat->wBitsPerSample)
    {
        pPlaceFn = Place8kHz16Mono;
        dwBytesPerXLate = 2 * 8000;
    } else
    // 8kHz 16 bit stereo
    //
    if (2 == lpFormat->nChannels &&
        8000 == lpFormat->nSamplesPerSec &&
        32000 == lpFormat->nAvgBytesPerSec &&
        4 == lpFormat->nBlockAlign &&
        16 == lpFormat->wBitsPerSample)
    {
        pPlaceFn = Place8kHz16Stereo;
        dwBytesPerXLate = 4 * 8000;
    } else
    // 11kHz 8 bit mono
    //
    if (1 == lpFormat->nChannels &&                 // mono
        11025 == lpFormat->nSamplesPerSec &&
        11025 == lpFormat->nAvgBytesPerSec &&
        1 == lpFormat->nBlockAlign &&
        8 == lpFormat->wBitsPerSample)
    {
        pPlaceFn = Place11kHz8Mono;
        dwBytesPerXLate = 1 * 11025;
    }
    else
    // 22kHz 8 mono
    //
    if (1 == lpFormat->nChannels &&
        22050 == lpFormat->nSamplesPerSec &&
        22050 == lpFormat->nAvgBytesPerSec &&
        1 == lpFormat->nBlockAlign &&
        8 == lpFormat->wBitsPerSample)
    {
        pPlaceFn = Place22kHz8Mono;
        dwBytesPerXLate = 2 * 11025;
    }
    else
    // 44kHz 8 mono
    //
    if (1 == lpFormat->nChannels &&
        44100 == lpFormat->nSamplesPerSec &&
        44100 == lpFormat->nAvgBytesPerSec &&
        1 == lpFormat->nBlockAlign &&
        8 == lpFormat->wBitsPerSample)
    {
        pPlaceFn = Place44kHz8Mono;
        dwBytesPerXLate = 4 * 11025;
    }
    else
    // 11kHz 8 bit stereo
    //
    if (2 == lpFormat->nChannels &&
        11025 == lpFormat->nSamplesPerSec &&
        22050 == lpFormat->nAvgBytesPerSec &&
        2 == lpFormat->nBlockAlign &&
        8 == lpFormat->wBitsPerSample)
    {
        pPlaceFn = Place11kHz8Stereo;
        dwBytesPerXLate = 2 * 11025;
    }
    else
    // 22kHz 8 bit stereo
    //
    if (2 == lpFormat->nChannels &&
        22050 == lpFormat->nSamplesPerSec &&
        44100 == lpFormat->nAvgBytesPerSec &&
        2 == lpFormat->nBlockAlign &&
        8 == lpFormat->wBitsPerSample)
    {
        pPlaceFn = Place22kHz8Stereo;
        dwBytesPerXLate = 4 * 11025;
    }
    else
    // 44kHz 8 bit stereo
    //
    if (2 == lpFormat->nChannels &&
        44100 == lpFormat->nSamplesPerSec &&
        88200 == lpFormat->nAvgBytesPerSec &&
        2 == lpFormat->nBlockAlign &&
        8 == lpFormat->wBitsPerSample)
    {
        pPlaceFn = Place44kHz8Stereo;
        dwBytesPerXLate = 8 * 11025;
    }
    else
    // 11kHz 16 bit mono
    //
    if (1 == lpFormat->nChannels &&
        11025 == lpFormat->nSamplesPerSec &&
        22050 == lpFormat->nAvgBytesPerSec &&
        2 == lpFormat->nBlockAlign &&
        16 == lpFormat->wBitsPerSample)
    {
        pPlaceFn = Place11kHz16Mono;
        dwBytesPerXLate = 2 * 11025;
    }
    else
    // 22kHz 16 bit mono
    //
    if (1 == lpFormat->nChannels &&
        22050 == lpFormat->nSamplesPerSec &&
        44100 == lpFormat->nAvgBytesPerSec &&
        2 == lpFormat->nBlockAlign &&
        16 == lpFormat->wBitsPerSample)
    {
        pPlaceFn = Place22kHz16Mono;
        dwBytesPerXLate = 4 * 11025;
    }
    else
    // 44kHz 16 bit mono
    //
    if (1 == lpFormat->nChannels &&
        44100 == lpFormat->nSamplesPerSec &&
        88200 == lpFormat->nAvgBytesPerSec &&
        2 == lpFormat->nBlockAlign &&
        16== lpFormat->wBitsPerSample)
    {
        pPlaceFn = Place44kHz16Mono;
        dwBytesPerXLate = 8 * 11025;
    }
    else
    // 11kHz 16 bit stereo
    //
    if (2 == lpFormat->nChannels &&
        11025 == lpFormat->nSamplesPerSec &&
        44100 == lpFormat->nAvgBytesPerSec &&
        4 == lpFormat->nBlockAlign &&
        16 == lpFormat->wBitsPerSample)
    {
        pPlaceFn = Place11kHz16Stereo;
        dwBytesPerXLate = 4 * 11025;
    }
    else
    // 22kHz 16 bit stereo
    //
    if (2 == lpFormat->nChannels &&
        22050 == lpFormat->nSamplesPerSec &&
        88200 == lpFormat->nAvgBytesPerSec &&
        4 == lpFormat->nBlockAlign &&
        16 == lpFormat->wBitsPerSample)
    {
        pPlaceFn = Place22kHz16Stereo;
        dwBytesPerXLate = 8 * 11025;
    }
    else
    // 44kHz 16 bit stereo
    //
    if (2 == lpFormat->nChannels &&
        44100 == lpFormat->nSamplesPerSec &&
        176400 == lpFormat->nAvgBytesPerSec &&
        4 == lpFormat->nBlockAlign &&
        16 == lpFormat->wBitsPerSample)
    {
        pPlaceFn = Place44kHz16Stereo;
        dwBytesPerXLate = 16 * 11025;
    }
    else
    // 48kHz 8 bit mono
    //
    if (1 == lpFormat->nChannels &&
        48000 == lpFormat->nSamplesPerSec &&
        48000 == lpFormat->nAvgBytesPerSec &&
        1 == lpFormat->nBlockAlign &&
        8 == lpFormat->wBitsPerSample)
    {
        pPlaceFn = Place48kHz8Mono;
        dwBytesPerXLate = 48000;
    } else
    // 48kHz 8 bit stereo
    //
    if (2 == lpFormat->nChannels &&
        48000 == lpFormat->nSamplesPerSec &&
        96000 == lpFormat->nAvgBytesPerSec &&
        2 == lpFormat->nBlockAlign &&
        8 == lpFormat->wBitsPerSample)
    {
        pPlaceFn = Place48kHz8Stereo;
        dwBytesPerXLate = 2 * 48000;
    } else
    // 48kHz 16 bit mono
    //
    if (1 == lpFormat->nChannels &&
        48000 == lpFormat->nSamplesPerSec &&
        96000 == lpFormat->nAvgBytesPerSec &&
        2 == lpFormat->nBlockAlign &&
        16 == lpFormat->wBitsPerSample)
    {
        pPlaceFn = Place48kHz16Mono;
        dwBytesPerXLate = 2 * 48000;
    } else
    // 48kHz 16 bit stereo
    //
    if (2 == lpFormat->nChannels &&
        48000 == lpFormat->nSamplesPerSec &&
        192000 == lpFormat->nAvgBytesPerSec &&
        4 == lpFormat->nBlockAlign &&
        16 == lpFormat->wBitsPerSample)
    {
        pPlaceFn = Place48kHz16Stereo;
        dwBytesPerXLate = 4 * 48000;
    } else
    {
    // fall in an error
    //
        TRC(ALV, "waveOpen: unsupported format requested\n");
        TRC(ALV, "waveOpen: FormatTag - %d\n", lpFormat->wFormatTag);
        TRC(ALV, "waveOpen: Channels - %d\n", lpFormat->nChannels);
        TRC(ALV, "waveOpen: SamplesPerSec - %d\n", lpFormat->nSamplesPerSec);
        TRC(ALV, "waveOpen: AvgBytesPerSec - %d\n", lpFormat->nAvgBytesPerSec);
        TRC(ALV, "waveOpen: BlockAlign - %d\n", lpFormat->nBlockAlign);
        TRC(ALV, "waveOpen: BitsPerSample - %d\n", lpFormat->wBitsPerSample);

        rv = WAVERR_BADFORMAT;
        goto exitpt;
    }

    // validate the flags
    //
    if (0 != (dwFlags & WAVE_FORMAT_QUERY))
    {
        // this was only a query
        TRC(ALV, "waveOpen: WAVE_FORMAT_QUERY\n");
        rv = MMSYSERR_NOERROR;
        goto exitpt;
    }
    dwProbe = ~(WAVE_ALLOWSYNC |
                CALLBACK_EVENT | 
                CALLBACK_FUNCTION |
                CALLBACK_WINDOW
            );


    if (0 != (dwFlags & dwProbe))
    {
        TRC(ERR, "waveOpen: unsupported flags required: 0x%x\n",
                dwFlags);
        rv = MMSYSERR_NOTSUPPORTED;
        goto exitpt;
    }

    //  Check that the remote side is there
    //
    if ( AudioRedirDisabled() ||
        (    !_waveCheckSoundAlive() && 
             g_hWaitToInitialize == NULL ))
    {
        TRC(ALV, "waveOpen: No remote sound\n");
        rv = MMSYSERR_NODRIVER;
        goto exitpt;
    }

    //  Allocate the context structure
    //
    pWaveOut = TSMALLOC(sizeof(*pWaveOut));
    if (NULL == pWaveOut)
    {
        TRC(ERR, "waveOpen: Can't allocate %d bytes\n", sizeof(*pWaveOut));
        rv = MMSYSERR_NOMEM;
        goto exitpt;
    }
    memset(pWaveOut, 0, sizeof(*pWaveOut));

    // fill the context
    //
    pWaveOut->hWave = pWaveOpenDesc->hWave;
    pWaveOut->dwOpenFlags = dwFlags;
    pWaveOut->dwCallback = pWaveOpenDesc->dwCallback;
    pWaveOut->dwInstance = pWaveOpenDesc->dwInstance;

    pWaveOut->lpfnPlace = pPlaceFn;
    pWaveOut->dwXlateRate = dwBytesPerXLate;

    pWaveOut->Format_nBlockAlign = lpFormat->nBlockAlign;
    pWaveOut->Format_nAvgBytesPerSec = lpFormat->nAvgBytesPerSec;
    pWaveOut->Format_nChannels   = lpFormat->nChannels;

    if ( NULL != g_Stream )
        pWaveOut->cLastStreamPosition = g_Stream->cLastBlockQueued;
    else
        pWaveOut->cLastStreamPosition = 0;

    pWaveOut->hNoDataEvent = CreateEvent(NULL, TRUE, TRUE, NULL);

    if (NULL == pWaveOut->hNoDataEvent)
    {
        TRC(ERR, "waveOpen: can't create event\n");
        goto exitpt;
    }
    
    *ppWaveOut = pWaveOut;

    if ( NULL != g_hWaitToInitialize )
    {
        pWaveOut->bDelayed = TRUE;
    }

    // add this context to the global queue
    //
    ENTER_CRIT;
    pWaveOut->lpNext = g_pAllWaveOut;
    g_pAllWaveOut = pWaveOut;
    LEAVE_CRIT;

    waveCallback(pWaveOut, WOM_OPEN, 0);

    rv = MMSYSERR_NOERROR;

exitpt:

    if (MMSYSERR_NOERROR != rv)
    {
        if (pWaveOut)
        {
            if (NULL != pWaveOut->hNoDataEvent)
                CloseHandle(pWaveOut->hNoDataEvent);

            TSFREE(pWaveOut);
        }
    }
    return rv;
}
    
/*
 *  Function:
 *      waveGetWaveOutDeviceCaps
 *
 *  Description:
 *      The user requests for device capabilities
 *
 *  Parameters:
 *      pWaveOut    - our context
 *      pWaveOutCaps- supported capabilites
 *      dwWaveOutCapsSize - the sizeof the parameter above
 *
 */
DWORD
waveGetWaveOutDeviceCaps(
    PWAVEOUTCTX     pWaveOut,
    LPWAVEOUTCAPS   pWaveOutCaps,
    DWORD_PTR       dwWaveOutCapsSize
    )
{
    DWORD rv = MMSYSERR_ERROR;

    //  Parameters check
    //
    if (dwWaveOutCapsSize < sizeof(*pWaveOutCaps))
    {
        TRC(ERR, "waveGetWaveOutDeviceCaps: invalid size of WAVEOUTCAPS, expect %d, received %d\n",
            sizeof(*pWaveOutCaps), dwWaveOutCapsSize);
        rv = MMSYSERR_INVALPARAM;
        goto exitpt;
    }

    pWaveOutCaps->wMid = MM_MICROSOFT;
    pWaveOutCaps->wPid = MM_MSFT_GENERIC_WAVEOUT;
    pWaveOutCaps->vDriverVersion = TSSND_DRIVER_VERSION;
    LoadString( g_hDllInst, 
                IDS_DRIVER_NAME, 
                pWaveOutCaps->szPname, 
                sizeof( pWaveOutCaps->szPname ) / sizeof( pWaveOutCaps->szPname[0] ));
    pWaveOutCaps->dwFormats = WAVE_FORMAT_1M08 | WAVE_FORMAT_1M16 |
                              WAVE_FORMAT_1S08 | WAVE_FORMAT_1S16 |
                              WAVE_FORMAT_2M08 | WAVE_FORMAT_2M16 |
                              WAVE_FORMAT_2S08 | WAVE_FORMAT_2S16 |
                              WAVE_FORMAT_4M08 | WAVE_FORMAT_4S08 |
                              WAVE_FORMAT_4M16 | WAVE_FORMAT_4S16;
    pWaveOutCaps->wChannels = 2;

    pWaveOutCaps->dwSupport = WAVECAPS_SAMPLEACCURATE;
    if ( NULL != g_Stream )
    {
        pWaveOutCaps->dwSupport |= (g_Stream->dwSoundCaps & TSSNDCAPS_VOLUME)?
                                    WAVECAPS_VOLUME : 0;
        pWaveOutCaps->dwSupport |= (g_Stream->dwSoundCaps & TSSNDCAPS_PITCH)?
                                    WAVECAPS_PITCH : 0;
    }
    rv = MMSYSERR_NOERROR;

exitpt:
    return rv;
}

/*
 *  Function:
 *      waveSetVolume
 *
 *  Description:
 *      The user requests a new volume
 *
 *  Parameters:
 *      pWaveOut    - context
 *      dwVolume    - new volume
 *
 */
DWORD
waveSetVolume(
    PWAVEOUTCTX pWaveOut,
    DWORD       dwVolume
    )
{
    DWORD rv = MMSYSERR_ERROR;

    //  Parameters check
    //

    //  in case of mono, adjust the volume to stereo
    //
    if ( NULL != pWaveOut && 
         1 == pWaveOut->Format_nChannels )
    {
        dwVolume = ( dwVolume & 0xffff ) | 
                   (( dwVolume & 0xffff ) << 16 );
    }

    // Set the new volume in the sound stream
    // 
    if (!_waveAcquireStream())
    {
        TRC(ERR, "waveSetVolume: can't acquire stream mutex\n");
        goto exitpt;
    }

    //  Check that volume control
    // is supported on the remote
    //
    if (0 != (g_Stream->dwSoundCaps & TSSNDCAPS_VOLUME))
    {
        g_Stream->dwVolume      = dwVolume;
        g_Stream->bNewVolume    = TRUE;
    }
    else
        rv = MMSYSERR_NOTSUPPORTED;

    _waveReleaseStream();

    if (MMSYSERR_NOTSUPPORTED == rv)
    {
        TRC(INF, "waveSetVolume: volume control not supported\n");
        goto exitpt;
    }

    // kick the sndio thread
    //
    if (g_hDataReadyEvent)
        SetEvent(g_hDataReadyEvent);
    else
        TRC(WRN, "waveSetVolume: g_hDataReadyEvent is NULL\n");

    rv = MMSYSERR_NOERROR;

exitpt:
    return rv;
}

/*
 *  Function:
 *      waveGetVolume
 *
 *  Description:
 *      The user queries for the current volume level
 *
 *  Parameters:
 *      pWaveOut    - context
 *      pdwVolume   - [out] current volume
 *
 */
DWORD
waveGetVolume(
    PWAVEOUTCTX pWaveOut,
    DWORD       *pdwVolume
    )
{
    DWORD rv = MMSYSERR_ERROR;

    //  Parameters check
    //

    if (NULL == pdwVolume)
    {
        TRC(ERR, "pdwVolume is NULL\n");
        rv = MMSYSERR_INVALPARAM;
        goto exitpt;
    }

    if (!_waveAcquireStream())
    {
        TRC(ERR, "waveGetVolume: can't acquire stream mutex\n");
        goto exitpt;
    }

    //  Check that volume control
    // is supported on the remote
    //
    if (0 != (g_Stream->dwSoundCaps & TSSNDCAPS_VOLUME))
        *pdwVolume = g_Stream->dwVolume;
    else
        rv = MMSYSERR_NOTSUPPORTED;

    _waveReleaseStream();

    if (MMSYSERR_NOTSUPPORTED == rv)
    {
        TRC(INF, "waveGetVolume: volume control not supported\n");
        goto exitpt;
    }

    rv = MMSYSERR_NOERROR;

exitpt:
    return rv;

}

DWORD
waveSetMute(
    PWAVEOUTCTX pWaveOut,
    BOOL        fMute
    )
{
    DWORD rv = MMSYSERR_ERROR;

    if ( NULL == g_Stream)
    {
        TRC(ERR, "waveGetVolume: stream is NULL\n");
        goto exitpt;
    }

    if ( fMute )
    {
        g_Stream->dwSoundFlags      |= TSSNDFLAGS_MUTE;
    } else {
        g_Stream->dwSoundFlags      &= ~TSSNDFLAGS_MUTE;
    }

    rv = MMSYSERR_NOERROR;

exitpt:
    return rv;
}

DWORD
waveGetMute(
    PWAVEOUTCTX pWaveOut,
    DWORD       *pfdwMute
    )
{
    DWORD rv = MMSYSERR_ERROR;

    if ( NULL == g_Stream)
    {
        TRC(ERR, "waveGetVolume: stream is NULL\n");
        goto exitpt;
    }

    *pfdwMute = ( 0 != ( g_Stream->dwSoundFlags & TSSNDFLAGS_MUTE ));

    rv = MMSYSERR_NOERROR;

exitpt:
    return rv;
}

/*
 *  Function:
 *      waveSetPitch
 *
 *  Description:
 *      Sets new pitch level
 *
 *  Parameters:
 *      pWaveOut    - context
 *      dwPitch     - new pitch level
 *
 */
DWORD
waveSetPitch(
    PWAVEOUTCTX pWaveOut,
    DWORD       dwPitch
    )
{
    DWORD rv = MMSYSERR_ERROR;

    //  Parameters check
    //

    // Set the new volume in the sound stream
    // 
    if (!_waveAcquireStream())
    {
        TRC(ERR, "waveSetPitch: can't acquire stream mutex\n");
        goto exitpt;
    }

    //  Check that pitch control
    // is supported on the remote
    //
    if (0 != (g_Stream->dwSoundCaps & TSSNDCAPS_PITCH))
    {
        g_Stream->dwPitch       = dwPitch;
        g_Stream->bNewPitch     = TRUE;
    }
    else
        rv = MMSYSERR_NOTSUPPORTED;

    _waveReleaseStream();

    if (MMSYSERR_NOTSUPPORTED == rv)
    {
        TRC(INF, "waveSetPitch: pitch control not supported\n");
        goto exitpt;
    }

    // kick the sndio thread
    //
    if (g_hDataReadyEvent)
        SetEvent(g_hDataReadyEvent);
    else
        TRC(WRN, "waveSetPitch: g_hDataReadyEvent is NULL\n");

    rv = MMSYSERR_NOERROR;

exitpt:
    return rv;
}

/*
 *  Function:
 *      waveGetPitch
 *
 *  Description:
 *      Queries for the current pitch level
 *
 *  Parameters:
 *      pWaveOut    - context
 *      pdwPitch    - [out] current pitch level
 *
 */
DWORD
waveGetPitch(
    PWAVEOUTCTX pWaveOut,
    DWORD       *pdwPitch
    )
{
    DWORD rv = MMSYSERR_ERROR;

    //  Parameters check
    //

    if (NULL == pdwPitch)
    {
        TRC(ERR, "pdwPitch is NULL\n");
        rv = MMSYSERR_INVALPARAM;
        goto exitpt;
    }

    if (!_waveAcquireStream())
    {
        TRC(ERR, "waveGetPitch: can't acquire stream mutex\n");
        goto exitpt;
    }

    //  Check that pitch control
    // is supported on the remote
    //
    if (0 != (g_Stream->dwSoundCaps & TSSNDCAPS_PITCH))
        *pdwPitch = g_Stream->dwPitch;
    else
        rv = MMSYSERR_NOTSUPPORTED;

    _waveReleaseStream();

    if (MMSYSERR_NOTSUPPORTED == rv)
    {
        TRC(INF, "waveGetPitch: pitch control not supported\n");
        goto exitpt;
    }

    rv = MMSYSERR_NOERROR;

exitpt:
    return rv;

}

/*
 *  Function:
 *      waveGetNumDevs
 *
 *  Description:
 *      we have only one device
 *
 */
DWORD
waveGetNumDevs(
    VOID
    )
{
    return 1;
}
    
/*
 *  Function:
 *      waveClose
 *
 *  Description:
 *      Wait for all blocks to complete and then close
 *
 *  Parameters:
 *      pWaveOut    - context
 *
 */
DWORD
waveClose(
    PWAVEOUTCTX pWaveOut
    )
{
    DWORD       rv = MMSYSERR_ERROR;
    DWORD       syserr;
    PWAVEOUTCTX pPrevWaveOut;
    PWAVEOUTCTX pWaveOutIter;

    if (NULL == pWaveOut)
    {
        TRC(ERR, "waveClose: invalid device handle\n");
        rv = MMSYSERR_INVALHANDLE;
        goto exitpt;
    }

    //
    //  test if we are still playing
    //
    if ( pWaveOut->bPaused && 0 != pWaveOut->lNumberOfBlocksPlaying )
    {
        TRC(INF, "waveClose: WAVERR_STILLPLAYING\n");
        rv = WAVERR_STILLPLAYING;
        goto exitpt;
    }

    if ( NULL != pWaveOut->hNoDataEvent)
    {
        DWORD dwTimeout;

        if ( pWaveOut->bDelayed )
        {
            TRC( INF, "waveClose: delaying 15 seconds\n" );
            dwTimeout = 15000;
        } else {
            dwTimeout = 0;
        }

        syserr = WaitForSingleObject(pWaveOut->hNoDataEvent, dwTimeout);

        if ( WAIT_TIMEOUT == syserr )
        {
            TRC(INF, "waveClose: WAVERR_STILLPLAYING\n");
            rv = WAVERR_STILLPLAYING;
            goto exitpt;
        }
    }

    //
    //  we may end with some data in the last block in the stream
    //  if the "queued" mark hasn't change, increment it and kick the io
    //  thread to play this block
    //  to test this play very-very short files
    //  shorter than TSSND_BLOCKSIZE / (TSSND_NATIVE_BLOCKALIGN * 
    //  TSSND_NATIVE_SAMPLERATE) seconds
    //
    //
    //
    if (_waveAcquireStream())
    {
        if (g_Stream->cLastBlockQueued == pWaveOut->cLastStreamPosition &&
            0 != pWaveOut->dwLastStreamOffset)
        {
            g_Stream->cLastBlockQueued ++;
            //
            //  kick the io thread
            //
            if (g_hDataReadyEvent)
                SetEvent(g_hDataReadyEvent);
            else
                TRC(WRN, "waveClose: g_hDataReadyEvent is NULL\n");
        }
        _waveReleaseStream();
    }


    if (NULL != pWaveOut->hNoDataEvent)
        CloseHandle(pWaveOut->hNoDataEvent);

    // remove this context from the global queue
    //
    ENTER_CRIT;

    pPrevWaveOut = NULL;
    pWaveOutIter = g_pAllWaveOut;

    while ( NULL != pWaveOutIter && 
            pWaveOutIter != pWaveOut)
    {
        pPrevWaveOut = pWaveOutIter;
        pWaveOutIter = pWaveOutIter->lpNext;
    }

    ASSERT(pWaveOut == pWaveOutIter);

    if (pWaveOut == pWaveOutIter)
    {
        if (pPrevWaveOut)
            pPrevWaveOut->lpNext = pWaveOut->lpNext;
        else
            g_pAllWaveOut = pWaveOut->lpNext;
    }
    LEAVE_CRIT;

    waveCallback(pWaveOut, WOM_CLOSE, 0);

    TSFREE(pWaveOut);

    rv = MMSYSERR_NOERROR;

exitpt:
    return rv;
}

/*
 *  Function:
 *      waveWrite
 *
 *  Description:
 *      Play a block of data
 *
 *  Parameters:
 *      pWaveOut    - context
 *      pWaveHdr    - the block
 *      dwWaveHdrSize - size of the above parameter
 *
 */
DWORD
waveWrite(
    PWAVEOUTCTX pWaveOut,
    PWAVEHDR    pWaveHdr,
    DWORD_PTR   dwWaveHdrSize
    )
{
    SNDWAVE WaveData;
    DWORD rv = MMSYSERR_ERROR;
    PWAVEHDR    pPrevHdr;
    PWAVEHDR    pLastHdr;

    // Parameters check
    //
    if (NULL == pWaveOut)
    {
        TRC(ERR, "waveWrite: invalid device handle\n");
        rv = MMSYSERR_INVALHANDLE;
        goto exitpt;
    }

    if (sizeof(*pWaveHdr) != dwWaveHdrSize)
    {
        TRC(ERR, "waveWrite: invalid size for dwWaveHdrSize\n");
        rv = MMSYSERR_INVALPARAM;
        goto exitpt;
    }

    //
    //  check the buffer size alignment
    //
    if ( 0 != pWaveOut->Format_nBlockAlign &&
         0 != pWaveHdr->dwBufferLength % pWaveOut->Format_nBlockAlign )
    {
        TRC( ERR, "wavePrepare: size unaligned\n" );
        rv = MMSYSERR_INVALPARAM;
        goto exitpt;
    }

    if (IsBadReadPtr( pWaveHdr->lpData, pWaveHdr->dwBufferLength ))
    {
        TRC( ERR, "wavePrepare: buffer unreadable\n" );
        rv = MMSYSERR_INVALPARAM;
        goto exitpt;
    }

#ifdef  _WIN64
    //
    //  check for proper alignment
    //
    if ( 0 != pWaveOut->Format_nBlockAlign &&
         2 == pWaveOut->Format_nBlockAlign / pWaveOut->Format_nChannels &&
         0 != (( (LONG_PTR)pWaveHdr->lpData ) & 1 ))
    {
        TRC( ERR, "wavePrepare: buffer unaligned\n" );
        rv = MMSYSERR_INVALPARAM;
        goto exitpt;
    }
#endif

    //  pass this header to the mixer thread
    //
    if (NULL == g_hMixerEvent)
    {
        TRC(ERR, "waveWrite: g_hMixerEvent is NULL\n");
        // confirm that the block is done
        //
        waveCallback(pWaveOut, WOM_DONE, (DWORD_PTR)pWaveHdr);
        goto exitpt;
    }

    // add the header to the queue
    //
    ENTER_CRIT;

    //  find the last header
    //
    pPrevHdr = NULL;
    pLastHdr = pWaveOut->pFirstWaveHdr;
    while (pLastHdr)
    {
        //
        //  VERY VERY VERY IMAPORTANT !!!
        //  check if the app trys to add a header twice
        //  (WINAMP does)
        //
        if (pLastHdr == pWaveHdr)
        {
            TRC(ERR, "waveWrite: equal headers found, aborting\n");
            goto abort_waveWrite;
        }

        pPrevHdr = pLastHdr;
        pLastHdr = pLastHdr->lpNext;
    }

    pWaveHdr->lpNext = NULL;
    pWaveHdr->reserved = (DWORD_PTR)pWaveOut;
    pWaveHdr->dwFlags &= ~(WHDR_DONE);
    pWaveHdr->dwFlags |= WHDR_INQUEUE;

    // add the new header
    //
    if (NULL == pPrevHdr)
    {
        pWaveOut->pFirstWaveHdr = pWaveHdr;
    } else {
        pPrevHdr->lpNext = pWaveHdr;
    }

    InterlockedIncrement(&pWaveOut->lNumberOfBlocksPlaying);

    ResetEvent(pWaveOut->hNoDataEvent);

    //
    // kick the mixer thread
    //
    SetEvent(g_hMixerEvent);

abort_waveWrite:

    LEAVE_CRIT;

    rv = MMSYSERR_NOERROR;

exitpt:

    return rv;
}

/*
 *  Function:
 *      _waveAcquireStream
 *
 *  Description:
 *      Locks down the stream using mutex
 *
 */
BOOL
_waveAcquireStream(
    VOID
    )
{
    BOOL    rv = FALSE;
    DWORD   dwres;

    if (NULL == g_hStream ||
        NULL == g_Stream)
    {
        TRC(ALV, "_waveAcquireStream: the stream handle is NULL\n");
        goto exitpt;
    }

    if (NULL == g_hStreamMutex)
    {
        TRC(FATAL, "_waveAcquireStreamMutex: the stream mutex is NULL\n");
        goto exitpt;
    }

    dwres = WaitForSingleObject(g_hStreamMutex, DEFAULT_VC_TIMEOUT);
    if (WAIT_TIMEOUT == dwres ||
        WAIT_ABANDONED == dwres )
    {
        TRC(ERR, "_waveAcquireStreamMutex: "
                 "timed out waiting for the stream mutex or owner crashed=%d\n", dwres );
        //
        // possible app crash
        //
        ASSERT(0);
        goto exitpt;
    }

    rv = TRUE;

exitpt:
    return rv;
}

BOOL
_waveReleaseStream(
    VOID
    )
{
    BOOL rv = TRUE;

    ASSERT(NULL != g_hStream);
    ASSERT(NULL != g_Stream);
    ASSERT(NULL != g_hStreamMutex);

    if (!ReleaseMutex(g_hStreamMutex))
        rv = FALSE;

    return rv;
}

/*
 *  Function:
 *      _waveCheckSoundAlive
 *
 *  Description:
 *      Chacks if the client can play audio
 *
 */
BOOL
_waveCheckSoundAlive(
    VOID
    )
{
    BOOL rv = FALSE;

    rv = ( NULL != g_Stream && 0 != (g_Stream->dwSoundCaps & TSSNDCAPS_ALIVE));

    return rv;
}

BOOL
AudioRedirDisabled(
    VOID
    )
{
    BOOL                    fSuccess = FALSE;
    static BOOL             s_fChecked = FALSE;
    static HANDLE           s_hRDPEvent = NULL;
    static WINSTATIONCONFIG s_config;
    ULONG                   returnedLength;

    if ( s_fChecked )
    {
        return s_config.User.fDisableCam;
    }

    //
    //  we need special case for session 0
    //  because winlogon never exits there
    //
    if ( 0 == NtCurrentPeb()->SessionId )
    {
        DWORD dw;
        if ( NULL == s_hRDPEvent )
        {

            s_hRDPEvent = OpenEvent( SYNCHRONIZE, FALSE, L"Global\\RDPAudioDisabledEvent" );
            if ( NULL == s_hRDPEvent )
            {
                TRC( ERR, "failed to open Global\\RDPAudioDisabledEvent [%d]\n", GetLastError());
                return FALSE;
            }
        }
        
        dw = WaitForSingleObject( s_hRDPEvent, 0 );
        return ( WAIT_OBJECT_0 == dw );
    }

    //
    //  check if the loader lock is held
    //  if true, we'll fail to do the RPC call
    //
    if ( NtCurrentTeb()->ClientId.UniqueThread !=
         ((PRTL_CRITICAL_SECTION)(NtCurrentPeb()->LoaderLock))->OwningThread )
    {
        fSuccess = WinStationQueryInformation(NULL, LOGONID_CURRENT,
                    WinStationConfiguration, &s_config,
                    sizeof(s_config), &returnedLength);
        if ( fSuccess )
        {
            s_fChecked = TRUE;
        }
    }

    return ( !fSuccess || s_config.User.fDisableCam );
}


/*
 *  Create the mixer thread
 *
 *
 */
BOOL
_EnableMixerThread(
    VOID
    )
{
    DWORD dwThreadId;

    ENTER_CRIT;
    
    if ( AudioRedirDisabled() )
    {
        TRC( ALV, "TS Audio redirection is disabled\n" );
        goto exitpt;
    }

    if ( !g_bPersonalTS && 0 != NtCurrentPeb()->SessionId )
    {
        if ( NULL == g_pAllWaveOut )
        {
            //
            //  not yet
            //
            goto exitpt;
        }
    }

    if ( NULL != g_hMixerThread )
    {
        DWORD dw = WaitForSingleObject( g_hMixerThread, 0 );
        if ( WAIT_OBJECT_0 == dw )
        {
            CloseHandle( g_hMixerThread );
            g_hMixerThread = NULL;
        }
    }

    if ( NULL == g_hMixerThread )
    {
        g_bMixerRunning = TRUE;

        g_hMixerThread = CreateThread(
                    NULL,
                    0,
                    waveMixerThread,
                    NULL,
                    0,
                    &dwThreadId
            );
    }

    if (NULL == g_hMixerThread)
    {
        TRC(FATAL, "DriverProc: can't start mixer thread\n");
    }

exitpt:
    LEAVE_CRIT;

    return ( NULL != g_hMixerThread );
}

/*
 *  called on waveOutClose, if there are no more workers to play, close the mixer thread
 *
 */
VOID
_DerefMixerThread(
    VOID
    )
{
    HANDLE hMixerThread;

    //
    //  don't close the mixer thread on Pro and on session 0 on servers
    //
    if (g_bPersonalTS || 0 == NtCurrentPeb()->SessionId)
    {
        goto exitpt;
    }

    if ( NULL == g_hMixerEvent )
    {
        TRC( ERR, "_DerefMixerThread: no mixer event\n" );
        goto exitpt;
    }

    ENTER_CRIT;
    if ( NULL != g_pAllWaveOut )
    {
        //
        //  not yet
        //
        LEAVE_CRIT;
        goto exitpt;
    }

    hMixerThread = g_hMixerThread;
    g_hMixerThread = NULL;
    g_bMixerRunning = FALSE;
    LEAVE_CRIT;

    SetEvent( g_hMixerEvent );
    WaitForSingleObject(hMixerThread, INFINITE);
    CloseHandle( hMixerThread );

exitpt:
    ;
}

/*
 *  Function:
 *      _waveMixerWriteData
 *
 *  Description:
 *      Mixes blocks of data to the stream
 *
 */
VOID
_waveMixerWriteData(
    VOID
    )
{
    //  this call is made within the mixer
    //  thread context
    //
    UINT        uiEmptyBlocks;
    PWAVEHDR    pWaveHdr;
    PWAVEHDR    pPrevHdr;
    PWAVEOUTCTX pWaveOut;
    DWORD       dwStartPos;
    DWORD       dwSize1;
    DWORD       dwSize2;
    DWORD       dwFitBufferLength;
    DWORD       dwFitDest;
    DWORD       dwBuffDisp;
    BOOL        bKickStream = FALSE;

    ENTER_CRIT;

    if (NULL == g_pAllWaveOut)
    {
        TRC(ALV, "_waveWriteData: WaveOut queue is empty\n");
        goto exitpt;
    }

    if (NULL == g_hDataReadyEvent)
    {
        TRC(ERR, "_waveWriteData: g_hStreamDataReady is NULL\n");
        goto exitpt;
    }

    if (!_waveAcquireStream())
    {
        TRC(ERR, "_waveWriteData: can't acquire the stream mutex\n");
        goto exitpt;
    }

    if (  0 == (g_Stream->dwSoundCaps & TSSNDCAPS_ALIVE) ||
          0 != ( g_Stream->dwSoundFlags & TSSNDFLAGS_MUTE ))
    {
        // no play here
        _waveReleaseStream();
        goto exitpt;
    }

    for (
         pWaveOut = g_pAllWaveOut; 
         NULL != pWaveOut; 
         pWaveOut = pWaveOut->lpNext
        )
    {

      for( 
           pPrevHdr = NULL, pWaveHdr = pWaveOut->pFirstWaveHdr;
           NULL != pWaveHdr;
           /* nothing */
         )
      {

        // if this stream is paused advance to the next one
        //
        if (pWaveOut->bPaused)
            break;

        // check if we have to append data to a buffer
        // from previous call
        //
        if ((BYTE)(pWaveOut->cLastStreamPosition - g_Stream->cLastBlockSent) >
            TSSND_MAX_BLOCKS ||
            (BYTE)(g_Stream->cLastBlockQueued - 
                pWaveOut->cLastStreamPosition) >
                TSSND_MAX_BLOCKS)
        {
            pWaveOut->cLastStreamPosition = g_Stream->cLastBlockSent;
            pWaveOut->dwLastStreamOffset = 0;

            TRC(ALV, "_waveWriteData: reseting the stream position\n");
        }

        //  the empty blocks are from "LastStreamPosition" to "Confirmed"
        //  ( "Confirmed" to "LastStreamPosition" are preserved )
        //
        uiEmptyBlocks = (BYTE)
                        (g_Stream->cLastBlockSent + TSSND_MAX_BLOCKS -
                        pWaveOut->cLastStreamPosition);

        if (uiEmptyBlocks > TSSND_MAX_BLOCKS)
        {
            TRC(FATAL, "too many empty blocks:\n");
            TRC(FATAL, "cLastBlockQueued=%d\n", g_Stream->cLastBlockQueued);
            TRC(FATAL, "cLastBlockSent =%d\n", g_Stream->cLastBlockSent);
            TRC(FATAL, "cLastBlockConfirmed%d\n", g_Stream->cLastBlockConfirmed);
            TRC(FATAL, "cLastStreamPosition=%d\n", pWaveOut->cLastStreamPosition);
            ASSERT(0);
            break;
        }

        // if everything is full, go to bed
        //
        if (0 == uiEmptyBlocks)
        {
            TRC(ALV, "_waveMixerWriteData: stream is full\n");
            break;
        }

        //  WHAT IF THE EMPTY SPACE IS SMALLER THAN THE DATA IN THE HEADER
        //
        dwFitBufferLength = (uiEmptyBlocks * TSSND_BLOCKSIZE -
                                pWaveOut->dwLastStreamOffset);

        dwFitDest = MulDiv(
                        pWaveHdr->dwBufferLength - 
                            pWaveOut->dwLastHeaderOffset,
                        TSSND_NATIVE_XLATERATE,
                        pWaveOut->dwXlateRate
                    );

        dwFitDest &= ~( TSSND_NATIVE_BLOCKALIGN - 1 );

        if ( dwFitBufferLength < dwFitDest )
        {
            dwFitDest = MulDiv(
                            dwFitBufferLength,
                            pWaveOut->dwXlateRate,
                            TSSND_NATIVE_XLATERATE
                        );

            dwFitDest &= ~( pWaveOut->Format_nBlockAlign - 1 );
        } else {
            dwFitBufferLength = dwFitDest;

            dwFitDest = pWaveHdr->dwBufferLength - pWaveOut->dwLastHeaderOffset;
        }

        // place the data, because of the round buffer,
        // this could be a two step process
        //
//        TRC( INF, "Filling block # %d, offset=0x%x\n", pWaveOut->cLastStreamPosition, pWaveOut->dwLastStreamOffset );
        dwStartPos = (pWaveOut->cLastStreamPosition
                            % TSSND_MAX_BLOCKS) *
                            TSSND_BLOCKSIZE + 
                            pWaveOut->dwLastStreamOffset;

        if ( dwStartPos + dwFitBufferLength >
             TSSND_TOTALSTREAMSIZE)
        {
            dwSize1 = (TSSND_TOTALSTREAMSIZE - dwStartPos) / 
                                TSSND_NATIVE_BLOCKALIGN;
            dwSize2 = dwFitBufferLength / TSSND_NATIVE_BLOCKALIGN -
                        dwSize1;
        } else {
            dwSize1 = dwFitBufferLength / TSSND_NATIVE_BLOCKALIGN;
            dwSize2 = 0;
        }

        pWaveOut->lpfnPlace(g_Stream->pSndData + 
               dwStartPos,
               ((LPSTR)pWaveHdr->lpData) + pWaveOut->dwLastHeaderOffset,
               dwSize1);

        dwBuffDisp = MulDiv(
                        dwSize1 * TSSND_NATIVE_BLOCKALIGN,
                        pWaveOut->dwXlateRate,
                        TSSND_NATIVE_XLATERATE
                    );

        dwBuffDisp &= ~( pWaveOut->Format_nBlockAlign - 1 );

        pWaveOut->lpfnPlace(g_Stream->pSndData,
               ((LPSTR)pWaveHdr->lpData) + pWaveOut->dwLastHeaderOffset +
                   dwBuffDisp,
               dwSize2);

        //  Calculate the new position
        //
        pWaveOut->dwLastStreamOffset   += dwFitBufferLength;
        pWaveOut->cLastStreamPosition  += (BYTE)(pWaveOut->dwLastStreamOffset / 
                                            TSSND_BLOCKSIZE);
        pWaveOut->dwLastStreamOffset   %= TSSND_BLOCKSIZE;

        pWaveOut->dwLastHeaderOffset += dwFitDest;

        ASSERT(pWaveOut->dwLastHeaderOffset <= pWaveHdr->dwBufferLength);

        //
        //  check if the buffer is completed
        //
        if ( 0 == MulDiv(
              ( pWaveHdr->dwBufferLength - pWaveOut->dwLastHeaderOffset ),
                TSSND_NATIVE_XLATERATE,
                pWaveOut->dwXlateRate))
        {

            pWaveOut->dwLastHeaderOffset = 0;

            // remove this header from the queue
            //
            if (NULL == pPrevHdr)
                pWaveOut->pFirstWaveHdr = pWaveHdr->lpNext;
            else
                pPrevHdr->lpNext = pWaveHdr->lpNext;

            pWaveHdr->lpNext = NULL;
            //
            //  save the current stream mark
            //
            pWaveHdr->reserved = g_Stream->cLastBlockQueued;

            //  add it to the ready queue
            //
            if (NULL == pWaveOut->pLastReadyHdr)
            {
                pWaveOut->pFirstReadyHdr = pWaveHdr;
                pWaveOut->pLastReadyHdr  = pWaveHdr;
            } else {
                pWaveOut->pLastReadyHdr->lpNext = pWaveHdr;
                pWaveOut->pLastReadyHdr = pWaveHdr;
            }

            //  reset pPrevHdr and pWaveHdr
            //
            pPrevHdr = NULL;
            pWaveHdr = pWaveOut->pFirstWaveHdr;
        } else {
            //
            //  Advance to the next header
            //
            pPrevHdr = pWaveHdr;
            pWaveHdr = pWaveHdr->lpNext;
        }

        //
        // kick the stream thread
        //
        if ((BYTE)(pWaveOut->cLastStreamPosition - g_Stream->cLastBlockQueued) < 
            _NEG_IDX)
        {

            bKickStream = TRUE;
            //
            // move the "queued" mark
            //
            g_Stream->cLastBlockQueued = pWaveOut->cLastStreamPosition;
        }

      }
    }

    if (bKickStream)
    {
        //
        //  kick the io
        //
        SetEvent(g_hDataReadyEvent);
    }

    _waveReleaseStream();

exitpt:

    //  Now for all "done" buffers, send the callback
    //

    for (pWaveOut = g_pAllWaveOut;
         NULL != pWaveOut;
         pWaveOut = pWaveOut->lpNext)
    {
      for (pPrevHdr = NULL, pWaveHdr = pWaveOut->pFirstReadyHdr;
           NULL != pWaveHdr;
           /* nothing */ )
      {

        if ( (INT)((CHAR)(g_Stream->cLastBlockQueued -
                   PtrToLong((PVOID)pWaveHdr->reserved))) >= 0)
        {
        // this block was confirmed, proceed with
        // extracting it and notification
        //
            if (NULL != pPrevHdr)
                pPrevHdr->lpNext = pWaveHdr->lpNext;
            else
                pWaveOut->pFirstReadyHdr = pWaveHdr->lpNext;

            if (pWaveHdr == pWaveOut->pLastReadyHdr)
                pWaveOut->pLastReadyHdr = pPrevHdr;

            //
            //  advance the number of samples.
            //  also, remember a time stamp and this block size
            //  in samples, for sample accuracy
            //
            pWaveOut->dwSamples += pWaveHdr->dwBufferLength / 
                                   pWaveOut->Format_nBlockAlign;

            //
            //  clear this buffer from the pending list
            //
            if (0 == InterlockedDecrement(&pWaveOut->lNumberOfBlocksPlaying))
            {
                SetEvent(pWaveOut->hNoDataEvent);
            }

            // notify the app
            //

            // mark the buffer as ready
            //
            pWaveHdr->dwFlags |= WHDR_DONE;
            pWaveHdr->dwFlags &= ~(WHDR_INQUEUE);
            pWaveHdr->lpNext = NULL;
            pWaveHdr->reserved = 0;

            // confirm that the block is done
            //
            waveCallback(pWaveOut, WOM_DONE, (DWORD_PTR)pWaveHdr);


            // reinitialize the iterators
            //
            if ( NULL == g_pAllWaveOut )
                goto leave_crit;

            pWaveOut = g_pAllWaveOut;

            pPrevHdr = NULL, pWaveHdr = pWaveOut->pFirstReadyHdr;

            if ( NULL == pWaveHdr )
                goto leave_crit;
        } else {

            //  advance the iterators
            //
            pPrevHdr = pWaveHdr;
            pWaveHdr = pWaveHdr->lpNext;
        }
      }
    }

leave_crit:
    LEAVE_CRIT;

}

/*
 *  Function:
 *      _waveMixerPlaySilence
 *
 *  Description:
 *      Simulates play by using sleep
 *
 */
BOOL
_waveMixerPlaySilence(
    VOID
    )
{
    BOOL    rv = FALSE;
    DWORD   dwMinTime;
    DWORD   dwTime;
    DWORD   dwLength;
    PWAVEHDR    pWaveHdr;
    PWAVEOUTCTX pWaveOut;

    //
    //  simulate silent play
    //
    dwMinTime = (DWORD)-1;
    //
    //  find the smallest block waiting and sleep
    //  for the time it has to play
    //
    ENTER_CRIT;
    for (
         pWaveOut = g_pAllWaveOut;
         NULL != pWaveOut;
         pWaveOut = pWaveOut->lpNext
        )
    {
        pWaveHdr = pWaveOut->pFirstWaveHdr;

        if ( NULL == pWaveHdr )
            continue;

        dwLength = pWaveHdr->dwBufferLength - pWaveOut->dwLastHeaderOffset;
        //
        //  time is in miliseconds
        //
        dwTime = dwLength * 1000 / 
            pWaveOut->Format_nAvgBytesPerSec;

        if ( dwMinTime > dwTime )
            dwMinTime = dwTime;
    }
    LEAVE_CRIT;

    //
    //  exit if no block is found
    //
    if ( (DWORD)-1 == dwMinTime )
        goto exitpt;

    if ( 0 == dwMinTime )
        dwMinTime = 1;

    Sleep( dwMinTime );

    //
    //  start confirming
    //
    ENTER_CRIT;
    for (
         pWaveOut = g_pAllWaveOut;
         NULL != pWaveOut;
         pWaveOut = pWaveOut->lpNext
        )
    {
        pWaveHdr = pWaveOut->pFirstWaveHdr;

        if ( NULL == pWaveHdr )
            continue;

        dwLength = pWaveOut->dwLastHeaderOffset;
        dwLength += dwMinTime * pWaveOut->Format_nAvgBytesPerSec / 1000;
        //
        //  align to a block
        //
        dwLength += pWaveOut->Format_nBlockAlign - 1;
        dwLength /= pWaveOut->Format_nBlockAlign;
        dwLength *= pWaveOut->Format_nBlockAlign;

        pWaveOut->dwLastHeaderOffset = dwLength;
        if ( dwLength >= pWaveHdr->dwBufferLength )
        {
            pWaveOut->dwLastHeaderOffset = 0;
            pWaveOut->pFirstWaveHdr = pWaveHdr->lpNext;
            //
            //  this block is "done"
            //  mark the buffer as ready
            //
            pWaveHdr->dwFlags |= WHDR_DONE;
            pWaveHdr->dwFlags &= ~(WHDR_INQUEUE);
            pWaveHdr->lpNext = NULL;
            pWaveHdr->reserved = 0;

            //  increment the position
            //
            pWaveOut->dwSamples += pWaveHdr->dwBufferLength /
                       pWaveOut->Format_nBlockAlign;

            if (0 == InterlockedDecrement(&pWaveOut->lNumberOfBlocksPlaying))
            {
                SetEvent(pWaveOut->hNoDataEvent);
            }

            // confirm that the block is done
            //
            waveCallback(pWaveOut, WOM_DONE, (DWORD_PTR)pWaveHdr);
        }
    }
    LEAVE_CRIT;

    rv = TRUE;

exitpt:
    return rv;
}

/*
 *  Function:
 *      waveMixerThread
 *
 *  Description:
 *      Mixer thread main entry point
 *
 *  Parameters:
 *      pParam  - unused
 *
 */
DWORD
WINAPI
waveMixerThread(
    PVOID   pParam
    )
{
    HANDLE          ahEvents[3];
    PWAVEOUTCTX     pWaveOut;
    HANDLE          hCleanupEvent = NULL;
    DWORD           numEvents;

    //
    //  wait for the sound process to initialize
    //
    if (( NULL == g_Stream ||
          0 == ( g_Stream->dwSoundCaps & TSSNDCAPS_INITIALIZED)) && 
        NULL != g_hWaitToInitialize )
    {
        DWORD dw = WaitForSingleObject( g_hWaitToInitialize,
                                        10 * DEFAULT_VC_TIMEOUT );
        if ( WAIT_OBJECT_0 != dw )
            TRC( ERR, "WaitToInitialize failed\n" );
        else
            TRC( INF, "WaitToInitialize succeeded\n" );

        hCleanupEvent = g_hWaitToInitialize;
        g_hWaitToInitialize = NULL;

        drvEnable();
    } else {
        hCleanupEvent = _CreateInitEvent();
    }

    if (NULL == g_hMixerEvent ||
        NULL == g_hDataReadyEvent)
    {
        TRC(FATAL, "waveMixerThread: no events\n");
        goto exitpt;
    }

    if ( NULL != hCleanupEvent )
    {
        ahEvents[0] = hCleanupEvent;
        ahEvents[1] = g_hMixerEvent;
        ahEvents[2] = g_hStreamIsEmptyEvent;
        numEvents = 3;
    } else {
        ahEvents[0] = g_hMixerEvent;
        ahEvents[1] = g_hStreamIsEmptyEvent;
        numEvents = 2;
    }

    while (g_bMixerRunning)
    {
        DWORD dwres;
        DWORD bHdrsPending = FALSE;

        // check if there are headers pending
        //
        ENTER_CRIT;
        for (pWaveOut = g_pAllWaveOut;
             NULL != pWaveOut && !bHdrsPending;
             pWaveOut = pWaveOut->lpNext
            )
            bHdrsPending = (NULL != pWaveOut->pFirstWaveHdr ||
                            NULL != pWaveOut->pFirstReadyHdr) &&
                            !pWaveOut->bPaused;

        LEAVE_CRIT;

        if ( bHdrsPending && 
             NULL != g_Stream &&
                    ( 0 == (g_Stream->dwSoundCaps & TSSNDCAPS_ALIVE) ||
                      ( 0 != (g_Stream->dwSoundCaps & TSSNDCAPS_VOLUME) &&
                        0 == g_Stream->dwVolume 
                      ) ||
                       ( 0 != ( g_Stream->dwSoundFlags & TSSNDFLAGS_MUTE ))
                    )
            )
        {        
            //
            //  play silence in case of disconnected on "mute" mode
            //
            while(  ( 0 == (g_Stream->dwSoundCaps & TSSNDCAPS_ALIVE) ||
                        ( 0 != (g_Stream->dwSoundCaps & TSSNDCAPS_VOLUME) &&
                          0 == g_Stream->dwVolume
                        ) ||
                      ( 0 != ( g_Stream->dwSoundFlags & TSSNDFLAGS_MUTE ))
                     ) &&
                    _waveMixerPlaySilence() )
                ;
        } else {
            Sleep( 30 );    // give some time to the DSound emulator thread to wake up
                            //

            dwres = WaitForMultipleObjects(
                    (!bHdrsPending) ? numEvents - 1 : numEvents,
                    ahEvents,
                    FALSE,
                    INFINITE
                );

            //
            //  check for termination
            //
            if ( WAIT_OBJECT_0 == dwres && NULL != hCleanupEvent )
            {
                TRC( INF, "Cleanup detected (rdpclip disappeared ?!)\n" );
                // check for termination
                if ( _waveAcquireStream() )
                {
                    if ( TSSNDCAPS_TERMINATED == g_Stream->dwSoundCaps )
                    {
                        TRC( INF, "Cleaning up global data\n" );
                        CloseHandle( g_hMixerThread );
                        g_hMixerThread = NULL;
                        _waveReleaseStream();
                        drvDisable();
                        goto exitpt;
                    }

                    _waveReleaseStream();
                }
            }

            _waveMixerWriteData();
        }

    }

exitpt:
    TRC(INF, "waveMixerThread exited\n");

    if ( NULL != hCleanupEvent )
        CloseHandle( hCleanupEvent );

    return 0;
}

/*
 *  Function:
 *      wavePrepare
 *
 *  Description:
 *      Prepares a block, i.e. only sets it's flags
 *
 */
DWORD
wavePrepare(
    PVOID        pWaveCtx, 
    PWAVEHDR     pWaveHdr,
    DWORD_PTR    dwWaveHdrSize,
    BOOL         bPrepare)
{
    PWAVEOUTCTX pWaveOut = pWaveCtx;
    BOOL rv = MMSYSERR_NOTSUPPORTED;

    // Parameters check
    //
    if (NULL == pWaveCtx)
    {
        TRC(ERR, "wavePrepare: invalid device handle\n");
        rv = MMSYSERR_INVALHANDLE;
        goto exitpt;
    }

    if (sizeof(*pWaveHdr) != dwWaveHdrSize)
    {
        TRC(ERR, "wavePrepare: invalid size for dwWaveHdrSize\n");
        rv = MMSYSERR_INVALPARAM;
        goto exitpt;
    }

    //
    //  check the buffer size alignment
    //
    if ( 0 != pWaveOut->Format_nBlockAlign &&
         0 != pWaveHdr->dwBufferLength % pWaveOut->Format_nBlockAlign )
    {
        TRC( ERR, "wavePrepare: size unaligned\n" );
        rv = MMSYSERR_INVALPARAM;
        goto exitpt;
    }

    if (IsBadReadPtr( pWaveHdr->lpData, pWaveHdr->dwBufferLength ))
    {
        TRC( ERR, "wavePrepare: buffer unreadable\n" );
        rv = MMSYSERR_INVALPARAM;
        goto exitpt;
    }

#ifdef  _WIN64
    //
    //  check for proper alignment
    //
    if ( 0 != pWaveOut->Format_nChannels &&
         2 == pWaveOut->Format_nBlockAlign / pWaveOut->Format_nChannels &&
         0 != (( (LONG_PTR)pWaveHdr->lpData ) & 1 ))
    {
        TRC( ERR, "wavePrepare: buffer unaligned\n" );
        rv = MMSYSERR_INVALPARAM;
        goto exitpt;
    }
#endif

    if (bPrepare)
        pWaveHdr->dwFlags |= WHDR_PREPARED;
    else
        pWaveHdr->dwFlags &= ~WHDR_PREPARED;

    rv = MMSYSERR_NOERROR;

exitpt:
    return rv;
}

/*
 *  Function:
 *      waveReset
 *
 *  Description:
 *      Resets all current queued blocks
 *
 */
DWORD
waveReset(
    PWAVEOUTCTX pWaveOut
    )
{
    BOOL rv = MMSYSERR_NOTSUPPORTED;
    LPWAVEHDR   pWaveHdr;
    LPWAVEHDR   pFoundPrevHdr;

    ENTER_CRIT;

    // Parameters check
    //
    if (NULL == pWaveOut)
    {
        TRC(ERR, "waveReset: invalid device handle\n");
        rv = MMSYSERR_INVALHANDLE;
        goto exitpt;
    }

    //  dismiss all headers pending confirmation
    //
    while ( NULL != pWaveOut->pFirstReadyHdr )
    {
        pWaveHdr = pWaveOut->pFirstReadyHdr;
        pWaveOut->pFirstReadyHdr = pWaveOut->pFirstReadyHdr->lpNext;

        if (NULL == pWaveOut->pFirstReadyHdr)
            pWaveOut->pLastReadyHdr = NULL;
        
        pWaveHdr->reserved = 0;
        pWaveHdr->lpNext = NULL;
        pWaveHdr->dwFlags |= WHDR_DONE;
        pWaveHdr->dwFlags &= ~(WHDR_INQUEUE);

        // confirm that the block is done
        //
        LEAVE_CRIT;

        waveCallback(pWaveOut, WOM_DONE, (DWORD_PTR)pWaveHdr);

        ENTER_CRIT;

        if (0 == InterlockedDecrement(&pWaveOut->lNumberOfBlocksPlaying))
        {
            SetEvent(pWaveOut->hNoDataEvent);
        }
    }

    //  Clean all headers in the queue
    //
    while(NULL != pWaveOut->pFirstWaveHdr)
    {

        pWaveHdr = pWaveOut->pFirstWaveHdr;
        pWaveOut->pFirstWaveHdr = pWaveHdr->lpNext;

        pWaveHdr->reserved = 0;
        pWaveHdr->lpNext = NULL;
        pWaveHdr->dwFlags |= WHDR_DONE;
        pWaveHdr->dwFlags &= ~(WHDR_INQUEUE);

        // confirm that the block is done
        //
        LEAVE_CRIT;

        waveCallback(pWaveOut, WOM_DONE, (DWORD_PTR)pWaveHdr);

        ENTER_CRIT;

        if (0 == InterlockedDecrement(&pWaveOut->lNumberOfBlocksPlaying))
        {
            SetEvent(pWaveOut->hNoDataEvent);
        }

    }

    //
    //  we may end with some data in the last block in the stream
    //  if the "queued" mark hasn't change, increment it and kick the io
    //  thread to play this block
    //  to test this play very-very short files
    //  shorter than TSSND_BLOCKSIZE / (TSSND_NATIVE_BLOCKALIGN *
    //  TSSND_NATIVE_SAMPLERATE) seconds
    //
    //
    //
    if (_waveAcquireStream())
    {
        if (g_Stream->cLastBlockQueued == pWaveOut->cLastStreamPosition &&
            0 != pWaveOut->dwLastStreamOffset)
        {
            g_Stream->cLastBlockQueued ++;
            //
            //  kick the io thread
            //
            if (g_hDataReadyEvent)
                SetEvent(g_hDataReadyEvent);
            else
                TRC(WRN, "waveClose: g_hDataReadyEvent is NULL\n");
        }
        _waveReleaseStream();
    }

    pWaveOut->dwLastHeaderOffset = 0;
    pWaveOut->dwSamples = 0;

    rv = MMSYSERR_NOERROR;

exitpt:
    LEAVE_CRIT;

    return rv;
}

/*
 *  Function:
 *      waveGetPos
 *
 *  Description:
 *      Gets current position in the current stream
 *
 */
DWORD
waveGetPos(
    PWAVEOUTCTX pWaveOut,
    MMTIME     *pMMTime,
    DWORD_PTR   dwMMTimeSize
    )
{
    DWORD       rv = MMSYSERR_ERROR;
    DWORD       dwSamples;
    DWORD       ms;

    if (NULL == pWaveOut)
    {
        TRC(ERR, "waveGetPos: invalid device handle\n");
        rv = MMSYSERR_INVALHANDLE;
        goto exitpt;
    }

    if (NULL == pMMTime || sizeof(*pMMTime) != dwMMTimeSize)
    {
        TRC(ERR, "waveGetPos: pMMTime is invalid\n");
        rv = MMSYSERR_INVALPARAM;
        goto exitpt;
    }

    //
    //  update the played position
    //

    dwSamples = pWaveOut->dwSamples;

    switch ( pMMTime->wType )
    {
    case TIME_SAMPLES:
        pMMTime->u.sample = dwSamples;
    break;
    case TIME_BYTES:
        pMMTime->u.cb = dwSamples * pWaveOut->Format_nBlockAlign;
    break;
    case TIME_MS:
        pMMTime->u.ms = MulDiv( dwSamples, pWaveOut->Format_nBlockAlign * 1000,
                        pWaveOut->Format_nAvgBytesPerSec );

    break;
    case TIME_SMPTE:
        ms = MulDiv( dwSamples, pWaveOut->Format_nBlockAlign * 1000,
                     pWaveOut->Format_nAvgBytesPerSec );

        pMMTime->u.smpte.frame = (BYTE)((ms % 1000) * 24 / 1000);
        ms /= 1000;
        pMMTime->u.smpte.sec = (BYTE)(ms % 60);
        ms /= 60;
        pMMTime->u.smpte.min = (BYTE)(ms % 60);
        ms /= 60;
        pMMTime->u.smpte.hour = (BYTE)ms;
        pMMTime->u.smpte.fps = 24;
    break;
    default:
        rv = MMSYSERR_NOTSUPPORTED;
    }

    rv = MMSYSERR_NOERROR;

exitpt:

    return rv;
}

/*
 *  Function:
 *      wavePause
 *
 *  Description:
 *      Pauses the current play
 *
 */
DWORD
wavePause(
    PWAVEOUTCTX pWaveOut
    )
{
    DWORD       rv = MMSYSERR_ERROR;

    if (NULL == pWaveOut)
    {
        TRC(ERR, "wavePause: invalid device handle\n");
        rv = MMSYSERR_INVALHANDLE;
        goto exitpt;
    }

    pWaveOut->bPaused = TRUE;

    rv = MMSYSERR_NOERROR;

exitpt:

    return rv;
}

/*
 *  Function:
 *      waveRestart
 *
 *  Description:
 *      Restarts a paused play
 *
 */
DWORD
waveRestart(
    PWAVEOUTCTX pWaveOut
    )
{
    DWORD       rv = MMSYSERR_ERROR;

    if (NULL == pWaveOut)
    {
        TRC(ERR, "waveRestart: invalid device handle\n");
        rv = MMSYSERR_INVALHANDLE;
        goto exitpt;
    }

    pWaveOut->bPaused = FALSE;

    //
    //  Kick the mixer thread
    //
    if (NULL == g_hMixerEvent)
    {
        TRC(WRN, "waveRestart: g_hMixerEvent is NULL\n");
    } else
        SetEvent(g_hMixerEvent);

    rv = MMSYSERR_NOERROR;

exitpt:

    return rv;
}

/*
 *  Function:
 *      wodMessage
 *
 *  Description:
 *      Main entry point for WaveOut device
 *
 *  Parameters:
 *
 *
 */
DWORD
APIENTRY
wodMessage(
    UINT    uDeviceID,
    UINT    uMessage,
    DWORD_PTR   dwUser,
    DWORD_PTR   dwParam1,
    DWORD_PTR   dwParam2
    )
{
    DWORD rv = MMSYSERR_ERROR;
    PWAVEOUTCTX pWaveOut = (PWAVEOUTCTX)dwUser;

    switch ( uMessage )
    {
    case WODM_GETNUMDEVS:
        TRC(ALV, "WODM_GETNUMDEVS\n");
        rv = waveGetNumDevs();
    break;

    case WODM_GETDEVCAPS:
        drvEnable();

        TRC( ALV, "WODM_GETDEVCAPS\n");
        rv = waveGetWaveOutDeviceCaps(
                pWaveOut, 
                (LPWAVEOUTCAPS)dwParam1, 
                dwParam2
            );
    break;

    case WODM_OPEN:
        drvEnable();

        TRC(ALV, "WODM_OPEN\n");
        rv = waveOpen(  (PWAVEOUTCTX *)dwUser, 
                        (LPWAVEOPENDESC)dwParam1, 
                        dwParam2);

        _EnableMixerThread();
    break;

    case WODM_CLOSE:
        TRC(ALV, "WODM_CLOSE\n");
        rv = waveClose(pWaveOut);
        _DerefMixerThread();
    break;

    case WODM_WRITE:
        TRC(ALV, "WODM_WRITE\n");
        rv = waveWrite(pWaveOut, (PWAVEHDR)dwParam1, dwParam2);
    break;

    case WODM_PAUSE:
        TRC(ALV, "WODM_PAUSE\n");
        rv = wavePause(pWaveOut);
    break;

    case WODM_RESTART:
        TRC(ALV, "WODM_RESTART\n");
        rv = waveRestart(pWaveOut);
    break;

    case WODM_RESET:
        TRC(ALV, "WODM_RESET\n");
        rv = waveReset(pWaveOut);
    break;

    case WODM_BREAKLOOP:
        TRC(ALV, "WODM_BREAKLOOP\n");
        // rv = waveBreakLoop(pWaveOut);
        rv = MMSYSERR_NOERROR;
    break;

    case WODM_GETPOS:
        TRC(ALV, "WODM_GETPOS\n");
        rv = waveGetPos(pWaveOut, (MMTIME *)dwParam1, dwParam2);
    break;

    case WODM_SETPITCH:
        TRC(ALV, "WODM_SETPITCH\n");
        rv = waveSetPitch(pWaveOut, PtrToLong((PVOID)dwParam1));
    break;

    case WODM_SETVOLUME:
        TRC(ALV, "WODM_SETVOLUME\n");
        rv = waveSetVolume(pWaveOut, PtrToLong((PVOID)dwParam1));
    break;

    case WODM_SETPLAYBACKRATE:
        TRC(ALV, "WODM_SETPLAYBACKRATE\n");
        // rv = waveSetPlaybackRate(pWaveOut, dwParam1);
        rv = MMSYSERR_NOTSUPPORTED;
    break;

    case WODM_GETPITCH:
        TRC(ALV, "WODM_GETVOLUME\n");
        rv = waveGetPitch(pWaveOut, (DWORD *)dwParam1);
    break;

    case WODM_GETVOLUME:
        TRC(ALV, "WODM_GETVOLUME\n");
        rv = waveGetVolume(pWaveOut, (DWORD *)dwParam1);
    break;

    case WODM_GETPLAYBACKRATE:
        TRC(ALV, "WODM_GETPLAYBACKRATE\n");
        // rv = waveGetPlaybackRate(pWaveOut, (DWORD *)dwParam1);
        rv = MMSYSERR_NOTSUPPORTED;
    break;

    case WODM_PREPARE:
        TRC(ALV, "WODM_PREPARE\n");
        rv = wavePrepare(pWaveOut, (PWAVEHDR)dwParam1, dwParam2, TRUE);
    break;

    case WODM_UNPREPARE:
        TRC(ALV, "WODM_UNPREPARE\n");
        rv = wavePrepare(pWaveOut, (PWAVEHDR)dwParam1, dwParam2, FALSE);
    break;

    default:
        TRC(ERR, "Unsupported message: 0x%x\n", uMessage);
        rv = MMSYSERR_NOTSUPPORTED;
    }

    return rv;
}

/*
 *  Function:
 *      widMessage
 *
 *  Description:
 *      Main entry point for WaveIn device ( unsupported
 */
DWORD
APIENTRY
widMessage(
    UINT    uDeviceID,
    UINT    uMessage,
    DWORD_PTR   dwUser,
    DWORD_PTR   dwParam1,
    DWORD_PTR   dwParam2
    )
{
    if ( WIDM_GETNUMDEVS == uMessage )
        return 0;

    return MMSYSERR_NODRIVER;
}

//
//  Common PCM format -> 22 kHz 16 bit stereo
//
//  THE SIZE IS IN NUMBER OF SAMPLES IN NATIVE FORMAT
//
#define PLACE_DATA(_pdst_, _srcv_)    \
        sum = _pdst_[0] + _srcv_;     \
                                      \
        if (sum > 0x7FFF)             \
            sum = 0x7FFF;             \
        if (sum < -0x8000)            \
            sum = -0x8000;            \
                                      \
        _pdst_[0] = (INT16)sum;       \
        _pdst_ ++;

VOID
Place8kHz8Mono(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    BYTE    *psrc;
    INT16   *pdst;
    DWORD   dwLeap;

    if ( NULL == pDest || NULL == pSrc )
        goto exitpt;

    for (psrc = pSrc,
         pdst = pDest,
         dwLeap = 0;
         dwSize;
         dwSize--)
    {
        INT src;
        INT sum;

        src = ((INT)(psrc[0] - 0x80)) << 8;

        PLACE_DATA( pdst, src );
        PLACE_DATA( pdst, src );

        dwLeap += 8000;

        psrc += ( dwLeap / TSSND_NATIVE_SAMPLERATE );
        dwLeap %= TSSND_NATIVE_SAMPLERATE;
    }
exitpt:
    ;
}

VOID
Place8kHz8Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    BYTE    *psrc;
    INT16   *pdst;
    DWORD   dwLeap;

    if ( NULL == pDest || NULL == pSrc )
        goto exitpt;

    for (psrc = pSrc,
         pdst = pDest,
         dwLeap = 0;
         dwSize;
         dwSize--)
    {
        INT src;
        INT sum;

        src = ((INT)(psrc[0] - 0x80)) << 8;

        PLACE_DATA( pdst, src );

        src = ((INT)(psrc[1] - 0x80)) << 8;
        PLACE_DATA( pdst, src );

        dwLeap += 8000;

        psrc += 2 * ( dwLeap / TSSND_NATIVE_SAMPLERATE );
        dwLeap %= TSSND_NATIVE_SAMPLERATE;
    }
exitpt:
    ;
}

VOID
Place8kHz16Mono(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    INT16   *psrc;
    INT16   *pdst;
    DWORD   dwLeap;

    if ( NULL == pDest || NULL == pSrc )
        goto exitpt;

    for (psrc = pSrc,
         pdst = pDest,
         dwLeap = 0;
         dwSize;
         dwSize--)
    {
        INT src;
        INT sum;

        src = psrc[0];

        PLACE_DATA( pdst, src );
        PLACE_DATA( pdst, src );

        dwLeap += 8000;

        psrc += (dwLeap / TSSND_NATIVE_SAMPLERATE);
        dwLeap %= TSSND_NATIVE_SAMPLERATE;
    }
exitpt:
    ;
}

VOID
Place8kHz16Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    INT16   *psrc;
    INT16   *pdst;
    DWORD   dwLeap;

    if ( NULL == pDest || NULL == pSrc )
        goto exitpt;

    for (psrc = pSrc,
         pdst = pDest,
         dwLeap = 0;
         dwSize;
         dwSize--)
    {
        INT src;
        INT sum;

        src = psrc[0];

        PLACE_DATA( pdst, src );

        src = psrc[1];
        PLACE_DATA( pdst, src );

        dwLeap += 8000;

        psrc += 2 * (dwLeap / TSSND_NATIVE_SAMPLERATE);
        dwLeap %= TSSND_NATIVE_SAMPLERATE;
    }
exitpt:
    ;
}

VOID
Place11kHz8Mono(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    BYTE    *psrc;
    INT16   *pdst;

    if (NULL == pDest || NULL == pSrc)
        goto exitpt;

    for (psrc = pSrc, 
         pdst = pDest; 
         dwSize; 
         dwSize--)
    {
        INT sum;
        INT src;

        src = ((INT)(psrc[0] - 0x80)) << 8;

        PLACE_DATA(pdst, src);
        PLACE_DATA(pdst, src);

        psrc += (dwSize & 1);    // advance on every odd step
    } 

exitpt:
    ;
}
    

VOID
Place22kHz8Mono(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    BYTE   *psrc;
    INT16  *pdst;

    if (NULL == pDest || NULL == pSrc)
        goto exitpt;

    for (pdst = pDest, psrc = pSrc;
         dwSize;
         dwSize--)
    {
        INT sum;
        INT src;

        src = ((INT)(psrc[0] - 0x80)) << 8;

        PLACE_DATA(pdst, src);
        PLACE_DATA(pdst, src);

        psrc ++;
    }

exitpt:
    ;
}

VOID
Place44kHz8Mono(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    BYTE   *psrc;
    INT16  *pdst;

    if (NULL == pDest || NULL == pSrc)
        goto exitpt;

    for (pdst = pDest, psrc = pSrc;
         dwSize;
         dwSize--)
    {
        INT sum;
        INT src;

        src = (((INT)(psrc[0] + psrc[1] - 2 * 0x80)) / 2) << 8;

        PLACE_DATA(pdst, src);
        PLACE_DATA(pdst, src);

        psrc += 2;
    }

exitpt:
    ;
}

VOID
Place11kHz16Mono(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    INT16   *psrc;
    INT16   *pdst;

    if (NULL == pDest || NULL == pSrc)
        goto exitpt;

    for (pdst = pDest, psrc = pSrc;
         dwSize;
         dwSize --)
    {
        INT sum;
        INT src;

        src = psrc[0];

        PLACE_DATA(pdst, src);
        PLACE_DATA(pdst, src);

        psrc += (dwSize & 1);    // advance on every odd step

    }

exitpt:
    ;
}

VOID
Place22kHz16Mono(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    INT16  *pdst;
    INT16  *psrc;

    if (NULL == pDest || NULL == pSrc)
        goto exitpt;

    for (pdst = pDest, psrc = pSrc;
         dwSize;
         dwSize--)
    {
        INT sum;
        INT src;

        src = psrc[0];

        PLACE_DATA(pdst, src);
        PLACE_DATA(pdst, src);

        psrc ++;
    }

exitpt:
    ;
}

VOID
Place44kHz16Mono(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    INT16 *pdst;
    INT16 *psrc;

    if (NULL == pDest || NULL == pSrc)
        goto exitpt;

    for (pdst = pDest, psrc = pSrc;
         dwSize;
         dwSize--)
    {
        INT sum;
        INT src;

        src = (psrc[0] + psrc[1]) / 2;

        PLACE_DATA(pdst, src);
        PLACE_DATA(pdst, src);

        psrc += 2;
    }

exitpt:
    ;
}

VOID
Place11kHz8Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    INT16  *pdst;
    BYTE   *psrc;

    if (NULL == pDest || NULL == pSrc)
        goto exitpt;

    for (pdst = pDest, psrc = pSrc;
         dwSize;
         dwSize --)
    {
        INT sum;
        INT srcl, srcr;

        srcl = (((INT)(psrc[0] - 0x80)) << 8);
        srcr = (((INT)(psrc[1] - 0x80)) << 8);

        PLACE_DATA(pdst, srcl);
        PLACE_DATA(pdst, srcr);

        psrc += 2 * (dwSize & 1);    // advance on every odd step
    }

exitpt:
    ;
}

VOID
Place22kHz8Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    INT16  *pdst;
    BYTE   *psrc;

    if (NULL == pDest || NULL == pSrc)
        goto exitpt;

    for (pdst = pDest, psrc = pSrc;
         dwSize;
         dwSize--)
    {
        INT sum;
        INT srcl, srcr;

        srcl = (((INT)(psrc[0] - 0x80)) << 8);
        srcr = (((INT)(psrc[1] - 0x80)) << 8);

        PLACE_DATA(pdst, srcl);
        PLACE_DATA(pdst, srcr);

        psrc += 2;
    }

exitpt:
    ;
}

VOID
Place44kHz8Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    INT16  *pdst;
    BYTE   *psrc;

    if (NULL == pDest || NULL == pSrc)
        goto exitpt;

    for (pdst = pDest, psrc = pSrc;
         dwSize;
         dwSize--)
    {
        INT sum;
        INT srcl, srcr;

        srcl = (((INT)(psrc[0] + psrc[2] - 2 * 0x80) / 2) << 8);
        srcr = (((INT)(psrc[1] + psrc[3] - 2 * 0x80) / 2) << 8);

        PLACE_DATA(pdst, srcl);
        PLACE_DATA(pdst, srcr);

        psrc += 4;
    }

exitpt:
    ;
}

VOID
Place11kHz16Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    INT16 *pdst;
    INT16 *psrc;

    if (NULL == pDest || NULL == pSrc)
        goto exitpt;

    for (pdst = pDest, psrc = pSrc;
         dwSize;
         dwSize --)
    {
        INT sum;
        INT srcl, srcr;

        srcl = (INT)psrc[0];
        srcr = (INT)psrc[1];

        PLACE_DATA(pdst, srcl);
        PLACE_DATA(pdst, srcr);

        psrc += 2 * (dwSize & 1);    // advance on every odd step
    }

exitpt:
    ;
}

VOID
Place22kHz16Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    INT16 *pdst;
    INT16 *psrc;

    if (NULL == pDest || NULL == pSrc)
        goto exitpt;

    for (pdst = pDest, psrc = pSrc;
         dwSize;
         dwSize--)
    {
        INT sum;
        INT srcl, srcr;

        srcl = (INT)psrc[0];
        srcr = (INT)psrc[1];

        PLACE_DATA(pdst, srcl);
        PLACE_DATA(pdst, srcr);

        psrc += 2;
    }

exitpt:
    ;
}

VOID
Place44kHz16Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    INT16 *pdst;
    INT16 *psrc;

    if (NULL == pDest || NULL == pSrc)
        goto exitpt;

    for (pdst = pDest, psrc = pSrc;
         dwSize;
         dwSize--)
    {
        INT sum;
        INT srcl, srcr;

        srcl = (INT)(psrc[0] + psrc[2]) / 2;
        srcr = (INT)(psrc[1] + psrc[3]) / 2;

        PLACE_DATA(pdst, srcl);
        PLACE_DATA(pdst, srcr);

        psrc += 4;
    }

exitpt:
    ;
}

VOID
Place12kHz8Mono(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    BYTE    *psrc;
    INT16   *pdst;
    DWORD   dwLeap;

    if ( NULL == pDest || NULL == pSrc )
        goto exitpt;

    for (psrc = pSrc,
         pdst = pDest,
         dwLeap = 0;
         dwSize;
         dwSize--)
    {
        INT src;
        INT sum;

        src = ((INT)(psrc[0] - 0x80)) << 8;

        PLACE_DATA( pdst, src );
        PLACE_DATA( pdst, src );

        dwLeap += 12000;

        psrc += ( dwLeap / TSSND_NATIVE_SAMPLERATE );
        dwLeap %= TSSND_NATIVE_SAMPLERATE;
    }
exitpt:
    ;
}

VOID
Place12kHz8Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    BYTE    *psrc;
    INT16   *pdst;
    DWORD   dwLeap;

    if ( NULL == pDest || NULL == pSrc )
        goto exitpt;

    for (psrc = pSrc,
         pdst = pDest,
         dwLeap = 0;
         dwSize;
         dwSize--)
    {
        INT src;
        INT sum;

        src = ((INT)(psrc[0] - 0x80)) << 8;

        PLACE_DATA( pdst, src );

        src = ((INT)(psrc[1] - 0x80)) << 8;
        PLACE_DATA( pdst, src );

        dwLeap += 12000;

        psrc += 2 * ( dwLeap / TSSND_NATIVE_SAMPLERATE );
        dwLeap %= TSSND_NATIVE_SAMPLERATE;
    }
exitpt:
    ;
}

VOID
Place12kHz16Mono(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    INT16   *psrc;
    INT16   *pdst;
    DWORD   dwLeap;

    if ( NULL == pDest || NULL == pSrc )
        goto exitpt;

    for (psrc = pSrc,
         pdst = pDest,
         dwLeap = 0;
         dwSize;
         dwSize--)
    {
        INT src;
        INT sum;

        src = psrc[0];

        PLACE_DATA( pdst, src );
        PLACE_DATA( pdst, src );

        dwLeap += 12000;

        psrc += (dwLeap / TSSND_NATIVE_SAMPLERATE);
        dwLeap %= TSSND_NATIVE_SAMPLERATE;
    }
exitpt:
    ;
}

VOID
Place12kHz16Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    INT16   *psrc;
    INT16   *pdst;
    DWORD   dwLeap;

    if ( NULL == pDest || NULL == pSrc )
        goto exitpt;

    for (psrc = pSrc,
         pdst = pDest,
         dwLeap = 0;
         dwSize;
         dwSize--)
    {
        INT src;
        INT sum;

        src = psrc[0];

        PLACE_DATA( pdst, src );

        src = psrc[1];
        PLACE_DATA( pdst, src );

        dwLeap += 12000;

        psrc += 2 * (dwLeap / TSSND_NATIVE_SAMPLERATE);
        dwLeap %= TSSND_NATIVE_SAMPLERATE;
    }
exitpt:
    ;
}


VOID
Place16kHz8Mono(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    BYTE    *psrc;
    INT16   *pdst;
    DWORD   dwLeap;

    if ( NULL == pDest || NULL == pSrc )
        goto exitpt;

    for (psrc = pSrc,
         pdst = pDest,
         dwLeap = 0;
         dwSize;
         dwSize--)
    {
        INT src;
        INT sum;

        src = ((INT)(psrc[0] - 0x80)) << 8;

        PLACE_DATA( pdst, src );
        PLACE_DATA( pdst, src );

        dwLeap += 16000;

        psrc += ( dwLeap / TSSND_NATIVE_SAMPLERATE );
        dwLeap %= TSSND_NATIVE_SAMPLERATE;
    }
exitpt:
    ;
}

VOID
Place16kHz8Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    BYTE    *psrc;
    INT16   *pdst;
    DWORD   dwLeap;

    if ( NULL == pDest || NULL == pSrc )
        goto exitpt;

    for (psrc = pSrc,
         pdst = pDest,
         dwLeap = 0;
         dwSize;
         dwSize--)
    {
        INT src;
        INT sum;

        src = ((INT)(psrc[0] - 0x80)) << 8;

        PLACE_DATA( pdst, src );

        src = ((INT)(psrc[1] - 0x80)) << 8;
        PLACE_DATA( pdst, src );

        dwLeap += 16000;

        psrc += 2 * ( dwLeap / TSSND_NATIVE_SAMPLERATE );
        dwLeap %= TSSND_NATIVE_SAMPLERATE;
    }
exitpt:
    ;
}

VOID
Place16kHz16Mono(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    INT16   *psrc;
    INT16   *pdst;
    DWORD   dwLeap;

    if ( NULL == pDest || NULL == pSrc )
        goto exitpt;

    for (psrc = pSrc,
         pdst = pDest,
         dwLeap = 0;
         dwSize;
         dwSize--)
    {
        INT src;
        INT sum;

        src = psrc[0];

        PLACE_DATA( pdst, src );
        PLACE_DATA( pdst, src );

        dwLeap += 16000;

        psrc += (dwLeap / TSSND_NATIVE_SAMPLERATE);
        dwLeap %= TSSND_NATIVE_SAMPLERATE;
    }
exitpt:
    ;
}

VOID
Place16kHz16Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    INT16   *psrc;
    INT16   *pdst;
    DWORD   dwLeap;

    if ( NULL == pDest || NULL == pSrc )
        goto exitpt;

    for (psrc = pSrc,
         pdst = pDest,
         dwLeap = 0;
         dwSize;
         dwSize--)
    {
        INT src;
        INT sum;

        src = psrc[0];

        PLACE_DATA( pdst, src );

        src = psrc[1];
        PLACE_DATA( pdst, src );

        dwLeap += 16000;

        psrc += 2 * (dwLeap / TSSND_NATIVE_SAMPLERATE);
        dwLeap %= TSSND_NATIVE_SAMPLERATE;
    }
exitpt:
    ;
}


VOID
Place24kHz8Mono(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    BYTE    *psrc;
    INT16   *pdst;
    DWORD   dwLeap;

    if ( NULL == pDest || NULL == pSrc )
        goto exitpt;

    for (psrc = pSrc,
         pdst = pDest,
         dwLeap = 0;
         dwSize;
         dwSize--)
    {
        INT src;
        INT sum;

        src = ((INT)(psrc[0] - 0x80)) << 8;

        PLACE_DATA( pdst, src );
        PLACE_DATA( pdst, src );

        dwLeap += 24000;

        psrc += ( dwLeap / TSSND_NATIVE_SAMPLERATE );
        dwLeap %= TSSND_NATIVE_SAMPLERATE;
    }
exitpt:
    ;
}

VOID
Place24kHz8Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    BYTE    *psrc;
    INT16   *pdst;
    DWORD   dwLeap;

    if ( NULL == pDest || NULL == pSrc )
        goto exitpt;

    for (psrc = pSrc,
         pdst = pDest,
         dwLeap = 0;
         dwSize;
         dwSize--)
    {
        INT src;
        INT sum;

        src = ((INT)(psrc[0] - 0x80)) << 8;

        PLACE_DATA( pdst, src );

        src = ((INT)(psrc[1] - 0x80)) << 8;
        PLACE_DATA( pdst, src );

        dwLeap += 24000;

        psrc += 2 * ( dwLeap / TSSND_NATIVE_SAMPLERATE );
        dwLeap %= TSSND_NATIVE_SAMPLERATE;
    }
exitpt:
    ;
}

VOID
Place24kHz16Mono(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    INT16   *psrc;
    INT16   *pdst;
    DWORD   dwLeap;

    if ( NULL == pDest || NULL == pSrc )
        goto exitpt;

    for (psrc = pSrc,
         pdst = pDest,
         dwLeap = 0;
         dwSize;
         dwSize--)
    {
        INT src;
        INT sum;

        src = psrc[0];

        PLACE_DATA( pdst, src );
        PLACE_DATA( pdst, src );

        dwLeap += 24000;

        psrc += (dwLeap / TSSND_NATIVE_SAMPLERATE);
        dwLeap %= TSSND_NATIVE_SAMPLERATE;
    }
exitpt:
    ;
}

VOID
Place24kHz16Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    INT16   *psrc;
    INT16   *pdst;
    DWORD   dwLeap;

    if ( NULL == pDest || NULL == pSrc )
        goto exitpt;

    for (psrc = pSrc,
         pdst = pDest,
         dwLeap = 0;
         dwSize;
         dwSize--)
    {
        INT src;
        INT sum;

        src = psrc[0];

        PLACE_DATA( pdst, src );

        src = psrc[1];
        PLACE_DATA( pdst, src );

        dwLeap += 24000;

        psrc += 2 * (dwLeap / TSSND_NATIVE_SAMPLERATE);
        dwLeap %= TSSND_NATIVE_SAMPLERATE;
    }
exitpt:
    ;
}


VOID
Place32kHz8Mono(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    BYTE    *psrc;
    INT16   *pdst;
    DWORD   dwLeap;

    if ( NULL == pDest || NULL == pSrc )
        goto exitpt;

    for (psrc = pSrc,
         pdst = pDest,
         dwLeap = 0;
         dwSize;
         dwSize--)
    {
        INT src;
        INT sum;

        src = ((INT)(psrc[0] - 0x80)) << 8;

        PLACE_DATA( pdst, src );
        PLACE_DATA( pdst, src );

        dwLeap += 32000;

        psrc += ( dwLeap / TSSND_NATIVE_SAMPLERATE );
        dwLeap %= TSSND_NATIVE_SAMPLERATE;
    }
exitpt:
    ;
}

VOID
Place32kHz8Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    BYTE    *psrc;
    INT16   *pdst;
    DWORD   dwLeap;

    if ( NULL == pDest || NULL == pSrc )
        goto exitpt;

    for (psrc = pSrc,
         pdst = pDest,
         dwLeap = 0;
         dwSize;
         dwSize--)
    {
        INT src;
        INT sum;

        src = ((INT)(psrc[0] - 0x80)) << 8;

        PLACE_DATA( pdst, src );

        src = ((INT)(psrc[1] - 0x80)) << 8;
        PLACE_DATA( pdst, src );

        dwLeap += 32000;

        psrc += 2 * ( dwLeap / TSSND_NATIVE_SAMPLERATE );
        dwLeap %= TSSND_NATIVE_SAMPLERATE;
    }
exitpt:
    ;
}

VOID
Place32kHz16Mono(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    INT16   *psrc;
    INT16   *pdst;
    DWORD   dwLeap;

    if ( NULL == pDest || NULL == pSrc )
        goto exitpt;

    for (psrc = pSrc,
         pdst = pDest,
         dwLeap = 0;
         dwSize;
         dwSize--)
    {
        INT src;
        INT sum;

        src = psrc[0];

        PLACE_DATA( pdst, src );
        PLACE_DATA( pdst, src );

        dwLeap += 32000;

        psrc += (dwLeap / TSSND_NATIVE_SAMPLERATE);
        dwLeap %= TSSND_NATIVE_SAMPLERATE;
    }
exitpt:
    ;
}

VOID
Place32kHz16Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    INT16   *psrc;
    INT16   *pdst;
    DWORD   dwLeap;

    if ( NULL == pDest || NULL == pSrc )
        goto exitpt;

    for (psrc = pSrc,
         pdst = pDest,
         dwLeap = 0;
         dwSize;
         dwSize--)
    {
        INT src;
        INT sum;

        src = psrc[0];

        PLACE_DATA( pdst, src );

        src = psrc[1];
        PLACE_DATA( pdst, src );

        dwLeap += 32000;

        psrc += 2 * (dwLeap / TSSND_NATIVE_SAMPLERATE);
        dwLeap %= TSSND_NATIVE_SAMPLERATE;
    }
exitpt:
    ;
}


VOID
Place48kHz8Mono(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    BYTE    *psrc;
    INT16   *pdst;
    DWORD   dwLeap;

    if ( NULL == pDest || NULL == pSrc )
        goto exitpt;

    for (psrc = pSrc,
         pdst = pDest,
         dwLeap = 0;
         dwSize;
         dwSize--)
    {
        INT src;
        INT sum;

        src = ((INT)(psrc[0] - 0x80)) << 8;

        PLACE_DATA( pdst, src );
        PLACE_DATA( pdst, src );

        dwLeap += 48000;

        psrc += ( dwLeap / TSSND_NATIVE_SAMPLERATE );
        dwLeap %= TSSND_NATIVE_SAMPLERATE;
    }
exitpt:
    ;
}

VOID
Place48kHz8Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    BYTE    *psrc;
    INT16   *pdst;
    DWORD   dwLeap;

    if ( NULL == pDest || NULL == pSrc )
        goto exitpt;

    for (psrc = pSrc,
         pdst = pDest,
         dwLeap = 0;
         dwSize;
         dwSize--)
    {
        INT src;
        INT sum;

        src = ((INT)(psrc[0] - 0x80)) << 8;

        PLACE_DATA( pdst, src );

        src = ((INT)(psrc[1] - 0x80)) << 8;
        PLACE_DATA( pdst, src );

        dwLeap += 48000;

        psrc += 2 * ( dwLeap / TSSND_NATIVE_SAMPLERATE );
        dwLeap %= TSSND_NATIVE_SAMPLERATE;
    }
exitpt:
    ;
}

VOID
Place48kHz16Mono(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    INT16   *psrc;
    INT16   *pdst;
    DWORD   dwLeap;

    if ( NULL == pDest || NULL == pSrc )
        goto exitpt;

    for (psrc = pSrc,
         pdst = pDest,
         dwLeap = 0;
         dwSize;
         dwSize--)
    {
        INT src;
        INT sum;

        src = psrc[0];

        PLACE_DATA( pdst, src );
        PLACE_DATA( pdst, src );

        dwLeap += 48000;

        psrc += (dwLeap / TSSND_NATIVE_SAMPLERATE);
        dwLeap %= TSSND_NATIVE_SAMPLERATE;
    }
exitpt:
    ;
}

VOID
Place48kHz16Stereo(PVOID pDest, PVOID pSrc, DWORD dwSize)
{
    INT16   *psrc;
    INT16   *pdst;
    DWORD   dwLeap;

    if ( NULL == pDest || NULL == pSrc )
        goto exitpt;

    for (psrc = pSrc,
         pdst = pDest,
         dwLeap = 0;
         dwSize;
         dwSize--)
    {
        INT src;
        INT sum;

        src = psrc[0];

        PLACE_DATA( pdst, src );

        src = psrc[1];
        PLACE_DATA( pdst, src );

        dwLeap += 48000;

        psrc += 2 * (dwLeap / TSSND_NATIVE_SAMPLERATE);
        dwLeap %= TSSND_NATIVE_SAMPLERATE;
    }
exitpt:
    ;
}

////////////////////////////////////////////////////////////////////////
//
//  Unsupported entries
//
////////////////////////////////////////////////////////////////////////

DWORD
APIENTRY
modMessage(
    UINT    uDeviceID,
    UINT    uMessage,
    DWORD_PTR   dwUser,
    DWORD_PTR   dwParam1,
    DWORD_PTR   dwParam2
    )
{
    if ( MODM_GETNUMDEVS == uMessage )
        return 0;

    return MMSYSERR_NODRIVER;
}

DWORD
APIENTRY
midMessage(
    UINT    uDeviceID,
    UINT    uMessage,
    DWORD_PTR   dwUser,
    DWORD_PTR   dwParam1,
    DWORD_PTR   dwParam2
    )
{
    if ( MIDM_GETNUMDEVS == uMessage )
        return 0;

    return MMSYSERR_NODRIVER;
}

DWORD
APIENTRY
auxMessage(
    UINT    uDeviceID,
    UINT    uMessage,
    DWORD_PTR   dwUser,
    DWORD_PTR   dwParam1,
    DWORD_PTR   dwParam2
    )
{
    if ( AUXDM_GETNUMDEVS == uMessage )
        return 0;

    return MMSYSERR_NODRIVER;
}

////////////////////////////////////////////////////////////////////////
//
//  Mixer implementation
//
DWORD
RDPMixerOpen(
    PMIXERCTX       *ppMixer,
    PMIXEROPENDESC  pMixerDesc,
    DWORD_PTR       dwFlags
    )
{
    DWORD rv = MMSYSERR_ERROR;
    PMIXERCTX pMix = NULL;

    ASSERT( CALLBACK_FUNCTION == dwFlags );

    pMix = &g_Mixer;

    rv = MMSYSERR_NOERROR;

    return rv;
}

DWORD
RDPMixerClose(
    PMIXERCTX pMixer
    )
{
    return MMSYSERR_NOERROR;
}
    
DWORD
RDPMixerGetDevCaps(
    PMIXERCTX   pMixer,
    PMIXERCAPS  pCaps,
    DWORD_PTR   dwCapsSize
    )
{
    DWORD rv = MMSYSERR_ERROR;

    //  Parameters check
    //
    if (dwCapsSize < sizeof(*pCaps))
    {
        TRC(ERR, "RDPMixerGetDevCaps: invalid size of MIXERCAPS, expect %d, received %d\n",
            sizeof(*pCaps), dwCapsSize);
        rv = MMSYSERR_INVALPARAM;
        goto exitpt;
    }

    pCaps->wMid = MM_MICROSOFT;
    pCaps->wPid = MM_MSFT_GENERIC_WAVEOUT;
    pCaps->vDriverVersion = TSSND_DRIVER_VERSION;
    LoadString( g_hDllInst,
                IDS_DRIVER_NAME,
                pCaps->szPname,
                sizeof( pCaps->szPname ) / sizeof( pCaps->szPname[0] ));
    pCaps->fdwSupport = 0;  // no flags defined
    pCaps->cDestinations = 1;

    rv = MMSYSERR_NOERROR;
exitpt:
    return rv;
}

DWORD
_FillMixerLineInfo( PMIXERLINE pLine )
{
    DWORD dw;

    pLine->dwDestination = 0;   // just one destination
    pLine->dwLineID = 0;        // just one line
    pLine->fdwLine  = MIXERLINE_LINEF_ACTIVE;
    pLine->dwComponentType = MIXERLINE_COMPONENTTYPE_DST_SPEAKERS;
    pLine->cChannels = 2;
    pLine->cConnections = 0;
    pLine->cControls = 2;

    LoadString( g_hDllInst,
                IDS_VOLUME_NAME,
                pLine->szShortName,
                RTL_NUMBER_OF( pLine->szShortName ));

    LoadString( g_hDllInst,
                IDS_VOLUME_NAME,
                pLine->szName,
                RTL_NUMBER_OF( pLine->szName ));

    pLine->Target.dwType = MIXERLINE_TARGETTYPE_WAVEOUT;

    pLine->Target.dwDeviceID = WAVE_MAPPER;

    pLine->Target.wMid = MM_MICROSOFT;
    pLine->Target.wPid = MM_MSFT_GENERIC_WAVEOUT;
    pLine->Target.vDriverVersion = TSSND_DRIVER_VERSION;

    LoadString( g_hDllInst,
                IDS_DRIVER_NAME,
                pLine->Target.szPname,
                RTL_NUMBER_OF( pLine->Target.szPname ));

    return MMSYSERR_NOERROR;
}

DWORD
RDPMixerGetLineInfo(
    PMIXERCTX   pMixer,
    PMIXERLINE  pLine,
    DWORD_PTR   dwFlags
    )
{
    DWORD rv = MMSYSERR_ERROR;

    if ( pLine->cbStruct < sizeof( *pLine ))
    {
        TRC(ERR, "MixerGetLineInfo: invalid lineinfo size: %d\n", pLine->cbStruct );
        rv = MMSYSERR_INVALPARAM;
        goto exitpt;
    }

    switch( dwFlags & MIXER_GETLINEINFOF_QUERYMASK )
    {

    case MIXER_GETLINEINFOF_DESTINATION:
        TRC( ALV, "MixerGetLineInfo: MIXER_GETLINEINFOF_DESTINATION\n" );
        if ( 0 != pLine->dwDestination )
        {   
            //
            //  there's just one destination
            //
            TRC( ERR, "MixerGetLineInfo: invalid destination: %d\n", pLine->dwDestination );
            rv = MMSYSERR_INVALPARAM;
            goto exitpt;
        }
        rv = _FillMixerLineInfo( pLine );
    break;

    case MIXER_GETLINEINFOF_TARGETTYPE:
        TRC( ALV, "MixerGetLineInfo: MIXER_GETLINEINFOF_TARGETTYPE\n" );
        if ( MIXERLINE_TARGETTYPE_WAVEOUT != pLine->Target.dwType )
        {
            TRC( ERR, "MIXER_GETLINEINFOF_TARGETTYPE for unsupported type=0x%x\n", pLine->Target.dwType );
            rv = MMSYSERR_NOTSUPPORTED;
            goto exitpt;
        }
        rv = _FillMixerLineInfo( pLine );
    break;

    case MIXER_GETLINEINFOF_COMPONENTTYPE:
        TRC( ALV, "MixerGetLineInfo: MIXER_GETLINEINFOF_COMPONENTTYPE\n" );
        if ( MIXERLINE_COMPONENTTYPE_DST_SPEAKERS != pLine->dwComponentType )
        {
            TRC( ERR, "MIXER_GETLINEINFOF_COMPONENTTYPE for unsupported type=0x%x\n", pLine->dwComponentType );
            rv = MMSYSERR_NOTSUPPORTED;
            goto exitpt;
        }
        rv = _FillMixerLineInfo( pLine );
    break;

    case MIXER_GETLINEINFOF_LINEID:
        TRC( ALV, "MIXER_GETLINEINFOF_LINEID\n" );
        if ( 0 != pLine->dwLineID )
        {
            TRC( ERR, "MIXER_GETLINEINFOF_LINEID for invalid line ID: %d\n", pLine->dwLineID );
            rv = MIXERR_INVALLINE;
            goto exitpt;
        }
        rv = _FillMixerLineInfo( pLine );
    break;
    }

exitpt:
    return rv;
}

DWORD
_FillLineControl(
    PMIXERLINECONTROLS pc,
    DWORD dwControlId
    )
{
    DWORD rv = MMSYSERR_ERROR;
    PMIXERCONTROL pmc;
    DWORD dwMax = (DWORD)-1;

    if ( pc->cbmxctrl < sizeof( *(pc->pamxctrl )))
    {
        TRC( ERR, "_FillLineControl: no enough space\n" );
        rv = MMSYSERR_INVALPARAM;
        goto exitpt;
    }

    pc->dwLineID = 0;
    pmc = pc->pamxctrl;

    pmc->cbStruct = sizeof( *pmc );
    pmc->dwControlID = dwControlId;
    switch( dwControlId )
    {
//    case RDP_MXDID_MIXER:  pmc->dwControlType = MIXERCONTROL_CONTROLTYPE_MIXER;  break;
    case RDP_MXDID_VOLUME: pmc->dwControlType = MIXERCONTROL_CONTROLTYPE_VOLUME; dwMax = (WORD)-1; break;
    case RDP_MXDID_MUTE:   pmc->dwControlType = MIXERCONTROL_CONTROLTYPE_MUTE; dwMax = 1;  break;
    }
    pmc->fdwControl = 0;
    pmc->cMultipleItems = 0;

    LoadString( g_hDllInst,
                IDS_VOLUME_NAME,
                pmc->szShortName,
                RTL_NUMBER_OF( pmc->szShortName ));

    LoadString( g_hDllInst,
                IDS_VOLUME_NAME,
                pmc->szName,
                RTL_NUMBER_OF( pmc->szName ));

    pmc->Bounds.dwMinimum = 0;
    pmc->Bounds.dwMaximum = dwMax;
    pmc->Metrics.cSteps = 1;
    rv = MMSYSERR_NOERROR;

exitpt:
    return rv;
}

DWORD
_FillLineControlAll(
    PMIXERLINECONTROLS pc
    )
{
    DWORD rv = MMSYSERR_ERROR;
    PMIXERCONTROL pmc;
    PMIXERCONTROL pnextmc;

    if ( pc->cbmxctrl < sizeof( *(pc->pamxctrl )))
    {
        TRC( ERR, "_FillLineControl: no enough space\n" );
        rv = MMSYSERR_INVALPARAM;
        goto exitpt;
    }

    if ( 2 != pc->cControls )
    {
        TRC( ERR, "_FillLineControl: invalid number of lines\n" );
        rv = MMSYSERR_INVALPARAM;
        goto exitpt;
    }

    pc->dwLineID = 0;
    pmc = pc->pamxctrl;

    pmc->cbStruct = sizeof( *pmc );
    pmc->dwControlID = RDP_MXDID_MUTE;
    pmc->dwControlType = MIXERCONTROL_CONTROLTYPE_MUTE;
    pmc->fdwControl = 0;
    pmc->cMultipleItems = 0;

    LoadString( g_hDllInst,
                IDS_VOLUME_NAME,
                pmc->szShortName,
                RTL_NUMBER_OF( pmc->szShortName ));

    LoadString( g_hDllInst,
                IDS_VOLUME_NAME,
                pmc->szName,
                RTL_NUMBER_OF( pmc->szName ));

    pmc->Bounds.dwMinimum = 0;
    pmc->Bounds.dwMaximum = 1;
    pmc->Metrics.cSteps = 1;

    //
    //  copy the volume struct
    //
    pnextmc = (PMIXERCONTROL)(((PBYTE)pmc) + pc->cbmxctrl);
    RtlCopyMemory( pnextmc, pmc, sizeof( *pmc ));
    pmc = pnextmc;
    pmc->dwControlID = RDP_MXDID_VOLUME;
    pmc->dwControlType = MIXERCONTROL_CONTROLTYPE_VOLUME;
    pmc->Bounds.dwMinimum = 0;
    pmc->Bounds.dwMaximum = (WORD)(-1);

    rv = MMSYSERR_NOERROR;

exitpt:
    return rv;
}

DWORD
RDPMixerGetLineControls(
    PMIXERCTX pMixer,
    PMIXERLINECONTROLS pControls,
    DWORD_PTR   fdwControls
    )
{
    DWORD rv = MMSYSERR_ERROR;
    DWORD dwControlId;

    if ( pControls->cbStruct < sizeof( *pControls ))
    {
        TRC(ERR, "MixerGetLineControls: invalid linecontrols size: %d\n", pControls->cbStruct );
        rv = MMSYSERR_INVALPARAM;
        goto exitpt;
    }

    switch( fdwControls )
    {
    case MIXER_GETLINECONTROLSF_ONEBYTYPE:
        TRC( ALV, "MixerGetLineControls: MIXER_GETLINECONTROLSF_ONEBYTYPE\n",
            pControls->dwControlType );
        if ( 0 != pControls->dwLineID )
        {
            rv = MIXERR_INVALLINE;
            goto exitpt;
        }
        switch( pControls->dwControlType )
        {
//        case MIXERCONTROL_CONTROLTYPE_MIXER: dwControlId = RDP_MXDID_MIXER; break;
        case MIXERCONTROL_CONTROLTYPE_VOLUME: dwControlId = RDP_MXDID_VOLUME; break;
        case MIXERCONTROL_CONTROLTYPE_MUTE:  dwControlId = RDP_MXDID_MUTE; break;
        default:
            rv = MMSYSERR_NOTSUPPORTED;
            goto exitpt;
        }
        rv = _FillLineControl( pControls, dwControlId ); 
    break;
    case MIXER_GETLINECONTROLSF_ONEBYID:
        TRC( ALV, "MixerGetLineControls: MIXER_GETLINECONTROLSF_ONEBYID\n" );
        if ( RDP_MXDID_LAST <= pControls->dwControlID )
        {
            TRC( ERR, "MixerGetLineControls: invalid line id: %d\n", pControls->dwControlID );
            rv = MIXERR_INVALCONTROL;
            goto exitpt;
        }
        rv = _FillLineControl( pControls, pControls->dwControlID );
    break;
    case MIXER_GETLINECONTROLSF_ALL:
        TRC( ALV, "MixerGetLineControls: MIXER_GETLINECONTROLSF_ALL\n" );
        if ( 0 != pControls->dwLineID )
        {
            rv = MIXERR_INVALLINE;
            goto exitpt;
        }
        if ( 2 > pControls->cControls )
        {
            TRC( ERR, "MixerGetLineControls: invalid cControls=%d\n", pControls->cControls );
            rv = MIXERR_INVALCONTROL;
            goto exitpt;
        }
        rv = _FillLineControlAll( pControls );
    break;
    }

exitpt:
    return rv;
}

DWORD
RDPMixerGetSetControlDetails( 
    PMIXERCTX               pMixer, 
    PMIXERCONTROLDETAILS    pDetails,
    DWORD_PTR               fdwDetails,
    BOOL                    bGet
    )
{
    DWORD           rv = MMSYSERR_ERROR;
    DWORD           fdw;

    if ( pDetails->cbStruct < sizeof( *pDetails ))
    {
        TRC( ERR, "Mixer%sControlDetails: invalid details size\n", (bGet)?"Get":"Set" );
        rv = MMSYSERR_INVALPARAM;
        goto exitpt;
    }

    if ( 0 != pDetails->cMultipleItems &&
         1 != pDetails->cMultipleItems )
    {
        rv = MMSYSERR_INVALPARAM;
        goto exitpt;
    }

    if ( RDP_MXDID_LAST <= pDetails->dwControlID )
    {
        TRC( ERR, "Mixer%sControlDetails: invalid control id: %d\n", (bGet)?"Get":"Set", pDetails->dwControlID );
        rv = MIXERR_INVALCONTROL;
        goto exitpt;
    }

    fdw = PtrToLong( (PVOID)(MIXER_GETCONTROLDETAILSF_QUERYMASK & fdwDetails));

    if ( MIXER_GETCONTROLDETAILSF_VALUE == fdw )
    {
        TRC( ALV, "Mixer%sControlDetails: read VALUE, cbDetail=%d, cChannels=%d, controlId=%d\n", 
            (bGet)?"Get":"Set",
            pDetails->cbDetails, pDetails->cChannels,
            pDetails->dwControlID
            );
        ASSERT( pDetails->cbDetails == sizeof( DWORD ));
        if ( pDetails->cbDetails == sizeof( DWORD ))
        {
            DWORD dwVal = *(DWORD *)pDetails->paDetails;
            if ( !bGet )
            {
                if ( 2 != pDetails->cChannels &&
                     1 != pDetails->cChannels )
                {
                    TRC( ERR, "Unexpected # channels\n" );
                    rv = MMSYSERR_INVALPARAM;
                    goto exitpt;
                }
            //
            //  the mute has different control id
            //
                if ( RDP_MXDID_MUTE == pDetails->dwControlID )
                {
                    rv = waveSetMute( NULL, (dwVal != 0) );
                } else {
                //
                //  this will set the volume
                //  there should be 2 channels for stereo
                //
                    if ( pDetails->cChannels == 2 )
                    {
                        DWORD dwChanLeft, dwChanRight;

                        dwChanRight = ((DWORD *)pDetails->paDetails)[0];
                        dwChanLeft = ((DWORD *)pDetails->paDetails)[1];
                        dwVal   = ((dwChanLeft & 0xffff) << 16) | ( dwChanRight & 0xffff );
                    } else {
                        dwVal = ((DWORD *)pDetails->paDetails)[0];
                        dwVal |= dwVal << 16;
                    }
                    rv = waveSetVolume( NULL, dwVal );
                }
                
            } else {
                if ( 2 != pDetails->cChannels &&
                     1 != pDetails->cChannels )
                {
                    TRC( ERR, "Unexpected # channels\n" );
                    rv = MMSYSERR_INVALPARAM;
                    goto exitpt;
                }
                //
                //  get the new volume value
                //
                if ( RDP_MXDID_MUTE == pDetails->dwControlID )
                {
                    rv =  waveGetMute( NULL, &dwVal );
                    ((DWORD *)(pDetails->paDetails))[0] = dwVal;
                    if ( 2 == pDetails->cChannels )
                    {
                        ((DWORD *)(pDetails->paDetails))[1] = dwVal;
                    }
                } else {
                    //
                    // get the volume
                    //
                    rv = waveGetVolume( NULL, &dwVal );
                    TRC( ALV, "GET Volume=0x%x\n", dwVal );
                    if ( 2 == pDetails->cChannels )
                    {
                        ((DWORD *)(pDetails->paDetails))[0] = dwVal & 0xffff; // right
                        ((DWORD *)(pDetails->paDetails))[1] = dwVal >> 16;    // left
                    } else
                    {
                        // get an average
                        //
                        ((DWORD *)(pDetails->paDetails))[0] = 
                            (( dwVal & 0xffff ) + ( dwVal >> 16 )) / 2;
                    }
                }
            }
        }
    } else {
        TRC( ERR, "Mixer%sControlDetails fdwDetails=0x%x\n", 
                (bGet)?"Get":"Set", fdwDetails );
    }

exitpt:
    return rv;
}

DWORD
APIENTRY
mxdMessage(
    UINT    uDeviceID,
    UINT    uMessage,
    DWORD_PTR   dwUser,
    DWORD_PTR   dwParam1,
    DWORD_PTR   dwParam2
    )
{
    DWORD rv = MMSYSERR_ERROR;
    PMIXERCTX pMixer = (PMIXERCTX)dwUser;

    switch ( uMessage )
    {

    case MXDM_GETNUMDEVS:
        TRC( ALV, "WXDM_GETNUMDEVS\n");
        return 1;

    case MXDM_GETDEVCAPS:
        TRC( ALV, "MXDM_GETDEVCAPS\n" );
        rv = RDPMixerGetDevCaps( pMixer, (PMIXERCAPS)dwParam1, dwParam2 );
    break;

    case MXDM_OPEN:
        TRC( ALV, "MXDM_OPEN\n" );
        rv = RDPMixerOpen( (PMIXERCTX *)dwUser,
                        (PMIXEROPENDESC)dwParam1,
                        dwParam2 );
    break;

    case MXDM_CLOSE:
        TRC( ALV, "MXDM_CLOSE\n" );
        rv = RDPMixerClose( pMixer );
    break;

    case MXDM_GETLINEINFO:
        TRC( ALV, "MXDM_GETLINEINFO\n" );
        rv = RDPMixerGetLineInfo( pMixer, (PMIXERLINE)dwParam1, dwParam2 );
    break;
        
    case MXDM_GETLINECONTROLS:
        TRC( ALV, "MXDM_GETLINECONTROLS\n" );
        rv = RDPMixerGetLineControls( pMixer, (PMIXERLINECONTROLS)dwParam1, dwParam2 );
    break;

    case MXDM_GETCONTROLDETAILS:
        TRC( ALV, "MXDM_GETCONTROLDETAILS\n" );
        rv = RDPMixerGetSetControlDetails( pMixer, (PMIXERCONTROLDETAILS)dwParam1, dwParam2, TRUE );
    break;

    case MXDM_SETCONTROLDETAILS:
        TRC( ALV, "MXDM_SETCONTROLDETAILS\n" );
        rv = RDPMixerGetSetControlDetails( pMixer, (PMIXERCONTROLDETAILS)dwParam1, dwParam2, FALSE );
    break;

    default:
        TRC( ALV, "Message id=%d\n", uMessage );
    }

    return rv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpsnd\rdpsnd.h ===
/////////////////////////////////////////////////////////////////////
//
//      Module:     tssnd.h
//
//      Copyright(C) Microsoft Corporation 2000
//
//      History:    4-10-2000  vladimis [created]
//
/////////////////////////////////////////////////////////////////////

#ifndef _TSSND_H
#define _TSSND_H

//
//  Includes
//
#include    <nt.h>
#include    <ntrtl.h>
#include    <nturtl.h>
#include    <windows.h>
#include    <mmsystem.h>
#include    <mmreg.h>
#include    <mmddk.h>
#include    <winsock.h>

#include    "rdpstrm.h"

//
//  Defines
//
#undef  ASSERT
#ifdef  DBG
#define TRC     _DebugMessage
#define ASSERT(_x_)     if (!(_x_)) \
                        {  TRC(FATAL, "ASSERT failed, line %d, file %s\n", \
                        __LINE__, __FILE__); DebugBreak(); }
#else   // !DBG
#define TRC
#define ASSERT
#endif  // !DBG

#define TSHEAPINIT      {g_hHeap = HeapCreate(0, 800, 0);}
#define TSISHEAPOK      (NULL != g_hHeap)
#define TSMALLOC(_x_)   HeapAlloc(g_hHeap, 0, _x_)
#define TSREALLOC(_p_, _x_) \
                        HeapReAlloc(g_hHeap, 0, _p_, _x_);
#define TSFREE(_p_)     HeapFree(g_hHeap, 0, _p_)
#define TSHEAPDESTROY   { HeapDestroy(g_hHeap); g_hHeap = 0; }

#define TSSND_DRIVER_VERSION    1

#define IDS_DRIVER_NAME 101
#define IDS_VOLUME_NAME 102

//
//  Constants
//
extern const CHAR  *ALV;
extern const CHAR  *INF;
extern const CHAR  *WRN;
extern const CHAR  *ERR;
extern const CHAR  *FATAL;

//
//  Structures
//
typedef struct _WAVEOUTCTX {
    HANDLE      hWave;                      // handle passed by the user
    DWORD_PTR   dwOpenFlags;                //
    DWORD_PTR   dwCallback;                 // callback parmeter
    DWORD_PTR   dwInstance;                 // user's instance
    DWORD       dwSamples;                  // samples played
    DWORD       dwBytesPerSample;           //
    DWORD       dwXlateRate;                //
    BOOL        bPaused;                    // is the stream paused
    BOOL        bDelayed;
    VOID      (*lpfnPlace)(PVOID, PVOID, DWORD);    // mixer fn
    BYTE        cLastStreamPosition;        // last position in the stream
    DWORD       dwLastStreamOffset;         //
    DWORD       dwLastHeaderOffset;         //
    DWORD       Format_nBlockAlign;         // current format params
    DWORD       Format_nAvgBytesPerSec;
    DWORD       Format_nChannels;
    HANDLE      hNoDataEvent;               // signaled when all blocks are done
    LONG        lNumberOfBlocksPlaying;     // number of blocks in the queue
    PWAVEHDR    pFirstWaveHdr;              // block list
    PWAVEHDR    pFirstReadyHdr;             // list of done blocks
    PWAVEHDR    pLastReadyHdr;
    struct      _WAVEOUTCTX *lpNext;
} WAVEOUTCTX, *PWAVEOUTCTX;


//
//  mixer context
//
typedef struct _MIXERCTX {
    PVOID   pReserved;
} MIXERCTX, *PMIXERCTX;

//
//  Internal function definitions
//

//
//  Trace
//
VOID
_cdecl
_DebugMessage(
    LPCSTR  szLevel,
    LPCSTR  szFormat,
    ...
    );

//
//  Threads
//
DWORD
WINAPI
waveMixerThread(
    PVOID   pParam
    );

LRESULT
drvEnable(
    VOID
    );

LRESULT
drvDisable(
    VOID
    );

BOOL
_waveCheckSoundAlive(
    VOID
    );

BOOL
_waveAcquireStream(
    VOID
    );

HANDLE
_CreateInitEvent(
    VOID
    );

BOOL
_EnableMixerThread(
    VOID
    );

BOOL
AudioRedirDisabled(
    VOID
    );
//
//  Globals
//
extern HANDLE      g_hHeap;                 // private heap

extern HINSTANCE   g_hDllInst;

extern CRITICAL_SECTION    g_cs;
extern HANDLE              g_hMixerEvent;
extern HANDLE              g_hMixerThread;

extern HANDLE      g_hWaitToInitialize;
extern HANDLE      g_hDataReadyEvent;
extern HANDLE      g_hStreamIsEmptyEvent;
extern HANDLE      g_hStreamMutex;
extern HANDLE      g_hStream;
extern PSNDSTREAM  g_Stream;

extern BOOL        g_bMixerRunning;
extern BOOL        g_bPersonalTS;

#endif  // !_TSSND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpsnd\rdpsnd.c ===
/////////////////////////////////////////////////////////////////////
//
//      Module:     rdpsnd.c
//
//      Purpose:    User-mode audio driver for terminal server
//                  audio redirection
//
//      Copyright(C) Microsoft Corporation 2000
//
//      History:    4-10-2000  vladimis [created]
//
/////////////////////////////////////////////////////////////////////

#include    "rdpsnd.h"
#include    <stdio.h>
#include    <aclapi.h>
#include    <psapi.h>

#define WINLOGON_EXE    L"\\??\\%SystemRoot%\\system32\\winlogon.exe"

const CHAR  *ALV =   "TSSND::ALV - ";
const CHAR  *INF =   "TSSND::INF - ";
const CHAR  *WRN =   "TSSND::WRN - ";
const CHAR  *ERR =   "TSSND::ERR - ";
const CHAR  *FATAL = "TSSND::FATAL - ";

HANDLE  g_hHeap = NULL;

HANDLE  g_hMixerThread = NULL;

HINSTANCE g_hDllInst = NULL;

BOOL    g_bPersonalTS = FALSE;

BOOL  bInitializedSuccessfully = FALSE;

/*
 *  Function:
 *      DllInstanceInit
 *
 *  Description:
 *      Dll main enrty point
 *
 */
BOOL
DllInstanceInit(
    HINSTANCE hDllInst,
    DWORD     dwReason,
    LPVOID    fImpLoad
    )
{
    BOOL rv = FALSE;

    if          (DLL_PROCESS_ATTACH == dwReason)
    {
        TRC(ALV, "DLL_PROCESS_ATTACH\n");
        TSHEAPINIT;

        if (!TSISHEAPOK)
        {
            TRC(FATAL, "DllInstanceInit: can't create heap\n");
            goto exitpt;
        }

        __try {
            InitializeCriticalSection(&g_cs);
            rv = TRUE;
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            rv = FALSE;
        }

        if (!rv)
        {
            TRC(FATAL, "DllInstanceInit: can't initialize critical section\n");
            goto exitpt;
        }

        DisableThreadLibraryCalls(hDllInst);
        g_hDllInst = hDllInst;

        rv = TRUE;

    } else if   (DLL_PROCESS_DETACH == dwReason)
    {
        TRC(ALV, "DLL_PROCESS_DETACH\n");
        TSHEAPDESTROY;
        rv = TRUE;
    }

exitpt:
    return rv;
}

BOOL
IsPersonalTerminalServicesEnabled(
    VOID
    )
{
    BOOL fRet;
    DWORDLONG dwlConditionMask;
    OSVERSIONINFOEX osVersionInfo;

    RtlZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osVersionInfo.wProductType = VER_NT_WORKSTATION;
    osVersionInfo.wSuiteMask = VER_SUITE_SINGLEUSERTS;

    dwlConditionMask = 0;
    VER_SET_CONDITION(dwlConditionMask, VER_PRODUCT_TYPE, VER_EQUAL);
    VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);

    fRet = VerifyVersionInfo(
            &osVersionInfo,
            VER_PRODUCT_TYPE | VER_SUITENAME,
            dwlConditionMask
            );

    return(fRet);
}

BOOL
RunningInWinlogon()
{
    WCHAR szWinlogonOrg[128];
    WCHAR szFile[128];
    static BOOL s_bWinlogonChecked = FALSE;
    static BOOL s_bWinlogonResult  = FALSE;

    if ( s_bWinlogonChecked )
    {
        goto exitpt;
    }

    szWinlogonOrg[0] = 0;
    if (!ExpandEnvironmentStrings( WINLOGON_EXE, szWinlogonOrg, RTL_NUMBER_OF( szWinlogonOrg )))
    {
        TRC( ERR, "Failed to get winlogon path: GetLastError=%d\n", GetLastError());
        goto exitpt;
    }

    if ( !GetModuleFileNameEx( 
            GetCurrentProcess(), 
            GetModuleHandle( NULL ), 
            szFile, 
            RTL_NUMBER_OF( szFile )))
    {
        TRC( ERR, "GetModuleFileNameEx failed: GetLastError=%d\n", GetLastError());
        goto exitpt;
    }

    s_bWinlogonChecked = TRUE;

    s_bWinlogonResult = ( 0 == _wcsicmp( szFile, szWinlogonOrg ));

exitpt:
    return s_bWinlogonResult;
}

HANDLE
_CreateInitEvent(
    VOID
    )
{
    SECURITY_ATTRIBUTES SA;
    PSECURITY_DESCRIPTOR pSD = NULL;
    EXPLICIT_ACCESS ea[2];
    SID_IDENTIFIER_AUTHORITY siaWorld   = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY siaNT      = SECURITY_NT_AUTHORITY;
    PSID pSidWorld = NULL;
    PSID pSidNT = NULL;
    PACL pNewDAcl = NULL;
    DWORD dwres;
    HANDLE  hWaitToInit = NULL;

    //
    //  wait, before creating this event, check if we are running inside winlogon
    //  only then create this event, because only then we have to delay
    //  audio rendering of the logon sound (aka "TADA")
    //
    if ( !RunningInWinlogon() )
    {
        goto exitpt;
    } else {
        TRC( INF, "running in winlogon, delayed audio rendering\n" );
    }

    pSD = (PSECURITY_DESCRIPTOR) TSMALLOC(SECURITY_DESCRIPTOR_MIN_LENGTH);
    if ( NULL == pSD )
        goto exitpt;

    if ( !AllocateAndInitializeSid(
            &siaWorld, 1, SECURITY_WORLD_RID, 
            0, 0, 0, 0, 0, 0, 0, &pSidWorld))
    {
        goto exitpt;
    }

    if ( !AllocateAndInitializeSid(
            &siaNT, 1, SECURITY_LOCAL_SYSTEM_RID, 
            0, 0, 0, 0, 0, 0, 0, &pSidNT ))
    {
        goto exitpt;
    }

    ZeroMemory(ea, sizeof(ea));
    ea[0].grfAccessPermissions = EVENT_MODIFY_STATE;
    ea[0].grfAccessMode = GRANT_ACCESS;
    ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[0].Trustee.ptstrName = (LPTSTR)pSidWorld;
    ea[1].grfAccessPermissions = GENERIC_ALL;
    ea[1].grfAccessMode = GRANT_ACCESS;
    ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[1].Trustee.ptstrName = (LPTSTR)pSidNT;

    dwres = SetEntriesInAcl(2, ea, NULL, &pNewDAcl );
    if ( ERROR_SUCCESS != dwres )
    {
        goto exitpt;
    }

    if (!InitializeSecurityDescriptor(pSD,
                                      SECURITY_DESCRIPTOR_REVISION))
        goto exitpt;

    if (!SetSecurityDescriptorDacl(pSD,
                                   TRUE,     // specifying a disc. ACL
                                   pNewDAcl,
                                   FALSE))  // not a default disc. ACL
        goto exitpt;

    SA.nLength = sizeof( SA );
    SA.lpSecurityDescriptor = pSD;
    SA.bInheritHandle = FALSE;

    hWaitToInit = CreateEvent( &SA,
                               FALSE,
                               FALSE,
                               TSSND_WAITTOINIT );
    if ( NULL == hWaitToInit )
    {
        TRC( ALV, "Failed to create WaitToInit event:%d\n",
            GetLastError());
    } else if ( ERROR_ALREADY_EXISTS == GetLastError() ) 
    {
        CloseHandle( hWaitToInit );
        TRC( ALV, "Init event already exists\n" );
        hWaitToInit = NULL;   
    }

exitpt:

    if ( NULL != pNewDAcl )
    {
        LocalFree( pNewDAcl );
    }

    if ( NULL != pSidNT )
    {
        LocalFree( pSidNT );
    }

    if ( NULL != pSidWorld )
    {
        LocalFree( pSidWorld );
    }

    if ( NULL != pSD )
    {
        TSFREE( pSD );
    }

    return hWaitToInit;
}

/*
 *  Function:
 *      drvEnable
 *
 *  Description:
 *      Initializes the driver
 *
 */
LRESULT
drvEnable(
    VOID
    )
{
    LRESULT rv = 1;

    EnterCriticalSection(&g_cs);

    if (bInitializedSuccessfully)
    {
        rv = 1;
        goto exitpt;
    }

    if ( NULL == g_hDataReadyEvent )
        g_hDataReadyEvent       = OpenEvent(EVENT_ALL_ACCESS, 
                                            FALSE, 
                                            TSSND_DATAREADYEVENT);

    if (NULL == g_hDataReadyEvent)
    {
        TRC(ALV, "DRV_ENABLE: can't open %S: %d\n",
                TSSND_DATAREADYEVENT,
                GetLastError());

        rv = 0;
    }

    if ( NULL == g_hStreamIsEmptyEvent )
        g_hStreamIsEmptyEvent   = OpenEvent(EVENT_ALL_ACCESS, 
                                            FALSE, 
                                            TSSND_STREAMISEMPTYEVENT);
    if (NULL == g_hDataReadyEvent)
    {
        TRC(ALV, "DRV_ENABLE: can't open %S: %d\n",
                TSSND_STREAMISEMPTYEVENT,
                GetLastError());
        rv = 0;
    }

    if ( NULL == g_hStreamMutex )
        g_hStreamMutex          = OpenMutex(SYNCHRONIZE,
                                            FALSE,
                                            TSSND_STREAMMUTEX);
    if (NULL == g_hDataReadyEvent)
    {
        TRC(ALV, "DRV_ENABLE: can't open %S: %d\n",
                TSSND_STREAMMUTEX,
                GetLastError());
        rv = 0;
    }

    if ( NULL == g_hMixerEvent )
        g_hMixerEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (NULL == g_hMixerEvent)
    {
        TRC(ERR, "DRV_ENABLE: can't create mixer event: %d\n",
            GetLastError());
        rv = 0;
    }

    if ( NULL == g_hStream )
        g_hStream = OpenFileMapping(
                        FILE_MAP_ALL_ACCESS,
                        FALSE,
                        TSSND_STREAMNAME
                    );

    if (NULL == g_hStream)
    {
        TRC(ALV, "Can't open the stream mapping\n");
        rv = 0;
    }

    if ( (NULL == g_Stream) && (NULL != g_hStream) )
        g_Stream = MapViewOfFile(
                    g_hStream,
                    FILE_MAP_ALL_ACCESS,
                    0, 0,       // offset
                    sizeof(*g_Stream)
                    );

    if (NULL == g_Stream)
    {
        TRC(ALV, "drvEnale: "
                 "can't map the stream view: %d\n",
                 GetLastError());
        rv = 0;
    }

    g_bPersonalTS = IsPersonalTerminalServicesEnabled();

    if ( 1 == rv &&
         NULL != g_Stream &&
         0 != ( g_Stream->dwSoundCaps & TSSNDCAPS_INITIALIZED ))
    {
        rv = _EnableMixerThread();
    }

exitpt:

    if (0 != rv)
    {
        bInitializedSuccessfully = TRUE;
    }

    //
    //  waiting for initialization ?
    //
    if ((   0 == rv ||
            NULL == g_Stream ||
            0 == ( g_Stream->dwSoundCaps & TSSNDCAPS_INITIALIZED )) &&
        !AudioRedirDisabled() &&
        NULL == g_hWaitToInitialize )
    {
        g_hWaitToInitialize = _CreateInitEvent();
    }

    LeaveCriticalSection(&g_cs);

    return rv;
}

/*
 *  Function:
 *      drvDisable
 *
 *  Description:
 *      Driver cleanup
 *
 */
LRESULT
drvDisable(
    VOID
    )
{
    HANDLE hStreamMutex;

    EnterCriticalSection(&g_cs);

    hStreamMutex = g_hStreamMutex;

    _waveAcquireStream();

    TRC( INF, "drvDisable PID(0x%x)\n", GetCurrentProcessId() );

    if (NULL == g_hMixerThread ||
        NULL == g_hMixerEvent)
        goto exitpt;
    //
    //  Disable the mixer
    //
    g_bMixerRunning = FALSE;

    //
    //  Kick the mixer thread, so it exits
    //
    SetEvent(g_hMixerEvent);

    WaitForSingleObject(g_hMixerThread, INFINITE);
    
exitpt:

    if ( NULL != g_hWaitToInitialize )
    {
        CloseHandle( g_hWaitToInitialize );
    }

    if (NULL != g_hDataReadyEvent)
        CloseHandle(g_hDataReadyEvent);

    if (NULL != g_hStreamIsEmptyEvent)
        CloseHandle(g_hStreamIsEmptyEvent);

    if (NULL != g_hMixerEvent)
        CloseHandle(g_hMixerEvent);

    if (NULL != g_Stream)
        UnmapViewOfFile(g_Stream);

    if (NULL != g_hStream)
        CloseHandle(g_hStream);

    if (NULL != g_hMixerThread)
        CloseHandle(g_hMixerThread);

    g_hWaitToInitialize     = NULL;
    g_hDataReadyEvent       = NULL;
    g_hStreamIsEmptyEvent   = NULL;
    g_hMixerEvent           = NULL;
    g_hStreamMutex          = NULL;
    g_Stream                = NULL;
    g_hStream               = NULL;
    g_hMixerThread          = NULL;
    g_bMixerRunning         = FALSE;

    bInitializedSuccessfully = FALSE;

    if (NULL != hStreamMutex)
        CloseHandle(hStreamMutex);  // this will release the stream

    LeaveCriticalSection(&g_cs);

    return 1;
}

/*
 *  Function:
 *      DriverProc
 *
 *  Description:
 *      Driver main entry point
 *
 */
LRESULT
DriverProc(
    DWORD_PTR   dwDriverID,
    HANDLE      hDriver,
    UINT        uiMessage,
    LPARAM      lParam1,
    LPARAM      lParam2
    )
{
    LRESULT rv = 0; 

    //  Here, we don't do anything but trace and call DefDriverProc
    //
    switch (uiMessage)
    {
    case DRV_LOAD:
        TRC(ALV, "DRV_LOAD\n");
        rv = 1;
    break;

    case DRV_FREE:
        TRC(ALV, "DRV_FREE\n");

        rv = 1;
    break;

    case DRV_OPEN:
        TRC(ALV, "DRV_OPEN\n");
        rv = 1;
    break;

    case DRV_CLOSE:
        TRC(ALV, "DRV_CLOSE\n");
        rv = 1;
    break;

    case DRV_ENABLE:
        TRC(ALV, "DRV_ENABLE\n");
        rv = 1;
        break;

    case DRV_DISABLE:
        TRC(ALV, "DRV_DISABLE\n");
        rv = drvDisable();
        break;

    case DRV_QUERYCONFIGURE:
        TRC(ALV, "DRV_QUERYCONFIGURE\n");
        rv = 0;
        break;

    case DRV_CONFIGURE:
        TRC(ALV, "DRV_CONFIGURE\n");
        rv = 0;
        break;

    default:
        rv = DefDriverProc(
                    dwDriverID,
                    hDriver,
                    uiMessage,
                    lParam1,
                    lParam2
                );
        TRC(ALV, "DRV_UNKNOWN(%d): DefDriverProc returned %d\n", 
            uiMessage, rv);
    }

    return rv;
}

VOID
_cdecl
_DebugMessage(
    LPCSTR  szLevel,
    LPCSTR  szFormat,
    ...
    )
{
    CHAR szBuffer[256];
    va_list     arglist;

    if (ALV == szLevel)
        return;

    va_start (arglist, szFormat);
    _vsnprintf (szBuffer, RTL_NUMBER_OF(szBuffer), szFormat, arglist);
    va_end (arglist);
    szBuffer[ RTL_NUMBER_OF( szBuffer ) - 1 ] = 0;

    OutputDebugStringA(szLevel);
    OutputDebugStringA(szBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\gcc\tgcccb.c ===
//*************************************************************
//
//  File name:      TGccCB.c
//
//  Description:    Contains routines to support GCC
//                  mcs callback processing
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1991-1997
//  All rights reserved
//
//*************************************************************


#include <_tgcc.h>

#include <stdio.h>

// Data declarations

GCCCallBack     g_GCCCallBack = NULL;


//*************************************************************
//
//  gccSetCallback()
//
//  Purpose:    Sets GCC callback address
//
//  Parameters: IN [control_sap_callback]
//
//  Return:     void
//
//  History:    08-10-97    BrianTa     Created
//
//*************************************************************

void
gccSetCallback(IN GCCCallBack control_sap_callback)
{
    TS_ASSERT(control_sap_callback);

    g_GCCCallBack = control_sap_callback;
}


//*************************************************************
//
//  gccConnectProviderIndication()
//
//  Purpose:    GCC_CREATE_INDICATION processing
//
//  Parameters: IN [pcpi]       -- ConnectProviderIndication
//              IN [pvContext]  -- Context
//
//  Return:     void
//
//  History:    08-10-97    BrianTa     Created
//
//*************************************************************

MCSError
gccConnectProviderIndication(IN PConnectProviderIndication pcpi,
                             IN PVOID                      pvContext)
{
    MCSError                    mcsError;
    GCCMessage                  gccMessage;
    CreateIndicationMessage     *pCreateInd;
    GCCUserData                 *pUserData;
    GCCUserData                 UserData;
    USHORT                      usMembers;

    TRACE((DEBUG_GCC_DBFLOW,
            "GCC: gccConnectProviderIndication entry "
            "(MCS userDataLength = 0x%x)\n",
            pcpi->UserDataLength));

    pUserData = &UserData;

    mcsError = gccDecodeUserData(pcpi->pUserData, pcpi->UserDataLength, pUserData);

    if (mcsError == MCS_NO_ERROR)
    {
        ZeroMemory(&gccMessage, sizeof(gccMessage));

        gccMessage.message_type = GCC_CREATE_INDICATION;
        gccMessage.user_defined = pvContext;

        pCreateInd = &gccMessage.u.create_indication;

        pCreateInd->domain_parameters = &pcpi->DomainParams;
        pCreateInd->connection_handle = pcpi->hConnection;

        pCreateInd->number_of_user_data_members = 1;
        pCreateInd->user_data_list = &pUserData;

        TRACE((DEBUG_GCC_DBNORMAL, 
                "GCC: Performing GCC_CREATE_INDICATION callout\n"));

        g_GCCCallBack(&gccMessage);

        TRACE((DEBUG_GCC_DBNORMAL,
                "GCC: Returned from GCC_CREATE_INDICATION callout\n"));

        gccFreeUserData(pUserData);
    }

    TRACE((DEBUG_GCC_DBFLOW,
            "GCC: gccConnectProviderIndication exit - 0x%x\n",
            mcsError));

    return (mcsError);
}


//*************************************************************
//
//  gccDisconnectProviderIndication()
//
//  Purpose:    GCC_DISCONNECT_INDICATION processing
//
//  Parameters: IN [pcpi]       -- DisconnectProviderIndication
//              IN [pvContext]  -- Context
//
//  Return:     void
//
//  History:    08-10-97    BrianTa     Created
//
//*************************************************************

MCSError
gccDisconnectProviderIndication(IN PDisconnectProviderIndication pdpi,
                                IN PVOID                         pvContext)
{
    GCCMessage                  gccMessage;
    DisconnectIndicationMessage *pDiscInd;
    TerminateIndicationMessage  *pTermInd;

    TRACE((DEBUG_GCC_DBFLOW,
            "GCC: gccDisconnectProviderIndication entry\n"));

    // Handle GCC_DISCONNECT_INDICATION

    ZeroMemory(&gccMessage, sizeof(gccMessage));

    gccMessage.message_type = GCC_DISCONNECT_INDICATION;
    gccMessage.user_defined = pvContext;

    pDiscInd = &gccMessage.u.disconnect_indication;

    pDiscInd->reason = pdpi->Reason;

    TRACE((DEBUG_GCC_DBNORMAL, 
            "GCC: Performing GCC_DISCONNECT_INDICATION callout\n"));

    g_GCCCallBack(&gccMessage);

    TRACE((DEBUG_GCC_DBNORMAL, 
            "GCC: Returned from GCC_DISCONNECT_INDICATION callout\n"));

    // Handle GCC_TERMINATE_INDICATION

    ZeroMemory(&gccMessage, sizeof(gccMessage));

    gccMessage.message_type = GCC_TERMINATE_INDICATION;
    gccMessage.user_defined = pvContext;

    pTermInd = &gccMessage.u.terminate_indication;

    pTermInd->reason = pdpi->Reason;

    TRACE((DEBUG_GCC_DBNORMAL, 
            "GCC: Performing GCC_TERMINATE_INDICATION callout\n"));

    g_GCCCallBack(&gccMessage);

    TRACE((DEBUG_GCC_DBNORMAL, 
            "GCC: Returned from GCC_TERMINATE_INDICATION callout\n"));

    TRACE((DEBUG_GCC_DBFLOW,
            "GCC: gccDisconnectProviderIndication exit - 0x%x\n", 
            MCS_NO_ERROR));

    return (MCS_NO_ERROR);
}


//*************************************************************
//
//  mcsCallback()
//
//  Purpose:    MCS node controller callback dispatch processing
//
//  Parameters: IN [hDomain]        -- Domain handle for the callback
//              IN [Message]        -- Callback message
//              IN [pvParam]        -- Param
//              IN [pvContext]      -- Context
//
//  Return:     MCSError
//
//  History:    08-10-97    BrianTa     Created
//
//*************************************************************

MCSError
mcsCallback(DomainHandle hDomain,
            UINT         Message,
            PVOID        pvParam,
            PVOID        pvContext)
{
    MCSError    mcsError;

    TRACE((DEBUG_GCC_DBFLOW,
            "GCC: mcsCallback entry\n"));

    TRACE((DEBUG_GCC_DBDEBUG,
            "GCC: Message 0x%x, pvParam 0x%x, pvContext 0x%x\n",
            Message, pvParam, pvContext));

    switch (Message)
    {
        case MCS_CONNECT_PROVIDER_INDICATION:
            mcsError = gccConnectProviderIndication(
                            (PConnectProviderIndication) pvParam,
                            pvContext);
            break;

        case MCS_DISCONNECT_PROVIDER_INDICATION:
            mcsError = gccDisconnectProviderIndication(
                            (PDisconnectProviderIndication) pvParam,
                            pvContext);
            break;

        default:
            mcsError = MCS_COMMAND_NOT_SUPPORTED;

            TRACE((DEBUG_GCC_DBWARN,
                    "GCC: mcsCallback: Unknown Message 0x%x\n",
                     Message));
            break;
    }

    TRACE((DEBUG_GCC_DBFLOW,
            "GCC: mcsCallback exit - 0x%x\n",
            mcsError));

    return (mcsError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\gcc\tgccdata.c ===
//*************************************************************
//
//  File name:      GccData.c
//
//  Description:    Contains routines to support GCC
//                  user data manipulation
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1991-1997
//  All rights reserved
//
//*************************************************************

#include <_tgcc.h>
#include <stdio.h>

//gccDecodeUserData must have input data size at least 21  
#define GCC_MINIMUM_DATASIZE 21
 
//*************************************************************
//
//  gccDecodeUserData()
//
//  Purpose:    Decodes BER data into GCCUserData
//
//  Parameters: IN  [pData]         -- Ptr to BER data
//              IN  [DataLength]    -- BER data length
//              OUT [pUserData]     -- Ptr to GCCUserData
//
//  Return:     MCSError
//
//  History:    08-10-97    BrianTa     Created
//
//*************************************************************

MCSError
gccDecodeUserData(IN  PBYTE         pData,
                  IN  UINT          DataLength,
                  OUT GCCUserData   *pUserData)
{
    MCSError        mcsError;
    PBYTE           pBerData;
    UINT            UserDataLength, DataLengthValidate;

    TRACE((DEBUG_GCC_DBFLOW,
            "GCC: gccDecodeUserData entry\n"));

    TS_ASSERT(pData);
    TS_ASSERT(DataLength > 0);

    mcsError = MCS_NO_ERROR;

//  TRACE((DEBUG_GCC_DBDEBUG,
//          "GCC: gccDecodeUserData\n"));

//  TSMemoryDump(pData, DataLength);

    //DataLength must be at least GCC_MINIMUM_DATASIZE
    if (DataLength < GCC_MINIMUM_DATASIZE) 
    {
        TRACE((DEBUG_GCC_DBERROR,
                    "GCC: Send data size is too small\n"));
        return MCS_SEND_SIZE_TOO_SMALL;
    }
    DataLengthValidate = GCC_MINIMUM_DATASIZE;

    pBerData = pData;

    // T.124 identifier

    ASSERT(*pBerData == 0x00);
    pBerData++;

    ASSERT(*pBerData == 0x05);
    pBerData++;

    // Chosen object

    pBerData += 5;

    // PDU length

    if (*pBerData & 0x80)
    {
        pBerData++;
        DataLengthValidate++;
    }

    pBerData++;

    // Connect GCC PDU

    ASSERT(*pBerData == 0x00);
    pBerData++;

    ASSERT(*pBerData == 0x08);
    pBerData++;

    // Conference name, etc.

    pBerData += 6;

    // Key

    TS_ASSERT(strncmp(pBerData, "Duca", 4) == 0);

    pUserData->key.key_type = GCC_H221_NONSTANDARD_KEY;
    pUserData->key.u.h221_non_standard_id.octet_string_length = 4;
    pUserData->key.u.h221_non_standard_id.octet_string = pBerData;

    // octet_string

    pBerData += 4;
    UserDataLength = *pBerData++;
    
    if (UserDataLength & 0x80)
    {
        UserDataLength = ((UserDataLength & 0x7f) << 8) + *pBerData++;
        DataLengthValidate++;
    }

    //Adjust used datalength
    DataLengthValidate += UserDataLength;

    //Validate the data length
    if (DataLengthValidate > DataLength) 
    {
        TRACE((DEBUG_GCC_DBERROR,
                    "GCC: Send data size is too small\n"));
        return MCS_SEND_SIZE_TOO_SMALL;
    }

    TS_ASSERT(UserDataLength > 0);

    if (UserDataLength)
    {
        pUserData->octet_string = TSHeapAlloc(0,
                                              sizeof(*pUserData->octet_string),
                                              TS_HTAG_GCC_USERDATA_IN);

        if (pUserData->octet_string)
        {
            pUserData->octet_string->octet_string_length =
                    (USHORT)UserDataLength;
            pUserData->octet_string->octet_string = pBerData;
        }
        else
        {
            TRACE((DEBUG_GCC_DBWARN,
                    "GCC: Cannot allocate octet_string buffer\n"));

            mcsError = MCS_ALLOCATION_FAILURE;
        }
    }
    else
    {
        TRACE((DEBUG_GCC_DBERROR,
                    "GCC: UserDataLength is zero\n"));
        mcsError =  MCS_SEND_SIZE_TOO_SMALL;
    }

    TRACE((DEBUG_GCC_DBFLOW,
            "GCC: gccDecodeUserData (len=0x%x) exit - 0x%x\n",
            UserDataLength, mcsError));

    return (mcsError);
}


//*************************************************************
//
//  gccEncodeUserData()
//
//  Purpose:    Encodes BER data from GCCUserData
//
//  Parameters: IN  [usMembers]         -- Member count
//              IN  [ppDataList]        -- Ptr to GCCUserData array
//              OUT [pUserData]         -- Ptr to BER data
//              OUT [pUserDataLength]   -- Ptr to BER data length
//
//  Return:     MCSError
//
//  History:    08-10-97    BrianTa     Created
//
//*************************************************************

MCSError
gccEncodeUserData(IN  USHORT        usMembers,
                  IN  GCCUserData **ppDataList,
                  OUT PBYTE        *pUserData,
                  OUT UINT         *pUserDataLength)
{
    MCSError        mcsError;
    PBYTE           pBerData;
    UINT            UserDataLength;
    UINT            len;

    TRACE((DEBUG_GCC_DBFLOW,
            "GCC: gccEncodeUserData entry\n"));

    mcsError = MCS_NO_ERROR;

    *pUserData = NULL;
    *pUserDataLength = 0;

    if (ppDataList)
    {
        len = (*ppDataList)->octet_string->octet_string_length;

        pBerData = TSHeapAlloc(0,
                               len + 32,
                               TS_HTAG_GCC_USERDATA_OUT);

        if (pBerData)
        {
            UserDataLength = 0;

            pBerData[UserDataLength++] = 0x00;
            pBerData[UserDataLength++] = 0x05;
            pBerData[UserDataLength++] = 0x00;
            pBerData[UserDataLength++] = 0x14;
            pBerData[UserDataLength++] = 0x7c;
            pBerData[UserDataLength++] = 0x00;
            pBerData[UserDataLength++] = 0x01;
            pBerData[UserDataLength++] = 0x2a;
            pBerData[UserDataLength++] = 0x14;
            pBerData[UserDataLength++] = 0x76;
            pBerData[UserDataLength++] = 0x0a;
            pBerData[UserDataLength++] = 0x01;
            pBerData[UserDataLength++] = 0x01;
            pBerData[UserDataLength++] = 0x00;
            pBerData[UserDataLength++] = 0x01;
            pBerData[UserDataLength++] = 0xc0;
            pBerData[UserDataLength++] = 0x00;

            pBerData[UserDataLength++] = (*ppDataList)->key.u.h221_non_standard_id.octet_string[0];
            pBerData[UserDataLength++] = (*ppDataList)->key.u.h221_non_standard_id.octet_string[1];
            pBerData[UserDataLength++] = (*ppDataList)->key.u.h221_non_standard_id.octet_string[2];
            pBerData[UserDataLength++] = (*ppDataList)->key.u.h221_non_standard_id.octet_string[3];

            if (len >= 128)
                pBerData[UserDataLength++] = (0x80 | (len >> 8));

            pBerData[UserDataLength++] =
                    ((*ppDataList)->octet_string->octet_string_length) & 0xff;

            memcpy(&pBerData[UserDataLength],
                   (*ppDataList)->octet_string->octet_string, len);

            *pUserData = (PBYTE) pBerData;
            *pUserDataLength = len + UserDataLength;

//          TRACE((DEBUG_GCC_DBDEBUG,
//                  "GCC: gccEncodeUserData\n"));

//          TSHeapDump(TS_HEAP_DUMP_ALL,
//                  *pUserData, *pUserDataLength);

            mcsError = MCS_NO_ERROR;
        }
        else
        {
            TRACE((DEBUG_GCC_DBWARN,
                    "GCC: Cannot allocate BER data buffer\n"));

            mcsError = MCS_ALLOCATION_FAILURE;
        }
    }

    TRACE((DEBUG_GCC_DBFLOW,
            "GCC: gccEncodeUserData exit - 0x%x\n",
            mcsError));

    return (mcsError);
}


//*************************************************************
//
//  gccFreeUserData()
//
//  Purpose:    Frees prev allocated GCCUserData
//
//  Parameters: IN [pUserData]          -- Ptr to GCCUserData
//
//  History:    08-10-97    BrianTa     Created
//
//*************************************************************

VOID
gccFreeUserData(IN GCCUserData  *pUserData)
{
    if (pUserData->octet_string)
        TShareFree(pUserData->octet_string);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\gcc\tgcc.c ===
//*************************************************************
//
//  File name:      TGcc.c
//
//  Description:    Contains routines to provide
//                  Tiny GCC support
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1991-1997
//  All rights reserved
//
//*************************************************************

#define _TGCC_ALLOC_DATA_

#include <_tgcc.h>
#include <stdio.h>
#include <mcs.h>


//*************************************************************
//
//  gccMapMcsError()
//
//  Purpose:    Provides MCSError to GCCError mapping
//
//  Parameters: IN [mcsError]       -- MCSError
//
//  Return:     GCCError
//
//  History:    08-10-97    BrianTa     Created
//
//*************************************************************

GCCError
gccMapMcsError(IN MCSError mcsError)
{
    int         i;
    GCCError    gccError;

    gccError = GCC_UNSUPPORTED_ERROR;

    for (i=0; i<sizeof(GccMcsErrorTBL) / sizeof(GccMcsErrorTBL[0]); i++)
    {
        if (GccMcsErrorTBL[i].mcsError == mcsError)
        {
            gccError = GccMcsErrorTBL[i].gccError;
            break;
        }
    }

#if DBG
    if (i < sizeof(GccMcsErrorTBL) / sizeof(GccMcsErrorTBL[0]))
    {
        TRACE((DEBUG_GCC_DBDEBUG,
                "GCC: gccMapMcsError: mcsError 0x%x (%s), gbbError 0x%x (%s)\n",
                mcsError, GccMcsErrorTBL[i].pszMcsMessageText,
                gccError, GccMcsErrorTBL[i].pszGccMessageText));
    }
    else
    {
        TRACE((DEBUG_GCC_DBDEBUG,
                "GCC: gccMapMcsError: mcsError 0x%x (UNKNOWN)\n",
                mcsError));
    }
#endif

    return (gccError);
}


//*************************************************************
//
//  gccInitialized()
//
//  Purpose:    Sets GCC initialized state
//
//  Parameters: IN [fInitialized]   -- State (T/F)
//
//  Return:     void
//
//  History:    08-10-97    BrianTa     Created
//
//*************************************************************

void
gccInitialized(IN BOOL fInitialized)
{
    g_fInitialized = fInitialized;
}


//*************************************************************
//
//  gccIsInitialized()
//
//  Purpose:    Returns GCC initialized state
//
//  Parameters: OUT [gccError]      -- Ptr to return error to
//
//  Return:     TRUE                - if initialized
//              FALSE               - if not initialized
//
//  History:    08-10-97    BrianTa     Created
//
//*************************************************************

BOOL
gccIsInitialized(OUT GCCError *pgccError)
{
    *pgccError = (g_fInitialized ? GCC_ALREADY_INITIALIZED
                                 : GCC_NOT_INITIALIZED);

    return (g_fInitialized);
}


//*************************************************************
//
//  GCCRegisterNodeControllerApplication()
//
//  Purpose:    Performs GCC NC registration
//
//  Parameters: Too many - read the code <g>
//
//  Return:     GCCError
//
//  History:    08-10-97    BrianTa     Created
//
//*************************************************************

GCCError
APIENTRY
GCCRegisterNodeControllerApplication(
            GCCCallBack             control_sap_callback,
            void FAR *              user_defined,
            GCCVersion              gcc_version_requested,
            unsigned short  FAR *   initialization_flags,
            unsigned long   FAR *   application_id,
            unsigned short  FAR *   capabilities_mask,
            GCCVersion      FAR *   gcc_high_version,
            GCCVersion      FAR *   gcc_version)
{
    MCSError    mcsError;
    GCCError    gccError;

    TRACE((DEBUG_GCC_DBFLOW,
            "GCC: GCCRegisterNodeControllerApplication entry\n"));

    if (!gccIsInitialized(&gccError))
    {
        if (gcc_version_requested.major_version == GCC_MAJOR_VERSION &&
            gcc_version_requested.minor_version == GCC_MINOR_VERSION)
        {
            TS_ASSERT(application_id);

            gcc_version->major_version = GCC_MAJOR_VERSION;
            gcc_version->minor_version = GCC_MINOR_VERSION;

            gcc_high_version->major_version = GCC_MAJOR_VERSION;
            gcc_high_version->minor_version = GCC_MINOR_VERSION;

            gccSetCallback(control_sap_callback);

            TRACE((DEBUG_GCC_DBDEBUG,
                    "GCC: Calling MCSInitialize - callback 0x%x\n",
                    mcsCallback));

            mcsError = MCSInitialize(mcsCallback);

            gccDumpMCSErrorDetails(mcsError,
                    "MCSInitialize");

            gccError = gccMapMcsError(mcsError);

            if (gccError == GCC_NO_ERROR)
                gccInitialized(TRUE);

            *application_id = (g_fInitialized ? 1 : 0);
        }
        else
        {
            TRACE((DEBUG_GCC_DBERROR,
                    "GCC: Invalid GCC version requested\n"));

            gccError = GCC_INVALID_PARAMETER;
        }
    }

    TRACE((DEBUG_GCC_DBFLOW,
            "GCC: GCCRegisterNodeControllerApplication exit - 0x%x\n",
            gccError));

    return (gccError);
}


//*************************************************************
//
//  GCCCleanup()
//
//  Purpose:    Performs GCC cleanup processing
//
//  Parameters: application_id
//
//  Return:     GCCError
//
//  History:    08-10-97    BrianTa     Created
//
//*************************************************************

GCCError
APIENTRY
GCCCleanup(ULONG application_id)
{
    MCSError    mcsError;
    GCCError    gccError;

    TRACE((DEBUG_GCC_DBFLOW,
            "GCC: GCCCleanup entry\n"));

    if (gccIsInitialized(&gccError))
    {
        TS_ASSERT(application_id > 0);

        TRACE((DEBUG_GCC_DBDEBUG,
                "GCC: Calling MCSCleanup - no args\n"));

        mcsError = MCSCleanup();

        gccDumpMCSErrorDetails(mcsError,
                "MCSCleanup");

        gccError = gccMapMcsError(mcsError);
    }

    TRACE((DEBUG_GCC_DBFLOW,
            "GCC: GCCCleanup exit - 0x%x\n",
            gccError));

    return (gccError);
}


//*************************************************************
//
//  GCCConferenceInit()
//
//  Purpose:    Initializes the conference
//
//  Parameters: application_id
//
//  Return:     GCCError
//
//  History:    08-10-97    BrianTa     Created
//
//*************************************************************

GCCError
APIENTRY
GCCConferenceInit(HANDLE        hIca,
                  HANDLE        hStack,
                  PVOID         pvContext,
                  DomainHandle  *phDomain)
{
    MCSError    mcsError;
    GCCError    gccError;

    TRACE((DEBUG_GCC_DBFLOW,
            "GCC: GCCConferenceInit entry\n"));

    if (gccIsInitialized(&gccError))
    {
        TS_ASSERT(hIca);
        TS_ASSERT(hStack);
        TS_ASSERT(pvContext);
        TS_ASSERT(phDomain);

        TRACE((DEBUG_GCC_DBDEBUG,
                "GCC: Calling MCSCreateDomain - hIca 0x%x, hStack 0x%x, "
                "pvContext 0x%x, phDomain 0x%x\n",
                hIca, hStack, pvContext, phDomain));

        mcsError = MCSCreateDomain(hIca, hStack, pvContext, phDomain);

        gccDumpMCSErrorDetails(mcsError,
                "MCSCreateDomain");

        TRACE((DEBUG_GCC_DBDEBUG, 
                "GCC: MCSCreateDomain: domain 0x%x\n", 
                *phDomain));

        gccError = gccMapMcsError(mcsError);
    }

    TRACE((DEBUG_GCC_DBFLOW,
            "GCC: GCCConferenceInit exit - 0x%x\n",
            gccError));

    return (gccError);
}


//*************************************************************
//
//  GCCConferenceCreateResponse()
//
//  Purpose:    Performs conference creation
//
//  Parameters: application_id
//
//  Return:     GCCError
//
//  History:    08-10-97    BrianTa     Created
//
//*************************************************************

GCCError
APIENTRY
GCCConferenceCreateResponse(GCCNumericString    conference_modifier,
                            DomainHandle        hDomain,
                            T120Boolean         use_password_in_the_clear,
                            DomainParameters    *domain_parameters,
                            USHORT              number_of_network_addresses,
                            GCCNetworkAddress   **local_network_address_list,
                            USHORT              number_of_user_data_members,
                            GCCUserData         **user_data_list,
                            GCCResult           result)
{
    MCSError    mcsError;
    GCCError    gccError;
    PBYTE       pUserData;
    UINT        UserDataLength;

    TRACE((DEBUG_GCC_DBFLOW,
            "GCC: GCCConferenceCreateResponse entry\n"));

    if (gccIsInitialized(&gccError))
    {
        mcsError = gccEncodeUserData(number_of_user_data_members,
                                     user_data_list,
                                     &pUserData,
                                     &UserDataLength);

        if (mcsError == MCS_NO_ERROR)
        {
            TRACE((DEBUG_GCC_DBDEBUG,
                "GCC: Calling MCSConnectProviderResponse - hDomain 0x%x, result 0x%x, "
                "pUserData 0x%x, UserDataLength 0x%x\n",
                hDomain, result, pUserData, UserDataLength));

            TS_ASSERT(hDomain);

            mcsError = MCSConnectProviderResponse(hDomain, result, pUserData, UserDataLength);

            gccDumpMCSErrorDetails(mcsError,
                    "MCSConnectProviderResponse");

            if (pUserData)
                TShareFree(pUserData);
        }

        gccError = gccMapMcsError(mcsError);
    }

    TRACE((DEBUG_GCC_DBFLOW,
            "GCC: GCCConferenceCreateResponse exit - 0x%x\n",
            gccError));

    return (gccError);
}


//*************************************************************
//
//  GCCConferenceTerminateRequest()
//
//  Purpose:    Performs conference termination
//
//  Parameters: application_id
//
//  Return:     GCCError
//
//  History:    08-10-97    BrianTa     Created
//
//*************************************************************

GCCError
APIENTRY
GCCConferenceTerminateRequest(HANDLE            hIca,
                              DomainHandle      hDomain,
                              ConnectionHandle  hConnection,
                              GCCReason         reason)
{
    MCSError    mcsError;
    GCCError    gccError;
    MCSReason   mcsReason;

    TRACE((DEBUG_GCC_DBFLOW,
            "GCC: GCCConferenceTerminateRequest entry\n"));

    if (gccIsInitialized(&gccError))
    {
        switch (reason)
        {
            case GCC_REASON_SERVER_INITIATED:
                mcsReason = REASON_PROVIDER_INITIATED;
                break;

            case GCC_REASON_USER_INITIATED:
                mcsReason = REASON_USER_REQUESTED;
                break;

            case GCC_REASON_UNKNOWN:
                mcsReason = REASON_PROVIDER_INITIATED;
                break;

            case GCC_REASON_ERROR_TERMINATION:
                mcsReason = REASON_PROVIDER_INITIATED;
                break;

            default:
                ASSERT(0);
                mcsReason = REASON_PROVIDER_INITIATED;
                break;
        }
            
        mcsError = MCS_NO_ERROR;

        if (hConnection)
        {
            TRACE((DEBUG_GCC_DBDEBUG,
                    "GCC: Calling MCSDisconnectProviderRequest - "
                    "hConnection 0x%x, mcsReason 0x%x\n",
                    hConnection, mcsReason));

            mcsError = MCSDisconnectProviderRequest(hIca, hConnection, mcsReason);

            gccDumpMCSErrorDetails(mcsError,
                    "GCCConferenceTerminateRequest");
        }

        if (hDomain)
        {
            mcsError = MCSDeleteDomain(hIca, hDomain, reason);

            gccDumpMCSErrorDetails(mcsError,
                    "MCSDeleteDomain");
        }

        gccError = gccMapMcsError(mcsError);
    }

    TRACE((DEBUG_GCC_DBFLOW,
            "GCC: GCCConferenceTerminateRequest exit - 0x%x\n",
            gccError));

    return (gccError);
}


#if DBG

//*************************************************************
//
//  gccDumpMCSErrorDetails()
//
//  Purpose:    Dumps out MCSError details
//
//  Parameters: IN [mcsError]           - MCS return code
//              IN [PrintLevel]         - Print level
//              IN [pszText]            - var text
//
//  Return:     void
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

void
gccDumpMCSErrorDetails(IN MCSError        mcsError,
                       IN PCHAR           pszText)
{
    int         i;
    PCHAR       pszMessageText;

    pszMessageText = "UNKNOWN_MCS_ERROR";

    for (i=0; i<sizeof(GccMcsErrorTBL) / sizeof(GccMcsErrorTBL[0]); i++)
    {
        if (GccMcsErrorTBL[i].mcsError == mcsError)
        {
            pszMessageText = GccMcsErrorTBL[i].pszMcsMessageText;
            break;
        }
    }

    TRACE((DEBUG_GCC_DBDEBUG,
            "GCC: %s - MCSError 0x%x (%s)\n",
             pszText, mcsError, pszMessageText));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\gcc\_tgcc.h ===
//---------------------------------------------------------------------------
//
//  File:       _Gcc.h
//
//  Contents:   Gcc private include file
//
//  Copyright:  (c) 1992 - 1997, Microsoft Corporation.
//              All Rights Reserved.
//              Information Contained Herein is Proprietary
//              and Confidential.
//
//  History:    17-JUL-97   BrianTa         Created.
//
//---------------------------------------------------------------------------

#ifndef __GCC_H_
#define __GCC_H_

#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <t120.h>
#include <tshrutil.h>

//---------------------------------------------------------------------------
// Defines
//---------------------------------------------------------------------------

#define GCC_MAJOR_VERSION   1
#define GCC_MINOR_VERSION   0


#if DBG
#define GCCMCS_TBL_ITEM(_x_, _y_) {_x_, _y_, #_x_, #_y_}

#else
#define GCCMCS_TBL_ITEM(_x_, _y_) {_x_, _y_}

#endif // DBG defines


//---------------------------------------------------------------------------
// Typedefs
//---------------------------------------------------------------------------

// MCS/GCC return code table

typedef struct _GCCMCS_ERROR_ENTRY
{
    MCSError    mcsError;               // MCSError
    GCCError    gccError;               // GCCError

#if DBG
    PCHAR       pszMcsMessageText;      // MCSError text
    PCHAR       pszGccMessageText;      // GCCError text
#endif

} GCCMCS_ERROR_ENTRY, *PGCCMCS_ERROR_ENTRY;


//---------------------------------------------------------------------------
// Data declarations
//---------------------------------------------------------------------------

#ifdef _TGCC_ALLOC_DATA_

BOOL            g_fInitialized = FALSE;


GCCMCS_ERROR_ENTRY GccMcsErrorTBL[] = {
    GCCMCS_TBL_ITEM(MCS_NO_ERROR,              GCC_NO_ERROR),
    GCCMCS_TBL_ITEM(MCS_ALLOCATION_FAILURE,    GCC_ALLOCATION_FAILURE),
    GCCMCS_TBL_ITEM(MCS_ALREADY_INITIALIZED,   GCC_ALREADY_INITIALIZED),
    GCCMCS_TBL_ITEM(MCS_NOT_INITIALIZED,       GCC_NOT_INITIALIZED),
    GCCMCS_TBL_ITEM(MCS_INVALID_PARAMETER,     GCC_INVALID_PARAMETER),
    GCCMCS_TBL_ITEM(MCS_DOMAIN_ALREADY_EXISTS, GCC_FAILURE_CREATING_DOMAIN),
    GCCMCS_TBL_ITEM(MCS_NO_SUCH_CONNECTION,    GCC_BAD_CONNECTION_HANDLE_POINTER),
    GCCMCS_TBL_ITEM(MCS_NO_SUCH_DOMAIN,        GCC_DOMAIN_PARAMETERS_UNACCEPTABLE)};

#else

extern  BOOL                g_fInitialized;

extern  GCCMCS_ERROR_ENTRY  GccMcsErrorTBL[];

#endif


//---------------------------------------------------------------------------
// Prototypes
//---------------------------------------------------------------------------

GCCError    gccMapMcsError(IN MCSError mcsError);
void        gccInitialized(IN BOOL fInitialized);
BOOL        gccIsInitialized(OUT GCCError *pgccError);

MCSError    gccEncodeUserData(IN  USHORT        usMembers,
                              IN  GCCUserData **ppDataList,
                              OUT PBYTE        *pUserData,
                              OUT UINT         *pUserDataLength);

MCSError    gccDecodeUserData(IN  PBYTE         pData,
                              IN  UINT          DataLength,
                              OUT GCCUserData   *pGccUserData);

void        gccSetCallback(OUT GCCCallBack control_sap_callback);

MCSError    gccConnectProviderIndication(IN PConnectProviderIndication pcpi,
                                         IN PVOID                      pvContext);

MCSError    gccDisconnectProviderIndication(IN PDisconnectProviderIndication pdpi,
                                            IN PVOID                         pvContext);

MCSError    mcsCallback(IN DomainHandle hDomain,
                        IN UINT         Message,
                        IN PVOID pvParam,
                        IN PVOID pvContext);


VOID        gccFreeUserData(IN GCCUserData  *pUserData);


#if DBG

void    gccDumpMCSErrorDetails(IN MCSError        mcsError,
                               IN PCHAR           pszText);

#else

#define gccDumpMCSErrorDetails(_x_, _y_);

#endif


#endif // __GCC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\inc\mcslib.h ===
/*++

Copyright (c) 1995-1997 Microsoft Corporation

Module Name:

    mcslib.h

Abstract:

    This file contains the misc library functions that are defined in
    mcsmux.

Author:

    Madan Appiah (madana)   25-Aug-1997

Revision History:

--*/

BOOL
MCSDLLInit(
    VOID
    );

VOID
MCSDllCleanup(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\inc\tshrutil.h ===
/*++

Copyright (c) 1994-1997  Microsoft Corporation

Module Name:

    tshrutil.h

Abstract:

    Contains proto type and constant definitions for tshare utility
    functions.

Author:

    Madan Appiah (madana)  25-Aug-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _TSHRUTIL_H_
#define _TSHRUTIL_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <winsta.h>

#ifndef CHANNEL_FIRST
#include <icadd.h>
#endif

#include <icaapi.h>


//---------------------------------------------------------------------------------
// Defines
//---------------------------------------------------------------------------------

#if DBG

extern  HANDLE  g_hIcaTrace;

extern  HANDLE  g_hTShareHeap;

// Trace

#undef  TRACE
#define TRACE(_arg)     { if (g_hIcaTrace) IcaSystemTrace _arg; }

#define TS_ASSERT(Predicate)  ASSERT(Predicate)

#ifndef TC_WX
#define TC_WX           0x40000000          // winstation extension
#endif


#define DEBUG_GCC_DBERROR   g_hIcaTrace, TC_WX, TT_ERROR
#define DEBUG_GCC_DBWARN    g_hIcaTrace, TC_WX, TT_API1
#define DEBUG_GCC_DBNORMAL  g_hIcaTrace, TC_WX, TT_API1
#define DEBUG_GCC_DBDEBUG   g_hIcaTrace, TC_WX, TT_API2
#define DEBUG_GCC_DbDETAIL  g_hIcaTrace, TC_WX, TT_API3
#define DEBUG_GCC_DBFLOW    g_hIcaTrace, TC_WX, TT_API4
#define DEBUG_GCC_DBALL     g_hIcaTrace, TC_WX, TT_API5


#define DEBUG_TSHRSRV_ERROR    g_hIcaTrace, TC_WX, TT_ERROR
#define DEBUG_TSHRSRV_WARN     g_hIcaTrace, TC_WX, TT_API1
#define DEBUG_TSHRSRV_NORMAL   g_hIcaTrace, TC_WX, TT_API1
#define DEBUG_TSHRSRV_DEBUG    g_hIcaTrace, TC_WX, TT_API2
#define DEBUG_TSHRSRV_DETAIL   g_hIcaTrace, TC_WX, TT_API3
#define DEBUG_TSHRSRV_FLOW     g_hIcaTrace, TC_WX, TT_API4

// util flags.

#define DEBUG_ERROR         g_hIcaTrace, TC_WX, TT_ERROR
#define DEBUG_MISC          g_hIcaTrace, TC_WX, TT_API2
#define DEBUG_REGISTRY      g_hIcaTrace, TC_WX,TT_API2
#define DEBUG_MEM_ALLOC     g_hIcaTrace, TC_WX,TT_API4
           
// Heap defines

#define TSHeapAlloc(dwFlags, dwSize, nTag) \
            HeapAlloc(g_hTShareHeap, dwFlags, dwSize)

#define TSHeapReAlloc(dwFlags, lpOldMemory, dwNewSize) \
            HeapReAlloc(g_hTShareHeap, dwFlags, lpOldMemory, dwNewSize)

#define TSHeapFree(lpMemoryPtr) \
            HeapFree(g_hTShareHeap, 0, lpMemoryPtr)

#define TSHeapValidate(dwFlags, lpMemoryPtr, nTag)
#define TSHeapWalk(dwFlags, nTag, dwSize)
#define TSHeapDump(dwFlags, lpMemoryPtr, dwSize)
#define TSMemoryDump(lpMemoryPtr, dwSize)


#else   // DBG

extern  HANDLE  g_hTShareHeap;

// Trace

#define TRACE(_arg)
#define TS_ASSERT(Predicate)

// Heap defines

#define TSHeapAlloc(dwFlags, dwSize, nTag) \
            HeapAlloc(g_hTShareHeap, dwFlags, dwSize)

#define TSHeapReAlloc(dwFlags, lpOldMemory, dwNewSize) \
            HeapReAlloc(g_hTShareHeap, dwFlags, lpOldMemory, dwNewSize)

#define TSHeapFree(lpMemoryPtr) \
            HeapFree(g_hTShareHeap, 0, lpMemoryPtr)

#define TSHeapValidate(dwFlags, lpMemoryPtr, nTag)
#define TSHeapWalk(dwFlags, nTag, dwSize)
#define TSHeapDump(dwFlags, lpMemoryPtr, dwSize)
#define TSMemoryDump(lpMemoryPtr, dwSize)

#endif  // DBG


#define TShareAlloc(dwSize) \
            TSHeapAlloc(0, dwSize, TS_HTAG_0)

#define TShareAllocAndZero(dwSize) \
            TSHeapAlloc(HEAP_ZERO_MEMORY, dwSize, 0)

#define TShareRealloc(lpOldMemory, dwNewSize) \
            TSHeapReAlloc(0, lpOldMemory, dwNewSize)
            
#define TShareReallocAndZero(lpOldMemory, dwNewSize) \
            TSHeapReAlloc(HEAP_ZERO_MEMORY, lpOldMemory, dwNewSize)
            
#define TShareFree(lpMemoryPtr) \
            TSHeapFree(lpMemoryPtr)


DWORD   TSUtilInit(VOID);
VOID    TSUtilCleanup(VOID);


#ifdef __cplusplus
} // extern "C"
#endif

#endif // _TSHRUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\inc\tshrtag.h ===
//*************************************************************
//
//  File name:      tshrtag.h
//
//  Description:    Contains TShare heap tag definitions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1991-1997
//  All rights reserved
//
//*************************************************************


// The following are all the defined TShare heap ID tags know to the
// system.  To add a new tag, it must be placed here (and only here).
// The value of each tag is generated sequentially.
//
// Note that each entry has a comment at the end of the definition
// denoting its deterministic value - this is provided only as a
// convenience to the reader.
//
// To add a new tag, just add (at the end preferably) the following:
//
//  TS_HTAG_ITEM(x)     // n
//
//  where   'x' is the new tag define, and
//          'n' is it's deterministic value


// TShrSRV

TS_HTAG_ITEM(TS_HTAG_TSS_FONTTABLE)         // 1
TS_HTAG_ITEM(TS_HTAG_TSS_FONTENUMDATA)      // 2
TS_HTAG_ITEM(TS_HTAG_TSS_WSXCONTEXT)        // 3
TS_HTAG_ITEM(TS_HTAG_TSS_TSRVINFO)          // 4
TS_HTAG_ITEM(TS_HTAG_TSS_USERDATA_IN)       // 5
TS_HTAG_ITEM(TS_HTAG_TSS_USERDATA_OUT)      // 6
TS_HTAG_ITEM(TS_HTAG_TSS_USERDATA_LIST)     // 7
TS_HTAG_ITEM(TS_HTAG_TSS_WORKITEM)          // 8

// GCC

TS_HTAG_ITEM(TS_HTAG_GCC_USERDATA_IN)       // 9
TS_HTAG_ITEM(TS_HTAG_GCC_USERDATA_OUT)      // 10

// MCSMUX

TS_HTAG_ITEM(TS_HTAG_MCSMUX_ALL)            // 11

// VC

TS_HTAG_ITEM(TS_HTAG_VC_ADDINS)             // 12

// Add others here...
TS_HTAG_ITEM(TS_HTAG_TSS_PRINTERINFO2)      // 13
TS_HTAG_ITEM(TS_HTAG_TSS_SPOOLERINFO)       // 14
TS_HTAG_ITEM(TS_HTAG_TSS_PUBKEY)            // 15
TS_HTAG_ITEM(TS_HTAG_TSS_CERTIFICATE)       // 16
TS_HTAG_ITEM(TS_HTAG_TSS_WINSTATION_CLIENT) // 17
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\inc\tsreg.h ===
/*++

Copyright (c) 1994-1997  Microsoft Corporation

Module Name:

    tsreg.h

Abstract:

    This file contains registry key and value names used by tshare component.

Author:

    Madan Appiah (madana)  26-Aug-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _TSREG_H_
#define _TSREG_H_

#define TSHARE_REG_KEY   \
    L"System\\CurrentControlSet\\Services\\IcaSrv\TShare"

#endif // _TSREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\mcsmux\precomp.h ===
/****************************************************************************/
// precomp.h
//
// Precompiled header for RDPWSX mcsmux.
//
// Copyriht (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>

#ifndef _HYDRA_
#include <cxstatus.h>
#endif

#include <winsta.h>
#include <hydrix.h>

#ifndef CHANNEL_FIRST
#include <icadd.h>
#endif

#include <icaapi.h>

struct _OUTBUF;
typedef struct _OUTBUF *POUTBUF;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\mcsmux\convnchn.c ===
/* (C) 1997 Microsoft Corp.
 *
 * file   : ConvnChn.c
 * author : Erik Mavrinac
 *
 * description: MCSMUX API entry points for MCS T.122 API convened-channel
 *   functions.
 */

#include "precomp.h"
#pragma hdrstop

#include "mcsmux.h"


/*
 * Allows a user attachment to convene a private channel. The attachment
 * becomes the channel convenor and invites/allows others to join.
 */

MCSError APIENTRY MCSChannelConveneRequest(UserHandle hUser)
{
    CheckInitialized("ChannelConveneReq()");

    ErrOut("ChannelConveneReq(): Not implemented");
    return MCS_COMMAND_NOT_SUPPORTED;

/* Implementation notes:
1. Verify hUser.
2. Create new dynamic channel, place this hUser as the convenor and in
   user attachment list.
3. Add channel to channel list.
*/
}



/*
 * Allows a user attachment to disband a private channel it has convened.
 */
MCSError APIENTRY MCSChannelDisbandRequest(
    UserHandle hUser,
    ChannelID  ChannelID)
{
    CheckInitialized("ChannelDisbandReq()");

    ErrOut("ChannelDisbandReq(): Not implemented");
    return MCS_COMMAND_NOT_SUPPORTED;

/* Implementation notes:
1. Verify hUser.
2. Verify ChannelID is in channel list and hUser is the convenor.
3. Remove channel from channel list.
4. Inform all subordinate nodes of their expulsion from the channel with
   Channel-Expel-Indication PDUs sent to all subnodes.
*/
}



/*
 * Allows a channel convenor/manager to admit other users to that channel.
 */
MCSError APIENTRY MCSChannelAdmitRequest(
        UserHandle hUser,
        ChannelID  ChannelID,
        PUserID    UserIDList,
        unsigned   NUserIDs)
{
    CheckInitialized("ChannelAdmitReq()");

    ErrOut("ChannelAdmitReq(): Not implemented");
    return MCS_COMMAND_NOT_SUPPORTED;

/* Implementation notes:
1. Verify hUser.
2. Verify ChannelID is in channel list and hUser is the convenor.
3. ...
*/
}



/*
 * Allows a channel convenor/manager to expel users from a private channel.
 */
MCSError APIENTRY MCSChannelExpelRequest(
        UserHandle hUser,
        ChannelID  ChannelID,
        UserID     UserIDList[],
        unsigned   NUserIDs)
{
    CheckInitialized("ChannelExpelReq()");

    ErrOut("ChannelExpelReq(): Not implemented");
    return MCS_COMMAND_NOT_SUPPORTED;

/* Implementation notes:
1. Verify hUser.
2. Verify ChannelID is in channel list and hUser is the convenor.
3. ...
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\mcsmux\slist.h ===
/* (C) 1997 Microsoft Corp.
 *
 * file    : SList.h
 * authors : Christos Tsollis, Erik Mavrinac
 *
 * description: Interface definition to a dynamically-resizing list/queue
 *   data type. The "key" values in the list are unsigned ints of whatever the
 *   default word size is, so the elements of the array will be word-aligned.
 *   These elements can be cast into whatever form is needed. Associated is
 *   a void * for data asssociated with the "key".
 */

#ifndef __SLIST_H
#define __SLIST_H


/*
 * Types
 */

typedef struct
{
    unsigned Key;
    void     *Value;
} _SListNode;

typedef struct {
    unsigned NEntries;    // current # of entries in the list
    unsigned MaxEntries;  // max # of entries that the array can hold
    unsigned HeadOffset;  // Offset of the 1st entry in the circular array
    unsigned CurrOffset;  // Iterator value
    _SListNode *Entries;    // Circular array of entries
} SList, *PSList;



/*
 * API prototypes.
 */

BOOLEAN SListAppend(PSList, unsigned, void *);
void SListDestroy(PSList);
BOOLEAN SListGetByKey(PSList, unsigned, void **);
void SListInit(PSList, unsigned);
BOOLEAN SListIterate(PSList, unsigned *, void **);
BOOLEAN SListPrepend(PSList, unsigned, void *);
void SListRemove(PSList, unsigned, void **);
void SListRemoveFirst(PSList, unsigned *, void **);
void SListRemoveLast(PSList, unsigned *, void **);



/*
 * API functions implemented as macros.
 */

// void SListResetIteration(PSList);  // Resets iteration counter.
#define SListResetIteration(pSL) (pSL)->CurrOffset = 0xFFFFFFFF

// unsigned SListGetEntries(PSList);  // Ret. # entries in list.
#define SListGetEntries(pSL) ((pSL)->NEntries)

// void SListClear(PSList);
#define SListClear(pSL) {  \
    (pSL)->NEntries = (pSL)->HeadOffset = 0;  \
    (pSL)->CurrOffset = 0xFFFFFFFF;  \
}

// BOOLEAN SListIsEmpty(PSList);
#define SListIsEmpty(pSL) ((pSL)->NEntries == 0)



#endif  // !defined(__SLIST_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\mcsmux\mcsmux.h ===
/* (C) 1997 Microsoft Corp.
 *
 * file   : MCSMUX.h
 * author : Erik Mavrinac
 *
 * description: MCSMUX API types and definitions.
 */

#include "MCS.h"
#include "MCSIoctl.h"
#include "Trace.h"
#include "slist.h"
#include "tshrutil.h"

/*
 * Defines
 */

// Memory alloc and copy functions.
#define Malloc(size) TSHeapAlloc(HEAP_ZERO_MEMORY, size, TS_HTAG_MCSMUX_ALL)
#define Free(ptr)    TSHeapFree(ptr)
#define MemCpy(dest, src, len) memcpy((dest), (src), (len))


// Code common to all entry points except MCSInitialized(), we don't want it
//   around in retail builds.
#if DBG
#define CheckInitialized(funcname) \
        if (!g_bInitialized) { \
            ErrOut(funcname " called when MCS not initialized"); \
            return MCS_NOT_INITIALIZED; \
        }
#else
#define CheckInitialized(funcname) 
#endif


// Must be as large as the largest MCS node controller indication/confirm
//   size sent up from PDMCS.
//TODO FUTURE: Will need to change if we support SendData indications to user
//  mode.
#define DefaultInputBufSize sizeof(ConnectProviderIndicationIoctl)



/*
 * Types
 */

// Forward reference.
typedef struct _Domain Domain;

typedef struct {
    Domain *pDomain;
    ConnectionHandle hConnKernel;
} Connection;


typedef enum
{
    Dom_Unconnected,  // Initial state.
    Dom_Connected,    // Up-and-running state.
    Dom_PendingCPResponse,  // Waiting for ConnectProvResponse.
    Dom_Rejected,     // Rejected during ConnectProvInd.
} DomainState;

typedef struct _Domain
{
    LONG RefCount;
        
    // Locks access to this struct.
    CRITICAL_SECTION csLock;
    
#if MCS_Future
    // Selector. This is determined by MCSMUX to be unique across the system.
    // Not currently exported to node controller, may be in the future.
    unsigned SelLen;
    unsigned char Sel[MaxDomainSelectorLength];
#endif

    // ICA-related bindings.
    HANDLE hIca;
    HANDLE hIcaStack;
    HANDLE hIcaT120Channel;
    
    void *NCUserDefined;

    // Domain-specific information.
    unsigned bDeleteDomainCalled    :1;
    unsigned bPortDisconnected      :1;
    
    DomainState State;
    DomainParameters DomParams;

    // IoPort required member.
    OVERLAPPED Overlapped;

    // TODO FUTURE: This is for a hack for single-connection system,
    //   get rid of it by implementing Connection objects.
    HANDLE hConn;
    
    //TODO FUTURE: Connection objects will need to be separate allocations
    //   for future systems with more than one connection.
    Connection MainConn;

    // Domain IOPort receive buffer.
    BYTE InputBuf[DefaultInputBufSize];
} Domain;

typedef enum {
    User_Attached,
    User_AttachConfirmPending,
} UserState;

typedef struct {
    MCSUserCallback     Callback;
    MCSSendDataCallback SDCallback;
    void                *UserDefined;
    UserState           State;
    UserHandle          hUserKernel;  // Returned from kernel mode.
    UserID              UserID;  // Returned from kernel mode.
    Domain              *pDomain;
    SList               JoinedChannelList;
    unsigned            MaxSendSize;
} UserInformation;

// Contains little info, this is used as a guard against bluescreens --
//   if bad hChannel is presented a user-mode fault will occur.
typedef struct
{
    ChannelHandle hChannelKernel;
    ChannelID     ChannelID;
} MCSChannel;


/*
 * Globals
 */

extern BOOL  g_bInitialized;  // Overall DLL initialization status.
extern CRITICAL_SECTION g_csGlobalListLock;
extern SList g_DomainList;    // List of active domains.
extern SList g_hUserList;     // Maps hUsers to domains.
extern SList g_hConnList;     // Maps hConnections to domains.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\mcsmux\mcsapi.c ===
/****************************************************************************/
// mcsapi.c
//
// TS RDPWSX MCS user-mode multiplexing layer code.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "mcsmux.h"


/*
 * Defines
 */
#define DefaultNumDomains  10
#define DefaultNumChannels 3

#define MinDomainControlMarker    0xFFFFFFF0
#define ReadChannelRequestMarker  0xFFFFFFFD
#define CloseChannelRequestMarker 0xFFFFFFFE
#define ExitIoThreadMarker        0xFFFFFFFF

// Defines the maximum number of threads that can be waiting on the global
// I/O completion port. 0 means the same as the number of processors in
// the system.
#define MaxIoPortThreads 0


/*
 * DLL globals
 */
static PVOID      g_NCUserDefined = NULL;
static DWORD      g_IoThreadID = 0;
static HANDLE     g_hIoPort = NULL,
                  g_hIoThread = NULL,
                  g_hIoThreadEndEvent = NULL;
static OVERLAPPED g_NCOverlapped;
static MCSNodeControllerCallback g_NCCallback = NULL;

// Externs global to all sources.
BOOL  g_bInitialized = FALSE;

#ifdef MCS_FUTURE
CRITICAL_SECTION g_csGlobalListLock;
SList g_UserList;
SList g_ConnList;
#endif


/*
 * Local function prototypes.
 */
MCSError SendConnectProviderResponse(Domain *, ConnectionHandle, MCSResult,
        BYTE *, unsigned);


/*
 * Initialization done at RDPWSX.dll load.
 */
BOOL MCSDLLInit(void)
{
    return TRUE;
}


/*
 * Cleanup done at RDPWSX.dll unload.
 */
void MCSDllCleanup(void)
{
    // Cleanup all resources. MCSCleanup() must handle abnormal
    //   terminations where MCSCleanup() was not properly called
    //   by the node controller.
    MCSCleanup();
}


/*
 * Utility functions.
 */
void DestroyUserInfo(UserInformation *pUserInfo)
{
    MCSChannel *pMCSChannel;
    
    SListResetIteration(&pUserInfo->JoinedChannelList);
    while (SListIterate(&pUserInfo->JoinedChannelList,
            (unsigned *)&pMCSChannel, &pMCSChannel))
        Free(pMCSChannel);
    SListDestroy(&pUserInfo->JoinedChannelList);
}


// Perform common domain destruction. Used in multiple places in code.
void DestroyDomain(Domain *pDomain)
{
    // Fill the to-be-freed Domain with recognizable trash
    // and then release it back to the heap
    DeleteCriticalSection(&pDomain->csLock);
    Free(pDomain);

}


/*
 * Handles a connect-provider indication ChanelInput coming from kernel mode.
 */
void HandleConnectProviderIndication(
        Domain                         *pDomain,
        unsigned                       BytesTransferred,
        ConnectProviderIndicationIoctl *pCPin)
{
    MCSError MCSErr;
    Connection *pConn;
    ConnectProviderIndication CP;

    if (BytesTransferred != sizeof(ConnectProviderIndicationIoctl)) {
        ErrOutIca1(pDomain->hIca, "HandleConnectProvInd(): Wrong size data "
                "received (%d), ignoring", BytesTransferred);
        return;
    }

    ASSERT(pCPin->UserDataLength <= MaxGCCConnectDataLength);

    if (pDomain->State != Dom_Unconnected) {
        ErrOutIca(pDomain->hIca, "HandleConnectProvInd(): Connect received "
                "unexpectedly, ignoring");
        return;
    }

    // Generate a new Connection for user mode. Associate it with the domain.
    // This allows the ConnectProviderResponse() to find the domain again.
    // TODO FUTURE: We use a static Connection embedded in the Domain since
    //   we are currently a single-connection system. Change this in the
    //   future for multiple-connection system.
    pConn = &pDomain->MainConn;
    pConn->pDomain = pDomain;
    pConn->hConnKernel = pCPin->hConn;

#ifdef MCS_Future
    pConn = Malloc(sizeof(Connection));
    if (pConn == NULL) {
        ErrOutIca(pDomain->hIca, "HandleConnectProvInd(): Could not "
                "create Connection");

        // Send error PDU back.
        MCSErr = SendConnectProviderResponse(pDomain, pCPin->hConn,
                RESULT_UNSPECIFIED_FAILURE, NULL, 0);

        // We cannot do much more error handling if this does not work.
        ASSERT(MCSErr == MCS_NO_ERROR);
        return;
    }

    EnterCriticalSection(&g_csGlobalListLock);
    if (!SListAppend(&g_ConnList, (unsigned)pConn, pDomain)) {
        LeaveCriticalSection(&g_csGlobalListLock);

        ErrOutIca(pDomain->hIca, "ConnectProvInd: Could not "
                "add hConn to global list");

        // Send error PDU back.
        MCSErr = SendConnectProviderResponse(pDomain, pCPin->hConn,
                RESULT_UNSPECIFIED_FAILURE, NULL, 0);

        // We cannot do much more error handling if this does not work.
        ASSERT(MCSErr == MCS_NO_ERROR);
        return;
    }
    LeaveCriticalSection(&g_csGlobalListLock);
#endif

    // Store information away for future use.
    pDomain->DomParams = pCPin->DomainParams;

    // Prepare a ConnectProviderIndication for sending up to
    //   the node controller.
    CP.hConnection = pConn;
    CP.bUpwardConnection = pCPin->bUpwardConnection;
    CP.DomainParams = pCPin->DomainParams;

    CP.UserDataLength = pCPin->UserDataLength;
    if (CP.UserDataLength == 0)
        CP.pUserData = NULL;
    else
        CP.pUserData = pCPin->UserData;

    //TODO FUTURE: This is a hack, assumes only one connection
    //   per domain. This is used in DisconnectProviderInd
    //   to get the user mode hConn for the domain.
    pDomain->hConn = pConn;

    // Set state to pending response.
    pDomain->State = Dom_PendingCPResponse;

    // Call the node controller callback.
    TraceOutIca(pDomain->hIca, "MCS_CONNECT_PROV_IND received, calling node "
            "ctrl callback");
    ASSERT(g_NCCallback != NULL);
    g_NCCallback(pDomain, MCS_CONNECT_PROVIDER_INDICATION,
            &CP, pDomain->NCUserDefined);
}


/*
 * Handles a disconnect-provider indication ChanelInput coming from kernel
 *   mode.
 */
void HandleDisconnectProviderIndication(
        Domain                            *pDomain,
        unsigned                          BytesTransferred,
        DisconnectProviderIndicationIoctl *pDPin)
{
    Domain *pDomainConn;
    Connection *pConn;
    DisconnectProviderIndication DP;

    if (BytesTransferred != sizeof(DisconnectProviderIndicationIoctl)) {
        ErrOutIca1(pDomain->hIca, "HandleDiscProvInd(): Wrong size data "
                "received (%d), ignoring", BytesTransferred);
        return;
    }

#ifdef MCS_Future
    // Remove the connection from the connection list, destroy.
    EnterCriticalSection(&g_csGlobalListLock);
    SListResetIteration(&g_ConnList);
    while (SListIterate(&g_ConnList, (unsigned *)&pConn, &pDomainConn)) {
        if (pConn->hConnKernel == pDPin->hConn) {
            ASSERT(pDomainConn == pDomain);
            SListRemove(&g_ConnList, (unsigned)pConn, NULL);

            // TODO FUTURE: This was removed to work with the statically
            //   allocated Connection object contained in the Domain.
            //   Restore if moving to a multiple-connection system.
            Free(pConn);

            break;
        }
    }
    LeaveCriticalSection(&g_csGlobalListLock);
#endif

    // We are now no longer connected.
    pDomain->hConn = NULL;
    pDomain->State = Dom_Unconnected;

    // Prepare a DisconnectProviderIndication for sending up
    //   to node controller.
    DP.hDomain = pDomain;
    //TODO FUTURE: This hack assumes only one connection per
    //    domain.
    DP.hConnection = pDomain->hConn;
    DP.Reason = pDPin->Reason;

    // Call the node controller callback.
    TraceOutIca(pDomain->hIca, "MCS_DISCONNECT_PROV_IND received, calling "
            "node ctrl callback");
    ASSERT(g_NCCallback != NULL);
    g_NCCallback(pDomain, MCS_DISCONNECT_PROVIDER_INDICATION, &DP,
            pDomain->NCUserDefined);
}


/*
 * Takes a reference count on a domain
 */
VOID MCSReferenceDomain(Domain *pDomain)
{
    if (InterlockedIncrement(&pDomain->RefCount) <= 0)
        ASSERT(0);
}


/*
 * Releases domain resources if the reference count goes to zero
 */
VOID MCSDereferenceDomain(Domain *pDomain)
{
    ASSERT(pDomain->RefCount > 0);

    // Don't delete the domain unless everyone is done with it.  This means
    // GCC has let it go, and there are no pending I/O's for it.
    if (InterlockedDecrement(&pDomain->RefCount) == 0) {
        DestroyDomain(pDomain);
    }
}


/*
 * Closes the domain channel.  Does nothing if the channel is already closed
 */
VOID MCSChannelClose(Domain *pDomain)
{
    // Note that the channel is disconnected, and then
    // close the ica channel if it is still open

    pDomain->bPortDisconnected = TRUE;

    if (pDomain->hIcaT120Channel != NULL)
    {
        //TraceOutIca(pDomain->hIca, "MCSChannelClose(): Closing "
        //        "T120 ICA channel");
        
        CancelIo(pDomain->hIcaT120Channel);
        IcaChannelClose(pDomain->hIcaT120Channel);

        pDomain->hIcaT120Channel = NULL;
    }
}


/*
 * Initiates port disconnection
 */
NTSTATUS MCSDisconnectPort(Domain       *pDomain,
                           MCSReason    Reason)
{
    NTSTATUS                        ntStatus = STATUS_SUCCESS;
    DisconnectProviderRequestIoctl  DPrq;
    
    // Send special disconnect-provider request to kernel to trigger
    //   sending detach-user requests to local attachments with their own
    //   UserIDs, signaling that the domain is going away.

    if (!pDomain->bPortDisconnected) {
        DPrq.Header.Type = MCS_DISCONNECT_PROVIDER_REQUEST;
        DPrq.Header.hUser = NULL;           // Special meaning node controller.
        DPrq.hConn = NULL;                  // Special meaning last local connection.
        DPrq.Reason = Reason;
    
        // Call kernel mode
    
        ntStatus = IcaStackIoControl(pDomain->hIcaStack, IOCTL_T120_REQUEST, &DPrq,
                                     sizeof(DPrq), NULL, 0, NULL);
   
    }
        
    // Queue a channel close request to the IoThreadFunc() to cancel the I/O
    // since GCC is done with it.  This is necessary as the I/O must
    // be canceled from the same thread that initially issued it.
    MCSReferenceDomain(pDomain);
    PostQueuedCompletionStatus(g_hIoPort, CloseChannelRequestMarker,
            (ULONG_PTR)pDomain, NULL);

    return ntStatus;
}


/*
 * Handles port data and reissues the read
 */
VOID MCSPortData(Domain *pDomain,
                 DWORD   BytesTransferred)
{
    IoctlHeader *pHeader;
    
    EnterCriticalSection(&pDomain->csLock);
    
    // If real data has been received on the channel instead of a queued domain
    // control message, then process the data.
    if (BytesTransferred < MinDomainControlMarker) {
        
        // We only do callbacks if MCSDeleteDomain() was not called.
        if (pDomain->bDeleteDomainCalled == FALSE) {
            // Decode the ChannelInput and make the callback.
            
            pHeader = (IoctlHeader *)pDomain->InputBuf;
    
            switch (pHeader->Type)
            {
                case MCS_CONNECT_PROVIDER_INDICATION:
                    ASSERT(pHeader->hUser == NULL);
    
                    HandleConnectProviderIndication(pDomain,
                            BytesTransferred,
                            (ConnectProviderIndicationIoctl *)pHeader);
                    break;
    
                case MCS_DISCONNECT_PROVIDER_INDICATION:
                    ASSERT(pHeader->hUser == NULL);
    
                    HandleDisconnectProviderIndication(pDomain,
                            BytesTransferred,
                            (DisconnectProviderIndicationIoctl *)pHeader);
                    MCSChannelClose(pDomain);
                    break;
    
                default:
                    //TODO FUTURE: Handle other MCS indications/confirms.
                    ErrOutIca2(pDomain->hIca, "IoThreadFunc(): Unknown "
                            "node controller ioctl %d received for "
                            "domain %X", pHeader->Type, pDomain);
                    break;
            }
            
            // Set the message number to an invalid value.
            // This makes sure that any improperly-received dequeued
            //   messages that do not bring data with them will, when
            //   reusing pDomain->InputBuf, fall to the default part of
            //   the switch statement and throw an error.
    
            pHeader->Type = 0xFFFFFFFF;
        }        
    }

    // Else, a special domain control request has been queued to the I/O port
    else {
        switch (BytesTransferred) {
            case ReadChannelRequestMarker :
                break;

            case CloseChannelRequestMarker :
                MCSChannelClose(pDomain);
                break;

            default:
                ErrOutIca2(pDomain->hIca, "MCSPortData: Unknown domain control "
                           "for Domain(%lx), code(%lx)",
                           pDomain, BytesTransferred);
        }
    }

    // Issue a new read to catch the next indication/confirm.  Overlapped 
    // I/O reads will return as "unsuccessful" if there is no data already
    // waiting to be read so check for that status specifically.
    if (pDomain->hIcaT120Channel) {
        if (ReadFile(pDomain->hIcaT120Channel, pDomain->InputBuf,
                DefaultInputBufSize, NULL, &pDomain->Overlapped) ||
            (GetLastError() == ERROR_IO_PENDING))
            MCSReferenceDomain(pDomain);
        else
            {
                // Warning only. This should occur only when the ICA stack
                //   is being torn down without our direct knowledge. In that
                //   case, we simply keep running until we are torn down at the
                //   user mode level.  Take off a ref count since there is no
                //   longer a pending I/O.
                WarnOutIca2(pDomain->hIca, "IoThreadFunc(): Could not perform "
                        "ReadFile, pDomain=%X, rc=%X", pDomain, GetLastError());
            }
    }  

    // Release the lock on the domain
    LeaveCriticalSection(&pDomain->csLock);

    // drop the reference count since we just completed processing
    MCSDereferenceDomain(pDomain);
}


/*
 * Param is the handle for the I/O completion port to wait on.
 * Completion key of ExitIoThreadMarker tells the thread to exit.
 * On exit we set an event to indicate we are done. This must be done instead
 *   of relying solely on the thread's handle signaling in the case where
 *   the unload is occurring because of abnormal termination, and Cleanup()
 *   does not get called normally but instead from within DLL_PROCESS_DETACH.
 *   The call to DllEntryPoint prevents the thread handle from signaling,
 *   so we would end up in a race condition. A parallel event handle can be
 *   signaled correctly in all cases.
 */

DWORD WINAPI IoThreadFunc(void *Param)
{
    BOOL        bSuccess;
    DWORD       BytesTransferred;
    Domain      *pDomain;
    OVERLAPPED  *pOverlapped;

    ASSERT(Param != NULL);

    for (;;) 
    {
        // Wait for a port completion status
        
        pDomain = NULL;
        pOverlapped = NULL;
        bSuccess = GetQueuedCompletionStatus((HANDLE)Param, &BytesTransferred,
                (ULONG_PTR *)&pDomain, &pOverlapped, INFINITE);

        // Check for failed dequeue, at which point pDomain is not valid.
        if (!bSuccess && (pOverlapped == NULL)) {
            continue;
        }

        // If the pDomain is ExitIoThreadMarker then we are
        // shutting down and being unloaded
        if (pDomain == (Domain *)(DWORD_PTR)ExitIoThreadMarker)
            break;

        // We have successfully received a completion status.  Either it is a 
        // domain control request or user data
        if (bSuccess)
            MCSPortData(pDomain, BytesTransferred);
        
        // Else a cancel or abort I/O has occurred.  Release a ref count since
        // an I/O is no longer pending.
        else
            MCSDereferenceDomain(pDomain);
    }

    ASSERT(g_hIoThreadEndEvent);
    SetEvent(g_hIoThreadEndEvent);

    return 0;
}


/*
 * MUX-only non-MCS primitive function to allow ICA code to inject a new entry
 *   into the MUX-internal domain/stack database.
 */
MCSError APIENTRY MCSCreateDomain(
        HANDLE hIca,
        HANDLE hIcaStack,
        void *pContext,
        DomainHandle *phDomain)
{
    NTSTATUS status;
    Domain *pDomain;
    NTSTATUS Status;
    IoctlHeader StartIoctl;

    CheckInitialized("CreateDomain()");

    // Init the receiver's data to NULL to ensure a fault if they skip the
    // error code.
    *phDomain = NULL;

    pDomain = Malloc(sizeof(Domain));
    if (pDomain != NULL) {
        // Create and enter the locking critical section.
        status = RtlInitializeCriticalSection(&pDomain->csLock);
        if (status == STATUS_SUCCESS) {
            EnterCriticalSection(&pDomain->csLock);

#if MCS_Future
            pDomain->SelLen = 0;
#endif

            pDomain->hIca = hIca;
            pDomain->hIcaStack = hIcaStack;
            pDomain->NCUserDefined = pContext;
            pDomain->State = Dom_Unconnected;
            pDomain->Overlapped.hEvent = NULL;
            pDomain->Overlapped.Offset = pDomain->Overlapped.OffsetHigh = 0;
            pDomain->RefCount = 0;

            // Take a reference count for the caller of this function (GCC).
            MCSReferenceDomain(pDomain);

            // Open T.120 ICA virtual channel.
            Status = IcaChannelOpen(hIca, Channel_Virtual, Virtual_T120,
                    &pDomain->hIcaT120Channel);
            if (!NT_SUCCESS(Status)) {
                ErrOutIca(hIca, "CreateDomain: Error opening virtual channel");
                goto PostInitCS;
            }

            // Add the hIcaT120 Channel to the handles associated with the
            // main I/O completion port. We use pDomain as the completion key
            // so we can find it during callback processing.
            if (CreateIoCompletionPort(pDomain->hIcaT120Channel, g_hIoPort,
                    (ULONG_PTR)pDomain, MaxIoPortThreads) == NULL) {
                ErrOutIca(hIca, "CreateDomain(): Could not add ICA channel to "
                        "I/O completion port");
                goto PostChannel;
            }

            // Tell kernel mode to start the MCS I/O.
            StartIoctl.hUser = NULL;
            StartIoctl.Type = MCS_T120_START;
            Status = IcaStackIoControl(hIcaStack, IOCTL_T120_REQUEST,
                    &StartIoctl, sizeof(StartIoctl), NULL, 0, NULL);
            if (!NT_SUCCESS(Status)) {
                ErrOutIca(hIca, "Could not start kernel T120 I/O");
                goto PostChannel;
            }

            // Set the domain handle for use by GCC
            *phDomain = pDomain;

            // Send a message to the IoThreadFunc to initiate the read on
            // the channel. We do this so that the same thread is always
            // responsible for all I/O operations. This is important for
            // CancelIo. Take another ref count since an I/O result is
            // pending for the completion port now.
            MCSReferenceDomain(pDomain);
            PostQueuedCompletionStatus(g_hIoPort, ReadChannelRequestMarker,
                    (ULONG_PTR)pDomain, NULL);

            // Leave the Domain locking critical section.
            LeaveCriticalSection(&pDomain->csLock);
        }
        else {
            ErrOutIca(hIca, "CreateDomain: Error initialize pDomain->csLock");
            goto PostAlloc;
        }
    }
    else {
        ErrOutIca(hIca, "CreateDomain(): Error allocating a new domain");
        return MCS_ALLOCATION_FAILURE;
    }

    return MCS_NO_ERROR;


// Error handling

PostChannel:
    IcaChannelClose(pDomain->hIcaT120Channel);

PostInitCS:
    LeaveCriticalSection(&pDomain->csLock);
    DeleteCriticalSection(&pDomain->csLock);

PostAlloc:
    Free(pDomain);

    return MCS_ALLOCATION_FAILURE;
}



/*
 * Signals that an hIca is no longer valid.
 * Tears down the associated domain, including sending detach-user
 *    indications to remaining local attachments.
 */

MCSError APIENTRY MCSDeleteDomain(
        HANDLE       hIca,
        DomainHandle hDomain,
        MCSReason    Reason)
{
    Domain *pDomain, pDomainConn;
    NTSTATUS Status;
    MCSError MCSErr;
    Connection *pConn;

    pDomain = (Domain *)hDomain;

    TraceOutIca(hIca, "DeleteDomain() entry");

    // Gain access to the domain. Prevents collision with other API functions
    //   and concurrent callbacks.
    EnterCriticalSection(&pDomain->csLock);

    // This API should not be called more than once per domain.
    if (pDomain->bDeleteDomainCalled) {
        ASSERT(!pDomain->bDeleteDomainCalled);
        MCSErr = MCS_INVALID_PARAMETER;
        LeaveCriticalSection(&pDomain->csLock);
        goto PostLockDomain;
    }

#ifdef MCS_Future
    // If we are still connected find and remove remaining connections
    //   which refer to this domain.
    if (pDomain->State != Dom_Unconnected) {
        //TODO FUTURE: This assumes only one connection per domain.
        EnterCriticalSection(&g_csGlobalListLock);
        SListRemove(&g_ConnList, (unsigned)pDomain->hConn,
                (void **)&pDomainConn);
        LeaveCriticalSection(&g_csGlobalListLock);

        // TODO FUTURE: This was removed to work with the statically
        //   allocated Connection object contained in the Domain.
        //   Restore if moving to a multiple-connection system.
        if (pDomainConn != NULL)
            Free(pConn);
    }
#endif

    pDomain->hConn = NULL;
    pDomain->State = Dom_Unconnected;

    //TODO: Implement detach-user indications for local attachments.

    // Queue the "Destroy this domain!" request. This allows the domain
    // free code to be in only one place and the IoPort queue will
    // serialize this request along with closed virtual channel indications.

    pDomain->bDeleteDomainCalled = TRUE;
    MCSDisconnectPort(pDomain, Reason);

    // Drop a ref count because GCC is done with the domain.  This count was
    // originally incremented for GCC in MCSCreateDomain().
    LeaveCriticalSection(&pDomain->csLock);
    MCSDereferenceDomain(pDomain);
    MCSErr = MCS_NO_ERROR;

PostLockDomain:
    
    return MCSErr;
}



/*
 * Called by node controller to initialize DLL.
 */

MCSError APIENTRY MCSInitialize(MCSNodeControllerCallback Callback)
{
    NTSTATUS status; 

#if DBG
    if (g_bInitialized) {
        ErrOut("Initialize() called when already initialized");
        return MCS_ALREADY_INITIALIZED;
    }
#endif

    // Initialize node controller specific information.
    g_NCCallback = Callback;

#ifdef MCS_FUTURE
    // Initialize global MCS lists.
    status = RtlInitializeCriticalSection(&g_csGlobalListLock);
    if (status != STATUS_SUCCESS) {
        ErrOut("MCSInitialize: Error initialize g_csGlobalListLock");
        return MCS_ALLOCATION_FAILURE;
    }
    EnterCriticalSection(&g_csGlobalListLock);
    SListInit(&g_UserList, DefaultNumDomains);
    SListInit(&g_ConnList, DefaultNumDomains);
    LeaveCriticalSection(&g_csGlobalListLock);
#endif

    // Create I/O completion port, not associated with any requests.
    g_hIoPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0,
            MaxIoPortThreads);
    if (g_hIoPort == NULL) {
        ErrOut1("IO completion port not created (rc = %ld)", GetLastError());
        return MCS_ALLOCATION_FAILURE;
    }

    // Create I/O port listening thread, starts waiting immediately.
    g_hIoThread = CreateThread(NULL, 0, IoThreadFunc, g_hIoPort, 0,
            &g_IoThreadID);
    if (g_hIoThread == NULL) {
        ErrOut1("IO thread not created (rc = %ld)", GetLastError());
        return MCS_ALLOCATION_FAILURE;
    }

    // Increase the priority of the IoThread to increase connect performance.
    SetThreadPriority(g_hIoThread, THREAD_PRIORITY_HIGHEST);

    g_bInitialized = TRUE;

    return MCS_NO_ERROR;
}



/*
 * Called by the node controller or DllEntryPoint() to shut down the DLL.
 */

MCSError APIENTRY MCSCleanup(void)
{
    DWORD WaitResult;
    Domain *pDomain;
    Connection *pConn;
    UserInformation *pUserInfo;

    CheckInitialized("Cleanup()");

    if (!g_bInitialized)
        return MCS_NO_ERROR;
        
    // Kill I/O completion port, thread(s) waiting on it.
    g_hIoThreadEndEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    PostQueuedCompletionStatus(g_hIoPort, 0, ExitIoThreadMarker, NULL);

    WaitResult = WaitForSingleObject(g_hIoThreadEndEvent, INFINITE);

    CloseHandle(g_hIoThreadEndEvent);
    CloseHandle(g_hIoThread);
    CloseHandle(g_hIoPort);

    // Cleanup node controller-specific information.
    g_NCCallback = NULL;
    g_NCUserDefined = NULL;

    /*
     * Clean up global MCS lists.
     */

#ifdef MCS_Future
    EnterCriticalSection(&g_csGlobalListLock);

    // Kill remaining users.
    SListResetIteration(&g_UserList);
    while (SListIterate(&g_UserList, (unsigned *)&pUserInfo, NULL)) {
        DestroyUserInfo(pUserInfo);
        Free(pUserInfo);
    }
    SListDestroy(&g_UserList);

    // Kill remaining connections.
    SListResetIteration(&g_ConnList);
    // TODO FUTURE: Removed to work with statically allocated Connection
    //   contained in Domain. Restore fo multiple-connection system.
    while (SListIterate(&g_ConnList, (unsigned *)&pConn, NULL))
        Free(pConn);
    SListDestroy(&g_ConnList);

    LeaveCriticalSection(&g_csGlobalListLock);
    DeleteCriticalSection(&g_csGlobalListLock);
#endif

    g_bInitialized = FALSE;

    return MCS_NO_ERROR;
}


/*
 * Response function for an MCS_CONNECT_PROVIDER_INDICATION callback. Result
 *   values are as defined by T.125.
 */

MCSError APIENTRY MCSConnectProviderResponse(
        DomainHandle hDomain,
        MCSResult    Result,
        BYTE         *pUserData,
        unsigned     UserDataLen)
{
    Domain *pDomain;
    MCSError MCSErr;
    ConnectProviderResponseIoctl CPrs;
    
    CheckInitialized("ConnectProvResponse()");

    pDomain = (Domain *) hDomain;

    // Lock the domain.
    EnterCriticalSection(&pDomain->csLock);

    // It is possible for us to call this function in the wrong state, e.g.
    //   if we have gotten a disconnect very soon after processing a
    //   connection, and have transitioned to State_Unconnected.
    if (pDomain->State != Dom_PendingCPResponse) {
        TraceOutIca(pDomain->hIca, "ConnectProvderResp(): in wrong state, "
                "ignoring call");
        MCSErr = MCS_NO_ERROR;
        goto PostLockDomain;
    }

    // TODO FUTURE: We are assuming an hConn in the Domain which is a hack
    //   only for a single-connection system.
    MCSErr = SendConnectProviderResponse(pDomain,
            ((Connection *)pDomain->hConn)->hConnKernel,
            Result, pUserData, UserDataLen);
    if (MCSErr == MCS_NO_ERROR) {
        if (Result == RESULT_SUCCESSFUL)
            pDomain->State = Dom_Connected;
        else
            pDomain->State = Dom_Rejected;
    }

PostLockDomain:
    // Release the domain.
    LeaveCriticalSection(&pDomain->csLock);

    return MCSErr;
}

// Utility function called internally as well as part of
//   MCSConnectProviderResponse(). Domain must be locked before calling.
MCSError SendConnectProviderResponse(
        Domain           *pDomain,
        ConnectionHandle hConnKernel,
        MCSResult        Result,
        BYTE             *pUserData,
        unsigned         UserDataLen)
{
    NTSTATUS Status;
    ConnectProviderResponseIoctl CPrs;

    // Transfer params.
    CPrs.Header.hUser = NULL;  // Special value meaning node controller.
    CPrs.Header.Type = MCS_CONNECT_PROVIDER_RESPONSE;
    CPrs.hConn = hConnKernel;
    CPrs.Result = Result;
    CPrs.UserDataLength = UserDataLen;

    // Points to user data.
    if (UserDataLen)
        CPrs.pUserData = pUserData;

    // Call kernel mode. No callback is expected.
    Status = IcaStackIoControl(pDomain->hIcaStack, IOCTL_T120_REQUEST, &CPrs,
            sizeof(ConnectProviderResponseIoctl), NULL, 0, NULL);
    if (!NT_SUCCESS(Status)) {
        ErrOutIca(pDomain->hIca, "ConnectProvResponse(): Stack ioctl failed");
        return MCS_ALLOCATION_FAILURE;
    }
    TraceOutIca(pDomain->hIca, "Sent MCS_CONNECT_PROVIDER_RESPONSE");

    return MCS_NO_ERROR;
}



/*
 * Terminates an existing MCS connection or aborts a creation in-progress.
 */

MCSError APIENTRY MCSDisconnectProviderRequest(
        HANDLE hIca,
        ConnectionHandle hConn,
        MCSReason Reason)
{
    Domain *pDomain;
    NTSTATUS Status;
    MCSError MCSErr;
    Connection *pConn;
    DisconnectProviderRequestIoctl DPrq;

    CheckInitialized("DisconnectProviderReq()");

    pConn = (Connection *)hConn;
    pDomain = pConn->pDomain;

    // Lock the domain.
    EnterCriticalSection(&pDomain->csLock);

    // Transfer params.
    DPrq.Header.hUser = NULL;  // Special meaning node controller.
    DPrq.Header.Type = MCS_DISCONNECT_PROVIDER_REQUEST;
    DPrq.hConn = pConn->hConnKernel;
    DPrq.Reason = Reason;

    // TODO FUTURE: Assumes only one connection.
    pDomain->hConn = NULL;
    pDomain->State = Dom_Unconnected;

    // TODO FUTURE: We do not deallocate the Connection. Unnecessary for now
    //   since we are using a static Connection in the Domain, but will be an
    //   issue when mallocing the Connection objects.
#ifdef MCS_Future
    EnterCriticalSection(&g_csGlobalListLock);
    SListRemove(&g_ConnList, (unsigned)pConn, NULL);
    LeaveCriticalSection(&g_csGlobalListLock);

    Free(pConn);
#endif

    // Call kernel mode. No callback is expected.
    Status = IcaStackIoControl(pDomain->hIcaStack, IOCTL_T120_REQUEST, &DPrq,
            sizeof(DPrq), NULL, 0, NULL);
    if (!NT_SUCCESS(Status)) {
        ErrOutIca(hIca, "DisconnectProvRequest(): Stack ioctl failed");
        MCSErr = MCS_ALLOCATION_FAILURE;
        goto PostLockDomain;
    }
    
    TraceOutIca(hIca, "Sent MCS_DISCONNECT_PROVIDER_REQUEST");

    MCSErr = MCS_NO_ERROR;

PostLockDomain:
    // Release the domain.
    LeaveCriticalSection(&pDomain->csLock);

    return MCSErr;
}

/*
 *
 * CODE PAST THIS POINT IS FOR REFERENCE PURPOSES ONLY.  IT IS NOT PART OF
 * THE PRODUCT.
 *
 */

#if MCS_Future
/*
 * Connects a local domain to a remote domain, merging the two domains.
 */

MCSError APIENTRY MCSConnectProviderRequest(
        DomainSelector    CallingDom,
        unsigned          CallingDomLen,
        DomainSelector    CalledDom,
        unsigned          CalledDomLen,
        BOOL              bUpwardConnection,
        PDomainParameters pDomParams,
        BYTE              *UserData,
        unsigned          UserDataLen,
        DomainHandle      *phDomain,
        ConnectionHandle  *phConn)

{
    CheckInitialized("ConnectProvReq()");

// Create new domain or look up already-created one.
// call to kernel mode to set up the connection.

    ErrOut("ConnectProviderRequest: Not implemented");
    return MCS_COMMAND_NOT_SUPPORTED;
}
#endif  // MCS_Future


#if MCS_Future
/*
 * Attaches a user SAP to an existing domain.
 */

MCSError APIENTRY MCSAttachUserRequest(
        DomainHandle        hDomain,
        MCSUserCallback     UserCallback,
        MCSSendDataCallback SDCallback,
        void                *UserDefined,
        UserHandle          *phUser,
        unsigned            *pMaxSendSize,
        BOOLEAN             *pbCompleted)
{
    Domain *pDomain;
    unsigned i, Err, OutBufSize, BytesReturned;
    NTSTATUS ntStatus;
    UserInformation *pUserInfo;
    AttachUserReturnIoctl AUrt;
    AttachUserRequestIoctl AUrq;

    CheckInitialized("AttachUserReq()");

    pDomain = (Domain *)hDomain;
    *pbCompleted = FALSE;

    // We must by this time have an hICA assigned to the domain.
    ASSERT(pDomain->hIca != NULL);

    // Make a new user-mode user information struct.
    *phUser = pUserInfo = Malloc(sizeof(UserInformation));
    if (pUserInfo == NULL) {
        ErrOutIca(pDomain->hIca, "AttachUserReq(): Alloc failure for "
                   "user info");
        return MCS_ALLOCATION_FAILURE;
    }

    // Fill in the struct
    pUserInfo->Callback = UserCallback;
    pUserInfo->SDCallback = SDCallback;
    pUserInfo->UserDefined = UserDefined;
    pUserInfo->State = User_AttachConfirmPending;
    pUserInfo->hUserKernel = NULL;  // Don't yet have kernel hUser assignment.
    pUserInfo->UserID = 0;  // Don't yet have kernel UserID assignment.
    pUserInfo->pDomain = pDomain;
    SListInit(&pUserInfo->JoinedChannelList, DefaultNumChannels);

    // Transfer params for kernel-mode call.
    AUrq.Header.hUser = NULL;
    AUrq.Header.Type = MCS_ATTACH_USER_REQUEST;
    AUrq.UserDefined = UserDefined;

    // Add the user to the global UserInfo list.
    EnterCriticalSection(&g_csGlobalListLock);
    if (!SListAppend(&g_UserList, (unsigned)pUserInfo, pDomain)) {
        ErrOutIca(pDomain->hIca, "AttachUserReq(): Could not add user to "
                   "user list");
        AUrt.MCSErr = MCS_ALLOCATION_FAILURE;
        LeaveCriticalSection(&g_csGlobalListLock);
        goto PostAlloc;
    }
    LeaveCriticalSection(&g_csGlobalListLock);

    // Issue the T120 request to kernel mode.
    ntStatus = IcaStackIoControl(pDomain->hIcaStack, IOCTL_T120_REQUEST,
            &AUrq, sizeof(AUrq), &AUrt, sizeof(AUrt), &BytesReturned);
    if (!NT_SUCCESS(ntStatus)) {
        ErrOutIca(pDomain->hIca, "AttachUserRequest(): T120 request failed");
        AUrt.MCSErr = MCS_ALLOCATION_FAILURE;
        goto PostAddList;
    }
    if (AUrt.MCSErr != MCS_NO_ERROR)
        goto PostAddList;

    pUserInfo->hUserKernel = AUrt.hUser;
    *phUser = pUserInfo;
    *pMaxSendSize = AUrt.MaxSendSize;
    pUserInfo->MaxSendSize = AUrt.MaxSendSize;
    if (AUrt.bCompleted) {
        pUserInfo->UserID = AUrt.UserID;
        *pbCompleted = TRUE;
    }

    return MCS_NO_ERROR;

// Error handling.
PostAddList:
    EnterCriticalSection(&g_csGlobalListLock);
    SListRemove(&g_UserList, (unsigned)pUserInfo, NULL);
    LeaveCriticalSection(&g_csGlobalListLock);
    
PostAlloc:
    SListDestroy(&pUserInfo->JoinedChannelList);
    Free(pUserInfo);
    
    return AUrt.MCSErr;
}
#endif  // MCS_Future



#if MCS_Future
UserID MCSGetUserIDFromHandle(UserHandle hUser)
{
    return ((UserInformation *)hUser)->UserID;
}
#endif // MCS_Future



#if MCS_Future
/*
 * Detach a previously created user attachment from a domain.
 */

MCSError APIENTRY MCSDetachUserRequest(UserHandle hUser)
{
    Domain *pDomain;
    NTSTATUS Status;
    unsigned BytesReturned;
    MCSError MCSErr;
    MCSChannel *pMCSChannel;
    UserInformation *pUserInfo;
    DetachUserRequestIoctl DUrq;

    CheckInitialized("DetachUserReq()");
    
    pUserInfo = (UserInformation *)hUser;
    
    // Fill in detach-user request for sending to kernel mode.
    DUrq.Header.Type = MCS_DETACH_USER_REQUEST;
    DUrq.Header.hUser = pUserInfo->hUserKernel;

    // Call down to kernel mode, using the user attachment channel.
    // Issue the T120 request to kernel mode.
    Status = IcaStackIoControl(pUserInfo->pDomain->hIcaStack,
            IOCTL_T120_REQUEST, &DUrq, sizeof(DUrq), &MCSErr, sizeof(MCSErr),
            &BytesReturned);
    if (!NT_SUCCESS(Status)) {
        ErrOutIca(pDomain->hIca, "DetachUserRequest(): T120 request failed");
        return MCS_USER_NOT_ATTACHED;
    }
    if (MCSErr != MCS_NO_ERROR)
        return MCSErr;

    // Remove the hUser from the User list.
    EnterCriticalSection(&g_csGlobalListLock);
    SListRemove(&g_UserList, (unsigned)hUser, &pDomain);
    LeaveCriticalSection(&g_csGlobalListLock);
    if (pDomain == NULL)
        return MCS_NO_SUCH_USER;
    
    // Clean up contents of pUserInfo then free.
    DestroyUserInfo(pUserInfo);
    Free(pUserInfo);

    return MCS_NO_ERROR;
}
#endif  // MCS_Future



#if MCS_Future
/*
 * Join a data channel. Once joined, an attachment can receive data sent on
 * that channel. Static channels are in range 1..1000 and can be joined by
 * any user. Dynamic channels are in range 1001..65535 and cannot be joined
 * unless they are convened by a user and the convenor allows this user
 * to be admitted, or the dynamic channel is a previously assigned channel
 * requested by a user attachment calling JoinRequest() with a channel ID
 * of 0.
 */

MCSError APIENTRY MCSChannelJoinRequest(
        UserHandle    hUser,
        ChannelID     ChannelID,
        ChannelHandle *phChannel,
        BOOLEAN       *pbCompleted)
{
    unsigned Err, BytesReturned;
    NTSTATUS Status;
    MCSChannel *pMCSChannel;
    UserInformation *pUserInfo;
    ChannelJoinReturnIoctl CJrt;
    ChannelJoinRequestIoctl CJrq;

    CheckInitialized("ChannelJoinReq()");

    pUserInfo = (UserInformation *)hUser;
    *pbCompleted = FALSE;

    // Alloc a new user-mode channel struct.
    pMCSChannel = Malloc(sizeof(MCSChannel));
    if (pMCSChannel == NULL) {
        ErrOutIca(pUserInfo->pDomain->hIca, "ChannelJoinReq(): "
                "Could not alloc a user-mode channel");
        return MCS_ALLOCATION_FAILURE;
    }
    pMCSChannel->hChannelKernel = NULL;
    pMCSChannel->ChannelID = 0;

    // Add channel to user list of joined channels.
    if (!SListAppend(&pUserInfo->JoinedChannelList, (unsigned)pMCSChannel,
            pMCSChannel)) {
        ErrOutIca(pUserInfo->pDomain->hIca, "ChannelJoinReq(): "
                "Could not add channel to user mode user list");
        CJrt.MCSErr = MCS_ALLOCATION_FAILURE;
        goto PostAlloc;
    }

    // Transfer params for kernel mode call.
    CJrq.Header.hUser = pUserInfo->hUserKernel;
    CJrq.Header.Type = MCS_CHANNEL_JOIN_REQUEST;
    CJrq.ChannelID = ChannelID;

    // Issue the T120 request to kernel mode
    Status = IcaStackIoControl(pUserInfo->pDomain->hIcaStack,
            IOCTL_T120_REQUEST, &CJrq, sizeof(CJrq), &CJrt, sizeof(CJrt),
            &BytesReturned);
    if (!NT_SUCCESS(Status)) {
        ErrOutIca1(pUserInfo->pDomain->hIca, "ChannelJoinReq(): "
                "T120 request failed (%ld)", Status);
        CJrt.MCSErr = MCS_ALLOCATION_FAILURE;
        goto PostAddList;
    }
    if (CJrt.MCSErr != MCS_NO_ERROR)
        goto PostAddList;

    if (CJrt.bCompleted) {
        // Fill in the user-mode channel info.
        pMCSChannel->hChannelKernel = CJrt.hChannel;
        pMCSChannel->ChannelID = CJrt.ChannelID;
        *phChannel = pMCSChannel;
        *pbCompleted = TRUE;
    }

    return MCS_NO_ERROR;

// Error handling.
PostAddList:
    SListRemove(&pUserInfo->JoinedChannelList, (unsigned)pMCSChannel, NULL);
    
PostAlloc:
    Free(pMCSChannel);
    return CJrt.MCSErr;
}
#endif  // MCS_Future



#if MCS_Future
/*
 * Leave a data channel previously joined. Once unjoined, the user attachment
 * does not receive data from that channel.
 */

MCSError APIENTRY MCSChannelLeaveRequest(
        UserHandle    hUser,
        ChannelHandle hChannel)
{
    unsigned BytesReturned;
    MCSError MCSErr;
    NTSTATUS Status;
    MCSChannel *pMCSChannel;
    UserInformation *pUserInfo;
    ChannelLeaveRequestIoctl CLrq;

    CheckInitialized("ChannelLeaveReq()");

    pUserInfo = (UserInformation *)hUser;

#if DBG
    // Check that the indicated channel is actually present.
    if (!SListGetByKey(&pUserInfo->JoinedChannelList, (unsigned)hChannel,
            &pMCSChannel)) {
        ErrOutIca(pUserInfo->pDomain->hIca, "ChannelLeaveReq(): "
                "Given hChannel not present!");
        return MCS_NO_SUCH_CHANNEL;
    }
#endif

    pMCSChannel = (MCSChannel *)hChannel;
    
    // Transfer params.
    CLrq.Header.Type = MCS_CHANNEL_LEAVE_REQUEST;
    CLrq.Header.hUser = pUserInfo->hUserKernel;
    CLrq.hChannel = pMCSChannel->hChannelKernel;

    // Issue the T120 request to kernel mode
    Status = IcaStackIoControl(pUserInfo->pDomain->hIcaStack,
            IOCTL_T120_REQUEST, &CLrq, sizeof(CLrq), &MCSErr,
            sizeof(MCSErr), &BytesReturned);
    if (!NT_SUCCESS(Status)) {
        ErrOutIca1(pUserInfo->pDomain->hIca, "ChannelLeaveReq(): "
                "T120 request failed (%ld)", Status);
        return MCS_ALLOCATION_FAILURE;
    }
    if (MCSErr != MCS_NO_ERROR)
        return MCSErr;

    // Remove the user-mode channel from the user list and destroy.
    SListRemove(&pUserInfo->JoinedChannelList, (unsigned)pMCSChannel, NULL);
    Free(pMCSChannel);

    return MCS_NO_ERROR;
}
#endif  // MCS_Future



/*
 * Allocates a SendData buffer. This must be done by MCS to ensure high
 *   performance operation without memcpy()'s.
 */

#if MCS_Future
MCSError APIENTRY MCSGetBufferRequest(
        UserHandle hUser,
        unsigned Size,
        void **ppBuffer)
{
    BYTE *pBuf;

    CheckInitialized("GetBufferReq()");

    // Leave sizeof(MCSSendDataRequestIoctl) in front of the block to bypass
    //   memcpy()'s during SendData.
    pBuf = Malloc(sizeof(SendDataRequestIoctl) + Size);
    if (pBuf == NULL) {
        ErrOut("GetBufferReq(): Malloc failed");
        return MCS_ALLOCATION_FAILURE;
    }

    *ppBuffer = pBuf + sizeof(SendDataRequestIoctl);
    return MCS_NO_ERROR;
}
#endif  // MCS_Future



/*
 * Free a buffer allocated using GetBufferRequest(). This should only need to
 *   be done in the case where a buffer was allocated but never used.
 *   SendDataReq() automatically frees the buffer used before it returns.
 */

#if MCS_Future
MCSError APIENTRY MCSFreeBufferRequest(UserHandle hUser, void *pBuffer)
{
    CheckInitialized("FreeBufReq()");

    ASSERT(pBuffer != NULL);

    // Reverse the process done in GetBufferReq() above.
    Free((BYTE *)pBuffer - sizeof(SendDataRequestIoctl));

    return MCS_NO_ERROR;
}
#endif  // MCS_Future



#if MCS_Future
/*
 * Sends data on a channel. The channel need not have been joined before
 * sending. The pData[] buffers must have been generated from successful
 * calls to MCSGetBufferRequest(). After this call the pData[] are invalid;
 * MCS will free them, and assign NULL to the contents in pData[].
 */

MCSError APIENTRY MCSSendDataRequest(
        UserHandle      hUser,
        DataRequestType RequestType,
        ChannelHandle   hChannel,
        ChannelID       ChannelID,
        MCSPriority     Priority,
        Segmentation    Segmentation,
        BYTE            *pData,
        unsigned        DataLength)
{
    unsigned BytesReturned;
    NTSTATUS Status;
    MCSError MCSErr;
    MCSChannel *pMCSChannel;
    UserInformation *pUserInfo;
    SendDataRequestIoctl *pSDrq;

    CheckInitialized("SendDataReq()");
    
    ASSERT(pData != NULL);

    pUserInfo = (UserInformation *)hUser;

#if DBG
    // Check against maximum send size allowed.
    if (DataLength > pUserInfo->MaxSendSize) {
        ErrOutIca(pUserInfo->pDomain->hIca, "SendDataReq(): Send size "
                "exceeds negotiated domain maximum");
        return MCS_SEND_SIZE_TOO_LARGE;
    }
#endif

    // Inbound buffer was allocated by GetBufferReq() with
    //   sizeof(MCSSendDataRequestIoctl) bytes at the beginning.
    pSDrq = (SendDataRequestIoctl *)(pData - sizeof(SendDataRequestIoctl));

    if (hChannel == NULL) {
        // The user requested a send to a channel that it has not joined.

        ASSERT(ChannelID >= 1 && ChannelID <= 65535);

        // Forward the channel number to kernel mode for handling.
        pSDrq->hChannel = NULL;
        pSDrq->ChannelID = ChannelID;
    }
    else {

#if DBG
        // Check that the indicated channel is actually present.
        if (!SListGetByKey(&pUserInfo->JoinedChannelList, (unsigned)hChannel,
                &pMCSChannel)) {
            ErrOutIca(pUserInfo->pDomain->hIca, "SendDataReq(): "
                    "Given hChannel not joined by user!");
            return MCS_NO_SUCH_CHANNEL;
        }
#endif

        pMCSChannel = (MCSChannel *)hChannel;

        pSDrq->hChannel = pMCSChannel->hChannelKernel;
        pSDrq->ChannelID = 0;
    }

    // Fill out data for sending to kernel mode.
    pSDrq->Header.Type = (RequestType == NORMAL_SEND_DATA ?
            MCS_SEND_DATA_REQUEST : MCS_UNIFORM_SEND_DATA_REQUEST);
    pSDrq->Header.hUser = pUserInfo->hUserKernel;
    pSDrq->RequestType = RequestType;
    pSDrq->Priority = Priority;
    pSDrq->Segmentation = Segmentation;
    pSDrq->DataLength = DataLength;

    // Issue the T120 request to kernel mode.
    Status = IcaStackIoControl(pUserInfo->pDomain->hIcaStack,
            IOCTL_T120_REQUEST, (BYTE *)pSDrq,
            sizeof(SendDataRequestIoctl) + DataLength,
            &MCSErr, sizeof(MCSErr), &BytesReturned);
    if (!NT_SUCCESS(Status)) {
        ErrOutIca1(pUserInfo->pDomain->hIca, "MCSSendDataReq(): "
                "T120 request failed (%ld)", Status);
        return MCS_ALLOCATION_FAILURE;
    }
    if (MCSErr != MCS_NO_ERROR)
        return MCSErr;

    // Buffer sent to kernel mode is copied as necessary. We free
    //   the memory after we are done.
    MCSFreeBufferRequest(hUser, pData);

    return MCS_NO_ERROR;
}
#endif  // MCS_Future
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\mcsmux\trace.h ===
/* (C) 1997 Microsoft Corp.
 *
 * file   : Trace.h
 * author : Erik Mavrinac
 *
 * description: MCSMUX tracing defines.
 */

#if DBG

// Used when hIca is not known.
#define ErrOut(str) DbgPrint("MCSMUX: **** ERROR: " str "\n")
#define ErrOut1(str, arg1) DbgPrint("MCSMUX: **** ERROR: " str "\n", arg1)
#define WarnOut(str) DbgPrint("MCSMUX: warning: " str "\n")
#define TraceOut(str) DbgPrint("MCSMUX: " str "\n")


// Used for when the hIca is known.
// These ...Out() macros are graded by the number of extra parameters:
//   Out() is only a string, Out1() is one stack parameter, etc.
// We use non-ICA-defined trace types here to allow clean separation from
//   WDTShare tracing, which uses the ICA TT_API*, TT_OUT*, TT_IN* macros.

#define MCS_TT_Error   TT_ERROR
#define MCS_TT_Warning 0x02000000
#define MCS_TT_Trace   0x04000000
#define MCS_TT_Dump    0x08000000

#define ErrOutIca(hica, str) \
        IcaTrace(hica, TC_PD, MCS_TT_Error, "MCSMUX: **** ERROR: " str "\n")
#define ErrOutIca1(hica, str, arg1) \
        IcaTrace(hica, TC_PD, MCS_TT_Error, "MCSMUX: **** ERROR: " str "\n", arg1)
#define ErrOutIca2(hica, str, arg1, arg2) \
        IcaTrace(hica, TC_PD, MCS_TT_Error, "MCSMUX: **** ERROR: " str "\n", arg1, arg2)

#define WarnOutIca(hica, str) \
        IcaTrace(hica, TC_PD, MCS_TT_Warning, "MCSMUX: warning: " str "\n")
#define WarnOutIca1(hica, str, arg1) \
        IcaTrace(hica, TC_PD, MCS_TT_Warning, "MCSMUX: warning: " str "\n", arg1)
#define WarnOutIca2(hica, str, arg1, arg2) \
        IcaTrace(hica, TC_PD, MCS_TT_Warning, "MCSMUX: warning: " str "\n", arg1, arg2)

#define TraceOutIca(hica, str) \
        IcaTrace(hica, TC_PD, MCS_TT_Trace, "MCSMUX: " str "\n")
#define TraceOutIca1(hica, str, arg1) \
        IcaTrace(hica, TC_PD, MCS_TT_Trace, "MCSMUX: " str "\n", arg1)
#define TraceOutIca2(hica, str, arg1, arg2) \
        IcaTrace(hica, TC_PD, MCS_TT_Trace, "MCSMUX: " str "\n", arg1, arg2)


#else


// Used when hIca is not known.
#define ErrOut(str) 
#define ErrOut1(str, arg1)
#define WarnOut(str)
#define TraceOut(str) 


// Used for when the hIca is known.

#define ErrOutIca(hica, str) 
#define ErrOutIca1(hica, str, arg1) 
#define ErrOutIca2(hica, str, arg1, arg2) 

#define WarnOutIca(hica, str) 
#define WarnOutIca1(hica, str, arg1) 
#define WarnOutIca2(hica, str, arg1, arg2) 

#define TraceOutIca(hica, str) 
#define TraceOutIca1(hica, str, arg1) 
#define TraceOutIca2(hica, str, arg1, arg2) 


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\mcsmux\token.c ===
/* (C) 1997 Microsoft Corp.
 *
 * file   : Token.c
 * author : Erik Mavrinac
 *
 * description: MCSMUX API entry points for MCS T.122 API token functions.
 *
 */

#include "precomp.h"
#pragma hdrstop

#include "mcsmux.h"


/*
 * Grabs the specified token ID. Grabbing is like taking out a critical
 * section in the kernel, except that it's network-based and handled at
 * the Top Provider (that's us). An inhibited token cannot be grabbed.
 */

MCSError APIENTRY MCSTokenGrabRequest(
        UserHandle hUser,
        TokenID    TokenID)
{
    CheckInitialized("TokenGrabReq()");

    ErrOut("TokenGrabReq(): Not implemented");
    return MCS_COMMAND_NOT_SUPPORTED;

/* Implementation notes:
1. Verify hUser.
2. if (TokenID == 0)
       return MCS_INVALID_PARAMETER;
...
*/
}



/*
 * Inhibits the specified token ID. Inhibiting is like increasing a count
 * which prevents grabbing the token.
 */

MCSError APIENTRY MCSTokenInhibitRequest(
        UserHandle hUser,
        TokenID    TokenID)
{
    CheckInitialized("TokenInhibitReq()");

    ErrOut("TokenInhibitReq(): Not implemented");
    return MCS_COMMAND_NOT_SUPPORTED;

/* Implementation notes:
1. Verify hUser.
2. if (TokenID == 0)
       return MCS_INVALID_PARAMETER;
...
*/
}



/*
 * Allows a user attachment to give a token it has grabbed to another user.
 */

MCSError APIENTRY MCSTokenGiveRequest(
        UserHandle hUser,
        TokenID    TokenID,
        UserID     ReceiverID)
{
    CheckInitialized("TokenGiveReq()");

    ErrOut("TokenGiveReq(): Not implemented");
    return MCS_COMMAND_NOT_SUPPORTED;

/* Implementation notes:
1. Verify hUser.
2. if (TokenID == 0)
       return MCS_INVALID_PARAMETER;
3. if (ReceiverID < MinDynamicChannel)
       return MCS_INVALID_PARAMETER;

...
*/
}



/*
 * Allows a user to respond to a token-give offer from another user.
 */
MCSError APIENTRY MCSTokenGiveResponse(
        UserHandle hUser,
        TokenID    TokenID,
        MCSResult  Result)
{
    CheckInitialized("TokenGiveResponse()");

    ErrOut("TokenGiveResponse(): Not implemented");
    return MCS_COMMAND_NOT_SUPPORTED;

/* Implementation notes:
1. Verify hUser.
2. if (TokenID == 0)
       return MCS_INVALID_PARAMETER;
3. verify token is pending a give response.

...
*/
}



/*
 * Allows a user to request a token from the current grabber.
 */

MCSError APIENTRY MCSTokenPleaseRequest(
        UserHandle hUser,
        TokenID    TokenID)
{
    CheckInitialized("TokenPleaseReq()");

    ErrOut("TokenPleaseReq(): Not implemented");
    return MCS_COMMAND_NOT_SUPPORTED;

/* Implementation notes:
1. Verify hUser.
2. if (TokenID == 0)
       return MCS_INVALID_PARAMETER;
3. verify token is pending a give response.

...
*/
}



/*
 * Releases a currently grabbed or inhibited token.
 */

MCSError APIENTRY MCSTokenReleaseRequest(
        UserHandle hUser,
        TokenID    TokenID)
{
    CheckInitialized("TokenReleaseReq()");

    ErrOut("TokenReleaseReq(): Not implemented");
    return MCS_COMMAND_NOT_SUPPORTED;

/* Implementation notes:
1. Verify hUser.
2. if (TokenID == 0)
       return MCS_INVALID_PARAMETER;
3. verify token is grabbed or inhibited by this user.

...
*/
}



/*
 * Tests the current state of a token.
 */

MCSError APIENTRY MCSTokenTestRequest(
        UserHandle hUser,
        TokenID    TokenID)
{
    CheckInitialized("TokenTestReq()");

    ErrOut("TokenTestReq(): Not implemented");
    return MCS_COMMAND_NOT_SUPPORTED;

/* Implementation notes:
1. Verify hUser.
2. if (TokenID == 0)
       return MCS_INVALID_PARAMETER;

...
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\mcsmux\slist.c ===
/* (C) 1997 Microsoft Corp.
 *
 * file    : SList.c
 * authors : Christos Tsollis, Erik Mavrinac
 *
 * description: Implementation of list described in SList.h.
 */

#include "precomp.h"
#pragma hdrstop

#include "MCSMUX.h"


void SListInit(PSList pSL, unsigned NItems)
{
    pSL->MaxEntries = NItems;

    // Allocate the block of items (which, hopefully, will be the last one).
    // NULL return value will be handled in the future.
    pSL->Entries = (_SListNode *)Malloc(NItems * sizeof(_SListNode));

    // Initialize the private member variables
    pSL->NEntries = 0;
    pSL->HeadOffset = 0;
    pSL->CurrOffset = 0xFFFFFFFF;
}



void SListDestroy(PSList pSL)
{
    if (pSL->Entries != NULL) {
        Free(pSL->Entries);
        pSL->Entries = NULL;
        pSL->NEntries = 0;
    }
}



/*
 * Expand
 *   Private function to double the storage of the SList. Returns FALSE on
 *   error.
 */

static BOOLEAN SListExpand(PSList pSL)
{
    unsigned Temp;
    _SListNode *OldEntries;    // Keeps a copy of the old array of values.

    if (pSL->Entries == NULL) {
        // The list is empty; we try to allocate space anyway.
        pSL->Entries = Malloc(pSL->MaxEntries * sizeof(_SListNode));
        if (pSL->Entries == NULL)
            return FALSE;
        return TRUE;
    }
                
    // The current array of entries is full, so we need to allocate a bigger
    //   one. The new array has twice the size of the old one.
    OldEntries = pSL->Entries;
    pSL->Entries = Malloc(pSL->MaxEntries * 2 * sizeof(_SListNode));
    if (pSL->Entries == NULL) {
        // We failed; we have to return
        pSL->Entries = OldEntries;
        return FALSE;
    }

    // Copy the old entries into the new array, starting from the head.
    Temp = pSL->MaxEntries - pSL->HeadOffset;
    MemCpy(pSL->Entries, OldEntries + pSL->HeadOffset, Temp * sizeof(_SListNode));
    MemCpy(pSL->Entries + Temp, OldEntries, pSL->HeadOffset * sizeof(_SListNode));

    // Free the old array of entries
    Free(OldEntries);

    // Set the instance variables
    pSL->MaxEntries *= 2;
    pSL->HeadOffset = 0;
    return TRUE;
}



/*
 * Append
 *   Inserts a value at the end of a list. Returns FALSE on error.
 */

BOOLEAN SListAppend(PSList pSL, unsigned NewKey, void *NewValue)
{
    unsigned Temp;

    if (pSL->Entries == NULL || pSL->NEntries >= pSL->MaxEntries)
        if (!SListExpand(pSL))
            return FALSE;

    ASSERT(pSL->Entries != NULL);
    ASSERT(pSL->NEntries < pSL->MaxEntries);

    Temp = pSL->HeadOffset + pSL->NEntries;
    if (Temp >= pSL->MaxEntries)
        Temp -= pSL->MaxEntries;
    pSL->Entries[Temp].Key = NewKey;
    pSL->Entries[Temp].Value = NewValue;
    pSL->NEntries++;

    return TRUE;
}



/*
 * Prepend
 *   Inserts a value at hte beginning of a list. Returns FALSE on error.
 */

BOOLEAN SListPrepend(PSList pSL, unsigned NewKey, void *NewValue)
{
    if (pSL->Entries == NULL || pSL->NEntries >= pSL->MaxEntries)
        if (!SListExpand(pSL))
            return FALSE;

    ASSERT(pSL->Entries != NULL);
    ASSERT(pSL->NEntries < pSL->MaxEntries);

    if (pSL->HeadOffset == 0)
        pSL->HeadOffset = pSL->MaxEntries - 1;
    else
        pSL->HeadOffset--;
    
    pSL->Entries[pSL->HeadOffset].Key = NewKey;
    pSL->Entries[pSL->HeadOffset].Value = NewValue;
    pSL->NEntries++;

    // Reset iteration.
    pSL->CurrOffset = 0xFFFFFFFF;
    
    return TRUE;
}



/*
 * Remove
 *   Removes a value from the list, returning the value in *pValue. Returns
 *     NULL in *pValue if the key does not exist. pValue can be NULL.
 */

void SListRemove(PSList pSL, unsigned Key, void **pValue)
{
    unsigned i, Temp, CurItem;

    // Find Key in the list.
    CurItem = pSL->HeadOffset;
    for (i = 0; i < pSL->NEntries; i++) {
        if (Key == pSL->Entries[CurItem].Key) {
            // Found it; now move the last value in the list into its place.
            // (Remember we aren't trying to preserve ordering here.)
            if (pValue != NULL)
                *pValue = pSL->Entries[CurItem].Value;

            // Move the last item in the list into the open place.
            Temp = pSL->HeadOffset + pSL->NEntries - 1;
            if (Temp >= pSL->MaxEntries)
                Temp -= pSL->MaxEntries;
            pSL->Entries[CurItem] = pSL->Entries[Temp];

            pSL->NEntries--;
            pSL->CurrOffset = 0xFFFFFFFF;  // Reset iteration.
            return;
        }

        // Advance CurItem, wrapping at end of list.
        CurItem++;
        if (CurItem == pSL->MaxEntries)
            CurItem = 0;
    }

    if (pValue != NULL)
        *pValue = NULL;
}



/*
 * RemoveFirst
 *   Reads and removes the 1st item from the list. Returns the value removed,
 *     or zero if the list is empty.
 */

void SListRemoveFirst(PSList pSL, unsigned *pKey, void **pValue)
{
    if (pSL->NEntries < 1) {
        *pKey = 0;
        *pValue = NULL;
        return;
    }

    // Reset iteration.
    pSL->CurrOffset = 0xFFFFFFFF;
    
    *pKey = (pSL->Entries + pSL->HeadOffset)->Key;
    *pValue = (pSL->Entries + pSL->HeadOffset)->Value;
    pSL->NEntries--;
    pSL->HeadOffset++;
    if (pSL->HeadOffset >= pSL->MaxEntries)
        pSL->HeadOffset = 0;
}



/*
 * GetByKey
 *   Searches the list and returns in *pValue the value corresponding to the
 *     given key. If the key is not present, returns FALSE and NULL in
 *     *pValue. If key is found, reurns nonzero.
 */

BOOLEAN SListGetByKey(PSList pSL, unsigned Key, void **pValue)
{
    unsigned i, Temp;
    _SListNode *pItem;

    // Find Key in the list.
    pItem = pSL->Entries + pSL->HeadOffset;
    for (i = 0; i < pSL->NEntries; i++) {
        if (Key == pItem->Key) {
            // Found it; set *pValue and return.
            *pValue = pItem->Value;
            return TRUE;
        }

        // Advance pItem, wrapping at end of list.
        pItem++;
        if ((unsigned)(pItem - pSL->Entries) >= pSL->MaxEntries)
            pItem = pSL->Entries;
    }

    *pValue = NULL;
    return FALSE;
}



/*
 * RemoveLast
 *   Removes the value at the end of the lst and returns it. If the list is
 *   empty, returns zero.
 */

void SListRemoveLast(PSList pSL, unsigned *pKey, void **pValue)
{
    unsigned Temp;

    if (pSL->NEntries < 1) {
        *pKey = 0;
        *pValue = NULL;
        return;
    }

    // Reset iteration.
    pSL->CurrOffset = 0xFFFFFFFF;
    
    pSL->NEntries--;
    Temp = pSL->HeadOffset + pSL->NEntries - 1;
    if (Temp >= pSL->MaxEntries)
        Temp -= pSL->MaxEntries;

    *pKey = (pSL->Entries + Temp)->Key;
    *pValue = (pSL->Entries + Temp)->Value;
}



/*
 * Iterate
 *   Iterates through the items of a list. CurrOffset is used as a current
 *   iteration pointer, so this function can be called in a loop. Returns
 *   FALSE if the iteration has completed, nonzero if the iteration continues
 *   (and *pKey is valid).
 */

BOOLEAN SListIterate(PSList pSL, unsigned *pKey, void **pValue)
{
    unsigned Temp;

    if (pSL->NEntries < 1)
        return FALSE;

    if (pSL->CurrOffset == 0xFFFFFFFF) {
        // Start from the beginning.
        pSL->CurrOffset = 0;
    }
    else {
        pSL->CurrOffset++;
        if (pSL->CurrOffset >= pSL->NEntries) {
            // Reset the iterator.
            pSL->CurrOffset = 0xFFFFFFFF;
            return FALSE;
        }
    }

    Temp = pSL->CurrOffset + pSL->HeadOffset;
    if (Temp >= pSL->MaxEntries)
        Temp -= pSL->MaxEntries;

    *pKey = pSL->Entries[Temp].Key;
    *pValue = pSL->Entries[Temp].Value;
        
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\makefile.inc ===
!if exist($(TARGET_DIRECTORY).inc)
!include $(TARGET_DIRECTORY).inc
!endif

DLG_FILES=
ICO_FILES=

res.rc: $(ICO_FILES) $(DLG_FILES)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\rdppnutl.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name :
    
    rdppnutl.h

Abstract:

	User-Mode RDP Module Containing Redirected Printer-Related Utilities

Author:

    TadB

Revision History:
--*/

#ifndef _RDPPNUTL_
#define _RDPPNUTL_

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
//  Removes all TS-Redirected Printer Queues
//
DWORD RDPPNUTL_RemoveAllTSPrinters();

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _RDPPNUTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\rdppnutl.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name :
    
    rdppnutl.c

Abstract:

	User-Mode RDP Module Containing Redirected Printer-Related Utilities

Author:

    TadB

Revision History:
--*/

#include <TSrv.h>
#include <winspool.h>
#include "rdppnutl.h"
#include "regapi.h"
#include <wchar.h>

//////////////////////////////////////////////////////////////
//
//  Defines and Macros
//

//
//  Spooler Service Name
//
#define SPOOLER                         L"Spooler"

//
//  Is a character numeric?
//
#define ISNUM(c) ((c>='0')&&(c<='9'))


//////////////////////////////////////////////////////////////
//
//  Globals to this Module
//

//  Number of seconds to wait for the spooler to finish initializing.
DWORD   SpoolerServiceTimeout = 45;


//////////////////////////////////////////////////////////////
//
//  Internal Prototypes
//

//  Actually performs the printer deletion.
void DeleteTSPrinters(
    IN PRINTER_INFO_5 *pPrinterInfo,
    IN DWORD count
    );

//  Load registry settings for this module.
void LoadRDPPNUTLRegistrySettings();

//  Waits until the spooler finishes initializing or until a timeout period 
//  elapses.
DWORD WaitForSpoolerToStart();


DWORD     
RDPPNUTL_RemoveAllTSPrinters()
/*++    

Routine Description:

    Removes all TS-Redirected Printer Queues

Arguments:

Return Value:

    Returns ERROR_SUCCESS on success.  Error status, otherwise.

--*/
{
    PRINTER_INFO_5 *pPrinterInfo = NULL;
    DWORD cbBuf = 0;
    DWORD cReturnedStructs = 0;
    DWORD tsPrintQueueFlags;
    NTSTATUS status;
    PBYTE buf = NULL;
    OSVERSIONINFOEX versionInfo;
    unsigned char stackBuf[4 * 1024];   //  Initial EnumPrinter buffer size to 
                                        //   avoid two round-trip RPC's, if possible.

    //
    //  This code should only run on server.  For Pro/Personal, we can't run because it
    //  affects boot performance.  For Pro, we clean up queues in winlogon anyway.
    //
    versionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if (!GetVersionEx((LPOSVERSIONINFO)&versionInfo)) {
        status = GetLastError();
        TRACE((DEBUG_TSHRSRV_ERROR,"RDPPNUTL: GetVersionEx failed. Error: %08X.\n", 
            status));
        TS_ASSERT(FALSE);
        return status;
    }
    if (versionInfo.wProductType == VER_NT_WORKSTATION) {
        TRACE((DEBUG_TSHRSRV_DEBUG,"RDPPNUTL: Skipping cleanup because not server\n"));
        return ERROR_SUCCESS;
    }

    TRACE((DEBUG_TSHRSRV_DEBUG,"RDPPNUTL: RDPPNUTL_RemoveAllTSPrinters entry\n"));

    //
    //  Load registry settings for this module.
    //
    LoadRDPPNUTLRegistrySettings();

    //
    //  Wait until the spooler has finished initializing.
    //
    status = WaitForSpoolerToStart();
    if (status != ERROR_SUCCESS) {
        TRACE((
            DEBUG_TSHRSRV_DEBUG,
            "RDPPNUTL: RDPPNUTL_RemoveAllTSPrinters exiting because spooler failed to start.\n"
            ));
        return status; 
    }

    //
    //  Try to enumerate printers using the stack buffer, first, to avoid two 
    //  round-trip RPC's to the spooler, if possible.
    //
    if (!EnumPrinters(
            PRINTER_ENUM_LOCAL,     // Flags
            NULL,                   // Name
            5,                      // Print Info Type
            stackBuf,               // buffer
            sizeof(stackBuf),       // Size of buffer
            &cbBuf,                 // Required
            &cReturnedStructs)) {
        status = GetLastError();

        //
        //  See if we need to allocate more room for the printer information.
        //
        if (status == ERROR_INSUFFICIENT_BUFFER) {
            buf = TSHeapAlloc(HEAP_ZERO_MEMORY,
                              cbBuf,
                              TS_HTAG_TSS_PRINTERINFO2);

            if (buf == NULL) {
                TRACE((DEBUG_TSHRSRV_ERROR,"RDPPNUTL: ALLOCMEM failed. Error: %08X.\n", 
                    GetLastError()));
                status = ERROR_OUTOFMEMORY;
            }
            else {
                pPrinterInfo = (PRINTER_INFO_5 *)buf;
                status = ERROR_SUCCESS;
            }

            //
            //  Enumerate printers.
            //
            if (status == ERROR_SUCCESS) {
                if (!EnumPrinters(
                        PRINTER_ENUM_LOCAL,
                        NULL,
                        5,
                        (PBYTE)pPrinterInfo,
                        cbBuf,
                        &cbBuf,
                        &cReturnedStructs)) {

                    TRACE((DEBUG_TSHRSRV_ERROR,"RDPPNUTL: EnumPrinters failed. Error: %08X.\n", 
                        GetLastError()));
                    status = GetLastError();
                }
                else {
                    TRACE((DEBUG_TSHRSRV_DEBUG,"RDPPNUTL: Second EnumPrinters succeeded.\n"));
                }
            }
        }
	    else {
            TRACE((DEBUG_TSHRSRV_ERROR,"RDPPNUTL: EnumPrinters failed. Error: %08X.\n", 
                        GetLastError()));
	    }
    }
    else {
        TRACE((DEBUG_TSHRSRV_DEBUG,"RDPPNUTL: First EnumPrinters succeeded.\n"));
        status = ERROR_SUCCESS;
        pPrinterInfo = (PRINTER_INFO_5 *)stackBuf;
    }

    //
    //  Delete all the TS printers.  We allow ERROR_INSUFFICIENT_BUFFER here because
    //  a second invokation of EnumPrinters may have missed a few last-minute
    //  printer additions.
    //
    if ((status == ERROR_SUCCESS) || (status == ERROR_INSUFFICIENT_BUFFER)) {

        DeleteTSPrinters(pPrinterInfo, cReturnedStructs);

        status = ERROR_SUCCESS;
    }

    //
    //  Release the printer info buffer.
    //
    if (buf != NULL) {
        TSHeapFree(buf);                
    }


    TRACE((DEBUG_TSHRSRV_DEBUG,"TShrSRV: RDPPNUTL_RemoveAllTSPrinters exit\n"));

    return status;
}

void 
DeleteTSPrinters(
    IN PRINTER_INFO_5 *pPrinterInfo,
    IN DWORD count
    )
/*++    

Routine Description:

    Actually performs the printer deletion.

Arguments:

    pPrinterInfo    -   All printer queues on the system.
    count           -   Number of printers in pPrinterInfo

Return Value:

    NA

--*/
{
    DWORD i;
    DWORD regValueDataType;
    DWORD sessionID;
    HANDLE hPrinter = NULL;
    DWORD bufSize;
    PRINTER_DEFAULTS defaults = {NULL, NULL, PRINTER_ALL_ACCESS};

    TRACE((DEBUG_TSHRSRV_DEBUG,"RDPPNUTL: DeleteTSPrinters entry\n"));

    for (i=0; i<count; i++) {

        if (pPrinterInfo[i].pPrinterName) {

            TRACE((DEBUG_TSHRSRV_DEBUG,"RDPPNUTL: Checking %ws for TS printer status.\n",
			    pPrinterInfo[i].pPrinterName));

            //
            //  Is this a TS printer?
            //
            if (pPrinterInfo[i].pPortName &&
                (pPrinterInfo[i].pPortName[0] == 'T') &&
                (pPrinterInfo[i].pPortName[1] == 'S') && 
                ISNUM(pPrinterInfo[i].pPortName[2])) {

                TRACE((DEBUG_TSHRSRV_DEBUG,"RDPPNUTL: %ws is a TS printer.\n",
                    pPrinterInfo[i].pPrinterName));
            }
            else {
                continue;
            }

            //
            //  Purge and delete the printer.
            //
            if (OpenPrinter(pPrinterInfo[i].pPrinterName, &hPrinter, &defaults)) {
                if (!SetPrinter(hPrinter, 0, NULL, PRINTER_CONTROL_PURGE) ||
                    !DeletePrinter(hPrinter)) {
                    TRACE((DEBUG_TSHRSRV_WARN,"RDPPNUTL: Error deleting printer %ws.\n", 
                           pPrinterInfo[i].pPrinterName));
                }
                else {
                    TRACE((DEBUG_TSHRSRV_DEBUG,"RDPPNUTL: Successfully deleted %ws.\n",
			            pPrinterInfo[i].pPrinterName));
                }
                ClosePrinter(hPrinter);
            }
            else {
                TRACE((DEBUG_TSHRSRV_ERROR,
                        "RDPPNUTL: OpenPrinter failed for %ws. Error: %08X.\n",
                        pPrinterInfo[i].pPrinterName,
                        GetLastError())
                        );
            }
        }
        else {
            TRACE((DEBUG_TSHRSRV_DEBUG,"RDPPNUTL: Printer %ld is NULL\n", i));
        }
    }

    TRACE((DEBUG_TSHRSRV_DEBUG,"RDPPNUTL: DeleteTSPrinters exit\n"));
}

void 
LoadRDPPNUTLRegistrySettings()
/*++    

Routine Description:

    Load registry settings for this module.

Arguments:

Return Value:
    
      NA
--*/
{
    HKEY regKey;
    DWORD dwResult;
    DWORD type;
    DWORD sz;

    TRACE((DEBUG_TSHRSRV_DEBUG,"RDPPNUTL: Loading registry settings.\n"));

    //
    //  Open the registry key.
    //
    dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, DEVICERDR_REG_NAME, 
                            0, KEY_READ, &regKey);
    if (dwResult == ERROR_SUCCESS) {
        //
        //  Read the "wait for spooler" timeout value.
        //
        sz = sizeof(SpoolerServiceTimeout);
        dwResult = RegQueryValueEx(
                            regKey,
                            DEVICERDR_WAITFORSPOOLTIMEOUT,
                            NULL,
                            &type,
                            (PBYTE)&SpoolerServiceTimeout,
                            &sz
                            ); 
        if (dwResult != ERROR_SUCCESS){
            TRACE((DEBUG_TSHRSRV_WARN,
                    "RDPPNUTL: Failed to read spooler timeout value.:  %08X.\n",
                    dwResult));
        }
        else {
            TRACE((DEBUG_TSHRSRV_WARN,
                    "RDPPNUTL: Spooler timeout value is %ld.\n",
                    SpoolerServiceTimeout));
        }

        //
        //  Close the reg key.
        //
        RegCloseKey(regKey);
    }
    else {
        TRACE((DEBUG_TSHRSRV_ERROR,
                "RDPPNUTL: Failed to open registry key:  %08X.\n",
                dwResult));
    }
}

DWORD 
WaitForSpoolerToStart()
/*++    

Routine Description:

    Waits until the spooler finishes initializing or until a timeout period 
    elapses.

Arguments:

Return Value:

    Returns ERROR_SUCCESS if the spooler successfully initialized.  Otherwise, 
    an error code is returned.

--*/
{
    SC_HANDLE scManager = NULL;
    SC_HANDLE hService = NULL;
    DWORD result = ERROR_SUCCESS;
    SERVICE_STATUS serviceStatus;
    DWORD i;
    QUERY_SERVICE_CONFIG *pServiceConfig = NULL;
    DWORD bufSize;
    
    TRACE((DEBUG_TSHRSRV_DEBUG,"RDPPNUTL: Enter WaitForSpoolerToStart.\n"));

    //
    //  Open the service control manager.
    //
    scManager = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);
    if (scManager == NULL) {
        result = GetLastError();
        TRACE((DEBUG_TSHRSRV_ERROR,"RDPPNUTL: OpenSCManager failed with %08X.\n",
            result));
        goto CleanUpAndExit;
    }

    //
    //  Open the spooler service.
    //
    hService = OpenService(scManager, SPOOLER, SERVICE_ALL_ACCESS);
    if (hService == NULL) {
        result = GetLastError();
        TRACE((DEBUG_TSHRSRV_ERROR,
            "RDPPNUTL: OpenService on spooler failed with %08X.\n",
            result));
        goto CleanUpAndExit;
    }

    //
    //  If the spooler is currently running, that is all we need to know.
    //
    if (!QueryServiceStatus(hService, &serviceStatus)) {
        result = GetLastError();
        TRACE((DEBUG_TSHRSRV_ERROR,
            "RDPPNUTL: QueryServiceStatus on spooler failed with %08X.\n",
            result));
        goto CleanUpAndExit;
    }
    else if (serviceStatus.dwCurrentState == SERVICE_RUNNING) {
        TRACE((DEBUG_TSHRSRV_DEBUG,"RDPPNUTL: Spooler is running.\n"));
        result = ERROR_SUCCESS;
        goto CleanUpAndExit;
    }

    //
    //  Size the spooler service query configuration buffer.  This API should
    //  fail with ERROR_INSUFFICIENT_BUFFER, so we can get the size of the 
    //  buffer before we call the function with real parameters.
    //
    if (!QueryServiceConfig(hService, NULL, 0, &bufSize) &&
        (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        
            pServiceConfig = (QUERY_SERVICE_CONFIG *)TSHeapAlloc(
                                            HEAP_ZERO_MEMORY,
                                            bufSize,
                                            TS_HTAG_TSS_SPOOLERINFO
                                            );
        if (pServiceConfig == NULL) {
            TRACE((DEBUG_TSHRSRV_ERROR,"RDPPNUTL: ALLOCMEM failed. Error: %08X.\n", GetLastError()));
            result = ERROR_OUTOFMEMORY;
            goto CleanUpAndExit;
        }
    }
    else {
        TRACE((DEBUG_TSHRSRV_ERROR,"RDPPNUTL: QueryServiceConfig unexpected return.\n"));
        result = E_UNEXPECTED;
        goto CleanUpAndExit;
    }

    //
    //  Get the spooler's configuration information.
    //
    if (!QueryServiceConfig(hService, pServiceConfig, bufSize, &bufSize)) {
        TRACE((DEBUG_TSHRSRV_ERROR,"RDPPNUTL: QueryServiceConfig failed: %08X.\n", 
            GetLastError()));
        result = GetLastError();
        goto CleanUpAndExit;

    }

    //
    //  If the spooler is not automatically configured to start on demand or 
    //  automatically on system start then that is all we need to know.
    //
    if (pServiceConfig->dwStartType != SERVICE_AUTO_START) {
        TRACE((DEBUG_TSHRSRV_WARN,"RDPPNUTL: Spooler not configured to start.\n"));
        result = E_FAIL;
        goto CleanUpAndExit;
    }

    //
    //  Poll the service status until we timeout or until the spooler 
    //  starts.
    //
    for (i=0; (i<SpoolerServiceTimeout) && 
              (serviceStatus.dwCurrentState != SERVICE_RUNNING); i++) {

        //
        //  Sleep for a sec.
        //
        Sleep(1000);

        TRACE((DEBUG_TSHRSRV_DEBUG,"RDPPNUTL: Spooler is still initializing.\n"));

        //
        //  Try again.
        //
        if (!QueryServiceStatus(hService, &serviceStatus)) {
            result = GetLastError();
            TRACE((DEBUG_TSHRSRV_ERROR,
                "RDPPNUTL: QueryServiceStatus on spooler failed with %08X.\n",
                result));
            goto CleanUpAndExit;
        }
    }

    //
    //  Sucess if the spooler is now running.  
    //
    if (serviceStatus.dwCurrentState == SERVICE_RUNNING) {
        result = ERROR_SUCCESS;
    }
    else {
        TRACE((DEBUG_TSHRSRV_WARN,
            "RDPPNUTL: Spooler is not running after a timeout or error.\n")
            );
        result = E_FAIL;
    }

CleanUpAndExit:

    if (pServiceConfig != NULL) {
        TSHeapFree(pServiceConfig);                
    }

    if (scManager != NULL) {
        CloseServiceHandle(scManager);
    }

    if (hService != NULL) {
        CloseServiceHandle(hService);
    }

    TRACE((DEBUG_TSHRSRV_DEBUG,"RDPPNUTL: Exit WaitForSpoolerToStart.\n"));

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpcfgex\rdpcfgex.c ===
/*******************************************************************************
*
* rdpcfgex.c
*
* WinCfg extension DLL
*
* Copyright (c) 1997, Microsoft Corporation
* All rights reserved.
*
*******************************************************************************/

#include <windows.h>
#include <tscfgex.h>
#include "rdpcfgex.h"
#include <ntverp.h>

//
// This global variable is returned to TSCFG and is used to populate the
// Encryption Level field.
//
const EncryptionLevel EncryptionLevels[] = {
   {  IDS_LOW,          REG_LOW,        0  },
   {  IDS_COMPATIBLE,   REG_MEDIUM,     ELF_DEFAULT  },
   {  IDS_HIGH,         REG_HIGH,       0 },
   {  IDS_FIPS,         REG_FIPS,       0 }
};

/////////////////////////////////////////////////////////////////////////////
// DllMain
//
// Main entry point of the DLL
//
BOOL APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
#if defined(FULL_DEBUG)
    OutputDebugString(TEXT("RDPCFGX: DllMain Called\n"));
#endif
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// ExtStart
//
// WinCfg calls this function immediately after loading the DLL
// Put any global initialization stuff here
//
void WINAPI ExtStart(WDNAME *pWdName)
{
#if defined(FULL_DEBUG)
    OutputDebugString(TEXT("RDPCFGX: ExtStart Called\n"));
#endif
}


/////////////////////////////////////////////////////////////////////////////
// ExtEnd
//
// WinCfg calls this function when exiting
// Put any global cleanup stuff here
//
void WINAPI ExtEnd()
{
#if defined(FULL_DEBUG)
    OutputDebugString(TEXT("RDPCFGX: ExtEnd Called\n"));
#endif
}

//-------------------------------------------------------------------------
// We need to be compatible with citrix, modifying EncryptionLevel struct
// would cause some undesirable results on a metaframe server.  Currently
// the MS ext will support description for the encryption levels.
// When TSCC obtains the extension config dll it will getproc this method
// failure indicates that we have a non-MS cfgdll
//
LONG WINAPI ExtGetEncryptionLevelDescr( int idx , int *pnResid )
{
    switch( idx )
    {
    case REG_LOW:

        *pnResid = IDS_LOW_DESCR;
        break;

    case REG_MEDIUM:

        *pnResid = IDS_COMPATIBLE_DESCR;
        break;

    case REG_HIGH:

        *pnResid = IDS_HI_DESCR;
        break;

    case REG_FIPS:

        *pnResid = IDS_FIPS_DESCR;
        break;

    default:
    #if DBG
        OutputDebugString(TEXT("RDPCFGX: ExtGetEncryptionLevelDescr - invalid arg\n"));
    #endif
        *pnResid = 0;
    }

    return ( *pnResid ? 0 : -1 );
}

//-------------------------------------------------------------------------
// VER_PRODUCTVERSION_DW defined in ntverp.h
//-------------------------------------------------------------------------
DWORD WINAPI ExGetCfgVersionInfo( void )
{
    return VER_PRODUCTVERSION_DW;
}

/////////////////////////////////////////////////////////////////////////////
// ExtEncryptionLevels
//
// Provide array of encryption levels for this protocol
// Returns the number of encryption levels in the array
//
LONG WINAPI ExtEncryptionLevels(WDNAME *pWdName, EncryptionLevel **levels)
{
#if defined(FULL_DEBUG)
    OutputDebugString(TEXT("RDPCFGX: ExtEncryptionLevels Called\n"));
#endif

   *levels = (EncryptionLevel *)EncryptionLevels;

   return NUM_RDP_ENCRYPTION_LEVELS;
}

/////////////////////////////////////////////////////////////////////////////
// ExtGetCapabilities
//
// This routine returns a ULONG which contains a mask of the different
// Client settings that the RDP protocol supports.
//
ULONG WINAPI ExtGetCapabilities(void)
{
    return ( WDC_CLIENT_AUDIO_MAPPING |
             WDC_CLIENT_DRIVE_MAPPING |
             WDC_WIN_CLIENT_PRINTER_MAPPING |
             WDC_CLIENT_LPT_PORT_MAPPING |
             WDC_CLIENT_COM_PORT_MAPPING |
             WDC_CLIENT_CLIPBOARD_MAPPING |

        // left here for backwards compatibility
             WDC_SHADOWING );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpcfgex\rdpcfgex.h ===
/*++

Copyright (C) 1989-1998 Microsoft Corporation, All rights reserved

Module:
    tscfgex.h

Abstract:
    Terminal Server Connection Configuration DLL extension data structures
    and function prototypes.

Author:
    Brad Graziadio (BradG) 4-Feb-98

--*/

#ifndef _RDPCFGEX_
#define _RDPCFGEX_

//
// Constants used for string table entries
//
#define IDS_LOW                         1000
#define IDS_COMPATIBLE                  1001
#define IDS_HIGH                        1002
#define IDS_FIPS                        1003

#define IDS_LOW_DESCR                   1010
#define IDS_COMPATIBLE_DESCR            1011
#define IDS_HI_DESCR                    1012
#define IDS_FIPS_DESCR                  1013

//
// DWORD values that get stored in the registry to represent the
// encryption level.
//
#define REG_LOW                         0x00000001
#define REG_MEDIUM                      0x00000002
#define REG_HIGH                        0x00000003
#define REG_FIPS                        0x00000004

//
// Number of encryption levels the RDP protocol uses
//
#define NUM_RDP_ENCRYPTION_LEVELS       4

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\tsrv.c ===
//*************************************************************
//
//  File name:      TSrv.c
//
//  Description:    Contains routines to support remote
//                  terminals
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1991-1997
//  All rights reserved
//
//*************************************************************

#include <regapi.h>
#include <TSrv.h>
#include <TSrvTerm.h>
#include <TSrvCom.h>
#include <TSrvInfo.h>
#include <TSrvVC.h>
#include <McsLib.h>

#include "stdio.h"

#include "_tsrvinfo.h"
#include <tlsapi.h>

// Data declarations

HINSTANCE       g_hDllInstance = NULL;        // DLL instance
HANDLE          g_hMainThread = NULL;         // Main work thread
HANDLE          g_hReadyEvent = NULL;         // Ready event
BOOL            g_fShutdown = FALSE;          // TSrvShare shutdown flag
HANDLE          g_hIcaTrace;                  // system wide trace handle
HANDLE          g_MainThreadExitEvent = NULL;

extern HANDLE g_hVCAddinChangeEvent;
extern HKEY   g_hAddinRegKey;                 // handle to Addins reg subkey

#define CERTIFICATE_INSTALLATION_INTERVAL 900000

LICENSE_STATUS GetServerCertificate(CERT_TYPE   CertType,
                                    LPBYTE *    ppbCertificate,
                                    LPDWORD     pcbCertificate );

//*************************************************************
//
//  DllMain()
//
//  Purpose:    Dll entry point.
//
//  Parameters: IN [hInstance]     -- Dll hInstance.
//              IN [dwReason]      -- Call reason
//              IN [lpReserved]    -- Reserved.
//
//  Return:     TRUE        if successful
//              FALSE       if not
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************
BOOL WINAPI _CRT_INIT(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved);

BOOL
WINAPI
TShareDLLEntry(
    IN HINSTANCE    hInstance,
    IN DWORD        dwReason,
    IN LPVOID       lpReserved)
{
    BOOL    fSuccess;

    // DbgBreakPoint();

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: DllMain entry\n"));

    TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: hInstance 0x%x, dwReason 0x%x\n",
             hInstance, dwReason));

    fSuccess = TRUE;

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            if (!_CRT_INIT(hInstance, dwReason, lpReserved))
                return(FALSE);

            TRACE((DEBUG_TSHRSRV_NORMAL,
                    "TShrSRV: DLL attach\n"));

            // Disable thread library calls and save off
            // the DLL instance handle

            DisableThreadLibraryCalls(hInstance);

            g_hDllInstance = hInstance;

            TSRNG_Initialize();

            //
            // init TShare util library.
            //

            if (TSUtilInit() != ERROR_SUCCESS)
            {
                fSuccess = FALSE;
                break;
            }

            //
            // invoke mcsmux library first.
            //

            if (!MCSDLLInit())
            {
                fSuccess = FALSE;
                break;
            }

            //
            // Invoke TShareSRV initialization
            //

            if (!TSRVStartup())
            {
                fSuccess = FALSE;
                break;
            }

            //
            // additional init routines go here.
            //

            break;

        case DLL_PROCESS_DETACH:

            TRACE((DEBUG_TSHRSRV_NORMAL,
                    "TShrSRV: DLL deattach\n"));

            //
            // Invoke TShareSRV shutdown
            //

            TSRVShutdown();

            //
            // invoke mcsmux cleanup routine.
            //

            MCSDllCleanup();

            TSUtilCleanup();

            TSRNG_Shutdown();

            if (!_CRT_INIT(hInstance, dwReason, lpReserved))
                return(FALSE);

            break;

        default:
            TRACE((DEBUG_TSHRSRV_DEBUG,
                    "TShrSRV: Unknown reason code\n"));
            break;
    }

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: DllMain exit - 0x%x\n",
            fSuccess));

    return (fSuccess);
}


//*************************************************************
//
//  TSRVStartup()
//
//  Purpose:    Performs startup processing.
//
//  Parameters: void
//
//  Return:     TRUE        if successful
//              FALSE       if not
//
//  Notes:      This routine is called by DLLMain to perform the
//              most basic initialization
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

BOOL
TSRVStartup(void)
{
    DWORD err;
    LONG rc;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSRVStartup entry\n"));

    g_hMainThread = NULL;

    g_MainThreadExitEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

    if( NULL == g_MainThreadExitEvent )
    {
        err = GetLastError();
        TRACE((DEBUG_TSHRSRV_FLOW,
               "TShrSRV: TSRVStartup exit - 0x%x\n",
               err));

        return FALSE;
    }


    rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      TSRV_VC_KEY,
                      0,
                      KEY_READ,
                      &g_hAddinRegKey);

    if (rc == ERROR_SUCCESS)
    {
        g_hVCAddinChangeEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

        if( NULL == g_hVCAddinChangeEvent )
        {
            //
            // This is not catastrophic, so we just trace and continue.
            //
            err = GetLastError();
            TRACE((DEBUG_TSHRSRV_ERROR,
                   "TShrSRV: Failed to create VC Addin Change event - 0x%x\n",
                   err));
        }

    }
    else
    {
        // This is not catastrophic either.
        TRACE((DEBUG_TSHRSRV_ERROR,
               "TShrSRV: Failed to open key %S, rc %d\n",
               TSRV_VC_KEY, rc));
    }

    g_hReadyEvent = CreateEvent(NULL,       // security attributes
                                FALSE,      // manual-reset event
                                FALSE,      // initial state
                                NULL);      // event-object name

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSRVStartup exit - 0x%x\n",
             g_hReadyEvent ? TRUE : FALSE));

    return (g_hReadyEvent ? TRUE : FALSE);
}


//*************************************************************
//
//  TSRVShutdown()
//
//  Purpose:    Performs shutdown processing.
//
//  Parameters: void
//
//  Return:     void
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

void
TSRVShutdown(void)
{
    DWORD dwWaitStatus;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSRVShutdown entry\n"));

    // Denote that we are no longer ready to service any
    // new requests

    TSrvReady(FALSE);

    // If we were able to launch our main worker thread, then
    // we may need to terminate conferences, etc.

    if (g_hMainThread)
    {
        // Tell the system that we are terminating.  This will cause
        // TSrvMainThread to exit once it has finished servicing all
        // outstanding posted work items.

        TSrvTerminating(TRUE);

        // Wait for TSrvMainThread to exit

        TRACE((DEBUG_TSHRSRV_NORMAL,
                "TShrSRV: Waiting for TSrvMainThread to exit\n"));

        SetEvent( g_MainThreadExitEvent );

        dwWaitStatus = WaitForSingleObject(g_hMainThread, 600000);

        if( WAIT_OBJECT_0 != dwWaitStatus )
        {
            //
            // The thread did not terminate within allowable time
            //

            TRACE((DEBUG_TSHRSRV_DEBUG,
                   "TShrSRV: TSrvMainThread refused to exit, killing\n"));

            TerminateThread( g_hMainThread, 0 );
        }

        CloseHandle( g_hMainThread );
        g_hMainThread = NULL;

        CloseHandle( g_MainThreadExitEvent );
        g_MainThreadExitEvent = NULL;

        CloseHandle( g_hVCAddinChangeEvent );
        g_hVCAddinChangeEvent = NULL;

        if (g_hAddinRegKey)
        {
            RegCloseKey(g_hAddinRegKey);
            g_hAddinRegKey = NULL;
        }

        // Get the VC code to free its stuff
        TSrvTermVC();

        TLSShutdown();
    }
    else
    {
        TSrvTerminating(TRUE);
    }

    // Inform GCC we no longer want to be a Node Controller

    TSrvUnregisterNC();

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSRVShutdown exit\n"));
}


//*************************************************************
//
//  TSrvMainThread()
//
//  Purpose:    Main worker thread for TShareSRV.
//
//  Parameters: void
//
//  Return:     0
//
//  Notes:      This thread is spawned by DLLMain.  It performs
//              the vast majority of TShareSRV initialization
//              and then waits for work items to be posted to it.
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

DWORD
WINAPI
TSrvMainThread(LPVOID pvContext)
{
    LPBYTE pX509Cert;
    DWORD dwX509CertLen;
    DWORD dwWaitStatus;
    LICENSE_STATUS Status;
    LARGE_INTEGER DueTime = {0,0};
    HANDLE rghWait[4] = {0};
    DWORD dwCount = 0;
    DWORD dwWaitExit = 0xFFFFFFFF;
    DWORD dwWaitVCAddin = 0xFFFFFFFF;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvMainThread entry\n"));

    if (TSrvInitialize())
    {
        TSrvReady(TRUE);

        TRACE((DEBUG_TSHRSRV_NORMAL,
                "TShrSRV: Entering TSrvMainThread worker loop\n"));

        if (g_MainThreadExitEvent)
        {
            dwWaitExit = WAIT_OBJECT_0 + dwCount;
            rghWait[dwCount] = g_MainThreadExitEvent;
            dwCount++;
            TRACE((DEBUG_TSHRSRV_DEBUG, "TShrSRV: Added exit event\n"));
        }

        if (g_hVCAddinChangeEvent)
        {
            //
            // The addin change notification was set up earlier, when we read
            // the addins information from the registry.
            //
            dwWaitVCAddin = WAIT_OBJECT_0 + dwCount;
            rghWait[dwCount] = g_hVCAddinChangeEvent;
            dwCount++;
        }

        while (1)
        {
            dwWaitStatus = WaitForMultipleObjects(dwCount,
                                                  rghWait,
                                                  FALSE,
                                                  INFINITE);

            if( dwWaitExit == dwWaitStatus )
            {
                //
                // time to exit the thread
                //

                TRACE((DEBUG_TSHRSRV_NORMAL,
                    "TShrSRV: TSrvMainThread got EXIT event\n"));
                break;
            }
            else if (dwWaitVCAddin == dwWaitStatus)
            {
                //
                // The Virtual Channel Addins registry key has changed.
                // We need to kick off a refresh of our data.
                //
                TRACE((DEBUG_TSHRSRV_WARN,
                    "TShrSRV: TSrvMainThread got VC ADDINS CHANGED event\n"));
                TSrvGotAddinChangedEvent();                
            }
            else 
            {
                TS_ASSERT(dwWaitStatus == WAIT_FAILED);
                TRACE((DEBUG_TSHRSRV_DEBUG,
                    "TShrSRV: Wait failed, so we'll just exit\n"));

                //
                // Wait failed, just bail
                //
                break;
            }            
        }

        TSrvReady(FALSE);
    }

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvMainThread exit - 0x%x\n",
            0));

    return (0);
}


//*************************************************************
//
//  TSrvInitialize()
//
//  Purpose:    Main routine for TSrvShare initialization
//
//  Parameters: void
//
//  Return:     TRUE        if successful
//              FALSE       if not
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

BOOL
TSrvInitialize(void)
{
    BOOL    fSuccess;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvInitialize entry\n"));

    fSuccess = FALSE;

    // Initialize TSrvInfo data structs

    if (TSrvInitGlobalData())
    {
        if (TSrvInitVC())
        {
            // Register TShareSRV as GCC node controller

            if (TSrvRegisterNC())
            {
                if (ERROR_SUCCESS == TLSInit())
                {
                    fSuccess = TRUE;
                }
            }
        }
    }

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvInitialize exit - 0x%x\n", fSuccess));

    return (fSuccess);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\tsrv.h ===
//---------------------------------------------------------------------------
//
//  File:       TSrv.h
//
//  Contents:   TShareSRV public include file
//
//  Copyright:  (c) 1992 - 1997, Microsoft Corporation.
//              All Rights Reserved.
//              Information Contained Herein is Proprietary
//              and Confidential.
//
//  History:    7-JUL-97    BrianTa         Created.
//
//---------------------------------------------------------------------------

#ifndef _TSRV_H_
#define _TSRV_H_

#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <t120.h>
#include <tshrutil.h>
#include <lscsp.h>
#include "license.h"
#include <tssec.h>


//
// Defines
//

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C        extern "C"
#else
    #define EXTERN_C        extern
#endif
#endif


//
//  Externs
//

extern  HINSTANCE       g_hDllInstance;         // DLL instance
extern  HANDLE          g_hMainThread;          // Main work thread
extern  HANDLE          g_hReadyEvent;          // Ready event
extern  BOOL            g_fShutdown;            // TSrvShare shutdown flag


//
// TSrv.c Prototypes
//

EXTERN_C DWORD WINAPI TSrvMainThread(LPVOID pvContext);

EXTERN_C BOOL   TSRVStartup(void);
EXTERN_C void   TSRVShutdown(void);
EXTERN_C BOOL   TSrvInitialize(void);


//
// TSrvMisc.c protptypes
//

EXTERN_C void   TSrvReady(IN BOOL fReady);
EXTERN_C BOOL   TSrvIsReady(IN BOOL fWait);
EXTERN_C void   TSrvTerminating(BOOL fTerminating);
EXTERN_C BOOL   TSrvIsTerminating(void);
EXTERN_C PVOID  TSrvAllocSection(PHANDLE phSection, ULONG ulSize);
EXTERN_C void   TSrvFreeSection(HANDLE hSection, PVOID  pvBase);

#endif // _TSRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\tsrv128.h ===
//---------------------------------------------------------------------------
//
//  File:       TSrvWsx.h
//
//  Contents:   TSrvWsx private include file
//
//  Copyright:  (c) 1992 - 1997, Microsoft Corporation.
//              All Rights Reserved.
//              Information Contained Herein is Proprietary
//              and Confidential.
//
//  History:    17-JUL-97   BrianTa         Created.
//
//---------------------------------------------------------------------------

#ifndef _TSRV128_H_
#define _TSRV128_H_


/****************************************************************************/
/* Constants                                                                */
/****************************************************************************/

#define NET_MAX_SIZE_SEND_PKT           32000

/****************************************************************************/
/* Basic type definitions                                                   */
/****************************************************************************/

typedef ULONG   TS_SHAREID;


/**STRUCT+*******************************************************************/
/* Structure: TS_SHARECONTROLHEADER                                         */
/*                                                                          */
/* Description: ShareControlHeader                                          */
/****************************************************************************/

typedef struct _TS_SHARECONTROLHEADER
{
    USHORT                  totalLength;
    USHORT                  pduType;    // Also encodes the protocol version
    USHORT                  pduSource;
    
} TS_SHARECONTROLHEADER, *PTS_SHARECONTROLHEADER;

/**STRUCT+*******************************************************************/
/* Structure: TS_SHAREDATAHEADER                                            */
/*                                                                          */
/* Description: ShareDataHeader                                             */
/****************************************************************************/

typedef struct _TS_SHAREDATAHEADER
{
    TS_SHARECONTROLHEADER   shareControlHeader;
    TS_SHAREID              shareID;
    UCHAR                   pad1;
    UCHAR                   streamID;
    USHORT                  uncompressedLength;
    UCHAR                   pduType2;                            // T.128 bug
    UCHAR                   generalCompressedType;               // T.128 bug
    USHORT                  generalCompressedLength;
    
} TS_SHAREDATAHEADER, *PTS_SHAREDATAHEADER;

#endif // _TSRV128_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\tsrvcom.h ===
//---------------------------------------------------------------------------
//
//  File:       TSrvCom.h
//
//  Contents:   TSrvCom public include file
//
//  Copyright:  (c) 1992 - 1997, Microsoft Corporation.
//              All Rights Reserved.
//              Information Contained Herein is Proprietary
//              and Confidential.
//
//  History:    17-JUL-97   BrianTa         Created.
//
//---------------------------------------------------------------------------

#ifndef _TSRVCOM_H_
#define _TSRVCOM_H_

#include <TSrvExp.h>


//
// Prototypes
//

T120Boolean 
APIENTRY 
TSrvGCCCallBack(GCCMessage *pGCCMessage);

EXTERN_C BOOL       TSrvRegisterNC(void);
EXTERN_C void       TSrvUnregisterNC(void);

#ifdef _TSRVINFO_H_

EXTERN_C NTSTATUS   TSrvBindStack(PTSRVINFO  pTSrvInfo);
EXTERN_C NTSTATUS   TSrvConfDisconnectReq(PTSRVINFO pTSrvInfo, ULONG ulReason);
EXTERN_C NTSTATUS   TSrvConfCreateResp(PTSRVINFO pTSrvInfo);
EXTERN_C NTSTATUS   TSrvValidateServerCertificate(
                              HANDLE     hStack,
                              CERT_TYPE  *pCertType,
                              PULONG     pcbServerPubKey,
                              PBYTE      *ppbServerPubKey,
                              ULONG      cbShadowRandom,
                              PBYTE      pShadowRandom,
                              LONG       ulTimeout);

EXTERN_C NTSTATUS   TSrvInitWDConnectInfo(IN HANDLE hStack,
                              IN PTSRVINFO pTSrvInfo, 
                              IN OUT PUSERDATAINFO *ppUserDataInfo,
                              IN ULONG ioctl,
                              IN PBYTE pInBuffer, 
                              IN ULONG pInBufferSize,
                              IN BOOLEAN bGetCert,
                              OUT PVOID *pSecInfo);

EXTERN_C NTSTATUS   TSrvShadowTargetConnect(HANDLE hStack, 
                              PTSRVINFO pTSrvInfo, 
                              PBYTE pModuleData,
                              ULONG cbModuleData);

EXTERN_C NTSTATUS   TSrvShadowClientConnect(HANDLE hStack, PTSRVINFO pTSrvInfo);



#endif // _TSRVINFO_H_

#endif // _TSRVCOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\tsrvmisc.c ===
//*************************************************************
//
//  File name:      TSrvMisc.c
//
//  Description:    Misc TShareSRV support routines
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1991-1997
//  All rights reserved
//
//*************************************************************

#include <TSrv.h>


// Data declarations

BOOL    g_fTSrvReady = FALSE;
BOOL    g_fTSrvTerminating = FALSE;



//*************************************************************
//
//  TSrvReady()
//
//  Purpose:    Sets the TShareSRV "ready" state
//
//  Parameters: IN [fReady]         -- TSrv ready state
//
//  Return:     void
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

void
TSrvReady(IN BOOL fReady)
{
    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvReady entry\n"));

    g_fTSrvReady = fReady;

    TRACE((DEBUG_TSHRSRV_NORMAL, "TShrSRV: TShareSRV %sready\n",
                          (g_fTSrvReady ? "" : "not ")));

    if (g_hReadyEvent)
        SetEvent(g_hReadyEvent);

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvReady exit\n"));
}


//*************************************************************
//
//  TSrvIsReady()
//
//  Purpose:    Returns the TShareSRV "ready" state
//
//  Parameters: IN [fWait]          -- Wait if not ready
//
//  Return:     TRUE                if ready
//              FALSE               if not
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

BOOL
TSrvIsReady(IN BOOL fWait)
{
    if (!g_fTSrvReady && fWait)
    {
        TRACE((DEBUG_TSHRSRV_NORMAL,
                "TShrSRV: Waiting for TShareSRV to become ready\n"));

        WaitForSingleObject(g_hReadyEvent, 60000);

        TRACE((DEBUG_TSHRSRV_NORMAL,
                "TShrSRV: Done Waiting for TShareSRV to become ready - 0x%x\n",
                g_fTSrvReady));
    }

    return (g_fTSrvReady);
}


//*************************************************************
//
//  TSrvTerminating()
//
//  Purpose:    Sets the TShareSRV "terminating" state
//
//  Parameters: IN [fTerminating]       -- TSrv ready state
//
//  Return:     void
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

void
TSrvTerminating(BOOL fTerminating)
{
    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvTerminating entry\n"));

    g_fTSrvTerminating = fTerminating;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvTerminating exit\n"));
}


//*************************************************************
//
//  TSrvIsTerminating()
//
//  Purpose:    Returns the TShareSRV "terminating" state
//
//  Parameters: void
//
//  Return:     TRUE                if terminating
//              FALSE               if not
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

BOOL
TSrvIsTerminating(void)
{
    return (g_fTSrvTerminating);
}



//*************************************************************
//
//  TSrvAllocSection()
//
//  Purpose:    Allocates and mapps a section object
//
//  Parameters: ulSize              -- Section size
//              phSection           -- ptr to section handle
//
//  Return:     Ptr to section base - if successfull
//              NULL otherwise
//
//  History:    12-17-97    BrianTa     Created
//
//*************************************************************

PVOID
TSrvAllocSection(PHANDLE phSection,
                 ULONG   ulSize)
{
    LARGE_INTEGER   SectionSize;
    LARGE_INTEGER   liOffset;
    ULONG_PTR       ulViewSize;
    NTSTATUS        ntStatus;
    PVOID           pvBase;
  
    // Create section and map it into the kernel

    pvBase = NULL;

    SectionSize.QuadPart = ulSize;

    ntStatus = NtCreateSection(phSection,
                               SECTION_ALL_ACCESS,
                               NULL,
                               &SectionSize,
                               PAGE_READWRITE,
                               SEC_COMMIT,
                               NULL);

    if (NT_SUCCESS(ntStatus))
    {
        pvBase = NULL;
        ulViewSize = ulSize;

        // Map the section into the current process and commit it

        liOffset.QuadPart = 0;

        ntStatus = NtMapViewOfSection(*phSection, 
                                      GetCurrentProcess(),
                                      &pvBase, 
                                      0, 
                                      ulViewSize,
                                      &liOffset,
                                      &ulViewSize,
                                      ViewShare,
                                      SEC_NO_CHANGE,
                                      PAGE_READWRITE);
        if (!NT_SUCCESS(ntStatus))
        {
            KdPrint(("NtMapViewOfSection failed - 0x%x\n", ntStatus));
        }
    }
    else
    {
        KdPrint(("NtCreateSection failed - 0x%x\n", ntStatus));
    }

    return (pvBase);
}



//*************************************************************
//
//  TSrvFreeSection()
//
//  Purpose:    Frees a section object
//
//  Parameters: hSection            -- Section handle
//              pvBase              -- Base section address
//
//  Return:     None
//
//  History:    12-17-97    BrianTa     Created
//
//*************************************************************

void
TSrvFreeSection(HANDLE hSection,
                PVOID  pvBase)
{
    NTSTATUS    ntStatus;

    TS_ASSERT(hSection);
    
    ntStatus = NtUnmapViewOfSection(GetCurrentProcess, pvBase);

    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = CloseHandle(hSection);

        if (NT_SUCCESS(ntStatus))
            KdPrint(("Closehandle failed - 0x%x\n", ntStatus));
    }
    else
    {
        KdPrint(("NtUnmapViewOfSection failed - 0x%x\n", ntStatus));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\tsrvcon.h ===
//---------------------------------------------------------------------------
//
//  File:       TSrvCon.h
//
//  Contents:   TSrvCon public include file
//
//  Copyright:  (c) 1992 - 1997, Microsoft Corporation.
//              All Rights Reserved.
//              Information Contained Herein is Proprietary
//              and Confidential.
//
//  History:    17-JUL-97   BrianTa         Created.
//
//---------------------------------------------------------------------------

#ifndef _TSRVCON_H_
#define _TSRVCON_H_

#include <TSrvInfo.h>


//
// Typedefs
//

// Conf connect

typedef struct _TSHARE_CONF_CONNECT
{
    GCCConferenceID     GccConfId;                  // GCC conference ID
    ULONG               pcbMaxBufferSize;           // total number of bytes in bData
    ULONG               pcbValidBytesInUserData;    // number of bytes IN USE in bData
    BYTE                bData[1];                   // opaque user data

    // User data follows

} TSHARE_CONF_CONNECT, *PTSHARE_CONF_CONNECT;


//
// Prototypes
//

EXTERN_C NTSTATUS   TSrvStackConnect(IN HANDLE hIca,
                                     IN HANDLE hStack, OUT PTSRVINFO *ppTSrvInfo);

EXTERN_C NTSTATUS   TSrvConsoleConnect(IN HANDLE hIca,
                                       IN HANDLE hStack,
                                       IN PVOID pModuleData,
                                       IN ULONG ModuleDataLength,
                                       OUT PTSRVINFO *ppTSrvInfo);


#endif // _TSRVCON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\tsrvinfo.h ===
//---------------------------------------------------------------------------
//
//  File:       TSrvInfo.h
//
//  Contents:   TSrvInfo public include file
//
//  Copyright:  (c) 1992 - 1997, Microsoft Corporation.
//              All Rights Reserved.
//              Information Contained Herein is Proprietary
//              and Confidential.
//
//  History:    17-JUL-97   BrianTa         Created.
//
//---------------------------------------------------------------------------

#ifndef _TSRVINFO_H_
#define _TSRVINFO_H_

#include <TSrvExp.h>


//
// Defines
//

#define TSRV_CONF_PENDING       0
#define TSRV_CONF_CONNECTED     1
#define TSRV_CONF_TERMINATED    2


//
// Typedefs
//

// TSrvInfo object

typedef struct _TSRVINFO
{

#if DBG
    DWORD               CheckMark;              // "TSIN"
#endif

    CRITICAL_SECTION    cs;

    DomainHandle        hDomain;
    ConnectionHandle    hConnection;
    HANDLE              hIca;
    HANDLE              hStack;

    PUSERDATAINFO       pUserDataInfo;
    HANDLE              hWorkEvent;

    LONG                RefCount;

    BOOLEAN             fDisconnect :1;
    BOOLEAN             fConsoleStack :1;

    BYTE                fuConfState;
    ULONG               ulReason;
    NTSTATUS            ntStatus;

    BOOL                bSecurityEnabled;
    SECINFO             SecurityInfo;

} TSRVINFO, *PTSRVINFO;


// Per WinStation context memory

typedef struct _WSX_CONTEXT
{

    DWORD       CheckMark;          // "TSIN"
    HANDLE      hIca;               // Ica handle
    HANDLE      hStack;             // Primary stack
    ULONG       LogonId;
    PTSRVINFO   pTSrvInfo;          // TSrvinfo ptr
    UINT        cVCAddins;          // number of VC addins
    ULONG fAutoClientDrives : 1;
    ULONG fAutoClientLpts : 1;
    ULONG fForceClientLptDef : 1;
    ULONG fDisableCpm : 1;
    ULONG fDisableCdm : 1;
    ULONG fDisableCcm : 1;
    ULONG fDisableLPT : 1;
    ULONG fDisableClip : 1;
    ULONG fDisableExe : 1;
    ULONG fDisableCam : 1;
    CRITICAL_SECTION cs;
    BOOL  fCSInitialized;

    // Array of Virtual Channel addin structures (TSRV_VC_ADDIN) follows

} WSX_CONTEXT, *PWSX_CONTEXT;


//
// Prototypes
//

EXTERN_C VOID       TSrvReferenceInfo(IN PTSRVINFO pTSrvInfo);
EXTERN_C VOID       TSrvDereferenceInfo(IN PTSRVINFO pTSrvInfo);
EXTERN_C BOOL       TSrvInitGlobalData(void);
EXTERN_C NTSTATUS   TSrvAllocInfo(OUT PTSRVINFO *ppTSrvInfo, HANDLE hIca, HANDLE hStack);
EXTERN_C void       TSrvReleaseInfoPoolList(void);
EXTERN_C void       TSrvReleaseInfoUsedList(void);
EXTERN_C PTSRVINFO  TSrvGetInfoFromStack(IN HANDLE hStack);
EXTERN_C PTSRVINFO  TSrvGetInfoFromID(GCCConferenceID conference_id);


#if DBG
void        TSrvInfoValidate(PTSRVINFO pTSrvInfo);
#else
#define     TSrvInfoValidate(x)
#endif


#endif // _TSRVINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\tsrvcon.c ===
//*************************************************************
//
//  File name:      TSrvCon.c
//
//  Description:    Contains routines to provide TShareSRV
//                  connection support
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1991-1997
//  All rights reserved
//
//*************************************************************

#define DC_HICOLOR

#include <TSrv.h>
#include <TSrvInfo.h>
#include <TSrvCom.h>
#include <TSrvTerm.h>
#include <TSrvCon.h>
#include <_TSrvCon.h>
#include <_TSrvInfo.h>
#include <TSrvSec.h>

#include <at128.h>
#include <at120ex.h>
#include <ndcgmcro.h>


//*************************************************************
//
//  TSrvDoConnectResponse()
//
//  Purpose:    Performs the conf connect process
//
//  Parameters: IN [pTSrvInfo]     - GCC CreateIndicationMessage
//
//  Return:     STATUS_SUCCESS          - Success
//              other                   - Failure
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

NTSTATUS
TSrvDoConnectResponse(IN PTSRVINFO pTSrvInfo)
{
    NTSTATUS    ntStatus;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvDoConnectResponse entry\n"));

    // Invoke routine to perform actual response

    ntStatus = TSrvConfCreateResp(pTSrvInfo);

    if (NT_SUCCESS(ntStatus))
    {
        EnterCriticalSection(&pTSrvInfo->cs);

        // If this connection was not told to terminate during the
        // connection response, then mark the conference state as
        // TSRV_GCC_CONF_CONNECTED

        if (!pTSrvInfo->fDisconnect)
            pTSrvInfo->fuConfState = TSRV_CONF_CONNECTED;

        LeaveCriticalSection(&pTSrvInfo->cs);

        // If we were unable to mark the conf state as CONNECTED, then
        // the connection needs to be terminated

        if (pTSrvInfo->fuConfState != TSRV_CONF_CONNECTED)
        {
            TRACE((DEBUG_TSHRSRV_NORMAL,
                    "TShrSRV: Connection aborted due to termination request\n"));

            ntStatus = STATUS_REQUEST_ABORTED;
        }
    }

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvDoConnectResponse exit - 0x%x\n", ntStatus));

    return (ntStatus);
}


//*************************************************************
//
//  TSrvDoConnect()
//
//  Purpose:    Initiates the conf connect process
//
//  Parameters: IN [pTSrvInfo]     - GCC CreateIndicationMessage
//
//  Return:     STATUS_SUCCESS          - Success
//              other                   - Failure
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

NTSTATUS
TSrvDoConnect(IN PTSRVINFO pTSrvInfo)
{
    DWORD       dwStatus;
    NTSTATUS    ntStatus;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvDoConnect entry\n"));

    ntStatus = STATUS_TRANSACTION_ABORTED;

    if (pTSrvInfo->fDisconnect == FALSE)
    {
        TSrvReferenceInfo(pTSrvInfo);

        // Wait to be told that a connection is being
        // requested via the client

        TRACE((DEBUG_TSHRSRV_NORMAL,
                "TShrSRV: Waiting for connection Ind signal for pTSrvInfo 0x%x\n",
                pTSrvInfo));

        dwStatus = WaitForSingleObject(pTSrvInfo->hWorkEvent, 60000);

        TRACE((DEBUG_TSHRSRV_NORMAL,
                "TShrSRV: Connection Ind signal received for pTSrvInfo %p - 0x%x\n",
                pTSrvInfo, dwStatus));

        // If a client connection request has been recieved, then proceed
        // with the acknowledgement process (CreateResponse)

        switch (dwStatus)
        {
            case WAIT_OBJECT_0:
                if (pTSrvInfo->fDisconnect == FALSE)
                    ntStatus = TSrvDoConnectResponse(pTSrvInfo);
                else
                    ntStatus = STATUS_TRANSACTION_ABORTED;
                break;

            case WAIT_TIMEOUT:
                ntStatus = STATUS_IO_TIMEOUT;
                break;
        }

        TSrvDereferenceInfo(pTSrvInfo);
    }

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvDoConnect exit - 0x%x\n", ntStatus));

    return (ntStatus);
}


//*************************************************************
//
//  TSrvStackConnect()
//
//  Purpose:    Stack initiated connect
//
//  Parameters: IN  [hIca]              - Ica handle
//              IN  [hStack]            - Ica stack
//              OUT [ppTSrvInfo]        - Ptr to TSRVINFO ptr
//
//  Return:     STATUS_SUCCESS          - Success
//              other                   - Failure
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

NTSTATUS
TSrvStackConnect(IN  HANDLE     hIca,
                 IN  HANDLE     hStack,
                 OUT PTSRVINFO *ppTSrvInfo)
{
    NTSTATUS    ntStatus;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvStackConnect entry\n"));

    ntStatus = STATUS_UNSUCCESSFUL;

    if (TSrvIsReady(TRUE))
    {
        TS_ASSERT(hStack);

        // Allocate a TSrvInfo object which will be used to
        // track this connection instance

        ntStatus = TSrvAllocInfo(ppTSrvInfo, hIca, hStack);

        if (NT_SUCCESS(ntStatus))
        {
            TS_ASSERT(*ppTSrvInfo);

            ntStatus = TSrvDoConnect(*ppTSrvInfo);
        }
    }

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvStackConnect exit - 0x%x\n", ntStatus));

    return (ntStatus);
}


//*************************************************************
//
//  TSrvConsoleConnect()
//
//  Purpose:    Connest to console session
//
//  Parameters: IN  [hIca]              - Ica handle
//              IN  [hStack]            - Ica stack
//              OUT [ppTSrvInfo]        - Ptr to TSRVINFO ptr
//
//  Return:     STATUS_SUCCESS          - Success
//              other                   - Failure
//
//  History:    11-02-98    MartinRichards (DCL) Created
//
//*************************************************************

NTSTATUS
TSrvConsoleConnect(IN  HANDLE     hIca,
                   IN  HANDLE     hStack,
                   IN  PVOID      pBuffer,
                   IN  ULONG      ulBufferLength,
                   OUT PTSRVINFO *ppTSrvInfo)
{
    NTSTATUS    ntStatus;
    PTSRVINFO   pTSrvInfo;

    int                 i;
    ULONG               ulInBufferSize;
    ULONG               ulBytesReturned;
    PRNS_UD_CS_CORE     pCoreData;

    PTSHARE_MODULE_DATA    pModuleData = (PTSHARE_MODULE_DATA) pBuffer;
    PTSHARE_MODULE_DATA_B3 pModuleDataB3 = (PTSHARE_MODULE_DATA_B3) pBuffer;

    HDC hdc;
    int screenBpp;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvConsoleConnect entry\n"));

    ntStatus = STATUS_UNSUCCESSFUL;

    if (TSrvIsReady(TRUE))
    {
        TS_ASSERT(hStack);

        // Allocate a TSrvInfo object which will be used to
        // track this connection instance
        ntStatus = STATUS_NO_MEMORY;

        // Try allocating a TSRVINFO object

        pTSrvInfo = TSrvAllocInfoNew();

        // If we managed to get a TSRVINFO object, perform
        // default base initialization

        if (pTSrvInfo)
        {
            pTSrvInfo->hDomain = NULL;
            pTSrvInfo->hIca = hIca;
            pTSrvInfo->hStack = hStack;
            pTSrvInfo->fDisconnect = FALSE;
            pTSrvInfo->fConsoleStack = TRUE;
            pTSrvInfo->fuConfState = TSRV_CONF_PENDING;
            pTSrvInfo->ulReason = 0;
            pTSrvInfo->ntStatus = STATUS_SUCCESS;
            pTSrvInfo->bSecurityEnabled = FALSE;
            pTSrvInfo->SecurityInfo.CertType = CERT_TYPE_INVALID;

            /****************************************************************/
            /* Build the User data portion (remember that there is not      */
            /* actually a real client to connect; instead we need to pass   */
            /* in the relevant information about the console session)       */
            /****************************************************************/
            ulInBufferSize = sizeof(USERDATAINFO) + sizeof(RNS_UD_CS_CORE);
            pTSrvInfo->pUserDataInfo = TSHeapAlloc(0, ulInBufferSize,
                                                    TS_HTAG_TSS_USERDATA_OUT);
            if (pTSrvInfo->pUserDataInfo == NULL)
            {
                TRACE((DEBUG_TSHRSRV_ERROR,
                      "TShrSRV: Failed to get user data memory\n"));
                ntStatus = STATUS_NO_MEMORY;
                goto Cleanup;
            }
            pTSrvInfo->pUserDataInfo->cbSize  = sizeof(USERDATAINFO)
                                                     + sizeof(RNS_UD_CS_CORE);
            pTSrvInfo->pUserDataInfo->version = RNS_UD_VERSION;
            pTSrvInfo->pUserDataInfo->hDomain = NULL;

            pTSrvInfo->pUserDataInfo->ulUserDataMembers = 1;

            pCoreData = (PRNS_UD_CS_CORE)(pTSrvInfo->pUserDataInfo->rgUserData);

            pCoreData->header.type   = RNS_UD_CS_CORE_ID;
            pCoreData->header.length = sizeof(RNS_UD_CS_CORE);
            pCoreData->version       = RNS_UD_VERSION;

            pCoreData->desktopWidth  =
                               (TSUINT16)GetSystemMetrics(SM_CXVIRTUALSCREEN);
            pCoreData->desktopHeight =
                               (TSUINT16)GetSystemMetrics(SM_CYVIRTUALSCREEN);



            //
            // The fields colorDepth and supportedColorDepths of pCoreData are
            // used as temporary variables. The correct values are set before 
            // sending the Ioctl below.
            //
            pCoreData->colorDepth = 0;
            pCoreData->supportedColorDepths = 0;

            //
            // Get the color depth and capabilities from the remote client.
            //

            // B3 and B3_oops! servers used a fixed length user data structure
            if ( (ulBufferLength == sizeof(TSHARE_MODULE_DATA_B3)) ||
                 (ulBufferLength == sizeof(TSHARE_MODULE_DATA_B3_OOPS)) ) {

                pCoreData->colorDepth = pModuleDataB3->clientCoreData.colorDepth;

            } else if ( (ulBufferLength >= sizeof(TSHARE_MODULE_DATA)) &&
                        (ulBufferLength == (sizeof(TSHARE_MODULE_DATA) +
                     pModuleData->userDataLen - sizeof(RNS_UD_HEADER))) ) {

                PRNS_UD_HEADER pHeader;
                PRNS_UD_HEADER pEnd;
                PRNS_UD_CS_CORE pClientCoreData;

                pHeader = (PRNS_UD_HEADER) &pModuleData->userData;
                pEnd = (PRNS_UD_HEADER)((PBYTE)pHeader + pModuleData->userDataLen);

                // Loop through user data, extracting each piece.
                do {
                    if ( pHeader->type == RNS_UD_CS_CORE_ID ) {
                        pClientCoreData = (PRNS_UD_CS_CORE)pHeader;

                        pCoreData->colorDepth = pClientCoreData->colorDepth;

                        if (pClientCoreData->header.length >=
                                (FIELDOFFSET(RNS_UD_CS_CORE, supportedColorDepths) +
                                 FIELDSIZE(RNS_UD_CS_CORE, supportedColorDepths))) {

                            pCoreData->supportedColorDepths = pClientCoreData->supportedColorDepths;
                        }
                        break;
                    } 

                    // don't get stuck here for ever...
                    if (pHeader->length == 0) {
                        break;
                    }

                    // Move on to the next user data string.
                    pHeader = (PRNS_UD_HEADER)((PBYTE)pHeader + pHeader->length);
                } while (pHeader < pEnd);
            }


            switch (pCoreData->colorDepth) {
                case RNS_UD_COLOR_24BPP:
                    pCoreData->highColorDepth = 24;
                    break;

                case RNS_UD_COLOR_16BPP_565:
                    pCoreData->highColorDepth = 16;
                    break;

                case RNS_UD_COLOR_16BPP_555:
                    pCoreData->highColorDepth = 15;
                    break;

                case RNS_UD_COLOR_8BPP:
                    pCoreData->highColorDepth = 8;
                    break;

                case RNS_UD_COLOR_4BPP:
                    pCoreData->highColorDepth = 4;
                    break;

                default:
                    pCoreData->highColorDepth = 0;
                    break;
            }

#ifdef DC_HICOLOR
            /****************************************************************/
            /* setup color depth based on the screen capabilities           */
            /****************************************************************/

            hdc = GetDC(NULL);

            if (hdc) {

                screenBpp = GetDeviceCaps(hdc, BITSPIXEL);
                ReleaseDC(NULL, hdc);

                // Avoid bad colors when device bitmaps is enabled and if the
                // client connects at 15bpp and the console is at 16bpp.
                if ((screenBpp == 16) &&
                    (pCoreData->colorDepth == RNS_UD_COLOR_16BPP_555) &&
                    (pCoreData->supportedColorDepths & RNS_UD_16BPP_SUPPORT))
                {

                    pCoreData->colorDepth = RNS_UD_COLOR_16BPP_565;
                    pCoreData->highColorDepth = 16;

                } else
                // see if the ColorDepth is valid
                if( !((pCoreData->colorDepth == RNS_UD_COLOR_24BPP) ||
                      (pCoreData->colorDepth == RNS_UD_COLOR_16BPP_565) ||
                      (pCoreData->colorDepth == RNS_UD_COLOR_16BPP_555) ||
                      (pCoreData->colorDepth == RNS_UD_COLOR_8BPP) ||
                      (pCoreData->colorDepth == RNS_UD_COLOR_4BPP)) )
                {

                    pCoreData->highColorDepth = (TSUINT16)screenBpp;

                    if (screenBpp >= 24)
                    {
                        pCoreData->colorDepth = RNS_UD_COLOR_24BPP;
                        pCoreData->highColorDepth = 24;
                    }
                    else if (screenBpp == 16)
                    {
                        pCoreData->colorDepth = RNS_UD_COLOR_16BPP_565;
                    }
                    else if (screenBpp == 15)
                    {
                        pCoreData->colorDepth = RNS_UD_COLOR_16BPP_555;
                    }
                    else
                    {
                        pCoreData->colorDepth = RNS_UD_COLOR_8BPP;
                        pCoreData->highColorDepth = 8;
                    }
                }
                TRACE((DEBUG_TSHRSRV_NORMAL,
                      "TShrSRV: TSrvConsoleConnect at %d bpp\n", screenBpp));
            }
#endif

            // set new high color fields
            pCoreData->supportedColorDepths = (TSUINT16)( RNS_UD_24BPP_SUPPORT ||
                                                          RNS_UD_16BPP_SUPPORT ||
                                                          RNS_UD_15BPP_SUPPORT);

            // Pass the data to WDTShare

            ulBytesReturned = 0;
            ntStatus = IcaStackIoControl(pTSrvInfo->hStack,
                                         IOCTL_TSHARE_CONSOLE_CONNECT,
                                         pTSrvInfo->pUserDataInfo,
                                         ulInBufferSize,
                                         NULL,
                                         0,
                                         &ulBytesReturned);


        Cleanup:
            TRACE((DEBUG_TSHRSRV_FLOW,
                    "TShrSRV: TSrvConsoleConnect exit - 0x%x\n", ntStatus));

            pTSrvInfo->ntStatus = ntStatus;

            if (NT_SUCCESS(ntStatus))
            {
                EnterCriticalSection(&pTSrvInfo->cs);

                // If this connection was not told to terminate during the
                // connection response, then mark the conference state as
                // TSRV_GCC_CONF_CONNECTED

                if (!pTSrvInfo->fDisconnect)
                    pTSrvInfo->fuConfState = TSRV_CONF_CONNECTED;

                LeaveCriticalSection(&pTSrvInfo->cs);

                // If we were unable to mark the conf state as CONNECTED, then
                // the connection needs to be terminated

                if (pTSrvInfo->fuConfState != TSRV_CONF_CONNECTED)
                {
                    TRACE((DEBUG_TSHRSRV_NORMAL,
                        "TShrSRV: Connection aborted due to term request\n"));
                    ntStatus = STATUS_REQUEST_ABORTED;
                }

            }
            if (!NT_SUCCESS(ntStatus))
            {
                TSrvDereferenceInfo(pTSrvInfo);

                pTSrvInfo = NULL;
            }
        }

    }

    if (NT_SUCCESS(ntStatus))
    {
        *ppTSrvInfo = pTSrvInfo;
    }

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvConsoleConnect exit - 0x%x\n", ntStatus));

    return (ntStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\rdpwsx\rdpex\tsrvcom.c ===
/****************************************************************************/
// tsrvcom.c
//
// RDPWSX routines for lower-layer (GCC, RDPWD) communications support
//
// Copyright (C) 1991-2000 Microsoft Corporation
/****************************************************************************/

#include <TSrv.h>

#include <TSrvCom.h>
#include <TSrvInfo.h>
#include <_TSrvInfo.h>
#include <_TSrvCom.h>
#include <TSrvSec.h>
#include <licecert.h>


// Data declarations
ULONG g_GCCAppID = 0;
BOOL  g_fGCCRegistered = FALSE;


//*************************************************************
//
//  TSrvValidateServerCertificate()
//
//  Purpose:    Validate the certificate received from the shadow
//              client's server is legit.  Note that this function
//              is very similar to certificate validation by the
//              client.
//
//  Return:     STATUS_SUCCESS          - Success
//              other                   - Failure
//
//  History:    4/26/99    jparsons     Created
//
//*************************************************************
NTSTATUS
TSrvValidateServerCertificate(HANDLE    hStack,
                              CERT_TYPE *pCertType,
                              PULONG    pcbServerPubKey,
                              PBYTE     *ppbServerPubKey,
                              ULONG     cbShadowRandom,
                              PBYTE     pShadowRandom,
                              LONG      ulTimeout)
{
    ULONG           ulCertVersion;
    NTSTATUS        status;
    PSHADOWCERT     pShadowCert = NULL;
    PBYTE           pbNetCert;
    PBYTE           pbNetRandom;
    ULONG           ulBytesReturned;
    SECURITYTIMEOUT securityTimeout;

    *pcbServerPubKey = 0;
    *ppbServerPubKey = NULL;
    *pCertType = CERT_TYPE_INVALID;
    securityTimeout.ulTimeout = ulTimeout;

    // Wait for the shadow server certificate to arrive and determine how
    // much memory to allocate.  Note that one potential outcome is that the
    // other server is not encrypting and thus sends no certificate
    TRACE((DEBUG_TSHRSRV_NORMAL,
           "TShrSRV: Waiting to receive server certificate: msec=%ld\n", ulTimeout));

    status = IcaStackIoControl(hStack,
                               IOCTL_TSHARE_GET_CERT_DATA,
                               &securityTimeout, sizeof(securityTimeout),
                               NULL,
                               0,
                               &ulBytesReturned);

    if (status == STATUS_BUFFER_TOO_SMALL) {
        ULONG ulBytesNeeded = ulBytesReturned;

        TRACE((DEBUG_TSHRSRV_NORMAL,
               "TShrSRV: Need %ld bytes for certificate\n", ulBytesNeeded));
        pShadowCert = TSHeapAlloc(0, ulBytesNeeded, TS_HTAG_TSS_CERTIFICATE);

        if (pShadowCert != NULL) {
            memset(pShadowCert, 0, sizeof(PSHADOWCERT));
            pShadowCert->encryptionMethod = 0xffffffff;
            status = IcaStackIoControl(hStack,
                                       IOCTL_TSHARE_GET_CERT_DATA,
                                       &securityTimeout, sizeof(securityTimeout),
                                       pShadowCert,
                                       ulBytesNeeded,
                                       &ulBytesReturned);

            // calculate pointers to embedded data (if any)
            if (status == STATUS_SUCCESS) {
                TRACE((DEBUG_TSHRSRV_ERROR, "TShrSRV: Received random [%ld], Certificate [%ld]\n",
                        pShadowCert->shadowRandomLen, pShadowCert->shadowCertLen));

                if (pShadowCert->encryptionLevel != 0) {
                    pbNetRandom = pShadowCert->data;
                    pbNetCert = pbNetRandom + pShadowCert->shadowRandomLen;

                    // Save off the server random to establish session keys later
                    if (pShadowCert->shadowRandomLen == RANDOM_KEY_LENGTH) {
                        memcpy(pShadowRandom, pbNetRandom, pShadowCert->shadowRandomLen);
                    }
                    else {
                        memset(pShadowRandom, 0, RANDOM_KEY_LENGTH);
                        TRACE((DEBUG_TSHRSRV_ERROR,
                               "TShrSRV: Invalid shadow random key length: %ld\n",
                               pShadowCert->shadowRandomLen));
                        status = STATUS_INVALID_PARAMETER;
                    }
                }

                // else there is no encryption so we're done!
                else {
                    TRACE((DEBUG_TSHRSRV_NORMAL, "TShrSRV: Encryption is disabled\n"));
                    return STATUS_SUCCESS;
                }
            }
            else {
                TRACE((DEBUG_TSHRSRV_ERROR,
                       "TShrSRV: IOCTL_TSHARE_GET_CERT_DATA failed: rc=%lx\n",
                       status));
            }
        }
        else {
            TRACE((DEBUG_TSHRSRV_ERROR,
                   "TShrSRV: Could not allocate memory to validate shadow certificate\n"))
            status = STATUS_NO_MEMORY;
        }
    }

    // The other server returned a certificate, so validate it
    if (status == STATUS_SUCCESS && pShadowCert != NULL) {
        ULONG cbNetCert = pShadowCert->shadowCertLen;

        memcpy(&ulCertVersion, pbNetCert, sizeof(ULONG));

        // assume certificate validation is going to fail ;-(
        status = STATUS_LICENSE_VIOLATION;

        //
        // decode and validate proprietory certificate.
        //
        if( CERT_CHAIN_VERSION_2 > GET_CERTIFICATE_VERSION(ulCertVersion)) {
            Hydra_Server_Cert serverCertificate;
            *pCertType = CERT_TYPE_PROPRIETORY;

            // Unpack and validate the legacy certificate
            if (UnpackServerCert(pbNetCert, cbNetCert, &serverCertificate)) {
                if (ValidateServerCert(&serverCertificate)) {
                    *ppbServerPubKey = TSHeapAlloc(
                                        HEAP_ZERO_MEMORY,
                                        serverCertificate.PublicKeyData.wBlobLen,
                                        TS_HTAG_TSS_PUBKEY);

                    // Copy the public key from inside the proprietary blob!
                    if (*ppbServerPubKey != NULL) {
                        memcpy(*ppbServerPubKey,
                               serverCertificate.PublicKeyData.pBlob,
                               serverCertificate.PublicKeyData.wBlobLen);
                        *pcbServerPubKey = serverCertificate.PublicKeyData.wBlobLen;
                        status = STATUS_SUCCESS;
                    }
                    else {
                        status = STATUS_NO_MEMORY;
                        TRACE((DEBUG_TSHRSRV_ERROR,
                               "TShrSRV: Failed to allocate %u bytes for server public key\n",
                                *pcbServerPubKey)) ;
                    }
                }
                else {
                    TRACE((DEBUG_TSHRSRV_ERROR,
                           "TShrSRV: Invalid proprietary server certificate received\n"));
                }
            }
            else {
                TRACE((DEBUG_TSHRSRV_ERROR,
                       "TShrSRV: Failed to unpack proprietary server certificate\n")) ;
            }
        }

        //
        // decode X509 certificate and extract public key
        //
        else if( MAX_CERT_CHAIN_VERSION >= GET_CERTIFICATE_VERSION(ulCertVersion)) {
            ULONG fDates = CERT_DATE_DONT_VALIDATE;
            LICENSE_STATUS licStatus;

            *pCertType = CERT_TYPE_X509;
            *ppbServerPubKey = NULL;

            // Determine the length of the public key.  Note that this stinking
            // function is not multi-thread safe!
            TRACE((DEBUG_TSHRSRV_ERROR,
                   "TShrSRV: X.509 server certificate length: %ld\n",
                   cbNetCert)) ;

            // Watch out! X509 routines are not thread safe.
            EnterCriticalSection( &g_TSrvCritSect );
            licStatus = VerifyCertChain(pbNetCert, cbNetCert, NULL,
                                        pcbServerPubKey, &fDates);
            LeaveCriticalSection( &g_TSrvCritSect );

            if( LICENSE_STATUS_INSUFFICIENT_BUFFER == licStatus )
            {
                *ppbServerPubKey = TSHeapAlloc(HEAP_ZERO_MEMORY, *pcbServerPubKey,
                                         TS_HTAG_TSS_PUBKEY);

                if (*ppbServerPubKey != NULL) {
                    EnterCriticalSection( &g_TSrvCritSect );
                    licStatus = VerifyCertChain(pbNetCert, cbNetCert,
                                                *ppbServerPubKey, pcbServerPubKey,
                                                &fDates);
                    LeaveCriticalSection( &g_TSrvCritSect );

                    if (LICENSE_STATUS_OK == licStatus) {
                        status = STATUS_SUCCESS;
                    }
                    else {
                        TRACE((DEBUG_TSHRSRV_ERROR,
                               "TShrSRV: Failed to verify X.509 server certificate: %ld\n",
                               licStatus)) ;

                        // torch the server public key memory
                        TSHeapFree(*ppbServerPubKey);
                        *ppbServerPubKey = NULL;
                    }
                }
                else {
                    status = STATUS_NO_MEMORY;
                    TRACE((DEBUG_TSHRSRV_ERROR,
                           "TShrSRV: Failed to allocate %u bytes for server public key\n",
                            *pcbServerPubKey)) ;
                }
            }
            else {
                TRACE((DEBUG_TSHRSRV_ERROR,
                       "TShrSRV: Could not decode X.509 server public key length: %d\n",
                       licStatus )) ;
            }
        }

        //
        // don't know how to decode this version of certificate
        //
        else {
            status = LICENSE_STATUS_UNSUPPORTED_VERSION;
            TRACE((DEBUG_TSHRSRV_ERROR,"TShrSRV: Invalid certificate version: %ld\n",
                   GET_CERTIFICATE_VERSION(ulCertVersion))) ;
        }
    }

    // Something messed up!
    else {
        // Treat a timeout as fatal.
        if (status == STATUS_TIMEOUT)
            status = STATUS_IO_TIMEOUT;

        TRACE((DEBUG_TSHRSRV_ERROR,
               "TShrSRV: Failed to retrieve shadow server cerfificate, rc=%lx, "
               "pShadowCert=%p\n", status, pShadowCert));
    }

    if (pShadowCert != NULL)
        TSHeapFree(pShadowCert);

    return status;
}


//*************************************************************
//
//  TSrvCalculateUserDataSize()
//
//  Purpose:    Calculates the amount of user data passed in
//              the pCreateMessage message
//
//  Parameters: IN [pCreateMessage]     - GCC CreateIndicationMessage
//
//  Return:     User data size (bytes)
//
//  Notes:      Function trucks it's way through the GCC user_data_list
//              structure summing up the amount of user data supplied
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

ULONG
TSrvCalculateUserDataSize(IN CreateIndicationMessage *pCreateMessage)
{
    int             i;
    ULONG           ulUserDataSize;
    GCCUserData    *pClientUserData;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvCalculateUserDataSize entry\n"));

    ulUserDataSize = 0;

    TSrvDumpUserData(pCreateMessage);

    for (i=0; i<pCreateMessage->number_of_user_data_members; i++)
    {
        pClientUserData = pCreateMessage->user_data_list[i];

        if (pClientUserData != NULL)
        {
            // Calcu KEY size

            if (pClientUserData->key.key_type == GCC_OBJECT_KEY)
            {
                ulUserDataSize += (sizeof(ULONG) *
                        pClientUserData->key.u.object_id.long_string_length);
            }
            else
            {
                ulUserDataSize += (sizeof(UCHAR) *
                        pClientUserData->key.u.h221_non_standard_id.octet_string_length);
            }

            // Calc client size

            if (pClientUserData->octet_string)
            {
                // Allow for the extra indirection

                ulUserDataSize += sizeof(*(pClientUserData->octet_string));

                // Allow for the actual data

                ulUserDataSize += (sizeof(UCHAR) *
                        pClientUserData->octet_string->octet_string_length);
            }
        }
    }

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvCalculateUserDataSize exit - 0x%x\n", ulUserDataSize));

    return (ulUserDataSize);
}


//*************************************************************
//
//  TSrvSaveUserDataMember()
//
//  Purpose:    Saves off the provided userData member
//
//  Parameters: IN     [pInUserData]        - Source userData
//              OUT    [pOutUserData]       - Destination userData
//              IN OUT [pulUserDataOffset]  - Re-base offset
//
//  Return:     void
//
//  Notes:      This routine copies the src user data into the
//              destination user data, re-basing all the dest
//              user data ptrs to the provided pulUserDataOffset
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************

void
TSrvSaveUserDataMember(IN     GCCUserData   *pInUserData,
                       OUT    GCCUserData   *pOutUserData,
                       IN     PUSERDATAINFO  pUserDataInfo,
                       IN OUT PULONG         pulUserDataOffset)
{
    ULONG           ulUserDataSize;
    GCCOctetString  UNALIGNED *pOctetString;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvSaveUserDataMember entry\n"));

    *pOutUserData = *pInUserData;

    // Key data and length

    if (pInUserData->key.key_type == GCC_OBJECT_KEY)
    {
        pOutUserData->key.u.object_id.long_string =
                (PULONG FAR)ULongToPtr((*pulUserDataOffset));

        ulUserDataSize =
                pOutUserData->key.u.object_id.long_string_length * sizeof(ULONG);

        memcpy((PCHAR) pUserDataInfo + *pulUserDataOffset,
                pInUserData->key.u.object_id.long_string,
                ulUserDataSize);
    }
    else
    {
        pOutUserData->key.u.h221_non_standard_id.octet_string =
                (PUCHAR FAR)ULongToPtr((*pulUserDataOffset));

        ulUserDataSize =
                pInUserData->key.u.h221_non_standard_id.octet_string_length * sizeof(UCHAR);

        memcpy((PCHAR) pUserDataInfo + *pulUserDataOffset,
                pInUserData->key.u.h221_non_standard_id.octet_string,
                ulUserDataSize);
    }

    *pulUserDataOffset += ulUserDataSize;

    // Client data ptr, length, and data

    if (pInUserData->octet_string &&
        pInUserData->octet_string->octet_string)
    {
        // Data ptr

        pOutUserData->octet_string = (GCCOctetString *)ULongToPtr((*pulUserDataOffset));

        pOctetString = (GCCOctetString *)
                ((PUCHAR) pOutUserData->octet_string +
                (ULONG_PTR)pUserDataInfo);

        *pulUserDataOffset += sizeof(*(pInUserData->octet_string));

        // Data length

        pOctetString->octet_string_length =
                pInUserData->octet_string->octet_string_length;

        pOctetString->octet_string = (unsigned char FAR *)ULongToPtr((*pulUserDataOffset));

        ulUserDataSize =
                pInUserData->octet_string->octet_string_length * sizeof(UCHAR);

        // Data

        memcpy((PCHAR) pUserDataInfo + *pulUserDataOffset,
                pInUserData->octet_string->octet_string,
                ulUserDataSize);

        *pulUserDataOffset += ulUserDataSize;
    }

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvSaveUserDataMember exit\n"));
}


//*************************************************************
//
//  TSrvSaveUserData()
//
//  Purpose:    Saves off the provided userData
//
//  Parameters: IN [pTSrvInfo]          - TSrvInfo object
//              IN [pCreateMessage]     - CreateIndicationMessage
//
//  Return:     STATUS_SUCCESS          - Success
//              STATUS_NO_MEMORY        - Failure
//
//  Notes:      This routine makes a new copy of the userdata
//              provided by the GCC CreateIndicationMessage
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************
NTSTATUS
TSrvSaveUserData(IN PTSRVINFO                pTSrvInfo,
                 IN CreateIndicationMessage *pCreateMessage)
{
    DWORD                 i;
    ULONG               ulUserDataInfoSize;
    ULONG               ulUserDataOffset;
    ULONG               ulUserDataSize;
    PUSERDATAINFO       pUserDataInfo;
    NTSTATUS            ntStatus;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvSaveUserData entry\n"));

    ntStatus = STATUS_NO_MEMORY;

    // Calculate the size of the USERDATAINFO control structure and the
    // size of the data buffer needed to hold the GCC UserData
    ulUserDataInfoSize = sizeof(USERDATAINFO) +
                         sizeof(GCCUserData) * pCreateMessage->number_of_user_data_members;
    ulUserDataSize = TSrvCalculateUserDataSize(pCreateMessage);

    pUserDataInfo = TSHeapAlloc(HEAP_ZERO_MEMORY,
                                ulUserDataInfoSize + ulUserDataSize,
                                TS_HTAG_TSS_USERDATA_IN);

    TS_ASSERT(pTSrvInfo->pUserDataInfo == NULL);
    pTSrvInfo->pUserDataInfo = pUserDataInfo;

    // If we can allocate enough memory to do the copy, then loop through
    // each member saving the associated userdata
    if (pUserDataInfo)
    {
        TRACE((DEBUG_TSHRSRV_DETAIL, "TShrSRV: Allocated 0x%x bytes for UserData save space\n",
                ulUserDataInfoSize + ulUserDataSize));

        pUserDataInfo->cbSize = ulUserDataInfoSize + ulUserDataSize;

        pUserDataInfo->hDomain = pTSrvInfo->hDomain;
        pUserDataInfo->ulUserDataMembers = pCreateMessage->number_of_user_data_members;

        ulUserDataOffset = ulUserDataInfoSize;

        TRACE((DEBUG_TSHRSRV_DETAIL, "TShrSRV: Saving each UserDataMenber to save space\n"));

        for (i=0; i<pUserDataInfo->ulUserDataMembers; i++)
        {
            TSrvSaveUserDataMember(pCreateMessage->user_data_list[i],
                                   &pUserDataInfo->rgUserData[i],
                                   pUserDataInfo,
                                   &ulUserDataOffset);
        }

        TS_ASSERT(ulUserDataOffset <= ulUserDataInfoSize + ulUserDataSize);

        ntStatus = STATUS_SUCCESS;
    }
    else
    {
        TRACE((DEBUG_TSHRSRV_WARN, "TShrSRV: Can't allocate 0x%x for userData save space\n",
                ulUserDataInfoSize + ulUserDataSize));
    }

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvSaveUserData exit - 0x%x\n", ntStatus));

    return (ntStatus);
}


//*************************************************************
//
//  TSrvSignalIndication()
//
//  Purpose:    Signals the worker thread
//
//  Parameters: IN [pTSrvInfo]          - TSrvInfo object
//              IN [ntStatus]           - Signaling status
//
//  Return:     void
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************
void
TSrvSignalIndication(IN PTSRVINFO  pTSrvInfo,
                     IN NTSTATUS   ntStatus)
{
    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvSignalIndication entry\n"));

    TS_ASSERT(pTSrvInfo->hWorkEvent);

    TRACE((DEBUG_TSHRSRV_DEBUG, "TShrSRV: Signaling workEvent %p, status 0x%x\n",
            pTSrvInfo->hWorkEvent, ntStatus));

    pTSrvInfo->ntStatus = ntStatus;

    if (!SetEvent(pTSrvInfo->hWorkEvent))
    {
        TRACE((DEBUG_TSHRSRV_DEBUG, "TShrSRV: Cannot Signal workEvent %p, gle 0x%x\n",
            pTSrvInfo->hWorkEvent, GetLastError()));

        ASSERT(0);
    }

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvSignalIndication exit\n"));
}


//*************************************************************
//
//  TSrvHandleCreateInd()
//
//  Purpose:    Handles GCC Gcc_Create_Indication
//
//  Parameters: IN [pCreateInd]         - CreateIndicationMessage
//
//  Return:     void
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************
void
TSrvHandleCreateInd(IN PTSRVINFO                pTSrvInfo,
                    IN CreateIndicationMessage *pCreateInd)
{
    NTSTATUS ntStatus;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvHandleCreateInd entry\n"));

    // Reject the conference if we are not allowed to accept any new calls
    if (TSrvIsReady(FALSE))
    {
        TRACE((DEBUG_TSHRSRV_NORMAL,
                "TShrSRV: Accepting create indication - Domain %p\n",
                pTSrvInfo->hDomain));

        TSrvDumpCreateIndDetails(pCreateInd);

        pTSrvInfo->hConnection = pCreateInd->connection_handle;

        // Save off UserData

        TRACE((DEBUG_TSHRSRV_DETAIL,
                "TShrSRV: Attempting to save CreateInd userData\n"));

        ntStatus = TSrvSaveUserData(pTSrvInfo, pCreateInd);

        TRACE((DEBUG_TSHRSRV_DETAIL,
                "TShrSRV: Save userData was%s successful\n",
                (ntStatus == STATUS_SUCCESS ? "" : " not")));
    }
    else
    {
        TRACE((DEBUG_TSHRSRV_NORMAL,
                "TShrSRV: Rejecting create indication - Domain %p\n",
                pTSrvInfo->hDomain));

        ntStatus = STATUS_DEVICE_NOT_READY;
    }

    // Signal completion, and pass along the completion status

    TSrvSignalIndication(pTSrvInfo, ntStatus);

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvHandleCreateInd exit\n"));
}


//*************************************************************
//
//  TSrvHandleTerminateInd()
//
//  Purpose:    Handles GCC Gcc_Terminate_Ind
//
//  Parameters: IN [pTermInd]           - TerminateIndicationMessage
//
//  Return:     void
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************
void
TSrvHandleTerminateInd(IN PTSRVINFO                   pTSrvInfo,
                       IN TerminateIndicationMessage *pTermInd)
{
    BYTE        fuConfState;
    GCCError    GCCrc;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvHandleTerminateInd entry\n"));

    TRACE((DEBUG_TSHRSRV_DETAIL,
            "TShrSRV: Domain %p\n", pTSrvInfo->hDomain));

    TSrvDumpGCCReasonDetails(pTermInd->reason,
            "GCCTerminateConfirm");

    TSrvReferenceInfo(pTSrvInfo);

    EnterCriticalSection(&pTSrvInfo->cs);

    // If the disconnect was not requested (client, network) then disconnect the
    // connection, flag the status, and wait for ICASRV to ping us via the normal
    // termination mechanism.

    if (!pTSrvInfo->fDisconnect)
    {
        fuConfState = pTSrvInfo->fuConfState;

        pTSrvInfo->fDisconnect = TRUE;
        pTSrvInfo->ulReason = GCC_REASON_USER_INITIATED;
        pTSrvInfo->fuConfState = TSRV_CONF_TERMINATED;

        GCCrc = GCCConferenceTerminateRequest(pTSrvInfo->hIca, NULL,
                            pTSrvInfo->hConnection, pTSrvInfo->ulReason);

        TSrvDumpGCCRCDetails(GCCrc,
                "GCCConferenceTerminateRequest");

        pTSrvInfo->hConnection = NULL;

        if (fuConfState == TSRV_CONF_PENDING)
            TSrvSignalIndication(pTSrvInfo, STATUS_SUCCESS);
    }

    LeaveCriticalSection(&pTSrvInfo->cs);

    TSrvDereferenceInfo(pTSrvInfo);

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvHandleTerminateInd exit\n"));
}


//*************************************************************
//
//  TSrvHandleDisconnectInd()
//
//  Purpose:    Handles GCC Gcc_Disconnect_Ind
//
//  Parameters: IN [pDiscInd]           - DisconnectIndicationMessage
//
//  Return:     void
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************
void
TSrvHandleDisconnectInd(IN PTSRVINFO                    pTSrvInfo,
                        IN DisconnectIndicationMessage *pDiscInd)
{
    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvHandleDisconnectInd entry\n"));

    TRACE((DEBUG_TSHRSRV_DETAIL,
            "TShrSRV: Domain = 0x%x\n", pTSrvInfo->hDomain));

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvHandleDisconnectInd exit\n"));
}


//*************************************************************
//
//  TSrvGCCCallBack()
//
//  Purpose:    Handles GCC Callback messages
//
//  Parameters: IN [pDiscInd]           - DisconnectIndicationMessage
//
//  Return:     GCC_CALLBACK_PROCESSED
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************
T120Boolean
APIENTRY
TSrvGCCCallBack(IN GCCMessage *pGCCMessage)
{
    PTSRVINFO   pTSrvInfo;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvGCCCallBack entry\n"));

    TSrvDumpCallBackMessage(pGCCMessage);

    pTSrvInfo = pGCCMessage->user_defined;

    TSrvInfoValidate(pTSrvInfo);

    if (pTSrvInfo)
    {
        switch (pGCCMessage->message_type)
        {
            case GCC_CREATE_INDICATION:
                TSrvHandleCreateInd(pTSrvInfo, &(pGCCMessage->u.create_indication));
                break;

            case GCC_DISCONNECT_INDICATION:
                TSrvHandleDisconnectInd(pTSrvInfo, &(pGCCMessage->u.disconnect_indication));
                break;

            case GCC_TERMINATE_INDICATION:
                TSrvHandleTerminateInd(pTSrvInfo, &(pGCCMessage->u.terminate_indication));
                break;
        }
    }

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvGCCCallBack exit - GCC_CALLBACK_PROCESSED\n"));

    return (GCC_CALLBACK_PROCESSED);
}


//*************************************************************
//
//  TSrvRegisterNC()
//
//  Purpose:    Registers TShareSrv as Node Comtroller
//
//  Parameters: void
//
//  Return:     TRUE                    - Success
//              FALSE                   - Failure
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************
BOOL
TSrvRegisterNC(void)
{
    USHORT              usCapMask;
    USHORT              usInitFlags;
    GCCVersion          gccVersion;
    GCCVersion          highVersion;
    GCCVersion          versionRequested;
    GCCError            GCCrc;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvRegisterNC entry\n"));

    usInitFlags = 0xffff;
    usCapMask   = 0xffff;

    versionRequested.major_version = 1;
    versionRequested.minor_version = 0;

    TRACE((DEBUG_TSHRSRV_NORMAL, "TShrSRV: Registering Node Controller\n"));

    GCCrc = GCCRegisterNodeControllerApplication(TSrvGCCCallBack,
                                                 NULL,
                                                 versionRequested,
                                                 &usInitFlags,
                                                 &g_GCCAppID,
                                                 &usCapMask,
                                                 &highVersion,
                                                 &gccVersion);

    g_fGCCRegistered = (GCCrc == GCC_NO_ERROR);

    if (g_fGCCRegistered)
    {
        TRACE((DEBUG_TSHRSRV_DETAIL,
                "TShrSRV: RegNC - usInitFlags 0x%x, AppID 0x%x, capMask 0x%x\n",
                 usInitFlags, g_GCCAppID, usCapMask));

        TRACE((DEBUG_TSHRSRV_DETAIL,
                "TShrSRV: RegNC - High Version (major %d, minor %d)\n",
                 highVersion.major_version,
                 highVersion.minor_version));

        TRACE((DEBUG_TSHRSRV_DETAIL,
                "TShrSRV: RegNC - Version (major %d, minor %d)\n",
                 gccVersion.major_version,
                 gccVersion.minor_version));
    }

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvRegisterNC exit - 0x%x\n", g_fGCCRegistered));

    return (g_fGCCRegistered);
}


//*************************************************************
//
//  TSrvUnregisterNC()
//
//  Purpose:    Unregisters TShareSrv as Node Controller
//
//  Parameters: void
//
//  Return:     void
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************
void
TSrvUnregisterNC(void)
{
    GCCError    GCCrc;

    TRACE((DEBUG_TSHRSRV_FLOW, "TShrSRV: TSrvUnregisterNC entry\n"));

    if (g_fGCCRegistered)
    {
        TRACE((DEBUG_TSHRSRV_NORMAL, "TShrSRV: Performing GCCCleanup\n"));

        GCCrc = GCCCleanup(g_GCCAppID);

        g_fGCCRegistered = FALSE;

        TSrvDumpGCCRCDetails(GCCrc, "TShrSRV: GCCCleanup\n");
    }

    TRACE((DEBUG_TSHRSRV_FLOW, "TShrSRV: TSrvUnregisterNC exit\n"));
}



//*************************************************************
//
//  TSrvBindStack()
//
//  Purpose:    Initiates MCSMux stack association
//
//  Parameters: IN [pTSrvInfo]          - TShareSrv object
//
//  Return:     void
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************
NTSTATUS
TSrvBindStack(IN PTSRVINFO pTSrvInfo)
{
    NTSTATUS    ntStatus;
    GCCError    GCCrc;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvBindStack entry\n"));

    TS_ASSERT(pTSrvInfo);
    TS_ASSERT(pTSrvInfo->hStack);

    TRACE((DEBUG_TSHRSRV_NORMAL, "TShrSRV: Binding Ica stack\n"));

    GCCrc = GCCConferenceInit(pTSrvInfo->hIca,
                              pTSrvInfo->hStack,
                              pTSrvInfo,
                              &pTSrvInfo->hDomain);

    if (GCCrc == GCC_NO_ERROR)
    {
        ntStatus = STATUS_SUCCESS;

        TRACE((DEBUG_TSHRSRV_DEBUG, "TShrSRV: Ica stack bound successfully\n"));
    }
    else
    {
        ntStatus = STATUS_UNSUCCESSFUL;

        pTSrvInfo->hDomain = NULL;

        TRACE((DEBUG_TSHRSRV_ERROR,
                "TShrSRV: Unable to bind stack - hStack %p, GCCrc 0x%x\n",
                 pTSrvInfo->hStack, GCCrc));
    }

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvBindStack exit - 0x%x\n", ntStatus));

    return (ntStatus);
}


//*************************************************************
//
//  TSrvInitWDConnectInfo()
//
//  Purpose:    Performs WDTshare connection initialization
//
//  Return:     STATUS_SUCCESS          - Success
//              other                   - Failure
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************
NTSTATUS
TSrvInitWDConnectInfo(IN HANDLE hStack,
                      IN PTSRVINFO pTSrvInfo,
                      IN OUT PUSERDATAINFO *ppUserDataInfo,
                      IN ULONG ioctl,
                      IN PBYTE pModuleData,
                      IN ULONG cbModuleData,
                      IN BOOLEAN bGetCert,
                      OUT PVOID *ppSecInfo)
{
    int                 i;
    ULONG               ulInBufferSize;
    ULONG               ulBytesReturned;
    PUSERDATAINFO       pUserDataInfo;
    PUSERDATAINFO       pUserDataInfo2;
    NTSTATUS            ntStatus;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvInitWDConnectInfo entry\n"));

    // For a standard connection we receive client user data as part of the
    // GCC connection request.  Shadow connections are initiated via RPC and
    // the input buffer contains the format sent by the other TS.
    if (ioctl == IOCTL_TSHARE_CONF_CONNECT) {
        TS_ASSERT(pTSrvInfo->pUserDataInfo);
        TS_ASSERT(pTSrvInfo->pUserDataInfo->cbSize);
    }

    // Allocate a block of memory to receive return UserData from
    // WDTShare.  This data will subsequently be sent to the client
    // via TSrvConfCreateResp.
    pUserDataInfo = TSHeapAlloc(0, 128, TS_HTAG_TSS_USERDATA_OUT);
    if (pUserDataInfo != NULL) {
        // Set the UserData cbSize element.  This is so that WDTShare can
        // determine if there is sufficient space available to place the
        // return data into
        pUserDataInfo->cbSize = 128 ;

        TRACE((DEBUG_TSHRSRV_DETAIL,
            "TShrSRV: Allocated 0x%x bytes to recieve WDTShare return data\n",
            pUserDataInfo->cbSize));

        // Exchange UserData with WDTShare.  If the provided output buffer
        // (pUserDataInfo) is large enough then the data will be exchanged
        // in one call.  If the buffer is not large enough, then it is up to
        // WDTShare to tell TShareSRV how to react.  For general errors we
        // just exit.  For STATUS_BUFFER_TOO_SMALL errors, TShareSrv looks at
        // the returned cbSize to determine how to adjust the buffer.   If
        // WDTShare did not increase the cbSize then TShareSrv will increase
        // it by a default amount (128 bytes).  TShareSrv will use the new value
        // to reallocate the output buffer and try the WDTShare call again.
        // (Note that TShareSrv will only try this a max of 20 times)
        for (i = 0; i < 20; i++) {
            TRACE((DEBUG_TSHRSRV_NORMAL, "TShrSRV: Performing connect (size=%ld)\n",
                  pUserDataInfo->cbSize));

            ulBytesReturned = 0;

            // Pass the actual client user data to the WD
            if (ioctl == IOCTL_TSHARE_CONF_CONNECT) {
                ntStatus = IcaStackIoControl(hStack,
                                             ioctl,
                                             pTSrvInfo->pUserDataInfo,
                                             pTSrvInfo->pUserDataInfo->cbSize,
                                             pUserDataInfo,
                                             pUserDataInfo->cbSize,
                                             &ulBytesReturned);
            }

            // Pass the shadow module data to the WD
            else {
                ntStatus = IcaStackIoControl(hStack,
                                             ioctl,
                                             pModuleData,
                                             cbModuleData,
                                             pUserDataInfo,
                                             pUserDataInfo->cbSize,
                                             &ulBytesReturned);
            }

            if (ntStatus != STATUS_BUFFER_TOO_SMALL)
                break;

            // The output buffer is too small, if WDTShare told us how big to make
            // the buffer then we are all set. Otherwise, by default, bump the buffer
            // up by 128 bytes

            if (ulBytesReturned < sizeof(pUserDataInfo->cbSize))
            {
                pUserDataInfo->cbSize += 128;
                TRACE((DEBUG_TSHRSRV_DEBUG,
                    "TShrSRV: Buffer too small - increasing it by 128 bytes to %d\n",
                     pUserDataInfo->cbSize));
            }
            else
            {
                TRACE((DEBUG_TSHRSRV_DEBUG,
                    "TShrSRV: Buffer too small - WDTShare set it to %d bytes\n",
                     pUserDataInfo->cbSize));
            }

            pUserDataInfo2 = TSHeapReAlloc(0, pUserDataInfo, pUserDataInfo->cbSize);
            if (!pUserDataInfo2)
            {
                TRACE((DEBUG_TSHRSRV_WARN,
                        "TShrSRV: Unable to allocate %d byte userData buffer\n"));
                break;
            }
            else {
                pUserDataInfo = pUserDataInfo2;
            }
        }
    }
    else
    {
        TRACE((DEBUG_TSHRSRV_WARN,
            "TShrSRV: Unable to allocate 0x%x bytes to recieve WDTShare return data\n",
             pUserDataInfo->cbSize));

        ntStatus = STATUS_NO_MEMORY;
    }

    // Free the input (client generated) UserData - we don't need it
    // lying aroung anymore.
    if (pTSrvInfo->pUserDataInfo != NULL) {
        TSHeapFree(pTSrvInfo->pUserDataInfo);
        pTSrvInfo->pUserDataInfo = NULL;
    }

    // If we succeeded in the exchange of info, add security info.
    if (NT_SUCCESS(ntStatus))
    {
        TS_ASSERT( pUserDataInfo != NULL );

        //
        // add user mode security data to the pUserDataInfo if we originally
        // received user data from the client.
        //
        ntStatus = AppendSecurityData(pTSrvInfo, &pUserDataInfo, bGetCert, ppSecInfo);
    }

    if (!NT_SUCCESS(ntStatus)) {
        if (pUserDataInfo != NULL) {
            TSHeapFree(pUserDataInfo);
            pUserDataInfo = NULL;
        }
    }

    // Return this pointer since the underlying routine does a realloc on it
    *ppUserDataInfo = pUserDataInfo;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvInitWDConnectInfo exit - 0x%x\n", ntStatus));

    return ntStatus;
}


//*************************************************************
//  TSrvShadowTargetConnect
//
//  Purpose:    Sends the shadow server's certificate and server
//              random to the client server for validation, then
//              waits for an encrypted client random to be returned.
//
//  Return:     STATUS_SUCCESS          - Success
//              other                   - Failure
//
//  History:    4/26/99    jparsons     Created
//*************************************************************
NTSTATUS TSrvShadowTargetConnect(
        HANDLE hStack,
        PTSRVINFO pTSrvInfo,
        PBYTE pModuleData,
        ULONG cbModuleData)
{
    PUSERDATAINFO pUserDataInfo;
    NTSTATUS status;
    PVOID pSecInfo;

    pUserDataInfo = NULL;
    status = TSrvInitWDConnectInfo(hStack,
                                   pTSrvInfo,
                                   &pUserDataInfo,
                                   IOCTL_TSHARE_SHADOW_CONNECT,
                                   pModuleData,
                                   cbModuleData,
                                   TRUE,
                                   &pSecInfo);
    if (status == STATUS_SUCCESS) {
        status = SendSecurityData(hStack, pSecInfo);
        if (NT_SUCCESS(status)) {
            if (pTSrvInfo->bSecurityEnabled) {
                NTSTATUS TempStatus;

                // We use the result of GetClientRandom() as the status to
                // determine the CreateSessionKeys() IOCTL type. We ignore
                // the return from CreateSessionKeys() is the client random
                // is not successful.
                status = GetClientRandom(hStack, pTSrvInfo, 15000, TRUE);
                if (!NT_SUCCESS(status)) {
                    TRACE((DEBUG_TSHRSRV_ERROR,
                            "TShrSRV: Could not get client random [%lx]\n",
                            status));
                }
                TempStatus = CreateSessionKeys(hStack, pTSrvInfo, status);
                if (NT_SUCCESS(status))
                    status = TempStatus;
            }
        }
        else {
            TRACE((DEBUG_TSHRSRV_ERROR,
                   "TShrSRV: Could not send shadow security info[%lx]\n", status));
        }
    }
    else {
        TRACE((DEBUG_TSHRSRV_ERROR,
               "TShrSRV: Could not initialize shadow target [%lx]\n", status));
    }

    if (NT_SUCCESS(status)) {
        TRACE((DEBUG_TSHRSRV_NORMAL,
              "TShrSRV: Shadow target security exchange complete!\n"));
    }

    return status;
}


//*************************************************************
//
//  TSrvShadowClientConnect
//
//  Purpose:    Validate the certificate received from the shadow
//              client's server.  If legit generate and encrypt a
//              client random for use by the shadow server
//              client.
//
//  Return:     STATUS_SUCCESS          - Success
//              other                   - Failure
//
//  History:    4/26/99    jparsons     Created
//
//*************************************************************
NTSTATUS TSrvShadowClientConnect(HANDLE hStack, PTSRVINFO pTSrvInfo)
{
    CERT_TYPE         certType;
    ULONG             cbServerPubKey;
    PBYTE             pbServerPubKey = NULL;
    ULONG             cbServerRandom;
    PBYTE             pbServerRandom;
    PVOID             pSecInfo;
    PUSERDATAINFO     pUserDataInfo;
    NTSTATUS          status;

    pUserDataInfo = NULL;
    status = TSrvInitWDConnectInfo(hStack,
                                   pTSrvInfo,
                                   &pUserDataInfo,
                                   IOCTL_TSHARE_SHADOW_CONNECT,
                                   (PBYTE) NULL,
                                   0,
                                   FALSE,
                                   &pSecInfo);

    if (status == STATUS_SUCCESS) {
        // This is the client passthru stack so validate the shadow server's
        // certificate and if good, store the server random.
        pbServerRandom = pTSrvInfo->SecurityInfo.KeyPair.serverRandom;
        cbServerRandom = sizeof(pTSrvInfo->SecurityInfo.KeyPair.serverRandom);
        status = TSrvValidateServerCertificate(
                         hStack,
                         &certType,
                         &cbServerPubKey,
                         &pbServerPubKey,
                         cbServerRandom,
                         pbServerRandom,
                         15000);

        if (NT_SUCCESS(status)) {
            TRACE((DEBUG_TSHRSRV_NORMAL,
                   "TShrSRV: Validated server cert[%s]: PublicKeyLength = %ld\n",
                   (certType == CERT_TYPE_X509) ? "X509" :
                   ((certType == CERT_TYPE_PROPRIETORY) ? "PROPRIETORY" :
                   "INVALID"), cbServerPubKey));

            // If encryption is enabled, then we need to encrypt a client random
            // with the shadow server's public key, and send it.
            if (cbServerPubKey != 0) {
                BOOL success;

                EnterCriticalSection( &g_TSrvCritSect );
                success = TSRNG_GenerateRandomBits(
                            pTSrvInfo->SecurityInfo.KeyPair.clientRandom,
                            sizeof(pTSrvInfo->SecurityInfo.KeyPair.clientRandom));
                LeaveCriticalSection( &g_TSrvCritSect );

                if (!success) {
                    TRACE((DEBUG_TSHRSRV_ERROR,
                            "TShrSRV: Could not generate a client random!\n"));
                }

                // We use the result of TSRNG_GenerateRandomBits() to determine the
                // CreateSessionKeys() IOCTL type.
                status = CreateSessionKeys(hStack, pTSrvInfo,
                        (success ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL));

                // send encrypted client random to the other server
                if (NT_SUCCESS(status)) {
                    status = SendClientRandom(
                                 hStack,
                                 certType,
                                 pbServerPubKey,
                                 cbServerPubKey,
                                 pTSrvInfo->SecurityInfo.KeyPair.clientRandom,
                                 sizeof(pTSrvInfo->SecurityInfo.KeyPair.clientRandom));
                }

                if (pbServerPubKey != NULL) {
                    TSHeapFree(pbServerPubKey);
                    pbServerPubKey = NULL;
                }

                if (NT_SUCCESS(status)) {
                    TRACE((DEBUG_TSHRSRV_NORMAL,
                          "TShrSRV: Shadow client security exchange complete!\n"));
                }
            }
        }
        else {
            TRACE((DEBUG_TSHRSRV_ERROR,
                  "TShrSRV: Validation failed on shadow certificate rc=%lx\n",
                  status));
            if (status == STATUS_IO_TIMEOUT) {
                status = STATUS_DECRYPTION_FAILED;
            }
        }
    }
    else {
        TRACE((DEBUG_TSHRSRV_ERROR,
               "TShrSRV: Could not initialize shadow client [%lx]\n", status));
    }

    return status;
}


//*************************************************************
//
//  TSrvInitWD()
//
//  Purpose:    Performs WDTshare initialization
//
//  Parameters: IN [pTSrvInfo]          - TShareSrv object
//              IN OUT [ppUserDataInfo] - pointer to generated user data
//
//  Return:     STATUS_SUCCESS          - Success
//              other                   - Failure
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************
NTSTATUS
TSrvInitWD(IN PTSRVINFO pTSrvInfo, IN OUT PUSERDATAINFO *ppUserDataInfo)
{
    NTSTATUS    ntStatus;
    PVOID       pSecData;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvInitWD entry\n"));

    // Pass on connection information

    TRACE((DEBUG_TSHRSRV_NORMAL,
            "TShrSRV: Performing WDTShare connection info exchange\n"));

    ntStatus = TSrvInitWDConnectInfo(pTSrvInfo->hStack,
                                     pTSrvInfo,
                                     ppUserDataInfo,
                                     IOCTL_TSHARE_CONF_CONNECT,
                                     NULL, 0, TRUE, &pSecData);

    if (!NT_SUCCESS(ntStatus))
    {
        TRACE((DEBUG_TSHRSRV_DEBUG,
            "TShrSRV: WDTShare connection info exchange unsuccessful - 0x%x\n", ntStatus));
    }

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvInitWD exit - 0x%x\n", ntStatus));

    return (ntStatus);
}


//*************************************************************
//
//  TSrvCreateGCCDataList()
//
//  Purpose:    Creates a Gcc UserData indirection list and
//              re-bases the UserData data pointers
//
//  Parameters: IN [pTSrvInfo]          - TShareSrv object
//
//  Return:     ppDataList
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************
GCCUserData **
TSrvCreateGCCDataList(IN PTSRVINFO pTSrvInfo, PUSERDATAINFO pUserDataInfo)
{
    DWORD                 i;
    GCCUserData       **ppDataList;
    GCCUserData        *pUserData;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvCreateGCCDataList entry\n"));

    ppDataList = NULL;

    TS_ASSERT(pUserDataInfo);

    if (pUserDataInfo)
    {
        TRACE((DEBUG_TSHRSRV_DETAIL, "TShrSRV: Creating UserData list\n"));

        TS_ASSERT(pUserDataInfo->ulUserDataMembers > 0);

        // Allocate UserData list memory

        ppDataList = TSHeapAlloc(HEAP_ZERO_MEMORY,
                                 sizeof(GCCUserData *) * pUserDataInfo->ulUserDataMembers,
                                 TS_HTAG_TSS_USERDATA_LIST);

        if (ppDataList)
        {
            TRACE((DEBUG_TSHRSRV_DETAIL,
                    "TShrSRV: Allocated 0x%x bytes for 0x%x member UserData array\n",
                    sizeof(GCCUserData *) * pUserDataInfo->ulUserDataMembers,
                    pUserDataInfo->ulUserDataMembers));

            for (i=0; i<pUserDataInfo->ulUserDataMembers; i++)
            {
                pUserData = &pUserDataInfo->rgUserData[i];

                // Key data rebase

                if (pUserData->key.key_type == GCC_OBJECT_KEY)
                {
                    (PUCHAR) pUserData->key.u.object_id.long_string +=
                            (ULONG_PTR) pUserDataInfo;
                }
                else
                {
                    (PUCHAR) pUserData->key.u.h221_non_standard_id.octet_string +=
                            (ULONG_PTR)pUserDataInfo;
                }

                // Client data ptr, and data rebase

                if (pUserData->octet_string)
                {
                    (PUCHAR) pUserData->octet_string +=
                            (ULONG_PTR)pUserDataInfo;

                    if (pUserData->octet_string->octet_string)
                    {
                        (PUCHAR) pUserData->octet_string->octet_string +=
                                (ULONG_PTR) pUserDataInfo;
                    }
                }

                // Assign the table list entry

                ppDataList[i] = pUserData;
            }
        }
        else
        {
            TRACE((DEBUG_TSHRSRV_WARN,
                    "TShrSRV: Unable to allocate 0x%x bytes for 0x%x member UserData array\n",
                    sizeof(GCCUserData *) * pUserDataInfo->ulUserDataMembers,
                    pUserDataInfo->ulUserDataMembers));
        }
    }
    else
    {
        TRACE((DEBUG_TSHRSRV_WARN, "TShrSRV: Not creating UserData list - no UserData\n"));
    }

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvCreateGCCDataList exit = 0x%x\n", ppDataList));

    return (ppDataList);
}


//*************************************************************
//
//  TSrvConfCreateResp()
//
//  Purpose:    Performs GCCConferenceCreateResponse
//
//  Parameters: IN [pTSrvInfo]          - TShareSrv object
//
//  Return:     STATUS_SUCCESS          - Success
//              other                   - Failure
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************
NTSTATUS
TSrvConfCreateResp(IN OUT PTSRVINFO pTSrvInfo)
{
    NTSTATUS        ntStatus;
    GCCError        GCCrc;
    GCCUserData    **pDataList;
    PUSERDATAINFO  pUserDataInfo;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvConfCreateResp entry\n"));

    ntStatus = pTSrvInfo->ntStatus;
    pUserDataInfo = NULL;

    if (NT_SUCCESS(ntStatus))
    {
        TRACE((DEBUG_TSHRSRV_DEBUG, "TShrSRV: Attempting ConfCreate response\n"));

        // Perform WDTShare connection initialization

        ntStatus = TSrvInitWD(pTSrvInfo, &pUserDataInfo);

        pTSrvInfo->ntStatus = ntStatus;

        if (NT_SUCCESS(ntStatus))
        {
            // The exchange of info with WDTShare has proceeded successfully,
            // So we can now create a digestable data transfer structure
            // for GCC

            pDataList = TSrvCreateGCCDataList(pTSrvInfo, pUserDataInfo);

            if (pDataList)
            {
                // Accept the conference creation request

                TRACE((DEBUG_TSHRSRV_NORMAL, "TShrSRV: Accepting conference domain %p\n",
                        pTSrvInfo->hDomain));

                GCCrc = GCCConferenceCreateResponse(
                               NULL,                        // conference_modifier
                               pTSrvInfo->hDomain,          // domain handle
                               0,                           // use_password_in_the_clear
                               NULL,                        // domain_parameters
                               0,                           // number_of_network_addresses
                               NULL,                        // local_network_address_list
                               1,                           // number_of_user_data_members
                               (GCCUserData**)pDataList,    // user_data_list
                               GCC_RESULT_SUCCESSFUL);      // reason

                TSrvDumpGCCRCDetails(GCCrc,
                        "GCCConferenceCreateResponse");

                if (GCCrc == GCC_NO_ERROR)
                    ntStatus = STATUS_SUCCESS;
                else
                    ntStatus = STATUS_REQUEST_NOT_ACCEPTED;

                TSHeapFree(pDataList);
            }
            else
            {
                ntStatus = STATUS_NO_MEMORY;
            }
        }
        else
        {
            // Conference is being rejected

            TRACE((DEBUG_TSHRSRV_NORMAL, "TShrSRV: Rejecting conference domain %p - 0x%x\n",
                    pTSrvInfo->hDomain, pTSrvInfo->ntStatus));

            GCCrc = GCCConferenceCreateResponse(
                           NULL,                            // conference_modifier
                           pTSrvInfo->hDomain,              // domain
                           0,                               // use_password_in_the_clear
                           NULL,                            // domain_parameters
                           0,                               // number_of_network_addresses
                           NULL,                            // local_network_address_list
                           1,                               // number_of_user_data_members
                           NULL,                            // user_data_list
                           GCC_RESULT_USER_REJECTED);       // reason

            TSrvDumpGCCRCDetails(GCCrc,
                    "TShrSRV: GCCConferenceCreateResponse\n");

            // Return the original failure status back to the caller
            ntStatus = pTSrvInfo->ntStatus;
        }
    }
    else {
        TRACE((DEBUG_TSHRSRV_ERROR,
                "TShrSRV: Connect failure, could not generate response: %lx\n",
               ntStatus));
    }

    if (NT_SUCCESS(ntStatus))
    {
        //
        // if we successfully sent the conference connect response, then
        // check security response (only if we need to).
        //
        if (pTSrvInfo->bSecurityEnabled) {
            NTSTATUS TempStatus;

            // We use the result of GetClientRandom() as the status to
            // determine the CreateSessionKeys() IOCTL type. We ignore the
            // return from CreateSessionKeys() if the client random is
            // not successful.
            ntStatus = GetClientRandom(pTSrvInfo->hStack, pTSrvInfo, 60000,
                    FALSE);
            TempStatus = CreateSessionKeys(pTSrvInfo->hStack, pTSrvInfo,
                    ntStatus);
            if (NT_SUCCESS(ntStatus))
                ntStatus = TempStatus;
        }
    }

    // If we still have a UserData structure, free it, we no longer need it.
    if (pUserDataInfo)
    {
        TSHeapFree(pUserDataInfo);
        pUserDataInfo = NULL;
    }

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvConfCreateResp exit = 0x%x\n", ntStatus));

    return (ntStatus);
}


//*************************************************************
//
//  TSrvConfDisconnectReq()
//
//  Purpose:    Performs GCCConferenceTerminateRequest
//
//  Parameters: IN [pTSrvInfo]          - TShareSrv object
//              IN [ulReason]           - Reason code
//
//  Return:     STATUS_SUCCESS          - Success
//              other                   - Failure
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************
NTSTATUS
TSrvConfDisconnectReq(IN PTSRVINFO pTSrvInfo,
                      IN ULONG     ulReason)
{
    GCCError    GCCrc;
    NTSTATUS    ntStatus;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvConfDisconnectReq entry\n"));

    ntStatus = STATUS_REQUEST_ABORTED;

    TRACE((DEBUG_TSHRSRV_NORMAL,
            "TShrSRV: Conf termination - domain %p - reason 0x%x\n",
            pTSrvInfo->hDomain, ulReason));

    GCCrc = GCCConferenceTerminateRequest(pTSrvInfo->hIca, pTSrvInfo->hDomain,
                    pTSrvInfo->hConnection, ulReason);

    TSrvDumpGCCRCDetails(GCCrc,
            "GCCConferenceTerminateRequest");

    if (GCCrc == GCC_NO_ERROR)
        ntStatus = STATUS_SUCCESS;

    TRACE((DEBUG_TSHRSRV_FLOW,
            "TShrSRV: TSrvConfDisconnectReq exit = 0x%x\n", ntStatus));

    return (ntStatus);
}




//-----
#if DBG
//-----

//*************************************************************
//
//  TSrvBuildNameFromGCCConfName()
//
//  Purpose:    Build a traceable conference name from
//              a GCC name
//
//  Parameters: IN  [gccName]           - GCCConferenceName
//              OUT [pConfName]         - Traceable name
//
//  Return:     STATUS_SUCCESS          - Success
//              other                   - Failure
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************
void
TSrvBuildNameFromGCCConfName(IN  GCCConferenceName *gccName,
                             OUT PCHAR              pConfName)
{
    int     i;

    // The text represenation of a GCC conference name is:
    //
    // <text_string> : (<numeric_string>)

    i = 0;

    while (gccName->text_string[i] != 0x0000)
    {
        pConfName[i] = (CHAR)gccName->text_string[i];

        i++;
    }

    pConfName[i] = '\0';
}


//*************************************************************
//
//  TSrvDumpCreateIndDetails()
//
//  Purpose:    Dumps out GCC_CREATE_IND details
//
//  Parameters: IN [pCreateMessage]     - CreateIndicationMessage
//
//  Return:     void
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************
void
TSrvDumpCreateIndDetails(IN CreateIndicationMessage *pCreateMessage)
{
    CHAR    name[MAX_CONFERENCE_NAME_LEN];

    if (pCreateMessage->conductor_privilege_list == NULL)
    {
        TRACE((DEBUG_TSHRSRV_DETAIL,
                "TShrSRV: Conductor privilege list is NULL\n"));
    }
    else
    {
        TRACE((DEBUG_TSHRSRV_DETAIL,
                "TShrSRV: Conductor priv, terminate allowed 0x%x\n",
                 pCreateMessage->conductor_privilege_list->terminate_is_allowed));
    }

    if (pCreateMessage->conducted_mode_privilege_list == NULL)
    {
        TRACE((DEBUG_TSHRSRV_DETAIL,
                "TShrSRV: Conducted mode privilege list is NULL\n"));
    }
    else
    {
        TRACE((DEBUG_TSHRSRV_DETAIL,
                "TShrSRV: Conducted mode priv, terminate allowed 0x%x\n",
                 pCreateMessage->conducted_mode_privilege_list->terminate_is_allowed));
    }

    if (pCreateMessage->non_conducted_privilege_list == NULL)
    {
        TRACE((DEBUG_TSHRSRV_DETAIL,
                "TShrSRV: Non-conducted mode privilege list is NULL\n"));
    }
    else
    {
        TRACE((DEBUG_TSHRSRV_DETAIL,
                "TShrSRV: non-conducted priv, terminate allowed 0x%x\n",
                pCreateMessage->non_conducted_privilege_list->terminate_is_allowed));
    }

    if (pCreateMessage->conference_name.text_string == NULL)
    {
        TRACE((DEBUG_TSHRSRV_DETAIL,
                "TShrSRV: NULL conf name\n"));
    }
    else
    {
        TSrvBuildNameFromGCCConfName(&(pCreateMessage->conference_name), name);

        TRACE((DEBUG_TSHRSRV_DETAIL,
                "TShrSRV: Conf name '%s'\n", name));
    }
}


//*************************************************************
//
//  TSrvDumpGCCRCDetails()
//
//  Purpose:    Dumps out GCC return code details
//
//  Parameters: IN [GCCrc]              - GCC return code
//              IN [pszText]            - var text
//
//  Return:     void
//
//  History:    07-17-97    BrianTa     Created
//
//*************************************************************
void
TSrvDumpGCCRCDetails(IN GCCError        gccRc,
                     IN PCHAR           pszText)
{
    int         i;
    PCHAR       pszMessageText;

    pszMessageText = "UNKNOWN_GCC_RC";

    for (i=0; i<sizeof(GCCReturnCodeTBL) / sizeof(GCCReturnCodeTBL[0]); i++)
    {
        if (GCCReturnCodeTBL[i].gccRC == gccRc)
        {
            pszMessageText = GCCReturnCodeTBL[i].pszMessageText;
            break;
        }
    }

    TRACE((DEBUG_TSHRSRV_DETAIL,
            "TShrSRV: %s - GCC rc 0x%x (%s)\n",
             pszText, gccRc, 