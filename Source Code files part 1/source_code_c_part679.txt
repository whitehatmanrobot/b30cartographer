me");
const TCHAR c_szInternalPort[] = TEXT("InternalPort");
const TCHAR c_szKeyFormat[] = TEXT("%08X");
#endif
const TCHAR c_szMaxResponseEntry[] = TEXT("65535-65535,");
#if 0
const TCHAR c_szPort[] = TEXT("Port");
const TCHAR c_szProtocol[] = TEXT("Protocol");
const TCHAR c_szReservedAddress[] = TEXT("ReservedAddress");
#endif
const TCHAR c_szResponseFormat1[] = TEXT("%d");
const TCHAR c_szResponseFormat2[] = TEXT("%d-%d");
#if 0
const TCHAR c_szSectionFormat[] = TEXT("%s.%s");
const TCHAR c_szServer[] = TEXT("Server");
const TCHAR c_szSharedAccessIni[] = TEXT("SharedAccess.ini");
const TCHAR c_szTagBuiltIn[] = TEXT("BuiltIn=");
const TCHAR c_szTagInternalName[] = TEXT("InternalName=");
const TCHAR c_szTagInternalPort[] = TEXT("InternalPort=");
const TCHAR c_szTagPort[] = TEXT("Port=");
const TCHAR c_szTagProtocol[] = TEXT("Protocol=");
const TCHAR c_szTagReservedAddress[] = TEXT("ReservedAddress=");
const TCHAR c_szTagTcpResponseList[] = TEXT("TcpResponseList=");
const TCHAR c_szTagTitle[] = TEXT("Title=");
const TCHAR c_szTagUdpResponseList[] = TEXT("UdpResponseList=");
const TCHAR c_szTCP[] = TEXT("TCP");
const TCHAR c_szTcpResponseList[] = TEXT("TcpResponseList");
const TCHAR c_szTitle[] = TEXT("Title");
const TCHAR c_szUDP[] = TEXT("UDP");
const TCHAR c_szUdpResponseList[] = TEXT("UdpResponseList");

//
// FORWARD DECLARATIONS
//

SAAPPLICATION*
LoadApplication(
    ULONG KeyValue,
    BOOL Enabled,
    const TCHAR* Path
    );

TCHAR*
LoadEntryList(
    const TCHAR* Path,
    const TCHAR* Section
    );

TCHAR*
LoadPath(
    VOID
    );

SASERVER*
LoadServer(
    ULONG KeyValue,
    BOOL Enabled,
    const TCHAR* Path
    );

LONG
Lstrcmpni(
    const TCHAR* String1,
    const TCHAR* String2,
    LONG Length
    );

TCHAR*
QueryEntryList(
    const TCHAR* EntryList,
    const TCHAR* Tag
    );

BOOL
SaveApplication(
    SAAPPLICATION* Application,
    const TCHAR* Path
    );

BOOL
SaveServer(
    SAINFO* Info,
    SASERVER* Server,
    const TCHAR* Path
    );

BOOL
WritePrivateProfileStringUTF8(
    const TCHAR* Section,
    const TCHAR* Key,
    const TCHAR* Value,
    const TCHAR* Path
    );


VOID APIENTRY
RasFreeSharedAccessSettings(
    IN SAINFO* Info
    )

/*++

Routine Description:

    Frees memory allocated for the contents of 'Info'.

Arguments:

    Info - the settings to be freed

Return Value:

    none.

--*/

{
    SAAPPLICATION* Application;
    PLIST_ENTRY Link;
    SASERVER* Server;
    TRACE("RasFreeSharedAccessSettings");

    while (!IsListEmpty(&Info->ApplicationList)) {
        Link = RemoveHeadList(&Info->ApplicationList);
        Application = CONTAINING_RECORD(Link, SAAPPLICATION, Link);
        FreeSharedAccessApplication(Application);
    }

    while (!IsListEmpty(&Info->ServerList)) {
        Link = RemoveHeadList(&Info->ServerList);
        Server = CONTAINING_RECORD(Link, SASERVER, Link);
        FreeSharedAccessServer(Server);
    }

    Free(Info);
} // RasFreeSharedAccessSettings


SAINFO* APIENTRY
RasLoadSharedAccessSettings(
    BOOL EnabledOnly
    )

/*++

Routine Description:

    Reads in the local shared access settings, returning an allocated
    'SAINFO' containing the settings retrieved.

Arguments:

    EnabledOnly - if TRUE, only the application-entries which are enabled
        are retrieved.

Return Value:

    SAINFO* - the settings retrieved

--*/

{
    SAAPPLICATION* Application;
    BOOL Enabled;
    SAINFO* Info;
    TCHAR* Key;
    TCHAR* KeyEnd;
    TCHAR* KeyList;
    ULONG KeyValue;
    TCHAR* Path;
    TCHAR SectionName[32];
    SASERVER* Server;
    TRACE("RasLoadSharedAccessSettings");

    //
    // Allocate and initialize the settings-structure
    //

    Info = (SAINFO*)Malloc(sizeof(SAINFO));
    if (!Info) { return NULL; }

    InitializeListHead(&Info->ApplicationList);
    InitializeListHead(&Info->ServerList);

    //
    // Read scope information from the registry
    //

    CsQueryScopeInformation(NULL, &Info->ScopeAddress, &Info->ScopeMask);

    //
    // Construct the path to the shared access information file,
    // and read the index of 'application' sections.
    // Each section should contain a valid application-description,
    // for which we construct a corresponding 'SAAPPLICATION' entry
    // in the application-list.
    //

    if (!(Path = LoadPath())) {
        RasFreeSharedAccessSettings(Info);
        return NULL;
    }

    wsprintf(SectionName, c_szSectionFormat, c_szContents, c_szApplication);

    if (KeyList = LoadEntryList(SectionName, Path)) {

        for (Key = KeyList; *Key; Key += lstrlen(Key) + 1) {

            //
            // Ensure the key is a valid hexadecimal integer,
            // and read the 'Enabled' setting which is its value.
            // N.B. if the entry is disabled and the caller only wants
            // enabled entries, exclude this one.
            //

            KeyValue = _tcstoul(Key, &KeyEnd, 16);
            if (*KeyEnd++ != TEXT('=')) {
                continue;
            } else if (!(Enabled = !!_ttol(KeyEnd)) && EnabledOnly) {
                continue;
            }

            //
            // Read in the corresponding 'Application.<key>' section.
            //

            Application = LoadApplication(KeyValue, Enabled, Path);
            if (Application) {
                InsertTailList(&Info->ApplicationList, &Application->Link);
            }
        }

        Free(KeyList);
    }

    //
    // Finally, read the index of 'server' sections, and read each section.
    // Each section contains a server-description for which we construct
    // a corresponding 'SASERVER' entry in the server-list.
    //

    wsprintf(SectionName, c_szSectionFormat, c_szContents, c_szServer);

    if (KeyList = LoadEntryList(SectionName, Path)) {

        for (Key = KeyList; *Key; Key += lstrlen(Key) + 1) {

            //
            // Ensure the key is a valid hexadecimal integer,
            // and read the 'Enabled' setting which is its value.
            // N.B. if the entry is disabled and the caller only wants
            // enabled entries, exclude this one.
            //

            KeyValue = _tcstoul(Key, &KeyEnd, 16);
            if (*KeyEnd++ != TEXT('=')) {
                continue;
            } else if (!(Enabled = !!_ttol(KeyEnd)) && EnabledOnly) {
                continue;
            }

            //
            // Read in the corresponding 'Server.<key>' section.
            //

            Server = LoadServer(KeyValue, Enabled, Path);
            if (Server) {
                InsertTailList(&Info->ServerList, &Server->Link);
            }
        }

        Free(KeyList);
    }

    return Info;

} // RasLoadSharedAccessSettings


BOOL APIENTRY
RasSaveSharedAccessSettings(
    IN SAINFO* Info
    )

/*++

Routine Description:

    Stores the shared access settings in 'Info' back into the local registry
    from where the settings were read.

    N.B. If 'Info' was loaded with the 'EnableOnly' flag, saving it back
    will erase all disabled entries.

Arguments:

    Info - supplies the settings to be saved

Return Value:

    BOOL - TRUE if successful, FALSE otherwise.

--*/

{
    SAAPPLICATION* Application;
    TCHAR Buffer[10];
    PLIST_ENTRY Link;
    TCHAR Key[10];
    TCHAR* Path;
    TCHAR SectionName[32];
    SASERVER* Server;

    TRACE("RasSaveSharedAccessSettings");

    //
    // First erase the existing file.
    //

    if (!(Path = LoadPath()) || CreateDirectoriesOnPath(Path, NULL)) {
        Free0(Path);
        return FALSE;
    }

    DeleteFile(Path);

    //
    // Now we reconstruct the file.
    // We begin by saving each application entry, in the process building
    // a content index of all the saved entries.
    //

    wsprintf(SectionName, c_szSectionFormat, c_szContents, c_szApplication);

    for (Link = Info->ApplicationList.Flink; Link != &Info->ApplicationList;
         Link = Link->Flink) {
        Application = CONTAINING_RECORD(Link, SAAPPLICATION, Link);
        if (SaveApplication(Application, Path)) {
            wsprintf(Key, c_szKeyFormat, Application->Key);
            _ltot(!!Application->Enabled, Buffer, 10);
            WritePrivateProfileStringUTF8(
                SectionName,
                Key,
                Buffer,
                Path
                );
        }
    }

    //
    // Similarly, save each server entry, in the process building
    // a content index of all the saved entries.
    //

    wsprintf(SectionName, c_szSectionFormat, c_szContents, c_szServer);

    for (Link = Info->ServerList.Flink; Link != &Info->ServerList;
         Link = Link->Flink) {
        Server = CONTAINING_RECORD(Link, SASERVER, Link);
        if (SaveServer(Info, Server, Path)) {
            wsprintf(Key, c_szKeyFormat, Server->Key);
            _ltot(!!Server->Enabled, Buffer, 10);
            WritePrivateProfileStringUTF8(
                SectionName,
                Key,
                Buffer,
                Path
                );
        }
    }

    Free(Path);
    CsControlService(IPNATHLP_CONTROL_UPDATE_SETTINGS);
    return TRUE;
} // RasSaveSharedAccessSettings


VOID APIENTRY
FreeSharedAccessApplication(
    SAAPPLICATION* Application
    )
{
    PLIST_ENTRY Link;
    SARESPONSE* Response;
    while (!IsListEmpty(&Application->ResponseList)) {
        Link = RemoveHeadList(&Application->ResponseList);
        Response = CONTAINING_RECORD(Link, SARESPONSE, Link);
        Free(Response);
    }
    Free0(Application->Title);
    Free(Application);
}


VOID APIENTRY
FreeSharedAccessServer(
    SASERVER* Server
    )
{
    Free0(Server->Title);
    Free0(Server->InternalName);
    Free(Server);
}


SAAPPLICATION*
LoadApplication(
    ULONG KeyValue,
    BOOL Enabled,
    const TCHAR* Path
    )
{
    SAAPPLICATION* Application;
    TCHAR* EntryList;
    TCHAR Key[10];
    TCHAR SectionName[32];
    TCHAR* Value;

    wsprintf(Key, c_szKeyFormat, KeyValue);
    wsprintf(SectionName, c_szSectionFormat, c_szApplication, Key);
    if (!(EntryList = LoadEntryList(SectionName, Path))) { return NULL; }

    do {

        //
        // Allocate and initialize an 'application' entry.
        //

        Application = (SAAPPLICATION*)Malloc(sizeof(SAAPPLICATION));
        if (!Application) { break; }

        ZeroMemory(Application, sizeof(*Application));
        InitializeListHead(&Application->ResponseList);
        Application->Key = KeyValue;
        Application->Enabled = Enabled;

        //
        // Read each required '<tag>=<value>' entry in the section.
        // The tags required for an application are
        //      'Title='
        //      'Protocol='
        //      'Port='
        // The optional tags, at least one of which must be present, are
        //      'TcpResponseList='
        //      'UdpResponseList='
        // The optional tags which may be absent are
        //      'BuiltIn='
        //

        Value = QueryEntryList(EntryList, c_szTagTitle);
        if (!Value) { break; }
        Application->Title = StrDup(Value);

        Value = QueryEntryList(EntryList, c_szTagProtocol);
        if (!Value) { break; }
        if (!Lstrcmpni(Value, c_szTCP, LSTRLEN(c_szTCP))) {
            Application->Protocol = NAT_PROTOCOL_TCP;
        } else if (!Lstrcmpni(Value, c_szUDP, LSTRLEN(c_szTCP))) {
            Application->Protocol = NAT_PROTOCOL_UDP;
        } else {
            break;
        }

        Value = QueryEntryList(EntryList, c_szTagPort);
        if (!Value || !(Application->Port = (USHORT)_ttol(Value))) { break; }
        Application->Port = HTONS(Application->Port);

        Value = QueryEntryList(EntryList, c_szTagTcpResponseList);
        if (Value) {
            SharedAccessResponseStringToList(
                NAT_PROTOCOL_TCP,
                Value,
                &Application->ResponseList
                );
        }
        Value = QueryEntryList(EntryList, c_szTagUdpResponseList);
        if (Value) {
            SharedAccessResponseStringToList(
                NAT_PROTOCOL_UDP,
                Value,
                &Application->ResponseList
                );
        }
        if (IsListEmpty(&Application->ResponseList)) { break; }

        Value = QueryEntryList(EntryList, c_szTagBuiltIn);
        if (Value) {
            Application->BuiltIn = _ttol(Value) ? TRUE : FALSE;
        } else {
            Application->BuiltIn = FALSE;
        }

        //
        // The entry was loaded successfully.
        //

        Free(EntryList);
        return Application;

    } while (FALSE);

    //
    // Something went wrong.
    //

    if (Application) { FreeSharedAccessApplication(Application); }
    Free(EntryList);
    return NULL;
}


TCHAR*
LoadEntryList(
    const TCHAR* Section,
    const TCHAR* Path
    )
{
    CHAR* BufferA = NULL;
    ULONG Length;
    CHAR* PathA = NULL;
    CHAR* SectionA = NULL;
    ULONG Size;
    CHAR* Source;
    TCHAR* Target;
    TCHAR* BufferW = NULL;

    if (!(SectionA = StrDupAFromT(Section))) {
        return NULL;
    }
    if (!(PathA = StrDupAFromTAnsi(Path))) {
        Free(SectionA);
        return NULL;
    }
    for (BufferA = NULL, Size = MAX_PATH; ; Size += MAX_PATH, Free(BufferA)) {

        BufferA = (CHAR*)Malloc(Size);
        if (!BufferA) {
            break;
        }

        if (GetPrivateProfileSectionA(SectionA, BufferA, Size, PathA)
                == Size-2) {
            continue;
        }

        //
        // Convert each string in the buffer from UTF8 format to Unicode.
        // The conversion will result in at most 'Size' Unicode characters,
        // and fewer if 2- or 3-byte UTF8 sequences are present in the
        // source buffer.
        //

        BufferW = (TCHAR*)Malloc(Size * sizeof(TCHAR));
        if (!BufferW) {
            break;
        }
        Target = BufferW;
        for (Source = BufferA; *Source; Source += lstrlenA(Source) + 1) {
            if (StrCpyWFromA(Target, Source, Size) != NO_ERROR) {
                break;
            }
            Length = lstrlen(Target) + 1;
            Target += Length;
            Size -= Length;
        }
        if (*Source) { break; }
        Free(BufferA);
        Free(PathA);
        Free(SectionA);
        return BufferW;
    }
    Free0(BufferW);
    Free0(BufferA);
    Free0(PathA);
    Free0(SectionA);
    return NULL;
}


TCHAR*
LoadPath(
    VOID
    )
{
    TCHAR* Path;
    Path =
        (TCHAR*)Malloc(
            (MAX_PATH + lstrlen(c_szSharedAccessIni) + 1) * sizeof(TCHAR)
            );
    if (!Path || !GetPhonebookDirectory(PBM_System, Path)) {
        Free0(Path);
        return NULL;
    }

    lstrcat(Path, c_szSharedAccessIni);
    return Path;
}


SASERVER*
LoadServer(
    ULONG KeyValue,
    BOOL Enabled,
    const TCHAR* Path
    )
{
    SASERVER* Server;
    TCHAR* EntryList;
    TCHAR Key[10];
    TCHAR SectionName[32];
    TCHAR* Value;

    wsprintf(Key, c_szKeyFormat, KeyValue);
    wsprintf(SectionName, c_szSectionFormat, c_szServer, Key);
    if (!(EntryList = LoadEntryList(SectionName, Path))) { return NULL; }

    do {

        //
        // Allocate and initialize a 'server' entry.
        //

        Server = (SASERVER*)Malloc(sizeof(SASERVER));
        if (!Server) { break; }

        ZeroMemory(Server, sizeof(*Server));
        Server->Key = KeyValue;
        Server->Enabled = Enabled;

        //
        // Read each required '<tag>=<value>' entry in the section.
        // The tags required for a server are
        //      'Title='
        //      'Protocol='
        //      'Port='
        //      'InternalPort='
        // The optional tags which may be absent are
        //      'BuiltIn='
        //      'InternalName='
        //      'ReservedAddress='
        // The 'InternalName=' and 'ReservedAddress=' tags may only be absent
        // if 'BuiltIn' is set, in which case the entry is disabled.
        //

        Value = QueryEntryList(EntryList, c_szTagTitle);
        if (!Value) { break; }
        Server->Title = StrDup(Value);

        Value = QueryEntryList(EntryList, c_szTagProtocol);
        if (!Value) { break; }
        if (!Lstrcmpni(Value, c_szTCP, LSTRLEN(c_szTCP))) {
            Server->Protocol = NAT_PROTOCOL_TCP;
        } else if (!Lstrcmpni(Value, c_szUDP, LSTRLEN(c_szTCP))) {
            Server->Protocol = NAT_PROTOCOL_UDP;
        } else {
            break;
        }

        Value = QueryEntryList(EntryList, c_szTagPort);
        if (!Value || !(Server->Port = (USHORT)_ttol(Value))) { break; }
        Server->Port = HTONS(Server->Port);

        Value = QueryEntryList(EntryList, c_szTagInternalPort);
        if (!Value || !(Server->InternalPort = (USHORT)_ttol(Value))) { break; }
        Server->InternalPort = HTONS(Server->InternalPort);

        Value = QueryEntryList(EntryList, c_szTagBuiltIn);
        if (Value) {
            Server->BuiltIn = _ttol(Value) ? TRUE : FALSE;
        } else {
            Server->BuiltIn = FALSE;
        }

        Value = QueryEntryList(EntryList, c_szTagInternalName);
        if (!Value || !lstrlen(Value)) {
            if (!Server->BuiltIn) {
                break;
            } else {
                Server->InternalName = NULL;
                Server->Enabled = FALSE;
            }
        } else {
            Server->InternalName = StrDup(Value);
        }

        Value = QueryEntryList(EntryList, c_szTagReservedAddress);
        if (!Value || !lstrlen(Value)) {
            if (!Server->BuiltIn) {
                break;
            } else {
                Server->ReservedAddress = INADDR_NONE;
                Server->Enabled = FALSE;
            }
        } else {
            Server->ReservedAddress = IpPszToHostAddr(Value);
            if (Server->ReservedAddress == INADDR_NONE && !Server->BuiltIn) {
                break;
            }
            Server->ReservedAddress = HTONL(Server->ReservedAddress);
        }

        //
        // The entry was loaded successfully.
        //

        Free(EntryList);
        return Server;

    } while (FALSE);

    //
    // Something went wrong.
    //

    if (Server) { FreeSharedAccessServer(Server); }
    Free(EntryList);
    return NULL;
}


LONG
Lstrcmpni(
    const TCHAR* String1,
    const TCHAR* String2,
    LONG Length
    )
{
    return
        CSTR_EQUAL -
        CompareString(
            LOCALE_SYSTEM_DEFAULT,
            NORM_IGNORECASE,
            String1,
            Length,
            String2,
            Length
            );
}


TCHAR*
QueryEntryList(
    const TCHAR* EntryList,
    const TCHAR* Tag
    )
{
    TCHAR* Entry;
    ULONG TagLength = lstrlen(Tag);
    for (Entry = (TCHAR*)EntryList; *Entry; Entry += lstrlen(Entry) + 1) {
        if (Entry[0] == Tag[0] && !Lstrcmpni(Tag, Entry, TagLength)) {
            return Entry + TagLength;
        }
    }
    return NULL;
}


BOOL
SaveApplication(
    SAAPPLICATION* Application,
    const TCHAR* Path
    )
{
    TCHAR Buffer[32];
    ULONG Length;
    PLIST_ENTRY Link;
    SARESPONSE* Response;
    TCHAR SectionName[32];
    TCHAR* Value;

    wsprintf(Buffer, c_szKeyFormat, Application->Key);
    wsprintf(SectionName, c_szSectionFormat, c_szApplication, Buffer);

    WritePrivateProfileStringUTF8(
        SectionName,
        c_szTitle,
        Application->Title,
        Path
        );

    if (Application->Protocol == NAT_PROTOCOL_TCP) {
        Value = (TCHAR*)c_szTCP;
    } else if (Application->Protocol == NAT_PROTOCOL_UDP) {
        Value = (TCHAR*)c_szUDP;
    } else {
        return FALSE;
    }
    WritePrivateProfileStringUTF8(
        SectionName,
        c_szProtocol,
        Value,
        Path
        );

    _ltot(NTOHS(Application->Port), Buffer, 10);
    WritePrivateProfileStringUTF8(
        SectionName,
        c_szPort,
        Buffer,
        Path
        );

    Value = SharedAccessResponseListToString(&Application->ResponseList, NAT_PROTOCOL_TCP);
    if (Value) {
        WritePrivateProfileStringUTF8(
            SectionName,
            c_szTcpResponseList,
            Value,
            Path
            );
        Free(Value);
    }

    Value = SharedAccessResponseListToString(&Application->ResponseList, NAT_PROTOCOL_UDP);
    if (Value) {
        WritePrivateProfileStringUTF8(
            SectionName,
            c_szUdpResponseList,
            Value,
            Path
            );
        Free(Value);
    }

    _ltot(Application->BuiltIn, Buffer, 10);
    WritePrivateProfileStringUTF8(
        SectionName,
        c_szBuiltIn,
        Buffer,
        Path
        );

    return TRUE;
}


BOOL
SaveServer(
    SAINFO* Info,
    SASERVER* Server,
    const TCHAR* Path
    )
{
    TCHAR Buffer[32];
    ULONG ReservedAddress;
    TCHAR SectionName[32];
    TCHAR* Value;

    wsprintf(Buffer, c_szKeyFormat, Server->Key);
    wsprintf(SectionName, c_szSectionFormat, c_szServer, Buffer);

    WritePrivateProfileStringUTF8(
        SectionName,
        c_szTitle,
        Server->Title,
        Path
        );

    if (Server->Protocol == NAT_PROTOCOL_TCP) {
        Value = (TCHAR*)c_szTCP;
    } else if (Server->Protocol == NAT_PROTOCOL_UDP) {
        Value = (TCHAR*)c_szUDP;
    } else {
        return FALSE;
    }
    WritePrivateProfileStringUTF8(
        SectionName,
        c_szProtocol,
        Value,
        Path
        );

    _ltot(NTOHS(Server->Port), Buffer, 10);
    WritePrivateProfileStringUTF8(
        SectionName,
        c_szPort,
        Buffer,
        Path
        );

    WritePrivateProfileStringUTF8(
        SectionName,
        c_szInternalName,
        Server->InternalName,
        Path
        );

    _ltot(NTOHS(Server->InternalPort), Buffer, 10);
    WritePrivateProfileStringUTF8(
        SectionName,
        c_szInternalPort,
        Buffer,
        Path
        );

    if (Server->InternalName && lstrlen(Server->InternalName)) {
        ReservedAddress = IpPszToHostAddr(Server->InternalName);
        if (ReservedAddress != INADDR_NONE) {
            Server->ReservedAddress = HTONL(ReservedAddress);
        }
        if (Server->ReservedAddress == INADDR_NONE) {
            SASERVER* Entry;
            ULONG Index;
            PLIST_ENTRY Link;
            ULONG ScopeLength;
            for (Link = Info->ServerList.Flink; Link != &Info->ServerList;
                 Link = Link->Flink) {
                Entry = CONTAINING_RECORD(Link, SASERVER, Link);
                if (Entry != Server &&
                    Entry->ReservedAddress &&
                    Entry->ReservedAddress != INADDR_NONE &&
                    lstrcmpi(Entry->InternalName, Server->InternalName) == 0) {
                    Server->ReservedAddress = Entry->ReservedAddress;
                    break;
                }
            }
            if (Server->ReservedAddress == INADDR_NONE) {
                ScopeLength = NTOHL(~Info->ScopeMask);
                for (Index = 1; Index < ScopeLength - 1; Index++) {
                    ReservedAddress =
                        (Info->ScopeAddress & Info->ScopeMask) | HTONL(Index);
                    if (ReservedAddress == Info->ScopeAddress) { continue; }
                    for (Link = Info->ServerList.Flink;
                         Link != &Info->ServerList; Link = Link->Flink) {
                        Entry = CONTAINING_RECORD(Link, SASERVER, Link);
                        if (Entry->ReservedAddress == ReservedAddress) {
                            break;
                        }
                    }
                    if (Link == &Info->ServerList) { break; }
                }
                if (Index > ScopeLength) { return FALSE; }
                Server->ReservedAddress = ReservedAddress;
            }
        }

        IpHostAddrToPsz(NTOHL(Server->ReservedAddress), Buffer);
        WritePrivateProfileStringUTF8(
            SectionName,
            c_szReservedAddress,
            Buffer,
            Path
            );
    }

    _ltot(Server->BuiltIn, Buffer, 10);
    WritePrivateProfileStringUTF8(
        SectionName,
        c_szBuiltIn,
        Buffer,
        Path
        );

    return TRUE;
}

#endif


TCHAR* APIENTRY
SharedAccessResponseListToString(
    PLIST_ENTRY ResponseList,
    UCHAR Protocol
    )
{
    TCHAR Buffer[LSTRLEN(c_szMaxResponseEntry)];
    ULONG Length;
    PLIST_ENTRY Link;
    SARESPONSE* Response;
    TCHAR* Value;

    Length = 2;
    for (Link = ResponseList->Flink;
         Link != ResponseList; Link = Link->Flink) {
        Response = CONTAINING_RECORD(Link, SARESPONSE, Link);
        if (Response->Protocol != Protocol) { continue; }
        Length += LSTRLEN(c_szMaxResponseEntry);
    }

    if (Length == 2) { return NULL; }

    Value = (TCHAR*)Malloc(Length * sizeof(TCHAR));
    if (!Value) { return NULL; }

    Value[0] = TEXT('\0');
    for (Link = ResponseList->Flink;
         Link != ResponseList; Link = Link->Flink) {
        Response = CONTAINING_RECORD(Link, SARESPONSE, Link);
        if (Response->Protocol != Protocol) { continue; }
        if (Value[0] != TEXT('\0')) {
            lstrcat(Value, TEXT(","));
        }
        if (Response->StartPort == Response->EndPort) {
            wsprintf(
                Buffer,
                c_szResponseFormat1,
                NTOHS(Response->StartPort)
                );
        } else {
            wsprintf(
                Buffer,
                c_szResponseFormat2,
                NTOHS(Response->StartPort),
                NTOHS(Response->EndPort)
                );
        }
        lstrcat(Value, Buffer);
    }
    return Value;
}


BOOL APIENTRY
SharedAccessResponseStringToList(
    UCHAR Protocol,
    TCHAR* Value,
    PLIST_ENTRY ListHead
    )
{
    TCHAR* Endp;
    ULONG EndPort;
    LONG Length;
    SARESPONSE* Response;
    ULONG StartPort;

    while (*Value) {
        //
        // Read either a single port or a range of ports.
        //
        if (!(StartPort = _tcstoul(Value, &Endp, 10))) {
            return FALSE;
        } else if (StartPort > USHRT_MAX) {
            return FALSE;
        }
        while(*Endp == ' ') Endp++; // consume whitespace
        if (!*Endp || *Endp == ',') {
            EndPort = StartPort;
            Value = (!*Endp ? Endp : Endp + 1);
        } else if (*Endp != '-') {
            return FALSE;
        } else if (!(EndPort = _tcstoul(++Endp, &Value, 10))) {
            return FALSE;
        } else if (EndPort > USHRT_MAX) {
            return FALSE;
        } else if (EndPort < StartPort) {
            return FALSE;
        } else if (*Value && *Value++ != ',') {
            return FALSE;
        }
        //
        // Allocate and append another response entry
        //
        Response = (SARESPONSE*)Malloc(sizeof(SARESPONSE));
        if (!Response) { return FALSE; }
        Response->Protocol = Protocol;
        Response->StartPort = HTONS((USHORT)StartPort);
        Response->EndPort = HTONS((USHORT)EndPort);
        InsertTailList(ListHead, &Response->Link);
    }
    return TRUE;
}

#if 0


BOOL
WritePrivateProfileStringUTF8(
    const TCHAR* Section,
    const TCHAR* Key,
    const TCHAR* Value,
    const TCHAR* Path
    )
{
    CHAR* KeyA;
    CHAR* PathA;
    CHAR* SectionA;
    BOOL Succeeded;
    CHAR* ValueA = NULL;

    if (!(SectionA = StrDupAFromT(Section))) {
        Succeeded = FALSE;
    } else {
        if (!(KeyA = StrDupAFromT(Key))) {
            Succeeded = FALSE;
        } else {
            if (Value && !(ValueA = StrDupAFromT(Value))) {
                Succeeded = FALSE;
            } else {
                if (!(PathA = StrDupAFromTAnsi(Path))) {
                    Succeeded = FALSE;
                } else {
                    Succeeded =
                        WritePrivateProfileStringA(
                            SectionA,
                            KeyA,
                            ValueA,
                            PathA
                            );
                    Free(PathA);
                }
                Free0(ValueA);
            }
            Free(KeyA);
        }
        Free(SectionA);
    }
    return Succeeded;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\common\uiutil\ipaddr.c ===
/* Copyright (c) 1991, Microsoft Corporation, all rights reserved
**
** ipaddr.c
** IP Address custom edit control
**
** 11/09/92 Greg Strange
**     Original code
**
** 09/07/95 Steve Cobb
**     Lifted TerryK/TRomano-updated version from NCPA, deleting IPDLL
**     stuff, and making minor RAS-related customizations.
*/

#include <windows.h> // Win32 core
#include <uiutil.h>  // Our public header
#include <debug.h>    // Trace and assert

#define IPADDRESS_CLASS TEXT("RasIpAddress")

// Extended style bit causes the ip address control to
// correct the ip address so that it is contiguous (for submasks)
#define IPADDR_EX_STYLE_CONTIGUOUS 0x1

/* Module instance handle set when custom control is initialized.
*/
static HANDLE g_hLibInstance = NULL;

/* String ID of message displayed when user enters a field value that is out
** of range.  Something like "You must choose a value from %1 to %2 for this
** field."  Set when the custom control is initialized.
*/
static DWORD g_dwBadIpAddrRange = 0;

/* String ID of the popup title when the range error above is displayed.  Set
** when the custom control is initialized.
*/
static DWORD g_dwErrorTitle = 0;


// The character that is displayed between address fields.
#define FILLER     TEXT('.')
#define SZFILLER   TEXT(".")
#define SPACE      TEXT(' ')
#define BACK_SPACE 8

/* Min, max values */
#define NUM_FIELDS      4
#define CHARS_PER_FIELD 3
#define HEAD_ROOM       1       // space at top of control
#define LEAD_ROOM       3       // space at front of control
#define MIN_FIELD_VALUE 0       // default minimum allowable field value
#define MAX_FIELD_VALUE 255     // default maximum allowable field value


// All the information unique to one control is stuffed in one of these
// structures in global memory and the handle to the memory is stored in the
// Windows extra space.

typedef struct tagFIELD {
    HANDLE      hWnd;
    WNDPROC     lpfnWndProc;
    BYTE        byLow;  // lowest allowed value for this field.
    BYTE        byHigh; // Highest allowed value for this field.
} FIELD;

typedef struct tagCONTROL {
    HWND        hwndParent;
    UINT        uiFieldWidth;
    UINT        uiFillerWidth;
    BOOL        fEnabled;
    BOOL        fPainted;
    BOOL        bControlInFocus;        // TRUE if the control is already in focus, dont't send another focus command
    BOOL        bCancelParentNotify;    // Don't allow the edit controls to notify parent if TRUE
    BOOL        fInMessageBox;  // Set when a message box is displayed so that
                                // we don't send a EN_KILLFOCUS message when
                                // we receive the EN_KILLFOCUS message for the
                                // current field.
    FIELD       Children[NUM_FIELDS];
} CONTROL;


// The following macros extract and store the CONTROL structure for a control.
#define IPADDRESS_EXTRA             (sizeof(DWORD) + sizeof(DWORD))
#define GET_CONTROL_HANDLE(hWnd)    ((HGLOBAL)(GetWindowLongPtr((hWnd), GWLP_USERDATA)))
#define SAVE_CONTROL_HANDLE(hWnd,x) (SetWindowLongPtr((hWnd), GWLP_USERDATA, (ULONG_PTR)x))
#define IPADDR_GET_SUBSTYLE(hwnd) (GetWindowLong((hwnd), 4))
#define IPADDR_SET_SUBSTYLE(hwnd, style) (SetWindowLong((hwnd), 4, (style)))

/* internal IPAddress function prototypes */
LRESULT FAR PASCAL IPAddressWndFn( HWND, UINT, WPARAM, LPARAM );
LRESULT FAR PASCAL IPAddressFieldProc(HWND, UINT, WPARAM, LPARAM);
BOOL SwitchFields(CONTROL FAR *, int, int, WORD, WORD);
void EnterField(FIELD FAR *, WORD, WORD);
BOOL ExitField(CONTROL FAR *, int iField);
int GetFieldValue(FIELD FAR *);


LOGFONT logfont;


void SetDefaultFont( )
{
    LANGID langid = PRIMARYLANGID(GetThreadLocale());
    BOOL fIsDbcs = (langid == LANG_CHINESE ||
                    langid == LANG_JAPANESE ||
                    langid == LANG_KOREAN);
    HDC hdc = GetDC(NULL);

    if(NULL == hdc)
    {
        return;
    }

    logfont.lfWidth            = 0;
    logfont.lfEscapement       = 0;
    logfont.lfOrientation      = 0;
    logfont.lfOutPrecision     = OUT_DEFAULT_PRECIS;
    logfont.lfClipPrecision    = CLIP_DEFAULT_PRECIS;
    logfont.lfQuality          = DEFAULT_QUALITY;
    logfont.lfPitchAndFamily   = VARIABLE_PITCH | FF_SWISS;
    logfont.lfUnderline        = 0;
    logfont.lfStrikeOut        = 0;
    logfont.lfItalic           = 0;
    logfont.lfWeight           = FW_NORMAL;


    if (fIsDbcs)
    {
        logfont.lfHeight       = -(9*GetDeviceCaps(hdc,LOGPIXELSY)/72);
        logfont.lfCharSet      = DEFAULT_CHARSET;
    }
    else
    {
        logfont.lfHeight       = -(8*GetDeviceCaps(hdc,LOGPIXELSY)/72);
        logfont.lfCharSet      = ANSI_CHARSET;
    }
    lstrcpy( logfont.lfFaceName,TEXT("MS Shell Dlg"));

    ReleaseDC(NULL, hdc);
}



/*
    IpAddrInit() - IPAddress custom control initialization
    call
        hInstance = library or application instance
        dwErrorTitle = String ID of error popup title
        dwBadIpAddrRange = String ID of bad range popup text, e.g.
            "You must choose a value between %1 and %2 for this field."
    return
        TRUE on success, FALSE on failure.

    This function does all the one time initialization of IPAddress custom
    controls.  Specifically it creates the IPAddress window class.
*/
int FAR PASCAL
IpAddrInit(
    IN HANDLE hInstance,
    IN DWORD  dwErrorTitle,
    IN DWORD  dwBadIpAddrRange )
{
    HGLOBAL            hClassStruct;
    LPWNDCLASS        lpClassStruct;

    /* register IPAddress window if necessary */
    if ( g_hLibInstance == NULL ) {

        /* allocate memory for class structure */
        hClassStruct = GlobalAlloc( GHND, (DWORD)sizeof(WNDCLASS) );
        if ( hClassStruct ) {

            /* lock it down */
            lpClassStruct = (LPWNDCLASS)GlobalLock( hClassStruct );
            if ( lpClassStruct ) {

                /* define class attributes */
                lpClassStruct->lpszClassName = IPADDRESS_CLASS;
                lpClassStruct->hCursor =       LoadCursor(NULL,IDC_IBEAM);
                lpClassStruct->lpszMenuName =  (LPCTSTR)NULL;
                lpClassStruct->style =         CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS|CS_GLOBALCLASS;
                lpClassStruct->lpfnWndProc =   IPAddressWndFn;
                lpClassStruct->hInstance =     hInstance;
                lpClassStruct->hIcon =         NULL;
                lpClassStruct->cbWndExtra =    IPADDRESS_EXTRA;
                lpClassStruct->hbrBackground = (HBRUSH)(COLOR_WINDOW + 1 );

                /* register IPAddress window class */
                g_hLibInstance = ( RegisterClass(lpClassStruct) ) ? hInstance : NULL;
                GlobalUnlock( hClassStruct );
            }
            GlobalFree( hClassStruct );
        }
    }
    SetDefaultFont();

    g_dwErrorTitle = dwErrorTitle;
    g_dwBadIpAddrRange = dwBadIpAddrRange;

    return( g_hLibInstance ? 1:0 );
}

// Use this function to force the ip address entered to
// be contiguous (series of 1's followed by a series of 0's).
// This is useful for entering valid submasks
//
// Returns NO_ERROR if successful, error code otherwise
//
DWORD APIENTRY IpAddr_ForceContiguous(HWND hwndIpAddr) {
    DWORD dwOldStyle;

    // Set the last error information so that we can
    // return an error correctly
    SetLastError(NO_ERROR);

    // Set the extended style of the given window so
    // that it descriminates the address entered.
    dwOldStyle = IPADDR_GET_SUBSTYLE(hwndIpAddr);
    IPADDR_SET_SUBSTYLE(hwndIpAddr, dwOldStyle | IPADDR_EX_STYLE_CONTIGUOUS);

    return GetLastError();
}


void FormatIPAddress(LPTSTR pszString, DWORD* dwValue)
{
    static TCHAR szBuf[CHARS_PER_FIELD+1];
    int nField, nPos;
    BOOL fFinish = FALSE;

    dwValue[0] = 0; dwValue[1] = 0; dwValue[2] = 0; dwValue[3] = 0;

    if (pszString[0] == 0)
        return;

    for( nField = 0, nPos = 0; !fFinish; nPos++)
    {
        if (( pszString[nPos]<TEXT('0')) || (pszString[nPos]>TEXT('9')))
        {
            // not a number
            nField++;
            fFinish = (nField == 4);
        }
        else
        {
            dwValue[nField] *= 10;
            dwValue[nField] += (pszString[nPos]-TEXT('0'));
        }
    }
}

// This function causes the ip address entered into hwndIpAddr to be
// corrected so that it is contiguous.
DWORD IpAddrMakeContiguous(HWND hwndIpAddr) {
    DWORD i, dwNewMask, dwMask;

    // Read in the current address
    SendMessage(hwndIpAddr, IP_GETADDRESS, 0, (LPARAM)&dwMask);

    // Find out where the first '1' is in binary going right to left
    dwNewMask = 0;
    for (i = 0; i < sizeof(dwMask)*8; i++) {
        dwNewMask |= 1 << i;
        if (dwNewMask & dwMask) {
            break;
        }
    }

    // At this point, dwNewMask is 000...0111...  If we inverse it,
    // we get a mask that can be or'd with dwMask to fill in all of
    // the holes.
    dwNewMask = dwMask | ~dwNewMask;

    // If the new mask is different, correct it here
    if (dwMask != dwNewMask) {
        WCHAR pszAddr[32];
        wsprintfW(pszAddr, L"%d.%d.%d.%d", FIRST_IPADDRESS (dwNewMask),
                                           SECOND_IPADDRESS(dwNewMask),
                                           THIRD_IPADDRESS (dwNewMask),
                                           FOURTH_IPADDRESS(dwNewMask));
        SendMessage(hwndIpAddr, IP_SETADDRESS, 0, (LPARAM)pszAddr);
    }

    return NO_ERROR;
}


LRESULT FAR PASCAL IPAddressWndFn( hWnd, wMsg, wParam, lParam )
    HWND            hWnd;
    UINT            wMsg;
    WPARAM            wParam;
    LPARAM            lParam;
{
    LONG lResult;
    HGLOBAL hControl;
    CONTROL *pControl;
    int i;

    lResult = TRUE;

    switch( wMsg )
    {

    case WM_HELP:
    {
        HWND hwndParent = GetParent(hWnd);
        HELPINFO* p = (HELPINFO*)lParam;

        p->hItemHandle = hWnd;
        p->iCtrlId = (INT) GetWindowLongPtr(hWnd, GWLP_ID);
        
        TRACE4( "IPAddressWndFn(HLP,t=%d,id=%d,h=$%08x,p=$%08x)",
            p->iContextType,p->iCtrlId,p->hItemHandle,hwndParent);

        SendMessage(hwndParent, WM_HELP, wParam, lParam);
        return 0;
    }        
    break;
        
    case WM_CONTEXTMENU:
    {
        SendMessage(GetParent(hWnd), WM_CONTEXTMENU, (WPARAM)GetParent(hWnd), 0);
        return 0;
    }
    break;
        
// use empty string (not NULL) to set to blank
    case WM_SETTEXT:
        {
            static TCHAR szBuf[CHARS_PER_FIELD+1];
            DWORD dwValue[4];
            LPTSTR pszString = (LPTSTR)lParam;

            if (!pszString)
                pszString = TEXT("0.0.0.0");

            FormatIPAddress(pszString, &dwValue[0]);

            hControl = GET_CONTROL_HANDLE(hWnd);
            pControl = (CONTROL *)GlobalLock(hControl);
            pControl->bCancelParentNotify = TRUE;

            for (i = 0; i < NUM_FIELDS; ++i)
            {
                if (pszString[0] == 0)
                {
                    szBuf[0] = 0;
                }
                else
                {
                    wsprintf(szBuf, TEXT("%d"), dwValue[i]);
                }
                SendMessage(pControl->Children[i].hWnd, WM_SETTEXT,
                                0, (LPARAM) (LPSTR) szBuf);
            }

            pControl->bCancelParentNotify = FALSE;

            SendMessage(pControl->hwndParent, WM_COMMAND,
                MAKEWPARAM(GetWindowLong(hWnd, GWL_ID), EN_CHANGE), (LPARAM)hWnd);

            GlobalUnlock(hControl);
        }
        break;

    case WM_GETTEXTLENGTH:
    case WM_GETTEXT:
        {
            int iFieldValue;
            int srcPos, desPos;
            DWORD dwValue[4];
            TCHAR pszResult[30];
            TCHAR *pszDest = (TCHAR *)lParam;

            hControl = GET_CONTROL_HANDLE(hWnd);
            pControl = (CONTROL *)GlobalLock(hControl);

            lResult = 0;
            dwValue[0] = 0;
            dwValue[1] = 0;
            dwValue[2] = 0;
            dwValue[3] = 0;
            for (i = 0; i < NUM_FIELDS; ++i)
            {
                iFieldValue = GetFieldValue(&(pControl->Children[i]));
                if (iFieldValue == -1)
                    iFieldValue = 0;
                else
                    ++lResult;
                dwValue[i] = iFieldValue;
            }
            wsprintf( pszResult, TEXT("%d.%d.%d.%d"), dwValue[0], dwValue[1], dwValue[2], dwValue[3] );
            if ( wMsg == WM_GETTEXTLENGTH )
            {
                lResult = lstrlen( pszResult );
            }
            else
            {
                for ( srcPos=0, desPos=0; (srcPos+1<(INT)wParam) && (pszResult[srcPos]!=TEXT('\0')); )
                {
                    pszDest[desPos++] = pszResult[srcPos++];
                }
                pszDest[desPos]=TEXT('\0');
                lResult = desPos;
            }
            GlobalUnlock(hControl);
        }
        break;

    case WM_GETDLGCODE :
        lResult = DLGC_WANTCHARS;
        break;

    case WM_NCCREATE:
        SetWindowLong(hWnd, GWL_EXSTYLE, (GetWindowLong(hWnd, GWL_EXSTYLE) | WS_EX_CLIENTEDGE));
        lResult = TRUE;
        break;

    case WM_CREATE : /* create pallette window */
        {
            HDC hdc;
            UINT uiFieldStart;
            FARPROC lpfnFieldProc;

            hControl = GlobalAlloc(GMEM_MOVEABLE, sizeof(CONTROL));
            if (hControl)
            {
                HFONT OldFont;
                RECT rect;

                #define LPCS    ((CREATESTRUCT *)lParam)

                pControl = (CONTROL *)GlobalLock(hControl);
                pControl->fEnabled = TRUE;
                pControl->fPainted = FALSE;
                pControl->fInMessageBox = FALSE;
                pControl->hwndParent = LPCS->hwndParent;
                pControl->uiFillerWidth = 1;
                pControl->bControlInFocus = FALSE;
                pControl->bCancelParentNotify = FALSE;

                hdc = GetDC(hWnd);
                GetClientRect(hWnd, &rect);
                OldFont = SelectObject( hdc, CreateFontIndirect(&logfont) );
                if( NULL != OldFont )
                {
                    HFONT NewFont;
                    GetCharWidth(hdc, FILLER, FILLER,
                                            (int *)(&pControl->uiFillerWidth));
                    NewFont = SelectObject(hdc, OldFont );
                    if( NULL != NewFont )
                    {
                        DeleteObject( NewFont );
                    }
                }
                ReleaseDC(hWnd, hdc);

                pControl->uiFieldWidth = (LPCS->cx
                                          - LEAD_ROOM
                                          - pControl->uiFillerWidth
                                              *(NUM_FIELDS-1))
                                                  / NUM_FIELDS;
                uiFieldStart = LEAD_ROOM;

                lpfnFieldProc = MakeProcInstance((FARPROC)IPAddressFieldProc,
                                                 LPCS->hInstance);

                for (i = 0; i < NUM_FIELDS; ++i)
                {
                    pControl->Children[i].byLow = MIN_FIELD_VALUE;
                    pControl->Children[i].byHigh = MAX_FIELD_VALUE;

                    pControl->Children[i].hWnd = CreateWindowEx(0,
                                        TEXT("Edit"),
                                        NULL,
                                        WS_CHILD | WS_VISIBLE |
                                        ES_CENTER,
                                        uiFieldStart,
                                        HEAD_ROOM,
                                        pControl->uiFieldWidth,
                                        (rect.bottom-rect.top),
                                        hWnd,
                                        (HMENU)UlongToPtr(i),
                                        LPCS->hInstance,
                                        (LPVOID)NULL);

                    SendMessage(pControl->Children[i].hWnd, EM_LIMITTEXT,
                                CHARS_PER_FIELD, 0L);

                    SendMessage(pControl->Children[i].hWnd, WM_SETFONT,
                                (WPARAM)CreateFontIndirect(&logfont), TRUE);

                    pControl->Children[i].lpfnWndProc =
                        (WNDPROC)GetWindowLongPtr(pControl->Children[i].hWnd,
                                                GWLP_WNDPROC);

                    SetWindowLongPtr(pControl->Children[i].hWnd,
                                  GWLP_WNDPROC, (ULONG_PTR)lpfnFieldProc);

                    uiFieldStart += pControl->uiFieldWidth
                                    + pControl->uiFillerWidth;
                }

                GlobalUnlock(hControl);
                SAVE_CONTROL_HANDLE(hWnd, hControl);

                #undef LPCS
            }
            else
                DestroyWindow(hWnd);
        }
        lResult = 0;
        break;

    case WM_PAINT: /* paint control window */
        {
            PAINTSTRUCT Ps;
            RECT rect;
            UINT uiFieldStart;
            COLORREF TextColor;
            COLORREF cRef;
            HFONT OldFont, NewFont, TmpFont;
            HBRUSH hbr;

            //Add return value check for bug 199026
            if ( BeginPaint(hWnd, (LPPAINTSTRUCT)&Ps) )
            {
                NewFont = CreateFontIndirect(&logfont);
                if (NewFont)
                {
                    OldFont = SelectObject( Ps.hdc, NewFont );
                    if (OldFont)
                    {
                        GetClientRect(hWnd, &rect);
                        hControl = GET_CONTROL_HANDLE(hWnd);
                        if (hControl)
                        {
                            pControl = (CONTROL *)GlobalLock(hControl);
                            if (pControl)
                            {
                                if (pControl->fEnabled)
                                {
                                    TextColor = GetSysColor(COLOR_WINDOWTEXT);
                                    cRef = GetSysColor(COLOR_WINDOW);

                                }
                                else
                                {
                                    TextColor = GetSysColor(COLOR_GRAYTEXT);
                                    cRef = GetSysColor(COLOR_3DFACE);
                                }

                                if (cRef)
                                    SetBkColor(Ps.hdc, cRef);

                                if (TextColor)
                                    SetTextColor(Ps.hdc, TextColor);


                                hbr = CreateSolidBrush(cRef);
                                if ( NULL != hbr )
                                {
                                    FillRect(Ps.hdc, &rect, hbr);
                                    DeleteObject(hbr);
                                }

                                SetRect(&rect, 
                                        0, 
                                        HEAD_ROOM, 
                                        pControl->uiFillerWidth, 
                                        (rect.bottom-rect.top));

                                ExtTextOut(Ps.hdc, 
                                           rect.left, 
                                           HEAD_ROOM, 
                                           ETO_OPAQUE, 
                                           &rect, 
                                           L" ", 
                                           1, 
                                           NULL);

                                for (i = 0; i < NUM_FIELDS-1; ++i)
                                {
                                    rect.left += pControl->uiFieldWidth + 
                                                 pControl->uiFillerWidth;

                                    rect.right += rect.left + 
                                                  pControl->uiFillerWidth;

                                    ExtTextOut(Ps.hdc, 
                                               rect.left, 
                                               HEAD_ROOM, 
                                               ETO_OPAQUE, 
                                               &rect, 
                                               SZFILLER, 
                                               1, 
                                               NULL);
                                }

                                pControl->fPainted = TRUE;

                                GlobalUnlock(hControl);
                            }
                        }
                    
                        TmpFont = SelectObject(Ps.hdc, OldFont);

                        if (TmpFont)
                        {
                            NewFont = TmpFont;
                        }
                        else
                        {
                            NewFont = OldFont;
                        }
                    }

                    DeleteObject(NewFont);
                }
            EndPaint(hWnd, &Ps);
            }
        }
        break;

    case WM_SETFOCUS : /* get focus - display caret */
        hControl = GET_CONTROL_HANDLE(hWnd);
        pControl = (CONTROL *)GlobalLock(hControl);
        EnterField(&(pControl->Children[0]), 0, CHARS_PER_FIELD);
        GlobalUnlock(hControl);
        break;

    case WM_LBUTTONDOWN : /* left button depressed - fall through */
        SetFocus(hWnd);
        break;

    case WM_ENABLE:
        {
            hControl = GET_CONTROL_HANDLE(hWnd);
            pControl = (CONTROL *)GlobalLock(hControl);
            pControl->fEnabled = (BOOL)wParam;
            for (i = 0; i < NUM_FIELDS; ++i)
            {
                EnableWindow(pControl->Children[i].hWnd, (BOOL)wParam);
            }
            if (pControl->fPainted)    InvalidateRect(hWnd, NULL, FALSE);
            GlobalUnlock(hControl);
        }
        break;

    case WM_DESTROY :
        hControl = GET_CONTROL_HANDLE(hWnd);
        pControl = (CONTROL *)GlobalLock(hControl);

// Restore all the child window procedures before we delete our memory block.
        for (i = 0; i < NUM_FIELDS; ++i)
        {
            SetWindowLongPtr(pControl->Children[i].hWnd, GWLP_WNDPROC,
                          (ULONG_PTR)pControl->Children[i].lpfnWndProc);
        }

        GlobalUnlock(hControl);
        GlobalFree(hControl);
        break;

    case WM_COMMAND:
        switch (HIWORD(wParam))
        {
// One of the fields lost the focus, see if it lost the focus to another field
// of if we've lost the focus altogether.  If its lost altogether, we must send
// an EN_KILLFOCUS notification on up the ladder.
        case EN_KILLFOCUS:
            {
                HWND hFocus;

                hControl = GET_CONTROL_HANDLE(hWnd);
                pControl = (CONTROL *)GlobalLock(hControl);

                if (!pControl->fInMessageBox)
                {
                    hFocus = GetFocus();
                    for (i = 0; i < NUM_FIELDS; ++i)
                        if (pControl->Children[i].hWnd == hFocus)
                            break;

                    if (i >= NUM_FIELDS)
                    {
                        // Before sending the message up the ladder, make sure that
                        // the ip address is contiguous if needed
                        if (IPADDR_GET_SUBSTYLE(hWnd) & IPADDR_EX_STYLE_CONTIGUOUS)
                            IpAddrMakeContiguous(hWnd);

                        SendMessage(pControl->hwndParent, WM_COMMAND,
                                    MAKEWPARAM(GetWindowLong(hWnd, GWL_ID),
                                    EN_KILLFOCUS), (LPARAM)hWnd);
                        pControl->bControlInFocus = FALSE;
                    }
                }
                GlobalUnlock(hControl);
            }
            break;

        case EN_SETFOCUS:
            {
                HWND hFocus;

                hControl = GET_CONTROL_HANDLE(hWnd);
                pControl = (CONTROL *)GlobalLock(hControl);

                if (!pControl->fInMessageBox)
                {
                    hFocus = (HWND)lParam;

                    for (i = 0; i < NUM_FIELDS; ++i)
                        if (pControl->Children[i].hWnd == hFocus)
                            break;

                    // send a focus message when the
                    if (i < NUM_FIELDS && pControl->bControlInFocus == FALSE)
                    {
                        SendMessage(pControl->hwndParent, WM_COMMAND,
                                    MAKEWPARAM(GetWindowLong(hWnd, GWL_ID),
                                    EN_SETFOCUS), (LPARAM)hWnd);

                    pControl->bControlInFocus = TRUE; // only set the focus once
                    }
                }
                GlobalUnlock(hControl);
            }
            break;

        case EN_CHANGE:
            hControl = GET_CONTROL_HANDLE(hWnd);
            pControl = (CONTROL *)GlobalLock(hControl);

            if (pControl->bCancelParentNotify == FALSE)
            {
                    SendMessage(pControl->hwndParent, WM_COMMAND,
                    MAKEWPARAM(GetWindowLong(hWnd, GWL_ID), EN_CHANGE), (LPARAM)hWnd);

            }

            GlobalUnlock(hControl);

            break;
        }
        break;

// Get the value of the IP Address.  The address is placed in the DWORD pointed
// to by lParam and the number of non-blank fields is returned.
    case IP_GETADDRESS:
        {
            int iFieldValue;
            DWORD dwValue;

            hControl = GET_CONTROL_HANDLE(hWnd);
            pControl = (CONTROL *)GlobalLock(hControl);

            lResult = 0;
            dwValue = 0;
            for (i = 0; i < NUM_FIELDS; ++i)
            {
                iFieldValue = GetFieldValue(&(pControl->Children[i]));
                if (iFieldValue == -1)
                    iFieldValue = 0;
                else
                    ++lResult;
                dwValue = (dwValue << 8) + iFieldValue;
            }
            *((DWORD *)lParam) = dwValue;

            GlobalUnlock(hControl);
        }
        break;

// Clear all fields to blanks.
    case IP_CLEARADDRESS:
        {
            hControl = GET_CONTROL_HANDLE(hWnd);
            pControl = (CONTROL *)GlobalLock(hControl);
            pControl->bCancelParentNotify = TRUE;
            for (i = 0; i < NUM_FIELDS; ++i)
            {
                SendMessage(pControl->Children[i].hWnd, WM_SETTEXT,
                            0, (LPARAM) (LPSTR) TEXT(""));
            }
            pControl->bCancelParentNotify = FALSE;
            SendMessage(pControl->hwndParent, WM_COMMAND,
                MAKEWPARAM(GetWindowLong(hWnd, GWL_ID), EN_CHANGE), (LPARAM)hWnd);

            GlobalUnlock(hControl);
        }
        break;

// Set the value of the IP Address.  The address is in the lParam with the
// first address byte being the high byte, the second being the second byte,
// and so on.  A lParam value of -1 removes the address.
    case IP_SETADDRESS:
        {
            static TCHAR szBuf[CHARS_PER_FIELD+1];
            DWORD dwValue[4];
            LPTSTR pszString = (LPTSTR)lParam;

            FormatIPAddress(pszString, &dwValue[0]);

            hControl = GET_CONTROL_HANDLE(hWnd);
            pControl = (CONTROL *)GlobalLock(hControl);

            pControl->bCancelParentNotify = TRUE;

            for (i = 0; i < NUM_FIELDS; ++i)
            {
                if (pszString[0] == 0)
                {
                    szBuf[0] =0;
                }
                else
                {
                    wsprintf(szBuf, TEXT("%d"), dwValue[i]);
                }
                SendMessage(pControl->Children[i].hWnd, WM_SETTEXT,
                                0, (LPARAM) (LPSTR) szBuf);
            }


            pControl->bCancelParentNotify = FALSE;

            SendMessage(pControl->hwndParent, WM_COMMAND,
                MAKEWPARAM(GetWindowLong(hWnd, GWL_ID), EN_CHANGE), (LPARAM)hWnd);

            GlobalUnlock(hControl);
        }
        break;

    case IP_SETRANGE:
        if (wParam < NUM_FIELDS)
        {
            hControl = GET_CONTROL_HANDLE(hWnd);
            pControl = (CONTROL *)GlobalLock(hControl);

            pControl->Children[wParam].byLow = LOBYTE(LOWORD(lParam));
            pControl->Children[wParam].byHigh = HIBYTE(LOWORD(lParam));

            GlobalUnlock(hControl);
        }
        break;

// Set the focus to this control.
// wParam = the field number to set focus to, or -1 to set the focus to the
// first non-blank field.
    case IP_SETFOCUS:
        hControl = GET_CONTROL_HANDLE(hWnd);
        pControl = (CONTROL *)GlobalLock(hControl);

        if (wParam >= NUM_FIELDS)
        {
            for (wParam = 0; wParam < NUM_FIELDS; ++wParam)
                if (GetFieldValue(&(pControl->Children[wParam])) == -1)   break;
            if (wParam >= NUM_FIELDS)    wParam = 0;
        }
        EnterField(&(pControl->Children[wParam]), 0, CHARS_PER_FIELD);

        GlobalUnlock(hControl);
        break;

// Determine whether all four subfields are blank
    case IP_ISBLANK:
        hControl = GET_CONTROL_HANDLE(hWnd);
        pControl = (CONTROL *)GlobalLock(hControl);

        lResult = TRUE;
        for (i = 0; i < NUM_FIELDS; ++i)
        {
            if (GetFieldValue(&(pControl->Children[i])) != -1)
            {
                lResult = FALSE;
                break;
            }
        }

        GlobalUnlock(hControl);
        break;

    default:
        lResult = (LONG) DefWindowProc( hWnd, wMsg, wParam, lParam );
        break;
    }
    return( lResult );
}




/*
    IPAddressFieldProc() - Edit field window procedure

    This function sub-classes each edit field.
*/
LRESULT FAR PASCAL IPAddressFieldProc(HWND hWnd,
                                       UINT wMsg,
                                       WPARAM wParam,
                                       LPARAM lParam)
{
    HANDLE hControl;
    CONTROL *pControl;
    FIELD *pField;
    HWND hControlWindow;
    WORD wChildID;
    LRESULT lresult;

    if (!(hControlWindow = GetParent(hWnd)))
        return 0;

    hControl = GET_CONTROL_HANDLE(hControlWindow);
    pControl = (CONTROL *)GlobalLock(hControl);
    wChildID = (WORD)GetWindowLong(hWnd, GWL_ID);
    pField = &(pControl->Children[wChildID]);
    if (pField->hWnd != hWnd)    return 0;

    switch (wMsg)
    {
    case WM_CONTEXTMENU:
    {
        SendMessage(GetParent(hWnd), WM_CONTEXTMENU, (WPARAM)GetParent(hWnd), 0);
        return 0;
    }
    break;
    
    case WM_HELP:
    {
        HWND hwndParent = GetParent(hWnd);
        HELPINFO* p = (HELPINFO*)lParam;

        p->hItemHandle = hWnd;
        p->iCtrlId = (INT) GetWindowLongPtr(hWnd, GWLP_ID);
        
        TRACE4( "IPAddressFieldProc(HLP,t=%d,id=%d,h=$%08x,p=$%08x)",
            p->iContextType,p->iCtrlId,p->hItemHandle,hwndParent);

        SendMessage(hwndParent, WM_HELP, wParam, lParam);
        return 0;
    }        
    break;
        
    case WM_DESTROY:
        DeleteObject( (HGDIOBJ)SendMessage( hWnd, WM_GETFONT, 0, 0 ));
        return 0;
    case WM_CHAR:

// Typing in the last digit in a field, skips to the next field.
        if (wParam >= TEXT('0') && wParam <= TEXT('9'))
        {
            DWORD dwResult;

            dwResult = (DWORD)CallWindowProc(pControl->Children[wChildID].lpfnWndProc,
                                            hWnd, wMsg, wParam, lParam);
            dwResult = (DWORD) SendMessage(hWnd, EM_GETSEL, 0, 0L);

            if (dwResult == MAKELPARAM(CHARS_PER_FIELD, CHARS_PER_FIELD)
                && ExitField(pControl, wChildID)
                && wChildID < NUM_FIELDS-1)
            {
                EnterField(&(pControl->Children[wChildID+1]),
                                0, CHARS_PER_FIELD);
            }
            GlobalUnlock( hControl );
            return dwResult;
        }

// spaces and periods fills out the current field and then if possible,
// goes to the next field.
        else if (wParam == FILLER || wParam == SPACE )
        {
            DWORD dwResult;
            dwResult = (DWORD) SendMessage(hWnd, EM_GETSEL, 0, 0L);
            if (dwResult != 0L && HIWORD(dwResult) == LOWORD(dwResult)
                && ExitField(pControl, wChildID))
            {
                if (wChildID >= NUM_FIELDS-1)
                    MessageBeep((UINT)-1);
                else
                {
                    EnterField(&(pControl->Children[wChildID+1]),
                                    0, CHARS_PER_FIELD);
                }
            }
            GlobalUnlock( hControl );
            return 0;
        }

// Backspaces go to the previous field if at the beginning of the current field.
// Also, if the focus shifts to the previous field, the backspace must be
// processed by that field.
        else if (wParam == BACK_SPACE)
        {
            if (wChildID > 0 && SendMessage(hWnd, EM_GETSEL, 0, 0L) == 0L)
            {
                if (SwitchFields(pControl, wChildID, wChildID-1,
                              CHARS_PER_FIELD, CHARS_PER_FIELD)
                    && SendMessage(pControl->Children[wChildID-1].hWnd,
                        EM_LINELENGTH, 0, 0L) != 0L)
                {
                    SendMessage(pControl->Children[wChildID-1].hWnd,
                                wMsg, wParam, lParam);
                }
                GlobalUnlock( hControl );
                return 0;
            }
        }

// Any other printable characters are not allowed.
        else if (wParam > SPACE)
        {
            MessageBeep((UINT)-1);
            GlobalUnlock( hControl );
            return 0;
        }
        break;

    case WM_KEYDOWN:
        switch (wParam)
        {

// Arrow keys move between fields when the end of a field is reached.
        case VK_LEFT:
        case VK_RIGHT:
        case VK_UP:
        case VK_DOWN:
            if (GetKeyState(VK_CONTROL) < 0)
            {
                if ((wParam == VK_LEFT || wParam == VK_UP) && wChildID > 0)
                {
                    SwitchFields(pControl, wChildID, wChildID-1,
                                  0, CHARS_PER_FIELD);
                    GlobalUnlock( hControl );
                    return 0;
                }
                else if ((wParam == VK_RIGHT || wParam == VK_DOWN)
                         && wChildID < NUM_FIELDS-1)
                {
                    SwitchFields(pControl, wChildID, wChildID+1,
                                      0, CHARS_PER_FIELD);
                    GlobalUnlock( hControl );
                    return 0;
                }
            }
            else
            {
                DWORD dwResult;
                WORD wStart, wEnd;

                dwResult = (DWORD) SendMessage(hWnd, EM_GETSEL, 0, 0L);
                wStart = LOWORD(dwResult);
                wEnd = HIWORD(dwResult);
                if (wStart == wEnd)
                {
                    if ((wParam == VK_LEFT || wParam == VK_UP)
                        && wStart == 0
                        && wChildID > 0)
                    {
                        SwitchFields(pControl, wChildID, wChildID-1,
                                          CHARS_PER_FIELD, CHARS_PER_FIELD);
                        GlobalUnlock( hControl );
                        return 0;
                    }
                    else if ((wParam == VK_RIGHT || wParam == VK_DOWN)
                             && wChildID < NUM_FIELDS-1)
                    {
                        dwResult = (DWORD)SendMessage(hWnd, EM_LINELENGTH, 0, 0L);
                        if (wStart >= dwResult)
                        {
                            SwitchFields(pControl, wChildID, wChildID+1, 0, 0);
                            GlobalUnlock( hControl );
                            return 0;
                        }
                    }
                }
            }
            break;

// Home jumps back to the beginning of the first field.
        case VK_HOME:
            if (wChildID > 0)
            {
                SwitchFields(pControl, wChildID, 0, 0, 0);
                GlobalUnlock( hControl );
                return 0;
            }
            break;

// End scoots to the end of the last field.
        case VK_END:
            if (wChildID < NUM_FIELDS-1)
            {
                SwitchFields(pControl, wChildID, NUM_FIELDS-1,
                                CHARS_PER_FIELD, CHARS_PER_FIELD);
                GlobalUnlock( hControl );
                return 0;
            }
            break;


        } // switch (wParam)

        break;

    case WM_KILLFOCUS:
        if ( !ExitField( pControl, wChildID ))
        {
            GlobalUnlock( hControl );
            return 0;
        }

    } // switch (wMsg)

    lresult = CallWindowProc(pControl->Children[wChildID].lpfnWndProc,
        hWnd, wMsg, wParam, lParam);
    GlobalUnlock( hControl );
    return lresult;
}




/*
    Switch the focus from one field to another.
    call
        pControl = Pointer to the CONTROL structure.
        iOld = Field we're leaving.
        iNew = Field we're entering.
        hNew = Window of field to goto
        wStart = First character selected
        wEnd = Last character selected + 1
    returns
        TRUE on success, FALSE on failure.

    Only switches fields if the current field can be validated.
*/
BOOL SwitchFields(CONTROL *pControl, int iOld, int iNew, WORD wStart, WORD wEnd)
{
    if (!ExitField(pControl, iOld))    return FALSE;
    EnterField(&(pControl->Children[iNew]), wStart, wEnd);
    return TRUE;
}



/*
    Set the focus to a specific field's window.
    call
        pField = pointer to field structure for the field.
        wStart = First character selected
        wEnd = Last character selected + 1
*/
void EnterField(FIELD *pField, WORD wStart, WORD wEnd)
{
    SetFocus(pField->hWnd);
    SendMessage(pField->hWnd, EM_SETSEL, wStart, wEnd);
}


/*
    Exit a field.
    call
        pControl = pointer to CONTROL structure.
        iField = field number being exited.
    returns
        TRUE if the user may exit the field.
        FALSE if he may not.
*/
BOOL ExitField(CONTROL  *pControl, int iField)
{
    HWND hControlWnd;
    HWND hDialog;
    WORD wLength;
    FIELD *pField;
    static TCHAR szBuf[CHARS_PER_FIELD+1];
    int i,j;

    pField = &(pControl->Children[iField]);
    *(WORD *)szBuf = (sizeof(szBuf)/sizeof(TCHAR)) - 1;
    wLength = (WORD)SendMessage(pField->hWnd,EM_GETLINE,0,(LPARAM)szBuf);
    if (wLength != 0)
    {
        szBuf[wLength] = TEXT('\0');
        for (j=0,i=0;j<(INT)wLength;j++)
        {
            i=i*10+szBuf[j]-TEXT('0');
        }
        if (i < (int)(UINT)pField->byLow || i > (int)(UINT)pField->byHigh)
        {
            if ( i < (int)(UINT) pField->byLow )
            {
                /* too small */
                wsprintf(szBuf, TEXT("%d"), (int)(UINT)pField->byLow );
            }
            else
            {
                /* must be bigger */
                wsprintf(szBuf, TEXT("%d"), (int)(UINT)pField->byHigh );
            }
            SendMessage(pField->hWnd, WM_SETTEXT, 0, (LPARAM) (LPSTR) szBuf);
            if ((hControlWnd = GetParent(pField->hWnd)) != NULL
                && (hDialog = GetParent(hControlWnd)) != NULL)
            {
                MSGARGS msgargs;
                TCHAR   szLow[ 50 ];
                TCHAR   szHigh[ 50 ];

                pControl->fInMessageBox = TRUE;

                ZeroMemory( &msgargs, sizeof(msgargs) );
                msgargs.dwFlags = MB_ICONEXCLAMATION + MB_OK;
                wsprintf( szLow, TEXT("%d"), (int )pField->byLow );
                msgargs.apszArgs[ 0 ] = szLow;
                wsprintf( szHigh, TEXT("%d"), (int )pField->byHigh );
                msgargs.apszArgs[ 1 ] = szHigh;

                MsgDlgUtil( hDialog, g_dwBadIpAddrRange,
                    &msgargs, g_hLibInstance, g_dwErrorTitle );

                pControl->fInMessageBox = FALSE;
                SendMessage(pField->hWnd, EM_SETSEL, 0, CHARS_PER_FIELD);
                return FALSE;
            }
        }
    }
    return TRUE;
}


/*
    Get the value stored in a field.
    call
        pField = pointer to the FIELD structure for the field.
    returns
        The value (0..255) or -1 if the field has not value.
*/
int GetFieldValue(FIELD *pField)
{
    WORD wLength;
    static TCHAR szBuf[CHARS_PER_FIELD+1];
    INT i,j;

    *(WORD *)szBuf = (sizeof(szBuf)/sizeof(TCHAR)) - 1;
    wLength = (WORD)SendMessage(pField->hWnd,EM_GETLINE,0,(LPARAM)szBuf);
    if (wLength != 0)
    {
        szBuf[wLength] = TEXT('\0');
        for (j=0,i=0;j<(INT)wLength;j++)
        {
            i=i*10+szBuf[j]-TEXT('0');
        }
        return i;
    }
    else
        return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\common\uiutil\lvx.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** lvx.c
** Listview extension routines
** Listed alphabetically
**
** 11/25/95 Steve Cobb
**     Some adapted from \\ftp\data\softlib\mslfiles\odlistvw.exe sample code.
*/

#include <windows.h>  // Win32 root
#include <windowsx.h> // Win32 macro extensions
#include <commctrl.h> // Win32 common controls
#include <debug.h>    // Trace and assert
#include <uiutil.h>   // Our public header
#include <lvx.rch>    // Our resource constants


/* List view of check boxes state indices.
*/
#define SI_Unchecked 1
#define SI_Checked   2
#define SI_DisabledUnchecked 3
#define SI_DisabledChecked 4

/* Text indents within a column in pixels.  If you mess with the dx, you're
** asking for misalignment problems with the header labels.  BTW, the first
** column doesn't line up with it's header if there are no icons.  Regular
** list view has this problem, too.  If you try to fix this you'll wind up
** duplicating the AUTOSIZE_USEHEADER option of ListView_SetColumnWidth.
** Should be able to change the dy without causing problems.
*/
#define LVX_dxColText 4
#define LVX_dyColText 1

/* Guaranteed vertical space between icons.  Should be able to mess with this
** without causing problems.
*/
#define LVX_dyIconSpacing 1

/* The atom identifying our context property suitable for use by the Windows
** XxxProp APIs.  A Prop is used to associate context information (the address
** of the WNDPROC we subclassed) with a "list view of check boxes" window.
*/
static LPCWSTR g_lvxcbContextId = NULL;


/*----------------------------------------------------------------------------
** Local prototypes
**----------------------------------------------------------------------------
*/
LRESULT APIENTRY
LvxcbProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
LvxDrawItem(
    IN DRAWITEMSTRUCT* pdis,
    IN PLVXCALLBACK    pLvxCallback );

BOOL
LvxMeasureItem(
    IN     HWND               hwnd,
    IN OUT MEASUREITEMSTRUCT* pmis );


/*----------------------------------------------------------------------------
** ListView of check boxes
**----------------------------------------------------------------------------
*/

BOOL
ListView_GetCheck(
    IN HWND hwndLv,
    IN INT  iItem )

    /* Returns true if the check box of item 'iItem' of listview of checkboxes
    ** 'hwndLv' is checked, false otherwise.  This function works on disabled
    ** check boxes as well as enabled ones.
    */
{
    UINT unState;

    unState = ListView_GetItemState( hwndLv, iItem, LVIS_STATEIMAGEMASK );
    return !!((unState == INDEXTOSTATEIMAGEMASK( SI_Checked )) ||
              (unState == INDEXTOSTATEIMAGEMASK( SI_DisabledChecked )));
}

BOOL
ListView_IsCheckDisabled (
        IN HWND hwndLv,
        IN INT  iItem) 

    /* Returns true if the check box of item 'iItem' of listview of checkboxes
    ** 'hwndLv' is disabled, false otherwise.  
    */
{
    UINT unState;
    unState = ListView_GetItemState( hwndLv, iItem, LVIS_STATEIMAGEMASK );

    if ((unState == INDEXTOSTATEIMAGEMASK( SI_DisabledChecked )) ||
        (unState == INDEXTOSTATEIMAGEMASK( SI_DisabledUnchecked )))
        return TRUE;

    return FALSE;
}       

VOID
ListView_DisableCheck (
        IN HWND hwndLv,
        IN INT  iItem) 

    /* Disables a check box of item 'iItem' of listview of checkboxes.  Once
    ** disabled, ListView_SetCheck will have no effect on the item until
    ** ListView_EnableCheck(...) is called for this item.  Likewise, there is no 
    ** way through the UI to change the check of this item until it is enabled.
    ** Calling this function on a disabled check has no effect.
    */
{
    BOOL fCheck;

    fCheck = ListView_GetCheck(hwndLv, iItem);
    
    ListView_SetItemState( hwndLv, iItem,
        INDEXTOSTATEIMAGEMASK( (fCheck) ? SI_DisabledChecked : SI_DisabledUnchecked),
        LVIS_STATEIMAGEMASK );
}

VOID
ListView_EnableCheck (
        IN HWND hwndLv,
        IN INT  iItem) 

    /* Reverses the effect of ListView_DisableCheck.
    */
{
    BOOL fCheck;

    fCheck = ListView_GetCheck(hwndLv, iItem);
    
    ListView_SetItemState( hwndLv, iItem,
        INDEXTOSTATEIMAGEMASK( (fCheck) ? SI_Checked : SI_Unchecked ),
        LVIS_STATEIMAGEMASK );
}


UINT
ListView_GetCheckedCount(
    IN HWND hwndLv )

    /* Returns the number of checked items in 'hwndLv' regardless of whether
    ** they are disabled.
    */
{
    UINT c = 0;
    INT  i = -1;

    while ((i = ListView_GetNextItem( hwndLv, i, LVNI_ALL )) >= 0)
    {
        if (ListView_GetCheck( hwndLv, i ))
            ++c;
    }

    return c;
}


BOOL
ListView_InstallChecks(
    IN HWND      hwndLv,
    IN HINSTANCE hinst )

    /* Initialize "list of checkbox" handling for listview 'hwndLv'.  'Hinst'
    ** is the module instance containing the two checkbox icons.  See LVX.RC.
    **
    ** Returns true if successful, false otherwise.  Caller must eventually
    ** call 'ListView_UninstallChecks', typically in WM_DESTROY processing.
    */
{
    HICON      hIcon;
    HIMAGELIST himl;
    WNDPROC    pOldProc;
    //Add this for RTL(right to left, mirrored windows version)
    //whistler bug 41349       gangz
    //
    BOOL       fMirrored=FALSE; 
    DWORD      dwLayout;

        
    // pmay: 397395
    //
    // Prevent endless loops resulting from accidentally calling this
    // api twice.
    //
    pOldProc = (WNDPROC)GetWindowLongPtr(hwndLv, GWLP_WNDPROC);
    if (pOldProc == LvxcbProc)
    {
        return TRUE;
    }

    //get current application's layout (RTL or normal)      gangz
    //  for whistler bug 41349
    //There are two ways:
    //(1) use  GetWindowLong() with GWL_EXSTYLE for WS_EX_LAYOUTRTL style if 
    //    you have a window handler available
    //(2) use GetProcessDefaultLayout() to get the layout for the current 
    //    process, and compare that against LAYOUT_RTL  
    //
    dwLayout = GetWindowLong(hwndLv, GWL_EXSTYLE);
    if ( WS_EX_LAYOUTRTL & dwLayout )
    {
        fMirrored = TRUE;
     }

    /* Build checkbox image lists.
    */
    himl = ImageList_Create(
               GetSystemMetrics( SM_CXSMICON ),
               GetSystemMetrics( SM_CYSMICON ),
               ILC_MASK, 2, 2 );

    /* The order these are added is significant since it implicitly
    ** establishes the state indices matching SI_Unchecked and SI_Checked.
    */
    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_Unchecked ) );
    if ( NULL != hIcon )
    {
        ImageList_AddIcon( himl, hIcon );
        DeleteObject( hIcon );
    }

    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( fMirrored?IID_CheckedRTL : IID_Checked ) );
    if ( NULL != hIcon )
    {
        ImageList_AddIcon( himl, hIcon );
        DeleteObject( hIcon );
    }

    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_DisabledUnchecked ) );
    if ( NULL != hIcon )
    {
        ImageList_AddIcon( himl, hIcon );
        DeleteObject( hIcon );
    }

    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( fMirrored?IID_DisabledCheckedRTL : IID_DisabledChecked ) );
    if ( NULL != hIcon )
    {
        ImageList_AddIcon( himl, hIcon );
        DeleteObject( hIcon );
    }

    ListView_SetImageList( hwndLv, himl, LVSIL_STATE );

    /* Register atom for use in the Windows XxxProp calls which are used to
    ** associate the old WNDPROC with the listview window handle.
    */
    if (!g_lvxcbContextId)
        g_lvxcbContextId = (LPCWSTR )GlobalAddAtom( L"RASLVXCB" );
    if (!g_lvxcbContextId)
        return FALSE;

    /* Subclass the current window procedure.
    */
    pOldProc = (WNDPROC)SetWindowLongPtr(
                                hwndLv, GWLP_WNDPROC, (ULONG_PTR)LvxcbProc );

    return SetProp( hwndLv, g_lvxcbContextId, (HANDLE )pOldProc );
}


VOID
ListView_SetCheck(
    IN HWND hwndLv,
    IN INT  iItem,
    IN BOOL fCheck )

    /* Sets the check mark on item 'iItem' of listview of checkboxes 'hwndLv'
    ** to checked if 'fCheck' is true or unchecked if false.
    */
{
    NM_LISTVIEW nmlv;

    if (ListView_IsCheckDisabled(hwndLv, iItem))
        return;

    ListView_SetItemState( hwndLv, iItem,
        INDEXTOSTATEIMAGEMASK( (fCheck) ? SI_Checked : SI_Unchecked ),
        LVIS_STATEIMAGEMASK );

    nmlv.hdr.code = LVXN_SETCHECK;
    nmlv.hdr.hwndFrom = hwndLv;
    nmlv.iItem = iItem;

    FORWARD_WM_NOTIFY(
        GetParent(hwndLv), GetDlgCtrlID(hwndLv), &nmlv, SendMessage
        );
}


VOID
ListView_UninstallChecks(
    IN HWND hwndLv )

    /* Uninstalls "listview of check boxes" handling from list view 'hwndLv'.
    */
{
    WNDPROC pOldProc;

    pOldProc = (WNDPROC)GetProp( hwndLv, g_lvxcbContextId );
    if (pOldProc)
    {
        /* Un-subclass so it can terminate without access to the context.
        */
        SetWindowLongPtr( hwndLv, GWLP_WNDPROC, (ULONG_PTR)pOldProc );
    }

    RemoveProp( hwndLv, g_lvxcbContextId );
}


LRESULT APIENTRY
LvxcbProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* List view subclass window procedure to trap toggle-check events.
    */
{
    WNDPROC pOldProc;
    INT     iItem;
    BOOL    fSet;
    BOOL    fClear;
    BOOL    fToggle;

    iItem = -1;
    fSet = fClear = fToggle = FALSE;

    if (unMsg == WM_LBUTTONDOWN)
    {
        LV_HITTESTINFO info;

        /* Left mouse button pressed over checkbox icon toggles state.
        ** Normally, we'd use LVHT_ONITEMSTATEICON and be done with it, but we
        ** want to work with our cool owner-drawn list view extensions in
        ** which case the control doesn't know where the icon is on the item,
        ** so it returns a hit anywhere on the item anyway.
        */
        ZeroMemory( &info, sizeof(info) );
        info.pt.x = LOWORD( lparam );
        info.pt.y = HIWORD( lparam );
        info.flags = LVHT_ONITEM;
        iItem = ListView_HitTest( hwnd, &info );

        if (iItem >= 0)
        {
            /* OK, it's over item 'iItem'.  Now figure out if it's over the
            ** checkbox.  Note this currently doesn't account for use of the
            ** "indent" feature on an owner-drawn item.
            */
            if ((INT )(LOWORD( lparam )) >= GetSystemMetrics( SM_CXSMICON ))
                iItem = -1;
            else
                fToggle = TRUE;
        }
    }
    else if (unMsg == WM_LBUTTONDBLCLK)
    {
        LV_HITTESTINFO info;

        /* Left mouse button double clicked over any area toggles state.
        ** Normally, we'd use LVHT_ONITEMSTATEICON and be done with it, but we
        ** want to work with our cool owner-drawn list view extensions in
        ** which case the control doesn't know where the icon is on the item,
        ** so it returns a hit anywhere on the item anyway.
        */
        ZeroMemory( &info, sizeof(info) );
        info.pt.x = LOWORD( lparam );
        info.pt.y = HIWORD( lparam );
        info.flags = LVHT_ONITEM;
        iItem = ListView_HitTest( hwnd, &info );

        if (iItem >= 0)
        {
            /* OK, it's over item 'iItem'.  If the click does not occur
             * over a checkbox, inform the parent of the double click.
            */
            if ((INT )(LOWORD( lparam )) >= GetSystemMetrics( SM_CXSMICON )) {
                NM_LISTVIEW nmlv;
                nmlv.hdr.code = LVXN_DBLCLK;
                nmlv.hdr.hwndFrom = hwnd;
                nmlv.iItem = iItem;
                
                FORWARD_WM_NOTIFY(
                    GetParent(hwnd), GetDlgCtrlID(hwnd), &nmlv, SendMessage);
                    
                iItem = -1;
            }

            /*
             * Otherwise, toggle the state.
            */
            else
                fToggle = TRUE;
        }
    }
    else if (unMsg == WM_CHAR)
    {
        /* Space bar pressed with item selected toggles check.
        ** Plus or Equals keys set check.
        ** Minus key clears check.
        */
        switch (wparam)
        {
            case TEXT(' '):
                fToggle = TRUE;
                break;

            case TEXT('+'):
            case TEXT('='):
                fSet = TRUE;
                break;

            case TEXT('-'):
                fClear = TRUE;
                break;
        }

        if (fToggle || fSet || fClear)
            iItem = ListView_GetNextItem( hwnd, -1, LVNI_SELECTED );
    }
    else if (unMsg == WM_KEYDOWN)
    {
        /* Left arrow becomes up arrow and right arrow becomes down arrow so
        ** the list of checkboxes behaves just like a static group of
        ** checkboxes.
        */
        if (wparam == VK_LEFT)
            wparam = VK_UP;
        else if (wparam == VK_RIGHT)
            wparam = VK_DOWN;
    }

    if (iItem >= 0)
    {

        /* If we are handling the spacebar, plus, minus, or equals,
        ** the change we make applies to all the selected items;
        ** hence the do {} while(WM_CHAR).
        */
        
        do {

            if (fToggle)
            {
                UINT unOldState;
                BOOL fCheck;
    
                fCheck = ListView_GetCheck( hwnd, iItem );
                ListView_SetCheck( hwnd, iItem, !fCheck );
            }
            else if (fSet)
            {
                if (!ListView_GetCheck( hwnd, iItem ))
                    ListView_SetCheck( hwnd, iItem, TRUE );
            }
            else if (fClear)
            {
                if (ListView_GetCheck( hwnd, iItem ))
                    ListView_SetCheck( hwnd, iItem, FALSE );
            }

            iItem = ListView_GetNextItem(hwnd, iItem, LVNI_SELECTED);

        } while(iItem >= 0 && unMsg == WM_CHAR);

        if (fSet || fClear) {

            /* Don't pass to listview to avoid beep.
            */
            return 0;
        }
    }

    pOldProc = (WNDPROC )GetProp( hwnd, g_lvxcbContextId );
    if (pOldProc)
        return CallWindowProc( pOldProc, hwnd, unMsg, wparam, lparam );

    return 0;
}


/*----------------------------------------------------------------------------
** Enhanced ListView
**----------------------------------------------------------------------------
*/

BOOL
ListView_OwnerHandler(
    IN HWND         hwnd,
    IN UINT         unMsg,
    IN WPARAM       wparam,
    IN LPARAM       lparam,
    IN PLVXCALLBACK pLvxCallback )

    /* Handler that, when installed, turns a regular report-view-only list
    ** view (but with style LVS_OWNERDRAWFIXED) into an enhanced list view
    ** with full width selection bar and other custom column display options.
    ** It should appear in list view owner's dialog proc as follows:
    **
    **     BOOL
    **     MyDlgProc(
    **         IN HWND   hwnd,
    **         IN UINT   unMsg,
    **         IN WPARAM wparam,
    **         IN LPARAM lparam )
    **     {
    **         if (ListView_OwnerHandler(
    **                 hwnd, unMsg, wParam, lParam, MyLvxCallback ))
    **             return TRUE;
    **
    **         <the rest of your stuff here>
    **     }
    **
    ** 'PLvxCallback' is caller's callback routine that provides information
    ** about drawing columns and other options.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    /* This routine executes on EVERY message thru the dialog so keep it
    ** efficient, please.
    */
    switch (unMsg)
    {
        case WM_DRAWITEM:
            return LvxDrawItem( (DRAWITEMSTRUCT* )lparam, pLvxCallback );

        case WM_MEASUREITEM:
            return LvxMeasureItem( hwnd, (MEASUREITEMSTRUCT* )lparam );
    }

    return FALSE;
}


BOOL
LvxDrawItem(
    IN DRAWITEMSTRUCT* pdis,
    IN PLVXCALLBACK    pLvxCallback )

    /* Respond to WM_DRAWITEM by drawing the list view item.  'Pdis' is the
    ** information sent by the system.  'PLvxCallback' is caller's callback to
    ** get information about drawing the control.
    **
    ** Returns true is processed the message, false otherwise.
    */
{
    LV_ITEM      item;
    INT          i;
    INT          dxState;
    INT          dyState;
    INT          dxSmall;
    INT          dySmall;
    INT          dxIndent;
    UINT         uiStyleState;
    UINT         uiStyleSmall;
    HIMAGELIST   himlState;
    HIMAGELIST   himlSmall;
    LVXDRAWINFO* pDrawInfo;
    RECT         rc;
    RECT         rcClient;
    BOOL         fEnabled;
    BOOL         fSelected;
    HDC          hdc;
    HFONT        hfont;


    TRACE3("LvxDrawItem,i=%d,a=$%X,s=$%X",
        pdis->itemID,pdis->itemAction,pdis->itemState);

    /* Make sure this is something we want to handle.
    */
    if (pdis->CtlType != ODT_LISTVIEW)
        return FALSE;

    if (pdis->itemAction != ODA_DRAWENTIRE
        && pdis->itemAction != ODA_SELECT
        && pdis->itemAction != ODA_FOCUS)
    {
        return TRUE;
    }

    /* Get item information from the list view.
    */
    ZeroMemory( &item, sizeof(item) );
    item.mask = LVIF_IMAGE + LVIF_STATE;
    item.iItem = pdis->itemID;
    item.stateMask = LVIS_STATEIMAGEMASK;
    if (!ListView_GetItem( pdis->hwndItem, &item ))
    {
        TRACE("LvxDrawItem GetItem failed");
        return TRUE;
    }

    /* Stash some useful stuff for reference later.
    */
    fEnabled = IsWindowEnabled( pdis->hwndItem )
               && !(pdis->itemState & ODS_DISABLED);
    fSelected = (pdis->itemState & ODS_SELECTED);
    GetClientRect( pdis->hwndItem, &rcClient );

    /* Callback owner to get drawing information.
    */
    ASSERT(pLvxCallback);
    pDrawInfo = pLvxCallback( pdis->hwndItem, pdis->itemID );
    ASSERT(pDrawInfo);

    /* Get image list icon sizes now, though we draw them last because their
    ** background is set up during first column text output.
    */
    dxState = dyState = 0;
    himlState = ListView_GetImageList( pdis->hwndItem, LVSIL_STATE );
    if (himlState)
        ImageList_GetIconSize( himlState, &dxState, &dyState );

    dxSmall = dySmall = 0;
    himlSmall = ListView_GetImageList( pdis->hwndItem, LVSIL_SMALL );
    if (himlSmall)
        ImageList_GetIconSize( himlSmall, &dxSmall, &dySmall );

    uiStyleState = uiStyleSmall = ILD_TRANSPARENT;

    /* Figure out the number of pixels to indent the item, if any.
    */
    if (pDrawInfo->dxIndent >= 0)
        dxIndent = pDrawInfo->dxIndent;
    else
    {
        if (dxSmall > 0)
            dxIndent = dxSmall;
        else
            dxIndent = GetSystemMetrics( SM_CXSMICON );
    }

    /* Get a device context for the window and set it up with the font the
    ** control says it's using.  (Can't use the one that comes in the
    ** DRAWITEMSTRUCT because sometimes it has the wrong rectangle, see bug
    ** 13106)
    */
    hdc = GetDC( pdis->hwndItem );

    if(NULL == hdc)
    {
        return FALSE;
    }
    
    hfont = (HFONT )SendMessage( pdis->hwndItem, WM_GETFONT, 0, 0 );
    if (hfont)
        SelectObject( hdc, hfont );

    /* Set things up as if we'd just got done processing a column that ends
    ** after the icons, then loop thru each column from left to right.
    */
    rc.right = pdis->rcItem.left + dxIndent + dxState + dxSmall;
    rc.top = pdis->rcItem.top;
    rc.bottom = pdis->rcItem.bottom;

    for (i = 0; i < pDrawInfo->cCols; ++i)
    {
        TCHAR  szText[ LVX_MaxColTchars + 1 ];
        TCHAR* pszText;
        INT    dxCol;

        /* Get the column width, adding any index and icon width to the first
        ** column.
        */
        // For whistler bug 458513 39081
        //
        ZeroMemory(szText,sizeof(szText));
        dxCol = ListView_GetColumnWidth( pdis->hwndItem, i );
        if (i == 0)
            dxCol -= dxIndent + dxState + dxSmall;

        szText[ 0 ] = TEXT('\0');
        ListView_GetItemText( pdis->hwndItem, pdis->itemID, i, szText,
            LVX_MaxColTchars + 1 );

        /* Update rectangle to enclose just this one item's column 'i'.
        */
        rc.left = rc.right;
        rc.right = rc.left + dxCol;

        if ((pDrawInfo->dwFlags & LVXDI_DxFill)
            && i == pDrawInfo->cCols - 1)
        {
            INT dxWnd = pdis->rcItem.left + rcClient.right;

            if (rc.right < dxWnd)
            {
                /* When the last column does not fill out a full controls
                ** width of space, extend it to the right so it does.  Note
                ** this does not mean the user can't scroll off to the right
                ** if they want.
                ** (Abolade-Gbadegesin 03-27-96)
                ** Don't subtrace rc.left when there is only one column;
                ** this accounts for the space needed for icons.
                */
                rc.right = pdis->rcItem.right = dxWnd;
                if (i == 0) {
                    ListView_SetColumnWidth(pdis->hwndItem, i, rc.right);
                }
                else {
                    ListView_SetColumnWidth(
                        pdis->hwndItem, i, rc.right - rc.left );
                }
            }
        }

        /* Lop the text and append "..." if it won't fit in the column.
        */
        pszText = Ellipsisize( hdc, szText, rc.right - rc.left, LVX_dxColText );
        if (!pszText)
            continue;

        /* Figure out the appropriate text and background colors for the
        ** current item state.
        */
        if (fEnabled)
        {
            if (fSelected)
            {
                SetTextColor( hdc, GetSysColor( COLOR_HIGHLIGHTTEXT ) );
                SetBkColor( hdc, GetSysColor( COLOR_HIGHLIGHT ) );
                if (pDrawInfo->dwFlags & LVXDI_Blend50Sel)
                    uiStyleSmall |= ILD_BLEND50;
            }
            else
            {
                if (pDrawInfo->adwFlags[ i ] & LVXDIA_3dFace)
                {
                    SetTextColor( hdc, GetSysColor( COLOR_WINDOWTEXT ) );
                    SetBkColor( hdc, GetSysColor( COLOR_3DFACE ) );
                }
                else
                {
                    SetTextColor( hdc, GetSysColor( COLOR_WINDOWTEXT ) );
                    SetBkColor( hdc, GetSysColor( COLOR_WINDOW ) );
                }
            }
        }
        else
        {
            if (pDrawInfo->adwFlags[ i ] & LVXDIA_Static)
            {
                SetTextColor( hdc, GetSysColor( COLOR_WINDOWTEXT ) );
                SetBkColor( hdc, GetSysColor( COLOR_3DFACE ) );
            }
            else
            {
                SetTextColor( hdc, GetSysColor( COLOR_GRAYTEXT ) );
                SetBkColor( hdc, GetSysColor( COLOR_3DFACE ) );
            }

            if (pDrawInfo->dwFlags & LVXDI_Blend50Dis)
                uiStyleSmall |= ILD_BLEND50;
        }

        /* Draw the column text.  In the first column the background of any
        ** indent and icons is erased to the text background color.
        */
        {
            RECT rcBg = rc;

            if (i == 0)
                rcBg.left -= dxIndent + dxState + dxSmall;

            ExtTextOut( hdc, rc.left + LVX_dxColText,
                rc.top + LVX_dyColText, ETO_CLIPPED + ETO_OPAQUE,
                &rcBg, pszText, lstrlen( pszText ), NULL );
        }

        Free( pszText );
    }

    /* Finally, draw the icons, if caller specified any.
    */
    if (himlState)
    {
        ImageList_Draw( himlState, (item.state >> 12) - 1, hdc,
            pdis->rcItem.left + dxIndent, pdis->rcItem.top, uiStyleState );
    }

    if (himlSmall)
    {
        ImageList_Draw( himlSmall, item.iImage, hdc,
            pdis->rcItem.left + dxIndent + dxState,
            pdis->rcItem.top, uiStyleSmall );
    }

    /* Draw the dotted focus rectangle around the whole item, if indicated.
    */
//comment for bug 52688 whistler
//   if ((pdis->itemState & ODS_FOCUS) && GetFocus() == pdis->hwndItem)
//        DrawFocusRect( hdc, &pdis->rcItem );
//

    ReleaseDC( pdis->hwndItem, hdc );

    return TRUE;
}



BOOL
LvxMeasureItem(
    IN     HWND               hwnd,
    IN OUT MEASUREITEMSTRUCT* pmis )

    /* Respond to WM_MEASUREITEM message, i.e. fill in the height of an item
    ** in the ListView.  'Hwnd' is the owner window.  'Pmis' is the structure
    ** provided from Windows.
    **
    ** Returns true is processed the message, false otherwise.
    */
{
    HDC        hdc;
    HWND       hwndLv;
    HFONT      hfont;
    TEXTMETRIC tm;
    UINT       dySmIcon;
    RECT       rc;

    TRACE("LvxMeasureItem");

    if (pmis->CtlType != ODT_LISTVIEW)
        return FALSE;

    hwndLv = GetDlgItem( hwnd, pmis->CtlID );
    ASSERT(hwndLv);

    /* Get a device context for the list view control and set up the font the
    ** control says it's using.  MSDN claims the final font may not be
    ** available at this point, but it sure seems to be.
    */
    hdc = GetDC( hwndLv );
    hfont = (HFONT )SendMessage( hwndLv, WM_GETFONT, 0, 0 );
    if (hfont)
        SelectObject( hdc, hfont );

    if (GetTextMetrics( hdc, &tm ))
        pmis->itemHeight = tm.tmHeight + 1;
    else
        pmis->itemHeight = 0;

    /* Make sure it's tall enough for a standard small icon.
    */
    dySmIcon = (UINT )GetSystemMetrics( SM_CYSMICON );
    if (pmis->itemHeight < dySmIcon + LVX_dyIconSpacing)
        pmis->itemHeight = dySmIcon + LVX_dyIconSpacing;

    /* Set the width since the docs say to, though I don't think it's used by
    ** list view.
    */
    GetClientRect( hwndLv, &rc );
    pmis->itemWidth = rc.right - rc.left - 1;

    ReleaseDC( hwndLv, hdc );
    return TRUE;
}


/*----------------------------------------------------------------------------
** ListView utilities
**----------------------------------------------------------------------------
*/

VOID
ListView_SetDeviceImageList(
    IN HWND      hwndLv,
    IN HINSTANCE hinst )

    /* Set the "small icon" image list view 'hwndLv' to be a list of DI_*
    ** images.  'Hinst' is the module instance containing the icons IID_Modem
    ** and IID_Adapter.  For example, see RASDLG.DLL.
    */
{
    HICON      hIcon;
    HIMAGELIST himl;

    himl = ImageList_Create(
               GetSystemMetrics( SM_CXSMICON ),
               GetSystemMetrics( SM_CYSMICON ),
               ILC_MASK, 2, 2 );

    /* The order these are added is significant since it implicitly
    ** establishes the state indices matching SI_Unchecked and SI_Checked.
    */
    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_Modem ) );
    if ( NULL != hIcon )
    {
        ImageList_ReplaceIcon( himl, -1, hIcon );
        DeleteObject( hIcon );
    }

    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_Adapter ) );
    if ( NULL != hIcon )
    {
        ImageList_ReplaceIcon( himl, -1, hIcon );
        DeleteObject( hIcon );
    }

    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_Direct_Connect ) );
    if ( NULL != hIcon )
    {
        ImageList_ReplaceIcon( himl, -1, hIcon );
        DeleteObject( hIcon );
    }

    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_Connections_Modem ) );
    if ( NULL != hIcon )
    {
        ImageList_ReplaceIcon( himl, -1, hIcon );
        DeleteObject( hIcon );
    }

    ListView_SetImageList( hwndLv, himl, LVSIL_SMALL );
}

VOID
ListView_SetUserImageList(
    IN HWND      hwndLv,
    IN HINSTANCE hinst )

    /* Set the "small icon" image list view 'hwndLv' to be a list of DI_*
    ** images.  'Hinst' is the module instance containing the icons IID_Modem
    ** and IID_Adapter.  For example, see RASDLG.DLL.
    */
{
    HICON      hIcon;
    HIMAGELIST himl;

    himl = ImageList_Create(
               GetSystemMetrics( SM_CXSMICON ),
               GetSystemMetrics( SM_CYSMICON ),
               ILC_MASK, 2, 2 );

    /* The order these are added is significant since it implicitly
    ** establishes the state indices matching SI_Unchecked and SI_Checked.
    */
    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_Connections_User ) );

    if(NULL != hIcon)
    {
        ImageList_ReplaceIcon( himl, -1, hIcon );
        DeleteObject( hIcon );
    }

    ListView_SetImageList( hwndLv, himl, LVSIL_SMALL );
}


VOID
ListView_SetNetworkComponentImageList(
    IN HWND      hwndLv,
    IN HINSTANCE hinst )

    /* Set the "small icon" image list view 'hwndLv' to be a list of DI_*
    ** images.  'Hinst' is the module instance containing the icons IID_Modem
    ** and IID_Adapter.  For example, see RASDLG.DLL.
    */
{
    HICON      hIcon;
    HIMAGELIST himl;

    himl = ImageList_Create(
               GetSystemMetrics( SM_CXSMICON ),
               GetSystemMetrics( SM_CYSMICON ),
               ILC_MASK, 2, 2 );

    /* The order these are added is significant since it implicitly
    ** establishes the state indices matching SI_Unchecked and SI_Checked.
    */
    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_Protocol ) );

    if(NULL != hIcon)
    {
        ImageList_ReplaceIcon( himl, -1, hIcon );
        DeleteObject( hIcon );
    }

    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_Service ) );

    if(NULL != hIcon)
    {
        ImageList_ReplaceIcon( himl, -1, hIcon );
        DeleteObject( hIcon );
    }

    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_Client ) );

    if(NULL != hIcon)
    {
        ImageList_ReplaceIcon( himl, -1, hIcon );
        DeleteObject( hIcon );
    }

    ListView_SetImageList( hwndLv, himl, LVSIL_SMALL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\common\uiutil\tldef.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    tldef.h
//
// History:
//  Abolade Gbadegesin   Nov-20-1995    Created.
//
// Private implementation declarations for TreeList control.
//============================================================================

#ifndef _TLDEF_H_
#define _TLDEF_H_


typedef struct _TLITEM {

    struct _TLITEM *pParent;
    LIST_ENTRY      leSiblings;
    LIST_ENTRY      lhChildren;
    LIST_ENTRY      lhSubitems;
    INT             iLevel;
    INT             iIndex;
    UINT            nChildren;

    LV_ITEM         lvi;
    PTSTR           pszText;
    LPARAM          lParam;
    INT             iImage;
    UINT            uiFlag;

} TLITEM;


typedef struct _TLSUBITEM {

    LIST_ENTRY      leItems;
    DWORD           dwFlags;
    INT             iSubItem;
    PTSTR           pszText;

} TLSUBITEM;


typedef struct _TL {

    HWND            hwnd;
    UINT            iCtrlId;
    HWND            hwndList;
    HWND            hwndParent;
    TLITEM          root;
    UINT            nColumns;
    UINT            cyItem;
    UINT            cyText;
    UINT            cxIndent;
    HDC             hdcImages;
    HBITMAP         hbmp;
    HBITMAP         hbmpMem;
    UINT            cxBmp;
    UINT            cyBmp;
    HBITMAP         hbmpStart;
    HBRUSH          hbrBk;

} TL;

#define TLI_EXPANDED        0x0001

#define TL_ICONCOUNT            (IID_TL_IconLast - IID_TL_IconBase + 1)
#define TL_ICONID(index)        ((index) + IID_TL_IconBase)
#define TL_ICONINDEX(id)        ((id) - IID_TL_IconBase)

#define TL_GetPtr(hwnd)         (TL *)GetWindowLongPtr((hwnd), 0)
#define TL_SetPtr(hwnd,ptr)     (TL *)SetWindowLongPtr((hwnd), 0, (ULONG_PTR)(ptr))

#define TL_StateImageValue(p)   (((p)->lvi.state >> 12) & 0xf)
#define TL_StateImageIndex(p)   (TL_StateImageValue(p) - 1)
#define TL_IsExpanded(p)        ((p)->uiFlag & TLI_EXPANDED)
#define TL_IsVisible(p)         ((p)->iIndex != -1)

#define TL_VerticalLine         0
#define TL_RootChildless        1
#define TL_RootParentCollapsed  2
#define TL_RootParentExpanded   3
#define TL_MidChildless         4
#define TL_MidParentCollapsed   5
#define TL_MidParentExpanded    6
#define TL_EndChildless         7
#define TL_EndParentCollapsed   8
#define TL_EndParentExpanded    9
#define TL_ImageCount           10


LRESULT
CALLBACK
TL_WndProc(
    HWND hwnd,
    UINT uiMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
TL_OnCreate(
    TL *ptl,
    CREATESTRUCT *pcs
    );

VOID
TL_OnDestroy(
    TL *ptl
    );

BOOL
TL_NotifyParent(
    TL *ptl,
    NMHDR *pnmh
    );

LRESULT
TL_OnNotify(
    TL *ptl,
    INT iCtrlId,
    NMHDR *pnmh
    );

HTLITEM
TL_OnInsertItem(
    TL *ptl,
    TL_INSERTSTRUCT *ptlis
    );

BOOL
TL_OnDeleteItem(
    TL *ptl,
    HTLITEM hitem
    );

BOOL
TL_OnDeleteAllItems(
    TL *ptl
    );

VOID
TL_DeleteAndNotify(
    TL *ptl,
    TLITEM *pItem
    );

BOOL
TL_OnGetItem(
    TL *ptl,
    LV_ITEM *plvi
    );

BOOL
TL_OnSetItem(
    TL *ptl,
    LV_ITEM *plvi
    );

UINT
TL_OnGetItemCount(
    TL *ptl
    );

HTLITEM
TL_OnGetNextItem(
    TL *ptl,
    UINT uiFlag,
    HTLITEM hItem
    );

#define TL_Enumerate(ptl,pitem) \
        TL_OnGetNextItem((ptl), TLGN_ENUMERATE, (HTLITEM)(pitem))

BOOL
TL_OnExpand(
    TL *ptl,
    UINT uiFlag,
    HTLITEM hItem
    );

BOOL
TL_ItemExpand(
    TL *ptl,
    TLITEM *pItem
    );

BOOL
TL_ItemCollapse(
    TL *ptl,
    TLITEM *pItem
    );

INT
TL_OnInsertColumn(
    TL *ptl,
    INT iCol,
    LV_COLUMN *pCol
    );

BOOL
TL_OnDeleteColumn(
    TL *ptl,
    INT iCol
    );

BOOL
TL_OnSetSelection(
    TL *ptl,
    HTLITEM hItem
    );

VOID
TL_OnWindowPosChanged(
    TL *ptl,
    WINDOWPOS *pwp
    );

VOID
TL_OnEraseBackground(
    TL *ptl,
    HDC hdc
    );

BOOL
TL_OnDrawItem(
    TL *ptl,
    CONST DRAWITEMSTRUCT *pdis
    );

BOOL
TL_DrawItem(
    TL *ptl,
    CONST DRAWITEMSTRUCT *pdis
    );

VOID
TL_OnMeasureItem(
    TL *ptl,
    MEASUREITEMSTRUCT *pmis
    );

HBITMAP
TL_CreateColorBitmap(
    INT cx,
    INT cy
    );

VOID
TL_CreateTreeImages(
    TL *ptl
    );

VOID
TL_DottedLine(
    HDC hdc,
    INT x,
    INT y,
    INT dim,
    BOOL fVertical
    );

VOID
TL_DrawButton(
    HDC hdc,
    INT x,
    INT y,
    INT dim,
    HBRUSH hbrSign,
    HBRUSH hbrBox,
    HBRUSH hbrBk,
    BOOL bCollapsed
    );

VOID
TL_UpdateListIndices(
    TL *ptl,
    TLITEM *pStart
    );

VOID
TL_UpdateDescendantIndices(
    TL *ptl,
    TLITEM *pStart,
    INT *piIndex
    );

VOID
TL_UpdateAncestorIndices(
    TL *ptl,
    TLITEM *pStart,
    INT *piIndex
    );

VOID
TL_UpdateImage(
    TL *ptl,
    TLITEM *pItem,
    TLITEM **ppChanged
    );

VOID
TL_CountItems(
    TLITEM *pParent,
    INT *piCount
    );

BOOL
TL_OnRedraw(
    TL *ptl
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\common\uiutil\popupdlg.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** popupdlg.c
** UI helper library
** Popup dialog routines
** Listed alphabetically
**
** 08/25/95 Steve Cobb
*/


#include <nt.h>       // NT declarations
#include <ntrtl.h>    // NT general runtime-library
#include <nturtl.h>   // NT user-mode runtime-library
#include <windows.h>  // Win32 root
#include <lmerr.h>    // LAN Manager errors
#include <lmcons.h>   // LAN Manager constants
#include <stdarg.h>   // To stop va_list argument warning only
#include <ras.h>      // RAS API definitions
#include <raserror.h> // Win32 RAS error codes
#include <debug.h>    // Trace/assert library
#include <nouiutil.h> // No-HWND utilities
#include <uiutil.h>   // Our public header


/*----------------------------------------------------------------------------
** Error popup
**----------------------------------------------------------------------------
*/

int
ErrorDlgUtil(
    IN     HWND       hwndOwner,
    IN     DWORD      dwOperation,
    IN     DWORD      dwError,
    IN OUT ERRORARGS* pargs,
    IN     HINSTANCE  hInstance,
    IN     DWORD      dwTitle,
    IN     DWORD      dwFormat )

    /* Pops up a modal error dialog centered on 'hwndOwner'.  'DwOperation' is
    ** the string resource ID of the string describing the operation underway
    ** when the error occurred.  'DwError' is the code of the system or RAS
    ** error that occurred.  'Pargs' is a extended formatting arguments or
    ** NULL if none.  'hInstance' is the application/module handle where
    ** string resources are located.  'DwTitle' is the string ID of the dialog
    ** title.  'DwFormat' is the string ID of the error format title.
    **
    ** Returns MessageBox-style code.
    */
{
    TCHAR* pszUnformatted;
    TCHAR* pszOp;
    TCHAR  szErrorNum[ 50 ];
    TCHAR* pszError;
    TCHAR* pszResult;
    TCHAR* pszNotFound;
    int    nResult;

    TRACE("ErrorDlgUtil");

    /* A placeholder for missing strings components.
    */
    pszNotFound = TEXT("");

    /* Build the error number string.
    */
    if (dwError > 0x7FFFFFFF)
        wsprintf( szErrorNum, TEXT("0x%X"), dwError );
    else
        wsprintf( szErrorNum, TEXT("%u"), dwError );

    /* Build the error text string.
    */
    if (!GetErrorText( dwError, &pszError ))
        pszError = pszNotFound;

    /* Build the operation string.
    */
    pszUnformatted = PszFromId( hInstance, dwOperation );
    pszOp = pszNotFound;

    if (pszUnformatted)
    {
        FormatMessage(
            FORMAT_MESSAGE_FROM_STRING +
                FORMAT_MESSAGE_ALLOCATE_BUFFER +
                FORMAT_MESSAGE_ARGUMENT_ARRAY,
            pszUnformatted, 0, 0, (LPTSTR )&pszOp, 1,
            (va_list* )((pargs) ? pargs->apszOpArgs : NULL) );

        Free( pszUnformatted );
    }

    /* Call MsgDlgUtil with the standard arguments plus any auxillary format
    ** arguments.
    */
    pszUnformatted = PszFromId( hInstance, dwFormat );
    pszResult = pszNotFound;

    if (pszUnformatted)
    {
        MSGARGS msgargs;

        ZeroMemory( &msgargs, sizeof(msgargs) );
        msgargs.dwFlags = MB_ICONEXCLAMATION + MB_OK + MB_SETFOREGROUND;
        msgargs.pszString = pszUnformatted;
        msgargs.apszArgs[ 0 ] = pszOp;
        msgargs.apszArgs[ 1 ] = szErrorNum;
        msgargs.apszArgs[ 2 ] = pszError;

        if (pargs)
        {
            msgargs.fStringOutput = pargs->fStringOutput;

            CopyMemory( &msgargs.apszArgs[ 3 ], pargs->apszAuxFmtArgs,
                3 * sizeof(TCHAR) );
        }

        nResult =
            MsgDlgUtil(
                hwndOwner, 0, &msgargs, hInstance, dwTitle );

        Free( pszUnformatted );

        if (pargs && pargs->fStringOutput)
            pargs->pszOutput = msgargs.pszOutput;
    }

    if (pszOp != pszNotFound)
        LocalFree( pszOp );
    if (pszError != pszNotFound)
        LocalFree( pszError );

    return nResult;
}


BOOL
GetErrorText(
    DWORD   dwError,
    TCHAR** ppszError )

    /* Fill caller's '*ppszError' with the address of a LocalAlloc'ed heap
    ** block containing the error text associated with error 'dwError'.  It is
    ** caller's responsibility to LocalFree the returned string.
    **
    ** Returns true if successful, false otherwise.
    */
{
#define MAXRASERRORLEN 256

    TCHAR  szBuf[ MAXRASERRORLEN + 1 ];
    DWORD  dwFlags;
    HANDLE hmodule;
    DWORD  cch;

    /* Don't panic if the RAS API address is not loaded.  Caller may be trying
    ** and get an error up during LoadRas.
    */
    if ((Rasapi32DllLoaded() || RasRpcDllLoaded())
        && g_pRasGetErrorString
        && g_pRasGetErrorString(
               (UINT )dwError, (LPTSTR )szBuf, MAXRASERRORLEN ) == 0)
    {
        /* It's a RAS error.
        */
        *ppszError = LocalAlloc( LPTR, (lstrlen( szBuf ) + 1) * sizeof(TCHAR) );
        if (!*ppszError)
            return FALSE;

        lstrcpy( *ppszError, szBuf );
        return TRUE;
    }

    /* The rest adapted from BLT's LoadSystem routine.
    */
    dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER + FORMAT_MESSAGE_IGNORE_INSERTS;

    if (dwError >= MIN_LANMAN_MESSAGE_ID && dwError <= MAX_LANMAN_MESSAGE_ID)
    {
        /* It's a net error.
        */
        dwFlags += FORMAT_MESSAGE_FROM_HMODULE;
        hmodule = GetModuleHandle( TEXT("NETMSG.DLL") );
    }
    else
    {
        /* It must be a system error.
        */
        dwFlags += FORMAT_MESSAGE_FROM_SYSTEM;
        hmodule = NULL;
    }

    /* Whistler bug: 389111 VPN connection returns unacceptable error message
    ** when smart card is not available
    */
    dwFlags |= FORMAT_MESSAGE_MAX_WIDTH_MASK;

    /* This is an NTSTATUS error msg.
    */
    if (NT_ERROR(dwError))
    {
        dwError = RtlNtStatusToDosError( dwError );
    }

    cch = FormatMessage(
            dwFlags, hmodule, dwError, 0, (LPTSTR )ppszError, 1, NULL );

    /* FormatMessage failed so we are going to get a generic one from RAS.
    */
    if (!cch || !*ppszError)
    {
        Free0( *ppszError );
        dwError = ERROR_UNKNOWN;

        if ((Rasapi32DllLoaded() || RasRpcDllLoaded())
            && g_pRasGetErrorString
            && g_pRasGetErrorString(
                   (UINT )dwError, (LPTSTR )szBuf, MAXRASERRORLEN ) == 0)
        {
            *ppszError = LocalAlloc( LPTR, (lstrlen( szBuf ) + 1) *
                            sizeof(TCHAR) );
            if (!*ppszError)
                return FALSE;

            lstrcpy( *ppszError, szBuf );
            return TRUE;
        }
    }

    return (cch > 0);
}


/*----------------------------------------------------------------------------
** Message popup
**----------------------------------------------------------------------------
*/

int
MsgDlgUtil(
    IN     HWND      hwndOwner,
    IN     DWORD     dwMsg,
    IN OUT MSGARGS*  pargs,
    IN     HINSTANCE hInstance,
    IN     DWORD     dwTitle )

    /* Pops up a message dialog centered on 'hwndOwner'.  'DwMsg' is the
    ** string resource ID of the message text.  'Pargs' is a extended
    ** formatting arguments or NULL if none.  'hInstance' is the
    ** application/module handle where string resources are located.
    ** 'DwTitle' is the string ID of the dialog title.
    **
    ** Returns MessageBox-style code.
    */
{
    TCHAR* pszUnformatted;
    TCHAR* pszResult;
    TCHAR* pszNotFound;
    int    nResult;

    TRACE("MsgDlgUtil");

    /* A placeholder for missing strings components.
    */
    pszNotFound = TEXT("");

    /* Build the message string.
    */
    pszResult = pszNotFound;

    if (pargs && pargs->pszString)
    {
        FormatMessage(
            FORMAT_MESSAGE_FROM_STRING +
                FORMAT_MESSAGE_ALLOCATE_BUFFER +
                FORMAT_MESSAGE_ARGUMENT_ARRAY,
            pargs->pszString, 0, 0, (LPTSTR )&pszResult, 1,
            (va_list* )pargs->apszArgs );
    }
    else
    {
        pszUnformatted = PszFromId( hInstance, dwMsg );

        if (pszUnformatted)
        {
            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING +
                    FORMAT_MESSAGE_ALLOCATE_BUFFER +
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                pszUnformatted, 0, 0, (LPTSTR )&pszResult, 1,
                (va_list* )((pargs) ? pargs->apszArgs : NULL) );

            Free( pszUnformatted );
        }
    }

    if (!pargs || !pargs->fStringOutput)
    {
        TCHAR* pszTitle;
        DWORD  dwFlags;
        HHOOK  hhook;

        if (pargs && pargs->dwFlags != 0)
            dwFlags = pargs->dwFlags;
        else
            dwFlags = MB_ICONINFORMATION + MB_OK + MB_SETFOREGROUND;

        pszTitle = PszFromId( hInstance, dwTitle );

        if (hwndOwner)
        {
            /* Install hook that will get the message box centered on the
            ** owner window.
            */
            hhook = SetWindowsHookEx( WH_CALLWNDPROC,
                CenterDlgOnOwnerCallWndProc,
                hInstance, GetCurrentThreadId() );
        }
        else
            hhook = NULL;

        if (pszResult)
        {
            nResult = MessageBox( hwndOwner, pszResult, pszTitle, dwFlags );
        }

        if (hhook)
            UnhookWindowsHookEx( hhook );

        Free0( pszTitle );
        if (pszResult != pszNotFound)
            LocalFree( pszResult );
    }
    else
    {
        /* Caller wants the string without doing the popup.
        */
        pargs->pszOutput = (pszResult != pszNotFound) ? pszResult : NULL;
        nResult = IDOK;
    }

    return nResult;
}


LRESULT CALLBACK
CenterDlgOnOwnerCallWndProc(
    int    code,
    WPARAM wparam,
    LPARAM lparam )

    /* Standard Win32 CallWndProc hook callback that looks for the next dialog
    ** started and centers it on it's owner window.
    */
{
    /* Arrive here when any window procedure associated with our thread is
    ** called.
    */
    if (!wparam)
    {
        CWPSTRUCT* p = (CWPSTRUCT* )lparam;

        /* The message is from outside our process.  Look for the MessageBox
        ** dialog initialization message and take that opportunity to center
        ** the dialog on it's owner's window.
        */
        if (p->message == WM_INITDIALOG)
            CenterWindow( p->hwnd, GetParent( p->hwnd ) );
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\common\uiutil\treelist.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    treelist.c
//
// History:
//  Abolade Gbadegesin   Nov-20-1995    Created.
//
// Implementation routines for TreeList control.
//
// The TreeList control is implemented as a custom control,
// which creates and manages an owner-draw listview.
//============================================================================

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>

#include <debug.h>
#include <nouiutil.h>
#include <uiutil.h>
#include <list.h>

#include "treelist.h"
#include "tldef.h"


#if 0
#define TLTRACE     (0x80000002)
#else
#define TLTRACE     (0x00000002)
#endif



//----------------------------------------------------------------------------
// Function:    TL_Init
//
// Registers the TreeList window class.
//----------------------------------------------------------------------------

BOOL
TL_Init(
    HINSTANCE hInstance
    ) {

    INT i;
    HICON hicon;
    WNDCLASS wc;

    //
    // do nothing if the class is already registered
    //

    if (GetClassInfo(hInstance, WC_TREELIST, &wc)) {
        return TRUE;
    }


    //
    // setup the wndclass structure, and register
    //

    wc.lpfnWndProc = TL_WndProc;
    wc.hCursor = LoadCursor(hInstance, IDC_ARROW);
    wc.hIcon = NULL;
    wc.lpszMenuName = NULL;
    wc.hInstance = hInstance;
    wc.lpszClassName = WC_TREELIST;
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.style = CS_DBLCLKS;
    wc.cbWndExtra = sizeof(TL *);
    wc.cbClsExtra = 0;

    return RegisterClass(&wc);
}




//----------------------------------------------------------------------------
// Function:    TL_WndProc
//
// This function handles messages for TreeList windows
//----------------------------------------------------------------------------

LRESULT
CALLBACK
TL_WndProc(
    HWND hwnd,
    UINT uiMsg,
    WPARAM wParam,
    LPARAM lParam
    ) {

    TL *ptl;


    if (NULL == hwnd)
    {
        return (LRESULT)FALSE;
    }

    //
    // attempt to retrieve the data pointer for the window.
    // on WM_NCCREATE, this fails, so we allocate the data.
    //
    
    ptl = TL_GetPtr(hwnd);

    if (ptl == NULL) {

        if (uiMsg != WM_NCCREATE) {
            return DefWindowProc(hwnd, uiMsg, wParam, lParam);
        }


        //
        // allocate a block of memory
        //

        ptl = (TL *)Malloc(sizeof(TL));
        if (ptl == NULL) { return (LRESULT)FALSE; }


        //
        // save the pointer in the window's private bytes
        //

        ptl->hwnd = hwnd;

        //
        //Reset Error code, TL_SetPtr won't reset error code when
        //it succeeds
        //

        SetLastError(0);
        if ((0 == TL_SetPtr(hwnd, ptl)) && (0 != GetLastError()))
        {
            Free(ptl);
            return (LRESULT)FALSE;
        }

        return DefWindowProc(hwnd, uiMsg, wParam, lParam);
    }


    //
    // if the window is being destroyed, free the block allocated
    // and set the private bytes pointer to NULL
    //

    if (uiMsg == WM_NCDESTROY) {
        Free(ptl);
        TL_SetPtr(hwnd, NULL);

        return (LRESULT)0;
    }



    switch (uiMsg) {

        HANDLE_MSG(ptl, WM_CREATE, TL_OnCreate);
        HANDLE_MSG(ptl, WM_DESTROY, TL_OnDestroy);
        HANDLE_MSG(ptl, WM_DRAWITEM, TL_OnDrawItem);
        HANDLE_MSG(ptl, WM_MEASUREITEM, TL_OnMeasureItem);
        HANDLE_MSG(ptl, WM_NOTIFY, TL_OnNotify);

        case WM_ERASEBKGND: {

            TL_OnEraseBackground(ptl, (HDC)wParam);
            return (LRESULT)TRUE;
        }

        case WM_HELP: {

            //
            // change the control-id and HWND for the help to our values
            // and pass the message on to our parent
            //

            HELPINFO *phi = (HELPINFO *)lParam;

            phi->iCtrlId = ptl->iCtrlId;
            phi->hItemHandle = ptl->hwnd;
            return SendMessage(ptl->hwndParent, WM_HELP, 0L, lParam);
        }

        case WM_SYSCOLORCHANGE: {

            //
            // notify the listview window that a color has changed
            //

            TL_CreateTreeImages(ptl);
            FORWARD_WM_SYSCOLORCHANGE(ptl->hwndList, SendMessage);
//            ListView_SetBkColor(ptl->hwndList, GetSysColor(COLOR_WINDOW));
            return (LRESULT)0;
        }

        case WM_SETFOCUS: {

            //
            // if we receive the focus, give it to the listview instead
            //

            SetFocus(ptl->hwndList);
            return (LRESULT)0;
        }


        case WM_WINDOWPOSCHANGED: {
            TL_OnWindowPosChanged(ptl, (WINDOWPOS *)lParam);
            return 0;
        }
        


        //
        // the following cases handle TreeList-defined messages
        //

        case TLM_INSERTITEM: {
            return (LRESULT)TL_OnInsertItem(ptl, (TL_INSERTSTRUCT *)lParam);
        }

        case TLM_DELETEITEM: {
            return (LRESULT)TL_OnDeleteItem(ptl, (HTLITEM)lParam);
        }

        case TLM_DELETEALLITEMS: {
            return (LRESULT)TL_OnDeleteAllItems(ptl);
        }

        case TLM_GETITEM: {
            return (LRESULT)TL_OnGetItem(ptl, (LV_ITEM *)lParam);
        }

        case TLM_SETITEM: {
            return (LRESULT)TL_OnSetItem(ptl, (LV_ITEM *)lParam);
        }

        case TLM_GETITEMCOUNT: {
            return (LRESULT)TL_OnGetItemCount(ptl);
        }

        case TLM_GETNEXTITEM: {
            return (LRESULT)TL_OnGetNextItem(ptl, (UINT)wParam,(HTLITEM)lParam);
        }

        case TLM_EXPAND: {
            return (LRESULT)TL_OnExpand(ptl, (UINT)wParam, (HTLITEM)lParam);
        }

        case TLM_SETIMAGELIST: {
            return (LRESULT)ListView_SetImageList(
                        ptl->hwndList, (HIMAGELIST)lParam, LVSIL_SMALL
                        );
        }

        case TLM_GETIMAGELIST: {
            return (LRESULT)ListView_GetImageList(ptl->hwndList, LVSIL_SMALL);
        }

        case TLM_INSERTCOLUMN: {
            return (LRESULT)TL_OnInsertColumn(
                        ptl, (INT)wParam, (LV_COLUMN *)lParam
                        );
        }

        case TLM_DELETECOLUMN: {
            return (LRESULT)TL_OnDeleteColumn(ptl, (INT)wParam);
        }

        case TLM_SETSELECTION: {
            return (LRESULT)TL_OnSetSelection(ptl, (HTLITEM)lParam);
        }

        case TLM_REDRAW: {
            return (LRESULT)TL_OnRedraw(ptl);
        }

        case TLM_ISITEMEXPANDED: {
            return (LRESULT)TL_IsExpanded((TLITEM *)lParam);
        }

        case TLM_GETCOLUMNWIDTH: {
            return (LRESULT)SendMessage(
                        ptl->hwndList, LVM_GETCOLUMNWIDTH, wParam, lParam
                        );
        }

        case TLM_SETCOLUMNWIDTH: {
            return (LRESULT)SendMessage(
                        ptl->hwndList, LVM_SETCOLUMNWIDTH, wParam, lParam
                        );
        }
    }


    //
    // let the default processing be done
    //

    return DefWindowProc(hwnd, uiMsg, wParam, lParam);
}




//----------------------------------------------------------------------------
// Function:    TL_OnCreate
//
// This is called after WM_CREATE, and it initializes the window structure,
// as well as creating the listview which will contain the items added
//----------------------------------------------------------------------------

BOOL
TL_OnCreate(
    TL *ptl,
    CREATESTRUCT *pcs
    ) {

    RECT rc;
    HD_ITEM hdi;
    HWND hwndList;
    TLITEM *pRoot;
    DWORD dwStyle, dwExStyle;


    //
    // initialize the window structure
    //

    ptl->hbrBk = NULL;
    ptl->hbmp = NULL;
    ptl->hbmpStart = NULL;
    ptl->hbmpMem = NULL;
    ptl->hdcImages = NULL;
    ptl->hwndList = NULL;
    ptl->iCtrlId = PtrToUlong(pcs->hMenu);
    ptl->hwndParent = pcs->hwndParent;
    ptl->nColumns = 0;


    //
    // initialize the invisible root item
    //

    pRoot = &ptl->root;
    pRoot->pParent = NULL;
    pRoot->iLevel = -1;
    pRoot->iIndex = -1;
    pRoot->nChildren = 0;
    pRoot->uiFlag = TLI_EXPANDED;
    pRoot->pszText = TEXT("ROOT");
    InitializeListHead(&pRoot->lhChildren);
    InitializeListHead(&pRoot->lhSubitems);


    //
    // we pass on some of our window style bits to the listview
    // when we create it as our child; we also remove certain styles
    // which are never appropriate for the contained listview
    //

    dwStyle = pcs->style & ~(LVS_TYPESTYLEMASK | LVS_SORTASCENDING |
                             LVS_SORTDESCENDING);
    dwStyle |= WS_CHILD | LVS_REPORT | LVS_SINGLESEL | LVS_OWNERDRAWFIXED;

    dwExStyle = pcs->dwExStyle & ~(WS_EX_CLIENTEDGE | WS_EX_WINDOWEDGE |
                                   WS_EX_STATICEDGE);

    //
    // create the listview window
    //

    GetClientRect(ptl->hwnd, &rc);
    hwndList = CreateWindowEx(
                    dwExStyle, WC_LISTVIEW, NULL, dwStyle,
                    0, 0, rc.right, rc.bottom,
                    ptl->hwnd, NULL, pcs->hInstance, NULL
                    );
    if (hwndList == NULL) { return FALSE; }
//    ListView_SetBkColor(hwndList, GetSysColor(COLOR_WINDOW));

    //
    // We to set the background color to "NONE" to prevent the listview
    // from erasing its background itself. Removing the background color
    // causes the listview to forward its WM_ERASEBKGND messages to its parent,
    // which is our tree-list. We handle the WM_ERASEBKGND messages
    // efficiently by only erasing the background when absolutely necessary,
    // and this eliminates the flicker normally seen when windows are updated
    // frequently.
    //

    ListView_SetBkColor(hwndList, CLR_NONE);

    ptl->hwndList = hwndList;

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    TL_OnDestroy
//
// Delete all the items in the tree, and free the image bitmap
// used for drawing the tree structure
//----------------------------------------------------------------------------

VOID
TL_OnDestroy(
    TL *ptl
    ) {

    TL_OnDeleteAllItems(ptl);

    if (ptl->hdcImages != NULL) {

        if (ptl->hbmp) {
            SelectObject(ptl->hdcImages, ptl->hbmpStart);
            DeleteObject(ptl->hbmp);
        }

        DeleteDC(ptl->hdcImages);
    }

    if (ptl->hbmpMem) { DeleteObject(ptl->hbmpMem); }
}



//----------------------------------------------------------------------------
// Function:    TL_OnWindowPosChanged
//
// When the window width changes, we destroy our off-screen bitmap.
//----------------------------------------------------------------------------

VOID
TL_OnWindowPosChanged(
    TL *ptl,
    WINDOWPOS *pwp
    ) {

    RECT rc;

    GetClientRect(ptl->hwnd, &rc);

    SetWindowPos(
        ptl->hwndList, ptl->hwnd, 0, 0, rc.right, rc.bottom, pwp->flags
        );
}



//----------------------------------------------------------------------------
// Function:    TL_OnEraseBackground
//
// When we are asked to erase the background, first test to see if
// the update region is completely in the item-area for the listbox. If so,
// we know we'll be called to update each item, so we can ignore this
// request to erase our background.
//----------------------------------------------------------------------------

VOID
TL_OnEraseBackground(
    TL *ptl,
    HDC hdc
    ) {

    RECT rc;
    INT count;
    HBRUSH hbrOld;
    LV_HITTESTINFO lvhi;


    //
    // Retrieve the rectangle to be erased
    //

    GetClipBox(hdc, &rc);

    TRACEX4(
        TLTRACE, "WM_ERASEBKGND:  ClipBox:        (%d, %d) (%d %d)",
        rc.left, rc.top, rc.right, rc.bottom
        );


    //
    // Retrieve the count of listview items.
    // This is necessary because the smooth-scrolling code triggers
    // a repaint inside the ListView_DeleteItem() processing,
    // at which point our indices may be out of sync (i.e. we have more items
    // than the listview).
    // The count retrieved is used to do a sanity-check
    // on the treelist-item indices below.
    //

    count = ListView_GetItemCount(ptl->hwndList);
    TRACEX1(TLTRACE, "WM_ERASEBKGND:  Count:          %d", count);


    //
    // If there are no treelist items, we always have to erase.
    // If there are treelist items, we only have to erase
    // if part of the erase-region lies below our lowest item.
    //

    while (!IsListEmpty(&ptl->root.lhChildren)) { // one-time loop

        RECT rctop;
        INT iTopIndex;
        INT cyUpdate;
        TLITEM *pItem;
        LIST_ENTRY *phead;


        //
        // We need to factor in the height of the header-control, if any;
        // to this end, we get the bounding rectangle of the topmost item
        // visible in the listview, and then we use the top of that item
        // as the basis for our computations below
        //

        iTopIndex = ListView_GetTopIndex(ptl->hwndList);
        TRACEX1(TLTRACE, "WM_ERASEBKGND:  TopIndex:       %d", iTopIndex);

        ListView_GetItemRect(ptl->hwndList, iTopIndex, &rctop, LVIR_BOUNDS);
        TRACEX1(TLTRACE, "WM_ERASEBKGND:  rctop.top:      %d", rctop.top);

        rc.top = rctop.top;


        //
        // If the area to be erased extends further right in the window
        // than our items do, we'll have to erase
        //

        if (rctop.right < rc.right) {

            TRACEX2(
                TLTRACE, "WM_ERASEBKGND:  rctop.right < rc.right (%d < %d)",
                rctop.right, rc.right
                );

            break;
        }


        //
        // Get the total height of the area to be updated;
        // this excludes the area occupied by the header-control.
        //

        cyUpdate = rc.bottom - rctop.top;
        TRACEX1(TLTRACE, "WM_ERASEBKGND:  CyUpdate:       %d", cyUpdate);


        //
        // Get the lowest item; it is the one at the tail of the item-list
        //

        phead = ptl->root.lhChildren.Blink;
        
        pItem = CONTAINING_RECORD(phead, TLITEM, leSiblings);

        TRACEX1(TLTRACE, "WM_ERASEBKGND:  CyItem:         %d", ptl->cyItem);


        //
        // If the lowest item or one of its visible descendants is lower
        // than the bottom of the update region, we don't have to erase;
        // therefore, we walk down the list of the lowest item's descendants,
        // checking each time whether the descendant is lower than the region
        // we've been asked to erase.
        //

        do {

            TRACEX1(
                TLTRACE, "WM_ERASEBKGND:  pItem->iIndex:    %d", pItem->iIndex
                );
    

            //
            // force the erasure if the item's index is higher
            // than the number of listview items
            //

            if (pItem->iIndex >= count) { break; }


            //
            // defer the erasure if the item is lower than the bottom
            // of the update-rect
            //

            if ((pItem->iIndex - iTopIndex + 1) * (INT)ptl->cyItem > cyUpdate) {
                TRACEX(TLTRACE, "WM_ERASEBKGND:   DEFERRING");
                return;
            }


            //
            // move on to the item's lowest child;
            // if it has none, it means the erase-region's lowest edge
            // is lower than our lowest item, and that means
            // that we'll have to erase it now instead of just letting it
            // get updated when we handle the WM_DRAWITEM
            //

            if (IsListEmpty(&pItem->lhChildren)) { pItem = NULL; }
            else {

                phead = pItem->lhChildren.Blink;

                pItem = CONTAINING_RECORD(phead, TLITEM, leSiblings);
            }

        } while (pItem && TL_IsVisible(pItem));

        break;
    }
    


    //
    // One of the points was not on an item, so erase
    //

    TRACEX(TLTRACE, "WM_ERASEBKGND:  ERASING");

    hbrOld = SelectObject(hdc, ptl->hbrBk);
    PatBlt(
        hdc, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, PATCOPY
        );
    SelectObject(hdc, hbrOld);
}



//----------------------------------------------------------------------------
// Function:    TL_OnDrawItem
//
// This is called by the listview when an item needs to be drawn.
//----------------------------------------------------------------------------

BOOL
TL_OnDrawItem(
    TL *ptl,
    CONST DRAWITEMSTRUCT *pdis
    ) {


    //
    // make sure this is from our listview
    //

    if (pdis->CtlType != ODT_LISTVIEW) { return FALSE; }

    switch (pdis->itemAction) {

        //
        // currently listviews always send ODA_DRAWENTIRE,
        // but handle all cases anyway
        //

        case ODA_DRAWENTIRE:
        case ODA_FOCUS:
        case ODA_SELECT:
            return TL_DrawItem(ptl, pdis);
    }

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    TL_DrawItem
//
// This function does the actual drawing for a treelist item
//----------------------------------------------------------------------------

BOOL
TL_DrawItem(
    TL *ptl,
    CONST DRAWITEMSTRUCT *pdis
    ) {

    HDC hdcMem;
    TCHAR *psz;
    RECT rc, rcItem;
    HBITMAP hbmpOld;
    HIMAGELIST himl;
    TLSUBITEM *pSubitem;
    HFONT hfont, hfontOld;
    TLITEM *pItem, *pParent;
    LIST_ENTRY *ple, *phead;
    INT cxIndent, cxImage, cyImage, i, tx, x, y, xcol;



    //
    // the itemData contains the lParam passed in ListView_InsertItem;
    // this lParam is the TLITEM pointer for the tree-item, so we retrieve it
    // and use the information it contains to draw the item
    //

    cxIndent = ptl->cxIndent;
    pItem = (TLITEM *)pdis->itemData;
    rcItem.left = 0; rcItem.top = 0;
    rcItem.right = pdis->rcItem.right - pdis->rcItem.left;
    rcItem.bottom = pdis->rcItem.bottom - pdis->rcItem.top;



    //
    // create a compatible DC
    //

    hdcMem = CreateCompatibleDC(pdis->hDC);

    if(NULL == hdcMem)
    {
        return FALSE;
    }

    if (ptl->hbmpMem) {

        if (rcItem.right > (INT)ptl->cxBmp || rcItem.bottom > (INT)ptl->cyBmp) {
            DeleteObject(ptl->hbmpMem); ptl->hbmpMem = NULL;
        }
    }

    if (!ptl->hbmpMem) {

        ptl->hbmpMem = CreateCompatibleBitmap(
                            pdis->hDC, rcItem.right, rcItem.bottom
                            );

        ptl->cxBmp = rcItem.right;
        ptl->cyBmp = rcItem.bottom;
    }


    hbmpOld = SelectObject(hdcMem, ptl->hbmpMem);

    hfontOld = SelectObject(hdcMem, GetWindowFont(pdis->hwndItem));


    //
    // erase the background
    //

#if 0
    ptl->hbrBk = FORWARD_WM_CTLCOLOREDIT(
                    ptl->hwndParent, hdcMem, ptl->hwnd, SendMessage
                    );
#endif
    FillRect(hdcMem, &rcItem, ptl->hbrBk);


    //
    // set the text background color based on whether or not
    // the item is selected
    //

    if (pdis->itemState & ODS_SELECTED) {
        SetTextColor(hdcMem, GetSysColor(COLOR_HIGHLIGHTTEXT));
        SetBkColor(hdcMem, GetSysColor(COLOR_HIGHLIGHT));
    }
    else {
        SetTextColor(hdcMem, GetSysColor(COLOR_WINDOWTEXT));
        SetBkColor(hdcMem, GetSysColor(COLOR_WINDOW));
    }


    //
    // compute the starting position as a multiple of
    // the  item's level and the indentation per level
    //

    x = rcItem.left + pItem->iLevel * cxIndent;
    y = rcItem.top;

    xcol = rcItem.left + ListView_GetColumnWidth(pdis->hwndItem, 0);
    tx = x;
    x += cxIndent;


    //
    // now draw the item's tree image;
    // only draw as much as will fit in the first column
    //

    if (tx < xcol) {
        BitBlt(
            hdcMem, tx, y, min(cxIndent, xcol - tx), ptl->cyItem,
            ptl->hdcImages, pItem->iImage * cxIndent, 0, SRCCOPY
            );
    }


    //
    // draw the lines going down from the item's ancestors
    // to the item's ancestors' corresponding siblings;
    // in other words, for each ancestor which is not its parent's last child,
    // there should be a line going down from that ancestor to its next sibling
    // and the line will pass through the rows for all of that item's expanded
    // descendants.
    // note that we do not draw lines at the root-level
    //

    pParent = pItem->pParent;
    for (i = pItem->iLevel - 1, tx -= cxIndent; i > 0; i--, tx -= cxIndent) {

        if (tx < xcol &&
            pParent->leSiblings.Flink != &pParent->pParent->lhChildren) {
            BitBlt(
                hdcMem, tx, y, min(cxIndent, xcol - tx), ptl->cyItem,
                ptl->hdcImages, TL_VerticalLine * cxIndent, 0, SRCCOPY
                );
        }

        pParent = pParent->pParent;
    }


    //
    // draw the state image, if there is one,
    // and increment the left position by the width of the image
    //

    himl = ListView_GetImageList(pdis->hwndItem, LVSIL_STATE);

    if (himl != NULL && TL_StateImageValue(pItem)) {
        ImageList_GetIconSize(himl, &cxImage, &cyImage);
        ImageList_Draw(
            himl, TL_StateImageIndex(pItem), hdcMem,
            x, y + (ptl->cyItem - cyImage), ILD_NORMAL
            );

        x += cxImage;
    }


    //
    // draw the image, if there is an image list,
    // and increment the left position by the width of the image
    //

    himl = ListView_GetImageList(pdis->hwndItem, LVSIL_SMALL);
    if (himl != NULL && (pItem->lvi.mask & LVIF_IMAGE)) {
        ImageList_GetIconSize(himl, &cxImage, &cyImage);
        ImageList_Draw(
            himl, pItem->lvi.iImage, hdcMem,
            x, y + (ptl->cyItem - cyImage) / 2, ILD_NORMAL
            );

        x += cxImage;
    }


    //
    // compute the rectangle in the first column
    // which will be the clipping boundary for text
    //

    rc.left = x;
    rc.right = xcol;
    rc.top = rcItem.top;
    rc.bottom = rcItem.bottom;


    //
    // draw the first column's text
    //

    if (pItem->lvi.mask & LVIF_TEXT) {

        //
        // center the text vertically in the item-rectangle
        //

        psz = Ellipsisize(hdcMem, pItem->pszText, rc.right - rc.left, 0);
        ExtTextOut(
            hdcMem, rc.left + 2, rc.top + (ptl->cyItem - ptl->cyText) / 2,
            ETO_CLIPPED | ETO_OPAQUE, &rc, psz ? psz : pItem->pszText,
            lstrlen(psz ? psz : pItem->pszText), NULL
            );
        Free0(psz);
    }



    //
    // draw the subitems' texts
    //

    i = 1;
    phead = &pItem->lhSubitems;
    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        pSubitem = (TLSUBITEM *)CONTAINING_RECORD(ple, TLSUBITEM, leItems);


        //
        // we need to draw blank texts for subitems which have not been set;
        // this enables us to save memory on items which don't have
        // certain subitems set
        //

        for ( ; i < pSubitem->iSubItem; i++) {
            rc.left = rc.right;
            rc.right = rc.left + ListView_GetColumnWidth(pdis->hwndItem, i);
    
            ExtTextOut(
                hdcMem, rc.left + 2, rc.top + (ptl->cyItem - ptl->cyText) / 2,
                ETO_CLIPPED | ETO_OPAQUE, &rc, TEXT(""), 0, NULL
                );
        }


        //
        // now draw the text for the current item
        //

        rc.left = rc.right;
        rc.right = rc.left + ListView_GetColumnWidth(
                                pdis->hwndItem, pSubitem->iSubItem
                                );

        psz = Ellipsisize(hdcMem, pSubitem->pszText, rc.right - rc.left, 0);
        ExtTextOut(
            hdcMem, rc.left + 2, rc.top + (ptl->cyItem - ptl->cyText) / 2,
            ETO_CLIPPED | ETO_OPAQUE, &rc, psz ? psz : pSubitem->pszText,
            lstrlen(psz ? psz : pSubitem->pszText), NULL
            );
        Free0(psz);

        ++i;
    }


    //
    // we need to draw blank texts for subitems which have not been set
    //

    for ( ; i < (INT)ptl->nColumns; i++) {
        rc.left = rc.right;
        rc.right = rc.left + ListView_GetColumnWidth(pdis->hwndItem, i);

        ExtTextOut(
            hdcMem, rc.left + 2, rc.top + (ptl->cyItem - ptl->cyText) / 2,
            ETO_CLIPPED | ETO_OPAQUE, &rc, TEXT(""), 0, NULL
            );
    }


    //
    // restore the original background and text color
    //

#if 0
    if (pdis->itemState & ODS_SELECTED) {
        SetTextColor(pdis->hDC, GetSysColor(COLOR_WINDOWTEXT));
        SetBkColor(pdis->hDC, GetSysColor(COLOR_WINDOW));
    }
#endif


    //
    // draw the focus rectangle if necessary
    //

    if (pdis->itemState & ODS_FOCUS) {
        rc = rcItem;
        rc.left = min(x, xcol);
        DrawFocusRect(hdcMem, &rc);
    }


    //
    // Blt the changes to the screen DC
    //

    BitBlt(
        pdis->hDC, pdis->rcItem.left, pdis->rcItem.top, rcItem.right,
        rcItem.bottom, hdcMem, rcItem.left, rcItem.top, SRCCOPY
        );

    SelectObject(hdcMem, hbmpOld);
    SelectObject(hdcMem, hfontOld);

    DeleteDC(hdcMem);

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    TL_OnMeasureItem
//
// This is called by the listview when it needs to know
// the height of each item; we use this opportunity to rebuild
// the bitmap which holds images used for drawing tree lines.
//
// TODO: the listview currently seems to ignore the value we set,
// and instead uses the height of a small icon (SM_CYSMICON).
//----------------------------------------------------------------------------

VOID
TL_OnMeasureItem(
    TL *ptl,
    MEASUREITEMSTRUCT *pmis
    ) {

    HDC hdc;
    INT cyIcon;
    HFONT hfont;
    TEXTMETRIC tm;
    HWND hwndList;

    if (pmis->CtlType != ODT_LISTVIEW) { return; }

    //
    // retrieve the  listview, its font, and its device context
    //

    hwndList = GetDlgItem(ptl->hwnd, pmis->CtlID);

    hfont = GetWindowFont(hwndList);

    hdc = GetDC(hwndList);

    if(NULL == hdc)
    {
        return;
    }

    SelectObject(hdc, hfont);


    //
    // get the height of the listview's font
    //

    if (!GetTextMetrics(hdc, &tm)) 
    { 
        ReleaseDC(hwndList, hdc);
        return; 
    }

    ptl->cyText = tm.tmHeight;
    pmis->itemHeight = ptl->cyText;


    //
    // make sure the item height is at least as high as a small icon
    //

    cyIcon = GetSystemMetrics(SM_CYSMICON);
    if (pmis->itemHeight < (UINT)cyIcon) {
        pmis->itemHeight = cyIcon;
    }

    pmis->itemHeight += GetSystemMetrics(SM_CYBORDER);
#if 0
    pmis->itemHeight = (pmis->itemHeight + 1) & ~1;
#endif
    ptl->cyItem = pmis->itemHeight;
    ptl->cxIndent = GetSystemMetrics(SM_CXSMICON);

    ReleaseDC(hwndList, hdc);


    //
    // rebuild the images used in drawing tree lines
    //

    TL_CreateTreeImages(ptl);
}



//----------------------------------------------------------------------------
// Function:    TL_CreateColorBitmap
// 
// Utility function fro creating a color bitmap
//----------------------------------------------------------------------------

HBITMAP
TL_CreateColorBitmap(
    INT cx,
    INT cy
    ) {

    HDC hdc;
    HBITMAP hbmp;

    hdc = GetDC(NULL);

    if(NULL == hdc)
    {
        return NULL;
    }
    
    hbmp = CreateCompatibleBitmap(hdc, cx, cy);
    ReleaseDC(NULL, hdc);

    return hbmp;
}



//----------------------------------------------------------------------------
// Function:    TL_CreateTreeImages
//
// This function builds a list of images which are scaled to
// the height of each item in the tree. The appearance of the images
// is shown in ASCII text in the code below
//----------------------------------------------------------------------------

VOID
TL_CreateTreeImages(
    TL *ptl
    ) {

    HDC hdc;
    RECT rc;
    HBITMAP hbmpOld;
    INT cxIndent, x, c, xmid, ymid;
    HBRUSH hbrOld, hbrGrayText, hbrWinText;


    //
    // invalidate the listview's client area, to force a redraw
    //

    if (ptl->hwndList != NULL) { InvalidateRect(ptl->hwndList, NULL, TRUE); }


    //
    // create a device context if necessary
    //

    if (ptl->hdcImages == NULL) {
        ptl->hdcImages = CreateCompatibleDC(NULL);

        if(NULL == ptl->hdcImages)
        {
            return;
        }
    }


    hdc = ptl->hdcImages;
    cxIndent = ptl->cxIndent;

    ptl->hbrBk = FORWARD_WM_CTLCOLOREDIT(
                    ptl->hwndParent, hdc, ptl->hwnd, SendMessage
                    );

    //
    // create the bitmap to be used
    //

    hbmpOld = ptl->hbmp;
    ptl->hbmp = TL_CreateColorBitmap(TL_ImageCount * cxIndent, ptl->cyItem);
    if (hbmpOld == NULL) {
        ptl->hbmpStart = SelectObject(hdc, ptl->hbmp);
    }
    else {
        SelectObject(hdc, ptl->hbmp);
        DeleteObject(hbmpOld);
    }


    //
    // retreive system color brushes for drawing the tree images
    //

    hbrWinText = GetSysColorBrush(COLOR_WINDOWTEXT);
    hbrGrayText = GetSysColorBrush(COLOR_GRAYTEXT);

    hbrOld = SelectObject(hdc, hbrGrayText);

    rc.top = 0; rc.bottom = ptl->cyItem;
    rc.left = 0; rc.right = TL_ImageCount * cxIndent;


    //
    // fill the image with the background color
    //

    FillRect(hdc, &rc, ptl->hbrBk);

    xmid = cxIndent / 2;
    ymid = ((ptl->cyItem / 2) + 1) & ~1;

    c = min(xmid, ymid) / 2;


    //   |
    //   |

    x = TL_VerticalLine * cxIndent;
    TL_DottedLine(hdc, x + xmid, 0, ptl->cyItem, TRUE);


    //
    //   ---
    //

    x = TL_RootChildless * cxIndent;
    TL_DottedLine(hdc, x + xmid, ymid, cxIndent - xmid, FALSE);


    //
    //  +-+
    //  |+|--
    //  +-+
    //

    x = TL_RootParentCollapsed * cxIndent;
    TL_DottedLine(hdc, x + xmid, ymid, cxIndent - xmid, FALSE);
    TL_DrawButton(
        hdc, x + xmid, ymid, c, hbrWinText, hbrGrayText, ptl->hbrBk, TRUE
        );


    //
    //  +-+
    //  |-|--
    //  +-+
    //

    x = TL_RootParentExpanded * cxIndent;
    SelectObject(hdc, hbrGrayText);
    TL_DottedLine(hdc, x + xmid, ymid, cxIndent - xmid, FALSE);
    TL_DrawButton(
        hdc, x + xmid, ymid, c, hbrWinText, hbrGrayText, ptl->hbrBk, FALSE
        );


    //
    //   |
    //   +--
    //   |
    //

    x = TL_MidChildless * cxIndent;
    SelectObject(hdc, hbrGrayText);
    TL_DottedLine(hdc, x + xmid, 0, ptl->cyItem, TRUE);
    TL_DottedLine(hdc, x + xmid, ymid, cxIndent - xmid, FALSE);


    //
    //   |
    //  +-+
    //  |+|--
    //  +-+
    //   |
    //

    x = TL_MidParentCollapsed * cxIndent;
    TL_DottedLine(hdc, x + xmid, 0, ptl->cyItem, TRUE);
    TL_DottedLine(hdc, x + xmid, ymid, cxIndent - xmid, FALSE);
    TL_DrawButton(
        hdc, x + xmid, ymid, c, hbrWinText, hbrGrayText, ptl->hbrBk, TRUE
        );


    //
    //   |
    //  +-+
    //  |-|--
    //  +-+
    //   |
    //

    x = TL_MidParentExpanded * cxIndent;
    SelectObject(hdc, hbrGrayText);
    TL_DottedLine(hdc, x + xmid, 0, ptl->cyItem, TRUE);
    TL_DottedLine(hdc, x + xmid, ymid, cxIndent - xmid, FALSE);
    TL_DrawButton(
        hdc, x + xmid, ymid, c, hbrWinText, hbrGrayText, ptl->hbrBk, FALSE
        );


    //
    //   |
    //   +--
    //    

    x = TL_EndChildless * cxIndent;
    SelectObject(hdc, hbrGrayText);
    TL_DottedLine(hdc, x + xmid, 0, ymid, TRUE);
    TL_DottedLine(hdc, x + xmid, ymid, cxIndent - xmid, FALSE);


    //
    //   |
    //  +-+
    //  |+|--
    //  +-+
    //

    x = TL_EndParentCollapsed * cxIndent;
    TL_DottedLine(hdc, x + xmid, 0, ymid, TRUE);
    TL_DottedLine(hdc, x + xmid, ymid, cxIndent - xmid, FALSE);
    TL_DrawButton(
        hdc, x + xmid, ymid, c, hbrWinText, hbrGrayText, ptl->hbrBk, TRUE
        );


    //
    //   |
    //  +-+
    //  |-|--
    //  +-+
    //

    x = TL_EndParentExpanded * cxIndent;
    SelectObject(hdc, hbrGrayText);
    TL_DottedLine(hdc, x + xmid, 0, ymid, TRUE);
    TL_DottedLine(hdc, x + xmid, ymid, cxIndent - xmid, FALSE);
    TL_DrawButton(
        hdc, x + xmid, ymid, c, hbrWinText, hbrGrayText, ptl->hbrBk, FALSE
        );

    if (hbrOld != NULL) {
        SelectObject(hdc, hbrOld);
    }

    DeleteObject(hbrGrayText);
    DeleteObject(hbrWinText);

}



//----------------------------------------------------------------------------
// Function:    TL_DottedLine
//
// Draws a dotted line eiter vertically or horizontally,
// with the specified dimension as its length.
//----------------------------------------------------------------------------

VOID
TL_DottedLine(
    HDC hdc,
    INT x,
    INT y,
    INT dim,
    BOOL fVertical
    ) {

    for ( ; dim > 0; dim -= 2) {

        PatBlt(hdc, x, y, 1, 1, PATCOPY);

        if (fVertical) {
            y += 2;
        }
        else {
            x += 2;
        }
    }
}



//----------------------------------------------------------------------------
// Function:    TL_DrawButton
//
// Draws a button with a plus or a minus, centered at the given location
//----------------------------------------------------------------------------

VOID
TL_DrawButton(
    HDC hdc,
    INT x,
    INT y,
    INT dim,
    HBRUSH hbrSign,
    HBRUSH hbrBox,
    HBRUSH hbrBk,
    BOOL bCollapsed
    ) {

    int n;
    int p = (dim * 7) / 10;

    n = p * 2 + 1;

    //
    // first fill with the background color
    //

    SelectObject(hdc, hbrBk);
    PatBlt(hdc, x - dim, y - dim, dim * 2, dim * 2, PATCOPY);


    //
    // draw the sign
    //

    SelectObject(hdc, hbrSign);

    if (p >= 5) {

        PatBlt(hdc, x - p, y - 1, n, 3, PATCOPY);

        if (bCollapsed) {
            PatBlt(hdc, x - 1, y - p, 3, n, PATCOPY);
        }

        SelectObject(hdc, hbrBk);
        p--;
        n -= 2;
    }

    PatBlt(hdc, x - p, y, n, 1, PATCOPY);
    if (bCollapsed) {
        PatBlt(hdc, x, y - p, 1, n, PATCOPY);
    }

    n = dim * 2 + 1;


    //
    // draw the box around the sign
    // 

    SelectObject(hdc, hbrBox);

    PatBlt(hdc, x - dim, y - dim, n, 1, PATCOPY);
    PatBlt(hdc, x - dim, y - dim, 1, n, PATCOPY);
    PatBlt(hdc, x - dim, y + dim, n, 1, PATCOPY);
    PatBlt(hdc, x + dim, y - dim, 1, n, PATCOPY);
}



//----------------------------------------------------------------------------
// Function:    TL_UpdateListIndices
//
// This function updates the indices for all items in the tree
// which are visually below the specified item pStart, assuming that
// the list index for pStart is correct. Consider the case
// in the diagram below:
//
//      -- child 1
//      |   |- child 1,1
//      |   -- child 1,2
//      |- child 2
//      -- child 3
//      |   |- child 3,1
//      |   |   |- child 3,1,1
//      |   |   -- child 3,1,2
//      |   |- child 3,2
//      |   -- child 3,3
//      -- child 4
//
// Suppose that pStart points to "child 3,1". To set the indices,
// we first update the indices for all descendants of pStart,
// and then we update the indices for the siblings of pStart's ancestors
// which are after pStart's ancestors in the tree.
//----------------------------------------------------------------------------

VOID
TL_UpdateListIndices(
    TL *ptl,
    TLITEM *pStart
    ) {

    INT iIndex;

    iIndex = pStart->iIndex;

    if (pStart->nChildren > 0) {

        //
        // if the item is visible, set its index;
        // otherwise pass in NULL to set its index
        // and that of its descendants to -1
        //

        if (TL_IsExpanded(pStart) &&
            (pStart == &ptl->root || TL_IsVisible(pStart))) {
            TL_UpdateDescendantIndices(ptl, pStart, &iIndex);
        }
        else {
            TL_UpdateDescendantIndices(ptl, pStart, NULL);
        }
    }


    if (pStart->pParent != NULL) {
        TL_UpdateAncestorIndices(ptl, pStart, &iIndex);
    }

    ptl->root.iIndex = -1;
}



//----------------------------------------------------------------------------
// Function:    TL_UpdateDescendantIndices
//
// This function updates the indices of the descendants
// of the item specified. An item is not considered to be
// a descendant of itself.
//----------------------------------------------------------------------------

VOID
TL_UpdateDescendantIndices(
    TL *ptl,
    TLITEM *pStart,
    INT *piIndex
    ) {

    //
    // go through list of children setting indices
    //

    TLITEM *pItem;
    LIST_ENTRY *ple;

    for (ple = pStart->lhChildren.Flink;
         ple != &pStart->lhChildren; ple = ple->Flink) {

        pItem = (TLITEM *)CONTAINING_RECORD(ple, TLITEM, leSiblings);


        //
        // set the index of the child
        //

        pItem->iIndex = (piIndex ? ++(*piIndex) : -1);
   

        //
        // set the indices of the child's descendants
        //

        if (pItem->nChildren > 0) {

            //
            // if the item is visible, set its index;
            // otherwise pass in NULL to set its index
            // and that of its descendants to -1
            //

            if (TL_IsExpanded(pItem) && TL_IsVisible(pItem)) {
                TL_UpdateDescendantIndices(ptl, pItem, piIndex);
            }
            else {
                TL_UpdateDescendantIndices(ptl, pItem, NULL);
            }
        }
    }
}



//----------------------------------------------------------------------------
// Function:    TL_UpdateAncestorIndices
//
// This function updates the indices of the items which are
// visually below the specified item in the listview.
//----------------------------------------------------------------------------

VOID
TL_UpdateAncestorIndices(
    TL *ptl,
    TLITEM *pStart,
    INT *piIndex
    ) {

    TLITEM *pItem;
    LIST_ENTRY *ple;


    //
    // first set inidices for the siblings beneath this item;
    // note that we begin walking the siblings AFTER the item passed in,
    //

    for (ple = pStart->leSiblings.Flink;
         ple != &pStart->pParent->lhChildren;
         ple = ple->Flink) {

        pItem = (TLITEM *)CONTAINING_RECORD(ple, TLITEM, leSiblings);


        //
        // set the index for the sibling
        //

        pItem->iIndex = (piIndex ? ++(*piIndex) : -1);

        if (pItem->nChildren > 0) {

            //
            // if the item is visible, set its index;
            // otherwise pass in NULL to set its index
            // and that of its descendants to -1
            //

            if (TL_IsExpanded(pItem) && TL_IsVisible(pItem)) {
                TL_UpdateDescendantIndices(ptl, pItem, piIndex);
            }
            else {
                TL_UpdateDescendantIndices(ptl, pItem, NULL);
            }
        }
    }


    //
    // now set indices for the parent siblings which are beneath the parent
    //
    // TODO - OPTIMIZATION: this is post-recursion and therefore, it can 
    // be replaced by a loop, which at the very least would save stack 
    // space
    //

    if (pStart->pParent->pParent != NULL) {
        TL_UpdateAncestorIndices(ptl, pStart->pParent, piIndex);
    }
}



//----------------------------------------------------------------------------
// Function:    TL_NotifyParent
//
// Forwards a notification to the treelist's parent
//----------------------------------------------------------------------------

BOOL
TL_NotifyParent(
    TL *ptl,
    NMHDR *pnmh
    ) {

    return (BOOL)SendMessage(
                ptl->hwndParent, WM_NOTIFY, (WPARAM)ptl->hwnd, (LPARAM)pnmh
                );
}



//----------------------------------------------------------------------------
// Function:    TL_OnNotify
//
// Handles notifications from the listview window and its header control
//----------------------------------------------------------------------------

LRESULT
TL_OnNotify(
    TL *ptl,
    INT iCtrlId,
    NMHDR *pnmh
    ) {

    NMHDR nmh;
    TLITEM *pItem;


    //
    // notify parent of the message
    //

    if (TL_NotifyParent(ptl, pnmh)) { return FALSE; }



    switch (pnmh->code) {

        case HDN_ENDTRACK: {

            //
            // we need to redraw ourselves, AFTER the header resets;
            // hence the use of PostMessage instead of SendMessage
            //

            PostMessage(ptl->hwnd, TLM_REDRAW, (WPARAM)0, (LPARAM)0);
            return FALSE;
        }

        case NM_CLICK:
        case NM_DBLCLK: {

            //
            // do a hit-test;
            //

            POINT pt;
            INT iLeft; 
            LV_ITEM lvi;
            LV_HITTESTINFO lvhi;

            if (!GetCursorPos(&lvhi.pt)) { return FALSE; }
            ScreenToClient(ptl->hwndList, &lvhi.pt);

            if (ListView_HitTest(ptl->hwndList, &lvhi) == -1) { return FALSE; }

            if (!(lvhi.flags & LVHT_ONITEM)) { return FALSE; }


            //
            // see which part of the item was clicked
            //

            if (!ListView_GetItemPosition(ptl->hwndList, lvhi.iItem, &pt)) {
                return FALSE;
            }


            //
            // retrieve the item clicked
            //

            lvi.iItem = lvhi.iItem;
            lvi.iSubItem = 0;
            lvi.mask = LVIF_PARAM;
            if (!ListView_GetItem(ptl->hwndList, &lvi)) { return FALSE; }

            pItem = (TLITEM *)lvi.lParam;


            //
            // compute the position of the item's tree image
            //

            iLeft = pItem->iLevel * ptl->cxIndent;


            if (lvhi.pt.x > (pt.x + iLeft)) {

                //
                // the hit was to the right of the item's tree image
                //

                if (lvhi.pt.x < (pt.x + iLeft + (INT)ptl->cxIndent)) {

                    //
                    // the hit was on the item's tree image
                    //

                    if (pItem->nChildren > 0) {

                        //
                        // the +/- button was clicked, toggle expansion
                        //

                        return TL_OnExpand(ptl, TLE_TOGGLE, (HTLITEM)pItem);
                    }
                }
                else {
    
                    //
                    // the hit was on the item's state icon, image, or text
                    //


                    //
                    // see if the parent wants to handle it
                    //

                    nmh.code = pnmh->code;
                    nmh.idFrom = 0;
                    nmh.hwndFrom = ptl->hwnd;

                    TL_NotifyParent(ptl, &nmh);
                    if (nmh.idFrom != 0) { return TRUE; }


                    if (pnmh->code == NM_DBLCLK && pItem->nChildren > 0) {

                        //
                        // the item was double-clicked, toggle expansion
                        //

                        return TL_OnExpand(
                                    ptl, TLE_TOGGLE, (HTLITEM)pItem
                                    );
                    }
                }
            }
    
            return FALSE;
        }

        case NM_RETURN: {

            //
            // get current selection;
            // if a parent item, toggle expand-state
            //

            LV_ITEM lvi;

            lvi.iItem = ListView_GetNextItem(ptl->hwndList, -1, LVNI_SELECTED);
            if (lvi.iItem == -1) { return FALSE; }

            lvi.iSubItem = 0;
            lvi.mask = LVIF_PARAM;
            if (!ListView_GetItem(ptl->hwndList, &lvi)) { return FALSE; }

            pItem = (TLITEM *)lvi.lParam;

            if (pItem->nChildren > 0) {

                //
                // the item has children, toggle expand state
                //

                return TL_OnExpand(ptl, TLE_TOGGLE, (HTLITEM)pItem);
            }

            return FALSE;
        }

        case LVN_KEYDOWN: {

            //
            // get key pressed and current selection;
            // if a parent item and key is '+', expand;
            // if key is '-' or left key, collapse
            // if key is VK_RIGHT, expand and move to first child;
            // if key is VK_LEFT, collapse parent and move to parent
            //

            LV_ITEM lvi;
            LV_KEYDOWN *plvk;

            plvk = (LV_KEYDOWN *)pnmh;

            switch (plvk->wVKey) {

                case VK_RIGHT:
                case VK_ADD: {
    
                    //
                    // retrieve the item
                    //

                    lvi.iItem = ListView_GetNextItem(
                                    ptl->hwndList, -1, LVNI_SELECTED
                                    );
                    if (lvi.iItem == -1) { return FALSE; }
        
                    lvi.iSubItem = 0;
                    lvi.mask = LVIF_PARAM;
                    if (!ListView_GetItem(ptl->hwndList, &lvi)) {
                        return FALSE;
                    }
        

                    //
                    // expand the item if it is collapsed
                    //

                    pItem = (TLITEM *)lvi.lParam;

                    if (pItem->nChildren <= 0) { return FALSE; }

                    if (!TL_IsExpanded(pItem)) {
                        return TL_OnExpand(ptl, TLE_EXPAND, (HTLITEM)pItem);
                    }
                    else
                    if (plvk->wVKey == VK_RIGHT) {

                        //
                        // the key was VK_RIGHT,
                        // so we select the item's child
                        //

                        pItem = (TLITEM *)CONTAINING_RECORD(  
                                    pItem->lhChildren.Flink, TLITEM, leSiblings
                                    );

                        if (TL_OnSetSelection(ptl, (HTLITEM)pItem)) {
                            return ListView_EnsureVisible(
                                        ptl->hwndList, pItem->iIndex, FALSE
                                        );
                        }
                    }

                    break;
                }

                case VK_LEFT:
                case VK_SUBTRACT: {
    
                    //
                    // retrieve the current selection
                    //

                    lvi.iItem = ListView_GetNextItem(
                                    ptl->hwndList, -1, LVNI_SELECTED
                                    );
                    if (lvi.iItem == -1) { return FALSE; }
        
                    lvi.iSubItem = 0;
                    lvi.mask = LVIF_PARAM;
                    if (!ListView_GetItem(ptl->hwndList, &lvi)) {
                        return FALSE;
                    }
        

                    //
                    // collapse the item if it is expanded;
                    // otherwise, if the key is VK_LEFT,
                    // select the item's parent
                    //

                    pItem = (TLITEM *)lvi.lParam;

                    if (pItem->nChildren > 0) {
                        return TL_OnExpand(ptl, TLE_COLLAPSE, (HTLITEM)pItem);
                    }
                    else
                    if (plvk->wVKey == VK_LEFT &&
                        pItem->pParent != &ptl->root) {

                        if (TL_OnSetSelection(ptl, (HTLITEM)pItem->pParent)) {
                            return ListView_EnsureVisible(
                                        ptl->hwndList, pItem->pParent->iIndex,
                                        FALSE
                                        );
                        }
                    }

                    break;
                }
            }

            return FALSE;
        }

        case LVN_ITEMCHANGED: {

            NMTREELIST nmtl;
            NM_LISTVIEW *pnmlv;

            pnmlv = (NM_LISTVIEW *)pnmh;

            if ((pnmlv->uChanged & LVIF_STATE)) {
    
                if (pnmlv->uNewState & LVIS_SELECTED) {

                    //
                    // the new state is selected;
                    // notify the parent that the selection has changed
                    //
        
                    nmtl.hdr.hwndFrom = ptl->hwnd;
                    nmtl.hdr.code = TLN_SELCHANGED;
                    nmtl.hItem = (HTLITEM)pnmlv->lParam;
                    nmtl.lParam = ((TLITEM *)nmtl.hItem)->lParam;
    
                    return TL_NotifyParent(ptl, (NMHDR *)&nmtl);
                }
            }

            return FALSE;
        }

        case LVN_DELETEITEM: {

            INT iItem;
            LV_ITEM lvi;
            TLITEM *pNext;
            NM_LISTVIEW *pnmlv;

            //
            // get the item which is selected
            //

            pnmlv = (NM_LISTVIEW *)pnmh;

            iItem = ListView_GetNextItem(ptl->hwndList, -1, LVNI_SELECTED);

            if (iItem != -1) { return FALSE; }


            //
            // the deleted item was selected,
            // so select another item
            //

            lvi.mask = LVIF_PARAM;
            lvi.iItem = pnmlv->iItem;
            lvi.iSubItem = 0;
            if (!ListView_GetItem(ptl->hwndList, &lvi)) { return FALSE; }


            pItem = (TLITEM *)lvi.lParam;


            //
            // choose sibling item before this one
            //

            pNext = (TLITEM *)TL_OnGetNextItem(
                        ptl, TLGN_PREVSIBLING, (HTLITEM)pItem
                        );

            if (pNext == NULL) {

                //
                // that failed, so choose the sibling after this one
                //

                pNext = (TLITEM *)TL_OnGetNextItem(
                            ptl, TLGN_NEXTSIBLING, (HTLITEM)pItem
                            );

                if (pNext == NULL) {

                    //
                    // that failed too, so choose the parent
                    // so long as the parent isn't the root
                    //

                    pNext = pItem->pParent;
                    if (pNext == &ptl->root) { return FALSE; }
                }
            }


            return TL_OnSetSelection(ptl, (HTLITEM)pNext);
        }
    }

    return FALSE;
}



//----------------------------------------------------------------------------
// Function:    TL_UpdateImage
//
// This function updates the tree image for an item 
// when the item's state changes; this is called when an item
// is inserted or deleted, or expanded or collapsed.
// Insertion or deletions can have side-effects, as follows:
//
// (1) an item is inserted as the child of a previously childless item;
//      the parent's image changes to show a collapsed button
//          
// (2) an item is inserted as the last child of a parent which
//      had children; the image of the item which used to be
//      the parent's last child changes:
//          parent              parent
//             -- old     --->      |- old
//                                  -- new
//
// (3) the reverse of case 1, i.e. an item is removed which was
//      the only child of a parent item; the parent's image changes
//      to show that it is childless
//
// (4) the reverse of case 2, i.e. an item is removed which was
//      the last child of a parent which has other children;
//      the image of the item which will now be the last child changes
//
// In all of these cases, the item to which the side-effect occurs
// is written into ppChanged; so the caller can update the image
// for that item as well
//----------------------------------------------------------------------------

VOID
TL_UpdateImage(
    TL *ptl,
    TLITEM *pItem,
    TLITEM **ppChanged
    ) {

    INT iImage;
    TLITEM *pChanged;

    if (ppChanged == NULL) { ppChanged = &pChanged; }

    *ppChanged = NULL;


    //
    // special case for root-level items
    //

    if (pItem->pParent == &ptl->root) {

        if (pItem->nChildren == 0) {
            pItem->iImage = TL_RootChildless;
        }
        else {
            pItem->iImage = TL_IsExpanded(pItem) ? TL_RootParentExpanded
                                                 : TL_RootParentCollapsed;
        }
    }
    else
    if (pItem->leSiblings.Flink == &pItem->pParent->lhChildren) {

        //
        // item is last of its parent's children
        //

        if (pItem->nChildren == 0) {
            pItem->iImage = TL_EndChildless;
        }
        else {
            pItem->iImage = TL_IsExpanded(pItem) ? TL_EndParentExpanded
                                                 : TL_EndParentCollapsed;
        }

        //
        // if this is the only child, the parent was childless and
        // its image should change; otherwise, the child before this one
        // used to be the last child and its image should change
        //

        if (pItem->leSiblings.Blink == &pItem->pParent->lhChildren) {
            *ppChanged = pItem->pParent;
        }
        else {
            *ppChanged = (TLITEM *)CONTAINING_RECORD(
                            pItem->leSiblings.Blink, TLITEM, leSiblings
                            );
        }
    }
    else {

        //
        // item is not last of its parent's children
        //

        if (pItem->nChildren == 0) {
            pItem->iImage = TL_MidChildless;
        }
        else {
            pItem->iImage = TL_IsExpanded(pItem) ? TL_MidParentExpanded
                                                 : TL_MidParentCollapsed;
        }
    }
    
    return;
}



//----------------------------------------------------------------------------
// Function:    TL_OnInsertItem
//
// Inserts an item with the properties specified in the given LV_ITEM,
// and returns a handle to the item inserted
//----------------------------------------------------------------------------

HTLITEM
TL_OnInsertItem(
    TL *ptl,
    TL_INSERTSTRUCT *ptlis
    ) {

    LV_ITEM *plvi;
    LIST_ENTRY *ple, *phead;
    BOOL bParentVisible;
    TLITEM *pItem, *pChanged, *pTemp;

    if (ptlis == NULL) { return NULL; }


    //
    // set up the new item
    //

    pItem = (TLITEM *)Malloc(sizeof(TLITEM));
    if (pItem == NULL) { return NULL; }

    ZeroMemory(pItem, sizeof(TLITEM));

    if (ptlis->plvi->mask & LVIF_TEXT) {
        pItem->pszText = StrDup(ptlis->plvi->pszText);
        if (pItem->pszText == NULL) {
            Free(pItem); return NULL;
        }
    }


    //
    // set up the private members
    //

    pItem->uiFlag = 0;
    pItem->nChildren = 0;
    InitializeListHead(&pItem->lhSubitems);
    InitializeListHead(&pItem->lhChildren);
    pItem->pParent = (TLITEM *)ptlis->hParent;
    if (pItem->pParent == NULL) {
        pItem->pParent = &ptl->root;
    }
    ++pItem->pParent->nChildren;
    pItem->iLevel = pItem->pParent->iLevel + 1;


    //
    // set up the listview item
    //

    plvi = ptlis->plvi;
    pItem->lvi = *plvi;

    pItem->lParam = plvi->lParam;
    pItem->lvi.lParam = (LPARAM)pItem;
    pItem->lvi.pszText = pItem->pszText;
    pItem->lvi.mask |= LVIF_PARAM;


    //
    // insert this item amongst its siblings
    //

    // switch (PtrToUlong(ptlis->hInsertAfter)) {

    if(ptlis->hInsertAfter == TLI_FIRST)
    {

        InsertHeadList(&pItem->pParent->lhChildren, &pItem->leSiblings);
    }
    else if (ptlis->hInsertAfter == TLI_LAST)
    {

        InsertTailList(&pItem->pParent->lhChildren, &pItem->leSiblings);
    }
    else if (ptlis->hInsertAfter == TLI_SORT)
    {

        phead = &pItem->pParent->lhChildren;

        for (ple = phead->Flink; ple != phead; ple = ple->Flink) {
            pTemp = (TLITEM *)CONTAINING_RECORD(ple, TLITEM, leSiblings);
            if (lstrcmp(pItem->pszText, pTemp->pszText) < 0) {
                break;
            }
        }

        InsertTailList(ple, &pItem->leSiblings);

    }
    else
    {

        TLITEM *pPrev;

        pPrev = (TLITEM *)ptlis->hInsertAfter;

        InsertHeadList(&pPrev->leSiblings, &pItem->leSiblings);
    }
    //}



    //
    // set the item's image. if this was inserted
    // as the last child, we need to change the image
    // for the original last child, if any; otherwise,
    // if this is the first child of its parent, the image
    // for the parent must be changed
    //

    TL_UpdateImage(ptl, pItem, &pChanged);
    if (pChanged != NULL) { TL_UpdateImage(ptl, pChanged, NULL); }


    if (pItem->pParent != &ptl->root && !TL_IsVisible(pItem->pParent)) {
        pItem->iIndex = -1;
    }
    else {

        //
        // the item's parent is visible;
        // update the indices after the item's parent
        //

        TL_UpdateListIndices(ptl, pItem->pParent);


        //
        // insert the item in the list if its parent is expanded
        //

        if (TL_IsExpanded(pItem->pParent)) {

            INT iItem, iCol;

            //
            // In owner-draw mode, there is a bug in the listview code
            // where if an item has the focus but is not selected,
            // and then a new item is inserted above it and selected,
            // the focus rectangle remains on the item which had the focus
            //
            // To work around this, clear the focus if it is on the item
            // below the item just inserted
            //

            iItem = ListView_GetNextItem(ptl->hwndList, -1, LVNI_FOCUSED);


            pItem->lvi.iItem = pItem->iIndex;
            pItem->lvi.iSubItem = 0;
            ListView_InsertItem(ptl->hwndList, &pItem->lvi);


            //
            // if the item below this had the focus, clear the focus
            //

            if (iItem != -1 && iItem >= pItem->iIndex) {

                ListView_SetItemState(
                    ptl->hwndList, -1, 0, LVNI_FOCUSED
                    );
            }


            //
            // There is a bug in the listview code which shows up
            // when an item is inserted with no subitem,
            // and than an item is inserted above it with a subitem.
            // When a third item is inserted at the bottom of the list,
            // the insertion fails because there are now three items but
            // the last subitem belongs to item 1.
            //  (See cairoshl\commctrl\listview.c, ListView_OnInsertItem())
            //
            // We get around this by setting blank text for each column
            //

            for (iCol = 1; iCol < (INT)ptl->nColumns; iCol++) {
                ListView_SetItemText(
                    ptl->hwndList, pItem->iIndex, iCol, TEXT("")
                    );
            }

    
            //
            // redraw the changed item as well
            //

            if (pChanged != NULL) {
    
                pChanged->lvi.iItem = pChanged->iIndex;
                ListView_RedrawItems(
                    ptl->hwndList, pChanged->lvi.iItem, pChanged->lvi.iItem
                    );
            }


        }
        else
        if (pChanged != NULL && pChanged == pItem->pParent) {
    
            //
            // the parent is visible, and it has changed, so redraw it
            //

            ListView_RedrawItems(
                ptl->hwndList, pChanged->iIndex, pChanged->iIndex
                );
        }
    }

    return (HTLITEM)pItem;
}



//----------------------------------------------------------------------------
// Function:    TL_OnDeleteItem
//
// Removes the item with the specified handle from the treelist.
//----------------------------------------------------------------------------

BOOL
TL_OnDeleteItem(
    TL *ptl,
    HTLITEM hItem
    ) {

    TLITEM *pItem, *pChanged, *pParent;

    pItem = (TLITEM *)hItem;
    pParent = pItem->pParent;


    //
    // if the item is visible and expanded,
    // collapse it to simplify the deletion
    //

    if (TL_IsVisible(pItem) && TL_IsExpanded(pItem)) {
        TL_OnExpand(ptl, TLE_COLLAPSE, hItem);
    }


    //
    // see if there is a sibling after this item.
    // if there is, nothing changes when the item is deleted
    //
    pChanged = TL_OnGetNextItem(ptl, TLGN_NEXTSIBLING, (HTLITEM)pItem);

    if (pChanged != NULL) { pChanged = NULL; }
    else {

        //
        // this item is the last of its parent's children, so the change
        // is to the item's previous sibling, if any
        //

        pChanged = TL_OnGetNextItem(ptl, TLGN_PREVSIBLING, (HTLITEM)pItem);

        if (pChanged == NULL) {

            //
            // this item is its parent's only child, so the change 
            // is to the item's parent
            //

            if (pParent != &ptl->root) { pChanged = pParent; }
        }
    }
        

    //
    // delete the item and its descendants
    //

    TL_DeleteAndNotify(ptl, pItem);


    //
    // if there was a side-effect, update the affected item
    //

    if (pChanged != NULL) { TL_UpdateImage(ptl, pChanged, NULL); }


    //
    // update the indices of the items below the deleted item
    //

    TL_UpdateListIndices(ptl, pParent);

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    TL_DeleteAndNotify
//
// This function performs a recursive deletion on a subtree,
// notifying the treelist's parent as each item is removed
//----------------------------------------------------------------------------

VOID
TL_DeleteAndNotify(
    TL *ptl,
    TLITEM *pItem
    ) {

    NMTREELIST nmtl;
    TLSUBITEM *pSubitem;
    LIST_ENTRY *ple, *phead;
    TLITEM *pChild, *pChanged;


    //
    // do deletions on all descendants first
    // note that the entry will be removed inside the recursive call,
    // hence we walk the last be always picking off its head
    //

    phead = &pItem->lhChildren;
    for (ple = phead->Flink; ple != phead; ple = phead->Flink) {

        pChild = (TLITEM *)CONTAINING_RECORD(ple, TLITEM, leSiblings);

        TL_DeleteAndNotify(ptl, pChild);
    }


    //
    // notify the owner before completing the deletion
    //

    nmtl.hdr.hwndFrom = ptl->hwnd;
    nmtl.hdr.code = TLN_DELETEITEM;
    nmtl.hItem = (HTLITEM)pItem;
    nmtl.lParam = pItem->lParam;
    TL_NotifyParent(ptl, (NMHDR *)&nmtl);



    //
    // remove the entry from the listview if it is visible
    //

    if (TL_IsVisible(pItem)) {
        ListView_DeleteItem(ptl->hwndList, pItem->iIndex);
    }


    //
    // remove the entry from the list of its siblings
    //

    RemoveEntryList(&pItem->leSiblings);
    --pItem->pParent->nChildren;
    if (pItem->pParent->nChildren == 0 && pItem->pParent != &ptl->root) {
        pItem->pParent->uiFlag &= ~TLI_EXPANDED;
    }


    //
    // free the memory used by all its subitems, and free this item itself
    //

    while (!IsListEmpty(&pItem->lhSubitems)) {

        ple = RemoveHeadList(&pItem->lhSubitems);

        pSubitem = (TLSUBITEM *)CONTAINING_RECORD(ple, TLSUBITEM, leItems);

        Free0(pSubitem->pszText);
        Free(pSubitem);
    }

    Free0(pItem->pszText);
    Free(pItem);
}



//----------------------------------------------------------------------------
// Function:    TL_OnDeleteAllItems
//
// This function handles the case of deleting all items in the tree.
//----------------------------------------------------------------------------

BOOL
TL_OnDeleteAllItems(
    TL *ptl
    ) {

    LIST_ENTRY *ple, *phead;
    TLITEM *pItem, *pParent;
    
    ListView_DeleteAllItems(ptl->hwndList);

    phead = &ptl->root.lhChildren;

    for (ple = phead->Flink; ple != phead; ple = phead->Flink) {

        pItem = (TLITEM *)CONTAINING_RECORD(ple, TLITEM, leSiblings);

        TL_DeleteAndNotify(ptl, pItem);
    }

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    TL_OnGetItem
//
// This function is called to retrieve a specific item from the treelist
//----------------------------------------------------------------------------

BOOL
TL_OnGetItem(
    TL *ptl,
    LV_ITEM *plvi
    ) {

    PTSTR psz;
    TLITEM *pItem;
    TLSUBITEM *pSubitem;
    LIST_ENTRY *ple, *phead;

    psz = NULL;
    pItem = (TLITEM *)UlongToPtr(plvi->iItem);


    //
    // get a pointer to the text for the item (or subitem)
    //

    if (plvi->iSubItem == 0) {
        psz = pItem->pszText;
    }
    else
    if (plvi->mask & LVIF_TEXT) {

        phead = &pItem->lhSubitems;

        for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

            pSubitem = (TLSUBITEM *)CONTAINING_RECORD(ple, TLSUBITEM, leItems);
            if (pSubitem->iSubItem == plvi->iSubItem) {
                psz = pSubitem->pszText; break;
            }
        }

        if (psz == NULL) { return FALSE; }
    }
        

    //
    // retrieve the fields requested
    //

    if (plvi->mask & LVIF_TEXT) {
        lstrcpyn(plvi->pszText, psz, plvi->cchTextMax);
    }

    if (plvi->mask & LVIF_IMAGE) {
        plvi->iImage = pItem->lvi.iImage;
    }

    if (plvi->mask & LVIF_PARAM) {
        plvi->lParam = pItem->lParam;
    }

    if (plvi->mask & LVIF_STATE) {
        plvi->state = pItem->lvi.state;
    }

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    TL_OnSetItem
//
// This function changes a specific item (or subitem).
//----------------------------------------------------------------------------

BOOL
TL_OnSetItem(
    TL *ptl,
    LV_ITEM *plvi
    ) {

    PTSTR *psz;
    UINT uiMask;
    BOOL bSuccess;
    TLITEM *pItem;
    TLSUBITEM *pSubitem;
    LIST_ENTRY *ple, *phead;

    psz = NULL;
    uiMask = 0;
    pItem = (TLITEM *)UlongToPtr(plvi->iItem);

    //
    // retrieve the text pointer for the item (or subitem)
    //

    if (plvi->iSubItem == 0) {
        psz = &pItem->pszText;
    }
    else 
    if (plvi->mask & LVIF_TEXT) {

        //
        // search for the specified subitem
        //

        phead = &pItem->lhSubitems;

        for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

            pSubitem = (TLSUBITEM *)CONTAINING_RECORD(ple, TLSUBITEM, leItems);
            if (pSubitem->iSubItem > plvi->iSubItem) {
                break;
            }
            else
            if (pSubitem->iSubItem == plvi->iSubItem) {
                psz = &pSubitem->pszText; break;
            }
        }

        if (psz == NULL) { 

            //
            // create a new subitem
            //

            pSubitem = (TLSUBITEM *)Malloc(sizeof(TLSUBITEM));
            if (pSubitem == NULL) { return FALSE; }

            InsertTailList(ple, &pSubitem->leItems);

            pSubitem->iSubItem = plvi->iSubItem;
            pSubitem->pszText = NULL;
            psz = &pSubitem->pszText;
        }
    }


    //
    // update the fields to be changed
    //

    if (plvi->mask & LVIF_TEXT) {
        PTSTR pszTemp;

        uiMask |= LVIF_TEXT;
        pszTemp = StrDup(plvi->pszText);
        if (!pszTemp) { return FALSE; }
        Free0(*psz); *psz = pszTemp;
    }

    if (plvi->mask & LVIF_IMAGE) {
        uiMask |= LVIF_IMAGE;
        pItem->lvi.iImage = plvi->iImage;
    }

    if (plvi->mask & LVIF_PARAM) {
        pItem->lParam = plvi->lParam;
    }

    if (plvi->mask & LVIF_STATE) {
        uiMask |= LVIF_STATE;
        pItem->lvi.stateMask = plvi->stateMask;
        pItem->lvi.state = plvi->state;
    }

    bSuccess = TRUE;
    pItem->lvi.mask |= uiMask;


    //
    // update the item's appearance if it is visible
    //

    if (TL_IsVisible(pItem)) {

        UINT uiOldMask = pItem->lvi.mask;

        pItem->lvi.mask = uiMask;

        if(NULL != psz)
        {
            pItem->lvi.pszText = *psz;
        }
        
        pItem->lvi.iSubItem = plvi->iSubItem;

        bSuccess = ListView_SetItem(ptl->hwndList, &pItem->lvi);
        if (bSuccess) {
            ListView_RedrawItems(ptl->hwndList, pItem->iIndex, pItem->iIndex);
        }

        pItem->lvi.mask = uiOldMask;
        pItem->lvi.pszText = pItem->pszText;
        pItem->lvi.iSubItem = 0;
    }

    return bSuccess;
}



//----------------------------------------------------------------------------
// Function:    TL_GetItemCount
//
// This function retrieves a count of the items in the treelist
//----------------------------------------------------------------------------

UINT
TL_OnGetItemCount(
    TL *ptl
    ) {

    INT iCount = 0;

    //
    // count the items in the subtree rooted at the invisible root,
    // and decrement by one to exclude the root itself
    //

    TL_CountItems(&ptl->root, &iCount);

    return (UINT)(iCount - 1);
}



//----------------------------------------------------------------------------
// Function:    TL_CountItems
//
// This function recursively counts the items in the specified subtree
//----------------------------------------------------------------------------

VOID
TL_CountItems(
    TLITEM *pParent,
    INT *piCount
    ) {

    TLITEM *pItem;
    LIST_ENTRY *ple, *phead;

    ++(*piCount);

    phead = &pParent->lhChildren;

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {
        pItem = (TLITEM *)CONTAINING_RECORD(ple, TLITEM, leSiblings);

        TL_CountItems(pItem, piCount);
    }

    return;
}



//----------------------------------------------------------------------------
// Function:    TL_OnGetNextItem
//
// This function retrieves an item with a given property,
// or relative to a specified item
//----------------------------------------------------------------------------

HTLITEM
TL_OnGetNextItem(
    TL *ptl,
    UINT uiFlag,
    HTLITEM hItem
    ) {

    TLITEM *pItem;
    LIST_ENTRY *ple, *phead;

    pItem = (TLITEM *)hItem;

    switch (uiFlag) {

        case TLGN_FIRST: {

            if (IsListEmpty(&ptl->root.lhChildren)) {
                return NULL;
            }

            ple = ptl->root.lhChildren.Flink;

            return (HTLITEM)CONTAINING_RECORD(ple, TLITEM, leSiblings);
        }

        case TLGN_PARENT: {
            if (pItem->pParent == &ptl->root) {
                return NULL;
            }

            return (HTLITEM)pItem->pParent;
        }

        case TLGN_CHILD: {

            if (IsListEmpty(&pItem->lhChildren)) {
                return NULL;
            }

            ple = pItem->lhChildren.Flink;

            return (HTLITEM)CONTAINING_RECORD(ple, TLITEM, leSiblings);
        }

        case TLGN_NEXTSIBLING: {

            phead = &pItem->pParent->lhChildren;

            ple = pItem->leSiblings.Flink;
            if (ple == phead) { return NULL; }

            return (HTLITEM)CONTAINING_RECORD(ple, TLITEM, leSiblings);
        }

        case TLGN_PREVSIBLING: {

            phead = &pItem->pParent->lhChildren;

            ple = pItem->leSiblings.Blink;
            if (ple == phead) { return NULL; }

            return (HTLITEM)CONTAINING_RECORD(ple, TLITEM, leSiblings);
        }

        case TLGN_ENUMERATE: {
    
            TLITEM *pNext;

            if (pItem == NULL) {
                return TL_OnGetNextItem(ptl, TLGN_FIRST, NULL);
            }

            pNext = (TLITEM *)TL_OnGetNextItem(ptl, TLGN_CHILD, hItem);

            if (pNext == NULL) {

                pNext = TL_OnGetNextItem(ptl, TLGN_NEXTSIBLING, hItem);

                if (pNext == NULL) {

                    for (pItem = pItem->pParent;
                         pItem != &ptl->root; pItem = pItem->pParent) {
                        pNext = TL_OnGetNextItem(
                                    ptl, TLGN_NEXTSIBLING, (HTLITEM)pItem
                                    );
                        if (pNext != NULL) { break; }
                    }
                }
            }

            return pNext;
        }

        case TLGN_SELECTION: {

            INT iItem;
            LV_ITEM lvi;

            iItem = ListView_GetNextItem(ptl->hwndList, -1, LVNI_SELECTED);
            if (iItem == -1) {

                iItem = ListView_GetNextItem(ptl->hwndList, -1, LVNI_FOCUSED);

                if (iItem == -1)  { return NULL; }
            }

            lvi.iItem = iItem;
            lvi.iSubItem = 0;
            lvi.mask = LVIF_PARAM;

            if (!ListView_GetItem(ptl->hwndList, &lvi)) { return NULL; }

            return (HTLITEM)lvi.lParam;
        }
    }

    return NULL;
}



//----------------------------------------------------------------------------
// Function:    TL_OnExpand
//
// This is called to expand or collapse an item,
// or to toggle the expand-state of an item
//----------------------------------------------------------------------------

BOOL
TL_OnExpand(
    TL *ptl,
    UINT uiFlag,
    HTLITEM hItem
    ) {

    TLITEM *pItem;
    BOOL bSuccess;

    pItem = (TLITEM *)hItem;

    if (pItem->uiFlag & TLI_EXPANDED) {

        // item is expanded already, do nothing
        if (uiFlag == TLE_EXPAND) {
            return TRUE;
        }

        bSuccess = TL_ItemCollapse(ptl, pItem);
    }
    else {

        // item is collapsed already, do nothing
        if (uiFlag == TLE_COLLAPSE) {
            return TRUE;
        }

        bSuccess = TL_ItemExpand(ptl, pItem);
    }


    //
    // update the list indices and redraw the item expanded/collapsed
    //

    if (bSuccess) {
        ListView_RedrawItems(ptl->hwndList, pItem->iIndex, pItem->iIndex);
    }

    return bSuccess;
}



//----------------------------------------------------------------------------
// Function:    TL_ItemCollapse
//
// Collapses an item
//----------------------------------------------------------------------------

BOOL
TL_ItemCollapse(
    TL *ptl,
    TLITEM *pItem
    ) {

    INT i, iItem;
    TLITEM *pChild;
    LIST_ENTRY *ple, *phead;


    if (pItem->nChildren == 0 || !TL_IsExpanded(pItem)) { return FALSE; }


    //
    // first collapse all descendants;
    // note that this is done in reverse order,
    // so that the indices of the higher items remain valid
    // while the lower ones are being removed
    //

    phead = &pItem->lhChildren;

    for (ple = phead->Blink; ple != phead; ple = ple->Blink) {
        pChild = (TLITEM *)CONTAINING_RECORD(ple, TLITEM, leSiblings);
        TL_ItemCollapse(ptl, pChild);
    }


    //
    // delete all this item's children (they are now collapsed);
    // since the listview shifts items up when an item is deleted,
    // we delete items n through m by deleting item n (m-n)+1 times
    //

    iItem = pItem->iIndex;

    for (i = 0; i < (INT)pItem->nChildren; i++) {
        ListView_DeleteItem(ptl->hwndList, iItem + 1);
    }

    pItem->uiFlag &= ~TLI_EXPANDED;

    TL_UpdateImage(ptl, pItem, NULL);
    TL_UpdateListIndices(ptl, pItem);

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    TL_ItemExpand
//
// Expands an item
//----------------------------------------------------------------------------

BOOL
TL_ItemExpand(
    TL *ptl,
    TLITEM *pItem
    ) {

    INT i;
    TLITEM *pChild;
    TLSUBITEM *pSubitem;
    LIST_ENTRY *ple, *phead, *ples, *psubhead;


    if (pItem->nChildren == 0 || TL_IsExpanded(pItem)) { return FALSE; }


    //
    // update the expand-state and image for the item,
    // and then recompute the indices of its children
    //

    pItem->uiFlag |= TLI_EXPANDED;
    TL_UpdateImage(ptl, pItem, NULL);
    TL_UpdateListIndices(ptl, pItem);


    //
    // insert items below this one;
    // we also need to set the sub-item text for each inserted item
    //

    phead = &pItem->lhChildren;

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        pChild = (TLITEM *)CONTAINING_RECORD(ple, TLITEM, leSiblings);

        pChild->lvi.iItem = pChild->iIndex;
        pChild->lvi.iSubItem = 0;

        TL_UpdateImage(ptl, pChild, NULL);

        ListView_InsertItem(ptl->hwndList, &pChild->lvi);

        psubhead = &pChild->lhSubitems;

        i = 1;
        for (ples = psubhead->Flink; ples != psubhead; ples = ples->Flink) {

            pSubitem = (TLSUBITEM *)CONTAINING_RECORD(ples, TLSUBITEM, leItems);

            for ( ; i < pSubitem->iSubItem; i++) {
                ListView_SetItemText(
                    ptl->hwndList, pChild->iIndex, i, TEXT("")
                    );
            }

            ListView_SetItemText(
                ptl->hwndList, pChild->iIndex, pSubitem->iSubItem,
                pSubitem->pszText
                );

            ++i;
        }

        for ( ; i < (INT)ptl->nColumns; i++) {
            ListView_SetItemText(
                ptl->hwndList, pChild->iIndex, i, TEXT("")
                );
        }
    }

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    TL_OnInsertColumn
//
// Inserts a column. Memory for subitem's is not allocated until
// the subitems' texts aer actually set in TL_OnSetItem
//----------------------------------------------------------------------------

INT
TL_OnInsertColumn(
    TL *ptl,
    INT iCol,
    LV_COLUMN *pCol
    ) {

    if ((iCol = ListView_InsertColumn(ptl->hwndList, iCol, pCol)) != -1) {
        ++ptl->nColumns;
    }

    return iCol;
}



//----------------------------------------------------------------------------
// Function:    TL_OnDeleteColumn
//
// Deletes a column, and removes all subitems corresponding to the column
//----------------------------------------------------------------------------

BOOL
TL_OnDeleteColumn(
    TL *ptl,
    INT iCol
    ) {


    TLITEM *pItem;
    TLSUBITEM *pSubitem;
    LIST_ENTRY *ple, *phead;

    if (!ListView_DeleteColumn(ptl->hwndList, iCol)) {
        return FALSE;
    }

    --ptl->nColumns;


    //
    // delete the subitems which correspond to this column
    //

    pItem = NULL;

    while (pItem = TL_Enumerate(ptl, pItem)) {

        phead = &pItem->lhSubitems;

        for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

            pSubitem = (TLSUBITEM *)CONTAINING_RECORD(ple, TLSUBITEM, leItems);

            if (pSubitem->iSubItem > iCol) {

                //
                // the column was never set, so do nothing
                //

                break;
            }
            else
            if (pSubitem->iSubItem == iCol) {

                RemoveEntryList(&pSubitem->leItems);

                Free0(pSubitem->pszText);
                Free(pSubitem);
                break;
            }
        }
    }

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    TL_OnSetSelection
//
// Changes the currently selected treelist item
//----------------------------------------------------------------------------

BOOL
TL_OnSetSelection(
    TL *ptl,
    HTLITEM hItem
    ) {

    TLITEM *pItem;

    pItem = (TLITEM *)hItem;
    if (!TL_IsVisible(pItem)) { return FALSE; }

    ListView_SetItemState(
        ptl->hwndList, pItem->iIndex,
        LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED
        );

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    TL_OnRedraw
//
// Forces a redraw of the treelist by invalidating its entire client area
//----------------------------------------------------------------------------

BOOL
TL_OnRedraw(
    TL *ptl
    ) {

    InvalidateRect(ptl->hwndList, NULL, TRUE);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\common\uiutil\ui.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** ui.c
** UI helper routines
** Listed alphabetically
**
** 08/25/95 Steve Cobb
*/


#include <windows.h>  // Win32 root
#include <windowsx.h> // Win32 macro extensions
#include <commctrl.h> // Win32 common controls
#include <debug.h>    // Trace and assert
#include <uiutil.h>   // Our public header


/*----------------------------------------------------------------------------
** Globals
**----------------------------------------------------------------------------
*/

/* See SetOffDesktop.
*/
static LPCWSTR g_SodContextId = NULL;

/* Set when running in a mode where WinHelp does not work.  This is a
** workaround to the problem where WinHelp does not work correctly before a
** user is logged on.  See AddContextHelpButton.
*/
BOOL g_fNoWinHelp = FALSE;


/*----------------------------------------------------------------------------
** Local datatypes
**----------------------------------------------------------------------------
*/

/* SetOffDesktop context.
*/
#define SODINFO struct tagSODINFO
SODINFO
{
    RECT  rectOrg;
    BOOL  fWeMadeInvisible;
};

/*----------------------------------------------------------------------------
** Local prototypes
**----------------------------------------------------------------------------
*/

BOOL CALLBACK
CancelOwnedWindowsEnumProc(
    IN HWND   hwnd,
    IN LPARAM lparam );

BOOL CALLBACK
CloseOwnedWindowsEnumProc(
    IN HWND   hwnd,
    IN LPARAM lparam );


/*----------------------------------------------------------------------------
** Utility routines
**----------------------------------------------------------------------------
*/

VOID
AddContextHelpButton(
    IN HWND hwnd )

    /* Turns on title bar context help button in 'hwnd'.
    **
    ** Dlgedit.exe doesn't currently support adding this style at dialog
    ** resource edit time.  When that's fixed set DS_CONTEXTHELP in the dialog
    ** definition and remove this routine.
    */
{
    LONG lStyle;

    if (g_fNoWinHelp)
        return;

    lStyle = GetWindowLong( hwnd, GWL_EXSTYLE );

    if (lStyle)
        SetWindowLong( hwnd, GWL_EXSTYLE, lStyle | WS_EX_CONTEXTHELP );
}


VOID
Button_MakeDefault(
    IN HWND hwndDlg,
    IN HWND hwndPb )

    /* Make 'hwndPb' the default button on dialog 'hwndDlg'.
    */
{
    DWORD dwResult;
    HWND  hwndPbOldDefault;

    dwResult = (DWORD) SendMessage( hwndDlg, DM_GETDEFID, 0, 0 );
    if (HIWORD( dwResult ) == DC_HASDEFID)
    {
        /* Un-default the current default button.
        */
        hwndPbOldDefault = GetDlgItem( hwndDlg, LOWORD( dwResult ) );
        Button_SetStyle( hwndPbOldDefault, BS_PUSHBUTTON, TRUE );
    }

    /* Set caller's button to the default.
    */
    SendMessage( hwndDlg, DM_SETDEFID, GetDlgCtrlID( hwndPb ), 0 );
    Button_SetStyle( hwndPb, BS_DEFPUSHBUTTON, TRUE );
}


HBITMAP
Button_CreateBitmap(
    IN HWND        hwndPb,
    IN BITMAPSTYLE bitmapstyle )

    /* Creates a bitmap of 'bitmapstyle' suitable for display on 'hwndPb.  The
    ** 'hwndPb' must have been created with BS_BITMAP style.
    **
    ** 'HwndPb' may be a checkbox with BS_PUSHLIKE style, in which case the
    ** button locks down when pressed like a toolbar button.  This case
    ** requires that a color bitmap be created resulting in two extra
    ** restrictions.  First, caller must handle WM_SYSCOLORCHANGE and rebuild
    ** the bitmaps with the new colors and second, the button cannot be
    ** disabled.
    **
    ** Returns the handle to the bitmap.  Caller can display it on the button
    ** as follows:
    **
    **     SendMessage( hwndPb, BM_SETIMAGE, 0, (LPARAM )hbitmap );
    **
    ** Caller is responsible for calling DeleteObject(hbitmap) when done using
    ** the bitmap, typically when the dialog is destroyed.
    **
    ** (Adapted from a routine by Tony Romano)
    */
{
    RECT    rect;
    HDC     hdc;
    HDC     hdcMem;
    HBITMAP hbitmap;
    HFONT   hfont;
    HPEN    hpen;
    SIZE    sizeText;
    SIZE    sizeBitmap;
    INT     x;
    INT     y;
    TCHAR*  psz;
    TCHAR*  pszText;
    TCHAR*  pszText2;
    DWORD   dxBitmap;
    DWORD   dxBetween;
    BOOL    fOnRight;
    BOOL    fPushLike;

    hdc = NULL;
    hdcMem = NULL;
    hbitmap = NULL;
    hpen = NULL;
    pszText = NULL;
    pszText2 = NULL;

    switch (bitmapstyle)
    {
        case BMS_UpArrowOnLeft:
        case BMS_DownArrowOnLeft:
        case BMS_UpArrowOnRight:
        case BMS_DownArrowOnRight:
            dxBitmap = 5;
            dxBetween = 4;
            break;

        case BMS_UpTriangleOnLeft:
        case BMS_DownTriangleOnLeft:
        case BMS_UpTriangleOnRight:
        case BMS_DownTriangleOnRight:
            dxBitmap = 7;
            dxBetween = 6;
            break;

        default:
            return NULL;
    }

    fOnRight = (bitmapstyle & BMS_OnRight);
    fPushLike = (GetWindowLong( hwndPb, GWL_STYLE ) & BS_PUSHLIKE);

    /* Get a memory DC compatible with the button window.
    */
    hdc = GetDC( hwndPb );
    if (!hdc)
        return NULL;
    hdcMem = CreateCompatibleDC( hdc );
    if (!hdcMem)
        goto BCB_Error;

    /* Create a compatible bitmap covering the entire button in the memory DC.
    **
    ** For a push button, the bitmap is created compatible with the memory DC,
    ** NOT the display DC.  This causes the bitmap to be monochrome, the
    ** default for memory DCs.  When GDI maps monochrome bitmaps into color,
    ** white is replaced with the background color and black is replaced with
    ** the text color, which is exactly what we want.  With this technique, we
    ** are relieved from explicit handling of changes in system colors.
    **
    ** For a push-like checkbox the bitmap is created compatible with the
    ** button itself, so the bitmap is typically color.
    */
    GetClientRect( hwndPb, &rect );
    hbitmap = CreateCompatibleBitmap(
        (fPushLike) ? hdc : hdcMem, rect.right, rect.bottom );
    if (!hbitmap)
        goto BCB_Error;
    ReleaseDC( hwndPb, hdc );
    hdc = NULL;
    SelectObject( hdcMem, hbitmap );

    /* Select the font the button says it's using.
    */
    hfont = (HFONT )SendMessage( hwndPb, WM_GETFONT, 0, 0 );
    if (hfont)
        SelectObject( hdcMem, hfont );

    /* Set appropriate colors for regular and stuck-down states.  Don't need
    ** to do anything for the monochrome case as the default black pen and
    ** white background are what we want.
    */
    if (fPushLike)
    {
        INT nColor;

        if (bitmapstyle == BMS_UpArrowOnLeft
           || bitmapstyle == BMS_UpArrowOnRight
           || bitmapstyle == BMS_UpTriangleOnLeft
           || bitmapstyle == BMS_UpTriangleOnRight)
        {
            nColor = COLOR_BTNHILIGHT;
        }
        else
        {
            nColor = COLOR_BTNFACE;
        }

        SetBkColor( hdcMem, GetSysColor( nColor ) );
        hpen = CreatePen( PS_SOLID, 0, GetSysColor( COLOR_BTNTEXT ) );
        if (hpen)
            SelectObject( hdcMem, hpen );
    }

    /* The created bitmap is random, so we erase it to the background color.
    ** No text is written here.
    */
    ExtTextOut( hdcMem, 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL );

    /* Get the button label and make a copy with the '&' accelerator-escape
    ** removed, which would otherwise mess up our width calculations.
    */
    pszText = GetText( hwndPb );
    pszText2 = StrDup( pszText );
    if (!pszText || !pszText2)
        goto BCB_Error;

    for (psz = pszText2; *psz; psz = CharNext( psz ) )
    {
        if (*psz == TEXT('&'))
        {
            lstrcpy( psz, psz + 1 );
            break;
        }
    }

    /* Calculate the width of the button label text.
    */
    sizeText.cx = 0;
    sizeText.cy = 0;
    GetTextExtentPoint32( hdcMem, pszText2, lstrlen( pszText2 ), &sizeText );

    /* Draw the text off-center horizontally enough so it is centered with the
    ** bitmap symbol added.
    */
    --rect.bottom;
    sizeBitmap.cx = dxBitmap;
    sizeBitmap.cy = 0;

    rect.left +=
        ((rect.right - (sizeText.cx + sizeBitmap.cx) - dxBetween) / 2);

    if (fOnRight)
    {
        DrawText( hdcMem, pszText, -1, &rect,
            DT_VCENTER + DT_SINGLELINE + DT_EXTERNALLEADING );
        rect.left += sizeText.cx + dxBetween;
    }
    else
    {
        rect.left += dxBitmap + dxBetween;
        DrawText( hdcMem, pszText, -1, &rect,
            DT_VCENTER + DT_SINGLELINE + DT_EXTERNALLEADING );
        rect.left -= dxBitmap + dxBetween;
    }

    /* Eliminate the top and bottom 3 pixels of button from consideration for
    ** the bitmap symbol.  This leaves the button control room to do the
    ** border and 3D edges.
    */
    InflateRect( &rect, 0, -3 );

    /* Draw the bitmap symbol.  The rectangle is now 'dxBitmap' wide and
    ** centered vertically with variable height depending on the button size.
    */
    switch (bitmapstyle)
    {
        case BMS_UpArrowOnLeft:
        case BMS_UpArrowOnRight:
        {
            /* v-left
            ** ..... <-top
            ** .....
            ** .....
            ** ..*.. \
            ** .***.  |
            ** *****  |
            ** ..*..  |
            ** ..*..  |
            ** ..*..   > varies depending on font height
            ** ..*..  |
            ** ..*..  |
            ** ..*..  |
            ** ..*..  |
            ** ..*.. /
            ** .....
            ** .....
            ** .....
            ** ..... <-bottom
            */

            /* Draw the vertical line.
            */
            x = rect.left + 2;
            y = rect.top + 3;
            MoveToEx( hdcMem, x, y, NULL );
            LineTo( hdcMem, x, rect.bottom - 3 );

            /* Draw the 2 crossbars.
            */
            MoveToEx( hdcMem, x - 1, ++y, NULL );
            LineTo( hdcMem, x + 2, y );
            MoveToEx( hdcMem, x - 2, ++y, NULL );
            LineTo( hdcMem, x + 3, y );
            break;
        }

        case BMS_DownArrowOnLeft:
        case BMS_DownArrowOnRight:
        {
            /* v-left
            ** ..... <-top
            ** .....
            ** .....
            ** ..*.. \
            ** ..*..  |
            ** ..*..  |
            ** ..*..  |
            ** ..*..  |
            ** ..*..   > varies depending on font height
            ** ..*..  |
            ** ..*..  |
            ** *****  |
            ** .***.  |
            ** ..*.. /
            ** .....
            ** .....
            ** .....
            ** ..... <-bottom
            */

            /* Draw the vertical line.
            */
            x = rect.left + 2;
            y = rect.top + 3;
            MoveToEx( hdcMem, x, y, NULL );
            LineTo( hdcMem, x, rect.bottom - 3 );

            /* Draw the 2 crossbars.
            */
            y = rect.bottom - 6;
            MoveToEx( hdcMem, x - 2, y, NULL );
            LineTo( hdcMem, x + 3, y );
            MoveToEx( hdcMem, x - 1, ++y, NULL );
            LineTo( hdcMem, x + 2, y );
            break;
        }

        case BMS_UpTriangleOnLeft:
        case BMS_UpTriangleOnRight:
        {
            /* v-left
            ** ....... <-top
            ** .......
            ** .......
            ** .......
            ** .......
            ** .......
            ** .......
            ** ...o... <- o indicates x,y origin
            ** ..***..
            ** .*****.
            ** *******
            ** .......
            ** .......
            ** .......
            ** .......
            ** .......
            ** .......
            ** ....... <-bottom
            */
            x = rect.left + 3;
            y = ((rect.bottom - rect.top) / 2) + 2;
            MoveToEx( hdcMem, x, y, NULL );
            LineTo( hdcMem, x + 1, y );
            ++y;
            MoveToEx( hdcMem, x - 1, y, NULL );
            LineTo( hdcMem, x + 2, y );
            ++y;
            MoveToEx( hdcMem, x - 2, y, NULL );
            LineTo( hdcMem, x + 3, y );
            ++y;
            MoveToEx( hdcMem, x - 3, y, NULL );
            LineTo( hdcMem, x + 4, y );
            break;
        }

        case BMS_DownTriangleOnLeft:
        case BMS_DownTriangleOnRight:
        {
            /* v-left
            ** ....... <-top
            ** .......
            ** .......
            ** .......
            ** .......
            ** .......
            ** .......
            ** ***o*** <- o indicates x,y origin
            ** .*****.
            ** ..***..
            ** ...*...
            ** .......
            ** .......
            ** .......
            ** .......
            ** .......
            ** .......
            ** ....... <-bottom
            */
            x = rect.left + 3;
            y = ((rect.bottom - rect.top) / 2) + 2;
            MoveToEx( hdcMem, x - 3, y, NULL );
            LineTo( hdcMem, x + 4, y );
            ++y;
            MoveToEx( hdcMem, x - 2, y, NULL );
            LineTo( hdcMem, x + 3, y );
            ++y;
            MoveToEx( hdcMem, x - 1, y, NULL );
            LineTo( hdcMem, x + 2, y );
            ++y;
            MoveToEx( hdcMem, x, y, NULL );
            LineTo( hdcMem, x + 1, y );
            break;
        }
    }

BCB_Error:

    Free0( pszText );
    Free0( pszText2 );
    if (hdc)
        ReleaseDC( hwndPb, hdc );
    if (hdcMem)
        DeleteDC( hdcMem );
    if (hpen)
        DeleteObject( hpen );
    return hbitmap;
}


VOID
CenterWindow(
    IN HWND hwnd,
    IN HWND hwndRef )

    /* Center window 'hwnd' on window 'hwndRef' or if 'hwndRef' is NULL on
    ** screen.  The window position is adjusted so that no parts are clipped
    ** by the edge of the screen, if necessary.  If 'hwndRef' has been moved
    ** off-screen with SetOffDesktop, the original position is used.
    */
{
    RECT rectCur;
    LONG dxCur;
    LONG dyCur;
    RECT rectRef;
    LONG dxRef;
    LONG dyRef;

    GetWindowRect( hwnd, &rectCur );
    dxCur = rectCur.right - rectCur.left;
    dyCur = rectCur.bottom - rectCur.top;

    if (hwndRef)
    {
        if (!SetOffDesktop( hwndRef, SOD_GetOrgRect, &rectRef ))
            GetWindowRect( hwndRef, &rectRef );
    }
    else
    {
        rectRef.top = rectRef.left = 0;
        rectRef.right = GetSystemMetrics( SM_CXSCREEN );
        rectRef.bottom = GetSystemMetrics( SM_CYSCREEN );
    }

    dxRef = rectRef.right - rectRef.left;
    dyRef = rectRef.bottom - rectRef.top;

    rectCur.left = rectRef.left + ((dxRef - dxCur) / 2);
    rectCur.top = rectRef.top + ((dyRef - dyCur) / 2);

    SetWindowPos(
        hwnd, NULL,
        rectCur.left, rectCur.top, 0, 0,
        SWP_NOZORDER + SWP_NOSIZE );

    UnclipWindow( hwnd );
}


//Add this function for whislter bug  320863    gangz
//
//Center expand the window horizontally in its parent window
// this expansion will remain the left margin between the child window
// and the parent window
// hwnd: Child Window
// hwndRef: Reference window
// bHoriz: TRUE, means expand horizontally, let the right margin equal the left margin
// bVert: TRUE, elongate the height proportial to the width;
// hwndVertBound: the window that our vertical expandasion cannot overlap with
//
VOID
CenterExpandWindowRemainLeftMargin(
    IN HWND hwnd,
    IN HWND hwndRef,
    BOOL bHoriz,
    BOOL bVert,
    IN HWND hwndVertBottomBound)
{
    RECT rectCur, rectRef, rectVbBound;
    LONG dxCur, dyCur, dxRef;
    POINT ptTemp;
    double ratio;
    BOOL bvbBound = FALSE;

    if (hwnd)
    {
        GetWindowRect( hwnd, &rectCur );

        if (hwndRef)
        {
            GetWindowRect( hwndRef, &rectRef );

          if(hwndVertBottomBound)
          {
            GetWindowRect( hwndVertBottomBound, &rectVbBound );

            //We only consider normal cases, if hwnd and hwndVertBound are already
            //overlapped, that is the problem beyond this function.
            //
            if ( rectCur.top < rectVbBound.top )
            {
                bvbBound = TRUE;
             }
    
          }
          
          dxRef = rectRef.right - rectRef.left +1;
          dxCur = rectCur.right - rectCur.left +1;
          dyCur = rectCur.bottom - rectCur.top +1;
          ratio = dyCur*1.0/dxCur;
          
          if(bHoriz)
          {
               rectCur.right = rectRef.right - (rectCur.left - rectRef.left);
          }

          if(bVert)
          {
               rectCur.bottom = rectCur.top + 
                                (LONG)( (rectCur.right - rectCur.left+1) * ratio );
          }

          if(bvbBound)
          {
                //if overlapping occurs w/o expansion, we need to fix it
                //then we do the vertical centering,
                // this bounding is basically for JPN bugs 329700 329715 which
                // wont happen on English build
                //
                
                if(rectCur.bottom > rectVbBound.top )
                {
                   LONG dxResult, dyResult, dyVRef;

                   dyResult = rectVbBound.top - rectCur.top;
                   dxResult = (LONG)(dyResult/ratio);

                   ptTemp.x = rectVbBound.left;
                   ptTemp.y = rectVbBound.top-1;
                   
                   //For whistler bug 371914        gangz
                   //Cannot use ScreenToClient() here
                   //On RTL build, we must use MapWindowPoint() instead
                   //
                   MapWindowPoints(HWND_DESKTOP,
                                  hwndRef,
                                  &ptTemp,
                                  1);

                   dyVRef = ptTemp.y + 1;
                  
                   rectCur.left = rectRef.left + (dxRef - dxResult)/2;
                   rectCur.right = rectRef.right - (dxRef-dxResult)/2;
                   rectCur.bottom = rectVbBound.top - (dyVRef-dyResult)/2;
                   rectCur.top = rectCur.bottom - dyResult;
               }
           }

            ptTemp.x = rectCur.left;
            ptTemp.y = rectCur.top;
            MapWindowPoints(HWND_DESKTOP,
                           hwndRef,
                           &ptTemp,
                           1);
           
            rectCur.left = ptTemp.x;
            rectCur.top  = ptTemp.y;

            ptTemp.x = rectCur.right;
            ptTemp.y = rectCur.bottom;
            MapWindowPoints(HWND_DESKTOP,
                           hwndRef,
                           &ptTemp,
                           1);

            rectCur.right  = ptTemp.x;
            rectCur.bottom = ptTemp.y;

            //For mirrored build
            //
            if ( rectCur.right < rectCur.left )
            {
                int tmp;

                tmp = rectCur.right;
                rectCur.right = rectCur.left;
                rectCur.left = tmp;
            }
            
            SetWindowPos(
                    hwnd, 
                    NULL,
                    rectCur.left,
                    rectCur.top, 
                    rectCur.right - rectCur.left + 1,
                    rectCur.bottom - rectCur.top +1,
                    SWP_NOZORDER);
        }
    }

}


VOID
CancelOwnedWindows(
    IN HWND hwnd )

    /* Sends WM_COMMAND(IDCANCEL) to all windows that are owned by 'hwnd' in
    ** the current thread.
    */
{
    EnumThreadWindows( GetCurrentThreadId(),
        CloseOwnedWindowsEnumProc, (LPARAM )hwnd );
}


BOOL CALLBACK
CancelOwnedWindowsEnumProc(
    IN HWND   hwnd,
    IN LPARAM lparam )

    /* Standard Win32 EnumThreadWindowsWndProc used by CancelOwnedWindows.
    */
{
    HWND hwndThis;

    for (hwndThis = GetParent( hwnd );
         hwndThis;
         hwndThis = GetParent( hwndThis ))
    {
        if (hwndThis == (HWND )lparam)
        {
            FORWARD_WM_COMMAND(
                hwnd, IDCANCEL, NULL, 0, SendMessage );
            break;
        }
    }

    return TRUE;
}


VOID
CloseOwnedWindows(
    IN HWND hwnd )

    /* Sends WM_CLOSE to all windows that are owned by 'hwnd' in the current
    ** thread.
    */
{
    EnumThreadWindows( GetCurrentThreadId(),
        CloseOwnedWindowsEnumProc, (LPARAM )hwnd );
}


BOOL CALLBACK
CloseOwnedWindowsEnumProc(
    IN HWND   hwnd,
    IN LPARAM lparam )

    /* Standard Win32 EnumThreadWindowsWndProc used by CloseOwnedWindows.
    */
{
    HWND hwndThis;

    for (hwndThis = GetParent( hwnd );
         hwndThis;
         hwndThis = GetParent( hwndThis ))
    {
        if (hwndThis == (HWND )lparam)
        {
            SendMessage( hwnd, WM_CLOSE, 0, 0 );
            break;
        }
    }

    return TRUE;
}


INT
ComboBox_AddItem(
    IN HWND    hwndLb,
    IN LPCTSTR pszText,
    IN VOID*   pItem )

    /* Adds data item 'pItem' with displayed text 'pszText' to listbox
    ** 'hwndLb'.  The item is added sorted if the listbox has LBS_SORT style,
    ** or to the end of the list otherwise.  If the listbox has LB_HASSTRINGS
    ** style, 'pItem' is a null terminated string, otherwise it is any user
    ** defined data.
    **
    ** Returns the index of the item in the list or negative if error.
    */
{
    INT nIndex;

    nIndex = ComboBox_AddString( hwndLb, pszText );
    if (nIndex >= 0)
        ComboBox_SetItemData( hwndLb, nIndex, pItem );
    return nIndex;
}


INT
ComboBox_AddItemFromId(
    IN HINSTANCE hinstance,
    IN HWND      hwndLb,
    IN DWORD     dwStringId,
    IN VOID*     pItem )

    /* Adds data item 'pItem' to listbox 'hwndLb'.  'dwStringId' is the string
    ** ID of the item's displayed text.  'Hinstance' is the app or module
    ** instance handle.
    **
    ** Returns the index of the item in the list or negative if error.
    */
{
    INT     i;
    LPCTSTR psz;

    psz = PszLoadString( hinstance, dwStringId );

    if (psz)
    {
        i = ComboBox_AddItem( hwndLb, psz, pItem );
    }
    else
    {
        i = LB_ERRSPACE;
    }

    return i;
}


INT
ComboBox_AddItemSorted(
    IN HWND    hwndLb,
    IN LPCTSTR pszText,
    IN VOID*   pItem )

    /* Adds data item 'pItem' with displayed text 'pszText' to listbox
    ** 'hwndLb' in order sorted by 'pszText'.  It is assumed all items added
    ** to the list to this point are sorted.  If the listbox has LB_HASSTRINGS
    ** style, 'pItem' is a null terminated string, otherwise it is any user
    ** defined data.
    **
    ** Returns the index of the item in the list or negative if error.
    */
{
    INT nIndex;
    INT i;
    INT c;

    c = ComboBox_GetCount( hwndLb );
    for (i = 0; i < c; ++i)
    {
        TCHAR* psz;

        psz = ComboBox_GetPsz( hwndLb, i );
        if (psz)
        {
            if (lstrcmp( pszText, psz ) < 0)
                break;
            Free( psz );
        }
    }

    if (i >= c)
        i = -1;

    nIndex = ComboBox_InsertString( hwndLb, i, pszText );
    if (nIndex >= 0)
        ComboBox_SetItemData( hwndLb, nIndex, pItem );

    return nIndex;
}


VOID
ComboBox_AutoSizeDroppedWidth(
    IN HWND hwndLb )

    /* Set the width of the drop-down list 'hwndLb' to the width of the
    ** longest item (or the width of the list box if that's wider).
    */
{
    HDC    hdc;
    HFONT  hfont;
    TCHAR* psz;
    SIZE   size;
    DWORD  cch;
    DWORD  dxNew;
    DWORD  i;

    hfont = (HFONT )SendMessage( hwndLb, WM_GETFONT, 0, 0 );
    if (!hfont)
        return;

    hdc = GetDC( hwndLb );
    if (!hdc)
        return;

    SelectObject( hdc, hfont );

    dxNew = 0;
    for (i = 0; psz = ComboBox_GetPsz( hwndLb, i ); ++i)
    {
        cch = lstrlen( psz );
        if (GetTextExtentPoint32( hdc, psz, cch, &size ))
        {
            if (dxNew < (DWORD )size.cx)
                dxNew = (DWORD )size.cx;
        }

        Free( psz );
    }

    ReleaseDC( hwndLb, hdc );

    /* Allow for the spacing on left and right added by the control.
    */
    dxNew += 6;

    /* Figure out if the vertical scrollbar will be displayed and, if so,
    ** allow for it's width.
    */
    {
        RECT  rectD;
        RECT  rectU;
        DWORD dyItem;
        DWORD cItemsInDrop;
        DWORD cItemsInList;

        GetWindowRect( hwndLb, &rectU );
        SendMessage( hwndLb, CB_GETDROPPEDCONTROLRECT, 0, (LPARAM )&rectD );
        dyItem = (DWORD)SendMessage( hwndLb, CB_GETITEMHEIGHT, 0, 0 );
        cItemsInDrop = (rectD.bottom - rectU.bottom) / dyItem;
        cItemsInList = ComboBox_GetCount( hwndLb );
        if (cItemsInDrop < cItemsInList)
            dxNew += GetSystemMetrics( SM_CXVSCROLL );
    }

    SendMessage( hwndLb, CB_SETDROPPEDWIDTH, dxNew, 0 );
}


#if 0
VOID
ComboBox_FillFromPszList(
    IN HWND     hwndLb,
    IN DTLLIST* pdtllistPsz )

    /* Loads 'hwndLb' with an item form each node in the list strings,
    ** 'pdtllistPsz'.
    */
{
    DTLNODE* pNode;

    if (!pdtllistPsz)
        return;

    for (pNode = DtlGetFirstNode( pdtllistPsz );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        TCHAR* psz;

        psz = (TCHAR* )DtlGetData( pNode );
        ASSERT(psz);
        ComboBox_AddString( hwndLb, psz );
    }
}
#endif


VOID*
ComboBox_GetItemDataPtr(
    IN HWND hwndLb,
    IN INT  nIndex )

    /* Returns the address of the 'nIndex'th item context in 'hwndLb' or NULL
    ** if none.
    */
{
    LRESULT lResult;

    if (nIndex < 0)
        return NULL;

    lResult = ComboBox_GetItemData( hwndLb, nIndex );
    if (lResult < 0)
        return NULL;

    return (VOID* )lResult;
}


TCHAR*
ComboBox_GetPsz(
    IN HWND hwnd,
    IN INT  nIndex )

    /* Returns heap block containing the text contents of the 'nIndex'th item
    ** of combo box 'hwnd' or NULL.  It is caller's responsibility to Free the
    ** returned string.
    */
{
    INT    cch;
    TCHAR* psz;

    cch = ComboBox_GetLBTextLen( hwnd, nIndex );
    if (cch < 0)
        return NULL;

    psz = Malloc( (cch + 1) * sizeof(TCHAR) );

    if (psz)
    {
        *psz = TEXT('\0');
        ComboBox_GetLBText( hwnd, nIndex, psz );
    }

    return psz;
}


VOID
ComboBox_SetCurSelNotify(
    IN HWND hwndLb,
    IN INT  nIndex )

    /* Set selection in listbox 'hwndLb' to 'nIndex' and notify parent as if
    ** user had clicked the item which Windows doesn't do for some reason.
    */
{
    ComboBox_SetCurSel( hwndLb, nIndex );

    SendMessage(
        GetParent( hwndLb ),
        WM_COMMAND,
        (WPARAM )MAKELONG(
            (WORD )GetDlgCtrlID( hwndLb ), (WORD )CBN_SELCHANGE ),
        (LPARAM )hwndLb );
}


TCHAR*
Ellipsisize(
    IN HDC    hdc,
    IN TCHAR* psz,
    IN INT    dxColumn,
    IN INT    dxColText OPTIONAL )

    /* Returns a heap string containing the 'psz' shortened to fit in the
    ** given width, if necessary, by truncating and adding "...". 'Hdc' is the
    ** device context with the appropiate font selected.  'DxColumn' is the
    ** width of the column.  It is caller's responsibility to Free the
    ** returned string.
    */
{
    const TCHAR szDots[] = TEXT("...");

    SIZE   size;
    TCHAR* pszResult;
    TCHAR* pszResultLast;
    TCHAR* pszResult2nd;
    DWORD  cch;

    cch = lstrlen( psz );
    pszResult = Malloc( (cch * sizeof(TCHAR)) + sizeof(szDots) );
    if (!pszResult)
        return NULL;
    lstrcpy( pszResult, psz );

    dxColumn -= dxColText;
    if (dxColumn <= 0)
    {
        /* None of the column text will be visible so bag the calculations and
        ** just return the original string.
        */
        return pszResult;
    }

    if (!GetTextExtentPoint32( hdc, pszResult, cch, &size ))
    {
        Free( pszResult );
        return NULL;
    }

    pszResult2nd = CharNext( pszResult );
    pszResultLast = pszResult + cch;

    while (size.cx > dxColumn && pszResultLast > pszResult2nd)
    {
        /* Doesn't fit.  Lop off a character, add the ellipsis, and try again.
        ** The minimum result is "..." for empty original or "x..." for
        ** non-empty original.
        */
        pszResultLast = CharPrev( pszResult2nd, pszResultLast );
        lstrcpy( pszResultLast, szDots );

        if (!GetTextExtentPoint( hdc, pszResult, lstrlen( pszResult ), &size ))
        {
            Free( pszResult );
            return NULL;
        }
    }

    return pszResult;
}


VOID
ExpandWindow(
    IN HWND hwnd,
    IN LONG dx,
    IN LONG dy )

    /* Expands window 'hwnd' 'dx' pels to the right and 'dy' pels down from
    ** it's current size.
    */
{
    RECT rect;

    GetWindowRect( hwnd, &rect );

    SetWindowPos( hwnd, NULL,
        0, 0, rect.right - rect.left + dx, rect.bottom - rect.top + dy,
        SWP_NOMOVE + SWP_NOZORDER );
}


TCHAR*
GetText(
    IN HWND hwnd )

    /* Returns heap block containing the text contents of the window 'hwnd' or
    ** NULL.  It is caller's responsibility to Free the returned string.
    */
{
    INT    cch;
    TCHAR* psz;

    cch = GetWindowTextLength( hwnd );
    psz = Malloc( (cch + 1) * sizeof(TCHAR) );

    if (psz)
    {
        *psz = TEXT('\0');
        GetWindowText( hwnd, psz, cch + 1 );
    }

    return psz;
}


HWND
HwndFromCursorPos(
    IN  HINSTANCE   hinstance,
    IN  POINT*      ppt OPTIONAL )

    /* Returns a "Static" control window created at the specified position
    ** (or at the cursor position if NULL is passed in).
    ** The window is moved off the desktop using SetOffDesktop()
    ** so that it can be specified as the owner window
    ** for a popup dialog shown using MsgDlgUtil.
    ** The window returned should be destroyed using DestroyWindow().
    */
{

    HWND hwnd;
    POINT pt;

    if (ppt) { pt = *ppt; }
    else { GetCursorPos(&pt); }

    //
    // create the window
    //

    hwnd = CreateWindowEx(
                WS_EX_TOOLWINDOW, TEXT("Static"), NULL, WS_POPUP, pt.x, pt.y,
                1, 1, NULL, NULL, hinstance, NULL
                );
    if (!hwnd) { return NULL; }

    //
    // move it off the desktop
    //

    SetOffDesktop(hwnd, SOD_MoveOff, NULL);

    ShowWindow(hwnd, SW_SHOW);

    return hwnd;
}

LPTSTR
IpGetAddressAsText(
    HWND    hwndIp )
{
    if (SendMessage( hwndIp, IPM_ISBLANK, 0, 0 ))
    {
        return NULL;
    }
    else
    {
        DWORD dwIpAddrHost;
        TCHAR szIpAddr [32];

        SendMessage( hwndIp, IPM_GETADDRESS, 0, (LPARAM)&dwIpAddrHost );
        IpHostAddrToPsz( dwIpAddrHost, szIpAddr );
        return StrDup( szIpAddr );
    }
}


void
IpSetAddressText(
    HWND    hwndIp,
    LPCTSTR pszIpAddress )
{
    if (pszIpAddress)
    {
        DWORD dwIpAddrHost = IpPszToHostAddr( pszIpAddress );
        SendMessage( hwndIp, IPM_SETADDRESS, 0, dwIpAddrHost );
    }
    else
    {
        SendMessage( hwndIp, IPM_CLEARADDRESS, 0, 0 );
    }
}


INT
ListBox_AddItem(
    IN HWND   hwndLb,
    IN TCHAR* pszText,
    IN VOID*  pItem )

    /* Adds data item 'pItem' with displayed text 'pszText' to listbox
    ** 'hwndLb'.  The item is added sorted if the listbox has LBS_SORT style,
    ** or to the end of the list otherwise.  If the listbox has LB_HASSTRINGS
    ** style, 'pItem' is a null terminated string, otherwise it is any user
    ** defined data.
    **
    ** Returns the index of the item in the list or negative if error.
    */
{
    INT nIndex;

    nIndex = ListBox_AddString( hwndLb, pszText );
    if (nIndex >= 0)
        ListBox_SetItemData( hwndLb, nIndex, pItem );
    return nIndex;
}


TCHAR*
ListBox_GetPsz(
    IN HWND hwnd,
    IN INT  nIndex )

    /* Returns heap block containing the text contents of the 'nIndex'th item
    ** of list box 'hwnd' or NULL.  It is caller's responsibility to Free the
    ** returned string.
    */
{
    INT    cch;
    TCHAR* psz;

    cch = ListBox_GetTextLen( hwnd, nIndex );
    psz = Malloc( (cch + 1) * sizeof(TCHAR) );

    if (psz)
    {
        *psz = TEXT('\0');
        ListBox_GetText( hwnd, nIndex, psz );
    }

    return psz;
}


INT
ListBox_IndexFromString(
    IN HWND   hwnd,
    IN TCHAR* psz )

    /* Returns the index of the item in string list 'hwnd' that matches 'psz'
    ** or -1 if not found.  Unlike, ListBox_FindStringExact, this compare in
    ** case sensitive.
    */
{
    INT i;
    INT c;

    c = ListBox_GetCount( hwnd );

    for (i = 0; i < c; ++i)
    {
        TCHAR* pszThis;

        pszThis = ListBox_GetPsz( hwnd, i );
        if (pszThis)
        {
            BOOL f;

            f = (lstrcmp( psz, pszThis ) == 0);
            Free( pszThis );
            if (f)
                return i;
        }
    }

    return -1;
}


VOID
ListBox_SetCurSelNotify(
    IN HWND hwndLb,
    IN INT  nIndex )

    /* Set selection in listbox 'hwndLb' to 'nIndex' and notify parent as if
    ** user had clicked the item which Windows doesn't do for some reason.
    */
{
    ListBox_SetCurSel( hwndLb, nIndex );

    SendMessage(
        GetParent( hwndLb ),
        WM_COMMAND,
        (WPARAM )MAKELONG(
            (WORD )GetDlgCtrlID( hwndLb ), (WORD )LBN_SELCHANGE ),
        (LPARAM )hwndLb );
}


VOID*
ListView_GetParamPtr(
    IN HWND hwndLv,
    IN INT  iItem )

    /* Returns the lParam address of the 'iItem' item in 'hwndLv' or NULL if
    ** none or error.
    */
{
    LV_ITEM item;

    ZeroMemory( &item, sizeof(item) );
    item.mask = LVIF_PARAM;
    item.iItem = iItem;

    if (!ListView_GetItem( hwndLv, &item ))
        return NULL;

    return (VOID* )item.lParam;
}


VOID*
ListView_GetSelectedParamPtr(
    IN HWND hwndLv )

    /* Returns the lParam address of the first selected item in 'hwndLv' or
    ** NULL if none or error.
    */
{
    INT     iSel;
    LV_ITEM item;

    iSel = ListView_GetNextItem( hwndLv, -1, LVNI_SELECTED );
    if (iSel < 0)
        return NULL;

    return ListView_GetParamPtr( hwndLv, iSel );
}


VOID
ListView_InsertSingleAutoWidthColumn(
    HWND hwndLv )

    // Insert a single auto-sized column into listview 'hwndLv', e.g. for a
    // list of checkboxes with no visible column header.
    //
{
    LV_COLUMN col;

    ZeroMemory( &col, sizeof(col) );
    col.mask = LVCF_FMT;
    col.fmt = LVCFMT_LEFT;
    ListView_InsertColumn( hwndLv, 0, &col );
    ListView_SetColumnWidth( hwndLv, 0, LVSCW_AUTOSIZE );
}


BOOL
ListView_SetParamPtr(
    IN HWND  hwndLv,
    IN INT   iItem,
    IN VOID* pParam )

    /* Set the lParam address of the 'iItem' item in 'hwndLv' to 'pParam'.
    ** Return true if successful, false otherwise.
    */
{
    LV_ITEM item;

    ZeroMemory( &item, sizeof(item) );
    item.mask = LVIF_PARAM;
    item.iItem = iItem;
    item.lParam = (LPARAM )pParam;

    return ListView_SetItem( hwndLv, &item );
}


VOID
Menu_CreateAccelProxies(
    IN HINSTANCE hinst,
    IN HWND      hwndParent,
    IN DWORD     dwMid )

    /* Causes accelerators on a popup menu to choose menu commands when the
    ** popup menu is not dropped down.  'Hinst' is the app/dll instance.
    ** 'HwndParent' is the window that receives the popup menu command
    ** messages.  'DwMid' is the menu ID of the menu bar containing the popup
    ** menu.
    */
{
    #define MCF_cbBuf 512

    HMENU        hmenuBar;
    HMENU        hmenuPopup;
    TCHAR        szBuf[ MCF_cbBuf ];
    MENUITEMINFO item;
    INT          i;

    hmenuBar = LoadMenu( hinst, MAKEINTRESOURCE( dwMid ) );
    ASSERT(hmenuBar);
    hmenuPopup = GetSubMenu( hmenuBar, 0 );
    ASSERT(hmenuPopup);

    /* Loop thru menu items on the popup menu.
    */
    for (i = 0; TRUE; ++i)
    {
        ZeroMemory( &item, sizeof(item) );
        item.cbSize = sizeof(item);
        item.fMask = MIIM_TYPE + MIIM_ID;
        item.dwTypeData = szBuf;
        item.cch = MCF_cbBuf;

        if (!GetMenuItemInfo( hmenuPopup, i, TRUE, &item ))
            break;

        if (item.fType != MFT_STRING)
            continue;

        /* Create an off-screen button on the parent with the same ID and
        ** text as the menu item.
        */
        CreateWindow( TEXT("button"), szBuf, WS_CHILD,
            30000, 30000, 0, 0, hwndParent, (HMENU )UlongToPtr(item.wID), hinst, NULL );
    }

    DestroyMenu( hmenuBar );
}


VOID
ScreenToClientRect(
    IN     HWND  hwnd,
    IN OUT RECT* pRect )

    /* Converts '*pRect' from screen to client coordinates of 'hwnd'.
    */
{
    POINT xyUL;
    POINT xyBR;

    xyUL.x = pRect->left;
    xyUL.y = pRect->top;
    xyBR.x = pRect->right;
    xyBR.y = pRect->bottom;

    ScreenToClient( hwnd, &xyUL );
    ScreenToClient( hwnd, &xyBR );

    pRect->left = xyUL.x;
    pRect->top = xyUL.y;
    pRect->right = xyBR.x;
    pRect->bottom = xyBR.y;
}


BOOL
SetOffDesktop(
    IN  HWND  hwnd,
    IN  DWORD dwAction,
    OUT RECT* prectOrg )

    /* Move 'hwnd' back and forth from the visible desktop to the area
    ** off-screen.  Use this when you want to "hide" your owner window without
    ** hiding yourself which Windows automatically does.
    **
    ** 'dwAction' describes the action to take:
    **     SOD_Moveoff:        Move 'hwnd' off the desktop.
    **     SOD_MoveBackFree:   Undo SOD_MoveOff.
    **     SOD_GetOrgRect:     Retrieves original 'hwnd' position.
    **     SOD_Free:           Free SOD_MoveOff context without restoring.
    **     SOD_MoveBackHidden: Move window back, but hidden so you can call
    **                             routines that internally query the position
    **                             of the window.  Undo with SOD_Moveoff.
    **
    ** '*prectOrg' is set to the original window position when 'dwAction' is
    ** SOD_GetOrgRect.  Otherwise, it is ignored, and may be NULL.
    **
    ** Returns true if the window has a SODINFO context, false otherwise.
    */
{
    SODINFO* pInfo;

    TRACE2("SetOffDesktop(h=$%08x,a=%d)",hwnd,dwAction);

    if (!g_SodContextId)
    {
        g_SodContextId = (LPCTSTR )GlobalAddAtom( TEXT("RASSETOFFDESKTOP") );
        if (!g_SodContextId)
            return FALSE;
    }

    pInfo = (SODINFO* )GetProp( hwnd, g_SodContextId );

    if (dwAction == SOD_MoveOff)
    {
        if (pInfo)
        {
            /* Caller is undoing a SOD_MoveBackHidden.
            */
            SetWindowPos( hwnd, NULL,
                pInfo->rectOrg.left, GetSystemMetrics( SM_CYSCREEN ),
                0, 0, SWP_NOSIZE + SWP_NOZORDER );

            if (pInfo->fWeMadeInvisible)
            {
                ShowWindow( hwnd, SW_SHOW );
                pInfo->fWeMadeInvisible = FALSE;
            }
        }
        else
        {
            BOOL f;

            pInfo = (SODINFO* )Malloc( sizeof(SODINFO) );
            if (!pInfo)
                return FALSE;

            f = IsWindowVisible( hwnd );
            if (!f)
                ShowWindow( hwnd, SW_HIDE );

            GetWindowRect( hwnd, &pInfo->rectOrg );
            SetWindowPos( hwnd, NULL, pInfo->rectOrg.left,
                GetSystemMetrics( SM_CYSCREEN ),
                0, 0, SWP_NOSIZE + SWP_NOZORDER );

            if (!f)
                ShowWindow( hwnd, SW_SHOW );

            pInfo->fWeMadeInvisible = FALSE;
            SetProp( hwnd, g_SodContextId, pInfo );
        }
    }
    else if (dwAction == SOD_MoveBackFree || dwAction == SOD_Free)
    {
        if (pInfo)
        {
            if (dwAction == SOD_MoveBackFree)
            {
                SetWindowPos( hwnd, NULL,
                    pInfo->rectOrg.left, pInfo->rectOrg.top, 0, 0,
                    SWP_NOSIZE + SWP_NOZORDER );
            }

            Free( pInfo );
            RemoveProp( hwnd, g_SodContextId );
        }

        return FALSE;
    }
    else if (dwAction == SOD_GetOrgRect)
    {
        if (!pInfo)
            return FALSE;

        *prectOrg = pInfo->rectOrg;
    }
    else
    {
        ASSERT(dwAction==SOD_MoveBackHidden);

        if (!pInfo)
            return FALSE;

        if (IsWindowVisible( hwnd ))
        {
            ShowWindow( hwnd, SW_HIDE );
            pInfo->fWeMadeInvisible = TRUE;
        }

        SetWindowPos( hwnd, NULL,
            pInfo->rectOrg.left, pInfo->rectOrg.top, 0, 0,
            SWP_NOSIZE + SWP_NOZORDER );
    }

    return TRUE;
}


BOOL
SetDlgItemNum(
    IN HWND hwndDlg,
    IN INT iDlgItem,
    IN UINT uValue )

    /* Similar to SetDlgItemInt, but this function uses commas (or the
    ** locale-specific separator) to delimit thousands
    */
{

    DWORD dwSize;
    TCHAR szNumber[32];

    dwSize  = 30;
    GetNumberString(uValue, szNumber, &dwSize);

    return SetDlgItemText(hwndDlg, iDlgItem, szNumber);
}


BOOL
SetEvenTabWidths(
    IN HWND  hwndDlg,
    IN DWORD cPages )

    /* Set the tabs on property sheet 'hwndDlg' to have even fixed width.
    ** 'cPages' is the number of pages on the property sheet.
    **
    ** Returns true if successful, false if any of the tabs requires more than
    ** the fixed width in which case the call has no effect.
    */
{
    HWND hwndTab;
    LONG lStyle;
    RECT rect;
    INT  dxFixed;

    /* The tab control uses hard-coded 1-inch tabs when you set FIXEDWIDTH
    ** style while we want the tabs to fill the page, so we figure out the
    ** correct width ourselves.  For some reason, without a fudge-factor (the
    ** -10) the expansion does not fit on a single line.  The factor
    ** absolutely required varies between large and small fonts and the number
    ** of tabs does not seem to be a factor.
    */
    hwndTab = PropSheet_GetTabControl( hwndDlg );
    GetWindowRect( hwndTab, &rect );
    dxFixed = (rect.right - rect.left - 10 ) / cPages;

    while (cPages > 0)
    {
        RECT rectTab;

        --cPages;
        if (!TabCtrl_GetItemRect( hwndTab, cPages, &rectTab )
            || dxFixed < rectTab.right - rectTab.left)
        {
            /* This tab requires more than the fixed width.  Since the fixed
            ** width is unworkable do nothing.
            */
            return FALSE;
        }
    }

    TabCtrl_SetItemSize( hwndTab, dxFixed, 0 );
    lStyle = GetWindowLong( hwndTab, GWL_STYLE );
    SetWindowLong( hwndTab, GWL_STYLE, lStyle | TCS_FIXEDWIDTH );
    return TRUE;
}


HFONT
SetFont(
    HWND   hwndCtrl,
    TCHAR* pszFaceName,
    BYTE   bfPitchAndFamily,
    INT    nPointSize,
    BOOL   fUnderline,
    BOOL   fStrikeout,
    BOOL   fItalic,
    BOOL   fBold )

    /* Sets font of control 'hwndCtrl' to a font matching the specified
    ** attributes.  See LOGFONT documentation.
    **
    ** Returns the HFONT of the created font if successful or NULL.  Caller
    ** should DeleteObject the returned HFONT when the control is destroyed.
    */
{
    LOGFONT logfont;
    INT     nPelsPerInch;
    HFONT   hfont;

    {
        HDC hdc = GetDC( NULL );
        if (hdc == NULL)
        {
            return NULL;
        }
       
        nPelsPerInch = GetDeviceCaps( hdc, LOGPIXELSY );
        ReleaseDC( NULL, hdc );
    }

    ZeroMemory( &logfont, sizeof(logfont) );
    logfont.lfHeight = -MulDiv( nPointSize, nPelsPerInch, 72 );

    {
        DWORD       cp;
        CHARSETINFO csi;

        cp = GetACP();
        if (TranslateCharsetInfo( &cp, &csi, TCI_SRCCODEPAGE ))
            logfont.lfCharSet = (UCHAR)csi.ciCharset;
        else
            logfont.lfCharSet = ANSI_CHARSET;
    }

    logfont.lfOutPrecision = OUT_DEFAULT_PRECIS;
    logfont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    logfont.lfQuality = DEFAULT_QUALITY;
    logfont.lfPitchAndFamily = bfPitchAndFamily;
    lstrcpy( logfont.lfFaceName, pszFaceName );
    logfont.lfUnderline = (BYTE)fUnderline;
    logfont.lfStrikeOut = (BYTE)fStrikeout;
    logfont.lfItalic = (BYTE)fItalic;
    logfont.lfWeight = (fBold) ? FW_BOLD : FW_NORMAL;

    hfont = CreateFontIndirect( &logfont );
    if (hfont)
    {
        SendMessage( hwndCtrl,
            WM_SETFONT, (WPARAM )hfont, MAKELPARAM( TRUE, 0 ) );
    }

    return hfont;
}



VOID
SlideWindow(
    IN HWND hwnd,
    IN HWND hwndParent,
    IN LONG dx,
    IN LONG dy )

    /* Moves window 'hwnd' 'dx' pels right and 'dy' pels down from it's
    ** current position.  'HwndParent' is the handle of 'hwnd's parent or NULL
    ** if 'hwnd' is not a child window.
    */
{
    RECT  rect;
    POINT xy;

    GetWindowRect( hwnd, &rect );
    xy.x = rect.left;
    xy.y = rect.top;

    if (GetParent( hwnd ))
    {
        /*
         * For mirrored parents we us the right point not the left.
         */
        if (GetWindowLongPtr(GetParent( hwnd ), GWL_EXSTYLE) & WS_EX_LAYOUTRTL) {
            xy.x = rect.right;
        }
        ScreenToClient( hwndParent, &xy );
    }

    SetWindowPos( hwnd, NULL,
        xy.x + dx, xy.y + dy, 0, 0,
        SWP_NOSIZE + SWP_NOZORDER );
}


VOID
UnclipWindow(
    IN HWND hwnd )

    /* Moves window 'hwnd' so any clipped parts are again visible on the
    ** screen.  The window is moved only as far as necessary to achieve this.
    */
{
    RECT rect;
    INT  dxScreen = GetSystemMetrics( SM_CXSCREEN );
    INT  dyScreen = GetSystemMetrics( SM_CYSCREEN );

    GetWindowRect( hwnd, &rect );

    if (rect.right > dxScreen)
        rect.left = dxScreen - (rect.right - rect.left);

    if (rect.left < 0)
        rect.left = 0;

    if (rect.bottom > dyScreen)
        rect.top = dyScreen - (rect.bottom - rect.top);

    if (rect.top < 0)
        rect.top = 0;

    SetWindowPos(
        hwnd, NULL,
        rect.left, rect.top, 0, 0,
        SWP_NOZORDER + SWP_NOSIZE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\extapi\src\asyncm.h ===
/* Copyright (c) 1992, Microsoft Corporation, all rights reserved
**
** asyncm.h
** Remote Access External APIs
** Asyncronous state machine mechanism definitions
**
** 10/12/92 Steve Cobb
*/

#ifndef _ASYNCM_H_
#define _ASYNCM_H_


/* Defines an OnEvent function which is supplied by caller in the ASYNCMACHINE
** structure passed to StartAsyncMachine.  The first argument is actually an
** ASYNCMACHINE* but there's a chicken and egg definition problem with
** ONEVENTFUNC and ASYNCMACHINE that's most easily solved by caller casting
** the passed argument.  The second argument is true if a "drop" event has
** occurred, false if a "done" event has occurred.
**
** Caller's ONEVENTFUNC function is called once on each AsyncMachineEvent and
** should return as soon as possible.  Before returning caller's function should
** either call SignalDone or call an asynchronous RAS Manager call passing the
** hEvent member for notification.  On each call caller's function should check
** the 'dwError' member of ASYNCMACHINE before further processing to detect
** errors in the asynch machine mechanism.
**
** Caller's function should return true to quit, false to go on to the next
** state.
*/
typedef BOOL (*ONEVENTFUNC)( LPVOID, BOOL );

/* Defines a clean up function that is called just before exitting the async
** machine.
*/
typedef VOID (*CLEANUPFUNC)( LPVOID );

//
// Defines a free function that deallocates memory associated
// with the connection after the final event is read from the
// I/O completion port.
//
typedef VOID (*FREEFUNC)(LPVOID, LPVOID);

/* This structure is used to pass arguments into the asynchronous loop
** (squeezes more than one argument thru the one-argument thread interface on
** Win32).  Caller must fill in the 'oneventfunc' and 'cleanupfunc', and
** 'pParam' (passed to both calls, i.e. a control block) before calling
** StartAsyncMachine.  Thereafter, only the interface calls and macros should
** be used.
**
** There are three overlapped structures used in I/O completion port
** processing between rasapi32 and rasman.  OvDrop is the overlapped
** structure passed when rasman signals a port disconnect event.
** OvStateChange is the overlapped structure signaled both by rasapi32
** and rasman on the completion of rasdial state machine transitions.
** OvPpp is the overlapped structure signaled by rasman when a new PPP
** event arrives, and RasPppGetInfo can be called to return the event.
**
** 'dwError' is set non-0 if an system error occurs in the async machine
** mechanism.
**
** 'fQuitAsap' is indicates that the thread is being terminated by other than
** reaching a terminal state, i.e. by RasHangUp.
*/
#define INDEX_Drop      0

#define ASYNCMACHINE struct tagASYNCMACHINE

ASYNCMACHINE
{
    LIST_ENTRY  ListEntry;
    ONEVENTFUNC oneventfunc;
    CLEANUPFUNC cleanupfunc;
    VOID*       pParam;
    FREEFUNC    freefunc;
    LPVOID      freefuncarg;
    DWORD       dwError;
    //BOOL        fQuitAsap;
    BOOL        fSuspended;
    HANDLE      hDone;
    //
    // The following fields are used
    // by the async machine worker
    // thread to process I/O completion
    // packets.
    //
    BOOL        fSignaled;
    HPORT       hport;
    DWORD       dwfMode;
    HRASCONN    hRasconn;
    RAS_OVERLAPPED OvDrop;
    RAS_OVERLAPPED OvStateChange;
    RAS_OVERLAPPED OvPpp;
    RAS_OVERLAPPED OvLast;
};


//
// Flags to dwfMode parameter of EnableAsyncMachine().
//
#define ASYNC_ENABLE_ALL            0
#define ASYNC_MERGE_DISCONNECT      1
#define ASYNC_DISABLE_ALL           2

/* Function prototypes
*/
VOID  CloseAsyncMachine( ASYNCMACHINE* pasyncmachine );
DWORD NotifyCaller( DWORD dwNotifierType, LPVOID notifier,
          HRASCONN hrasconn, DWORD dwSubEntry, ULONG_PTR dwCallbackId,
          UINT unMsg, RASCONNSTATE state, DWORD dwError,
          DWORD dwExtendedError );
VOID  SignalDone( ASYNCMACHINE* pasyncmachine );
DWORD StartAsyncMachine( ASYNCMACHINE* pasyncmachine, HRASCONN hRasconn );
VOID  SuspendAsyncMachine( ASYNCMACHINE* pasyncmachine, BOOL fSuspended );
DWORD ResetAsyncMachine( ASYNCMACHINE *pasyncmachine );
BOOL  StopAsyncMachine( ASYNCMACHINE* pasyncmachine );
DWORD EnableAsyncMachine(HPORT, ASYNCMACHINE* pasyncmachine, DWORD dwfMode);
VOID  ShutdownAsyncMachine(VOID);

#endif /* _ASYNCM_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\common\uiutil\wait.c ===
/* Copyright (c) 1996, Microsoft Corporation, all rights reserved
**
** wait.c
** Waiting for services popup
** Listed alphabetically
**
** 02/17/96 Steve Cobb
*/

#include <windows.h>  // Win32 root
#include <debug.h>    // Trace and assert
#include <nouiutil.h> // No-HWND utilities
#include <uiutil.h>   // Our public header
#include <wait.rch>   // Our resource constants

/* Set when RasLoad has completed successfully in this process context.
*/
BOOL g_fRasLoaded = FALSE;


/* Waiting for services thread argument block.
*/
#define WSARGS struct tagWSARGS
WSARGS
{
    HINSTANCE hInst;
    HWND      hwndOwner;
    HANDLE    hEventUp;
    HANDLE    hEventDie;
};

/* Waiting for services thread context.
*/
#define WSINFO struct tagWSINFO
WSINFO
{
    HANDLE hEventDie;
    DWORD  dwThreadId;
    HICON  hIcon;    
};


/*----------------------------------------------------------------------------
** Local prototypes
**----------------------------------------------------------------------------
*/

VOID
StartWaitingForServices(
    HINSTANCE hInst,
    HWND      hwndOwner,
    WSINFO*   pInfo );

VOID
StopWaitingForServices(
    IN WSINFO* pInfo );

DWORD
WsThread(
    LPVOID pArg );

INT_PTR CALLBACK
WsDlgProc(
    HWND   hwnd,
    UINT   unMsg,
    WPARAM wParam,
    LPARAM lParam );


/*----------------------------------------------------------------------------
** Routines
**----------------------------------------------------------------------------
*/

DWORD
LoadRas(
    IN HINSTANCE hInst,
    IN HWND      hwnd )

    /* Starts the RASMAN service and loads the RASMAN and RASAPI32 entrypoint
    ** addresses.  The "waiting for services" popup is displayed, if
    ** indicated.  'HInst' and 'hwnd' are the owning instance and window.
    **
    ** Returns 0 if successful or an error code.
    */
{
    DWORD  dwErr;
    WSINFO info;

    TRACE("LoadRas");

    ZeroMemory(&info, sizeof(WSINFO)); 
    if (g_fRasLoaded)
        dwErr = 0;
    else
    {
        if (IsRasmanServiceRunning())
            info.hEventDie = NULL;
        else
            StartWaitingForServices( hInst, hwnd, &info );

        dwErr = LoadRasapi32Dll();
        if (dwErr == 0)
        {
            dwErr = LoadRasmanDll();
            if (dwErr == 0)
            {
                ASSERT(g_pRasInitialize);
                TRACE("RasInitialize");
                dwErr = g_pRasInitialize();
                TRACE1("RasInitialize=%d",dwErr);
            }
        }

        StopWaitingForServices( &info );

        if (dwErr == 0)
            g_fRasLoaded = TRUE;
    }

    TRACE1("LoadRas=%d",dwErr);
    return dwErr;
}


VOID
StartWaitingForServices(
    HINSTANCE hInst,
    HWND      hwndOwner,
    WSINFO*   pInfo )

    /* Popup the "waiting for services" dialog in another thread.  'HInst' and
    ** 'hwnd' are the owning instance and window.  Fills caller's 'pInfo' with
    ** context to pass to StopWaitingForServices.
    */
{
#ifndef NT4STUFF

    // Set the hourglass cursor
    pInfo->hIcon = SetCursor (LoadCursor (NULL, IDC_WAIT));
    ShowCursor (TRUE);

#else 

    WSARGS* pArgs;
    HANDLE  hThread;
    HANDLE  hEventUp;

    pInfo->hEventDie = NULL;

    pArgs = (WSARGS* )Malloc( sizeof(*pArgs) );
    if (!pArgs)
        return;

    ZeroMemory( pArgs, sizeof(*pArgs) );
    pArgs->hInst = hInst;
    pArgs->hwndOwner = hwndOwner;

    hEventUp = pArgs->hEventUp =
        CreateEvent( NULL, FALSE, FALSE, NULL );
    if (!hEventUp)
    {
        Free( pArgs );
        return;
    }

    pInfo->hEventDie = pArgs->hEventDie =
        CreateEvent( NULL, FALSE, FALSE, NULL );
    if (!pInfo->hEventDie)
    {
        Free( pArgs );
        CloseHandle( hEventUp );
        return;
    }

    /* Create a thread so paint messages for the popup get processed.  The
    ** current thread is going to be tied up starting RAS Manager.
    */
    hThread = CreateThread( NULL, 0, WsThread, pArgs, 0, &pInfo->dwThreadId );
    if (hThread)
    {
        /* Don't begin churning on RASMAN until the popup has displayed
        ** itself.
        */
        SetThreadPriority( hThread, THREAD_PRIORITY_HIGHEST );
        WaitForSingleObject( hEventUp, INFINITE );
        CloseHandle( hThread );
    }
    else
    {
        /* Thread was DOA.
        */
        CloseHandle( pInfo->hEventDie );
        pInfo->hEventDie = NULL;
        Free( pArgs );
    }

    CloseHandle( hEventUp );
    
#endif    
}


VOID
StopWaitingForServices(
    IN WSINFO* pInfo )

    /* Terminate the "waiting for services" popup.  'PInfo' is the context
    ** from StartWaitingForServices.
    */
{
    TRACE("StopWaitingForServices");


#ifndef NT4STUFF

    if (pInfo->hIcon == NULL)
        pInfo->hIcon = LoadCursor (NULL, IDC_ARROW);

    SetCursor (pInfo->hIcon);
    ShowCursor (TRUE);
    
#else

    if (pInfo->hEventDie)
    {
        /* The post triggers the message loop to action, but you can't rely on
        ** the posted message arriving in the thread message loop.  For
        ** example, if user holds the mouse down on the window caption, the
        ** message never appears, presumably because it's flushed by some
        ** sub-loop during "move window" processing.  Set the event to make
        ** sure the popup knows to quit the next time it processes a message.
        */
        SetEvent( pInfo->hEventDie );
        PostThreadMessage( pInfo->dwThreadId, WM_CLOSE, 0, 0 );
    }
    
#endif    
}


DWORD
WsThread(
    LPVOID pArg )

    /* Waiting for services thread main.
    */
{
    WSARGS* pArgs;
    HWND    hwnd;
    MSG     msg;

    TRACE("WsThread running");

    pArgs = (WSARGS* )pArg;
    hwnd = CreateDialog( pArgs->hInst,
               MAKEINTRESOURCE( DID_WS_WaitingForServices ),
               NULL, WsDlgProc );
    if (hwnd)
    {
        LONG lStyle;

        /* Make ourselves topmost if the owner window is, otherwise we may not
        ** be visible under the topmost window, such as the winlogin window.
        ** Note that if you actally create the dialog with an owner you have
        ** all kinds of thread related problems.  In retrospect, should have
        ** written this such that the "waiting" dialog happened in the main
        ** thread and the LoadLibraries and RasInitialize happened in the
        ** created thread which would automatically avoid this kind of
        ** problem, but this works too.
        */
        lStyle = GetWindowLong( pArgs->hwndOwner, GWL_EXSTYLE );
        if (lStyle & WS_EX_TOPMOST)
        {
            TRACE("TOPMOST");
            SetWindowPos( hwnd, HWND_TOPMOST,
                0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE );
        }

        CenterWindow( hwnd, pArgs->hwndOwner );
        ShowWindow( hwnd, SW_SHOW );
        UpdateWindow( hwnd );
        SetForegroundWindow( hwnd );
    }

    /* Tell other thread to go on.
    */
    SetEvent( pArgs->hEventUp );

    if (hwnd)
    {
        TRACE("WsThread msg-loop running");

        while (GetMessage( &msg, NULL, 0, 0 ))
        {
            if (WaitForSingleObject( pArgs->hEventDie, 0 ) == WAIT_OBJECT_0)
            {
                /* Normal termination.
                */
                DestroyWindow( hwnd );
                break;
            }

            if (!IsDialogMessage( hwnd, &msg ))
            {
                TranslateMessage( &msg );
                DispatchMessage( &msg );
            }
        }

        if (pArgs->hwndOwner)
            SetForegroundWindow( pArgs->hwndOwner );
    }

    CloseHandle( pArgs->hEventDie );
    Free( pArgs );
    TRACE("WsThread terminating");
    return 0;
}


INT_PTR CALLBACK
WsDlgProc(
    HWND   hwnd,
    UINT   unMsg,
    WPARAM wParam,
    LPARAM lParam )

    /* Standard Win32 dialog procedure.
    */
{
    if (unMsg == WM_INITDIALOG)
    {
        HMENU hmenu;

        /* Remove Close from the system menu since some people think it kills
        ** the app and not just the popup.
        */
        hmenu = GetSystemMenu( hwnd, FALSE );
        if (hmenu && DeleteMenu( hmenu, SC_CLOSE, MF_BYCOMMAND ))
            DrawMenuBar( hwnd );
        return TRUE;
    }

    return FALSE;
}


VOID
UnloadRas(
    void )

    /* Unload the DLLs loaded by LoadRas().
    */
{
    if (g_fRasLoaded)
    {
        g_fRasLoaded = FALSE;
        UnloadRasmanDll();
        UnloadRasapi32Dll();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\extapi\src\asyncm.c ===
/* Copyright (c) 1992, Microsoft Corporation, all rights reserved
**
** asyncm.c
** Remote Access External APIs
** Asynchronous state machine mechanism
** Listed alphabetically
**
** This mechanism is designed to encapsulate the "make asynchronous" code
** which will differ for Win32, Win16, and DOS.
**
** 10/12/92 Steve Cobb
*/


#include <extapi.h>

//
// Prototypes for routines only used locally.
//
DWORD AsyncMachineWorker(
    IN OUT LPVOID pThreadArg
    );

BOOL WaitForEvent(
    OUT ASYNCMACHINE **pasyncmachine,
    OUT LPDWORD iEvent
    );

extern CRITICAL_SECTION RasconncbListLock;
extern DTLLIST *PdtllistRasconncb;

//
// The table of active machines and the worker
// thread handle.  The worker thread can only
// handle up to MAX_ASYNC_ITEMS simultaneously.
//
#define MAX_ASYNC_ITEMS (MAXIMUM_WAIT_OBJECTS / 3)

HANDLE              hIoCompletionPort = INVALID_HANDLE_VALUE;
RAS_OVERLAPPED      ovShutdown;
CRITICAL_SECTION    csAsyncLock;
DWORD               dwcAsyncWorkItems;
LIST_ENTRY          AsyncWorkItems;
HANDLE              hAsyncEvent;
HANDLE              hAsyncThread;
HANDLE              hDummyEvent;

VOID
InsertAsyncWorkItem(
    IN ASYNCMACHINE *pasyncmachine
    )
{
    InsertTailList(&AsyncWorkItems, &pasyncmachine->ListEntry);
    dwcAsyncWorkItems++;
}


VOID
RemoveAsyncWorkItem(
    IN ASYNCMACHINE *pasyncmachine
    )
{
    if (!IsListEmpty(&pasyncmachine->ListEntry)) 
    {
        RemoveEntryList(&pasyncmachine->ListEntry);
        
        InitializeListHead(&pasyncmachine->ListEntry);
        
        dwcAsyncWorkItems--;
    }
}


DWORD
AsyncMachineWorker(
    IN OUT LPVOID pThreadArg )

/*++

Routine Description

    Generic worker thread that call's user's OnEvent function
    whenever an event occurs.  'pThreadArg' is the address of
    an ASYNCMACHINE structure containing caller's OnEvent
    function and parameters.

Arguments    

Return Value

    Returns 0 always.
    
--*/
{
    PLIST_ENTRY pEntry;
    ASYNCMACHINE* pasyncmachine;
    DWORD iEvent;

    for (;;)
    {
        //
        // WaitForEvent will return FALSE when there
        // are no items in the queue.
        //
        if (!WaitForEvent(&pasyncmachine, &iEvent))
        {
            break;
        }

        if (pasyncmachine->oneventfunc(
                pasyncmachine, (iEvent == INDEX_Drop) ))
        {
            //
            // Clean up resources.  This must be protected from 
            // interference by RasHangUp.
            //
            RASAPI32_TRACE("Asyncmachine: Cleaning up");
            
            EnterCriticalSection(&csStopLock);
            
            pasyncmachine->cleanupfunc(pasyncmachine);
            
            LeaveCriticalSection(&csStopLock);
        }
    }

    RASAPI32_TRACE("AsyncMachineWorker terminating");

    EnterCriticalSection(&csStopLock);

    EnterCriticalSection(&csAsyncLock);
    
    CloseHandle(hAsyncThread);
    
    CloseHandle(hIoCompletionPort);
    
    hIoCompletionPort = INVALID_HANDLE_VALUE;
    
    hAsyncThread = NULL;
    
    InitializeListHead(&AsyncWorkItems);
    
    LeaveCriticalSection(&csAsyncLock);

    SetEvent( HEventNotHangingUp );
    
    LeaveCriticalSection(&csStopLock);

    return 0;
}


VOID
CloseAsyncMachine(
    IN OUT ASYNCMACHINE* pasyncmachine )

/*++

Routine Description

    Releases resources associated with the asynchronous 
    state machine described in 'pasyncmachine'.

Arguments

Return Value
    
--*/

{
    DWORD dwErr;

    RASAPI32_TRACE("CloseAsyncMachine");

    EnterCriticalSection(&csAsyncLock);

    //
    // Disable the rasman I/O completion
    // port events.
    //
    if (pasyncmachine->hport == INVALID_HPORT)
    {
        dwErr = EnableAsyncMachine(
                  pasyncmachine->hport,
                  pasyncmachine,
                  ASYNC_DISABLE_ALL);
    }                  

    if (pasyncmachine->hDone) 
    {
        SetEvent(pasyncmachine->hDone);
        
        CloseHandle(pasyncmachine->hDone);
        
        pasyncmachine->hDone = NULL;
    }
    
    //
    // Remove the work item from the list of work items.
    // The worker thread will exit when there are no more
    // work items.
    //
    RemoveAsyncWorkItem(pasyncmachine);
    SetEvent(hAsyncEvent);

    LeaveCriticalSection(&csAsyncLock);
}


DWORD
NotifyCaller(
    IN DWORD        dwNotifierType,
    IN LPVOID       notifier,
    IN HRASCONN     hrasconn,
    IN DWORD        dwSubEntry,
    IN ULONG_PTR    dwCallbackId,
    IN UINT         unMsg,
    IN RASCONNSTATE state,
    IN DWORD        dwError,
    IN DWORD        dwExtendedError
    )

/*++

Routine Description

    Notify API caller of a state change event.  If
    the RASDIALFUNC2-style callback returns 0,
    the dial machine will not issue further callbacks
    for this connection.  If it returns 2, then the
    dial machine will re-read the phonebook entry
    for this connection, assuming a field in it has
    been modified.

Arguments

Return Value
    
--*/
{
    DWORD dwNotifyResult = 1;

    RASAPI32_TRACE5("NotifyCaller(nt=0x%x,su=%d,s=%d,e=%d,xe=%d)...",
      dwNotifierType,
      dwSubEntry,
      state,
      dwError,
      dwExtendedError);

    switch (dwNotifierType)
    {
        case 0xFFFFFFFF:
            SendMessage(
                (HWND )notifier, 
                unMsg, 
                (WPARAM )state, 
                (LPARAM )dwError );
            break;

        case 0:
            ((RASDIALFUNC )notifier)(
                (DWORD )unMsg, 
                (DWORD )state, 
                dwError );
            break;

        case 1:
            ((RASDIALFUNC1 )notifier)(
                        hrasconn, 
                        (DWORD )unMsg, 
                        (DWORD )state, 
                        dwError,
                        dwExtendedError 
                        );
            break;

        case 2:

            __try
            {
                dwNotifyResult =
                  ((RASDIALFUNC2)notifier)(
                    dwCallbackId,
                    dwSubEntry,
                    hrasconn,
                    (DWORD)unMsg,
                    (DWORD)state,
                    dwError,
                    dwExtendedError);
            }                
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                DWORD dwExceptionCode = GetExceptionCode();
                
                RASAPI32_TRACE2("NotifyCaller: notifier %p raised "
                        "exception 0x%x", 
                        notifier,
                        dwExceptionCode);

#if DBG
                DebugBreak();                         
#endif
                        
                ASSERT(FALSE);
            }
            
            break;
    }

    RASAPI32_TRACE1("NotifyCaller done (dwNotifyResult=%d)", 
           dwNotifyResult);

    return dwNotifyResult;
}


VOID
SignalDone(
    IN OUT ASYNCMACHINE* pasyncmachine )
/*++

Routine Description

    Triggers the "done with this state" event associated
    with 'pasyncmachine'.

Arguments

Return Value

--*/    
{
    if (hIoCompletionPort == INVALID_HANDLE_VALUE ||
        pasyncmachine->hDone == NULL)
    {
        return;
    }

    RASAPI32_TRACE1(
      "SignalDone: pOverlapped=0x%x",
      &pasyncmachine->OvStateChange);

    pasyncmachine->fSignaled = TRUE;
    if (!PostQueuedCompletionStatus(
          hIoCompletionPort,
          0,
          0,
          (LPOVERLAPPED)&pasyncmachine->OvStateChange))
    {
        pasyncmachine->dwError = GetLastError();
    }
}


VOID
ShutdownAsyncMachine(
    VOID
    )
    
/*++

Routine Description

    Tells the worker thread to shutdown.

Arguments

Return Value

--*/

{
    if (hIoCompletionPort == INVALID_HANDLE_VALUE)
        return;

    RASAPI32_TRACE1(
      "SignalShutdown: pOverlapped=0x%x",
      &ovShutdown);

    PostQueuedCompletionStatus(
      hIoCompletionPort,
      0,
      0,
      (LPOVERLAPPED)&ovShutdown);
}


DWORD
StartAsyncMachine(
    IN OUT ASYNCMACHINE* pasyncmachine,
    IN HRASCONN hrasconn)

/*++ 

Routine Description

    Allocates system resources necessary to run the async
    state machine 'pasyncmachine'.  Caller should fill in
    the oneventfunc and 'pParams' members of 'pasyncmachine'
    before the call.

Arguments

Return Value

    Returns 0 if successful, otherwise a non-0 error code.
    
--*/
{
    DWORD dwThreadId;
    DWORD dwErr = 0;

    RASAPI32_TRACE("StartAsyncMachine");

    pasyncmachine->dwError = 0;
    
    pasyncmachine->hDone = NULL;
    
    pasyncmachine->fSignaled = FALSE;
    
    pasyncmachine->hport = INVALID_HPORT;
    
    pasyncmachine->dwfMode = ASYNC_DISABLE_ALL;
    
    pasyncmachine->OvDrop.RO_EventType = OVEVT_DIAL_DROP;
    
    pasyncmachine->OvDrop.RO_Info = (PVOID)pasyncmachine;

    pasyncmachine->OvDrop.RO_hInfo = hrasconn;
    
    pasyncmachine->OvStateChange.RO_EventType = OVEVT_DIAL_STATECHANGE;
    
    pasyncmachine->OvStateChange.RO_Info = (PVOID)pasyncmachine;

    pasyncmachine->OvStateChange.RO_hInfo = hrasconn;
    
    pasyncmachine->OvPpp.RO_EventType = OVEVT_DIAL_PPP;
    
    pasyncmachine->OvPpp.RO_Info = (PVOID)pasyncmachine;

    pasyncmachine->OvPpp.RO_hInfo = hrasconn;
    
    pasyncmachine->OvLast.RO_EventType = OVEVT_DIAL_LAST;
    
    pasyncmachine->OvLast.RO_Info = (PVOID)pasyncmachine;

    pasyncmachine->OvLast.RO_hInfo = hrasconn;

    do
    {
        //
        // Create the event that is signaled by
        // the dialing machine when the connection
        // is completed.
        //
        if (!(pasyncmachine->hDone = CreateEvent(NULL,
                                                 FALSE,
                                                 FALSE,
                                                 NULL))) 
        {
            dwErr = GetLastError();
            break;
        }

        EnterCriticalSection(&csAsyncLock);
        
        //
        // Insert the work item into the list of
        // work items.
        //
        InsertTailList(&AsyncWorkItems, &pasyncmachine->ListEntry);
        
        dwcAsyncWorkItems++;
        
        //
        // Fork a worker thread if necessary.
        //
        if (hAsyncThread == NULL) 
        {
            //
            // Create the I/O completion port used in the
            // dialing state machine.
            //
            hIoCompletionPort = CreateIoCompletionPort(
                                  INVALID_HANDLE_VALUE,
                                  NULL,
                                  0,
                                  0);
                                  
            if (hIoCompletionPort == NULL)
            {
                dwErr = GetLastError();
                RemoveAsyncWorkItem(pasyncmachine);
                LeaveCriticalSection(&csAsyncLock);
                break;
            }
            
            //
            // Initialize the shutdown overlapped
            // structure used to shutdown the worker
            // thread.
            //
            ovShutdown.RO_EventType = OVEVT_DIAL_SHUTDOWN;

            //
            // Require that any pending HangUp has completed.
            // (This check is actually not required until
            // RasPortOpen, but putting it here confines
            // this whole "not hanging up" business to the
            // async machine routines).
            //
            WaitForSingleObject(HEventNotHangingUp, INFINITE);

            hAsyncThread = CreateThread(
                             NULL,
                             0,
                             AsyncMachineWorker,
                             NULL,
                             0,
                             (LPDWORD )&dwThreadId);
                             
            if (hAsyncThread == NULL) 
            {
                dwErr = GetLastError();
                RemoveAsyncWorkItem(pasyncmachine);
                LeaveCriticalSection(&csAsyncLock);
                break;
            }
        }
        LeaveCriticalSection(&csAsyncLock);
    }
    while (FALSE);

    if (dwErr) 
    {
        CloseHandle(pasyncmachine->hDone);
        pasyncmachine->hDone = NULL;
    }

    return dwErr;
}


VOID
SuspendAsyncMachine(
    IN OUT ASYNCMACHINE* pasyncmachine,
    IN BOOL fSuspended )
{
    if (pasyncmachine->fSuspended != fSuspended) 
    {
        pasyncmachine->fSuspended = fSuspended;
        
        //
        // Restart the async machine again, if necessary.
        //
        if (!fSuspended)
        {
            SignalDone(pasyncmachine);
        }
    }
}


DWORD
ResetAsyncMachine(
    IN OUT ASYNCMACHINE* pasyncmachine
    )
{
    pasyncmachine->dwError = 0;
    return 0;
}


BOOL
StopAsyncMachine(
    IN OUT ASYNCMACHINE* pasyncmachine )

/*++

Routine Description

    Tells the thread captured in 'pasyncmachine' to 
    terminate at the next opportunity.  The call may
    return before the machine actually terminates.

Arguments

Return Value

    Returns true if the machine is running on entry,
    false otherwise.
    
--*/
{
    BOOL fStatus = FALSE;
    DWORD dwErr;

    RASAPI32_TRACE("StopAsyncMachine");

    //
    // Disable the rasman I/O completion
    // port events.
    //
    dwErr = EnableAsyncMachine(
              pasyncmachine->hport,
              pasyncmachine,
              ASYNC_DISABLE_ALL);

    //
    // ...and tell this async machine to stop as
    // soon as possible.
    //
    fStatus = TRUE;

    return fStatus;
}

BOOL
fAsyncMachineRunning(PRAS_OVERLAPPED pRasOverlapped)
{
    RASCONNCB *prasconncb;
    BOOL fAMRunning = FALSE;
    DTLNODE *pdtlnode;

    EnterCriticalSection (  &RasconncbListLock );
    
    for (pdtlnode = DtlGetFirstNode( PdtllistRasconncb );
         pdtlnode;
         pdtlnode = DtlGetNextNode ( pdtlnode ))
    {
        prasconncb = (RASCONNCB*) DtlGetData( pdtlnode );
        
        if (    pRasOverlapped == 
                    &prasconncb->asyncmachine.OvStateChange
            ||  pRasOverlapped == 
                    &prasconncb->asyncmachine.OvDrop
            ||  pRasOverlapped == 
                    &prasconncb->asyncmachine.OvPpp
            ||  pRasOverlapped == 
                    &prasconncb->asyncmachine.OvLast)
        {
            if(     (NULL != pRasOverlapped->RO_Info)
                &&  (   (prasconncb->hrasconn == 
                        (HRASCONN) pRasOverlapped->RO_hInfo)
                    ||  (prasconncb->hrasconnOrig ==
                        (HRASCONN) pRasOverlapped->RO_hInfo)))
            {
                fAMRunning = TRUE;
                break;
            }
        }
    }            
    
    LeaveCriticalSection( &RasconncbListLock );

    if ( !fAMRunning )
    {
        RASAPI32_TRACE("fAsyncMachineRunning: The Asyncmachine"
              " is shutdown");
    }

    return fAMRunning;

    
}

BOOL
WaitForEvent(
    OUT ASYNCMACHINE **pasyncmachine,
    OUT LPDWORD piEvent
    )

/*++    

Routine Description
    Waits for one of the events associated with 
    'pasyncmachine' to be set. The dwError member
    of 'pasyncmachine' is set if an error occurs.

Arguments

Return Value

    Returns the index of the event that occurred.
    
--*/

{
    DWORD       dwcWorkItems,
                dwBytesTransferred;
    ULONG_PTR   ulpCompletionKey;
          
    PRAS_OVERLAPPED pOverlapped;

    RASAPI32_TRACE("WaitForEvent");

again:

    //
    // Wait for an event posted to the
    // I/O completion port.
    //
    if (!GetQueuedCompletionStatus(
           hIoCompletionPort,
           &dwBytesTransferred,
           &ulpCompletionKey,
           (LPOVERLAPPED *)&pOverlapped,
           INFINITE))
    {
        RASAPI32_TRACE1(
          "WaitForEvent: GetQueuedCompletionStatus"
          " failed (dwErr=%d)",
          GetLastError());
          
        return FALSE;
    }

    RASAPI32_TRACE1("WorkerThread: pOverlapped=0x%x",
           pOverlapped);
    
    //
    // make sure that the asyncmachine is running
    //
    if (    pOverlapped != (PRAS_OVERLAPPED) &ovShutdown
        &&  !fAsyncMachineRunning(pOverlapped))
    {
        RASAPI32_TRACE("WaitForEvent: Ignoring this event."
             " Asyncm shutdown. This is bad!!!");

        RASAPI32_TRACE1("WaitForEvent: Received 0x%x after the"
               "the connection was destroyed",
               pOverlapped);
        
        goto again;
    }

    RASAPI32_TRACE1("WorkerThread: type=%d",
            pOverlapped->RO_EventType);
    //
    // Check for shutdown event received.
    //
    
    if (pOverlapped->RO_EventType == OVEVT_DIAL_SHUTDOWN) 
    {
        RASAPI32_TRACE("WaitForEvent: OVTEVT_DIAL_SHUTDOWN "
        "event received");
        
        return FALSE;
    }
    
    *pasyncmachine = (ASYNCMACHINE *)pOverlapped->RO_Info;
    *piEvent = pOverlapped->RO_EventType - OVEVT_DIAL_DROP;

    //
    // Check the merge disconnect flag.  If this
    // is set and the event is a disconnect event,
    // then change the event to be a state change
    // event.  This is used during callback.
    //
    if (    pOverlapped->RO_EventType == OVEVT_DIAL_DROP 
        &&  (*pasyncmachine)->dwfMode == ASYNC_MERGE_DISCONNECT)
    {
        RASAPI32_TRACE1("asyncmachine=0x%x: merging disconnect event",
               *pasyncmachine);

        //
        // just something other than INDEX_Drop
        //           
        *piEvent = *piEvent + 1;
        
        (*pasyncmachine)->dwfMode = ASYNC_ENABLE_ALL;
    }
    else if (pOverlapped->RO_EventType == OVEVT_DIAL_LAST) 
    {
        if ((*pasyncmachine)->fSignaled) 
        {
            RASAPI32_TRACE2("asyncmachine=0x%x: next event will be last"
            " event for hport=%d",
            *pasyncmachine,
            (*pasyncmachine)->hport);
            
            (*pasyncmachine)->OvStateChange.RO_EventType
                                        = OVEVT_DIAL_LAST;
            
            (*pasyncmachine)->fSignaled = FALSE;
        }
        else 
        {
            RASAPI32_TRACE2("asyncmachine=0x%x: last event for hport=%d",
                   *pasyncmachine,
                   (*pasyncmachine)->hport);
                   
            (*pasyncmachine)->freefunc(
                              *pasyncmachine,
                              (*pasyncmachine)->freefuncarg
                              );
        }
        goto again;
    }



    //
    // Clear the signaled flag set in SignalDone().
    //
    if (pOverlapped->RO_EventType == OVEVT_DIAL_STATECHANGE)
    {
        (*pasyncmachine)->fSignaled = FALSE;
    }
    
    if ((*pasyncmachine)->hDone == NULL) 
    {
        RASAPI32_TRACE1(
          "Skipping completed asyncmachine pointer: 0x%x",
          pOverlapped->RO_Info);
          
        goto again;
    }
    
    RASAPI32_TRACE2("Unblock i=%d, h=0x%x",
           *piEvent,
           *pasyncmachine);

    return TRUE;
}


DWORD
EnableAsyncMachine(
    HPORT hport,
    ASYNCMACHINE *pasyncmachine,
    DWORD dwfMode
    )
{
    DWORD dwErr = 0;

    pasyncmachine->dwfMode = dwfMode;
    
    switch (dwfMode) 
    {
    case ASYNC_ENABLE_ALL:
        ASSERT(hIoCompletionPort != INVALID_HANDLE_VALUE);
        
        RASAPI32_TRACE6(
            "EnableAsyncMachine: hport=%d, pasyncmachine=0x%x, "
            "OvDrop=0x%x, OvStateChange=0x%x, OvPpp=0x%x, "
            "OvLast=0x%x", 
            hport,
            pasyncmachine,
            &pasyncmachine->OvDrop,
            &pasyncmachine->OvStateChange,
            &pasyncmachine->OvPpp,

        &pasyncmachine->OvLast);
        
        //
        // Stash away a copy of the hport.
        //
        pasyncmachine->hport = hport;
        
        //
        // Set the I/O completion port associated
        // with this port.  The I/O completion port
        // is used in place of event handles to drive
        // the connection process.
        //
        dwErr = g_pRasSetIoCompletionPort(
                  hport,
                  hIoCompletionPort,
                  &pasyncmachine->OvDrop,
                  &pasyncmachine->OvStateChange,
                  &pasyncmachine->OvPpp,
                  &pasyncmachine->OvLast,
                  pasyncmachine->hRasconn);
                  
        break;
        
    case ASYNC_MERGE_DISCONNECT:
    
        //
        // Disable the rasman I/O completion
        // port events.  No processing necessary.
        //
        break;
        
    case ASYNC_DISABLE_ALL:
    
        //
        // Disable the rasman I/O completion
        // port events.
        //
        if (pasyncmachine->hport != INVALID_HPORT)
        {
            dwErr = g_pRasSetIoCompletionPort(
                      pasyncmachine->hport,
                      INVALID_HANDLE_VALUE,
                      NULL,
                      NULL,
                      NULL,
                      NULL,
                      pasyncmachine->hRasconn);
        }
        
        break;
        
    default:
    
        ASSERT(FALSE);
        RASAPI32_TRACE1("EnableAsyncMachine: invalid mode=%d",
               dwfMode);
               
        dwErr = ERROR_INVALID_PARAMETER;
        
        break;
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\extapi\src\eapui.c ===
/*++

Copyright (c) 1995, Microsoft Corporation, all rights reserved

Module Name:

    eapui.c

Abstract:

    this file contains code to Invoke the eapui from registry

Author:    

    Rao Salapaka 11/03/97 

Revision History:    

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <extapi.h>
#include "extapi.h"
#include "rasauth.h"
#include "raseapif.h"

typedef DWORD (APIENTRY * PEAPINVOKEINTERACTIVEUI)(
                                           DWORD,
                                           HWND,
                                           PBYTE,
                                           DWORD,
                                           PBYTE *,
                                           DWORD *);

typedef DWORD (APIENTRY * PEAPFREEMEMORY)(
                                           PBYTE);

LONG
lrGetMaxSubkeyLength( HKEY hkey, DWORD *pdwMaxSubkeyLen )
{
    LONG        lr = ERROR_SUCCESS;
    FILETIME    ft;

    lr = RegQueryInfoKey( hkey,
                          NULL, NULL, NULL, NULL,
                          pdwMaxSubkeyLen,
                          NULL, NULL, NULL, NULL,
                          NULL, &ft);
    return lr;
}

DWORD
DwGetDllPath(DWORD dwEapTypeId, LPTSTR *ppszDllPath)
{
    LONG        lr              = ERROR_SUCCESS;
    HKEY        hkey            = NULL;
    DWORD       dwIndex         = 0;
    DWORD       dwType, dwSize;
    DWORD       dwTypeId;
    LPTSTR      pszDllPath;
    TCHAR       szEapPath[64]   = {0};
    TCHAR       szEapId[12]     = {0};

    //
    // Create the path to the eap key we 
    // are interested in
    //
    _snwprintf(szEapPath,
               (sizeof(szEapPath) / sizeof(TCHAR)) - 1,
               TEXT("%s\\%s"), 
               RAS_EAP_REGISTRY_LOCATION, 
               _ultow(dwEapTypeId, szEapId, 10));

    //
    // Open the eap key
    //
    if (lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          szEapPath,
                          0,
                          KEY_READ,
                          &hkey))
    {
        RASAPI32_TRACE1(
            "failed to open eap key %S. 0x%0x",
            szEapPath);
            
        RASAPI32_TRACE1("rc=0x%08x", lr);
            
        goto done;            
    }

    dwSize = 0;
    
    //
    // Get the size of the dll path
    //
    if(lr = RegQueryValueEx(
                        hkey,
                        RAS_EAP_VALUENAME_INTERACTIVEUI,
                        NULL,
                        &dwType,
                        NULL,
                        &dwSize))
    {
        RASAPI32_TRACE1("RegQ failed. for InteractiveUI. 0x%x",
               lr);
               
        goto done;
        
    }

    //
    // Allocate and get the dll name
    //
    pszDllPath = LocalAlloc(LPTR, dwSize);
    if(NULL == pszDllPath)
    {
        lr = (LONG) GetLastError();
        
        RASAPI32_TRACE2("Failed to allocate size %d. rc=0x%x",
               dwSize,
               lr);

        goto done;               
    }

    if (lr = RegQueryValueEx(
                        hkey,
                        RAS_EAP_VALUENAME_INTERACTIVEUI,
                        NULL,
                        &dwType,
                        (PBYTE) pszDllPath,
                        &dwSize))
    {
    
        RASAPI32_TRACE1("RegQ failed. for InteractiveUI. 0x%x",
               lr);
               
        goto done;
    }

    //
    // Expand the dllpath
    //
    lr = (LONG) DwGetExpandedDllPath(pszDllPath,
                                     ppszDllPath);
    
done:

    if (hkey)
    {
        RegCloseKey(hkey);
    }

    return (DWORD) lr;
}

DWORD
DwLoadEapDllAndGetEntryPoints( 
        DWORD                       dwEapTypeId,
        PEAPINVOKEINTERACTIVEUI     *ppfnInvoke,
        PEAPFREEMEMORY              *ppfnFree,
        HINSTANCE                   *phlib
        )
{
    HKEY        hkey                = NULL;
    LPTSTR      pszDllPath          = NULL;
    LPTSTR      pszExpandedDllPath  = NULL;
    DWORD       dwErr;
    DWORD       dwSize;
    DWORD       dwType;
    HINSTANCE   hlib = NULL;

    dwErr = DwGetDllPath(dwEapTypeId, &pszDllPath);

    if (dwErr)
    {
        RASAPI32_TRACE1("GetDllPath failed. %d", dwErr);

        goto done;
    }

    //
    // Load lib and get the entrypoints
    //
    hlib = LoadLibrary(pszDllPath);

    if (NULL == hlib)
    {
        dwErr = GetLastError();
        
        RASAPI32_TRACE1("Failed to load %S", pszDllPath);
        
        RASAPI32_TRACE1("dwErr=%d", dwErr);
        
        goto done;
    }

    if (    !((*ppfnInvoke) = (PEAPINVOKEINTERACTIVEUI)
                              GetProcAddress(
                                hlib, 
                                "RasEapInvokeInteractiveUI"))
                
        ||  !((*ppfnFree ) = (PEAPFREEMEMORY)
                             GetProcAddress(
                                hlib, 
                                "RasEapFreeMemory")))
    {
        dwErr = GetLastError();
        
        RASAPI32_TRACE1("failed to get entrypoint. rc=%d", dwErr);

        FreeLibrary(hlib);
        
        hlib = NULL;
        
        goto done;
    }
                                             
done:

    *phlib = hlib;

    if ( pszDllPath )
    {
        LocalFree(pszDllPath);
    }

    return dwErr;
}

DWORD
DwCallEapUIEntryPoint(s_InvokeEapUI *pInfo, HWND hWnd )
{
    DWORD                       dwErr;
    PEAPINVOKEINTERACTIVEUI     pfnEapInvokeInteractiveUI;
    PEAPFREEMEMORY              pfnEapFreeMemory;
    HINSTANCE                   hlib;
    PBYTE                       pUIData = NULL;
    DWORD                       dwSizeOfUIData;

    dwErr = DwLoadEapDllAndGetEntryPoints(
                            pInfo->dwEapTypeId,
                            &pfnEapInvokeInteractiveUI,
                            &pfnEapFreeMemory,
                            &hlib);

    if (dwErr)
    {
        RASAPI32_TRACE1("DwLoadEapDllAndGetEntryPoints failed. %d",
                dwErr);

        goto done;                
    }

    //
    // Bringup the ui
    //
    dwErr = (*pfnEapInvokeInteractiveUI)(
                            pInfo->dwEapTypeId,
                            hWnd,
                            pInfo->pUIContextData,
                            pInfo->dwSizeOfUIContextData,
                            &pUIData,
                            &dwSizeOfUIData
                            );
    if (dwErr)
    {
        RASAPI32_TRACE1("pfnEapInvokeInteractiveUI failed. %d",
                dwErr);
                
        goto done;                
    }

    //
    // free the context we passed to the dll
    //
    LocalFree(pInfo->pUIContextData);

    //
    // Allocate a new buffer to hold the user data
    //
    pInfo->pUIContextData = LocalAlloc(LPTR,
                                       dwSizeOfUIData);

    if (    (NULL == pInfo->pUIContextData)
        &&  (0 != dwSizeOfUIData))
    {
        dwErr = GetLastError();
        
        RASAPI32_TRACE2("DwCallEapUIEntryPoint: failed to"
               " allocate size %d. rc=%d",
               dwSizeOfUIData,
               dwErr);
               
        goto done;                            
    }

    //
    // fill in the new information
    //
    memcpy( pInfo->pUIContextData,
            pUIData,
            dwSizeOfUIData);
            
    pInfo->dwSizeOfUIContextData = dwSizeOfUIData;            

done:

    if (pUIData)
    {
        pfnEapFreeMemory(
                    pUIData
                    );
    }

    if (hlib)
    {
        FreeLibrary(hlib);
    }

    return dwErr;
}


BOOL
InvokeEapUI( HRASCONN            hConn, 
             DWORD               dwSubEntry, 
             LPRASDIALEXTENSIONS lpExtensions, 
             HWND                hWnd)
{
    s_InvokeEapUI *pInfo;
    PBYTE       pbEapUIData;
    DWORD       dwErr = 0;

    RASAPI32_TRACE("InvokeEapUI...");

    pInfo = LocalAlloc(LPTR, sizeof(s_InvokeEapUI));
    
    if (NULL == pInfo)
    {

        dwErr = GetLastError();
        
        RASAPI32_TRACE2("InvokeEapUI: Failed to allocate size %d. %d",
                sizeof(s_InvokeEapUI),
                dwErr);

        goto done;                
    }
    
    //
    // Get the size of eap information
    //
    RASAPI32_TRACE("InvokeEapUI: RasPppGetEapInfo...");
    
    dwErr = g_pRasPppGetEapInfo(
                    (HCONN) hConn, 
                    dwSubEntry, 
                    &pInfo->dwContextId,
                    &pInfo->dwEapTypeId,
                    &pInfo->dwSizeOfUIContextData,
                    NULL);
                              
    RASAPI32_TRACE1("InvokeEapUI: RasPppGetEapInfo done. %d", dwErr);

    if (    ERROR_BUFFER_TOO_SMALL != dwErr
        &&  ERROR_SUCCESS != dwErr)
    {
        RASAPI32_TRACE("InvokeEapUI: RasPppGetEapInfo failed.");
        
        goto done;
    }

    if(ERROR_BUFFER_TOO_SMALL == dwErr)
    {
        pInfo->pUIContextData = LocalAlloc(
                                    LPTR,
                                    pInfo->dwSizeOfUIContextData);

        if (    NULL == pInfo->pUIContextData
            &&  0 != pInfo->dwSizeOfUIContextData)
        {
            dwErr = GetLastError();
            
            RASAPI32_TRACE2("InvokeEapUI: Failed to allocate size %d. %d",
                    pInfo->dwSizeOfUIContextData,
                    dwErr);

            goto done;                
        }

        //
        // Get the eap information
        //
        RASAPI32_TRACE("InvokeEapUI: RasPppGetEapInfo...");

        dwErr = g_pRasPppGetEapInfo(
                            (HCONN) hConn,
                            dwSubEntry,
                            &pInfo->dwContextId,
                            &pInfo->dwEapTypeId,
                            &pInfo->dwSizeOfUIContextData,
                            pInfo->pUIContextData);

        RASAPI32_TRACE1("InvokeEapUI: RasPppGetEapInfo done. %d",
                dwErr);

        if ( 0 != dwErr)
        {
            RASAPI32_TRACE("InvokeEapUI: RasPppGetEapInfo failed.");
            goto done;
        }
    }

    dwErr = DwCallEapUIEntryPoint(pInfo, hWnd);

    if (dwErr)
    {
        RASAPI32_TRACE1("InvokeEapUI: DwCallEapUIEntryPoint returned %d",
               dwErr);

        goto done;                
    }

    lpExtensions->reserved1 = (ULONG_PTR) pInfo;

done:
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\extapi\src\dll.c ===
/* Copyright (c) 1992, Microsoft Corporation, all rights reserved
**
** dll.c
** Remote Access External APIs
** DLL entry point
**
** 10/12/92 Steve Cobb
*/


#define DEBUGGLOBALS
#include <extapi.h>


// Delay load support
//
#include <delayimp.h>

EXTERN_C
FARPROC
WINAPI
DelayLoadFailureHook (
    UINT            unReason,
    PDelayLoadInfo  pDelayInfo
    );

PfnDliHook __pfnDliFailureHook = DelayLoadFailureHook;


//
// Global variables.
//
HINSTANCE hModule;
DTLLIST* PdtllistRasconncb;
DWORD DwfInstalledProtocols = (DWORD)-1;
CRITICAL_SECTION RasconncbListLock;
CRITICAL_SECTION csStopLock;
HANDLE HEventNotHangingUp;
DWORD DwRasInitializeError;

//
// dhcp.dll entry points
//
DHCPNOTIFYCONFIGCHANGE PDhcpNotifyConfigChange;

//
// rasiphlp.dll entry points
//
HELPERSETDEFAULTINTERFACENET PHelperSetDefaultInterfaceNet;

//
// mprapi.dll entry points
//
MPRADMINISSERVICERUNNING PMprAdminIsServiceRunning;

//
// rascauth.dll entry points
//
AUTHCALLBACK g_pAuthCallback;
AUTHCHANGEPASSWORD g_pAuthChangePassword;
AUTHCONTINUE g_pAuthContinue;
AUTHGETINFO g_pAuthGetInfo;
AUTHRETRY g_pAuthRetry;
AUTHSTART g_pAuthStart;
AUTHSTOP g_pAuthStop;

//
// rasscript.dll entry points
//
RASSCRIPTEXECUTE g_pRasScriptExecute;

//
// rasshare.lib declaratiosn
//
extern BOOL CsDllMain(DWORD fdwReason);

//
// rasscrpt.lib declaration
//
BOOL 
WINAPI
RasScriptDllMain(
    IN      HINSTANCE   hinstance,
    IN      DWORD       dwReason,
    IN      PVOID       pUnused);

//
// External variables.
//

BOOL
DllMain(
    HANDLE hinstDll,
    DWORD  fdwReason,
    LPVOID lpReserved )

    /* This routine is called by the system on various events such as the
    ** process attachment and detachment.  See Win32 DllEntryPoint
    ** documentation.
    **
    ** Returns true if successful, false otherwise.
    */
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hinstDll);

        hModule = hinstDll;

        //
        // Load the rasman/raspi32 function pointers
        // used by the nouiutil library.
        //
        if (LoadRasapi32Dll())
            return FALSE;

        /* Create the list of connection control blocks.
        */
        if (!(PdtllistRasconncb = DtlCreateList( 0 )))
            return FALSE;

        /* Create the control block list mutex.
        */
        __try
        {
            InitializeCriticalSection(&RasconncbListLock);
        }
         __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return FALSE;    
         }

        /* Create the thread stopping mutex.
        */
        __try
        {
            InitializeCriticalSection(&csStopLock);
        }
         __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return FALSE;    
         }
        

        /* Initialize the Phonebook library.
        */
        if (InitializePbk() != 0)
            return FALSE;

        /* Create the "hung up port will be available" event.
        */
        if (!(HEventNotHangingUp = CreateEvent( NULL, TRUE, TRUE, NULL )))
            return FALSE;

        //
        // Create a dummy event that is not used so
        // we can pass a valid event handle to rasman
        // for connect, listen, and disconnect operations.
        //
        if (!(hDummyEvent = CreateEvent( NULL, FALSE, FALSE, NULL )))
            return FALSE;

        //
        // Create the async machine global mutex.
        //
        InitializeCriticalSection(&csAsyncLock);
        if (!(hAsyncEvent = CreateEvent(NULL, TRUE, TRUE, NULL))) {
            return FALSE;
        }
        InitializeListHead(&AsyncWorkItems);

        //
        // Initialize the connection sharing module
        //

        if (!CsDllMain(fdwReason))
            return FALSE;

        //
        // Initialize the ras script library
        //

        if (! RasScriptDllMain(hinstDll, fdwReason, lpReserved))
            return FALSE;
    }
    else if (fdwReason == DLL_PROCESS_DETACH)
    {
        //
        // Shutdown the ras script module
        //
        
        RasScriptDllMain(hinstDll, fdwReason, lpReserved);

        //
        // Shutdown the connection sharing module.
        //

        CsDllMain(fdwReason);

        if (PdtllistRasconncb)
            DtlDestroyList(PdtllistRasconncb, DtlDestroyNode);

        if (HEventNotHangingUp)
            CloseHandle( HEventNotHangingUp );

        /* Unload nouiutil entrypoints.
        */
        UnloadRasapi32Dll();
        UnloadRasmanDll();

        /* Uninitialize the Phonebook library.
        */
        TerminatePbk();

        //
        // Unload any other DLLs we've
        // dynamically loaded.
        //
        UnloadDlls();

        RasApiDebugTerm();
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\extapi\src\extapi.h ===
/* Copyright (c) 1992, Microsoft Corporation, all rights reserved
**
** extapi.h
** Remote Access External APIs
** Internal header
**
** 10/12/92 Steve Cobb
*/

#ifndef _EXTAPI_H_
#define _EXTAPI_H_

#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <tapi.h>
#include <ras.h>
#include <raserror.h>
#include <mprerror.h>

typedef LONG    APIERR;

#ifdef UNICODE
#include <nouiutil.h>
#else
#define UNICODE
#undef LPTSTR
#define LPTSTR WCHAR*
#undef TCHAR
#define TCHAR WCHAR
#include <nouiutil.h>
#undef TCHAR
#define TCHAR CHAR
#undef LPTSTR
#define LPTSTR CHAR*
#undef UNICODE
#endif

#include <uiip.h>
#include <rasip.h>
#include <clauth.h>
#include <dhcpcapi.h>
#include <rasp.h>

#ifdef UNICODE
#undef UNICODE
#include <rasppp.h>
#define INCL_PARAMBUF
#include <ppputil.h>
#define UNICODE
#else
#include <rasppp.h>
#define INCL_PARAMBUF
#include <ppputil.h>
#endif

#include <rasdlg.h>
#ifdef UNICODE
#include <pbk.h>
#include <phonenum.h>
#else
#define UNICODE
#include <pbk.h>
#include <phonenum.h>
#undef UNICODE
#endif

#include <asyncm.h>
#undef ASSERT
#include <debug.h>
#include <rasscrpt.h>
#include <rasuip.h>
#include "tstr.h"
#include "pwutil.h"

#define RAS_MaxConnectResponse  128
#define RAS_MaxProjections 3

#define RESTART_HuntGroup     0x1
#define RESTART_DownLevelIsdn 0x2

//
// TODO: Remove the maintenance of
// dwAuthentication from rasconncb.
// Putting this in temporarily.
//
#define AS_PppOnly                          2

//
// Multilink suspend states for dwfSuspended field
// in RASCONNCB.
//
#define SUSPEND_Master      0xffffffff
#define SUSPEND_Start       0
#define SUSPEND_InProgress  1
#define SUSPEND_Done        2

//
// Distinguish between connection-based
// and port-based HRASCONNs.
//
#define IS_HPORT(h) ((NULL != h) && (HandleToUlong(h) & 0xffff0000) ? FALSE : TRUE)
#define HPORT_TO_HRASCONN(h)  (HRASCONN)(UlongToPtr(HandleToUlong(h) + 1))
#define HRASCONN_TO_HPORT(h)  (HPORT)UlongToPtr((HandleToUlong(h) - 1))

//
// Debug string macros.
//
#define TRACESTRA(s)    ((s) != NULL ? (s) : "(null)")
#define TRACESTRW(s)    ((s) != NULL ? (s) : L"(null)")

enum _VPNPROTS
{
    PPTP    = 0,
    L2TP,
    NUMVPNPROTS
};

typedef enum _VPNPROTS VPNPROTS;

//-----------------------------------------
// Data Structures
//-----------------------------------------

//
// structure to convey eap information
// between ppp and rasdialmachine
//
typedef struct _INVOKE_EAP_UI
{
    DWORD       dwEapTypeId;
    DWORD       dwContextId;
    DWORD       dwSizeOfUIContextData;
    PBYTE       pUIContextData;

} s_InvokeEapUI;


//
// Connection control block.
//
#define RASCONNCB struct tagRASCONNCB

RASCONNCB
{
    //
    //The rasman connection identifier.
    //
    HCONN hrasconn;

    //
    //These fields are updated continually during state processing.
    //
    RASCONNSTATE rasconnstate;
    RASCONNSTATE rasconnstateNext;
    ASYNCMACHINE asyncmachine;

    DWORD dwError;
    DWORD dwExtendedError;
    DWORD dwRestartOnError;
    DWORD dwSavedError;

    DWORD cAddresses;
    DWORD iAddress;
    DWORD *pAddresses;

    DWORD cPhoneNumbers;
    DWORD iPhoneNumber;

    DWORD cDevices;
    DWORD iDevice;

    //
    // These fields are updated during
    // authentication/projection phase.
    //
    NETBIOS_PROJECTION_RESULT AmbProjection;
    PPP_PROJECTION_RESULT     PppProjection;
    HPORT                     hportBundled;
    RASSLIP                   SlipProjection;
    BOOL                      fProjectionComplete;
    BOOL                      fServerIsPppCapable;

    //
    // These fields are determined when the
    // port is opened in state 0.  States
    // 1-n may assume that the port is open
    // and these fields are set.
    //
    HPORT hport;
    TCHAR  szPortName[ MAX_PORT_NAME + 1 ];
    TCHAR  szDeviceName[ MAX_DEVICE_NAME + 1 ];
    TCHAR  szDeviceType[ MAX_DEVICETYPE_NAME + 1 ];
    TCHAR  szUserKey[(MAX_PHONENUMBER_SIZE        \
                     < MAX_ENTRYNAME_SIZE         \
                     ? MAX_ENTRYNAME_SIZE         \
                     : MAX_PHONENUMBER_SIZE) + 1];

    //
    // These fields are supplied by the API caller or
    // determined by other non-RAS Manager means before
    // the state machine stage.  All states may assume
    // these values have been set.
    //
    ULONG_PTR      reserved;
    ULONG_PTR      reserved1;
    DWORD          dwNotifierType;
    LPVOID         notifier;
    HWND           hwndParent;
    UINT           unMsg;
    PBFILE         pbfile;
    PBENTRY        *pEntry;
    PBLINK         *pLink;
    RASDIALPARAMS  rasdialparams;
    BOOL           fAllowPause;
    BOOL           fDefaultEntry;
    BOOL           fDisableModemSpeaker;
    BOOL           fDisableSwCompression;
    BOOL           fPauseOnScript;
    DWORD          dwUserPrefMode;
    BOOL           fUsePrefixSuffix;
    BOOL           fNoClearTextPw;
    BOOL           fRequireMsChap;
    BOOL           fRequireEncryption;
    BOOL           fLcpExtensions;
    DWORD          dwfPppProtocols;
    CHAR           szzPppParameters[ PARAMETERBUFLEN ];
    TCHAR          szPhoneNumber[RAS_MaxPhoneNumber + 1];
    TCHAR          szDomain[DNLEN + 1];
    TCHAR          szOldPassword[ PWLEN + 1 ];
    BOOL           fOldPasswordSet;
    BOOL           fUpdateCachedCredentials;
    BOOL           fRetryAuthentication;
    BOOL           fMaster;
    DWORD          dwfSuspended;
    BOOL           fStopped;
    BOOL           fCleanedUp;
    BOOL           fDeleted;
    BOOL           fTerminated;
    BOOL           fRasdialRestart;
    BOOL           fAlreadyConnected;
    BOOL           fPppEapMode;
    DWORD          dwDeviceLineCounter;

    //
    // This is the array of vpn protocols
    // to be used while autodetecting.
    //
    RASDEVICETYPE  ardtVpnProts[NUMVPNPROTS];

    //
    // Current vpn protocol being tried.
    //
    DWORD          dwCurrentVpnProt;

    //
    // These fields are determined before state machine stage and updated
    // after a successful authentication.  All states may assume that these
    // values have been set.
    //
#if AMB
    DWORD dwAuthentication;
#endif

    BOOL  fPppMode;

    //
    // These fields are set off by default, then set to non-default states at
    // modem dial time.  They must be stored since they are required by
    // Authentication but are only available before RasPortConnectComplete is
    // called.
    //
    BOOL fUseCallbackDelay;
    WORD wCallbackDelay;

    //
    // This field indicates an ISDN device is in use on the connection.  It is
    // set during device connection for use during authentication.
    //
    BOOL fIsdn;

    //
    // This field indicates a modem device is the last device connected.  It
    // is set during device connection and reset during device connected
    // processing.
    //
    BOOL fModem;

    //
    // This field indicates the operator dial user preference is in effect.
    //  This is determined during ConstructPhoneNumber in RASCS_PortOpened
    //  state.
    //
    BOOL fOperatorDial;

    //
    // These fields apply only to WOW-originated connections.  They are set
    // immediately after RasDialA returns.
    //
    UINT unMsgWow;
    HWND hwndNotifyWow;

    //
    // PPP config information used for continuing a PPP connection.
    //
    PPP_CONFIG_INFO cinfo;
    LUID luid;

    //
    // List of connection blocks for all
    // simultaneously-dialed subentries in a
    // connection.
    //
    BOOL fMultilink;
    BOOL fBundled;
    LIST_ENTRY ListEntry;

    //
    // Idle disconnect timeout.
    //
    DWORD dwIdleDisconnectSeconds;

    // synchronous rasdial result
    LPDWORD psyncResult;

    BOOL fDialSingleLink;

    BOOL fTryNextLink;

    //EapLogon information
    RASEAPINFO RasEapInfo;

    //
    // Flag corresponding to RDEOPT_UseCustomScripting
    //
    BOOL fUseCustomScripting;

    //
    // Original rasconn with which the link was dialed. This might
    // change to the bundles hrasconn in the case when a single
    // link a connected multilinked bundle is brought up. This
    // needs to be maintained because otherwise we cannot accurately
    // determine if the rasconncb is still valid.
    //
    HRASCONN hrasconnOrig;
};


//-----------------------------------------------------
// Global Data
//-----------------------------------------------------

//
// Async worker work list, etc.
//
extern HANDLE hIoCompletionPort;
extern CRITICAL_SECTION csAsyncLock;
extern HANDLE hAsyncEvent;
extern LIST_ENTRY AsyncWorkItems;
extern HANDLE hDummyEvent;

//
// DLL's HINSTANCE stashed at initialization.
//
extern HINSTANCE hModule;

//
// List of currently active connections.
//
extern DTLLIST* PdtllistRasconncb;

//
// Bit field of installed protocols, i.e. VALUE_Nbf,
// VALUE_Ipx, VALUE_Ip.
//
extern DWORD DwfInstalledProtocols;

//
// Used to synchronize access to the list of currently
// active connections.
//
extern CRITICAL_SECTION RasconncbListLock;

//
// Used to synchronize access to thread termination code.
// This is used to prevent RasHangUp and the thread itself
// rom interfering with the others closing the port and
// releasing the control block.  Since the control block
// is released in the protected code the mutex must be
// global.
//
extern CRITICAL_SECTION csStopLock;

//
// Used to keep an async machine from starting between return from RasHangUp
// and termination of the hung up thread.  This prevents the "port not
// available" error that might otherwise occur.  That is, it makes RasHangUp
// look synchronous when it's really not.  (The reason it's not is so the
// caller can call RasHangUp from within a RasDial notification, which is the
// only convenient place to do it.) If the event is set it is OK to create a
// machine.
//
extern HANDLE HEventNotHangingUp;

//
// Used to indicate if/how RasInitialize has failed.  This is required since
// there are various things (NCPA running, user didn't reboot after install)
// that can result in RasMan initialization failure and we don't want the user
// to get the ugly system error popup.
//
extern DWORD FRasInitialized;
extern DWORD DwRasInitializeError;

//
// The error message DLL.
//
#define MSGDLLPATH  TEXT("mprmsg.dll")

//
// rasman.dll entry points
//
typedef DWORD (APIENTRY * RASPORTCLOSE)(HPORT);
extern RASPORTCLOSE PRasPortClose;

typedef DWORD (APIENTRY * RASPORTENUM)(PBYTE,
                                       PWORD,
                                       PWORD );
extern RASPORTENUM PRasPortEnum;

typedef DWORD (APIENTRY * RASPORTGETINFO)(HPORT,
                                          PBYTE,
                                          PWORD );
extern RASPORTGETINFO PRasPortGetInfo;

typedef DWORD (APIENTRY * RASPORTSEND)(HPORT,
                                       PBYTE,
                                       WORD);
extern RASPORTSEND PRasPortSend;

typedef DWORD (APIENTRY * RASPORTRECEIVE)(HPORT,
                                          PBYTE,
                                          PWORD,
                                          DWORD,
                                          HANDLE);
extern RASPORTRECEIVE PRasPortReceive;

typedef DWORD (APIENTRY * RASPORTLISTEN)(HPORT,
                                         DWORD,
                                         HANDLE );
extern RASPORTLISTEN PRasPortListen;

typedef DWORD (APIENTRY * RASPORTCONNECTCOMPLETE)(HPORT);
extern RASPORTCONNECTCOMPLETE PRasPortConnectComplete;

typedef DWORD (APIENTRY * RASPORTDISCONNECT)(HPORT,
                                             HANDLE);
extern RASPORTDISCONNECT PRasPortDisconnect;

typedef DWORD (APIENTRY * RASPORTGETSTATISTICS)(HPORT,
                                                PBYTE,
                                                PWORD);
extern RASPORTGETSTATISTICS PRasPortGetStatistics;

typedef DWORD (APIENTRY * RASPORTCLEARSTATISTICS)(HPORT);
extern RASPORTCLEARSTATISTICS PRasPortClearStatistics;

typedef DWORD (APIENTRY * RASDEVICEENUM)(PCHAR,
                                         PBYTE,
                                         PWORD,
                                         PWORD);
extern RASDEVICEENUM PRasDeviceEnum;

typedef DWORD (APIENTRY * RASDEVICEGETINFO)(HPORT,
                                            PCHAR,
                                            PCHAR,
                                            PBYTE,
                                            PWORD);

extern RASDEVICEGETINFO PRasDeviceGetInfo;

typedef DWORD (APIENTRY * RASGETINFO)(HPORT,
                                      RASMAN_INFO*);
extern RASGETINFO PRasGetInfo;

typedef DWORD (APIENTRY * RASGETBUFFER)(PBYTE*,
                                        PWORD);
extern RASGETBUFFER PRasGetBuffer;

typedef DWORD (APIENTRY * RASFREEBUFFER)(PBYTE);
extern RASFREEBUFFER PRasFreeBuffer;

typedef DWORD (APIENTRY * RASREQUESTNOTIFICATION)(HPORT,
                                                  HANDLE);
extern RASREQUESTNOTIFICATION PRasRequestNotification;

typedef DWORD (APIENTRY * RASPORTCANCELRECEIVE)(HPORT);
extern RASPORTCANCELRECEIVE PRasPortCancelReceive;

typedef DWORD (APIENTRY * RASPORTENUMPROTOCOLS)(HPORT,
                                                RAS_PROTOCOLS*,
                                                PWORD);
extern RASPORTENUMPROTOCOLS PRasPortEnumProtocols;

typedef DWORD (APIENTRY * RASPORTSTOREUSERDATA)(HPORT,
                                                PBYTE,
                                                DWORD);
extern RASPORTSTOREUSERDATA PRasPortStoreUserData;

typedef DWORD (APIENTRY * RASPORTRETRIEVEUSERDATA)(HPORT,
                                                   PBYTE,
                                                   DWORD*);
extern RASPORTRETRIEVEUSERDATA PRasPortRetrieveUserData;

typedef DWORD (APIENTRY * RASPORTSETFRAMING)(HPORT,
                                             RAS_FRAMING,
                                             RASMAN_PPPFEATURES*,
                                             RASMAN_PPPFEATURES* );
extern RASPORTSETFRAMING PRasPortSetFraming;

typedef DWORD (APIENTRY * RASPORTSETFRAMINGEX)(HPORT,
                                               RAS_FRAMING_INFO*);
extern RASPORTSETFRAMINGEX PRasPortSetFramingEx;

typedef DWORD (APIENTRY * RASINITIALIZE)();
extern RASINITIALIZE PRasInitialize;

typedef DWORD (APIENTRY * RASSETCACHEDCREDENTIALS)(PCHAR,
                                                   PCHAR,
                                                   PCHAR);

extern RASSETCACHEDCREDENTIALS PRasSetCachedCredentials;

typedef DWORD (APIENTRY * RASGETDIALPARAMS)(DWORD,
                                            LPDWORD,
                                            PRAS_DIALPARAMS);
extern RASGETDIALPARAMS PRasGetDialParams;

typedef DWORD (APIENTRY * RASSETDIALPARAMS)(DWORD,
                                            DWORD,
                                            PRAS_DIALPARAMS,
                                            BOOL);
extern RASSETDIALPARAMS PRasSetDialParams;

typedef DWORD (APIENTRY * RASCREATECONNECTION)(HCONN *);
extern RASCREATECONNECTION PRasCreateConnection;

typedef DWORD (APIENTRY * RASDESTROYCONNECTION)(HCONN);
extern RASDESTROYCONNECTION PRasDestroyConnection;

typedef DWORD (APIENTRY * RASCONNECTIONENUM)(HCONN *,
                                             LPDWORD,
                                             LPDWORD);
extern RASCONNECTIONENUM PRasConnectionEnum;

typedef DWORD (APIENTRY * RASADDCONNECTIONPORT)(HCONN,
                                                HPORT,
                                                DWORD);
extern RASADDCONNECTIONPORT PRasAddConnectionPort;

typedef DWORD (APIENTRY * RASENUMCONNECTIONPORTS)(HCONN,
                                                  RASMAN_PORT *,
                                                  LPDWORD,
                                                  LPDWORD);
extern RASENUMCONNECTIONPORTS PRasEnumConnectionPorts;

typedef DWORD (APIENTRY * RASGETCONNECTIONPARAMS)(HCONN,
                                  PRAS_CONNECTIONPARAMS);
extern RASGETCONNECTIONPARAMS PRasGetConnectionParams;

typedef DWORD (APIENTRY * RASSETCONNECTIONPARAMS)(HCONN,
                                  PRAS_CONNECTIONPARAMS);
extern RASSETCONNECTIONPARAMS PRasSetConnectionParams;

typedef DWORD (APIENTRY * RASGETCONNECTIONUSERDATA)(HCONN,
                                                    DWORD,
                                                    PBYTE,
                                                    LPDWORD);
extern RASGETCONNECTIONUSERDATA PRasGetConnectionUserData;

typedef DWORD (APIENTRY * RASSETCONNECTIONUSERDATA)(HCONN,
                                                    DWORD,
                                                    PBYTE,
                                                    DWORD);
extern RASSETCONNECTIONUSERDATA PRasSetConnectionUserData;

typedef DWORD (APIENTRY * RASGETPORTUSERDATA)(HPORT,
                                              DWORD,
                                              PBYTE,
                                              LPDWORD);
extern RASGETPORTUSERDATA PRasGetPortUserData;

typedef DWORD (APIENTRY * RASSETPORTUSERDATA)(HPORT,
                                              DWORD,
                                              PBYTE,
                                              DWORD);
extern RASSETPORTUSERDATA PRasSetPortUserData;

typedef DWORD (APIENTRY * RASADDNOTIFICATION)(HCONN,
                                              HANDLE,
                                              DWORD);
extern RASADDNOTIFICATION PRasAddNotification;

typedef DWORD (APIENTRY * RASSIGNALNEWCONNECTION)(HCONN);
extern RASSIGNALNEWCONNECTION PRasSignalNewConnection;


/* DHCP.DLL entry points.
*/
typedef DWORD (APIENTRY * DHCPNOTIFYCONFIGCHANGE)(LPWSTR,
                                                  LPWSTR,
                                                  BOOL,
                                                  DWORD,
                                                  DWORD,
                                                  DWORD,
                                                  SERVICE_ENABLE );
extern DHCPNOTIFYCONFIGCHANGE PDhcpNotifyConfigChange;


/* RASIPHLP.DLL entry points.
*/
typedef APIERR (FAR PASCAL * HELPERSETDEFAULTINTERFACENET)(IPADDR,
                                                           BOOL);
extern HELPERSETDEFAULTINTERFACENET PHelperSetDefaultInterfaceNet;

//
// MPRAPI.DLL entry points
//
typedef BOOL (FAR PASCAL * MPRADMINISSERVICERUNNING) (
                                                LPWSTR);


extern MPRADMINISSERVICERUNNING PMprAdminIsServiceRunning;                                                
 
//
// RASCAUTH.DLL entry points.
//
typedef DWORD (FAR PASCAL *AUTHCALLBACK)(HPORT, PCHAR);
extern AUTHCALLBACK g_pAuthCallback;

typedef DWORD (FAR PASCAL *AUTHCHANGEPASSWORD)(HPORT,
                                               PCHAR,
                                               PCHAR,
                                               PCHAR);
extern AUTHCHANGEPASSWORD g_pAuthChangePassword;

typedef DWORD (FAR PASCAL *AUTHCONTINUE)(HPORT);
extern AUTHCONTINUE g_pAuthContinue;

typedef DWORD (FAR PASCAL *AUTHGETINFO)(HPORT,
                                        PAUTH_CLIENT_INFO);
extern AUTHGETINFO g_pAuthGetInfo;

typedef DWORD (FAR PASCAL *AUTHRETRY)(HPORT,
                                      PCHAR,
                                      PCHAR,
                                      PCHAR);
extern AUTHRETRY g_pAuthRetry;

typedef DWORD (FAR PASCAL *AUTHSTART)(HPORT,
                                      PCHAR,
                                      PCHAR,
                                      PCHAR,
                                      PAUTH_CONFIGURATION_INFO,
                                      HANDLE);
extern AUTHSTART g_pAuthStart;

typedef DWORD (FAR PASCAL *AUTHSTOP)(HPORT);
extern AUTHSTOP g_pAuthStop;

//
// RASSCRPT.DLL entry points
//
typedef DWORD (APIENTRY *RASSCRIPTEXECUTE)(HRASCONN,
                                           PBENTRY*,
                                           CHAR*,
                                           CHAR*,
                                           CHAR*);
extern RASSCRIPTEXECUTE g_pRasScriptExecute;

//-------------------------------------------------------
// Function Prototypes
//-------------------------------------------------------

DWORD       RasApiDebugInit();

DWORD       RasApiDebugTerm();

VOID         ReloadRasconncbEntry( RASCONNCB* prasconncb );

VOID         DeleteRasconncbNode( RASCONNCB* prasconncb );

VOID         CleanUpRasconncbNode(DTLNODE *pdtlnode);

VOID         FinalCleanUpRasconncbNode(DTLNODE *pdtlnode);

DWORD        ErrorFromDisconnectReason( RASMAN_DISCONNECT_REASON reason );

IPADDR       IpaddrFromAbcd( TCHAR* pwchIpAddress );

DWORD        LoadDhcpDll();

DWORD        LoadRasAuthDll();

DWORD        LoadRasScriptDll();

DWORD        LoadRasmanDllAndInit();

DWORD        LoadTcpcfgDll();

VOID         UnloadDlls();

DWORD        OnRasDialEvent(ASYNCMACHINE* pasyncmachine,
                            BOOL fDropEvent);

DWORD        OpenMatchingPort(RASCONNCB* prasconncb);

BOOL         FindNextDevice(RASCONNCB *prasconncb);

DWORD        DwOpenPort(RASCONNCB *prasconncb);

DWORD        _RasDial(LPCTSTR,
                      DWORD,
                      BOOL,
                      ULONG_PTR,
                      RASDIALPARAMS*,
                      HWND,
                      DWORD,
                      LPVOID,
                      ULONG_PTR,
                      LPRASDIALEXTENSIONS,
                      LPHRASCONN );

VOID         RasDialCleanup( ASYNCMACHINE* pasyncmachine );

VOID         RasDialFinalCleanup(ASYNCMACHINE* pasyncmachine,
                                 DTLNODE *pdtlnode);

RASCONNSTATE RasDialMachine( RASCONNSTATE rasconnstate,
                             RASCONNCB* prasconncb,
                             HANDLE hEventAuto,
                             HANDLE hEventManual );

VOID         RasDialRestart( RASCONNCB** pprasconncb );

VOID         RasDialTryNextLink(RASCONNCB **pprasconncb);

VOID        RasDialTryNextVpnDevice(RASCONNCB **pprasconncb);

DWORD        ReadPppInfoFromEntry( RASCONNCB* prasconncb );

DWORD        ReadConnectionParamsFromEntry( RASCONNCB* prasconncb,

                 PRAS_CONNECTIONPARAMS pparams );

DWORD        ReadSlipInfoFromEntry(RASCONNCB* prasconncb,
                                   WCHAR** ppwszIpAddress,
                                   BOOL* pfHeaderCompression,
                                   BOOL* pfPrioritizeRemote,
                                   DWORD* pdwFrameSize );

DWORD        SetSlipParams(RASCONNCB* prasconncb);

DWORD        RouteSlip(RASCONNCB* prasconncb,
                       WCHAR* pwszIpAddress,
                       BOOL fPrioritizeRemote,
                       DWORD dwFrameSize );
#if AMB
VOID         SetAuthentication( RASCONNCB* prasconncb,
                                DWORD dwAuthentication );
#endif

DWORD        SetDefaultDeviceParams(RASCONNCB* prasconncb,
                                    TCHAR* pszType,
                                    TCHAR* pszName );

DWORD        SetDeviceParamString(HPORT hport,
                                  TCHAR* pszKey,
                                  TCHAR* pszValue,
                                  TCHAR* pszType,
                                  TCHAR* pszName );

DWORD        SetDeviceParamNumber(HPORT hport,
                                  TCHAR* pszKey,
                                  DWORD dwValue,
                                  TCHAR* pszType,
                                  TCHAR* pszName );

DWORD        SetDeviceParams(RASCONNCB* prasconncb,
                             TCHAR* pszType,
                             TCHAR* pszName,
                             BOOL* pfTerminal);

DWORD        SetMediaParam(HPORT hport,
                           TCHAR* pszKey,
                           TCHAR* pszValue );

DWORD        SetMediaParams(RASCONNCB* prasconncb);

RASCONNCB*   ValidateHrasconn( HRASCONN hrasconn );

RASCONNCB*   ValidateHrasconn2(HRASCONN hrasconn,
                               DWORD dwSubEntry);

RASCONNCB*   ValidatePausedHrasconn(IN HRASCONN hrasconn);

RASCONNCB*   ValidatePausedHrasconnEx(IN HRASCONN hrasconn,
                                      DWORD dwSubEntry);

DWORD        RunApp(LPTSTR lpszApplication,
                    LPTSTR lpszCmdLine);

DWORD        PhonebookEntryToRasEntry(PBENTRY *pEntry,
                                      LPRASENTRY lpRasEntry,
                                      LPDWORD lpdwcb,
                                      LPBYTE lpbDeviceConfig,
                                      LPDWORD lpcbDeviceConfig );

DWORD        RasEntryToPhonebookEntry(LPCTSTR lpszEntry,
                                      LPRASENTRYW lpRasEntry,
                                      DWORD dwcb,
                                      LPBYTE lpbDeviceConfig,
                                      DWORD dwcbDeviceConfig,
                                      PBENTRY *pEntry );

DWORD        PhonebookLinkToRasSubEntry(PBLINK *pLink,
                                        LPRASSUBENTRYW lpRasSubEntry,
                                        LPDWORD lpdwcb,
                                        LPBYTE lpbDeviceConfig,
                                        LPDWORD lpcbDeviceConfig );

DWORD        RasSubEntryToPhonebookLink(PBENTRY *pEntry,
                                        LPRASSUBENTRYW lpRasSubEntry,
                                        DWORD dwcb,
                                        LPBYTE lpbDeviceConfig,
                                        DWORD dwcbDeviceConfig,
                                        PBLINK *pLink );

DWORD        RenamePhonebookEntry(PBFILE *ppbfile,
                                  LPCWSTR lpszOldEntry,
                                  LPCWSTR lpszNewEntry,
                                  DTLNODE *pdtlnode );

DWORD        CopyToAnsi(LPSTR lpszAnsi,
                        LPWSTR lpszUnicode,
                        ULONG ulAnsiMaxSize);

DWORD        CopyToUnicode(LPWSTR lpszUnicode,
                           LPSTR lpszAnsi);

DWORD        SetEntryDialParamsUID(DWORD dwUID,
                                   DWORD dwMask,
                                   LPRASDIALPARAMSW lprasdialparams,
                                   BOOL fDelete);

DWORD        GetEntryDialParamsUID(DWORD dwUID,
                                   LPDWORD lpdwMask,
                                   LPRASDIALPARAMSW lprasdialparams);

DWORD        ConstructPhoneNumber(RASCONNCB *prasconncb);

DWORD        GetAsybeuiLana(HPORT hport,
                            OUT BYTE* pbLana);

DWORD        SubEntryFromConnection(LPHRASCONN lphrasconn);

DWORD        SubEntryPort(HRASCONN hrasconn,
                          DWORD dwSubEntry,
                          HPORT *lphport);

VOID         CloseFailedLinkPorts();

BOOL         GetCallbackNumber(RASCONNCB *prasconncb,
                               PBUSER *ppbuser);

DWORD        SaveProjectionResults(RASCONNCB *prasconncb);

VOID         SetDevicePortName(TCHAR*,
                               TCHAR*,
                               TCHAR*);

VOID         GetDevicePortName(TCHAR*,
                               TCHAR*,
                               TCHAR*);

VOID         ConvertIpxAddressToString(PBYTE,
                                       LPWSTR);

VOID         ConvertIpAddressToString(DWORD,
                                      LPWSTR);

BOOL         InvokeEapUI( HRASCONN            hConn,
                          DWORD               dwSubEntry,
                          LPRASDIALEXTENSIONS lpExtensions,
                          HWND                hWnd);

DWORD        DwEnumEntriesFromPhonebook(
                        LPCWSTR         lpszPhonebookPath,
                        LPBYTE          lprasentryname,
                        LPDWORD         lpcb,
                        LPDWORD         lpcEntries,
                        DWORD           dwSize,
                        DWORD           dwFlags,
                        BOOL            fViewInfo
                        );

DWORD       DwEnumEntriesForPbkMode(
                        DWORD           dwFlags,
                        LPBYTE          lprasentryname,
                        LPDWORD         lpcb,
                        LPDWORD         lpcEntries,
                        DWORD           dwSize,
                        BOOL            fViewInfo
                        );

//
// WOW entry points.
//
DWORD FAR PASCAL RasDialWow(LPSTR lpszPhonebookPath,
                            IN LPRASDIALPARAMSA lpparams,
                            IN HWND hwndNotify,
                            IN DWORD dwRasDialEventMsg,
                            OUT LPHRASCONN lphrasconn );

VOID WINAPI      RasDialFunc1Wow(HRASCONN hrasconn,
                                 UINT unMsg,
                                 RASCONNSTATE rasconnstate,
                                 DWORD dwError,
                                 DWORD dwExtendedError );

DWORD FAR PASCAL RasEnumConnectionsWow(OUT LPRASCONNA lprasconn,
                                       IN OUT LPDWORD lpcb,
                                       OUT LPDWORD lpcConnections);

DWORD FAR PASCAL RasEnumEntriesWow(IN LPSTR reserved,
                                   IN LPSTR lpszPhonebookPath,
                                   OUT LPRASENTRYNAMEA lprasentryname,
                                   IN OUT LPDWORD lpcb,
                                   OUT LPDWORD lpcEntries );

DWORD FAR PASCAL RasGetConnectStatusWow(IN HRASCONN hrasconn,
                        OUT LPRASCONNSTATUSA lprasconnstatus);

DWORD FAR PASCAL RasGetErrorStringWow(IN UINT ResourceId,
                                      OUT LPSTR lpszString,
                                      IN DWORD InBufSize );

DWORD FAR PASCAL RasHangUpWow(IN HRASCONN hrasconn);

DWORD DwCustomHangUp(
            CHAR *lpszPhonebook,
            CHAR *lpszEntryName,
            HRASCONN hRasconn);

DWORD DwCustomDial(LPRASDIALEXTENSIONS lpExtensions,
                   LPCTSTR             lpszPhonebook,
                   CHAR                *pszSystemPbk,
                   LPRASDIALPARAMS     prdp,
                   DWORD               dwNotifierType,
                   LPVOID              pvNotifier,
                   HRASCONN            *phRasConn);


extern DWORD g_dwRasApi32TraceId;

#define RASAPI32_TRACE(a)               TRACE_ID(g_dwRasApi32TraceId, a)
#define RASAPI32_TRACE1(a,b)            TRACE_ID1(g_dwRasApi32TraceId, a,b)
#define RASAPI32_TRACE2(a,b,c)          TRACE_ID2(g_dwRasApi32TraceId, a,b,c)
#define RASAPI32_TRACE3(a,b,c,d)        TRACE_ID3(g_dwRasApi32TraceId, a,b,c,d)
#define RASAPI32_TRACE4(a,b,c,d,e)      TRACE_ID4(g_dwRasApi32TraceId, a,b,c,d,e)
#define RASAPI32_TRACE5(a,b,c,d,e,f)    TRACE_ID5(g_dwRasApi32TraceId, a,b,c,d,e,f)
#define RASAPI32_TRACE6(a,b,c,d,e,f,g)  TRACE_ID6(g_dwRasApi32TraceId, a,b,c,d,e,f,g)


#endif /*_EXTAPI_H_*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\extapi\src\api.c ===
/* Copyright (c) 1992, Microsoft Corporation, all rights reserved
**
** api.c
** Remote Access External APIs
** Non-RasDial API routines
**
** 10/12/92 Steve Cobb
*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <extapi.h>
#include <tapi.h>
#include <raseapif.h>

//
// CCP Option types
//
#define RAS_CCP_OPTION_MSPPC        18

// MSKK NaotoN Appended to support DBCS handling 11/23/93
//
//#ifdef  DBCS
#include <mbstring.h>
//#endif

//
// Version for TAPI APIs.
//
#define TAPIVERSION 0x10004

//
// Eap registry key/value paths
//
#define EAP_REGBASE                 TEXT("System\\CurrentControlSet\\Services\\Rasman\\PPP\\EAP")
#define EAP_REGINVOKE_NAMEDLG       TEXT("InvokeUsernameDialog")
#define EAP_REGIDENTITY_PATH        TEXT("IdentityPath")

//
// RasEapGetIdentity, RasEapFreeMemory in the EAP dll
//
#define EAP_RASEAPGETIDENTITY       "RasEapGetIdentity"
#define EAP_RASEAPFREEMEMORY        "RasEapFreeMemory"
typedef DWORD (APIENTRY * RASEAPGETIDENTITY)(
    DWORD,
    HWND,
    DWORD,
    const WCHAR*,
    const WCHAR*,
    PBYTE,
    DWORD,
    PBYTE,
    DWORD,
    PBYTE*,
    DWORD*,
    WCHAR**
);

typedef DWORD (APIENTRY * RASEAPFREEMEMORY)(
    PBYTE
);

typedef VOID (APIENTRY * SUBENTRY_ENUM_HANDLER)(
    VOID *,
    WCHAR *
);

DWORD
GetRasmanDeviceType(
    IN PBLINK *pLink,
    OUT LPTSTR pszDeviceType
);

//
// AutoDial registry key/value paths.
//
#define AUTODIAL_REGBASE           TEXT("Software\\Microsoft\\RAS AutoDial")
#define AUTODIAL_REGADDRESSBASE    TEXT("Addresses")
#define AUTODIAL_REGNETWORKBASE    TEXT("Networks")
#define AUTODIAL_REGNETWORKID      TEXT("NextId")
#define AUTODIAL_REGENTRYBASE      TEXT("Entries")
#define AUTODIAL_REGCONTROLBASE    TEXT("Control")
#define AUTODIAL_REGDISABLEDBASE   TEXT("Control\\Locations")
#define AUTODIAL_REGDEFAULT        TEXT("Default")

#define AUTODIAL_REGNETWORKVALUE   TEXT("Network")
#define AUTODIAL_REGDEFINTERNETVALUE TEXT("DefaultInternet")
#define AUTODIAL_REGFLAGSVALUE     TEXT("Flags")

//
// Autodial parameter registry keys.
//
#define MaxAutodialParams   5
struct AutodialParamRegKeys
{
    LPTSTR szKey;       // registry key name
    DWORD dwType;       // registry key type
    DWORD dwSize;       // default size
} AutodialParamRegKeys[MaxAutodialParams] =
{
    {TEXT("DisableConnectionQuery"),    REG_DWORD,      sizeof (DWORD)},
    {TEXT("LoginSessionDisable"),       REG_DWORD,      sizeof (DWORD)},
    {TEXT("SavedAddressesLimit"),       REG_DWORD,      sizeof (DWORD)},
    {TEXT("FailedConnectionTimeout"),   REG_DWORD,      sizeof (DWORD)},
    {TEXT("ConnectionQueryTimeout"),    REG_DWORD,      sizeof (DWORD)}
};

DWORD 
DwRenameDefaultConnection(
    LPCWSTR lpszPhonebook,
    LPCWSTR lpszOldEntry,
    LPCWSTR lpszNewEntry);

BOOL
CaseInsensitiveMatch(
    IN LPCWSTR pszStr1,
    IN LPCWSTR pszStr2
    );

DWORD
CallRasEntryDlgW(
    IN     LPCWSTR       pszPhonebook,
    IN     LPCWSTR       pszEntry,
    IN OUT RASENTRYDLGW* pInfo )

/*++

Routine Decriptions:

    Load and call RasEntryDlg with caller's parameters.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0 error code.

--*/

{
    DWORD   dwErr;
    HMODULE h;

    DWORD (*pRasEntryDlgW)(
        IN     LPCWSTR       pszPhonebook,
        IN     LPCWSTR       pszEntry,
        IN OUT RASENTRYDLGW* pInfo );

    h = LoadLibrary( TEXT("RASDLG.DLL") );

    if (!h)
    {
        return GetLastError();
    }

    pRasEntryDlgW = (VOID* )GetProcAddress( h, "RasEntryDlgW" );
    if (pRasEntryDlgW)
    {
        (*pRasEntryDlgW)( pszPhonebook, pszEntry, pInfo );
        dwErr = pInfo->dwError;
    }
    else
    {
        dwErr = GetLastError();
    }

    FreeLibrary( h );
    return dwErr;
}


DWORD APIENTRY
RasCreatePhonebookEntryW(
    IN HWND     hwnd,
    IN LPCWSTR  lpszPhonebook )

/*++

Routine Description:

    Pops up a dialog (owned by window 'hwnd') to create
    a new phonebook entry in phonebook 'lpszPhonebook'.
    'lpszPhonebook' may be NULL to indicate the default
    phonebook should be used.

Arguments:


Return Value:
    Returns 0 if successful, otherwise a non-0 error code.

--*/

{
    RASENTRYDLGW info;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    ZeroMemory( &info, sizeof(info) );
    info.dwSize = sizeof(info);
    info.hwndOwner = hwnd;
    info.dwFlags = RASEDFLAG_NewEntry;

    return CallRasEntryDlgW( lpszPhonebook, NULL, &info );
}


DWORD APIENTRY
RasCreatePhonebookEntryA(
    IN HWND   hwnd,
    IN LPCSTR lpszPhonebook )

/*++

Routine Description:

    Pops up a dialog (owned by window 'hwnd') to create
    a new phonebook entry in phonebook 'lpszPhonebook'.
    'lpszPhonebook' may be NULL to indicate the default
    phonebook should be used.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0 error code.

--*/
{
    NTSTATUS status;
    DWORD dwErr;
    WCHAR szPhonebookW[MAX_PATH];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (lpszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW, lpszPhonebook, MAX_PATH);
    }

    //
    // Call the W version to do the work.
    //
    dwErr = RasCreatePhonebookEntryW(
              hwnd,
              lpszPhonebook != NULL ? szPhonebookW : NULL);

    return dwErr;
}


DWORD APIENTRY
RasEditPhonebookEntryW(
    IN HWND     hwnd,
    IN LPCWSTR  lpszPhonebook,
    IN LPCWSTR  lpszEntryName )

/*++

Routine Description:

    Pops up a dialog (owned by window 'hwnd') to edit
    phonebook entry 'lpszEntryName' from phonebook
    'lpszPhonebook'.  'lpszPhonebook' may be NULL to
    indicate the default phonebook should be used.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0
    error code.

--*/
{
    RASENTRYDLGW info;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Validate parameters.
    //
    if (lpszEntryName == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    ZeroMemory( &info, sizeof(info) );
    info.dwSize = sizeof(info);
    info.hwndOwner = hwnd;

    return CallRasEntryDlgW( lpszPhonebook, lpszEntryName, &info );
}


DWORD APIENTRY
RasEditPhonebookEntryA(
    IN HWND   hwnd,
    IN LPCSTR lpszPhonebook,
    IN LPCSTR lpszEntryName )

/*++

Routine Description:

    Pops up a dialog (owned by window 'hwnd') to edit
    phonebook entry 'lpszEntryName' from phonebook
    'lpszPhonebook'.  'lpszPhonebook' may be NULL to
    indicate the default phonebook should be used.

Arguments:


Return Value:
    Returns 0 if successful, otherwise a non-0
    error code.

--*/
{
    NTSTATUS status;
    DWORD dwErr;
    WCHAR szPhonebookW[MAX_PATH],
          szEntryNameW[RAS_MaxEntryName + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (lpszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    lpszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the lpszEntry to Unicode.
    //
    if (lpszEntryName != NULL)
    {
        strncpyAtoWAnsi(szEntryNameW,
                    lpszEntryName,
                    RAS_MaxEntryName + 1);
    }

    //
    // Call the W version to do the work.
    //
    dwErr = RasEditPhonebookEntryW(
              hwnd,
              lpszPhonebook != NULL ? szPhonebookW : NULL,
              lpszEntryName != NULL ? szEntryNameW : NULL);

    return dwErr;
}


DWORD APIENTRY
RasEnumConnectionsW(
    OUT    LPRASCONNW lprasconn,
    IN OUT LPDWORD    lpcb,
    OUT    LPDWORD    lpcConnections )

/*++

Routine Description:

    Enumerate active RAS connections.  'lprasconn' is
    caller's buffer to receive the array of RASCONN
    structures.  'lpcb' is the size of caller's buffer
    on entry and is set to the number of bytes required
    for all information on exit.  '*lpcConnections' is
    set to the number of elements in the returned array.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0 error code.
--*/

{
    DWORD        dwErr;
    HCONN        *lpconns = NULL, *lpconn;
    DWORD        dwcbConnections, dwcConnections;
    DWORD        i, j;
    DWORD        dwSize, dwInBufSize;
    BOOL         fV351;
    BOOL         fV400;
    BOOL         fV401;
    BOOL         fV500;
    BOOL         fV501;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasEnumConnectionsW");

    // Check parameters.
    //
    if (    !lprasconn
        || (    lprasconn->dwSize != sizeof(RASCONNW)
            &&  lprasconn->dwSize != sizeof(RASCONNW_V500)
            &&  lprasconn->dwSize != sizeof(RASCONNW_V401))
            &&  lprasconn->dwSize != sizeof(RASCONNW_V400)
            &&  lprasconn->dwSize != sizeof(RASCONNW_V351))
    {
        return ERROR_INVALID_SIZE;
    }

    fV351 = (lprasconn->dwSize == sizeof(RASCONNW_V351));
    fV400 = (lprasconn->dwSize == sizeof(RASCONNW_V400));
    fV401 = (lprasconn->dwSize == sizeof(RASCONNW_V401));
    fV500 = (lprasconn->dwSize == sizeof(RASCONNW_V500));
    fV501 = (lprasconn->dwSize == sizeof(RASCONNW));

    if (    lpcb == NULL
        ||  lpcConnections == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Save the byte count passed in for checks later.
    // Initialize the return values.
    //
    dwInBufSize = *lpcb;
    *lpcConnections = 0;
    *lpcb = 0;

    // If rasman is not running, we don't need to do anything.  (No
    // connections to enumerate if rasman is not running.)
    // We only need to check if the service is running if we think it
    // might not be; and it might not be if FRasInitialized is FALSE.
    // If FRasInitialized were TRUE, we know it would be running because
    // it means we started it.
    //
    if (!FRasInitialized && !IsRasmanServiceRunning())
    {
        return 0;
    }

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError != 0)
    {
        return DwRasInitializeError;
    }

    //
    // Get a list of active connection
    // handles from rasman.
    //
    dwErr = g_pRasConnectionEnum(
              NULL,
              NULL,
              &dwcbConnections,
              &dwcConnections);

    if (dwErr != 0)
    {
        return dwErr;
    }

    do
    {
        if(NULL != lpconns)
        {
            Free(lpconns);
            lpconns = NULL;
        }

        if(!dwcConnections)
        {
            return 0;
        }
        
        lpconns = Malloc(dwcbConnections);

        if (lpconns == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        dwErr = g_pRasConnectionEnum(
                  NULL,
                  lpconns,
                  &dwcbConnections,
                  &dwcConnections);

    } while (ERROR_BUFFER_TOO_SMALL == dwErr);

    if (dwErr)
    {
        Free(lpconns);
        return dwErr;
    }

    //
    // Now loop again, filling in caller's buffer.
    //
    dwSize = lprasconn->dwSize;

    for (i = 0, j = 0; i < dwcConnections; i++)
    {
        RASMAN_PORT *lpPorts;
        RASMAN_INFO *pinfo = NULL;
        DWORD dwcbPorts, dwcPorts;

        //
        // Get the ports associated with the
        // connection.
        //
        dwcbPorts = dwcPorts = 0;

        lpPorts = NULL;

        dwErr = g_pRasEnumConnectionPorts(NULL,
                                          lpconns[i],
                                          NULL,
                                          &dwcbPorts,
                                          &dwcPorts);

        if (    dwErr == ERROR_BUFFER_TOO_SMALL
            &&  dwcPorts)
        {
            lpPorts = Malloc(dwcbPorts);
            if (lpPorts == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            dwErr = g_pRasEnumConnectionPorts(NULL,
                                              lpconns[i],
                                              lpPorts,
                                              &dwcbPorts,
                                              &dwcPorts);
            if (dwErr)
            {
                Free(lpPorts);
                break;
            }

            pinfo = Malloc(sizeof(RASMAN_INFO));
            if(NULL == pinfo)
            {
                Free(lpPorts);
                break;
            }

            ZeroMemory(pinfo, sizeof(RASMAN_INFO));
            
            dwErr = g_pRasGetInfo(NULL,
                                  lpPorts->P_Handle,
                                  pinfo);
            if (dwErr)
            {
                Free(lpPorts);
                Free(pinfo);
                break;
            }

            RASAPI32_TRACE1("RasEnumConnectionsW: PhoneEntry=%s",
                   pinfo->RI_PhoneEntry);
        }
        else
        {
            RASAPI32_TRACE1(
              "RasEnumConnectionsW: hrasconn=0x%x: orphaned"
              " connection",
              lpconns[i]);
            continue;
        }

        //
        // Check to see if we are going to overflow the
        // caller's buffer.
        //
        if ((j + 1) * dwSize > dwInBufSize)
        {
            *lpcConnections = dwcConnections;

            *lpcb = *lpcConnections * dwSize;

            dwErr = ERROR_BUFFER_TOO_SMALL;

            if (lpPorts != NULL)
            {
                Free(lpPorts);
            }

            if(pinfo != NULL)
            {
                Free(pinfo);
            }

            break;
        }

        //
        // Fill in caller's buffer entry.
        //
        // Note: Assumption is made here that the V351 and
        //       V400 structures are a subset of the V401
        //       structure.
        //
        lprasconn->hrasconn = (HRASCONN)lpconns[i];
        if (pinfo->RI_PhoneEntry[ 0 ] == '.')
        {
            if (fV351)
            {
                memset(
                  lprasconn->szEntryName,
                  '\0',
                  (RAS_MaxEntryName_V351 + 1) * sizeof (WCHAR));

                strncpyAtoW(
                  lprasconn->szEntryName,
                  pinfo->RI_PhoneEntry,
                  RAS_MaxEntryName_V351);
            }
            else
            {
                //
                // In the V40 structures the phonenumber
                // never needs truncation.
                //
                strncpyAtoW(lprasconn->szEntryName,
                           pinfo->RI_PhoneEntry,
                           sizeof(lprasconn->szEntryName) / sizeof(WCHAR));
            }
        }
        else
        {
            if (fV351)
            {
                memset(
                  lprasconn->szEntryName,
                  '\0',
                  (RAS_MaxEntryName_V351 + 1)
                  * sizeof (WCHAR));

                strncpyAtoW(
                  lprasconn->szEntryName,
                  pinfo->RI_PhoneEntry,
                  RAS_MaxEntryName_V351);
            }
            else
            {
                //
                // In the V40 structures the entry name
                // never needs truncation.
                //
                strncpyAtoW(lprasconn->szEntryName,
                           pinfo->RI_PhoneEntry,
                           sizeof(lprasconn->szEntryName) / sizeof(WCHAR));
            }
        }

        //
        // Set the V401 fields.
        //
        if (    !fV351
            &&  !fV400)
        {
            strncpyAtoW(lprasconn->szPhonebook,
                       pinfo->RI_Phonebook,
                       sizeof(lprasconn->szPhonebook) / sizeof(WCHAR));

            lprasconn->dwSubEntry = pinfo->RI_SubEntry;
        }

        if (!fV351)
        {
            //
            // The attached device name and type are
            // included in the V400+ version of the
            // structure.
            //
            *lprasconn->szDeviceName = L'\0';
            *lprasconn->szDeviceType = L'\0';

            if (lpPorts != NULL)
            {
                RasGetUnicodeDeviceName(lpPorts->P_Handle,
                                        lprasconn->szDeviceName);

                strncpyAtoW(lprasconn->szDeviceType,
                           lpPorts->P_DeviceType,
                           sizeof(lprasconn->szDeviceType) / sizeof(WCHAR));
            }
        }

        //
        // Set V500 fields
        //
        if (!fV351 && !fV400 && !fV401)
        {
            memcpy(&lprasconn->guidEntry,
                   &pinfo->RI_GuidEntry,
                   sizeof(GUID));
        }

        //
        // Set V501 fields
        //
        if(!fV351 && !fV400 && !fV401 && !fV500)
        {
            LUID luid;
            DWORD dwSizeLuid = sizeof(LUID);
            
            (void) g_pRasGetConnectionUserData(
                      (HCONN)lprasconn->hrasconn,
                      CONNECTION_LUID_INDEX,
                      (BYTE *) &lprasconn->luid,
                      &dwSizeLuid);

            //
            //  Zero the flags and then OR on the appropriate
            //  flags.
            //
            lprasconn->dwFlags = 0;

            if(pinfo->RI_dwFlags & RASMAN_DEFAULT_CREDS)
            {
                lprasconn->dwFlags |= RASCF_GlobalCreds;
            }                

            if(IsPublicPhonebook(lprasconn->szPhonebook))
            {
                lprasconn->dwFlags |= RASCF_AllUsers;
            }
        }

        if (fV351)
        {
            lprasconn =
                (RASCONNW* )(((CHAR* )lprasconn)
                + sizeof(RASCONNW_V351));
        }
        else if (fV400)
        {
            lprasconn =
                (RASCONNW* )(((CHAR* )lprasconn)
                + sizeof(RASCONNW_V400));
        }
        else if (fV401)
        {
            lprasconn =
                (RASCONNW*)  (((CHAR* )lprasconn)
                + sizeof(RASCONNW_V401));
        }
        else if (fV500)
        {
            lprasconn =
                (RASCONNW*)  (((CHAR* )lprasconn)
                + sizeof(RASCONNW_V500));
        }
        else
        {
            ++lprasconn;
        }

        //
        // Update the callers byte count and connection
        // count as we go.
        //
        j++;
        *lpcConnections = j;
        *lpcb = *lpcConnections * dwSize;

        //
        // Free the port structure associated with
        // the connection.
        //
        if (lpPorts != NULL)
        {
            Free(lpPorts);
        }

        if(pinfo != NULL)
        {
            Free(pinfo);
        }
    }

    Free(lpconns);
    return dwErr;
}


DWORD APIENTRY
RasEnumConnectionsA(
    OUT    LPRASCONNA lprasconn,
    IN OUT LPDWORD    lpcb,
    OUT    LPDWORD    lpcConnections )
{
    DWORD dwErr;
    DWORD cConnections;
    DWORD cb = 0;
    BOOL fV400;
    BOOL fV401;
    BOOL fV500;
    BOOL fV501;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if (    lpcb == NULL
        ||  lpcConnections == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Verify caller's buffer version.
    //
    if (!lprasconn
        || (    lprasconn->dwSize != sizeof(RASCONNA)
            &&  lprasconn->dwSize != sizeof(RASCONNA_V500)
            &&  lprasconn->dwSize != sizeof(RASCONNA_V401)            
            &&  lprasconn->dwSize != sizeof(RASCONNA_V400)
            &&  lprasconn->dwSize != sizeof(RASCONNA_V351)))
    {
        return ERROR_INVALID_SIZE;
    }

    fV400 = (lprasconn->dwSize == sizeof(RASCONNA_V400));
    fV401 = (lprasconn->dwSize == sizeof(RASCONNA_V401));
    fV500 = (lprasconn->dwSize == sizeof(RASCONNA_V500));
    fV501 = (lprasconn->dwSize == sizeof(RASCONNA));

    if (lprasconn->dwSize == sizeof(RASCONNA_V351))
    {
        RASCONNW_V351* prasconnw = NULL;

        //
        // Allocate Unicode buffer big enough to hold
        // the same number of connections as caller's
        // unicode buffer.
        //
        cb =   (*lpcb / sizeof(RASCONNA_V351))
             * sizeof(RASCONNW_V351);

        prasconnw = (RASCONNW_V351* )
                    Malloc( (UINT )(cb + sizeof(DWORD)) );

        if (!prasconnw)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        prasconnw->dwSize = sizeof(RASCONNW_V351);

        //
        // Call the Unicode version to do all the work.
        //
        if (!lpcConnections)
        {
            lpcConnections = &cConnections;
        }

        dwErr = RasEnumConnectionsW(
                    (RASCONNW* )prasconnw,
                    &cb,
                    lpcConnections
                    );

        //
        // Copy results to caller's Ansi buffer.
        //
        if (dwErr == 0)
        {
            DWORD i;

            for (i = 0; i < *lpcConnections; ++i)
            {
                RASCONNW_V351* prasconnwTmp =
                                    &prasconnw[i];

                RASCONNA_V351* prasconnaTmp =
                            &((RASCONNA_V351*)lprasconn)[i];

                prasconnaTmp->dwSize = sizeof(RASCONNA_V351);
                prasconnaTmp->hrasconn = prasconnwTmp->hrasconn;

                strncpyWtoAAnsi(
                  prasconnaTmp->szEntryName,
                  prasconnwTmp->szEntryName,
                  sizeof(prasconnaTmp->szEntryName));
            }
        }

        if (prasconnw)
        {
            Free( prasconnw );
        }
    }
    else
    {
        RASCONNW* prasconnw = NULL;

        //
        // Allocate Unicode buffer big enough to hold the
        // same number of connections as caller's Ansi buffer.
        //
        if(fV501)
        {
            cb = (*lpcb / sizeof(RASCONNA))
                * sizeof(RASCONNW);
        }
        else if(fV500)
        {
            cb = (*lpcb / sizeof(RASCONNA_V500))
                * sizeof(RASCONNW);
        }
        else if (fV401)
        {
            cb = (*lpcb / sizeof(RASCONNA_V401))
                 * sizeof(RASCONNW);
        }
        else if (fV400)
        {
            cb =   (*lpcb / sizeof(RASCONNA_V400))
                 * sizeof(RASCONNW);
        }

        // !!! for Whistler bug 522283      gangz
        // cb CAN be ZERO.
        // The caller to RasEnumConnectionsA() can pass a ZERO size parameter 
        // just to get back how much byte he needs to allocate, then he will 
        // call the second time to really get back all the entries. I just 
        // comment out the code below to avoid future reoccurance of it.
        
        //
        // .Net bug# 513844 new verbose RASAPI32 prefast warnings
        //
        /*
        if (!cb)
        {
            return ERROR_INVALID_SIZE;
        }
        */

        prasconnw = (RASCONNW* ) Malloc(
                (UINT )(cb + sizeof(DWORD))
                );

        if (!prasconnw)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        prasconnw->dwSize = sizeof(RASCONNW);

        //
        // Call the Unicode version to do all the work.
        //
        if (!lpcConnections)
        {
            lpcConnections = &cConnections;
        }

        dwErr = RasEnumConnectionsW(prasconnw,
                                    &cb,
                                    lpcConnections );

        //
        // Copy results to caller's Ansi buffer.
        //
        if (dwErr == 0)
        {
            DWORD i;

            for (i = 0; i < *lpcConnections; ++i)
            {
                RASCONNW* prasconnwTmp = &prasconnw[ i ];

                if (fV501)
                {
                    RASCONNA *prasconnaTmp = &lprasconn[i];
                    
                    prasconnaTmp->dwSize = sizeof(RASCONNA);

                    prasconnaTmp->hrasconn =
                            prasconnwTmp->hrasconn;

                    strncpyWtoAAnsi(
                      prasconnaTmp->szEntryName,
                      prasconnwTmp->szEntryName,
                      sizeof(prasconnaTmp->szEntryName));

                    strncpyWtoAAnsi(
                      prasconnaTmp->szDeviceType,
                      prasconnwTmp->szDeviceType,
                      sizeof(prasconnaTmp->szDeviceType));

                    strncpyWtoAAnsi(
                      prasconnaTmp->szDeviceName,
                      prasconnwTmp->szDeviceName,
                      sizeof(prasconnaTmp->szDeviceName));

                    strncpyWtoAAnsi(
                      prasconnaTmp->szPhonebook,
                      prasconnwTmp->szPhonebook,
                      sizeof(prasconnaTmp->szPhonebook));

                    prasconnaTmp->dwSubEntry =
                            prasconnwTmp->dwSubEntry;

                    memcpy(&prasconnaTmp->guidEntry,
                           &prasconnwTmp->guidEntry,
                           sizeof(GUID));

                    prasconnaTmp->dwFlags = prasconnwTmp->dwFlags;
                    CopyMemory(&prasconnaTmp->luid, &prasconnwTmp->luid,
                                sizeof(LUID));

                }
                else if (fV500)
                {
                    RASCONNA_V500* prasconnaTmp = &((RASCONNA_V500 *)
                                                        lprasconn)[i];

                    prasconnaTmp->dwSize = sizeof(RASCONNA_V500);

                    prasconnaTmp->hrasconn =
                            prasconnwTmp->hrasconn;

                    strncpyWtoAAnsi(
                      prasconnaTmp->szEntryName,
                      prasconnwTmp->szEntryName,
                      sizeof(prasconnaTmp->szEntryName));

                    strncpyWtoAAnsi(
                      prasconnaTmp->szDeviceType,
                      prasconnwTmp->szDeviceType,
                      sizeof(prasconnaTmp->szDeviceType));

                    strncpyWtoAAnsi(
                      prasconnaTmp->szDeviceName,
                      prasconnwTmp->szDeviceName,
                      sizeof(prasconnaTmp->szDeviceName));

                    strncpyWtoAAnsi(
                      prasconnaTmp->szPhonebook,
                      prasconnwTmp->szPhonebook,
                      sizeof(prasconnaTmp->szPhonebook));

                    prasconnaTmp->dwSubEntry =
                            prasconnwTmp->dwSubEntry;

                    memcpy(&prasconnaTmp->guidEntry,
                           &prasconnwTmp->guidEntry,
                           sizeof(GUID));
                }

                else if (fV401)
                {
                    RASCONNA_V401 *prasconnaTmp = &((RASCONNA_V401 *)
                                                    lprasconn)[i];

                    prasconnaTmp->dwSize = sizeof(RASCONNA_V401);

                    prasconnaTmp->hrasconn =
                            prasconnwTmp->hrasconn;

                    strncpyWtoAAnsi(
                      prasconnaTmp->szEntryName,
                      prasconnwTmp->szEntryName,
                      sizeof(prasconnaTmp->szEntryName));

                    strncpyWtoAAnsi(
                      prasconnaTmp->szDeviceType,
                      prasconnwTmp->szDeviceType,
                      sizeof(prasconnaTmp->szDeviceType));

                    strncpyWtoAAnsi(
                      prasconnaTmp->szDeviceName,
                      prasconnwTmp->szDeviceName,
                      sizeof(prasconnaTmp->szDeviceName));

                    strncpyWtoAAnsi(
                      prasconnaTmp->szPhonebook,
                      prasconnwTmp->szPhonebook,
                      sizeof(prasconnaTmp->szPhonebook));

                    prasconnaTmp->dwSubEntry =
                            prasconnwTmp->dwSubEntry;

                }
                else
                {
                    RASCONNA_V400* prasconnaTmp =
                            &((RASCONNA_V400* )lprasconn)[i];

                    prasconnaTmp->dwSize = sizeof(RASCONNA_V400);

                    prasconnaTmp->hrasconn = prasconnwTmp->hrasconn;

                    strncpyWtoAAnsi(
                      prasconnaTmp->szEntryName,
                      prasconnwTmp->szEntryName,
                      sizeof(prasconnaTmp->szEntryName));

                    strncpyWtoAAnsi(
                      prasconnaTmp->szDeviceType,
                      prasconnwTmp->szDeviceType,
                      sizeof(prasconnaTmp->szDeviceType));

                    strncpyWtoAAnsi(
                      prasconnaTmp->szDeviceName,
                      prasconnwTmp->szDeviceName,
                      sizeof(prasconnaTmp->szDeviceName));
                }
            }
        }

        if (prasconnw)
        {
            Free( prasconnw );
        }
    }

    //
    // In all cases, *lpcb should be updated
    // with the correct size.
    //
    *lpcb = *lpcConnections * lprasconn->dwSize;

    return dwErr;
}


DWORD APIENTRY
RasEnumEntriesW(
    IN     LPCWSTR         reserved,
    IN     LPCWSTR         lpszPhonebookPath,
    OUT    LPRASENTRYNAMEW lprasentryname,
    IN OUT LPDWORD         lpcb,
    OUT    LPDWORD         lpcEntries )

/*++

Routine Description:

    Enumerates all entries in the phone book.  'reserved'
    will eventually contain the name or path to the address
    book.  For now, it should always be NULL.  'lpszPhonebookPath'
    is the full path to the phone book file, or NULL, indicating
    that the default phonebook on the local machine should be
    used.  'lprasentryname' is caller's buffer to receive the
    array of RASENTRYNAME structures.  'lpcb' is the size in
    bytes of caller's buffer on entry and the size in bytes
    required for all information on exit.  '*lpcEntries'
    is set to the number of elements in the returned array.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0 error code.

--*/

{
    DWORD    dwErr = ERROR_SUCCESS;
    PBFILE   pbfile;
    DTLNODE  *dtlnode;
    PBENTRY  *pEntry;
    DWORD    dwInBufSize;
    BOOL     fV351;
    BOOL     fStatus;
    DWORD    cEntries;
    DWORD    dwSize;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasEnumEntriesW");

    if (reserved)
    {
        return ERROR_NOT_SUPPORTED;
    }

    if (!lpcb)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    !lprasentryname
        || (    lprasentryname->dwSize
                != sizeof(RASENTRYNAMEW)
            &&  lprasentryname->dwSize
                != sizeof(RASENTRYNAMEW_V401)
            &&  lprasentryname->dwSize
                != sizeof(RASENTRYNAMEW_V351)))
    {
        return ERROR_INVALID_SIZE;
    }

    if (!lpcEntries)
    {
        lpcEntries = &cEntries;
    }

    dwSize = lprasentryname->dwSize;

    if(lpszPhonebookPath)
    {
        dwErr = DwEnumEntriesFromPhonebook(
                                lpszPhonebookPath,
                                (LPBYTE) lprasentryname,
                                lpcb,
                                lpcEntries,
                                dwSize,
                                (IsPublicPhonebook(
                                    (LPTSTR) lpszPhonebookPath))
                                ? REN_AllUsers
                                : REN_User,
                                FALSE);
        goto done;
    }
    else
    {
        LPRASENTRYNAMEW lpRenName = lprasentryname;
        DWORD dwcb = *lpcb;
        DWORD dwcEntries;
        DWORD dwcbLeft = *lpcb;

        DWORD dwErrSav = SUCCESS;

        *lpcb = 0;
        *lpcEntries = 0;

        //
        // Enumerate entries from all pbk files in
        // All Users
        //
        dwErr = DwEnumEntriesForPbkMode(REN_AllUsers,
                                        (LPBYTE) lprasentryname,
                                        &dwcb,
                                        &dwcEntries,
                                        dwSize,
                                        FALSE);

        if(     dwErr
            &&  ERROR_BUFFER_TOO_SMALL != dwErr)
        {
            goto done;
        }

        if(ERROR_BUFFER_TOO_SMALL == dwErr)
        {
            dwErrSav = dwErr;
            dwcbLeft = 0;
        }
        else
        {
            (BYTE*)lprasentryname += (dwcEntries * dwSize);
            dwcbLeft -= ((dwcbLeft >= dwcb) ? dwcb : 0);
        }

        *lpcb += dwcb;
        dwcb = dwcbLeft;

        if(lpcEntries)
        {
            *lpcEntries = dwcEntries;
        }

        dwcEntries = 0;

        //
        // Enumerate entries from all pbk files in
        // users profile
        //
        dwErr = DwEnumEntriesForPbkMode(REN_User,
                                        (LPBYTE) lprasentryname,
                                        &dwcb,
                                        &dwcEntries,
                                        dwSize,
                                        FALSE);
        if(     dwErr
            &&  ERROR_BUFFER_TOO_SMALL != dwErr)
        {
            goto done;
        }
        else if (SUCCESS == dwErr)
        {
            dwErr = dwErrSav;
        }

        *lpcb += dwcb;

        if(lpcEntries)
        {
            *lpcEntries += dwcEntries;
        }
    }

done:
    return dwErr;
}


DWORD APIENTRY
RasEnumEntriesA(
    IN     LPCSTR         reserved,
    IN     LPCSTR         lpszPhonebookPath,
    OUT    LPRASENTRYNAMEA lprasentryname,
    IN OUT LPDWORD        lpcb,
    OUT    LPDWORD        lpcEntries )
{
    DWORD          dwErr;
    WCHAR          szPhonebookW[MAX_PATH];
    NTSTATUS       ntstatus;
    DWORD          cEntries = 0;
    DWORD          cb;

    UNREFERENCED_PARAMETER(reserved);

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify caller's buffer version.
    //
    if (    !lprasentryname
        || (    lprasentryname->dwSize
                != sizeof(RASENTRYNAMEA)
            &&  lprasentryname->dwSize
                != sizeof(RASENTRYNAMEA_V401)
            &&  lprasentryname->dwSize
                != sizeof(RASENTRYNAMEA_V351)))
    {
        return ERROR_INVALID_SIZE;
    }

    if (reserved)
    {
        return ERROR_NOT_SUPPORTED;
    }

    if (!lpcb)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (!lpcEntries)
    {
        lpcEntries = &cEntries;
    }

    //
    // Make Unicode version of caller's string argument.
    //
    if (lpszPhonebookPath != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    lpszPhonebookPath,
                    MAX_PATH);
    }

    if (lprasentryname->dwSize == sizeof(RASENTRYNAMEA_V351))
    {
        RASENTRYNAMEW_V351* prasentrynamew = NULL;

        //
        // Allocate Unicode buffer big enough to hold the
        // same number of entries as caller's Ansi buffer.
        //
        cb =  (*lpcb  / sizeof(RASENTRYNAMEA_V351))
            * sizeof(RASENTRYNAMEW_V351);

        prasentrynamew =
            (RASENTRYNAMEW_V351* )Malloc(
                            (UINT )(cb + sizeof(DWORD))
                            );

        if (!prasentrynamew)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        prasentrynamew->dwSize = sizeof(RASENTRYNAMEW_V351);

        //
        // Call the Unicode version to do all the work.
        //
        dwErr = RasEnumEntriesW(
            NULL,
            lpszPhonebookPath != NULL ? szPhonebookW : NULL,
            (RASENTRYNAMEW* )prasentrynamew, &cb, lpcEntries );

        //
        // Copy results to caller's unicode buffer.
        //
        if (dwErr == 0)
        {
            DWORD i;

            for (i = 0; i < *lpcEntries; ++i)
            {
                RASENTRYNAMEW_V351* prasentrynamewTmp =
                                        &prasentrynamew[i];

                RASENTRYNAMEA_V351* prasentrynameaTmp =
                    &((RASENTRYNAMEA_V351* )lprasentryname)[i];

                prasentrynameaTmp->dwSize =
                                sizeof(RASENTRYNAMEA_V351);

                strncpyWtoAAnsi(
                  prasentrynameaTmp->szEntryName,
                  prasentrynamewTmp->szEntryName,
                  sizeof(prasentrynameaTmp->szEntryName));
            }
        }

        if (prasentrynamew)
        {
            Free( prasentrynamew );
        }
    }
    else
    {
        RASENTRYNAMEW* prasentrynamew = NULL;

        //
        // Allocate Unicode buffer big enough to hold the
        // same number of entries as caller's Ansi buffer.
        //
        if(lprasentryname->dwSize == sizeof(RASENTRYNAMEA))
        {
            cb =  (*lpcb  / sizeof(RASENTRYNAMEA))
                * sizeof(RASENTRYNAMEW);
        }
        else
        {
            cb =  (*lpcb / sizeof(RASENTRYNAMEA_V401))
                * sizeof(RASENTRYNAMEW_V401);
        }

        prasentrynamew =
            (RASENTRYNAMEW* )Malloc(
                        (UINT )(cb + sizeof(DWORD))
                        );

        if (!prasentrynamew)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if(lprasentryname->dwSize == sizeof(RASENTRYNAMEA))
        {
            prasentrynamew->dwSize = sizeof(RASENTRYNAMEW);
        }
        else
        {
            prasentrynamew->dwSize =
                            sizeof(RASENTRYNAMEW_V401);
        }

        //
        // Call the Unicode version to do all the work.
        //
        dwErr = RasEnumEntriesW(
            NULL,
            lpszPhonebookPath != NULL ? szPhonebookW : NULL,
            prasentrynamew, &cb, lpcEntries );

        //
        // Copy results to caller's Ansi buffer.
        //
        if (dwErr == 0)
        {
            DWORD i;
            DWORD dwSize = lprasentryname->dwSize;
            LPBYTE lpBufA = (LPBYTE) lprasentryname;
            LPBYTE lpBufW = (LPBYTE) prasentrynamew;

            for (i = 0; i < *lpcEntries; ++i)
            {
                if(sizeof(RASENTRYNAMEA_V401) == dwSize)
                {
                    ((RASENTRYNAMEA_V401 *) lpBufA)->dwSize =
                                      sizeof(RASENTRYNAMEA_V401);

                    strncpyWtoAAnsi(
                      ((RASENTRYNAMEA_V401 *)lpBufA)->szEntryName,
                      ((RASENTRYNAMEW_V401 *)lpBufW)->szEntryName,
                      sizeof(((RASENTRYNAMEA_V401 *)lpBufA)->szEntryName));

                      lpBufA += sizeof(RASENTRYNAMEA_V401);
                      lpBufW += sizeof(RASENTRYNAMEW_V401);
                }
                else
                {
                    ((RASENTRYNAMEA *) lpBufA)->dwSize =
                                      sizeof(RASENTRYNAMEA);

                    strncpyWtoAAnsi(
                      ((RASENTRYNAMEA *)lpBufA)->szEntryName,
                      ((RASENTRYNAMEW *)lpBufW)->szEntryName,
                      sizeof(((RASENTRYNAMEA *)lpBufA)->szEntryName));

                    //
                    // if this is nt5 copy the phonebook name
                    // and the flags
                    //
                    strncpyWtoAAnsi(
                        ((RASENTRYNAMEA *)lpBufA)->szPhonebookPath,
                        ((RASENTRYNAMEW *)lpBufW)->szPhonebookPath,
                        sizeof(((RASENTRYNAMEA *)lpBufA)->szPhonebookPath));

                    ((RASENTRYNAMEA *)lpBufA)->dwFlags
                            = ((RASENTRYNAMEW *)lpBufW)->dwFlags;

                    lpBufA += sizeof(RASENTRYNAMEA);
                    lpBufW += sizeof(RASENTRYNAMEW);

                }
            }
        }

        if (prasentrynamew)
        {
            Free( prasentrynamew );
        }
    }

    //
    // In all cases, *lpcb should be updated
    // with the correct size.
    //
    *lpcb = *lpcEntries * lprasentryname->dwSize;

    return dwErr;
}


DWORD APIENTRY
RasGetConnectStatusW(
    IN  HRASCONN         hrasconn,
    OUT LPRASCONNSTATUSW lprasconnstatus )

/*++

Routine Description:

    Reports the current status of the connection
    associated with handle 'hrasconn', returning
    the information in caller's 'lprasconnstatus'
    buffer.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0
    error code.

--*/
{
    DWORD       dwErr, dwSize;
    DWORD       i, dwcbPorts = 0, dwcPorts = 0;
    RASMAN_PORT *lpPorts;
    RASMAN_INFO info;
    RASCONNCB   *prasconncb;
    HPORT       hport;
    BOOL        fV351;
    BOOL        fV400;
    BOOL        fFound;
    WCHAR        szDeviceType[RAS_MaxDeviceType + 1];
    WCHAR        szDeviceName[RAS_MaxDeviceName + 1];
    DWORD       dwSubEntry;
    BOOL        fPort;
    TCHAR*      pszDeviceType = NULL;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetConnectStatusW");

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError != 0)
    {
        return DwRasInitializeError;
    }

    if (    !lprasconnstatus
        || (    lprasconnstatus->dwSize
                != sizeof(RASCONNSTATUSW)
            &&  lprasconnstatus->dwSize
                != sizeof(RASCONNSTATUSW_V351)
            &&  lprasconnstatus->dwSize
                != sizeof(RASCONNSTATUSW_V400)))
    {
        return ERROR_INVALID_SIZE;
    }
    if (hrasconn == 0)
    {
        return ERROR_INVALID_HANDLE;
    }

    fV351 = (lprasconnstatus->dwSize ==
            sizeof(RASCONNSTATUSW_V351));

    fV400 = (lprasconnstatus->dwSize ==
             sizeof(RASCONNSTATUSW_V400));

    //
    // Get the subentry index encoded in the
    // connection handle, if any.
    //
    // If fPort is TRUE, then we always return
    // 0, setting a RASCS_Disconnected state
    // upon error.
    //
    fPort = IS_HPORT(hrasconn);

    dwSubEntry = SubEntryFromConnection(&hrasconn);

    if (!dwSubEntry)
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Get the list of ports in this
    // connection from rasman.
    //
    dwErr = g_pRasEnumConnectionPorts(
              NULL,
              (HCONN)hrasconn,
              NULL,
              &dwcbPorts,
              &dwcPorts);

    if (    dwErr != ERROR_BUFFER_TOO_SMALL
        ||  !dwcPorts)
    {
        if (fPort)
        {
            goto discon;
        }

        return ERROR_INVALID_HANDLE;
    }

    lpPorts = Malloc(dwcbPorts);

    if (lpPorts == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = g_pRasEnumConnectionPorts(
              NULL,
              (HCONN)hrasconn,
              lpPorts,
              &dwcbPorts,
              &dwcPorts);

    if (dwErr)
    {
        Free(lpPorts);

        if (fPort)
        {
            goto discon;
        }

        return ERROR_INVALID_HANDLE;
    }

    //
    // Get the device type and name
    // associated with the subentry.
    //
    fFound = FALSE;
    for (i = 0; i < dwcPorts; i++)
    {
        dwErr = g_pRasGetInfo(NULL,
                              lpPorts[i].P_Handle,
                              &info);

        if (dwErr || info.RI_SubEntry != dwSubEntry)
        {
            continue;
        }

        fFound = TRUE;

        hport = lpPorts[i].P_Handle;

        pszDeviceType = pszDeviceTypeFromRdt(lpPorts->P_rdtDeviceType);

        if(NULL == pszDeviceType)
        {
            //
            // default to modem
            //
            lstrcpyn(
                szDeviceType,
                TEXT("modem"),
                sizeof(szDeviceType) / sizeof(WCHAR));
        }
        else
        {
            lstrcpyn(
                szDeviceType,
                pszDeviceType,
                sizeof(szDeviceType) / sizeof(WCHAR));

            Free(pszDeviceType);
        }

        RasGetUnicodeDeviceName(lpPorts[i].P_Handle, szDeviceName);

        break;
    }
    Free(lpPorts);

    //
    // If the port is not found in the connection,
    // then it must be disconnected.
    //
    if (!fFound)
    {
discon:
        RASAPI32_TRACE("RasGetConnectStatus: subentry not found");
        lprasconnstatus->rasconnstate = RASCS_Disconnected;
        lprasconnstatus->dwError = 0;
        return 0;
    }

    //
    // Get the connection state and error
    // associated with the subentry.
    //
    dwSize = sizeof (lprasconnstatus->rasconnstate);
    dwErr = g_pRasGetPortUserData(
              hport,
              PORT_CONNSTATE_INDEX,
              (PBYTE)&lprasconnstatus->rasconnstate,
              &dwSize);

    if (dwErr)
    {
        return dwErr;
    }

    //
    // If the port is disconnected, then we have
    // to determine whether the connection is
    // waiting for callback.
    //
    if (    info.RI_ConnState == DISCONNECTED

        &&  lprasconnstatus->rasconnstate
            < RASCS_PrepareForCallback

        &&  lprasconnstatus->rasconnstate
            > RASCS_WaitForCallback)
    {
        lprasconnstatus->rasconnstate = RASCS_Disconnected;
    }

    dwSize = sizeof (lprasconnstatus->dwError);
    dwErr = g_pRasGetPortUserData(
              hport,
              PORT_CONNERROR_INDEX,
              (PBYTE)&lprasconnstatus->dwError,
              &dwSize);

    if (dwErr)
    {
        return dwErr;
    }

    //
    // Report RasDial connection states, but notice special
    // case where the line has disconnected since connecting.
    //
    // Note: Assumption is made here that the V351 structure
    // is a subset of the V40 structure with extra bytes
    // added to the last field in V40, i.e. szDeviceName.
    //
    if (    lprasconnstatus->rasconnstate == RASCS_Connected
        &&  info.RI_ConnState == DISCONNECTED)
    {
        lprasconnstatus->rasconnstate = RASCS_Disconnected;

        lprasconnstatus->dwError =
            ErrorFromDisconnectReason( info.RI_DisconnectReason );
    }

    //
    // If both the info.RI_Device*Connecting values are
    // valid, then we use those, otherwise we use the
    // info.P_Device* values we retrieved above.
    //
    if (lprasconnstatus->rasconnstate < RASCS_Connected)
    {
        DWORD dwTypeSize, dwNameSize;

        dwTypeSize = sizeof (szDeviceType);
        dwNameSize = sizeof (szDeviceName);
        szDeviceType[0] = szDeviceName[0] = L'\0';

        if (    !g_pRasGetPortUserData(
                    hport,
                    PORT_DEVICETYPE_INDEX,
                    (PCHAR)szDeviceType,
                    &dwTypeSize)
            &&
                !g_pRasGetPortUserData(
                    hport,
                    PORT_DEVICENAME_INDEX,
                    (PCHAR)szDeviceName,
                    &dwNameSize)

            &&    wcslen(szDeviceType)
            &&    wcslen(szDeviceName))
        {
            RASAPI32_TRACE2(
              "RasGetConnectStatus: read device (%S,%S) "
              "from port user data",
              szDeviceType,
              szDeviceName);
        }
    }

    //
    // For pptp connections, there are no intermediate
    // device types
    //
    else if (   strlen(info.RI_DeviceConnecting)

            &&  strlen(info.RI_DeviceTypeConnecting)

            &&  (RDT_X25 == RAS_DEVICE_CLASS(info.RI_rdtDeviceType)))
    {
        strncpyAtoW(szDeviceType,
                   info.RI_DeviceTypeConnecting,
                   sizeof(szDeviceType) / sizeof(WCHAR));

        strncpyAtoW(szDeviceName,
                   info.RI_DeviceConnecting,
                   sizeof(szDeviceName) / sizeof(WCHAR));
    }

    //
    // Don't overwrite the devicename if its a switch.
    // In the case of a switch the devicename is actually
    // the name of script file.
    //
    if(CaseInsensitiveMatch(szDeviceType, L"switch") == FALSE)
    {
        RasGetUnicodeDeviceName(hport, szDeviceName);
    }

    if (fV351)
    {
        memset(
          lprasconnstatus->szDeviceName,
          '\0',
          RAS_MaxDeviceName_V351 * sizeof (WCHAR) );

        wcsncpy(
          lprasconnstatus->szDeviceName,
          szDeviceName,
          RAS_MaxDeviceName_V351);
    }
    else
    {
        lstrcpyn(lprasconnstatus->szDeviceName,
                 szDeviceName,
                 sizeof(lprasconnstatus->szDeviceName) / sizeof(WCHAR));
    }

    lstrcpyn(lprasconnstatus->szDeviceType,
             szDeviceType,
             sizeof(lprasconnstatus->szDeviceType) / sizeof(WCHAR));

    //
    // Copy the phone number for the V401
    // version of the structure.
    //
    if (    !fV351
        &&  !fV400)
    {
        dwSize = sizeof (lprasconnstatus->szPhoneNumber);

        *lprasconnstatus->szPhoneNumber = L'\0';

        if (!g_pRasGetPortUserData(
              hport,
              PORT_PHONENUMBER_INDEX,
              (PCHAR)lprasconnstatus->szPhoneNumber,
              &dwSize))
        {
            RASAPI32_TRACE1(
              "RasGetConnectStatus: read phonenumber "
              "%S from port user data",
              lprasconnstatus->szPhoneNumber);
        }
    }

    return 0;
}


DWORD APIENTRY
RasGetConnectStatusA(
    IN  HRASCONN         hrasconn,
    OUT LPRASCONNSTATUSA lprcss )
{
    RASCONNSTATUSW rcsw;
    DWORD          dwErr;
    BOOL           fV351;
    BOOL           fV400;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify caller's buffer version.
    //
    if (    !lprcss
        ||  (   lprcss->dwSize != sizeof(RASCONNSTATUSA)
            &&  lprcss->dwSize != sizeof(RASCONNSTATUSA_V351)
            &&  lprcss->dwSize != sizeof(RASCONNSTATUSA_V400)))
    {
        return ERROR_INVALID_SIZE;
    }

    fV351 = (lprcss->dwSize == sizeof(RASCONNSTATUSA_V351));
    fV400 = (lprcss->dwSize == sizeof(RASCONNSTATUSA_V400));

    ZeroMemory(&rcsw, sizeof(RASCONNSTATUSW));

    rcsw.dwSize = sizeof(RASCONNSTATUSW);

    //
    // Call the ANSI version to do all the work.
    //
    dwErr = RasGetConnectStatusW( hrasconn, &rcsw );

    if (dwErr != 0)
    {
        return dwErr;
    }

    //
    // Copy results to caller's unicode buffer.
    //
    lprcss->rasconnstate = rcsw.rasconnstate;
    lprcss->dwError = rcsw.dwError;

    strncpyWtoA(
        lprcss->szDeviceType,
        rcsw.szDeviceType,
        sizeof(lprcss->szDeviceType));

    if (fV351)
    {
        RASCONNSTATUSA_V351 *prcss = (RASCONNSTATUSA_V351 *)lprcss;

        strncpyWtoAAnsi(
            prcss->szDeviceName,
            rcsw.szDeviceName,
            sizeof(prcss->szDeviceName));
    }
    else
    {
        strncpyWtoAAnsi(
            lprcss->szDeviceName,
            rcsw.szDeviceName,
            sizeof(lprcss->szDeviceName));
    }

    if (dwErr)
    {
        return dwErr;
    }

    if (    !fV351
        &&  !fV400)
    {
        strncpyWtoAAnsi(
            lprcss->szPhoneNumber,
            rcsw.szPhoneNumber,
            sizeof(lprcss->szPhoneNumber));
    }

    return 0;
}


DWORD APIENTRY
RasGetEntryHrasconnW(
    IN  LPCWSTR             pszPhonebook,
    IN  LPCWSTR             pszEntry,
    OUT LPHRASCONN          lphrasconn )

/*++

Routine Description:

    Retrieves the current 'HRASCONN' of the connection
    identified by 'pszPhonebook' and 'pszEntry', if connected.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0
    error code.

--*/

{
    DWORD dwErr;
    HRASCONN hrasconn;
    CHAR szPhonebookA[MAX_PATH],
         szEntryNameA[RAS_MaxEntryName + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetEntryHrasconn");

    //
    // Verify parameters
    //
    if (!pszEntry || !lphrasconn)
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError != 0)
    {
        return DwRasInitializeError;
    }

    //
    // Convert the pszPhonebook string to ANSI.
    //
    if (pszPhonebook)
    {
        strncpyWtoA(szPhonebookA, pszPhonebook, MAX_PATH);
    }
    else
    {
        TCHAR* pszPath;

        if (!GetDefaultPhonebookPath(0, &pszPath))
        {
            return ERROR_CANNOT_OPEN_PHONEBOOK;
        }

        strncpyTtoA(szPhonebookA, pszPath, MAX_PATH);
        Free(pszPath);
    }

    //
    // Convert the lpszEntry string to ANSI.
    //
    strncpyWtoA(szEntryNameA, pszEntry, RAS_MaxEntryName + 1);

    //
    // Map the phonebook entry to an hrasconn, if possible.
    //
    dwErr = g_pRasGetHConnFromEntry(
                (HCONN*)lphrasconn,
                szPhonebookA,
                szEntryNameA
                );
    return dwErr;
}


DWORD APIENTRY
RasGetEntryHrasconnA(
    IN  LPCSTR              pszPhonebook,
    IN  LPCSTR              pszEntry,
    OUT LPHRASCONN          lphrasconn )

/*++

Routine Description:

    Retrieves the current 'HRASCONN' of the connection
    identified by 'pszPhonebook' and 'pszEntry', if connected.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0
    error code.

--*/

{
    DWORD dwErr;
    HRASCONN hrasconn;
    CHAR szPhonebookA[MAX_PATH + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetEntryConnectStatusA");

    //
    // Verify parameters
    //
    if (!pszEntry || !lphrasconn)
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError != 0)
    {
        return DwRasInitializeError;
    }

    //
    // Construct the phonebook path, if necessary
    //
    if (pszPhonebook)
    {
        strncpy(szPhonebookA, pszPhonebook, MAX_PATH);
    }
    else
    {
        TCHAR* pszPath;

        if (!GetDefaultPhonebookPath(0, &pszPath))
        {
            return ERROR_CANNOT_OPEN_PHONEBOOK;
        }

        strncpyTtoA(szPhonebookA, pszPath, MAX_PATH);
        Free(pszPath);
    }

    //
    // Map the phonebook entry to an hrasconn, if possible.
    //
    dwErr = g_pRasGetHConnFromEntry(
                (HCONN*)lphrasconn,
                szPhonebookA,
                (CHAR*)pszEntry
                );
    return dwErr;
}


VOID APIENTRY
RasGetConnectResponse(
    IN  HRASCONN hrasconn,
    OUT CHAR*    pszConnectResponse )

/*++

Routine Description:

    Loads caller's '*pszConnectResponse' buffer with the
    connect response from the attached modem or "" if
    none is available.  Caller's buffer should be at
    least RAS_MaxConnectResponse + 1 bytes long.

Arguments:

Return Value:

--*/
{
    DWORD dwErr,
          dwcbPorts = 0,
          dwcPorts = 0,
          dwSize;

    RASMAN_PORT *lpPorts;
    HPORT hport;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetConnectResponseA");

    //
    // Initialize return value.
    //
    *pszConnectResponse = '\0';

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return;
    }

    if (DwRasInitializeError != 0)
    {
        return;
    }

    //
    // First, we need to get the first port
    // in the connection.
    //
    if (IS_HPORT(hrasconn))
    {
        hport = HRASCONN_TO_HPORT(hrasconn);
    }
    else
    {
        dwErr = g_pRasEnumConnectionPorts(
                                NULL,
                                (HCONN)hrasconn,
                                NULL,
                                &dwcbPorts,
                                &dwcPorts);

        if (    dwErr != ERROR_BUFFER_TOO_SMALL
            ||  !dwcPorts)
        {
            return;
        }

        lpPorts = Malloc(dwcbPorts);
        if (lpPorts == NULL)
        {
            return;
        }

        dwErr = g_pRasEnumConnectionPorts(
                                NULL,
                                (HCONN)hrasconn,
                                lpPorts,
                                &dwcbPorts,
                                &dwcPorts);

        if (    dwErr
            ||  !dwcPorts)
        {
            Free(lpPorts);
            return;
        }

        hport = lpPorts[0].P_Handle;
        Free(lpPorts);
    }

    //
    // Next, read the connection response for the port.
    //
    dwSize = RAS_MaxConnectResponse + 1;

    dwErr = g_pRasGetPortUserData(
              hport,
              PORT_CONNRESPONSE_INDEX,
              pszConnectResponse,
              &dwSize);

    if (dwErr)
    {
        *pszConnectResponse = '\0';
    }
}


//Real password won't be returned, only a handle will be returned.
DWORD APIENTRY
RasGetEntryDialParamsA(
    IN  LPCSTR           lpszPhonebook,
    OUT LPRASDIALPARAMSA lprasdialparams,
    OUT LPBOOL           lpfPassword )

/*++

Routine Description:
    Retrieves cached RASDIALPARAM information.

Arguments:

Return Value:
    Returns 0 if successful, otherwise a non-0 error code.

--*/
{
    NTSTATUS status;
    DWORD dwErr, dwcb;
    RASDIALPARAMSW rasdialparamsW;
    WCHAR szPhonebookW[MAX_PATH];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify parameters.
    //
    if (    lprasdialparams == NULL
        ||  lpfPassword == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    lprasdialparams->dwSize != sizeof (RASDIALPARAMSA)
        &&  lprasdialparams->dwSize != sizeof (RASDIALPARAMSA_V351)
        &&  lprasdialparams->dwSize != sizeof (RASDIALPARAMSA_V400))
    {
        return ERROR_INVALID_SIZE;
    }

    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (lpszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    lpszPhonebook,
                    MAX_PATH);
    }

    //
    // Copy the entry name from the user's A buffer into
    // the W buffer, taking into account the version
    // of the structure the user passed in.
    //
    rasdialparamsW.dwSize = sizeof (RASDIALPARAMSW);

    if (lprasdialparams->dwSize ==
                        sizeof (RASDIALPARAMSA_V351))
    {
        RASDIALPARAMSA_V351 *prdp =
                (RASDIALPARAMSA_V351 *)lprasdialparams;

        strncpyAtoWAnsi(rasdialparamsW.szEntryName,
                   prdp->szEntryName,
                   sizeof(rasdialparamsW.szEntryName) / sizeof(WCHAR));
    }
    else
    {
        strncpyAtoWAnsi(rasdialparamsW.szEntryName,
                   lprasdialparams->szEntryName,
                   sizeof(rasdialparamsW.szEntryName) / sizeof(WCHAR));
    }

    //
    // Call the W version to do the work.
    //
    dwErr = RasGetEntryDialParamsW(
              lpszPhonebook != NULL
              ? szPhonebookW : NULL,
              &rasdialparamsW,
              lpfPassword);
    if (dwErr)
    {
        goto done;
    }

    //
    // Copy over the rest of the fields to the
    // user's A buffer, taking into account the
    // version of the structure the user passed
    // in.
    //
    if (lprasdialparams->dwSize == sizeof (RASDIALPARAMSA_V351))
    {
        RASDIALPARAMSA_V351 *prdp =
                    (RASDIALPARAMSA_V351 *)lprasdialparams;

        WCHAR szBuf[RAS_MaxCallbackNumber_V351 + 1];

        strncpyWtoAAnsi(prdp->szPhoneNumber,
                   rasdialparamsW.szPhoneNumber,
                   sizeof(prdp->szPhoneNumber));

        //
        // The szCallbackNumber field is smaller
        // in the V351 version, therefore the extra
        // copy step.
        //
        lstrcpynW(
          szBuf,
          rasdialparamsW.szCallbackNumber,
          RAS_MaxCallbackNumber_V351+1);

        strncpyWtoAAnsi(
            prdp->szCallbackNumber,
            szBuf,
            sizeof(prdp->szCallbackNumber));

        strncpyWtoAAnsi(prdp->szUserName,
                   rasdialparamsW.szUserName,
                   sizeof(prdp->szUserName));

        strncpyWtoAAnsi(prdp->szPassword,
                   rasdialparamsW.szPassword,
                   sizeof(prdp->szPassword));

        strncpyWtoAAnsi(prdp->szDomain,
                   rasdialparamsW.szDomain,
                   sizeof(prdp->szDomain));
    }
    else
    {
        strncpyWtoAAnsi(lprasdialparams->szPhoneNumber,
                   rasdialparamsW.szPhoneNumber,
                   sizeof(lprasdialparams->szPhoneNumber));

        strncpyWtoAAnsi(lprasdialparams->szCallbackNumber,
                   rasdialparamsW.szCallbackNumber,
                   sizeof(lprasdialparams->szCallbackNumber));

        strncpyWtoAAnsi(lprasdialparams->szUserName,
                   rasdialparamsW.szUserName,
                   sizeof(lprasdialparams->szUserName));

        strncpyWtoAAnsi(lprasdialparams->szPassword,
                   rasdialparamsW.szPassword,
                   sizeof(lprasdialparams->szPassword));

        strncpyWtoAAnsi(lprasdialparams->szDomain,
                   rasdialparamsW.szDomain,
                   sizeof(lprasdialparams->szDomain));

        if (lprasdialparams->dwSize ==
                        sizeof (RASDIALPARAMSA))
        {
            lprasdialparams->dwSubEntry =
                        rasdialparamsW.dwSubEntry;
        }
    }

done:
    return dwErr;
}


//Real password won't be returned, only a handle will be returned.
DWORD APIENTRY
RasGetEntryDialParamsW(
    IN  LPCWSTR          lpszPhonebook,
    OUT LPRASDIALPARAMSW lprasdialparams,
    OUT LPBOOL           lpfPassword )

/*++

Routine Description:
    Retrieves cached RASDIALPARAM information.

Arguments:

Return Value:
    Returns 0 if successful, otherwise a non-0 error code.

--*/
{
    DWORD dwErr;
    DTLNODE *pdtlnode = NULL;
    PBENTRY *pEntry;
    DWORD dwMask;
    RAS_DIALPARAMS dialparams;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetEntryDialParamsA");

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Validate parameters.
    //
    if (    lprasdialparams == NULL
        ||  lpfPassword == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    lprasdialparams->dwSize !=
            sizeof (RASDIALPARAMSW)

        &&  lprasdialparams->dwSize !=
            sizeof (RASDIALPARAMSW_V351)

        &&  lprasdialparams->dwSize !=
            sizeof (RASDIALPARAMSW_V400))
    {
        return ERROR_INVALID_SIZE;
    }

    //
    // Load the phonebook file.
    //

    dwErr = ReadEntryFromSystem(
                lpszPhonebook,
                lprasdialparams->szEntryName,
                RPBF_NoCreate,
                NULL,
                &pdtlnode,
                NULL);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    pEntry = (PBENTRY *)DtlGetData(pdtlnode);
    ASSERT(pEntry);

    //
    // Set the appropriate flags to get all
    // the fields.
    //
    dwMask =    DLPARAMS_MASK_PHONENUMBER
            |   DLPARAMS_MASK_CALLBACKNUMBER
            |   DLPARAMS_MASK_USERNAME
            |   DLPARAMS_MASK_PASSWORD
            |   DLPARAMS_MASK_DOMAIN
            |   DLPARAMS_MASK_SUBENTRY
            |   DLPARAMS_MASK_OLDSTYLE;

    //
    // Get the dial parameters from rasman.
    //
    dwErr = g_pRasGetDialParams(
                pEntry->dwDialParamsUID,
                &dwMask,
                &dialparams);

    if (dwErr)
    {
        return dwErr;
    }

    //
    // Convert from the rasman dialparams
    // to the rasapi32 dialparams, taking
    // into account which version of the
    // structure the user passed in.
    //
    if (lprasdialparams->dwSize ==
        sizeof (RASDIALPARAMSW_V351))
    {
        RASDIALPARAMSW_V351 *prdp =
            (RASDIALPARAMSW_V351 *)lprasdialparams;

        lstrcpyn(prdp->szPhoneNumber,
                 dialparams.DP_PhoneNumber,
                 sizeof(prdp->szPhoneNumber) / sizeof(WCHAR));

        lstrcpynW(prdp->szCallbackNumber,
                dialparams.DP_CallbackNumber,
                RAS_MaxCallbackNumber_V351 + 1);

        lstrcpyn(prdp->szUserName,
                 dialparams.DP_UserName,
                 sizeof(prdp->szUserName) / sizeof(WCHAR));

        lstrcpyn(prdp->szPassword,
                 dialparams.DP_Password,
                 sizeof(prdp->szPassword) / sizeof(WCHAR));

        lstrcpyn(prdp->szDomain,
                 dialparams.DP_Domain,
                 sizeof(prdp->szDomain) / sizeof(WCHAR));
    }
    else
    {
        //
        // V400 and V401 structures only differ by the
        // the addition of the dwSubEntry field, which
        // we test at the end.
        //
        lstrcpyn(lprasdialparams->szPhoneNumber,
                 dialparams.DP_PhoneNumber,
                 sizeof(lprasdialparams->szPhoneNumber) / sizeof(WCHAR));

        lstrcpyn(lprasdialparams->szCallbackNumber,
                 dialparams.DP_CallbackNumber,
                 sizeof(lprasdialparams->szCallbackNumber) / sizeof(WCHAR));

        lstrcpyn(lprasdialparams->szUserName,
                 dialparams.DP_UserName,
                 sizeof(lprasdialparams->szUserName) / sizeof(WCHAR));

        lstrcpyn(lprasdialparams->szPassword,
                 dialparams.DP_Password,
                 sizeof(lprasdialparams->szPassword) / sizeof(WCHAR));

        lstrcpyn(lprasdialparams->szDomain,
                 dialparams.DP_Domain,
                 sizeof(lprasdialparams->szDomain) / sizeof(WCHAR));

        if (lprasdialparams->dwSize ==
                    sizeof (RASDIALPARAMSW))
        {
            lprasdialparams->dwSubEntry =
                        dialparams.DP_SubEntry;
        }
    }

    //
    // If we got the rest of the parameters,
    // then copy the entry name.
    //
    //For .Net 587396
    lstrcpynW(
      lprasdialparams->szEntryName,
      pEntry->pszEntryName,
      (lprasdialparams->dwSize ==
       sizeof (RASDIALPARAMSW_V351)) 
       ? RAS_MaxEntryName_V351+1
       : RAS_MaxEntryName + 1 );

    //
    // Set the lpfPassword flag if
    // we successfully retrieved the
    // password.
    //
    *lpfPassword =  (dwMask & DLPARAMS_MASK_PASSWORD)
                    ? TRUE
                    : FALSE;

done:

    //
    // Clean up.
    //
    if (pdtlnode)
    {
        DestroyEntryNode(pdtlnode);
    }        

    return dwErr;
}


DWORD APIENTRY
RasGetErrorStringW(
    IN  UINT  ResourceId,
    OUT LPWSTR lpszString,
    IN  DWORD InBufSize )

/*++

Routine Description:

    Load caller's buffer 'lpszString' of length 'InBufSize'
    with the resource string associated with ID 'ResourceId'.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0 error code.

--*/
{
    DWORD dwErr = 0;
    HINSTANCE hMsgDll;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if (    (   (  ResourceId < RASBASE
                ||  ResourceId > RASBASEEND)

            &&  (   ResourceId < ROUTEBASE
                ||  ResourceId > ROUTEBASEEND))

        || !lpszString )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (InBufSize == 1)
    {
        //
        // strange case, but a bug was filed...
        //
        lpszString[ 0 ] = L'\0';

        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Load the error message DLL.
    //
    hMsgDll = LoadLibrary(MSGDLLPATH);
    if (hMsgDll == NULL)
    {
        return GetLastError();
    }

    if (!FormatMessageW(
          FORMAT_MESSAGE_FROM_HMODULE,
          hMsgDll,
          ResourceId,
          0,
          lpszString,
          InBufSize,
          NULL))
    {
       dwErr = GetLastError();
    }

    FreeLibrary(hMsgDll);
    return dwErr;
}


DWORD APIENTRY
RasGetErrorStringA(
    IN  UINT   ResourceId,
    OUT LPSTR lpszString,
    IN  DWORD  InBufSize )

/*++

Routine Description:

    Load caller's buffer 'lpszString' of length
    'InBufSize' with the resource string
    associated with ID 'ResourceId'.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0
    error code.

--*/
{
    DWORD  dwErr = 0;
    HINSTANCE hMsgDll;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if (    (   (  ResourceId < RASBASE
                ||  ResourceId > RASBASEEND)

            &&  (   ResourceId < ROUTEBASE
                ||  ResourceId > ROUTEBASEEND))

        || !lpszString )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (InBufSize == 1)
    {
        //
        // strange case, but a bug was filed...
        //
        lpszString[ 0 ] = '\0';
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Load the error message DLL.
    //
    hMsgDll = LoadLibrary(MSGDLLPATH);
    if (hMsgDll == NULL)
    {
        return GetLastError();
    }

    if (!FormatMessageA(
          FORMAT_MESSAGE_FROM_HMODULE,
          hMsgDll,
          ResourceId,
          0,
          lpszString,
          InBufSize,
          NULL))
    {
       dwErr = GetLastError();
    }

    return dwErr;
}


HPORT APIENTRY
RasGetHport(
    IN HRASCONN hrasconn )

/*++

Routine Description:

Arguments:

Return value

    Return the HPORT associated with the 'hrasconn'
    or INVALID_HANDLE_VALUE on error.

--*/
{
    DWORD dwErr, dwcbPorts = 0, dwcPorts = 0;
    RASMAN_PORT *lpPorts;
    HPORT hport;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetHport");

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return INVALID_HPORT;
    }

    if (DwRasInitializeError)
    {
        return INVALID_HPORT;
    }

    if (IS_HPORT(hrasconn))
    {
        hport = HRASCONN_TO_HPORT(hrasconn);
    }
    else
    {
        //
        // Get the list of ports from rasman
        // and get the handle of the 0th port.
        //
        dwErr = g_pRasEnumConnectionPorts(
                  NULL,
                  (HCONN)hrasconn,
                  NULL,
                  &dwcbPorts,
                  &dwcPorts);

        if (    dwErr != ERROR_BUFFER_TOO_SMALL
            ||  !dwcPorts)
        {
            return INVALID_HPORT;
        }

        lpPorts = Malloc(dwcbPorts);
        if (lpPorts == NULL)
        {
            return INVALID_HPORT;
        }

        dwErr = g_pRasEnumConnectionPorts(
                  NULL,
                  (HCONN)hrasconn,
                  lpPorts,
                  &dwcbPorts,
                  &dwcPorts);

        if (    dwErr
            ||  !dwcPorts)
        {
            hport = INVALID_HPORT;
        }
        else
        {
            hport = lpPorts[0].P_Handle;
        }

        Free(lpPorts);
    }

    return hport;
}

DWORD 
DwGetReplyMessage(HRASCONN hrasconn,
                  WCHAR *pszReplyMessage,
                  DWORD cbBuf)
{
    DWORD dwErr;
    DWORD dwReplySize = 0;
    BYTE *pbReply = NULL;

    ASSERT(NULL != pszReplyMessage);

    pszReplyMessage[0] = L'\0';

    dwErr = g_pRasGetConnectionUserData(
              (HCONN)hrasconn,
              CONNECTION_PPPREPLYMESSAGE_INDEX,
              pbReply,
              &dwReplySize);

    if(     (ERROR_BUFFER_TOO_SMALL != dwErr)
        ||  (dwReplySize > cbBuf))
    {
        if(dwReplySize > cbBuf)
        {
            ERROR_BUFFER_TOO_SMALL;
        }
        
        goto done;
    }

    pbReply = LocalAlloc(LPTR,
                         dwReplySize);

    if(NULL == pbReply)
    {
        dwErr = GetLastError();
        goto done;
    }

    dwErr = g_pRasGetConnectionUserData(
                (HCONN) hrasconn,
                CONNECTION_PPPREPLYMESSAGE_INDEX,
                pbReply,
                &dwReplySize);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    //
    // convert the ansi string to unicode and return
    //
    strncpyAtoWAnsi(pszReplyMessage, (CHAR *) pbReply, cbBuf);

done:

    if(NULL != pbReply)
    {
        LocalFree(pbReply);
    }

    return dwErr;
    
}


DWORD APIENTRY
RasGetProjectionInfoW(
    HRASCONN        hrasconn,
    RASPROJECTION   rasprojection,
    LPVOID          lpprojection,
    LPDWORD         lpcb )

/*++

Routine Description:

    Loads caller's buffer '*lpprojection' with the
    data structure corresponding to the protocol
    'rasprojection' on 'hrasconn'.  On entry '*lpcp'
    indicates the size of caller's buffer.  On exit
    it contains the size of buffer required to hold
    all projection information.

Arguments:

Return Value:
    Returns 0 if successful, otherwise a non-zero
    error code.

--*/
{
    DWORD dwErr, dwSubEntry;

    DWORD dwPppSize, dwAmbSize, dwSlipSize;

    NETBIOS_PROJECTION_RESULT ambProj;

    PPP_PROJECTION_RESULT pppProj;

    RASSLIPW slipProj;

    PBYTE pBuf;


    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE1("RasGetProjectionInfoW(0x%x)",
           rasprojection);

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError != 0)
    {
        return DwRasInitializeError;
    }

    if (hrasconn == 0)
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Get the subentry associated with this
    // connection, if specified.
    //
    dwSubEntry = SubEntryFromConnection(&hrasconn);

    if (!dwSubEntry)
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Get the projection results from rasman.
    //
    dwPppSize = sizeof (pppProj);

    dwErr = g_pRasGetConnectionUserData(
              (HCONN)hrasconn,
              CONNECTION_PPPRESULT_INDEX,
              (PBYTE)&pppProj,
              &dwPppSize);

    if (dwErr)
    {
        return dwErr;
    }

    dwAmbSize = sizeof (ambProj);

    dwErr = g_pRasGetConnectionUserData(
              (HCONN)hrasconn,
              CONNECTION_AMBRESULT_INDEX,
              (PBYTE)&ambProj,
              &dwAmbSize);

    if (dwErr)
    {
        return dwErr;
    }

    dwSlipSize = sizeof (slipProj);

    dwErr = g_pRasGetConnectionUserData(
              (HCONN)hrasconn,
              CONNECTION_SLIPRESULT_INDEX,
              (PBYTE)&slipProj,
              &dwSlipSize);

    if (dwErr)
    {
        return dwErr;
    }

    //
    // Verify parameters.
    //
    if (    !lpcb
        ||  (   *lpcb > 0
            &&  !lpprojection))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    rasprojection != RASP_Amb
        &&  rasprojection != RASP_Slip
        &&  rasprojection != RASP_PppNbf
        &&  rasprojection != RASP_PppIpx
        &&  rasprojection != RASP_PppIp
        &&  rasprojection != RASP_PppLcp
        &&  rasprojection != RASP_PppCcp)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (rasprojection == RASP_PppNbf)
    {
        RASPPPNBFW*       pnbf;
        PPP_NBFCP_RESULT* ppppnbf;
        HPORT hport;

        if (    pppProj.nbf.dwError ==
                ERROR_PPP_NO_PROTOCOLS_CONFIGURED
            ||  dwPppSize != sizeof (pppProj))
        {
            return ERROR_PROTOCOL_NOT_CONFIGURED;
        }

        pnbf = (RASPPPNBFW* )lpprojection;
        ppppnbf = &pppProj.nbf;

        if (    (NULL == pnbf)
            ||  (*lpcb < pnbf->dwSize))
        {
            *lpcb = sizeof (RASPPPNBFW);

            return ERROR_BUFFER_TOO_SMALL;
        }

        if (pnbf->dwSize != sizeof(RASPPPNBFW))
        {
            return ERROR_INVALID_SIZE;
        }

        pnbf->dwError = ppppnbf->dwError;

        pnbf->dwNetBiosError = ppppnbf->dwNetBiosError;

        strncpyAtoW(
            pnbf->szNetBiosError,
            ppppnbf->szName,
            sizeof(pnbf->szNetBiosError) / sizeof(WCHAR));

        lstrcpyn(
            pnbf->szWorkstationName,
            ppppnbf->wszWksta,
            sizeof(pnbf->szWorkstationName) / sizeof(WCHAR));

        dwErr = SubEntryPort(hrasconn, dwSubEntry, &hport);

        if (dwErr)
        {
            return dwErr;
        }

        dwErr = GetAsybeuiLana(hport, &pnbf->bLana);

        if (dwErr)
        {
            return dwErr;
        }
    }
    else if (rasprojection == RASP_PppIpx)
    {
        RASPPPIPXW*       pipx;
        PPP_IPXCP_RESULT* ppppipx;

        if (    pppProj.ipx.dwError ==
                ERROR_PPP_NO_PROTOCOLS_CONFIGURED
            ||  dwPppSize != sizeof (pppProj))
        {
            return ERROR_PROTOCOL_NOT_CONFIGURED;
        }

        pipx = (RASPPPIPXW* )lpprojection;
        ppppipx = &pppProj.ipx;

        if (    (NULL != pipx)
            &&  (pipx->dwSize != sizeof(RASPPPIPXW)))
        {
            return ERROR_INVALID_SIZE;
        }

        if (    (NULL == pipx)
            ||  (*lpcb < pipx->dwSize))
        {
            *lpcb = sizeof(RASPPPIPXW);
            return ERROR_BUFFER_TOO_SMALL;
        }

        pipx->dwError = ppppipx->dwError;

        ConvertIpxAddressToString( ppppipx->bLocalAddress,
                                   pipx->szIpxAddress );
    }
    else if (rasprojection == RASP_PppIp)
    {
        RASPPPIPW*       pip;
        PPP_IPCP_RESULT* ppppip;

        if (    pppProj.ip.dwError ==
                ERROR_PPP_NO_PROTOCOLS_CONFIGURED
            ||  dwPppSize != sizeof (pppProj))
        {
            return ERROR_PROTOCOL_NOT_CONFIGURED;
        }

        pip = (RASPPPIPW* )lpprojection;
        ppppip = &pppProj.ip;

        if (    (NULL != pip)
            &&  (pip->dwSize != sizeof(RASPPPIPW))
            &&  (pip->dwSize != sizeof(RASPPPIPW_V35))
            &&  (pip->dwSize != sizeof(RASPPPIPW_V401)))
        {
            return ERROR_INVALID_SIZE;
        }

        if (    (NULL == pip)
            ||  (*lpcb < pip->dwSize))
        {
            if(NULL != pip)
            {
                *lpcb = pip->dwSize;
            }
            else
            {
                *lpcb = sizeof(RASPPPIPW);
            }
            
            return ERROR_BUFFER_TOO_SMALL;
        }

        //
        // The dumb case where caller's buffer is bigger
        // than the old structure, smaller than the new
        // structure, but dwSize asks for the new
        // structure.
        //
        if (    pip->dwSize == sizeof(RASPPPIPW)
            && *lpcb < sizeof(RASPPPIPW))
        {
            *lpcb = sizeof(RASPPPIPW);
            return ERROR_BUFFER_TOO_SMALL;
        }

        pip->dwError = ppppip->dwError;

        ConvertIpAddressToString(ppppip->dwLocalAddress,
                                 pip->szIpAddress );

        if (pip->dwSize >= sizeof(RASPPPIPW_V401))
        {
            //
            // The server address was added late in the
            // NT 3.51 cycle and is not reported to NT
            // 3.5 or earlier NT 3.51 clients.
            //

            ConvertIpAddressToString( ppppip->dwRemoteAddress,
                                      pip->szServerIpAddress );
        }

        if (pip->dwSize == sizeof(RASPPPIPW))
        {
            if (ppppip->fReceiveVJHCompression)
            {
                pip->dwOptions = RASIPO_VJ;
            }
            else
            {
                pip->dwOptions = 0;
            }

            if (ppppip->fSendVJHCompression)
            {
                pip->dwServerOptions = RASIPO_VJ;
            }
            else
            {
                pip->dwServerOptions = 0;
            }
        }
    }
    else if (rasprojection == RASP_PppLcp)
    {
        RASPPPLCP*      plcp;
        PPP_LCP_RESULT* pppplcp;

        if (dwPppSize != sizeof (pppProj))
        {
            return ERROR_PROTOCOL_NOT_CONFIGURED;
        }

        plcp = (RASPPPLCP* )lpprojection;
        pppplcp = &pppProj.lcp;

        if (    (NULL != plcp)
            &&  (plcp->dwSize != sizeof(RASPPPLCP))
            &&  (plcp->dwSize != sizeof(RASPPPLCP_V401)))
        {
            return ERROR_INVALID_SIZE;
        }

        if (    (NULL == plcp)
            ||  (*lpcb < plcp->dwSize))
        {
            if(NULL != plcp)
            {
                *lpcb = plcp->dwSize;
            }
            else
            {
                *lpcb = sizeof(RASPPPLCP);
            }
            
            return ERROR_BUFFER_TOO_SMALL;
        }

        plcp->fBundled = (pppplcp->hportBundleMember
                          != INVALID_HPORT);

        if(sizeof(RASPPPLCP) == plcp->dwSize)
        {
            //
            // Copy the additional fields if its NT5
            //

            plcp->dwOptions = 0;
            plcp->dwServerOptions = 0;

            if (pppplcp->dwLocalOptions & PPPLCPO_PFC)
            {
                plcp->dwOptions |= RASLCPO_PFC;
            }

            if (pppplcp->dwLocalOptions & PPPLCPO_ACFC)
            {
                plcp->dwOptions |= RASLCPO_ACFC;
            }

            if (pppplcp->dwLocalOptions & PPPLCPO_SSHF)
            {
                plcp->dwOptions |= RASLCPO_SSHF;
            }

            if (pppplcp->dwLocalOptions & PPPLCPO_DES_56)
            {
                plcp->dwOptions |= RASLCPO_DES_56;
            }

            if (pppplcp->dwLocalOptions & PPPLCPO_3_DES)
            {
                plcp->dwOptions |= RASLCPO_3_DES;
            }

            plcp->dwAuthenticationProtocol =
                    pppplcp->dwLocalAuthProtocol;

            plcp->dwAuthenticationData =
                    pppplcp->dwLocalAuthProtocolData;

            plcp->dwEapTypeId = pppplcp->dwLocalEapTypeId;

            if (pppplcp->dwRemoteOptions & PPPLCPO_PFC)
            {
                plcp->dwServerOptions |= RASLCPO_PFC;
            }

            if (pppplcp->dwRemoteOptions & PPPLCPO_ACFC)
            {
                plcp->dwServerOptions |= RASLCPO_ACFC;
            }

            if (pppplcp->dwRemoteOptions & PPPLCPO_SSHF)
            {
                plcp->dwServerOptions |= RASLCPO_SSHF;
            }

            if (pppplcp->dwRemoteOptions & PPPLCPO_DES_56)
            {
                plcp->dwServerOptions |= RASLCPO_DES_56;
            }

            if (pppplcp->dwRemoteOptions & PPPLCPO_3_DES)
            {
                plcp->dwServerOptions |= RASLCPO_3_DES;
            }

            plcp->dwServerAuthenticationProtocol =
                    pppplcp->dwRemoteAuthProtocol;

            plcp->dwServerAuthenticationData =
                    pppplcp->dwRemoteAuthProtocolData;

            plcp->dwServerEapTypeId = pppplcp->dwRemoteEapTypeId;

            //
            // Set the Terminate Reasons to 0 for now
            // They don't make sense since if PPP terminates
            // the line will go down and this api will fail.
            //
            plcp->dwTerminateReason = 0;
            plcp->dwServerTerminateReason = 0;


            dwErr = DwGetReplyMessage(hrasconn,
                                      plcp->szReplyMessage,
                                      RAS_MaxReplyMessage);
            plcp->dwError = 0;

            if(pppplcp->dwLocalFramingType & PPP_MULTILINK_FRAMING)
            {
                plcp->fMultilink = 1;
            }
            else
            {
                plcp->fMultilink = 0;
            }
        }
    }
    else if (rasprojection == RASP_Amb)
    {
        RASAMBW*                   pamb;
        NETBIOS_PROJECTION_RESULT* pCbAmb;
        HPORT hport;

        if (ambProj.Result == ERROR_PROTOCOL_NOT_CONFIGURED)
        {
            return ERROR_PROTOCOL_NOT_CONFIGURED;
        }

        pamb = (RASAMBW* )lpprojection;
        pCbAmb = &ambProj;

        if (    (NULL != pamb)
            &&  (pamb->dwSize != sizeof(RASAMBW)))
        {
            return ERROR_INVALID_SIZE;
        }

        if (    (NULL == pamb)
            ||  (*lpcb < pamb->dwSize))
        {
            *lpcb = sizeof(RASAMBW);
            return ERROR_BUFFER_TOO_SMALL;
        }

        pamb->dwError = pCbAmb->Result;

        strncpyAtoW(pamb->szNetBiosError,
                   pCbAmb->achName,
                   sizeof(pamb->szNetBiosError) / sizeof(WCHAR));

        dwErr = SubEntryPort(hrasconn,
                             dwSubEntry,
                             &hport);

        if (dwErr)
        {
            return dwErr;
        }

        dwErr = GetAsybeuiLana(hport, &pamb->bLana);

        if (dwErr)
        {
            return dwErr;
        }
    }
    else if (rasprojection == RASP_PppCcp)
    {
        RASPPPCCP*          pCcp;
        PPP_CCP_RESULT*     pPppCcp;

        if (    pppProj.ccp.dwError ==
                ERROR_PPP_NO_PROTOCOLS_CONFIGURED
            ||  dwPppSize != sizeof (pppProj))
        {
            return ERROR_PROTOCOL_NOT_CONFIGURED;
        }

        pCcp = (RASPPPCCP* )lpprojection;
        pPppCcp = &pppProj.ccp;

        if(     (NULL != pCcp)
            &&  (sizeof(RASPPPCCP) != pCcp->dwSize))
        {
            return ERROR_INVALID_SIZE;
        }

        if(     (NULL == pCcp)
            ||  (*lpcb < pCcp->dwSize))
        {
            if(NULL != pCcp)
            {
            *lpcb = pCcp->dwSize;
            }
            else
            {
                *lpcb = sizeof(RASPPPCCP);
            }
            
            return ERROR_BUFFER_TOO_SMALL;
        }

        pCcp->dwError = pPppCcp->dwError;

        //
        // Initialize everything to 0
        //
        pCcp->dwOptions = 
        pCcp->dwServerOptions =
        pCcp->dwCompressionAlgorithm = 
        pCcp->dwServerCompressionAlgorithm = 0;

        if(RAS_CCP_OPTION_MSPPC == pPppCcp->dwSendProtocol)
        {
            if(pPppCcp->dwSendProtocolData & MSTYPE_COMPRESSION)
            {
                pCcp->dwOptions |= RASCCPO_Compression;
            }

            if(pPppCcp->dwSendProtocolData & MSTYPE_HISTORYLESS)
            {
                pCcp->dwOptions |= RASCCPO_HistoryLess;
            }

            if(   pPppCcp->dwSendProtocolData
                & (   MSTYPE_ENCRYPTION_40F
                    | MSTYPE_ENCRYPTION_40))
            {
                pCcp->dwOptions |= RASCCPO_Encryption40bit;
            }
            else if(pPppCcp->dwSendProtocolData & MSTYPE_ENCRYPTION_56)
            {
                pCcp->dwOptions |= RASCCPO_Encryption56bit;
            }
            else if(pPppCcp->dwSendProtocolData & MSTYPE_ENCRYPTION_128)
            {
                pCcp->dwOptions |= RASCCPO_Encryption128bit;
            }

            if(0 != pCcp->dwOptions)
            {
                //
                // Set the MPPC bit only if some bits are set for
                // dwOptions. Otherwise setting MPPC doesn't make
                // sense since we couldn't have negotiated
                // compression
                //
                pCcp->dwCompressionAlgorithm = RASCCPCA_MPPC;
            }
        }

        if(RAS_CCP_OPTION_MSPPC == pPppCcp->dwReceiveProtocol)
        {
            if(pPppCcp->dwReceiveProtocolData & MSTYPE_COMPRESSION)
            {
                pCcp->dwServerOptions |= RASCCPO_Compression;
            }

            if(pPppCcp->dwReceiveProtocolData & MSTYPE_HISTORYLESS)
            {
                pCcp->dwServerOptions |= RASCCPO_HistoryLess;
            }

            if(   pPppCcp->dwReceiveProtocolData
                & (   MSTYPE_ENCRYPTION_40F
                    | MSTYPE_ENCRYPTION_40))
            {
                pCcp->dwServerOptions |= RASCCPO_Encryption40bit;
            }
            else if(pPppCcp->dwReceiveProtocolData & MSTYPE_ENCRYPTION_56)
            {
                pCcp->dwServerOptions |= RASCCPO_Encryption56bit;
            }
            else if(pPppCcp->dwReceiveProtocolData & MSTYPE_ENCRYPTION_128)
            {
                pCcp->dwServerOptions |= RASCCPO_Encryption128bit;
            }

            if(0 != pCcp->dwServerOptions)
            {
                //
                // Set the MPPC bit only if some bits are set for
                // dwOptions. Otherwise setting MPPC doesn't make
                // sense since we couldn't have negotiated
                // compression
                //
                pCcp->dwServerCompressionAlgorithm = RASCCPCA_MPPC;
            }
        }
    }
    else
    {
        //
        // if (rasprojection == RASP_Slip)
        //
        if (    slipProj.dwError ==
                ERROR_PROTOCOL_NOT_CONFIGURED
            ||  dwSlipSize != sizeof (slipProj))
        {
            return ERROR_PROTOCOL_NOT_CONFIGURED;
        }

        if (*lpcb < sizeof (RASSLIPW))
        {
            *lpcb = sizeof (RASSLIPW);
            return ERROR_BUFFER_TOO_SMALL;
        }

        memcpy(lpprojection,
               &slipProj,
               sizeof (RASSLIPW));
    }

    return 0;
}


DWORD
RasGetProjectionInfoA(
    HRASCONN        hrasconn,
    RASPROJECTION   rasprojection,
    LPVOID          lpprojection,
    LPDWORD         lpcb )
{
    DWORD dwErr = 0, dwcb;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if (    !lpcb
        || (    *lpcb > 0
            &&  !lpprojection))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    rasprojection != RASP_Amb
        &&  rasprojection != RASP_Slip
        &&  rasprojection != RASP_PppNbf
        &&  rasprojection != RASP_PppIpx
        &&  rasprojection != RASP_PppIp
        &&  rasprojection != RASP_PppLcp
        &&  rasprojection != RASP_PppCcp)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (rasprojection == RASP_PppNbf)
    {
        RASPPPNBFW  nbf;
        RASPPPNBFA* pnbf = (RASPPPNBFA* )lpprojection;

        if (pnbf->dwSize != sizeof(RASPPPNBFA))
        {
            return ERROR_INVALID_SIZE;
        }

        if (*lpcb < pnbf->dwSize)
        {
            *lpcb = sizeof(RASPPPNBFA);
            return ERROR_BUFFER_TOO_SMALL;
        }

        nbf.dwSize = sizeof(nbf);
        dwcb = sizeof (nbf);
        dwErr = RasGetProjectionInfoW(hrasconn,
                                      rasprojection,
                                      &nbf, &dwcb );
        *lpcb = pnbf->dwSize;

        if (dwErr == 0)
        {
            pnbf->dwError = nbf.dwError;
            pnbf->dwNetBiosError =  nbf.dwNetBiosError;

            strncpyWtoAAnsi(pnbf->szNetBiosError,
                       nbf.szNetBiosError,
                       sizeof(pnbf->szNetBiosError));

            strncpyWtoAAnsi(pnbf->szWorkstationName,
                       nbf.szWorkstationName,
                       sizeof(pnbf->szWorkstationName));
        }
    }
    else if (rasprojection == RASP_PppIpx)
    {
        RASPPPIPXW  ipx;
        RASPPPIPXA* pipx = (RASPPPIPXA* )lpprojection;

        if (pipx->dwSize != sizeof(RASPPPIPXA))
        {
            return ERROR_INVALID_SIZE;
        }

        if (*lpcb < pipx->dwSize)
        {
            *lpcb = sizeof(RASPPPIPXA);
            return ERROR_BUFFER_TOO_SMALL;
        }

        ipx.dwSize = sizeof(ipx);
        dwcb = sizeof (ipx);

        dwErr = RasGetProjectionInfoW(hrasconn,
                                      rasprojection,
                                      &ipx,
                                      &dwcb );
        *lpcb = pipx->dwSize;

        if (dwErr == 0)
        {
            pipx->dwError = ipx.dwError;
            strncpyWtoAAnsi(pipx->szIpxAddress,
                       ipx.szIpxAddress,
                       sizeof(pipx->szIpxAddress));
        }
    }
    else if (rasprojection == RASP_PppIp)
    {
        RASPPPIPW  ip;
        RASPPPIPA* pip = (RASPPPIPA* )lpprojection;

        if (    pip->dwSize != sizeof(RASPPPIPA)
            &&  pip->dwSize != sizeof(RASPPPIPA_V35)
            &&  pip->dwSize != sizeof(RASPPPIPA_V401))
        {
            return ERROR_INVALID_SIZE;
        }

        if (*lpcb < pip->dwSize)
        {
            *lpcb = pip->dwSize;
            return ERROR_BUFFER_TOO_SMALL;
        }

        //
        // The dumb case where caller's buffer is bigger
        // than the old structure, smaller than the new
        // structure, but dwSize asks for the new
        // structure.
        //
        if (    pip->dwSize == sizeof(RASPPPIPA)
            && *lpcb < sizeof(RASPPPIPA))
        {
            *lpcb = sizeof(RASPPPIPA);
            return ERROR_BUFFER_TOO_SMALL;
        }

        ip.dwSize = sizeof(ip);

        dwcb = sizeof (ip);

        dwErr = RasGetProjectionInfoW(hrasconn,
                                      rasprojection,
                                      &ip,
                                      &dwcb );
        *lpcb = pip->dwSize;

        if (dwErr == 0)
        {
            pip->dwError = ip.dwError;
            strncpyWtoAAnsi(
                pip->szIpAddress,
                ip.szIpAddress,
                sizeof(pip->szIpAddress));

            if (dwErr == 0)
            {
                if (pip->dwSize >= sizeof(RASPPPIPA_V401))
                {
                    //
                    // The server address was added late in
                    // the NT 3.51 cycle and is not reported
                    // to NT 3.5 or earlier NT 3.51
                    // clients.
                    //
                    strncpyWtoAAnsi(pip->szServerIpAddress,
                               ip.szServerIpAddress,
                               sizeof(pip->szServerIpAddress));
                }

                if (pip->dwSize >= sizeof(RASPPPIPA))
                {
                    pip->dwOptions = ip.dwOptions;
                    pip->dwServerOptions = ip.dwServerOptions;
                }
            }
        }
    }
    else if (rasprojection == RASP_PppLcp)
    {
        RASPPPLCPW  ppplcp;
        RASPPPLCPA* pppplcp = (RASPPPLCPA* )lpprojection;

        if (*lpcb < sizeof(RASPPPLCPA))
        {
            *lpcb = sizeof(RASPPPLCPA);
            return ERROR_BUFFER_TOO_SMALL;
        }

        if (pppplcp->dwSize != sizeof(RASPPPLCPA))
        {
            return ERROR_INVALID_SIZE;
        }

        ppplcp.dwSize = sizeof(RASPPPLCPW);

        dwcb = sizeof(RASPPPLCPW);

        dwErr = RasGetProjectionInfoW(
                                hrasconn,
                                rasprojection,
                                &ppplcp,
                                &dwcb );
        *lpcb = sizeof(RASPPPLCPA);

        if (dwErr == 0)
        {
            pppplcp->fBundled =     ppplcp.fBundled;
            pppplcp->dwError =      ppplcp.dwError;
            pppplcp->dwOptions = ppplcp.dwOptions;
            pppplcp->dwAuthenticationProtocol =
                                    ppplcp.dwAuthenticationProtocol;
            pppplcp->dwAuthenticationData =
                                    ppplcp.dwAuthenticationData;
            pppplcp->dwEapTypeId = ppplcp.dwEapTypeId;
            pppplcp->dwServerOptions = ppplcp.dwServerOptions;
            pppplcp->dwServerAuthenticationProtocol =
                                    ppplcp.dwServerAuthenticationProtocol;
            pppplcp->dwServerAuthenticationData =
                                    ppplcp.dwServerAuthenticationData;
            pppplcp->dwServerEapTypeId = ppplcp.dwServerEapTypeId;
            pppplcp->dwTerminateReason =
                                    ppplcp.dwTerminateReason;
            pppplcp->dwServerTerminateReason =
                                    ppplcp.dwServerTerminateReason;
            pppplcp->fMultilink =   ppplcp.fMultilink;

            strncpyWtoAAnsi(pppplcp->szReplyMessage,
                       ppplcp.szReplyMessage,
                       sizeof(pppplcp->szReplyMessage));
        }
    }
    else if (rasprojection == RASP_Amb)
    {
        RASAMBW  amb;
        RASAMBA* pamb = (RASAMBA* )lpprojection;

        if (pamb->dwSize != sizeof(RASAMBA))
        {
            return ERROR_INVALID_SIZE;
        }

        if (*lpcb < pamb->dwSize)
        {
            *lpcb = sizeof(RASAMBA);
            return ERROR_BUFFER_TOO_SMALL;
        }

        amb.dwSize = sizeof(amb);

        dwcb = sizeof (amb);

        dwErr = RasGetProjectionInfoW(hrasconn,
                                      rasprojection,
                                      &amb,
                                      &dwcb );
        *lpcb = pamb->dwSize;

        if (dwErr == 0)
        {
            pamb->dwError = amb.dwError;
            strncpyWtoAAnsi(pamb->szNetBiosError,
                       amb.szNetBiosError,
                       sizeof(pamb->szNetBiosError));
        }
    }
    else if (rasprojection == RASP_PppCcp)
    {
        dwErr = RasGetProjectionInfoW(
                                hrasconn,
                                rasprojection,
                                (RASPPPCCP *)
                                lpprojection,
                                lpcb);
    }
    else
    {
        //
        // if (rasprojection == RASP_Slip)
        //
        RASSLIPW  slip;
        RASSLIPA* pslip = (RASSLIPA* )lpprojection;

        if (pslip->dwSize != sizeof(RASSLIPA))
        {
            return ERROR_INVALID_SIZE;
        }

        if (*lpcb < pslip->dwSize)
        {
            *lpcb = sizeof(RASSLIPA);
            return ERROR_BUFFER_TOO_SMALL;
        }

        slip.dwSize = sizeof(slip);

        dwcb = sizeof (slip);

        dwErr = RasGetProjectionInfoW(hrasconn,
                                      rasprojection,
                                      &slip,
                                      &dwcb );
        *lpcb = pslip->dwSize;

        if (dwErr == 0)
        {
            pslip->dwError = slip.dwError;
            strncpyWtoAAnsi(pslip->szIpAddress,
                       slip.szIpAddress,
                       sizeof(pslip->szIpAddress));
        }
    }

    return dwErr;
}

DWORD DwHangUpConnection(HRASCONN hRasconn)
{
    DWORD dwErr = SUCCESS;
    DWORD dwRef;
    DWORD dwLastError = SUCCESS;

    RASAPI32_TRACE1("(HUC) RasRefConnection(FALSE), 0x%x ...",
            hRasconn);

    dwErr = g_pRasRefConnection((HCONN) hRasconn,
                                FALSE,
                                &dwRef);

    RASAPI32_TRACE3("(HUC) RasRefConnection(FALSE), "
            "0x%x. ref=%d, rc=%d",
            hRasconn,
            dwRef,
            dwErr );

    if(ERROR_SUCCESS != dwErr)
    {
        dwLastError = dwErr;
    }

    if (0 == dwRef)
    {
        //
        // Destroy the entire connection.
        //
        RASAPI32_TRACE1("(HU) RasDestroyConnection(%d)...",
                hRasconn);

        dwErr = g_pRasDestroyConnection((HCONN)hRasconn);

        RASAPI32_TRACE1("(HU) RasDestroyConnection done(%d)",
                dwErr);

        if(ERROR_SUCCESS != dwErr)
        {
            dwLastError = dwErr;
        }
    }

    if(     (ERROR_SUCCESS == dwErr)
        &&  (ERROR_SUCCESS != dwLastError))
    {
        dwErr = dwLastError;
    }

    return dwErr;
}


DWORD APIENTRY
RasHangUpW(
    IN HRASCONN hrasconn )

/*++

Routine Description:
    Hang up the connection associated with handle 'hrasconn'.

Arguments:

Return Value:
 Returns 0 if successful, otherwise a non-0 error code.

--*/
{
    DWORD dwErr = 0;
    RASCONNCB* prasconncb;
    HRASCONN hConnPrereq = NULL;
    DWORD dwLastError = ERROR_SUCCESS;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasHangUpW");

    //
    // Note: This stuff happens in the clean up routine if
    //       RasHangUp is called while the async machine
    //       is running.  That lets this routine return
    //       before the machine stops...very important because
    //       it allows the RasDial caller to call RasHangUp
    //       inside a RasDial callback function without
    //       deadlock.
    //
    //
    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError != 0)
    {
        return DwRasInitializeError;
    }

    if (hrasconn == 0)
    {
        return ERROR_INVALID_HANDLE;
    }

    EnterCriticalSection(&csStopLock);

    //
    // If this is a port-based HRASCONN, then
    // stop the async machine associated with
    // the particular subentry.  If this is a
    // connection-based HRASCONN, then stop
    // all async machines associated with this
    // HRASCONN.
    //
    if (IS_HPORT(hrasconn))
    {
        HPORT hport = HRASCONN_TO_HPORT(hrasconn);
        DWORD dwSubEntry;
        DWORD i, dwcbPorts, dwcPorts;

        dwSubEntry = SubEntryFromConnection(&hrasconn);

        if (hrasconn == 0)
        {
            dwErr = ERROR_INVALID_HANDLE;
            goto done;
        }

        RASAPI32_TRACE1("(HU) RasEnumConnectionPorts..",
               hrasconn);

        dwcbPorts = dwcPorts = 0;
        dwErr = g_pRasEnumConnectionPorts(
                    NULL,
                    (HCONN)hrasconn,
                    NULL,
                    &dwcbPorts,
                    &dwcPorts);

        RASAPI32_TRACE1("(HU) RasEnumConnectionPorts. 0x%x",
               dwErr);

        if(ERROR_BUFFER_TOO_SMALL == dwErr)
        {
            dwErr = ERROR_SUCCESS;
        }
        else if(ERROR_SUCCESS != dwErr)
        {
            dwLastError = dwErr;
        }

        //
        // if this is the last port in this connection
        // then deref the connection in rasman.
        //
        if(1 == dwcPorts)
        {
            DWORD dwRef;

            dwErr = g_pRasFindPrerequisiteEntry(
                                (HCONN) hrasconn,
                                (HCONN *) &hConnPrereq);
            RASAPI32_TRACE2("(HU) g_pRasFindPrequisiteEntry(%x). 0x%x",
                    hrasconn,
                    dwErr);

            dwErr = g_pRasRefConnection((HCONN) hrasconn,
                                        FALSE,
                                        &dwRef);

            RASAPI32_TRACE2("(HU) g_pRasRefConnection(%x). 0x%x",
                    hrasconn,
                    dwErr);

            if(ERROR_SUCCESS != dwErr)
            {
                dwLastError = dwErr;
            }
        }

        //
        // mark this connection as Terminated to
        // prevent rasdial machine from starting
        // the connection after the link connection
        // has been Terminated
        //
        prasconncb = ValidateHrasconn2(hrasconn,
                                       dwSubEntry);

        if (NULL != prasconncb)
        {
            prasconncb->fTerminated = TRUE;
        }

        //
        // Disconnect the port associated with this
        // subentry. This is a synchronous call
        //
        RASAPI32_TRACE1("(HU) RasPortDisconnect(%d)...", hport);

        dwErr = g_pRasPortDisconnect(hport,
                                     INVALID_HANDLE_VALUE);

        RASAPI32_TRACE1("(HU) RasPortDisconnect(%d)", dwErr);

        if(ERROR_SUCCESS != dwErr)
        {
            dwLastError = dwErr;
        }

        //
        // Close the port associated with this subentry.
        //
        RASAPI32_TRACE1("(HU) RasPortClose(%d)...", hport);

        dwErr = g_pRasPortClose(hport);

        RASAPI32_TRACE1("(HU) RasPortClose(%d)", dwErr);

        if(ERROR_SUCCESS != dwErr)
        {
            dwLastError = dwErr;
        }

        //
        // HangUp Prereq connection if any
        //
        if(hConnPrereq)
        {
            dwErr = DwHangUpConnection(hConnPrereq);
        }
    }
    else
    {
        DTLNODE *pdtlnode;
        DWORD   dwRef;
        DWORD   dwCount;
        CHAR    szPhonebookPath[MAX_PATH + 1];
        CHAR    szEntryName[MAX_ENTRYNAME_SIZE + 1];

        //
        // Check to see if we need to call the custom hangup
        // function. And if so call the customhangup fn. and
        // bail. Notice we become reentrant since the custom
        // hangup function call can call this function again.
        //
        dwErr = g_pRasReferenceCustomCount((HCONN) hrasconn,
                                           FALSE,
                                           szPhonebookPath,
                                           szEntryName,
                                           &dwCount);

        if(ERROR_SUCCESS != dwErr)
        {
            goto done;
        }

        if(dwCount > 0)
        {
            RASAPI32_TRACE1("RasHangUp: Calling Custom hangup for 0x%x",
                   hrasconn);
            //
            // Call the custom dll entry point and bail
            //
            dwErr = DwCustomHangUp(szPhonebookPath,
                                   szEntryName,
                                   hrasconn);

            RASAPI32_TRACE1("RasHangUp: Custom hangup returned %d",
                   dwErr);

            goto done;
        }

        //
        // mark all links in this connection as Terminated
        // to prevent rasdial machine from trying to
        // connect on these links after the connection
        // has been Terminated.
        //
        EnterCriticalSection(&RasconncbListLock);

        for (pdtlnode = DtlGetFirstNode(PdtllistRasconncb);
             pdtlnode != NULL;
             pdtlnode = DtlGetNextNode(pdtlnode))
        {
            prasconncb = DtlGetData(pdtlnode);
            ASSERT(prasconncb);
            if ((HRASCONN)prasconncb->hrasconn == hrasconn)
            {
                prasconncb->fTerminated = TRUE;
            }
        }

        LeaveCriticalSection(&RasconncbListLock);

        //
        // Check to see if this has a prerequisite connection
        //
        RASAPI32_TRACE1("(HU) RasFindPrerequisiteEntry, 0x%x",
                hrasconn);

        dwErr = g_pRasFindPrerequisiteEntry(
                                (HCONN) hrasconn,
                                (HCONN *) &hConnPrereq);

        RASAPI32_TRACE3("(HU) RasFindPrerequisiteEntry, 0x%x. "
                "hConnPrereq=0x%x, rc=%d",
                hrasconn,
                hConnPrereq,
                dwErr);

        //
        // HangUp the connection. This will bring down the
        // the prerequisite connection if required in rasman.
        //
        dwErr = DwHangUpConnection(hrasconn);

        //
        // HangUp Prereq connection if any
        //
        if(hConnPrereq)
        {
            dwErr = DwHangUpConnection(hConnPrereq);
        }


    }

    if(     (ERROR_SUCCESS == dwErr)
        &&  (ERROR_SUCCESS != dwLastError))
    {
        dwErr = dwLastError;
    }

done:
    LeaveCriticalSection(&csStopLock);
    return (dwErr == ERROR_ACCESS_DENIED)
            ? ERROR_HANGUP_FAILED
            : dwErr;
}


DWORD APIENTRY
RasHangUpA(
    HRASCONN hrasconn )
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    return RasHangUpW( hrasconn );
}


DWORD APIENTRY
RasSetEntryDialParamsW(
    IN LPCWSTR          lpszPhonebook,
    IN LPRASDIALPARAMSW lprasdialparams,
    IN BOOL             fRemovePassword )

/*++

Routine Description:
    Sets cached RASDIALPARAM information.

Arguments:

Return Value:
    Returns 0 if successful, otherwise a non-0 error code.

--*/
{
    DWORD dwErr;
    PBFILE pbfile;
    DTLNODE *pdtlnode;
    PBENTRY *pEntry;
    DWORD dwMask;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasSetEntryDialParamsW");

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Validate parameters.
    //
    if (lprasdialparams == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    lprasdialparams->dwSize !=
            sizeof (RASDIALPARAMSW)

        &&  lprasdialparams->dwSize !=
            sizeof (RASDIALPARAMSW_V351)

        &&  lprasdialparams->dwSize !=
            sizeof (RASDIALPARAMSW_V400))
    {
        return ERROR_INVALID_SIZE;
    }

    //gangz
    //For secure password bug .Net 754400
    SafeEncodePasswordBuf(lprasdialparams->szPassword);

    //
    // Load the phonebook file.
    //
	// Initialize
	ZeroMemory(&pbfile, sizeof(pbfile));
    pbfile.hrasfile = -1;

    dwErr = GetPbkAndEntryName(
                lpszPhonebook,
                lprasdialparams->szEntryName,
                RPBF_NoCreate,
                &pbfile,
                &pdtlnode);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    //
    // Get the dialparams UID corresponding to the
    // entry.  The phonebook library guarantees this
    // value to be unique.
    //
    pEntry = (PBENTRY *)DtlGetData(pdtlnode);

    //
    // Set the dial parameters in rasman.
    // If the caller wants to clear the password
    // we have to do that in a separate rasman
    // call.
    //
    dwMask =    DLPARAMS_MASK_PHONENUMBER
            |   DLPARAMS_MASK_CALLBACKNUMBER
            |   DLPARAMS_MASK_USERNAME
            |   DLPARAMS_MASK_DOMAIN
            |   DLPARAMS_MASK_SUBENTRY
            |   DLPARAMS_MASK_OLDSTYLE;

    if (!fRemovePassword)
    {
        dwMask |= DLPARAMS_MASK_PASSWORD;
    }

    SafeDecodePasswordBuf(lprasdialparams->szPassword);

    dwErr = SetEntryDialParamsUID(
              pEntry->dwDialParamsUID,
              dwMask,
              lprasdialparams,
              FALSE);

    SafeEncodePasswordBuf(lprasdialparams->szPassword);
              
    if (dwErr)
    {
        goto done;
    }

    if (fRemovePassword)
    {
        dwMask =    DLPARAMS_MASK_PASSWORD
                |   DLPARAMS_MASK_OLDSTYLE;

        SafeDecodePasswordBuf(lprasdialparams->szPassword);
        
        dwErr = SetEntryDialParamsUID(
                  pEntry->dwDialParamsUID,
                  dwMask,
                  lprasdialparams,
                  TRUE);
                  
        SafeEncodePasswordBuf(lprasdialparams->szPassword);

        if (dwErr)
        {
            goto done;
        }
    }

    //
    // Write out the phonebook file.
    //
    dwErr = WritePhonebookFile(&pbfile, NULL);

done:
    //
    // Clean up.
    //
    SafeDecodePasswordBuf(lprasdialparams->szPassword);
    
    ClosePhonebookFile(&pbfile);

    return dwErr;
}


DWORD APIENTRY
RasSetEntryDialParamsA(
    IN LPCSTR           lpszPhonebook,
    IN LPRASDIALPARAMSA lprasdialparams,
    IN BOOL             fRemovePassword )

/*++

Routine Description:
    Sets cached RASDIALPARAM information.

Arguments:

Return Value:
    Returns 0 if successful, otherwise a non-0
    error code.

--*/

{
    NTSTATUS status;
    DWORD dwErr, dwcb;
    RASDIALPARAMSW rasdialparamsW;
    WCHAR szPhonebookW[MAX_PATH];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify parameters.
    //
    if (lprasdialparams == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    lprasdialparams->dwSize !=
            sizeof (RASDIALPARAMSA)

        &&  lprasdialparams->dwSize !=
            sizeof (RASDIALPARAMSA_V351)

        &&  lprasdialparams->dwSize !=
            sizeof (RASDIALPARAMSA_V400))
    {
        return ERROR_INVALID_SIZE;
    }


    //Encode the input password
    SafeEncodePasswordBuf(lprasdialparams->szPassword);
    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (lpszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    lpszPhonebook,
                    MAX_PATH);
    }

    //
    // Copy the fields from the A buffer into
    // the user's W buffer, taking into account
    // the version of the structure the user
    // passed in.
    //
    rasdialparamsW.dwSize = sizeof (RASDIALPARAMSW);

    if (lprasdialparams->dwSize ==
        sizeof (RASDIALPARAMSA_V351))
    {
        RASDIALPARAMSA_V351 *prdp =
            (RASDIALPARAMSA_V351 *)lprasdialparams;

        strncpyAtoWAnsi(rasdialparamsW.szEntryName,
                   prdp->szEntryName,
                   sizeof(rasdialparamsW.szEntryName) / sizeof(WCHAR));

        strncpyAtoWAnsi(rasdialparamsW.szPhoneNumber,
                   prdp->szPhoneNumber,
                   sizeof(rasdialparamsW.szPhoneNumber) / sizeof(WCHAR));

        strncpyAtoWAnsi(rasdialparamsW.szCallbackNumber,
                   prdp->szCallbackNumber,
                   sizeof(rasdialparamsW.szCallbackNumber) / sizeof(WCHAR));

        strncpyAtoWAnsi(rasdialparamsW.szUserName,
                   prdp->szUserName,
                   sizeof(rasdialparamsW.szUserName) / sizeof(WCHAR));


        SafeDecodePasswordBuf(prdp->szPassword);

        strncpyAtoWAnsi(rasdialparamsW.szPassword,
                   prdp->szPassword,
                   sizeof(rasdialparamsW.szPassword) / sizeof(WCHAR));

        SafeEncodePasswordBuf(prdp->szPassword);
        SafeEncodePasswordBuf(rasdialparamsW.szPassword);
        
        strncpyAtoWAnsi(rasdialparamsW.szDomain,
                   prdp->szDomain,
                   sizeof(rasdialparamsW.szDomain) / sizeof(WCHAR));
    }
    else
    {
        strncpyAtoWAnsi(rasdialparamsW.szEntryName,
                   lprasdialparams->szEntryName,
                   sizeof(rasdialparamsW.szEntryName) / sizeof(WCHAR));

        strncpyAtoWAnsi(rasdialparamsW.szPhoneNumber,
                   lprasdialparams->szPhoneNumber,
                   sizeof(rasdialparamsW.szPhoneNumber) / sizeof(WCHAR));

        strncpyAtoWAnsi(rasdialparamsW.szCallbackNumber,
                   lprasdialparams->szCallbackNumber,
                   sizeof(rasdialparamsW.szCallbackNumber) / sizeof(WCHAR));

        strncpyAtoWAnsi(rasdialparamsW.szUserName,
                   lprasdialparams->szUserName,
                   sizeof(rasdialparamsW.szUserName) / sizeof(WCHAR));

        SafeDecodePasswordBuf(lprasdialparams->szPassword);
        
        strncpyAtoWAnsi(rasdialparamsW.szPassword,
                   lprasdialparams->szPassword,
                   sizeof(rasdialparamsW.szPassword) / sizeof(WCHAR));

        SafeEncodePasswordBuf(lprasdialparams->szPassword);
        SafeEncodePasswordBuf(rasdialparamsW.szPassword);

        strncpyAtoWAnsi(rasdialparamsW.szDomain,
                   lprasdialparams->szDomain,
                   sizeof(rasdialparamsW.szDomain) / sizeof(WCHAR));
    }

    if (lprasdialparams->dwSize == sizeof (RASDIALPARAMSA))
    {
        rasdialparamsW.dwSubEntry =
            lprasdialparams->dwSubEntry;
    }
    else
    {
        rasdialparamsW.dwSubEntry = 1;
    }

    //
    // Call the W version to do the work.
    //
    SafeDecodePasswordBuf(rasdialparamsW.szPassword);
    
    dwErr = RasSetEntryDialParamsW(
              lpszPhonebook != NULL
              ? szPhonebookW
              : NULL,
              &rasdialparamsW,
              fRemovePassword);

    SafeWipePasswordBuf(rasdialparamsW.szPassword);
    
    SafeDecodePasswordBuf(lprasdialparams->szPassword);

    return dwErr;
}


DWORD APIENTRY
RasSetOldPassword(
    IN HRASCONN hrasconn,
    IN CHAR*    pszPassword )

/*++

Routine Description:
    Allows user to explicitly set the "old" password prior to
    resuming a RasDial session paused due to password expiration.
    This allows change password to successfully complete in the
    "automatically use current username/password" case, where
    user has not already entered his clear text password.
    The clear text password is required to change the password.


Arguments:


Return Value
    Returns 0 if successful, otherwise a non-0 error code.

Notes:
    Change password for the auto-logon case was broken in NT31
    and NT35 and this is a somewhat hackish fix that avoids
    changing the published RAS APIs which will still work as
    before and as documented for the non-auto-logon cases.
    Otherwise public structures would need to to be reved
    introducing backward compatibility issues that just
    aren't worth it for this obscure problem.  This issue
    should be addressed in the next RAS API functionality
    update.

--*/
{
    RASCONNCB* prasconncb;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasSetOldPassword");

    prasconncb = ValidateHrasconn( hrasconn );

    if (!prasconncb)
    {
        return ERROR_INVALID_HANDLE;
    }

    SafeWipePasswordBuf(prasconncb->szOldPassword);
    strncpyAtoW(
        prasconncb->szOldPassword,
        pszPassword,
        sizeof(prasconncb->szOldPassword) / sizeof(WCHAR));

    SafeEncodePasswordBuf (prasconncb->szOldPassword);

    prasconncb->fOldPasswordSet = TRUE;

    return 0;
}


DWORD APIENTRY
RasEnumDevicesW(
    OUT    LPRASDEVINFOW lpRasDevInfo,
    IN OUT LPDWORD lpdwcb,
    OUT    LPDWORD lpdwcDevices
    )
{
    DWORD dwErr, dwSize;
    DWORD dwPorts;
    DWORD i,j = 0;
    RASMAN_PORT *pports, *pport;
    DWORD dwCallOutPorts = 0;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasEnumDevicesW");

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Verify parameters.
    //
    if (    lpRasDevInfo != NULL
        &&  lpRasDevInfo->dwSize != sizeof (RASDEVINFOW))
    {
        return ERROR_INVALID_SIZE;
    }

    if (    lpdwcb == NULL
        ||  lpdwcDevices == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    lpRasDevInfo != NULL
        && *lpdwcb < lpRasDevInfo->dwSize)
    {
        return ERROR_BUFFER_TOO_SMALL;
    }

    //
    // Get the port information from RASMAN.
    //
    dwErr = GetRasPorts(NULL, &pports, &dwPorts);

    if (dwErr)
    {
        return dwErr;
    }

    //
    // We want to enum only call out devices.
    // - RAID BUG 85434
    //

    for (i = 0, pport = pports; i < dwPorts; i++, pport++)
    {
        if ( pport->P_ConfiguredUsage & CALL_OUT )
        {
            dwCallOutPorts += 1;
        }
    }

    //
    // Make sure the caller's buffer is large enough.
    //
    dwSize = dwCallOutPorts * sizeof (RASDEVINFOW);

    if (    lpRasDevInfo == NULL
        ||  *lpdwcb < dwSize)
    {

        Free(pports);

        *lpdwcb         = dwSize;
        *lpdwcDevices   = dwCallOutPorts;

        return ERROR_BUFFER_TOO_SMALL;
    }

    *lpdwcb         = dwSize;
    *lpdwcDevices   = dwCallOutPorts;

    //
    // Enumerate the ports and fill in the user's buffer.
    //
    for (i = 0, pport = pports; i < dwPorts; i++, pport++)
    {

        TCHAR szDeviceType[RAS_MaxDeviceType + 1];

        TCHAR szDeviceName[RAS_MaxDeviceName + 1];

        TCHAR szNewDeviceName[RAS_MaxDeviceName + 1];

        TCHAR szPortName[MAX_PORT_NAME];

        TCHAR *pszDeviceType = NULL;

        //
        // Skip the ports that are not CALL_OUT
        //
        if ( ( pport->P_ConfiguredUsage & CALL_OUT ) == 0 )
        {
            continue;
        }

        lpRasDevInfo[j].dwSize = sizeof (RASDEVINFOW);

        pszDeviceType = pszDeviceTypeFromRdt(
                            pport->P_rdtDeviceType);

        if(NULL != pszDeviceType)
        {

            lstrcpyn(lpRasDevInfo[j].szDeviceType,
                    pszDeviceType,
                    sizeof(lpRasDevInfo[j].szDeviceType) / sizeof(WCHAR));

            Free(pszDeviceType);
        }
        else
        {
            strncpyAtoTAnsi(lpRasDevInfo[j].szDeviceType,
                           pport->P_DeviceType,
                           sizeof(lpRasDevInfo[j].szDeviceType) /
                             sizeof(WCHAR));
        }

        _tcslwr(lpRasDevInfo[j].szDeviceType);

        strncpyAtoTAnsi(szDeviceName,
                   pport->P_DeviceName,
                   sizeof(szDeviceName) / sizeof(WCHAR));

        strncpyAtoTAnsi(szPortName,
                   pport->P_PortName,
                   sizeof(szPortName) / sizeof(WCHAR));

        SetDevicePortName(szDeviceName,
                          szPortName,
                          szNewDeviceName);

        strncpyTtoWAnsi(lpRasDevInfo[j].szDeviceName,
                   szNewDeviceName,
                   sizeof(lpRasDevInfo[j].szDeviceName) / sizeof(WCHAR));

        RasGetUnicodeDeviceName(pport->P_Handle,
                                lpRasDevInfo[j].szDeviceName);

        j += 1;
    }

    Free(pports);

    return 0;
}


DWORD APIENTRY
RasEnumDevicesA(
    OUT LPRASDEVINFOA lpRasDevInfo,
    IN OUT LPDWORD lpdwcb,
    OUT LPDWORD lpdwcDevices
    )
{
    DWORD dwcb, dwErr, i;
    LPRASDEVINFOW lpRasDevInfoW = NULL;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify parameters.
    //
    if (    lpRasDevInfo != NULL
        &&  lpRasDevInfo->dwSize != sizeof (RASDEVINFOA))
    {
        return ERROR_INVALID_SIZE;
    }

    if (    lpdwcb == NULL
        ||  lpdwcDevices == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    lpRasDevInfo != NULL
        && *lpdwcb < lpRasDevInfo->dwSize)
    {
        return ERROR_BUFFER_TOO_SMALL;
    }

    //
    // Allocate the same number of entries
    // in the W buffer as the user passed
    // in with the A buffer.
    //
    dwcb =    (*lpdwcb / sizeof (RASDEVINFOA))
            * sizeof (RASDEVINFOW);

    if (lpRasDevInfo != NULL)
    {
        lpRasDevInfoW = (LPRASDEVINFOW)Malloc(dwcb);

        if (lpRasDevInfoW == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        lpRasDevInfoW->dwSize = sizeof (RASDEVINFOW);
    }

    //
    // Call the W version to do the work.
    //
    dwErr = RasEnumDevicesW(lpRasDevInfoW,
                            &dwcb,
                            lpdwcDevices);
    if (    !dwErr
        &&  lpRasDevInfo != NULL)
    {
        //
        // Copy the strings to the user's buffer.
        //
        for (i = 0; i < *lpdwcDevices; i++)
        {
            lpRasDevInfo[i].dwSize = sizeof (LPRASDEVINFOA);

            strncpyWtoAAnsi(lpRasDevInfo[i].szDeviceType,
                       lpRasDevInfoW[i].szDeviceType,
                       sizeof(lpRasDevInfo[i].szDeviceType));

            strncpyWtoAAnsi(lpRasDevInfo[i].szDeviceName,
                       lpRasDevInfoW[i].szDeviceName,
                       sizeof(lpRasDevInfo[i].szDeviceName));
        }
    }

    *lpdwcb = *lpdwcDevices * sizeof (RASDEVINFOA);

    //
    // Free the W buffer.
    //
    Free(lpRasDevInfoW);

    return dwErr;
}


DWORD APIENTRY
RasGetCountryInfoW(
    IN OUT LPRASCTRYINFOW lpRasCtryInfo,
    IN OUT LPDWORD lpdwcb
    )
{
    DWORD dwErr, dwcb, dwcbOrig;
    LINECOUNTRYLIST lineCountryList;

    LPLINECOUNTRYLIST lpLineCountryList = NULL;

    LPLINECOUNTRYENTRY lpLineCountryEntry;

    PWCHAR pEnd, lpszCountryName;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetCountryInfoW");

    //
    // Verify parameters.
    //
    if (    lpRasCtryInfo == NULL
        ||  lpdwcb == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    (*lpdwcb < sizeof(RASCTRYINFOW))
        ||  (lpRasCtryInfo->dwSize != sizeof (RASCTRYINFOW)))
    {
        return ERROR_INVALID_SIZE;
    }

    //
    // dwCountryId cannot be 0, since that tells
    // TAPI to return the entire table.  We only
    // want to return one structure at a time.
    //
    if (lpRasCtryInfo->dwCountryID == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Call TAPI to get the size of
    // the buffer needed.
    //
    RtlZeroMemory(&lineCountryList,
                  sizeof (lineCountryList));

    lineCountryList.dwTotalSize =
            sizeof (lineCountryList);

    dwErr = lineGetCountry(
              lpRasCtryInfo->dwCountryID,
              TAPIVERSION,
              &lineCountryList);
    //
    // The spec says if the dwCountryID is
    // invalid, return ERROR_INVALID_PARAMETER.
    //
    if (    dwErr
        || !lineCountryList.dwNeededSize)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Allocate the buffer required.
    //
    lpLineCountryList = Malloc(
            lineCountryList.dwNeededSize
            );

    if (lpLineCountryList == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize the new buffer and
    // make the call again to get the
    // real information.
    //
    lpLineCountryList->dwTotalSize =
            lineCountryList.dwNeededSize;

    dwErr = lineGetCountry(
              lpRasCtryInfo->dwCountryID,
              TAPIVERSION,
              lpLineCountryList);
    if (dwErr)
    {
        goto done;
    }

    lpLineCountryEntry =   (LPLINECOUNTRYENTRY)
                           ((ULONG_PTR)lpLineCountryList
                         + lpLineCountryList->dwCountryListOffset);

    //
    // Determine if the user's buffer is large enough.
    //
    dwcb = sizeof (RASCTRYINFOW) +
             ((lpLineCountryEntry->dwCountryNameSize + 1)
             * sizeof (WCHAR));

    if (*lpdwcb < dwcb)
    {
        dwErr = ERROR_BUFFER_TOO_SMALL;
    }

    //
    // Save off the size that the caller passed for use in the copy below
    //
    dwcbOrig = *lpdwcb;
    *lpdwcb = dwcb;
    if (dwErr)
    {
        goto done;
    }

    //
    // Fill in the user's buffer with the
    // necessary information.
    //
    lpRasCtryInfo->dwSize = sizeof (RASCTRYINFOW);

    lpRasCtryInfo->dwNextCountryID =
        lpLineCountryEntry->dwNextCountryID;

    lpRasCtryInfo->dwCountryCode =
        lpLineCountryEntry->dwCountryCode;

    pEnd = (PWCHAR)((ULONG_PTR)lpRasCtryInfo
                    + sizeof (RASCTRYINFOW));

    lpRasCtryInfo->dwCountryNameOffset =
                        (DWORD)((ULONG_PTR) pEnd - (ULONG_PTR) lpRasCtryInfo);

    lpszCountryName = (PWCHAR)((ULONG_PTR)lpLineCountryList
                    + lpLineCountryEntry->dwCountryNameOffset);

    lstrcpyn(
        (WCHAR*)pEnd,
        (WCHAR*)lpszCountryName,
        (INT )(((PWCHAR )lpRasCtryInfo + dwcbOrig) - pEnd));

done:

    if(NULL != lpLineCountryList)
    {
        Free(lpLineCountryList);
    }
    return dwErr;
}


DWORD APIENTRY
RasGetCountryInfoA(
    OUT LPRASCTRYINFOA lpRasCtryInfo,
    OUT LPDWORD lpdwcb
    )
{
    DWORD dwErr, dwcb, dwcbOrig;
    LPRASCTRYINFOW lpRasCtryInfoW;
    PCHAR pszCountryName;
    PWCHAR pwszCountryName;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify parameters.
    //
    if (    lpRasCtryInfo == NULL
        ||  lpdwcb == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (lpRasCtryInfo->dwSize != sizeof (RASCTRYINFOA))
    {
        return ERROR_INVALID_SIZE;
    }

    //
    // Determine the number of bytes
    // we should allocate for the W buffer.
    // Convert the size of the extra bytes
    // at the end from A to W.
    //
    if (*lpdwcb >= sizeof (RASCTRYINFOA))
    {
        dwcb =    sizeof (RASCTRYINFOW)
                + ( (*lpdwcb - sizeof (RASCTRYINFOA))
                   * sizeof (WCHAR));
    }
    else
    {
        dwcb = sizeof (RASCTRYINFOW);
    }

    lpRasCtryInfoW = (LPRASCTRYINFOW) Malloc(dwcb);

    if (lpRasCtryInfoW == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Call the W version to do all the work.
    //
    lpRasCtryInfoW->dwSize = sizeof (RASCTRYINFOW);

    lpRasCtryInfoW->dwCountryID =
                lpRasCtryInfo->dwCountryID;

    dwErr = RasGetCountryInfoW(lpRasCtryInfoW, &dwcb);

    if (!dwcb)
    {
        *lpdwcb = 0;
        goto done;
    }

    //
    // Set *lpdwcb before we return on any error.
    //
    dwcb =    sizeof (RASCTRYINFOA)
            + ((dwcb - sizeof (RASCTRYINFOW)) / sizeof (WCHAR));

    if (*lpdwcb < dwcb)
    {
        dwErr = ERROR_BUFFER_TOO_SMALL;
    }

    //
    // Save off the size that the caller passed for use in the copy below
    //
    dwcbOrig = *lpdwcb;
    *lpdwcb = dwcb;
    if (dwErr)
    {
        goto done;
    }

    //
    // Copy the fields from the W buffer
    // to the A buffer.
    //
    lpRasCtryInfo->dwSize = sizeof (RASCTRYINFOA);

    lpRasCtryInfo->dwNextCountryID =
            lpRasCtryInfoW->dwNextCountryID;

    lpRasCtryInfo->dwCountryCode =
            lpRasCtryInfoW->dwCountryCode;

    //
    // Note the next 3 statements assumes the
    // W and A structure sizes are the same!
    //
    lpRasCtryInfo->dwCountryNameOffset =
        lpRasCtryInfoW->dwCountryNameOffset;

    pszCountryName =
      (PCHAR)((ULONG_PTR)lpRasCtryInfo
      + lpRasCtryInfo->dwCountryNameOffset);

    pwszCountryName =
      (PWCHAR)((ULONG_PTR)lpRasCtryInfoW
      + lpRasCtryInfoW->dwCountryNameOffset);

    strncpyWtoAAnsi(
        pszCountryName,
        pwszCountryName,
        (INT )(((PCHAR )lpRasCtryInfo + dwcbOrig) - pszCountryName));

done:
    Free(lpRasCtryInfoW);
    return dwErr;
}


DWORD APIENTRY
RasGetEntryPropertiesA(
    IN     LPCSTR       lpszPhonebook,
    IN     LPCSTR       lpszEntry,
    OUT    LPRASENTRYA  lpRasEntry,
    IN OUT LPDWORD      lpcbRasEntry,
    OUT    LPBYTE       lpbDeviceConfig,
    IN OUT LPDWORD      lpcbDeviceConfig
    )
{
    NTSTATUS status;

    DWORD dwcb, dwErr;

    LPRASENTRYW lpRasEntryW = NULL;

    WCHAR szPhonebookW[MAX_PATH],
          szEntryNameW[RAS_MaxEntryName + 1];

    BOOL fv50 = TRUE;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify parameters.
    //
    if (lpcbRasEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    (lpRasEntry != NULL)
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYA))
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYA_V500))
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYA_V401))
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYA_V400)))
    {
        return ERROR_INVALID_SIZE;
    }

    if (    lpRasEntry != NULL
        &&  *lpcbRasEntry < lpRasEntry->dwSize)
    {
        return ERROR_BUFFER_TOO_SMALL;
    }

    if (    (lpRasEntry != NULL)
        &&  (   (sizeof(RASENTRYA_V401) == lpRasEntry->dwSize)
            ||  (sizeof(RASENTRYA_V400) == lpRasEntry->dwSize)))
    {
        fv50 = FALSE;
    }

    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (lpszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    lpszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the lpszEntry string to Unicode.
    //
    if (lpszEntry != NULL)
    {
        strncpyAtoWAnsi(szEntryNameW,
                    lpszEntry,
                    RAS_MaxEntryName + 1);
    }

    //
    // Determine the size of the W buffer
    // by calculating how many extra CHARs
    // the caller appended onto the end of the
    // A buffer for the alternate phone numbers.
    //
    if (*lpcbRasEntry < sizeof (RASENTRYA))
    {
        dwcb = sizeof (RASENTRYA);
    }
    else
    {
        dwcb = *lpcbRasEntry;
    }

    dwcb = sizeof (RASENTRYW)
         + ((dwcb - sizeof (RASENTRYA)) * sizeof (WCHAR));

    if (lpRasEntry != NULL)
    {
        lpRasEntryW = (LPRASENTRYW)Malloc(dwcb);

        if (lpRasEntryW == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Initialize the W buffer.
        //
        lpRasEntryW->dwSize = sizeof (RASENTRYW);
    }

    //
    // Call the W version to do the work.
    //
    dwErr = RasGetEntryPropertiesW(
              (lpszPhonebook != NULL) ? szPhonebookW : NULL,
              (lpszEntry != NULL) ? szEntryNameW : NULL,
              lpRasEntryW,
              &dwcb,
              lpbDeviceConfig,
              lpcbDeviceConfig);

    if (    !dwErr
        &&  lpRasEntry != NULL)
    {
        //
        // Copy the fields from the W buffer into
        // the user's A buffer.
        //
        lpRasEntry->dwfOptions = lpRasEntryW->dwfOptions;

        lpRasEntry->dwCountryID = lpRasEntryW->dwCountryID;

        lpRasEntry->dwCountryCode = lpRasEntryW->dwCountryCode;

        lpRasEntry->ipaddr = lpRasEntryW->ipaddr;

        lpRasEntry->ipaddrDns = lpRasEntryW->ipaddrDns;

        lpRasEntry->ipaddrDnsAlt = lpRasEntryW->ipaddrDnsAlt;

        lpRasEntry->ipaddrWins = lpRasEntryW->ipaddrWins;

        lpRasEntry->ipaddrWinsAlt = lpRasEntryW->ipaddrWinsAlt;

        lpRasEntry->dwFrameSize = lpRasEntryW->dwFrameSize;

        lpRasEntry->dwfNetProtocols = lpRasEntryW->dwfNetProtocols;

        lpRasEntry->dwFramingProtocol = lpRasEntryW->dwFramingProtocol;

        strncpyWtoAAnsi(lpRasEntry->szScript,
                   lpRasEntryW->szScript,
                   sizeof(lpRasEntry->szScript));

        strncpyWtoAAnsi(lpRasEntry->szX25PadType,
                   lpRasEntryW->szX25PadType,
                   sizeof(lpRasEntry->szX25PadType));

        strncpyWtoAAnsi(lpRasEntry->szX25Address,
                   lpRasEntryW->szX25Address,
                   sizeof(lpRasEntry->szX25Address));

        strncpyWtoAAnsi(lpRasEntry->szX25Facilities,
                   lpRasEntryW->szX25Facilities,
                   sizeof(lpRasEntry->szX25Facilities));

        strncpyWtoAAnsi(lpRasEntry->szX25UserData,
                   lpRasEntryW->szX25UserData,
                   sizeof(lpRasEntry->szX25UserData));

        strncpyWtoAAnsi(lpRasEntry->szAutodialDll,
                   lpRasEntryW->szAutodialDll,
                   sizeof(lpRasEntry->szAutodialDll));

        strncpyWtoAAnsi(lpRasEntry->szAutodialFunc,
                   lpRasEntryW->szAutodialFunc,
                   sizeof(lpRasEntry->szAutodialFunc));

        strncpyWtoAAnsi(lpRasEntry->szAreaCode,
                   lpRasEntryW->szAreaCode,
                   sizeof(lpRasEntry->szAreaCode));

        strncpyWtoAAnsi(lpRasEntry->szLocalPhoneNumber,
                   lpRasEntryW->szLocalPhoneNumber,
                   sizeof(lpRasEntry->szLocalPhoneNumber));

        strncpyWtoAAnsi(lpRasEntry->szDeviceType,
                   lpRasEntryW->szDeviceType,
                   sizeof(lpRasEntry->szDeviceType));

        strncpyWtoAAnsi(lpRasEntry->szDeviceName,
                   lpRasEntryW->szDeviceName,
                   sizeof(lpRasEntry->szDeviceName));

        if (fv50)
        {
            //
            // Guid
            //
            lpRasEntry->guidId = lpRasEntryW->guidId;

            //
            // Entry Type
            //
            lpRasEntry->dwType = lpRasEntryW->dwType;

            //
            // Encryption Type
            //
            lpRasEntry->dwEncryptionType =
                lpRasEntryW->dwEncryptionType;

            //
            // CustomAuthKey for EAP
            //
            if(lpRasEntry->dwfOptions & RASEO_RequireEAP)
            {
                lpRasEntry->dwCustomAuthKey =
                    lpRasEntryW->dwCustomAuthKey;
            }

            //
            // Custom dial dll
            //
            strncpyWtoAAnsi(lpRasEntry->szCustomDialDll,
                       lpRasEntryW->szCustomDialDll,
                       sizeof(lpRasEntry->szCustomDialDll));

            //
            // Entry Properties
            //
            lpRasEntry->dwVpnStrategy = lpRasEntryW->dwVpnStrategy;
        }
        else
        {
            //
            // Zero out the nt5 flags
            //
            lpRasEntry->dwfOptions &= ~(  RASEO_RequireEAP
                                        | RASEO_RequirePAP
                                        | RASEO_RequireSPAP
                                        | RASEO_PreviewPhoneNumber
                                        | RASEO_SharedPhoneNumbers
                                        | RASEO_PreviewUserPw
                                        | RASEO_PreviewDomain
                                        | RASEO_ShowDialingProgress
                                        | RASEO_Custom);

        }

        if(lpRasEntry->dwSize == sizeof(RASENTRYA))
        {
            lpRasEntry->dwfOptions2 = lpRasEntryW->dwfOptions2;
            strncpyWtoAAnsi(lpRasEntry->szDnsSuffix,
                           lpRasEntryW->szDnsSuffix,
                           sizeof(lpRasEntry->szDnsSuffix));
            lpRasEntry->dwTcpWindowSize = lpRasEntryW->dwTcpWindowSize;                           

            strncpyWtoAAnsi(lpRasEntry->szPrerequisitePbk,
                            lpRasEntryW->szPrerequisitePbk,
                            sizeof(lpRasEntry->szPrerequisitePbk));

            strncpyWtoAAnsi(lpRasEntry->szPrerequisiteEntry,
                            lpRasEntryW->szPrerequisiteEntry,
                            sizeof(lpRasEntry->szPrerequisiteEntry));

            lpRasEntry->dwRedialCount = lpRasEntryW->dwRedialCount; 
            lpRasEntry->dwRedialPause = lpRasEntryW->dwRedialPause;
        }

        //
        // Copy the alternate phone numbers to the
        // user's buffer, if any.
        //
        if (lpRasEntryW->dwAlternateOffset)
        {
            DWORD dwcbPhoneNumber;

            PCHAR pszPhoneNumber;

            WCHAR UNALIGNED *pwszPhoneNumber;

            lpRasEntry->dwAlternateOffset = sizeof (RASENTRYA);

            pwszPhoneNumber =
              (PWCHAR)((ULONG_PTR)lpRasEntryW +
                lpRasEntryW->dwAlternateOffset);

            pszPhoneNumber =
              (PCHAR)((ULONG_PTR)lpRasEntry +
                lpRasEntry->dwAlternateOffset);

            while (*pwszPhoneNumber != L'\0')
            {
                WCHAR *pwsz = strdupWU(pwszPhoneNumber);

                if (pwsz == NULL)
                {
                    dwErr = GetLastError();
                    goto done;
                }

                dwcbPhoneNumber = wcslen(pwsz);

                strncpyWtoAAnsi(
                    pszPhoneNumber,
                    pwsz,
                    (INT )(((PCHAR )lpRasEntry + *lpcbRasEntry) -
                        pszPhoneNumber));

                Free(pwsz);

                pwszPhoneNumber += dwcbPhoneNumber + 1;

                pszPhoneNumber += dwcbPhoneNumber + 1;
            }

            //
            // Add another null to terminate
            // the list.
            //
            *pszPhoneNumber = '\0';
        }
        else
        {
            lpRasEntry->dwAlternateOffset = 0;
        }

        //
        // Copy the following fields only for
        // a V401 structure or higher
        //
        if (    (lpRasEntry->dwSize == sizeof (RASENTRYA))
            ||  (lpRasEntry->dwSize == sizeof (RASENTRYA_V500))
            ||  (lpRasEntry->dwSize == sizeof (RASENTRYA_V401)))
        {
            lpRasEntry->dwSubEntries = lpRasEntryW->dwSubEntries;

            lpRasEntry->dwDialMode = lpRasEntryW->dwDialMode;

            lpRasEntry->dwDialExtraPercent =
                        lpRasEntryW->dwDialExtraPercent;

            lpRasEntry->dwDialExtraSampleSeconds =
                    lpRasEntryW->dwDialExtraSampleSeconds;

            lpRasEntry->dwHangUpExtraPercent =
                        lpRasEntryW->dwHangUpExtraPercent;

            lpRasEntry->dwHangUpExtraSampleSeconds =
                    lpRasEntryW->dwHangUpExtraSampleSeconds;

            lpRasEntry->dwIdleDisconnectSeconds =
                    lpRasEntryW->dwIdleDisconnectSeconds;
        }

    }

    //
    // Perform the inverse calculation we did
    // above to translate the A size from the W
    // size.
    //
done:
    *lpcbRasEntry = sizeof (RASENTRYA) +
                ((dwcb - sizeof (RASENTRYW)) / sizeof (WCHAR));
    //
    // Free the temporary W buffers.
    //
    Free(lpRasEntryW);

    return dwErr;
}


DWORD APIENTRY
RasGetEntryPropertiesW(
    IN     LPCWSTR      lpszPhonebook,
    IN     LPCWSTR      lpszEntry,
    OUT    LPRASENTRYW  lpRasEntry,
    IN OUT LPDWORD      lpcbRasEntry,
    OUT    LPBYTE       lpbDeviceConfig,
    IN OUT LPDWORD      lpcbDeviceConfig
    )
{
    DWORD   dwErr;
    DTLNODE *pdtlnode = NULL;
    PBENTRY *pEntry;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetEntryPropertiesW");

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Validate parameters.
    //
    if (lpcbRasEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    (lpRasEntry != NULL)
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYW))
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYW_V500))
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYW_V401))
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYW_V400)))
    {
        return ERROR_INVALID_SIZE;
    }

    if (    (lpRasEntry != NULL)
        &&  (*lpcbRasEntry < lpRasEntry->dwSize))
    {
        return ERROR_BUFFER_TOO_SMALL;
    }

    //
    // Initialize return value if supplied.
    //
    if (lpcbDeviceConfig != NULL)
    {
        *lpcbDeviceConfig = 0;
    }

    if (    (lpszEntry == NULL)
        ||  (*lpszEntry == '\0'))
    {
        //
        // If lpszEntry is NULL, initialize an
        // entry with defaults.  Othersize, look
        // up the entry.
        //
        pdtlnode = CreateEntryNode(TRUE);

        if (pdtlnode == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }
    }
    else
    {
        //
        // Load the phonebook file.
        //

        dwErr = ReadEntryFromSystem(
                        lpszPhonebook,
                        lpszEntry,
                        RPBF_NoCreate,
                        NULL,
                        &pdtlnode,
                        NULL);

        if(SUCCESS != dwErr)
        {
            goto done;
        }

    }
    
    pEntry = (PBENTRY *)DtlGetData(pdtlnode);

    //
    // Convert the PBENTRY into a RASENTRY.
    //
    dwErr = PhonebookEntryToRasEntry(
              pEntry,
              lpRasEntry,
              lpcbRasEntry,
              lpbDeviceConfig,
              lpcbDeviceConfig);

done:
    //
    // Clean up.
    //
    if (pdtlnode)
    {
        DestroyEntryNode(pdtlnode);
    }

    return dwErr;
}


DWORD APIENTRY
RasSetEntryPropertiesW(
    IN LPCWSTR      lpszPhonebook,
    IN LPCWSTR      lpszEntry,
    IN LPRASENTRYW  lpRasEntry,
    IN DWORD        dwcbRasEntry,
    IN LPBYTE       lpbDeviceConfig,
    IN DWORD        dwcbDeviceConfig
    )
{
    DWORD dwErr;
    PBFILE pbfile;
    DTLNODE *pdtlnode;
    PBENTRY *pEntry;
    BOOL fCreated = FALSE;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();
    ZeroMemory(&pbfile, sizeof(pbfile));
    pbfile.hrasfile = -1;

    RASAPI32_TRACE("RasSetEntryPropertiesW");

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Validate parameters.
    //
    if (lpRasEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    (lpRasEntry->dwSize != sizeof (RASENTRYW))
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYW_V500))
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYW_V401))
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYW_V400)))
        
    {
        return ERROR_INVALID_SIZE;
    }

    if (dwcbRasEntry < lpRasEntry->dwSize)
    {
        return ERROR_BUFFER_TOO_SMALL;
    }

    //
    // Load the phonebook file.
    //
    dwErr = GetPbkAndEntryName(
                    lpszPhonebook,
                    lpszEntry,
                    0,
                    &pbfile,
                    &pdtlnode);

    if(     (SUCCESS != dwErr)
        &&  (ERROR_CANNOT_FIND_PHONEBOOK_ENTRY != dwErr))
    {
        return dwErr;
    }

    if (pdtlnode != NULL)
    {
        DTLNODE *pdtlnodeNew;

        pdtlnodeNew = DuplicateEntryNode(pdtlnode);

        DtlRemoveNode(pbfile.pdtllistEntries, pdtlnode);

        DestroyEntryNode(pdtlnode);

        pdtlnode = pdtlnodeNew;
    }
    else
    {   
        DWORD dwPbkFlags = 0;

        if ((NULL == lpszPhonebook) && IsConsumerPlatform())
        {
            dwPbkFlags |= RPBF_AllUserPbk;
        }
        
        dwErr = ReadPhonebookFile(lpszPhonebook,
                          NULL,
                          NULL,
                          dwPbkFlags,
                          &pbfile);

        if(dwErr)
        {
            return ERROR_CANNOT_OPEN_PHONEBOOK;
        }
        
        pdtlnode = CreateEntryNode(TRUE);

        fCreated = TRUE;
    }

    if (pdtlnode == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    //
    // Add the node to the list of entries.
    //
    DtlAddNodeLast(pbfile.pdtllistEntries, pdtlnode);

    pEntry = (PBENTRY *)DtlGetData(pdtlnode);

    ASSERT(pEntry);

    //
    // Convert the RASENTRY to a PBENTRY.
    //
    dwErr = RasEntryToPhonebookEntry(
              lpszEntry,
              lpRasEntry,
              dwcbRasEntry,
              lpbDeviceConfig,
              dwcbDeviceConfig,
              pEntry);
    if (dwErr)
    {
        goto done;
    }

    //
    // Write out the phonebook file.
    //
    dwErr = WritePhonebookFile(&pbfile, NULL);

    if(ERROR_SUCCESS == dwErr)
    {
        dwErr = DwSendRasNotification(
                    (fCreated)
                    ? ENTRY_ADDED
                    : ENTRY_MODIFIED,
                    pEntry,
                    pbfile.pszPath,
                    NULL);

        dwErr = ERROR_SUCCESS;
    }

done:
    //
    // Clean up.
    //
    ClosePhonebookFile(&pbfile);

    return dwErr;
}


DWORD APIENTRY
RasSetEntryPropertiesA(
    IN LPCSTR       lpszPhonebook,
    IN LPCSTR       lpszEntry,
    IN LPRASENTRYA  lpRasEntry,
    IN DWORD        dwcbRasEntry,
    IN LPBYTE       lpbDeviceConfig,
    IN DWORD        dwcbDeviceConfig
    )
{
    NTSTATUS    status;
    DWORD       dwErr,
                dwcb;
    LPRASENTRYW lpRasEntryW;
    WCHAR       szPhonebookW[MAX_PATH],
                szEntryNameW[RAS_MaxEntryName + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify parameters.
    //
    if (lpRasEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    (lpRasEntry->dwSize != sizeof (RASENTRYA))
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYA_V500))
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYA_V401))
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYA_V400)))
    {
        return ERROR_INVALID_SIZE;
    }

    if (dwcbRasEntry < lpRasEntry->dwSize)
    {
        return ERROR_BUFFER_TOO_SMALL;
    }

    //
    // We don't handle the device
    // configuration parameters yet.
    //
    UNREFERENCED_PARAMETER(lpbDeviceConfig);
    UNREFERENCED_PARAMETER(dwcbDeviceConfig);

    //
    // Convert the lpszPhonebook string to
    // Unicode.
    //
    if (lpszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    lpszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the lpszEntry string to Unicode.
    //
    if (lpszEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    strncpyAtoWAnsi(szEntryNameW,
                lpszEntry,
                RAS_MaxEntryName + 1);

    //
    // Determine the size of the W buffer
    // by calculating how many extra CHARs
    // the caller appended onto the end of the
    // A buffer for the alternate phone numbers.
    //
    dwcb =    sizeof (RASENTRYW)
            +
             ( (dwcbRasEntry - lpRasEntry->dwSize)
             * sizeof (WCHAR));

    if (lpRasEntry != NULL)
    {
        lpRasEntryW = (LPRASENTRYW)Malloc(dwcb);

        if (lpRasEntryW == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // ZeroMem the rasentryw structure
        //
        ZeroMemory(lpRasEntryW, dwcb);

        //
        // Initialize the W buffer.
        //
        lpRasEntryW->dwSize = sizeof (RASENTRYW);
    }

    //
    // Copy the fields from the A buffer into
    // the user's W buffer.
    //
    lpRasEntryW->dwSize = sizeof (RASENTRYW);

    lpRasEntryW->dwfOptions = lpRasEntry->dwfOptions;

    lpRasEntryW->dwCountryID = lpRasEntry->dwCountryID;

    lpRasEntryW->dwCountryCode = lpRasEntry->dwCountryCode;

    lpRasEntryW->ipaddr = lpRasEntry->ipaddr;

    lpRasEntryW->ipaddrDns = lpRasEntry->ipaddrDns;

    lpRasEntryW->ipaddrDnsAlt = lpRasEntry->ipaddrDnsAlt;

    lpRasEntryW->ipaddrWins = lpRasEntry->ipaddrWins;

    lpRasEntryW->ipaddrWinsAlt = lpRasEntry->ipaddrWinsAlt;

    lpRasEntryW->dwFrameSize = lpRasEntry->dwFrameSize;

    lpRasEntryW->dwfNetProtocols = lpRasEntry->dwfNetProtocols;

    lpRasEntryW->dwFramingProtocol = lpRasEntry->dwFramingProtocol;

    strncpyAtoWAnsi(lpRasEntryW->szScript,
               lpRasEntry->szScript,
               sizeof(lpRasEntryW->szScript) / sizeof(WCHAR));

    strncpyAtoWAnsi(lpRasEntryW->szX25PadType,
               lpRasEntry->szX25PadType,
               sizeof(lpRasEntryW->szX25PadType) / sizeof(WCHAR));

    strncpyAtoWAnsi(lpRasEntryW->szX25Address,
               lpRasEntry->szX25Address,
               sizeof(lpRasEntryW->szX25Address) / sizeof(WCHAR));

    strncpyAtoWAnsi(lpRasEntryW->szX25Facilities,
               lpRasEntry->szX25Facilities,
               sizeof(lpRasEntryW->szX25Facilities) / sizeof(WCHAR));

    strncpyAtoWAnsi(lpRasEntryW->szX25UserData,
               lpRasEntry->szX25UserData,
               sizeof(lpRasEntryW->szX25UserData) / sizeof(WCHAR));

    strncpyAtoWAnsi(lpRasEntryW->szAutodialDll,
               lpRasEntry->szAutodialDll,
               sizeof(lpRasEntryW->szAutodialDll) / sizeof(WCHAR));

    strncpyAtoWAnsi(lpRasEntryW->szAutodialFunc,
               lpRasEntry->szAutodialFunc,
               sizeof(lpRasEntryW->szAutodialFunc) / sizeof(WCHAR));

    strncpyAtoWAnsi(lpRasEntryW->szAreaCode,
               lpRasEntry->szAreaCode,
               sizeof(lpRasEntryW->szAreaCode) / sizeof(WCHAR));

    strncpyAtoWAnsi(lpRasEntryW->szLocalPhoneNumber,
               lpRasEntry->szLocalPhoneNumber,
               sizeof(lpRasEntryW->szLocalPhoneNumber) / sizeof(WCHAR));

    strncpyAtoWAnsi(lpRasEntryW->szDeviceType,
               lpRasEntry->szDeviceType,
               sizeof(lpRasEntryW->szDeviceType) / sizeof(WCHAR));

    strncpyAtoWAnsi(lpRasEntryW->szDeviceName,
               lpRasEntry->szDeviceName,
               sizeof(lpRasEntryW->szDeviceName) / sizeof(WCHAR));

    //
    // Copy the alternate phone numbers to the
    // A buffer, if any.
    //
    if (lpRasEntry->dwAlternateOffset)
    {
        DWORD dwcbPhoneNumber;
        PCHAR pszPhoneNumber;
        WCHAR UNALIGNED *pwszPhoneNumber;

        lpRasEntryW->dwAlternateOffset = sizeof (RASENTRYW);

        pszPhoneNumber = (PCHAR)((ULONG_PTR)lpRasEntry
                       + lpRasEntry->dwAlternateOffset);

        pwszPhoneNumber = (PWCHAR)((ULONG_PTR)lpRasEntryW
                        + lpRasEntryW->dwAlternateOffset);

        while (*pszPhoneNumber != '\0')
        {
            WCHAR *psz;

            dwcbPhoneNumber = strlen(pszPhoneNumber);

            //
            // Extra steps necessary to copy to an
            // unaligned target.
            //
            psz = strdupAtoWAnsi(pszPhoneNumber);
            if (psz == NULL)
            {
                dwErr = GetLastError();
                goto done;
            }

            RtlCopyMemory(
              pwszPhoneNumber,
              psz,
              (dwcbPhoneNumber + 1) * sizeof (WCHAR));
            Free(psz);

            pwszPhoneNumber += dwcbPhoneNumber + 1;
            pszPhoneNumber += dwcbPhoneNumber + 1;
        }

        //
        // Add another null to terminate
        // the list.
        //
        *pwszPhoneNumber = L'\0';
    }
    else
    {
        lpRasEntryW->dwAlternateOffset = 0;
    }

    //
    // Copy the following fields only for
    // a V401 structure.
    //
    if (    (lpRasEntry->dwSize == sizeof (RASENTRYA))
        ||  (lpRasEntry->dwSize == sizeof (RASENTRYA_V401))
        ||  (lpRasEntry->dwSize == sizeof(RASENTRYA_V500))
       )
    {
        lpRasEntryW->dwDialMode = lpRasEntry->dwDialMode;

        lpRasEntryW->dwDialExtraPercent =
                        lpRasEntry->dwDialExtraPercent;

        lpRasEntryW->dwDialExtraSampleSeconds =
                    lpRasEntry->dwDialExtraSampleSeconds;

        lpRasEntryW->dwHangUpExtraPercent =
                    lpRasEntry->dwHangUpExtraPercent;

        lpRasEntryW->dwHangUpExtraSampleSeconds =
                lpRasEntry->dwHangUpExtraSampleSeconds;

        lpRasEntryW->dwIdleDisconnectSeconds =
                lpRasEntry->dwIdleDisconnectSeconds;
    }

    //
    // Copy the following fields only for V500 structures
    //
    if (    (lpRasEntry->dwSize == sizeof(RASENTRYA_V500))
        ||  (lpRasEntry->dwSize == sizeof(RASENTRYA)))
    {
        //
        // Entry type
        //
        lpRasEntryW->dwType = lpRasEntry->dwType;

        //
        // dwCustomAuthKey
        //
        lpRasEntryW->dwCustomAuthKey = lpRasEntry->dwCustomAuthKey;

        lpRasEntryW->guidId = lpRasEntry->guidId;

        //
        // Encryption type
        //
        lpRasEntryW->dwEncryptionType =
                lpRasEntry->dwEncryptionType;

        //
        // Custom Dial Dll
        //
        strncpyAtoWAnsi(lpRasEntryW->szCustomDialDll,
                   lpRasEntry->szCustomDialDll,
                   sizeof(lpRasEntryW->szCustomDialDll) / sizeof(WCHAR));

        //
        // vpn strategy
        //
        lpRasEntryW->dwVpnStrategy = lpRasEntry->dwVpnStrategy;

    }

    if(lpRasEntry->dwSize == sizeof(RASENTRYA))
    {
        //
        // Set the additional options bits
        //
        lpRasEntryW->dwfOptions2 = lpRasEntry->dwfOptions2;

        strncpyAtoWAnsi(lpRasEntryW->szDnsSuffix,
                       lpRasEntry->szDnsSuffix,
                       sizeof(lpRasEntryW->szDnsSuffix) / sizeof(WCHAR));

        lpRasEntryW->dwTcpWindowSize = lpRasEntry->dwTcpWindowSize;
        
        strncpyAtoWAnsi(lpRasEntryW->szPrerequisitePbk,
                       lpRasEntry->szPrerequisitePbk,
                       sizeof(lpRasEntryW->szPrerequisitePbk) / sizeof(WCHAR));

        strncpyAtoWAnsi(lpRasEntryW->szPrerequisiteEntry,
                       lpRasEntry->szPrerequisiteEntry,
                       sizeof(lpRasEntryW->szPrerequisiteEntry) /
                         sizeof(WCHAR));

        lpRasEntryW->dwRedialCount = lpRasEntry->dwRedialCount;
        lpRasEntryW->dwRedialPause = lpRasEntry->dwRedialPause;

    }

    //
    // Call the W version to do the work.
    //
    dwErr = RasSetEntryPropertiesW(
                (lpszPhonebook != NULL)
              ? szPhonebookW
              : NULL,
                (lpszEntry != NULL)
              ? szEntryNameW
              : NULL,
              lpRasEntryW,
              dwcb,
              lpbDeviceConfig,
              dwcbDeviceConfig);
    //
    // Free the temporary W buffers.
    //
done:
    Free(lpRasEntryW);

    return dwErr;
}


DWORD APIENTRY
RasRenameEntryW(
    IN LPCWSTR lpszPhonebook,
    IN LPCWSTR lpszOldEntry,
    IN LPCWSTR lpszNewEntry
    )
{
    DWORD dwErr;
    PBFILE pbfile;
    DTLNODE *pdtlnode;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasRenameEntryW");

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Check the entry names.
    //
    if (    lpszOldEntry == NULL
        ||  lpszNewEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if(lstrlen(lpszNewEntry) > RAS_MaxEntryName)
    {
        return ERROR_INVALID_NAME;
    }

    //
    // Load the phonebook file.
    //
    ZeroMemory(&pbfile, sizeof(pbfile));
    pbfile.hrasfile = -1;

    // 196460: (shaunco) Allow changing the case of an entry name.
    // Before, we'd fail with ERROR_ALREADY_EXISTS.
    //
    if (0 != lstrcmpi(lpszNewEntry, lpszOldEntry))
    {
        dwErr = GetPbkAndEntryName(
                        lpszPhonebook,
                        lpszNewEntry,
                        RPBF_NoCreate,
                        &pbfile,
                        &pdtlnode);

        if(SUCCESS == dwErr)
        {
            dwErr = ERROR_ALREADY_EXISTS;
            goto done;
        }
    }

    dwErr = GetPbkAndEntryName(
                    lpszPhonebook,
                    lpszOldEntry,
                    RPBF_NoCreate,
                    &pbfile,
                    &pdtlnode);

    if(ERROR_SUCCESS != dwErr)
    {
        goto done;
    }

    //
    // Rename the entry.
    //
    dwErr = RenamePhonebookEntry(
              &pbfile,
              lpszOldEntry,
              lpszNewEntry,
              pdtlnode);

    if (dwErr)
    {
        goto done;
    }

    //
    // Write out the phonebook file.
    //
    dwErr = WritePhonebookFile(&pbfile,
                               lpszOldEntry);
    if (dwErr)
    {
        goto done;
    }

    // Update the default connection if this is it
    //
    // Ignore the error.  It is non-critical
    //
    dwErr = DwRenameDefaultConnection(
                lpszPhonebook,
                lpszOldEntry,
                lpszNewEntry);
    dwErr = ERROR_SUCCESS;                
        
done:
    //
    // Clean up.
    //
    ClosePhonebookFile(&pbfile);

    return dwErr;
}

DWORD APIENTRY
RasRenameEntryA(
    IN LPCSTR lpszPhonebook,
    IN LPCSTR lpszOldEntry,
    IN LPCSTR lpszNewEntry
    )
{
    NTSTATUS        status;
    DWORD           dwErr;
    ANSI_STRING     ansiString;
    UNICODE_STRING  phonebookString,
                    oldEntryString,
                    newEntryString;
    WCHAR           szPhonebookW[MAX_PATH];
    WCHAR           szOldEntryNameW[RAS_MaxEntryName + 1];
    WCHAR           szNewEntryNameW[RAS_MaxEntryName + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Validate parameters.
    //
    if (    lpszOldEntry == NULL
        ||  lpszNewEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (lpszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    lpszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the lpszOldEntry to Unicode.
    //
    strncpyAtoWAnsi(szOldEntryNameW,
                lpszOldEntry,
                RAS_MaxEntryName + 1);

    //
    // Convert the lpszNewEntry to Unicode.
    //
    strncpyAtoWAnsi(szNewEntryNameW,
                lpszNewEntry,
                RAS_MaxEntryName + 1);

    //
    // Call the W version to do the work.
    //
    dwErr = RasRenameEntryW(
              lpszPhonebook != NULL
              ? szPhonebookW
              : NULL,
              szOldEntryNameW,
              szNewEntryNameW);

    return dwErr;
}


DWORD APIENTRY
RasDeleteEntryW(
    IN LPCWSTR lpszPhonebook,
    IN LPCWSTR lpszEntry
    )
{
    DWORD dwErr;
    PBFILE pbfile;
    DTLNODE *pdtlnode;
    PBENTRY *pEntry;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasDeleteEntryW");

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Verify parameters.
    //
    if (lpszEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Load the phonebook file.
    //
    ZeroMemory(&pbfile, sizeof(pbfile));
    pbfile.hrasfile = -1;

    dwErr = GetPbkAndEntryName(
                    lpszPhonebook,
                    lpszEntry,
                    RPBF_NoCreate,
                    &pbfile,
                    &pdtlnode);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    //
    // Remove this entry.
    //
    DtlRemoveNode(pbfile.pdtllistEntries, pdtlnode);

    //
    // Write out the phonebook file.
    //
    pEntry = (PBENTRY *)DtlGetData(pdtlnode);

    dwErr = WritePhonebookFile(&pbfile,
                              pEntry->pszEntryName);

    if (dwErr)
    {
        goto done;
    }

    //
    // Delete any home networking information associated with
    // this entry. Any errors that may occur are not fatal.
    //
    {
        HMODULE hHNetCfg;
        FARPROC pHNetDeleteRasConnection;

        hHNetCfg = LoadLibraryW(L"hnetcfg");

        if (NULL != hHNetCfg)
        {
            pHNetDeleteRasConnection =
                GetProcAddress(hHNetCfg, "HNetDeleteRasConnection");

            if (NULL != pHNetDeleteRasConnection)
            {
                (VOID)(*pHNetDeleteRasConnection)(pEntry->pGuid);
            }

            FreeLibrary(hHNetCfg);
        }
    }

    //
    // Delete the dialparams we store in lsa for this entry
    //
    dwErr = g_pRasSetDialParams(
              pEntry->dwDialParamsUID,
              DLPARAMS_MASK_DELETE | DLPARAMS_MASK_OLDSTYLE,
              NULL,
              FALSE);

    if(ERROR_SUCCESS != dwErr)
    {
        //
        // This is not fatal
        //
        RASAPI32_TRACE("RasSetDialParams(DLPARAMS_MASK_DELETE) failed");
    }

    dwErr = RasSetKey(
                NULL,
                pEntry->pGuid,
                DLPARAMS_MASK_PRESHAREDKEY,
                0, NULL);

    if(ERROR_SUCCESS != dwErr)
    {
        RASAPI32_TRACE1("RasSetKey returned error %d", dwErr);
    }
    

    if(     (NULL != pEntry->pszCustomDialerName)
      &&    (TEXT('\0') != pEntry->pszCustomDialerName[0]))
    {
        //
        // Notify Custom Dlls of the delete so that they can
        // clean up their state. First check to see if the
        // dll is a valid dll.
        //
        dwErr = DwCustomDeleteEntryNotify(
                                pbfile.pszPath,
                                lpszEntry,
                                pEntry->pszCustomDialerName);

        dwErr = NO_ERROR;
    }
    
    dwErr = DwSendRasNotification(ENTRY_DELETED,
                                  pEntry,
                                  pbfile.pszPath,
                                  NULL);

    dwErr = ERROR_SUCCESS;

    DestroyEntryNode(pdtlnode);

done:

    //
    // Clean up.
    //
    ClosePhonebookFile(&pbfile);

    return dwErr;
}


DWORD APIENTRY
RasDeleteEntryA(
    IN LPCSTR lpszPhonebook,
    IN LPCSTR lpszEntry
    )
{
    NTSTATUS status;
    DWORD    dwErr;
    WCHAR    szPhonebookW[MAX_PATH],
             szEntryNameW[RAS_MaxEntryName + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Validate parameters.
    //
    if (lpszEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (lpszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    lpszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the lpszEntry to Unicode.
    //
    strncpyAtoWAnsi(szEntryNameW,
                lpszEntry,
                RAS_MaxEntryName + 1);

    //
    // Call the W version to do the work.
    //
    dwErr = RasDeleteEntryW(
              lpszPhonebook != NULL
              ? szPhonebookW
              : NULL,
              szEntryNameW);

    return dwErr;
}


DWORD APIENTRY
RasValidateEntryNameW(
    IN LPCWSTR lpszPhonebook,
    IN LPCWSTR lpszEntry
    )
{
    DWORD dwErr;
    PBFILE pbfile;
    DTLNODE *pdtlnode;
    PBENTRY *pEntry;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasValidateEntryNameW");

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Verify parameters.
    //
    if (lpszEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    ZeroMemory(&pbfile, sizeof(pbfile));
    pbfile.hrasfile = -1;
    
    dwErr = GetPbkAndEntryName(
                    lpszPhonebook,
                    lpszEntry,
                    RPBF_NoCreate,
                    &pbfile,
                    &pdtlnode);

    if(     (SUCCESS == dwErr)
        &&  (NULL != pdtlnode))
    {
        dwErr = ERROR_ALREADY_EXISTS;
        goto done;
    }

    if(     (NULL == pdtlnode)
        &&  (ERROR_SUCCESS != dwErr)
        &&  (NULL != lpszPhonebook)
        &&  (ERROR_SUCCESS != ReadPhonebookFile(
                lpszPhonebook,
                NULL,
                lpszEntry,
                RPBF_NoCreate,
                &pbfile)))
    {
        dwErr = ERROR_CANNOT_OPEN_PHONEBOOK;
        goto done;
    }

    //
    // Validate the entry name.
    //
    dwErr = ValidateEntryName(lpszEntry)
            ? 0
            : ERROR_INVALID_NAME;

done:
    //
    // Clean up.
    //
    ClosePhonebookFile(&pbfile);

    return dwErr;
}


DWORD APIENTRY
RasValidateEntryNameA(
    IN LPCSTR lpszPhonebook,
    IN LPCSTR lpszEntry
    )
{
    NTSTATUS status;
    DWORD    dwErr;
    WCHAR    szPhonebookW[MAX_PATH],
             szEntryNameW[RAS_MaxEntryName + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Validate parameters.
    //
    if (lpszEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (lpszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    lpszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the lpszEntry to Unicode.
    //
    strncpyAtoWAnsi(szEntryNameW,
                lpszEntry,
                RAS_MaxEntryName + 1);

    //
    // Call the W version to do the work.
    //
    dwErr = RasValidateEntryNameW(
              lpszPhonebook != NULL
              ? szPhonebookW
              : NULL,
              szEntryNameW);

    return dwErr;
}


DWORD APIENTRY
RasGetSubEntryHandleW(
    IN HRASCONN hrasconn,
    IN DWORD dwSubEntry,
    OUT LPHRASCONN lphrasconn
    )
{
    DWORD dwErr;
    HPORT hport = NULL;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetSubEntryHandleW");

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    dwErr = SubEntryPort(hrasconn, dwSubEntry, &hport);
    if (dwErr)
    {
        return (dwErr != ERROR_PORT_NOT_OPEN ?
                ERROR_NO_MORE_ITEMS :
                ERROR_PORT_NOT_OPEN);
    }

    //
    // If we successfully get the port handle, we return
    // the encoded port handle as the subentry handle.
    // All RAS APIs that accept an HRASCONN
    // also check for an encoded HPORT.
    //
    *lphrasconn = HPORT_TO_HRASCONN(hport);

    return 0;
}


DWORD APIENTRY
RasGetSubEntryHandleA(
    IN HRASCONN hrasconn,
    IN DWORD dwSubEntry,
    OUT LPHRASCONN lphrasconn
    )
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    return RasGetSubEntryHandleW(hrasconn,
                                 dwSubEntry,
                                 lphrasconn);
}


DWORD APIENTRY
RasConnectionNotificationW(
    IN HRASCONN hrasconn,
    IN HANDLE hEvent,
    IN DWORD dwfEvents
    )
{
    DWORD dwErr;
    HCONN hconn;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    hconn = IS_HPORT(hrasconn) ?
              (HCONN)HRASCONN_TO_HPORT(hrasconn) :
              (HCONN)hrasconn;

    return g_pRasAddNotification(
                            hconn,
                            hEvent,
                            dwfEvents);
}


DWORD APIENTRY
RasConnectionNotificationA(
    IN HRASCONN hrasconn,
    IN HANDLE hEvent,
    IN DWORD dwfEvents
    )
{
    return RasConnectionNotificationW(
                                hrasconn,
                                hEvent,
                                dwfEvents);
}


DWORD APIENTRY
RasGetSubEntryPropertiesA(
    IN LPCSTR lpszPhonebook,
    IN LPCSTR lpszEntry,
    IN DWORD dwSubEntry,
    OUT LPRASSUBENTRYA lpRasSubEntry,
    IN OUT LPDWORD lpcbRasSubEntry,
    OUT LPBYTE lpbDeviceConfig,
    IN OUT LPDWORD lpcbDeviceConfig
    )
{
    NTSTATUS    status;
    DWORD       dwcb,
                dwErr;

    LPRASSUBENTRYW lpRasSubEntryW = NULL;

    WCHAR szPhonebookW[MAX_PATH],
          szEntryNameW[RAS_MaxEntryName + 1];

    DWORD dwSize;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify parameters.
    //
    if (lpcbRasSubEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    (lpRasSubEntry != NULL)
        &&  (sizeof (RASSUBENTRYA) !=
            lpRasSubEntry->dwSize))
    {
        return ERROR_INVALID_SIZE;
    }

    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (lpszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    lpszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the lpszEntry string to Unicode.
    //
    if (lpszEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    strncpyAtoWAnsi(szEntryNameW,
                lpszEntry,
                RAS_MaxEntryName + 1);

    //
    // Determine the size of the W buffer
    // by calculating how many extra CHARs
    // the caller appended onto the end of the
    // A buffer for the alternate phone numbers.
    //
    if (*lpcbRasSubEntry < sizeof (RASSUBENTRYA))
    {
        dwcb = sizeof (RASSUBENTRYA);
    }
    else
    {
        dwcb = *lpcbRasSubEntry;
    }

    dwcb =    sizeof (RASSUBENTRYW)
            + ((dwcb - sizeof(RASSUBENTRYA)) * sizeof (WCHAR));

    if (lpRasSubEntry != NULL)
    {
        lpRasSubEntryW = (LPRASSUBENTRYW)Malloc(dwcb);

        if (lpRasSubEntryW == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Initialize the W buffer.
        //
        lpRasSubEntryW->dwSize = sizeof (RASSUBENTRYW);
    }


    //
    // Call the W version to do the work.
    //
    dwErr = RasGetSubEntryPropertiesW(
              lpszPhonebook != NULL ? szPhonebookW : NULL,
              szEntryNameW,
              dwSubEntry,
              lpRasSubEntryW,
              &dwcb,
              lpbDeviceConfig,
              lpcbDeviceConfig);

    if (!dwErr && lpRasSubEntry != NULL)
    {
        //
        // Copy the fields from the W buffer into
        // the user's A buffer.
        //
        lpRasSubEntry->dwfFlags = lpRasSubEntryW->dwfFlags;

        strncpyWtoAAnsi(lpRasSubEntry->szLocalPhoneNumber,
                   lpRasSubEntryW->szLocalPhoneNumber,
                   sizeof(lpRasSubEntry->szLocalPhoneNumber));

        strncpyWtoAAnsi(lpRasSubEntry->szDeviceType,
                   lpRasSubEntryW->szDeviceType,
                   sizeof(lpRasSubEntry->szDeviceType));

        strncpyWtoAAnsi(lpRasSubEntry->szDeviceName,
                   lpRasSubEntryW->szDeviceName,
                   sizeof(lpRasSubEntry->szDeviceName));

        //
        // Copy the alternate phone numbers to the
        // user's buffer, if any.
        //
        if (lpRasSubEntryW->dwAlternateOffset)
        {
            DWORD dwcbPhoneNumber;
            PCHAR pszPhoneNumber;
            WCHAR UNALIGNED *pwszPhoneNumber;

            lpRasSubEntry->dwAlternateOffset =
                            sizeof (RASSUBENTRYA);

            pwszPhoneNumber =
              (PWCHAR)((ULONG_PTR)lpRasSubEntryW +
                lpRasSubEntryW->dwAlternateOffset);

            pszPhoneNumber =
              (PCHAR)((ULONG_PTR)lpRasSubEntry +
                lpRasSubEntry->dwAlternateOffset);

            while (*pwszPhoneNumber != L'\0')
            {
                WCHAR *pwsz = strdupWU(pwszPhoneNumber);

                //
                // Extra steps necessary to copy from
                // an unaligned target.
                //
                if (pwsz == NULL)
                {
                    dwErr = GetLastError();
                    goto done;
                }

                dwcbPhoneNumber = wcslen(pwsz);
                strncpyWtoAAnsi(
                    pszPhoneNumber,
                    pwsz,
                    (INT )(((PCHAR )lpRasSubEntry + *lpcbRasSubEntry) -
                        pszPhoneNumber));
                Free(pwsz);

                pwszPhoneNumber += dwcbPhoneNumber + 1;
                pszPhoneNumber += dwcbPhoneNumber + 1;
            }

            //
            // Add another null to terminate
            // the list.
            //
            *pszPhoneNumber = '\0';
        }
        else
        {
            lpRasSubEntry->dwAlternateOffset = 0;
        }
    }

    //
    // Perform the inverse calculation we did
    // above to translate the A size from the W
    // size.
    //
done:
    *lpcbRasSubEntry =   sizeof (RASSUBENTRYA)
                       + ((dwcb - sizeof (RASSUBENTRYW))
                       / sizeof (WCHAR));

    //
    // Free the temporary W buffers.
    //
    Free(lpRasSubEntryW);

    RASAPI32_TRACE2("done. *lpcb=%d,dwerr=%d",
           *lpcbRasSubEntry,
           dwErr );

    return dwErr;
}


DWORD APIENTRY
RasGetSubEntryPropertiesW(
    IN  LPCWSTR         lpszPhonebook,
    IN  LPCWSTR         lpszEntry,
    IN  DWORD           dwSubEntry,
    OUT LPRASSUBENTRYW  lpRasSubEntry,
    IN  OUT LPDWORD     lpcbRasSubEntry,
    OUT LPBYTE          lpbDeviceConfig,
    IN  OUT LPDWORD     lpcbDeviceConfig
    )
{
    DWORD dwErr;
    DTLNODE *pdtlnode = NULL, *pdtlEntryNode = NULL;
    PBENTRY *pEntry;
    PBLINK *pLink;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetSubEntryPropertiesW");

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Validate parameters.
    //
    if (    lpcbRasSubEntry == NULL
        ||  !dwSubEntry)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    lpRasSubEntry != NULL
        &&  lpRasSubEntry->dwSize != sizeof (RASSUBENTRYW))
    {
        return ERROR_INVALID_SIZE;
    }

    //
    // Load the phonebook file.
    //
    
    dwErr = ReadEntryFromSystem(
                lpszPhonebook,
                lpszEntry,
                RPBF_NoCreate,
                NULL,
                &pdtlEntryNode,
                NULL);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    pEntry = (PBENTRY *)DtlGetData(pdtlEntryNode);

    //
    // Get the subentry specified.
    //
    pdtlnode = DtlNodeFromIndex(
                 pEntry->pdtllistLinks,
                 dwSubEntry - 1);

    //
    // If the subentry doesn't exist, then
    // return an error.
    //
    if (pdtlnode == NULL)
    {
        dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
        goto done;
    }

    pLink = (PBLINK *)DtlGetData(pdtlnode);
    ASSERT(pLink);

    //
    // Convert the PBLINK into a RASSUBENTRY.
    //
    dwErr = PhonebookLinkToRasSubEntry(
              pLink,
              lpRasSubEntry,
              lpcbRasSubEntry,
              lpbDeviceConfig,
              lpcbDeviceConfig);

done:

    //
    // Clean up.
    //
    if (pdtlEntryNode)
    {
        DestroyEntryNode(pdtlEntryNode);
    }

    return dwErr;
}


DWORD APIENTRY
RasSetSubEntryPropertiesW(
    IN LPCWSTR lpszPhonebook,
    IN LPCWSTR lpszEntry,
    IN DWORD dwSubEntry,
    IN LPRASSUBENTRYW lpRasSubEntry,
    IN DWORD dwcbRasSubEntry,
    IN LPBYTE lpbDeviceConfig,
    IN DWORD dwcbDeviceConfig
    )
{
    DWORD dwErr, dwSubEntries;
    PBFILE pbfile;
    DTLNODE *pdtlnode;
    PBENTRY *pEntry;
    PBLINK *pLink;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasSetSubEntryPropertiesW");

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Validate parameters.
    //
    if (lpRasSubEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (lpRasSubEntry->dwSize != sizeof (RASSUBENTRYW))
    {
        return ERROR_INVALID_SIZE;
    }

    if (dwcbRasSubEntry < lpRasSubEntry->dwSize)
    {
        return ERROR_BUFFER_TOO_SMALL;
    }

    //
    // Load the phonebook file.
    //
    ZeroMemory(&pbfile, sizeof(pbfile));
    pbfile.hrasfile = -1;

    dwErr = GetPbkAndEntryName(
                        lpszPhonebook,
                        lpszEntry,
                        0,
                        &pbfile,
                        &pdtlnode);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    pEntry = (PBENTRY *)DtlGetData(pdtlnode);
    ASSERT(pEntry);

    //
    // Get the subentry specified.
    //
    dwSubEntries = DtlGetNodes(pEntry->pdtllistLinks);

    if (dwSubEntry <= dwSubEntries)
    {
        pdtlnode = DtlNodeFromIndex(
                     pEntry->pdtllistLinks,
                     dwSubEntry - 1);

        //
        // If the subentry doesn't exist, then
        // return an error.
        //
        if (pdtlnode == NULL)
        {
            dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
            goto done;
        }
    }
    else if (dwSubEntry == dwSubEntries + 1)
    {
        //
        // Create a new link node and add it
        // to the tail of the links.
        //
        pdtlnode = CreateLinkNode();
        DtlAddNodeLast(pEntry->pdtllistLinks, pdtlnode);
    }
    else
    {
        dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
        goto done;
    }

    pLink = (PBLINK *)DtlGetData(pdtlnode);

    ASSERT(pLink);

    //
    //
    // Convert the RASENTRY to a PBENTRY.
    //
    dwErr = RasSubEntryToPhonebookLink(
              pEntry,
              lpRasSubEntry,
              dwcbRasSubEntry,
              lpbDeviceConfig,
              dwcbDeviceConfig,
              pLink);
    if (dwErr)
    {
        goto done;
    }

    //
    // Write out the phonebook file.
    //
    dwErr = WritePhonebookFile(&pbfile, NULL);

done:
    //
    // Clean up.
    //
    ClosePhonebookFile(&pbfile);

    return dwErr;
}


DWORD APIENTRY
RasSetSubEntryPropertiesA(
    IN  LPCSTR          lpszPhonebook,
    IN  LPCSTR          lpszEntry,
    IN  DWORD           dwSubEntry,
    OUT LPRASSUBENTRYA  lpRasSubEntry,
    IN  DWORD           dwcbRasSubEntry,
    IN  LPBYTE          lpbDeviceConfig,
    IN  DWORD           dwcbDeviceConfig
    )
{
    NTSTATUS    status;
    DWORD       dwErr,
                dwcb;

    LPRASSUBENTRYW lpRasSubEntryW;

    WCHAR szPhonebookW[MAX_PATH],
          szEntryNameW[RAS_MaxEntryName + 1];

    DWORD   dwSize;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify parameters.
    //
    if (lpRasSubEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (sizeof (RASSUBENTRYA) !=
        lpRasSubEntry->dwSize)
    {
        return ERROR_INVALID_SIZE;
    }

    if (dwcbRasSubEntry < lpRasSubEntry->dwSize)
    {
        return ERROR_BUFFER_TOO_SMALL;
    }

    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (lpszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    lpszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the lpszEntry string to Unicode.
    //
    if (lpszEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    strncpyAtoWAnsi(szEntryNameW,
                lpszEntry,
                RAS_MaxEntryName + 1);

    //
    // Determine the size of the W buffer
    // by calculating how many extra CHARs
    // the caller appended onto the end of the
    // A buffer for the alternate phone numbers.
    //
    dwcb = sizeof (RASSUBENTRYW)
         + ((dwcbRasSubEntry - sizeof(RASSUBENTRYA))
         * sizeof (WCHAR));

    if (lpRasSubEntry != NULL)
    {
        lpRasSubEntryW = (LPRASSUBENTRYW)Malloc(dwcb);

        if (lpRasSubEntryW == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Initialize the W buffer.
        //
        lpRasSubEntryW->dwSize = sizeof (RASSUBENTRYW);
    }

    //
    // Copy the fields from the A buffer into
    // the user's W buffer.
    //
    lpRasSubEntryW->dwSize = sizeof (RASSUBENTRYW);

    lpRasSubEntryW->dwfFlags = lpRasSubEntry->dwfFlags;

    strncpyAtoWAnsi(lpRasSubEntryW->szLocalPhoneNumber,
               lpRasSubEntry->szLocalPhoneNumber,
               sizeof(lpRasSubEntryW->szLocalPhoneNumber) / sizeof(WCHAR));

    strncpyAtoWAnsi(lpRasSubEntryW->szDeviceType,
               lpRasSubEntry->szDeviceType,
               sizeof(lpRasSubEntryW->szDeviceType) / sizeof(WCHAR));

    strncpyAtoWAnsi(lpRasSubEntryW->szDeviceName,
               lpRasSubEntry->szDeviceName,
               sizeof(lpRasSubEntryW->szDeviceName) / sizeof(WCHAR));

    //
    // Copy the alternate phone numbers to the
    // A buffer, if any.
    //
    if (lpRasSubEntry->dwAlternateOffset)
    {
        DWORD dwcbPhoneNumber;

        PCHAR pszPhoneNumber;

        WCHAR UNALIGNED *pwszPhoneNumber;

        lpRasSubEntryW->dwAlternateOffset = sizeof (RASSUBENTRYW);

        pszPhoneNumber = (PCHAR)((ULONG_PTR)lpRasSubEntry
                       + lpRasSubEntry->dwAlternateOffset);

        pwszPhoneNumber = (PWCHAR)((ULONG_PTR)lpRasSubEntryW
                        + lpRasSubEntryW->dwAlternateOffset);

        while (*pszPhoneNumber != '\0')
        {
            WCHAR *psz;

            dwcbPhoneNumber = strlen(pszPhoneNumber);

            //
            // Extra steps necessary to copy to an
            // unaligned target.
            //
            psz = strdupAtoWAnsi(pszPhoneNumber);

            if (psz == NULL)
            {
                dwErr = GetLastError();
                goto done;
            }

            RtlCopyMemory(
              pwszPhoneNumber,
              psz,
              (dwcbPhoneNumber + 1) * sizeof (WCHAR));
            Free(psz);

            pwszPhoneNumber += dwcbPhoneNumber + 1;
            pszPhoneNumber += dwcbPhoneNumber + 1;
        }

        //
        // Add another null to terminate
        // the list.
        //
        *pwszPhoneNumber = L'\0';
    }
    else
    {
        lpRasSubEntryW->dwAlternateOffset = 0;
    }

    //
    // Call the A version to do the work.
    //
    dwErr = RasSetSubEntryPropertiesW(
              lpszPhonebook != NULL ? szPhonebookW : NULL,
              szEntryNameW,
              dwSubEntry,
              lpRasSubEntryW,
              dwcb,
              lpbDeviceConfig,
              dwcbDeviceConfig);
    //
    // Free the temporary W buffers.
    //
done:
    Free(lpRasSubEntryW);

    return dwErr;
}


//Real password won't be returned, only a handle will be returned.
DWORD APIENTRY
RasGetCredentialsW(
    IN  LPCWSTR           lpszPhonebook,
    IN  LPCWSTR           lpszEntry,
    OUT LPRASCREDENTIALSW lpRasCredentials
    )
{
    DWORD dwErr;
    DTLNODE *pdtlnode = NULL;
    PBENTRY *pEntry = NULL;
    DWORD dwMask;
    RAS_DIALPARAMS dialparams;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetCredentialsW");

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Validate parameters.
    //
    if (lpRasCredentials == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (lpRasCredentials->dwSize
        != sizeof (RASCREDENTIALSW))
    {
        return ERROR_INVALID_SIZE;
    }

    if(     ((lpRasCredentials->dwMask & RASCM_PreSharedKey)
        &&  (lpRasCredentials->dwMask != RASCM_PreSharedKey))
        ||  ((lpRasCredentials->dwMask & RASCM_DDMPreSharedKey)
        &&  (lpRasCredentials->dwMask != RASCM_DDMPreSharedKey))
        ||  ((lpRasCredentials->dwMask & RASCM_ServerPreSharedKey)
        &&  (lpRasCredentials->dwMask != RASCM_ServerPreSharedKey)))
    {
        return ERROR_INVALID_PARAMETER;
    }
    

    //
    // Load the phonebook file.
    //

    if(0 == (RASCM_ServerPreSharedKey & lpRasCredentials->dwMask))
    {
        dwErr = ReadEntryFromSystem(
                    lpszPhonebook,
                    lpszEntry,
                    RPBF_NoCreate,
                    NULL,
                    &pdtlnode,
                    NULL);

        if(SUCCESS != dwErr)
        {
            goto done;
        }

        pEntry = (PBENTRY *)DtlGetData(pdtlnode);
        ASSERT(pEntry);
    }

    // Set the appropriate flags to get the requested fields.
    //
    // (SteveC) Changed to include "old-style" bit so that Set/GetCredentials
    //    and Get/SetDialParams share the same data store.  See bug 335748,.
    //
    dwMask = lpRasCredentials->dwMask | DLPARAMS_MASK_OLDSTYLE;

    if(     (lpRasCredentials->dwMask & RASCM_PreSharedKey)
        ||  (lpRasCredentials->dwMask & RASCM_DDMPreSharedKey)
        ||  (lpRasCredentials->dwMask & RASCM_ServerPreSharedKey))
    {
        DWORD cbkey = (PWLEN + 1) * sizeof(WCHAR);
        
        dwMask = DLPARAMS_MASK_PRESHAREDKEY;
        if(lpRasCredentials->dwMask & RASCM_DDMPreSharedKey)
        {
            dwMask = DLPARAMS_MASK_DDM_PRESHAREDKEY;
        }
        else if(lpRasCredentials->dwMask & RASCM_ServerPreSharedKey)
        {
            dwMask = DLPARAMS_MASK_SERVER_PRESHAREDKEY;
        }
        
        dwErr = RasGetKey(
                    NULL,
                    (NULL != pEntry)
                    ? pEntry->pGuid
                    : NULL,
                    dwMask,
                    &cbkey,
                    (BYTE *) lpRasCredentials->szPassword);

        if(ERROR_SUCCESS != dwErr)
        {
            lpRasCredentials->dwMask = 0;
        }
        
        goto done;
    }

    if(dwMask & RASCM_DefaultCreds)
    {
        dwMask |= DLPARAMS_MASK_DEFAULT_CREDS;
    }

    //
    // .Net bug# 513844 new verbose RASAPI32 prefast warnings
    //
    if (!pEntry)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto done;
    }
    //
    // Get the dial parameters from rasman.
    //
    dwErr = g_pRasGetDialParams(pEntry->dwDialParamsUID,
                                &dwMask,
                                &dialparams);
    if (dwErr)
    {
        goto done;
    }

    //
    // Copy the fields back to the
    // lpRasCredentials structure.
    //
    lpRasCredentials->dwMask = dwMask;

    if(lpRasCredentials->dwMask & DLPARAMS_MASK_DEFAULT_CREDS)
    {
        lpRasCredentials->dwMask &= ~DLPARAMS_MASK_DEFAULT_CREDS;
        lpRasCredentials->dwMask |= RASCM_DefaultCreds;
    }

    if (dwMask & DLPARAMS_MASK_USERNAME)
    {
        lstrcpyn(lpRasCredentials->szUserName,
                 dialparams.DP_UserName,
                 sizeof(lpRasCredentials->szUserName) / sizeof(WCHAR));
    }
    else
    {
        *lpRasCredentials->szUserName = L'\0';
    }

    if (   (dwMask & DLPARAMS_MASK_PASSWORD)
        || (dwMask & DLPARAMS_MASK_PRESHAREDKEY)
        || (dwMask & DLPARAMS_MASK_SERVER_PRESHAREDKEY))
    {
        lstrcpyn(lpRasCredentials->szPassword,
                 dialparams.DP_Password,
                 sizeof(lpRasCredentials->szPassword) / sizeof(WCHAR));
    }
    else
    {
        *lpRasCredentials->szPassword = L'\0';
    }

    if (dwMask & DLPARAMS_MASK_DOMAIN)
    {
        lstrcpyn(lpRasCredentials->szDomain,
                 dialparams.DP_Domain,
                 sizeof(lpRasCredentials->szDomain) / sizeof(WCHAR));
    }
    else
    {
        *lpRasCredentials->szDomain = L'\0';
    }

done:
    //
    // Clean up.
    //
    if (pdtlnode)
    {
        DestroyEntryNode(pdtlnode);
    }        
        
    return dwErr;
}


//Real password won't be returned, only a handle will be returned.
DWORD APIENTRY
RasGetCredentialsA(
    IN  LPCSTR              lpszPhonebook,
    IN  LPCSTR              lpszEntry,
    OUT LPRASCREDENTIALSA   lpRasCredentials
    )
{
    NTSTATUS        status;
    DWORD           dwErr;
    RASCREDENTIALSW rascredentialsW;

    WCHAR szPhonebookW[MAX_PATH],
          szEntryNameW[RAS_MaxEntryName + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify parameters.
    //
    if (lpRasCredentials == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (lpRasCredentials->dwSize
        != sizeof (RASCREDENTIALSA))
    {
        return ERROR_INVALID_SIZE;
    }

    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (lpszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    lpszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the lpszEntry string to Unicode.
    //
    if (lpszEntry != NULL)
    {
        strncpyAtoWAnsi(szEntryNameW,
                    lpszEntry,
                    RAS_MaxEntryName + 1);
    }

    //
    // Copy the entry name from the user's A buffer into
    // the W buffer, taking into account the version
    // of the structure the user passed in.
    //
    rascredentialsW.dwSize = sizeof (RASCREDENTIALSW);
    rascredentialsW.dwMask = lpRasCredentials->dwMask;

    //
    // Call the W version to do the work.
    //
    dwErr = RasGetCredentialsW(
              lpszPhonebook != NULL ? szPhonebookW : NULL,
              lpszEntry != NULL ? szEntryNameW : NULL,
              &rascredentialsW);
    if (dwErr)
    {
        goto done;
    }

    //
    // Copy over the fields to the
    // user's A buffer.
    //
    lpRasCredentials->dwMask = rascredentialsW.dwMask;
    if (rascredentialsW.dwMask & RASCM_UserName)
    {
        strncpyWtoAAnsi(lpRasCredentials->szUserName,
                   rascredentialsW.szUserName,
                   sizeof(lpRasCredentials->szUserName));
    }
    else
    {
        *lpRasCredentials->szUserName = '\0';
    }

    if (    (rascredentialsW.dwMask & RASCM_Password)
        ||  (rascredentialsW.dwMask & RASCM_PreSharedKey)
        ||  (rascredentialsW.dwMask & RASCM_DDMPreSharedKey))
    {
        strncpyWtoAAnsi(lpRasCredentials->szPassword,
                   rascredentialsW.szPassword,
                   sizeof(lpRasCredentials->szPassword));
    }
    else
    {
        *lpRasCredentials->szPassword = '\0';
    }

    if (rascredentialsW.dwMask & RASCM_Domain)
    {
        strncpyWtoAAnsi(lpRasCredentials->szDomain,
                   rascredentialsW.szDomain,
                   sizeof(lpRasCredentials->szDomain));
    }
    else
    {
        *lpRasCredentials->szDomain = '\0';
    }

done:
    return dwErr;
}


DWORD APIENTRY
RasSetCredentialsW(
    IN LPCWSTR           lpszPhonebook,
    IN LPCWSTR           lpszEntry,
    IN LPRASCREDENTIALSW lpRasCredentials,
    IN BOOL              fDelete
    )
{
    DWORD       dwErr;
    PBFILE      pbfile;
    DTLNODE     *pdtlnode;
    PBENTRY     *pEntry = NULL;
    BOOL        fPbk = FALSE;

    RAS_DIALPARAMS dialparams;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasSetCredentialsW");

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Validate parameters.
    //
    if (    (lpRasCredentials == NULL)
        ||  ((lpRasCredentials->dwMask & RASCM_PreSharedKey)
            && (lpRasCredentials->dwMask != RASCM_PreSharedKey))
        ||  ((lpRasCredentials->dwMask & RASCM_DDMPreSharedKey)
            && (lpRasCredentials->dwMask != RASCM_DDMPreSharedKey))
        ||  ((lpRasCredentials->dwMask & RASCM_ServerPreSharedKey)
            && (lpRasCredentials->dwMask != RASCM_ServerPreSharedKey)))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (lpRasCredentials->dwSize != sizeof (RASCREDENTIALSW))
    {
        return ERROR_INVALID_SIZE;
    }

    //Protect input password
    SafeEncodePasswordBuf(lpRasCredentials->szPassword);
    //
    // Load the phonebook file.
    //
    ZeroMemory(&pbfile, sizeof(pbfile));
    pbfile.hrasfile = -1;

    if(0 == (lpRasCredentials->dwMask & RASCM_ServerPreSharedKey))
    {
        dwErr = GetPbkAndEntryName(
                        lpszPhonebook,
                        lpszEntry,
                        0,
                        &pbfile,
                        &pdtlnode);

        if(SUCCESS != dwErr)
        {
            goto done;
        }

        fPbk = TRUE;

        if(     (lpRasCredentials->dwMask & RASCM_DefaultCreds)
            &&  (!IsPublicPhonebook(pbfile.pszPath)))
        {
            RASAPI32_TRACE("RasSetCredentials: Attempting to set a defaultpw on"
                  " per user phonebook. ACCESS_DENIED");

            dwErr = ERROR_ACCESS_DENIED;
            goto done;
        }

        //
        // Get the dialparams UID corresponding to the
        // entry.  The phonebook library guarantees this
        // value to be unique.
        //
        pEntry = (PBENTRY *)DtlGetData(pdtlnode);
        ASSERT(pEntry);
    }

    if(     (lpRasCredentials->dwMask & RASCM_PreSharedKey)
        ||  (lpRasCredentials->dwMask & RASCM_DDMPreSharedKey)
        ||  (lpRasCredentials->dwMask & RASCM_ServerPreSharedKey))
    {

        DWORD dwMask = DLPARAMS_MASK_PRESHAREDKEY;
        DWORD cbkey = 0;
        
        
        if(lpRasCredentials->dwMask & RASCM_DDMPreSharedKey)
        {
            dwMask = DLPARAMS_MASK_DDM_PRESHAREDKEY;
        }
        else if(lpRasCredentials->dwMask & RASCM_ServerPreSharedKey)
        {
            dwMask = DLPARAMS_MASK_SERVER_PRESHAREDKEY;
        }

        //Decode before setting key in Rasman
        SafeDecodePasswordBuf(lpRasCredentials->szPassword);

        //Have to get the length of the key after decoding
        cbkey=  (fDelete)
            ? 0
            : (wcslen(lpRasCredentials->szPassword) + 1) * sizeof(WCHAR);

        dwErr = RasSetKey(NULL,
                         (NULL != pEntry)
                         ? pEntry->pGuid
                         : NULL,
                         dwMask,
                         cbkey,
                         (BYTE *) lpRasCredentials->szPassword);

      //Protect password after setting key in Rasman
      SafeEncodePasswordBuf(lpRasCredentials->szPassword);

        goto done;
                          
    }
    //
    // .Net bug# 513844 new verbose RASAPI32 prefast warnings
    //
    if (!pEntry)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto done;
    }
    //
    // Copy the fields from lpRasCredentials
    // into the rasman structure.
    //
    dialparams.DP_Uid = pEntry->dwDialParamsUID;

    lstrcpyn(dialparams.DP_UserName,
           lpRasCredentials->szUserName,
           sizeof(dialparams.DP_UserName) / sizeof(WCHAR));

   SafeDecodePasswordBuf(lpRasCredentials->szPassword);

    lstrcpyn(dialparams.DP_Password,
           lpRasCredentials->szPassword,
           sizeof(dialparams.DP_Password) / sizeof(WCHAR));

   SafeEncodePasswordBuf(lpRasCredentials->szPassword);
   SafeEncodePasswordBuf(dialparams.DP_Password);

    lstrcpyn(dialparams.DP_Domain,
           lpRasCredentials->szDomain,
           sizeof(dialparams.DP_Domain) / sizeof(WCHAR));

    if(lpRasCredentials->dwMask & RASCM_DefaultCreds)
    {
        lpRasCredentials->dwMask &= ~(RASCM_DefaultCreds);
        lpRasCredentials->dwMask |= DLPARAMS_MASK_DEFAULT_CREDS;
    }

    //
    // Or mask with delete flag so that the whole record
    // is removed from lsa for this connectoid. This will
    // break legacy usage of RasSetEntryDialParams but we
    // really want to discourage users from using that api.
    // 
    if(     fDelete
        &&  ((lpRasCredentials->dwMask & (~DLPARAMS_MASK_DEFAULT_CREDS)) == 
                (RASCM_Domain | RASCM_Password | RASCM_UserName)))
    {
        lpRasCredentials->dwMask |= DLPARAMS_MASK_DELETE; 
    }

    //
    // Set the dial parameters in rasman.
    //
    // (SteveC) Changed to include "old-style" bit so that Set/GetCredentials
    //    and Get/SetDialParams share the same data store.  See bug 335748,.
    //

    SafeDecodePasswordBuf(dialparams.DP_Password);

    dwErr = g_pRasSetDialParams(
              pEntry->dwDialParamsUID,
              lpRasCredentials->dwMask | DLPARAMS_MASK_OLDSTYLE,
              &dialparams,
              fDelete);
              
    //Protect after calling into rasman
    SafeWipePasswordBuf(dialparams.DP_Password);

    if (dwErr)
    {
        goto done;
    }

done:
    //
    // Clean up.
    //
    if(fPbk)
    {
        ClosePhonebookFile(&pbfile);
    }

    SafeDecodePasswordBuf(lpRasCredentials->szPassword);

    return dwErr;
}


DWORD APIENTRY
RasSetCredentialsA(
    IN LPCSTR lpszPhonebook,
    IN LPCSTR lpszEntry,
    IN LPRASCREDENTIALSA lpRasCredentials,
    IN BOOL fDelete
    )
{
    NTSTATUS    status;
    DWORD       dwErr;

    RASCREDENTIALSW rascredentialsW;

    WCHAR szPhonebookW[MAX_PATH],
          szEntryNameW[RAS_MaxEntryName + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify parameters.
    //
    if (lpRasCredentials == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (lpRasCredentials->dwSize != sizeof (RASCREDENTIALSA))
    {
        return ERROR_INVALID_SIZE;
    }

    SafeEncodePasswordBuf(lpRasCredentials->szPassword);

    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (lpszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    lpszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the lpszEntry string to Unicode.
    //
    if (lpszEntry != NULL)
    {
        strncpyAtoWAnsi(szEntryNameW,
                    lpszEntry,
                    RAS_MaxEntryName + 1);
    }

    //
    // Copy the fields from the A buffer into
    // the user's W buffer.
    //
    rascredentialsW.dwSize = sizeof (RASCREDENTIALSW);

    rascredentialsW.dwMask = lpRasCredentials->dwMask;

    strncpyAtoWAnsi(rascredentialsW.szUserName,
              lpRasCredentials->szUserName,
              sizeof(rascredentialsW.szUserName) / sizeof(WCHAR));

    //Decode password before copying
    SafeDecodePasswordBuf(lpRasCredentials->szPassword);

    strncpyAtoWAnsi(rascredentialsW.szPassword,
               lpRasCredentials->szPassword,
               sizeof(rascredentialsW.szPassword) / sizeof(WCHAR));

    //Protect password after copying
    SafeEncodePasswordBuf(lpRasCredentials->szPassword);

    strncpyAtoWAnsi(rascredentialsW.szDomain,
               lpRasCredentials->szDomain,
               sizeof(rascredentialsW.szDomain) / sizeof(WCHAR));

    //
    // Call the W version to do the work.
    //
    dwErr = RasSetCredentialsW(
              lpszPhonebook != NULL ? szPhonebookW : NULL,
              lpszEntry != NULL ? szEntryNameW : NULL,
              &rascredentialsW,
              fDelete);

    SafeWipePasswordBuf(rascredentialsW.szPassword);
    
    //Decode password before return
    SafeDecodePasswordBuf(lpRasCredentials->szPassword);
    
    return dwErr;
}


DWORD
NewAutodialNetwork(
    IN HKEY hkeyBase,
    OUT LPWSTR *lppszNetwork
    )
{
    HKEY hkeyNetworks, hkeyNetwork;
    DWORD dwErr, dwType, dwSize, dwDisp, dwNextId;
    LPWSTR lpszNetwork = NULL;

    //
    // Open the Networks section of the registry.
    //
    dwErr = RegCreateKeyEx(
              hkeyBase,
              AUTODIAL_REGNETWORKBASE,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hkeyNetworks,
              &dwDisp);
    if (dwErr)
    {
        return dwErr;
    }

    //
    // Read the next network number.
    //
    dwSize = sizeof (DWORD);
    dwErr = RegQueryValueEx(
              hkeyNetworks,
              AUTODIAL_REGNETWORKID,
              NULL,
              &dwType,
              (PVOID)&dwNextId,
              &dwSize);
    if (dwErr)
    {
        dwNextId = 0;
    }

    //
    // Create a new network key.
    //
    lpszNetwork = Malloc((wcslen(L"NETWORK") + 16) * sizeof (WCHAR));
    if (lpszNetwork == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    _snwprintf(lpszNetwork, wcslen(L"NETWORK") + 16, L"NETWORK%d", dwNextId);
    dwErr = RegCreateKeyEx(
              hkeyNetworks,
              lpszNetwork,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hkeyNetwork,
              &dwDisp);

    RegCloseKey(hkeyNetwork);

    //
    // Update the next network number.
    //
    dwNextId++;

    dwErr = RegSetValueEx(
              hkeyNetworks,
              AUTODIAL_REGNETWORKID,
              0,
              REG_DWORD,
              (LPBYTE)&dwNextId,
              sizeof (DWORD));
    if (dwErr)
    {
        goto done;
    }

done:
    RegCloseKey(hkeyNetworks);
    if (dwErr)
    {
        if (lpszNetwork != NULL)
        {
            Free(lpszNetwork);
            lpszNetwork = NULL;
        }
    }

    *lppszNetwork = lpszNetwork;

    return dwErr;
}


DWORD
AutodialEntryToNetwork(
    IN  HKEY    hkeyBase,
    IN  LPWSTR  lpszEntry,
    IN  BOOLEAN fCreate,
    OUT LPWSTR  *lppszNetwork
    )
{
    HKEY hkeyEntries;

    DWORD dwErr,
          dwType,
          dwSize,
          dwDisp;

    LPWSTR lpszNetwork = NULL;

    //
    // Open the Entries section of the registry.
    //
    dwErr = RegCreateKeyEx(
              hkeyBase,
              AUTODIAL_REGENTRYBASE,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hkeyEntries,
              &dwDisp);
    if (dwErr)
    {
        goto done;
    }

    //
    // Attempt to read the entry.
    //
    dwErr = RegQueryValueEx(
              hkeyEntries,
              lpszEntry,
              NULL,
              &dwType,
              NULL,
              &dwSize);
    if (dwErr)
    {
        //
        // If we shouldn't create a new network,
        // then it's an error.
        //
        if (!fCreate)
        {
            goto done;
        }

        //
        // If the entry doesn't exist, we have
        // to create a new network and map it to
        // the entry.
        //
        dwErr = NewAutodialNetwork(hkeyBase,
                &lpszNetwork);

        //
        // Map the entry to the new network.
        //
        dwErr = RegSetValueEx(
                  hkeyEntries,
                  lpszEntry,
                  0,
                  REG_SZ,
                  (LPBYTE)lpszNetwork,
                  (wcslen(lpszNetwork) + 1) * sizeof (WCHAR));

        if (dwErr)
        {
            goto done;
        }
    }
    else
    {
        //
        // The entry does exist.  Simply read it.
        //
        lpszNetwork = Malloc(dwSize + sizeof (WCHAR));
        if (lpszNetwork == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }

        RtlZeroMemory(lpszNetwork,
                      dwSize + sizeof (WCHAR));

        dwErr = RegQueryValueEx(
                  hkeyEntries,
                  lpszEntry,
                  NULL,
                  &dwType,
                  (PVOID)lpszNetwork,
                  &dwSize);
        if (dwErr)
        {
            goto done;
        }
    }

done:
    RegCloseKey(hkeyEntries);
    if (dwErr)
    {
        if (lpszNetwork != NULL)
        {
            Free(lpszNetwork);
            lpszNetwork = NULL;
        }
    }
    *lppszNetwork = lpszNetwork;

    return dwErr;
}

DWORD
DwOpenUsersRegistry(HKEY *phkey, BOOL *pfClose)
{
    DWORD dwErr = ERROR_SUCCESS;
    
    if(IsRasmanProcess())
    {
        dwErr = RtlOpenCurrentUser(
                            KEY_ALL_ACCESS,
                            phkey);

        *pfClose = TRUE;                            
    }
    else
    {
        *phkey = HKEY_CURRENT_USER;

        *pfClose = FALSE;
    }

    return dwErr;
}


DWORD WINAPI
RasAutodialEntryToNetwork(
    IN      LPWSTR  lpszEntry,
    OUT     LPWSTR  lpszNetwork,
    IN OUT  LPDWORD lpdwcbNetwork
    )
{
    DWORD dwErr, dwcbTmpNetwork;
    HKEY hkeyBase;
    LPWSTR lpszTmpNetwork;
    HKEY hkcu;
    BOOL fClose;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify parameter.
    //
    if (lpszEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwErr = DwOpenUsersRegistry(&hkcu, &fClose);

    if(ERROR_SUCCESS != dwErr)
    {
        return dwErr;
    }

    //
    // Open the root registry key.
    //
    dwErr = RegOpenKeyEx(
              hkcu,
              AUTODIAL_REGBASE,
              0,
              KEY_ALL_ACCESS,
              &hkeyBase);
    if (dwErr)
    {
        return dwErr;
    }

    //
    // Call internal routine to do the work.
    //
    dwErr = AutodialEntryToNetwork(hkeyBase,
                                   lpszEntry,
                                   FALSE,
                                   &lpszTmpNetwork);
    if (dwErr)
    {
        goto done;
    }

    dwcbTmpNetwork = (wcslen(lpszTmpNetwork) + 1)
                    * sizeof (WCHAR);

    if (    lpszNetwork == NULL
        || *lpdwcbNetwork < dwcbTmpNetwork)
    {
        *lpdwcbNetwork = dwcbTmpNetwork;
        goto done;
    }

    lstrcpyn(lpszNetwork, lpszTmpNetwork, *lpdwcbNetwork);
    *lpdwcbNetwork = dwcbTmpNetwork;

done:

    if(fClose)
    {
        NtClose(hkcu);
    }
    
    if (lpszTmpNetwork != NULL)
    {
        Free(lpszTmpNetwork);
    }

    RegCloseKey(hkeyBase);

    return dwErr;
}


LPWSTR
FormatKey(
    IN LPCWSTR lpszBase,
    IN LPCWSTR lpszKey
    )
{
    LPWSTR lpsz;

    lpsz = Malloc((wcslen(lpszBase)
            + wcslen(lpszKey) + 2) * sizeof (WCHAR));

    if (lpsz == NULL)
    {
        return NULL;
    }

    _snwprintf(
        lpsz,
        wcslen(lpszBase) + wcslen(lpszKey) + 2,
        L"%s\\%s",
        lpszBase,
        lpszKey);

    return lpsz;
}


DWORD
AddAutodialEntryToNetwork(
    IN HKEY     hkeyBase,
    IN LPWSTR   lpszNetwork,
    IN DWORD    dwDialingLocation,
    IN LPWSTR   lpszEntry
    )
{
    HKEY hkeyNetwork = NULL,
         hkeyEntries = NULL;

    DWORD dwErr,
          dwcb,
          dwDisp;

    LPWSTR  lpszNetworkKey;
    TCHAR   szLocationKey[16];

    //
    // Construct the network key.
    //
    lpszNetworkKey = FormatKey(AUTODIAL_REGNETWORKBASE,
                               lpszNetwork);

    if (lpszNetworkKey == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Open the lpszNetwork network subkey in the
    // Networks section of the registry.
    //
    dwErr = RegOpenKeyEx(
              hkeyBase,
              lpszNetworkKey,
              0,
              KEY_ALL_ACCESS,
              &hkeyNetwork);

    if (dwErr)
    {
        goto done;
    }

    //
    // Open the Entries section of the registry,
    // so we can inverse map the entry to the network.
    //
    dwErr = RegCreateKeyEx(
              hkeyBase,
              AUTODIAL_REGENTRYBASE,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hkeyEntries,
              &dwDisp);
    if (dwErr)
    {
        goto done;
    }

    //
    // Format the dialing location as a string
    // for the key value.
    //
    _snwprintf(szLocationKey,
             sizeof(szLocationKey) / sizeof(TCHAR),
             L"%d",
             dwDialingLocation);

    //
    // Add the dialing location and entry
    // to this subkey.
    //
    dwErr = RegSetValueEx(
              hkeyNetwork,
              szLocationKey,
              0,
              REG_SZ,
              (LPBYTE)lpszEntry,
              (wcslen(lpszEntry) + 1) * sizeof (WCHAR));
    if (dwErr)
    {
        goto done;
    }

    //
    // Also write the inverse mapping in the
    // entries section of the registry.
    //
    dwErr = RegSetValueEx(
              hkeyEntries,
              lpszEntry,
              0,
              REG_SZ,
              (LPBYTE)lpszNetwork,
              (wcslen(lpszNetwork) + 1) * sizeof (WCHAR));
    if (dwErr)
    {
        goto done;
    }

done:
    if (hkeyNetwork != NULL)
    {
        RegCloseKey(hkeyNetwork);
    }

    if (hkeyEntries != NULL)
    {
        RegCloseKey(hkeyEntries);
    }

    Free(lpszNetworkKey);

    return dwErr;
}


DWORD
AutodialAddressToNetwork(
    IN  HKEY    hkeyBase,
    IN  LPCWSTR lpszAddress,
    OUT LPWSTR  *lppszNetwork
    )
{
    HKEY hkeyAddress;

    DWORD dwErr,
          dwDisp,
          dwType,
          dwSize;

    LPWSTR lpszAddressKey = NULL,
           lpszNetwork = NULL;

    //
    // Construct the registry key path.
    //
    lpszAddressKey = FormatKey(AUTODIAL_REGADDRESSBASE,
                               lpszAddress);

    if (lpszAddressKey == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Open the address key.
    //
    dwErr = RegOpenKeyEx(
              hkeyBase,
              lpszAddressKey,
              0,
              KEY_ALL_ACCESS,
              &hkeyAddress);
    if (dwErr)
    {
        //
        // .Net bug# 509393 Memory allocated by GlobalAlloc is released by
        // LocalFree in AutodialAddressToNetwork
        //
        goto done;
    }

    //
    // Read the address key.
    //
    dwErr = RegQueryValueEx(
              hkeyAddress,
              AUTODIAL_REGNETWORKVALUE,
              NULL,
              &dwType,
              NULL,
              &dwSize);
    if (dwErr)
    {
        goto done;
    }

    lpszNetwork = Malloc(dwSize + sizeof (WCHAR));
    if (lpszNetwork == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    RtlZeroMemory(lpszNetwork, dwSize + sizeof (WCHAR));
    dwErr = RegQueryValueEx(
              hkeyAddress,
              AUTODIAL_REGNETWORKVALUE,
              NULL,
              &dwType,
              (PVOID)lpszNetwork,
              &dwSize);
    if (dwErr)
    {
        goto done;
    }

done:
    RegCloseKey(hkeyAddress);
    if (lpszAddressKey != NULL)
    {
        Free(lpszAddressKey);
    }

    if (dwErr)
    {
        if (lpszNetwork != NULL)
        {
            Free(lpszNetwork);
            lpszNetwork = NULL;
        }
    }
    *lppszNetwork = lpszNetwork;

    return dwErr;
}


DWORD WINAPI
RasAutodialAddressToNetwork(
    IN  LPWSTR  lpszAddress,
    OUT LPWSTR  lpszNetwork,
    IN  OUT     LPDWORD lpdwcbNetwork
    )
{
    DWORD dwErr,
          dwcbTmpNetwork;

    HKEY hkeyBase = NULL;

    HKEY hkcu;

    LPTSTR lpszTmpNetwork = NULL;

    BOOL fClose;

    //
    // Verify parameter.
    //
    if (lpszAddress == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwErr = DwOpenUsersRegistry(&hkcu, &fClose);

    if(ERROR_SUCCESS != dwErr)
    {
        return dwErr;
    }

    //
    // Open the root registry key.
    //
    dwErr = RegOpenKeyEx(
              hkcu,
              AUTODIAL_REGBASE,
              0,
              KEY_ALL_ACCESS,
              &hkeyBase);
    if (dwErr)
    {
        goto done;
    }

    //
    // Call internal routine to do the work.
    //
    dwErr = AutodialAddressToNetwork(
              hkeyBase,
              lpszAddress,
              &lpszTmpNetwork);
    if (dwErr)
    {
        goto done;
    }

    dwcbTmpNetwork = (wcslen(lpszTmpNetwork) + 1) * sizeof (WCHAR);

    if (    lpszNetwork == NULL
        ||  *lpdwcbNetwork < dwcbTmpNetwork)
    {
        *lpdwcbNetwork = dwcbTmpNetwork;
        goto done;
    }

    lstrcpyn(lpszNetwork, lpszTmpNetwork, *lpdwcbNetwork);
    *lpdwcbNetwork = dwcbTmpNetwork;

done:

    if(fClose)
    {
        NtClose(hkcu);
    }

    if (lpszTmpNetwork != NULL)
    {
        Free(lpszTmpNetwork);
    }

    if(NULL != hkeyBase)
    {
        RegCloseKey(hkeyBase);
    }

    return dwErr;
}

DWORD
RasDefIntConnOpenKey(
    IN BOOL fRead,
    OUT PHKEY phkSettings)
{
    DWORD dwErr = NO_ERROR, dwDisp;
    HKEY hkRoot = NULL, hkAutodial = NULL;
    BOOL fCloseRoot = FALSE;

    BOOL fPersonal = !IsConsumerPlatform();
    
    do
    {
        // Get a reference to the correct index into the registry
        //
        if (fPersonal)
        {
            dwErr = DwOpenUsersRegistry(&hkRoot, &fCloseRoot);
            if (dwErr != NO_ERROR)
            {
                break;
            }
        }
        else
        {
            hkRoot = HKEY_LOCAL_MACHINE;
        }

        //
        // Open the autodial registry key.
        //
        dwErr = RegCreateKeyEx(
                  hkRoot,
                  AUTODIAL_REGBASE,
                  0,
                  NULL,
                  REG_OPTION_NON_VOLATILE,
                  (fRead) ? 
                    (KEY_READ | KEY_CREATE_SUB_KEY) : 
                    (KEY_READ | KEY_WRITE),
                  NULL,
                  &hkAutodial,
                  &dwDisp);
        if (dwErr)
        {
            if ((fRead) && (ERROR_ACCESS_DENIED == dwErr))
            {
                // XP 313846
                //
                // If we are opening the key for read access, it may not be necessary 
                // to have the KEY_CREATE_SUB_KEY permission.  By attempting to open
                // without it, we allow "limited" users to read the default connection
                // setting which they could do with regedit anyway.  They just wont
                // be able to set the default connection.
                //
                dwErr = RegCreateKeyEx(
                          hkRoot,
                          AUTODIAL_REGBASE,
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_READ,
                          NULL,
                          &hkAutodial,
                          &dwDisp);
                if (dwErr)
                {
                    break;
                }
            }                
            else
            {
                break;
            }
        }

        //
        // Open the settings registry key.
        //
        dwErr = RegCreateKeyEx(
                  hkAutodial,
                  AUTODIAL_REGDEFAULT,
                  0,
                  NULL,
                  REG_OPTION_NON_VOLATILE,
                  (fRead) ? 
                    (KEY_READ) : 
                    (KEY_READ | KEY_WRITE),
                  NULL,
                  phkSettings,
                  &dwDisp);
        if (dwErr)
        {
            break;
        }
    } while (FALSE);

    // Cleanup
    {
        if (hkRoot && fCloseRoot)
        {   
            RegCloseKey(hkRoot);
        }
        if (hkAutodial)
        {
            RegCloseKey(hkAutodial);
        }
    }

    return dwErr;
}

DWORD
RasDefIntConnReadName(
    IN LPRASAUTODIALENTRYW pAdEntry)
{
    DWORD dwErr = NO_ERROR, dwType, dwSize;
    HKEY hkSettings = NULL;

    do
    {
        // Open the key
        //
        dwErr = RasDefIntConnOpenKey(TRUE, &hkSettings);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Read the name
        //
        dwType = REG_SZ;
        dwSize = sizeof(pAdEntry->szEntry);
        dwErr = RegQueryValueEx(
                    hkSettings,
                    AUTODIAL_REGDEFINTERNETVALUE,
                    NULL,
                    &dwType,
                    (LPBYTE)pAdEntry->szEntry,
                    &dwSize);
                    
        // Make sure the registry hasn't been tampered with and
        // that we got a valid name back.
        //
        if ((dwErr == NO_ERROR) && 
            (dwType != REG_SZ) || (dwSize == 0))
        {
            dwErr = ERROR_FILE_NOT_FOUND;
            break;
        }
        
    } while (FALSE);

    if (hkSettings)
    {
        RegCloseKey(hkSettings);
    }

    return dwErr;
}


// Populates the autodial entry structure with default connection 
// information.  Returns per-user default connections if configured,
// global default connections otherwise.  Returns ERROR_NOT_FOUND if 
// no default connections are configured
//
DWORD
RasDefIntConnGet(
    IN LPRASAUTODIALENTRYW pAdEntry)
{
    return RasDefIntConnReadName(pAdEntry);
}

// Configures the default connection according to the autodial entry
// structure.
//
DWORD
RasDefIntConnSet(
    IN  LPRASAUTODIALENTRYW pAdEntry,
    IN  LPRASAUTODIALENTRYW pAdEntryOld,
    OUT PBOOL pfDelete)
{
    DWORD dwErr = NO_ERROR;
    HKEY hkSettings = NULL;
    BOOL fDelete = FALSE;

    *pfDelete = FALSE;
    
    do
    {
        // Determine whether the default connection is being deleted
        //
        fDelete = lstrlen(pAdEntry->szEntry) == 0;

        // Open the default connection key
        //
        dwErr = RasDefIntConnOpenKey(FALSE, &hkSettings);
        if (dwErr)
        {
            break;
        }
    
        // Get the old value -- ignore any error, not critical
        //
        dwErr = RasDefIntConnReadName(pAdEntryOld);
        dwErr = NO_ERROR;
        
        // Save or delete the settings
        //
        if (fDelete)
        {
            dwErr = RegDeleteValue(
                        hkSettings,
                        AUTODIAL_REGDEFINTERNETVALUE);
        }
        else
        {
            dwErr = RegSetValueEx(
                        hkSettings,
                        AUTODIAL_REGDEFINTERNETVALUE,
                        0,
                        REG_SZ,
                        (CONST BYTE*)pAdEntry->szEntry,
                        (lstrlen(pAdEntry->szEntry) + 1) * sizeof(WCHAR));
        }
        if (dwErr)
        {
            break;
        }

        *pfDelete = fDelete;
        
    } while (FALSE);

    // Cleanup
    {
        if (hkSettings)
        {
            RegCloseKey(hkSettings);
        }
    }

    return dwErr;
}

// 
// Sends an autodial change notification
//
DWORD
RasDefIntConnNotify(
    IN LPRASAUTODIALENTRYW pAdEntryNew,
    IN LPRASAUTODIALENTRYW pAdEntryOld,
    IN BOOL fDelete)
{ 
    DWORD dwErr = NO_ERROR;
    DTLNODE* pNode = NULL;
    BOOL fLoaded = FALSE;
    PBENTRY* pEntry = NULL;
    RASAUTODIALENTRYW* pAdEntry = NULL;
    WCHAR* pszPbkPath = NULL;

    if (! IsRasmanServiceRunning())
    {
        return NO_ERROR;   
    }

    dwErr = LoadRasmanDll();
    if (NO_ERROR != dwErr)
    {
        return dwErr;
    }


    do
    {
        // We notify about the new entry when it 
        // is being set.  We notify about the old
        // entry when it is being cleared.
        //
        pAdEntry = (fDelete) ? pAdEntryOld : pAdEntryNew;
    
        // Find the phonebook entry
        //
        dwErr = ReadEntryFromSystem(
                    NULL, 
                    pAdEntry->szEntry, 
                    RPBF_NoCreate, 
                    NULL, 
                    &pNode,
                    &pszPbkPath);

        if( SUCCESS != dwErr )
        {
            break;
        }

        pEntry = (PBENTRY *) DtlGetData(pNode);

        // Send the notification
        //
        dwErr = DwSendRasNotification(
                    ENTRY_AUTODIAL,
                    pEntry,
                    pszPbkPath,
                    (HANDLE)&fDelete);
    
        dwErr = NO_ERROR;
    
    } while (FALSE);

    // Cleanup
    //
    if (pNode)
    {
        DestroyEntryNode(pNode);
    }
    if (pszPbkPath)
    {
        Free0(pszPbkPath);
    }

    return dwErr;
}    

DWORD APIENTRY
RasGetAutodialAddressW(
    IN      LPCWSTR             lpszAddress,
    OUT     LPDWORD             lpdwReserved,
    IN OUT  LPRASAUTODIALENTRYW lpRasAutodialEntries,
    IN OUT  LPDWORD             lpdwcbRasAutodialEntries,
    OUT     LPDWORD             lpdwcRasAutodialEntries
    )
{
    HKEY hkeyBase = NULL,
         hkeyNetwork = NULL;

    HKEY hkcu;         

    DWORD dwErr,
          dwNumSubKeys,
          dwMaxSubKeyLen,
          dwMaxClassLen;

    DWORD dwNumValues,
          dwMaxValueLen,
          dwMaxValueData,
          dwSecDescLen;

    DWORD dwcb,
          i,
          j = 0,
          dwType;

    DWORD dwcbLocation,
          dwcbEntry;

    FILETIME ftLastWriteTime;

    LPWSTR lpszNetworkKey = NULL,
           lpszLocation = NULL;

    LPWSTR lpszEntry = NULL,
           lpszNetwork = NULL;

    BOOL fClose;           

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetAutodialAddressW");
    //
    // Verify parameters.
    //
    if (    lpdwReserved != NULL
        ||  lpdwcbRasAutodialEntries == NULL
        ||  lpdwcRasAutodialEntries == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    lpRasAutodialEntries != NULL
        &&  lpRasAutodialEntries->dwSize
            != sizeof (RASAUTODIALENTRYW))
    {
        return ERROR_INVALID_SIZE;
    }

    if (lpRasAutodialEntries == NULL)
    {
        *lpdwcbRasAutodialEntries =
         *lpdwcRasAutodialEntries = 0;
    }

    // If the lpszAddress parameter is null, then we are getting the 
    // default Internet connection.  
    //
    if (lpszAddress == NULL)
    {
        RASAUTODIALENTRYW Entry;

        // Validate the size of the buffer passed in
        //
        if (   (NULL != lpRasAutodialEntries)
            && (sizeof(Entry) > *lpdwcbRasAutodialEntries))
        {
            *lpdwcbRasAutodialEntries = sizeof(Entry);
            *lpdwcRasAutodialEntries = 1;
            return ERROR_BUFFER_TOO_SMALL;
        }

        ZeroMemory(&Entry, sizeof(Entry));
        Entry.dwSize = sizeof(Entry);

        // Read the default Internet connection
        //
        dwErr = RasDefIntConnGet(&Entry);

        // If there is no default connection configured,
        // then report this to the user
        //
        if (dwErr == ERROR_FILE_NOT_FOUND)
        {
            *lpdwcbRasAutodialEntries =
                 *lpdwcRasAutodialEntries = 0;
                 
            return NO_ERROR;                
        }
        else if (dwErr != NO_ERROR)
        {
            return dwErr;
        }

        // Report that there is a default internet connection
        //
        *lpdwcbRasAutodialEntries = sizeof(Entry);
        *lpdwcRasAutodialEntries = 1;

        // Deal with the optional buffer parameter
        //
        if (lpRasAutodialEntries == NULL)
        {
            return ERROR_BUFFER_TOO_SMALL;
        }

        // Return the appropriate autodial structure
        //
        CopyMemory(lpRasAutodialEntries, &Entry, sizeof(Entry));
    
        return NO_ERROR;
    }

    dwErr = DwOpenUsersRegistry(&hkcu, &fClose);

    if(ERROR_SUCCESS != dwErr)
    {
        return dwErr;
    }

    //
    // Open the root registry key.
    //
    dwErr = RegOpenKeyEx(
              hkcu,
              AUTODIAL_REGBASE,
              0,
              KEY_ALL_ACCESS,
              &hkeyBase);

    if (dwErr)
    {
        goto done;
    }

    //
    // Get the network name associated with the
    // address.  The entries and dialing locations
    // are stored under the network.
    //
    dwErr = AutodialAddressToNetwork(hkeyBase,
                                     lpszAddress,
                                     &lpszNetwork);
    if (dwErr)
    {
        goto done;
    }

    //
    // Construct the registry key path.
    //
    lpszNetworkKey = FormatKey(AUTODIAL_REGNETWORKBASE,
                               lpszNetwork);

    if (lpszNetworkKey == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    //
    // Open the registry.
    //
    dwErr = RegOpenKeyEx(
              hkeyBase,
              lpszNetworkKey,
              0,
              KEY_READ,
              &hkeyNetwork);
    if (dwErr)
    {
        goto done;
    }

    //
    // Determine the number of dialing location values.
    //
    // .Net bug# 509437 Potential buffer overflow in RasGetAutodialAddressW and
    // RasEnumAutodialAddressesW
    //
    dwErr = RegQueryInfoKey(
              hkeyNetwork,
              NULL,
              NULL,
              NULL,
              &dwNumSubKeys,
              &dwMaxSubKeyLen,
              &dwMaxClassLen,
              &dwNumValues,
              &dwMaxValueLen,
              &dwMaxValueData,
              &dwSecDescLen,
              &ftLastWriteTime);
    if (    dwErr
        || !dwNumValues)
    {
        goto done;
    }

    //
    // Verify the user's buffer is big enough
    //
    dwcb = dwNumValues * sizeof (RASAUTODIALENTRYW);
    if (*lpdwcbRasAutodialEntries < dwcb)
    {
        dwErr = ERROR_BUFFER_TOO_SMALL;
        j = dwNumValues;
        goto done;
    }

    //
    // Allocate a buffer large enough to hold
    // the longest dialing location value.
    //
    lpszLocation = Malloc((dwMaxValueLen + 1)
                          * sizeof (WCHAR));

    if (lpszLocation == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    //
    // Allocate a buffer large enough to hold
    // the longest entry name.
    //
    lpszEntry = Malloc(dwMaxValueData + 1);
    if (lpszEntry == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    if (lpRasAutodialEntries != NULL)
    {
        for (i = 0, j = 0; i < dwNumValues; i++)
        {
            //
            // Read the location value.
            //
            dwcbLocation = dwMaxValueLen + 1;

            dwcbEntry = dwMaxValueData + 1;

            RtlZeroMemory(lpszEntry, dwMaxValueData + 1);

            dwErr = RegEnumValue(
                      hkeyNetwork,
                      i,
                      lpszLocation,
                      &dwcbLocation,
                      NULL,
                      NULL,
                      (PVOID)lpszEntry,
                      &dwcbEntry);
            if (dwErr)
            {
                goto done;
            }

            //
            // Enter the dialing location and
            // entry into the user's buffer.
            //
            lpRasAutodialEntries[j].dwSize =
                        sizeof (RASAUTODIALENTRYW);

            lpRasAutodialEntries[j].dwFlags = 0;

            lpRasAutodialEntries[j].dwDialingLocation =
                                    _wtol(lpszLocation);

            lstrcpyn(lpRasAutodialEntries[j].szEntry,
                     lpszEntry,
                     sizeof(lpRasAutodialEntries[j].szEntry) / sizeof(WCHAR));

            j++;
        }
    }

done:
    //
    // Set return sizes and count.
    //
    *lpdwcbRasAutodialEntries = j * sizeof (RASAUTODIALENTRYW);
    *lpdwcRasAutodialEntries = j;

    //
    // Free resources.
    //
    if (hkeyBase != NULL)
    {
        RegCloseKey(hkeyBase);
    }

    if (hkeyNetwork != NULL)
    {
        RegCloseKey(hkeyNetwork);
    }

    if (lpszNetworkKey != NULL)
    {
        Free(lpszNetworkKey);
    }

    if (lpszLocation != NULL)
    {
        Free(lpszLocation);
    }

    if (lpszNetwork != NULL)
    {
        //
        // .Net bug# 509393 Memory allocated by GlobalAlloc is released by
        // LocalFree in AutodialAddressToNetwork
        //
        Free(lpszNetwork);
    }

    if (lpszEntry != NULL)
    {
        Free(lpszEntry);
    }

    if(fClose)
    {
        NtClose(hkcu);
    }

    return dwErr;
}


DWORD APIENTRY
RasGetAutodialAddressA(
    IN      LPCSTR              lpszAddress,
    OUT     LPDWORD             lpdwReserved,
    IN OUT  LPRASAUTODIALENTRYA lpRasAutodialEntries,
    IN OUT  LPDWORD             lpdwcbRasAutodialEntries,
    OUT     LPDWORD             lpdwcRasAutodialEntries
    )
{
    NTSTATUS status;

    DWORD dwErr,
          dwcEntries,
          dwcb = 0,
          i;

    PWCHAR lpszAddressW = NULL;

    LPRASAUTODIALENTRYW lpRasAutodialEntriesW = NULL;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify parameters.
    //
    if (    lpdwcbRasAutodialEntries == NULL
        ||  lpdwcRasAutodialEntries == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    lpRasAutodialEntries != NULL
        &&  lpRasAutodialEntries->dwSize
            != sizeof (RASAUTODIALENTRYA))
    {
        return ERROR_INVALID_SIZE;
    }

    //
    // Convert the address to Unicode.
    //
    if (lpszAddress)
    {
        lpszAddressW = strdupAtoWAnsi(lpszAddress);
        if (lpszAddressW == NULL)
        {
            return GetLastError();
        }
    }        

    //
    // Allocate an W buffer as to fit the same
    // number of entries as the user's A buffer.
    //
    dwcEntries = *lpdwcbRasAutodialEntries
               / sizeof (RASAUTODIALENTRYA);

    dwcb = dwcEntries * sizeof (RASAUTODIALENTRYW);

    if (    lpRasAutodialEntries != NULL
        &&  dwcb)
    {
        lpRasAutodialEntriesW =
            (LPRASAUTODIALENTRYW)Malloc(dwcb);

        if (lpRasAutodialEntriesW == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }

        lpRasAutodialEntriesW->dwSize =
                sizeof (RASAUTODIALENTRYW);
    }
    else
    {
        dwcEntries = dwcb = 0;
    }

    //
    // Call the W version to do the work.
    //
    dwErr = RasGetAutodialAddressW(
              lpszAddressW,
              lpdwReserved,
              lpRasAutodialEntriesW,
              &dwcb,
              lpdwcRasAutodialEntries);
    if (dwErr)
    {
        goto done;
    }

    //
    // Copy the W buffer back to the user's A buffer.
    //
    if (lpRasAutodialEntries != NULL)
    {
        for (i = 0; i < *lpdwcRasAutodialEntries; i++)
        {
            lpRasAutodialEntries[i].dwSize =
                        sizeof (RASAUTODIALENTRYA);

            lpRasAutodialEntries[i].dwFlags = 
              lpRasAutodialEntriesW[i].dwFlags;

            lpRasAutodialEntries[i].dwDialingLocation =
              lpRasAutodialEntriesW[i].dwDialingLocation;

            strncpyWtoAAnsi(
              lpRasAutodialEntries[i].szEntry,
              lpRasAutodialEntriesW[i].szEntry,
              sizeof(lpRasAutodialEntries[i].szEntry));
        }
    }

done:
    //
    // Set return sizes.
    //
    *lpdwcbRasAutodialEntries = *lpdwcRasAutodialEntries
                                * sizeof (RASAUTODIALENTRYA);

    //
    // Free resources
    //
    if (lpszAddressW != NULL)
    {
        Free(lpszAddressW);
    }

    if (lpRasAutodialEntriesW != NULL)
    {
        Free(lpRasAutodialEntriesW);
    }

    return dwErr;
}


DWORD APIENTRY
RasSetAutodialAddressW(
    IN LPCWSTR              lpszAddress,
    IN DWORD                dwReserved,
    IN LPRASAUTODIALENTRYW  lpRasAutodialEntries,
    IN DWORD                dwcbRasAutodialEntries,
    IN DWORD                dwcRasAutodialEntries
    )
{
    HKEY hkeyBase = NULL,
         hkeyAddress = NULL,
         hkeyNetwork = NULL;

    HKEY hkcu;         

    BOOL fClose;

    DWORD dwErr,
          dwcbNetworkKey;

    DWORD dwNumSubKeys,
          dwMaxSubKeyLen,
          dwMaxClassLen;

    DWORD dwNumValues,
          dwMaxValueLen,
          dwMaxValueData,
          dwSecDescLen;

    DWORD i,
          j = 0,
          dwSize,
          dwDisp;

    FILETIME ftLastWriteTime;

    LPWSTR lpszAddressKey = NULL,
           lpszNetwork = NULL;

    LPWSTR lpszNetworkKey = NULL,
           lpszLocation = NULL;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasSetAutodialAddressW");

    //
    // Verify parameters.
    //
    if (dwReserved != 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    lpRasAutodialEntries != NULL
        &&  lpRasAutodialEntries->dwSize !=
            sizeof (RASAUTODIALENTRYW))
    {
        return ERROR_INVALID_SIZE;
    }

    if (!dwcbRasAutodialEntries != !dwcRasAutodialEntries)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // If the lpszAddress parameter is null, then we are setting the 
    // default Internet connection.  
    //
    if (lpszAddress == NULL)
    {
        RASAUTODIALENTRYW adEntryOld;   // previously set entry
        BOOL fDelete;

        // There is exactly 1 default connection
        //
        if (dwcRasAutodialEntries != 1)
        {
            return ERROR_INVALID_PARAMETER;
        }

        // Initialize
        //
        ZeroMemory(&adEntryOld, sizeof(adEntryOld));
        adEntryOld.dwSize = sizeof(adEntryOld);
        fDelete = FALSE;

        // Set the new default connection
        //
        dwErr = RasDefIntConnSet(lpRasAutodialEntries, &adEntryOld, &fDelete);
        if (dwErr == NO_ERROR)
        {
            // Tell the world that autodial settings have changed
            //
            // Ignore the error -- it is non-critical.
            //
            dwErr = RasDefIntConnNotify(
                        lpRasAutodialEntries, 
                        &adEntryOld, 
                        fDelete);
            dwErr = NO_ERROR;
        }

        return dwErr;
    }

    //
    // Create the name of the address key.
    //
    lpszAddressKey = FormatKey(AUTODIAL_REGADDRESSBASE,
                               lpszAddress);

    if (lpszAddressKey == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = DwOpenUsersRegistry(&hkcu, &fClose);

    if(ERROR_SUCCESS != dwErr)
    {
        //
        // .Net bug# 509379 Memory leak in function RasSetAutodialAddressW, in
        // error return path
        //
        goto done;
    }

    //
    // Open the root registry key.
    //
    dwErr = RegCreateKeyEx(
              hkcu,
              AUTODIAL_REGBASE,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hkeyBase,
              &dwDisp);
    if (dwErr)
    {
        goto done;
    }

    //
    // If lpRasAutodialEntries = NULL, the user
    // wants to delete the address key.
    //
    if (    lpRasAutodialEntries == NULL
        &&  !dwcbRasAutodialEntries
        &&  !dwcRasAutodialEntries)
    {
        //
        // Delete the address subkey.
        //
        dwErr = RegDeleteKey(hkeyBase, lpszAddressKey);
        goto done;
    }

    //
    // Open the address key in the registry.
    //
    dwErr = RegCreateKeyEx(
              hkeyBase,
              lpszAddressKey,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hkeyAddress,
              &dwDisp);
    if (dwErr)
    {
        goto done;
    }

    //
    // Do some miscellaneous parameter checking.
    //
    if (    lpRasAutodialEntries != NULL
        &&  (   !dwcbRasAutodialEntries
            ||  !dwcRasAutodialEntries
            ||  dwcbRasAutodialEntries <
                  dwcRasAutodialEntries
                * lpRasAutodialEntries->dwSize))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto done;
    }

    //
    // Get the network name associated with the
    // address.  The entries and dialing locations
    // are stored under the network.
    //
    dwErr = AutodialAddressToNetwork(hkeyBase,
                                    lpszAddress,
                                    &lpszNetwork);
    if (dwErr)
    {
        //
        // There is no network associated with
        // the address.  Create one now.
        //
        dwErr = AutodialEntryToNetwork(
                  hkeyBase,
                  lpRasAutodialEntries[0].szEntry,
                  TRUE,
                  &lpszNetwork);
        if (dwErr)
        {
            goto done;
        }

        //
        // Write the network value of the address.
        //
        dwErr = RegSetValueEx(
                  hkeyAddress,
                  AUTODIAL_REGNETWORKVALUE,
                  0,
                  REG_SZ,
                  (LPBYTE)lpszNetwork,
                  (wcslen(lpszNetwork) + 1) * sizeof (WCHAR));
        if (dwErr)
        {
            goto done;
        }
    }

    //
    // Set the entries the user has passed in.
    //
    for (i = 0; i < dwcRasAutodialEntries; i++)
    {
        dwErr = AddAutodialEntryToNetwork(
                  hkeyBase,
                  lpszNetwork,
                  lpRasAutodialEntries[i].dwDialingLocation,
                  lpRasAutodialEntries[i].szEntry);

        if (dwErr)
        {
            goto done;
        }
    }

done:
    //
    // Free resources.
    //
    if (hkeyBase != NULL)
    {
        RegCloseKey(hkeyBase);
    }

    if (hkeyAddress != NULL)
    {
        RegCloseKey(hkeyAddress);
    }

    if (hkeyNetwork != NULL)
    {
        RegCloseKey(hkeyNetwork);
    }

    if (lpszNetworkKey != NULL)
    {
        Free(lpszNetworkKey);
    }

    if (lpszAddressKey != NULL)
    {
        Free(lpszAddressKey);
    }

    if (lpszNetwork != NULL)
    {
        //
        // .Net bug# 509399 Memory allocated by GlobalAlloc is released by
        // LocalFree in RasSetAutodialAddressW
        //
        Free(lpszNetwork);
    }

    if (lpszLocation != NULL)
    {
        Free(lpszLocation);
    }

    if(fClose)
    {
        NtClose(hkcu);
    }

    return dwErr;
}


DWORD APIENTRY
RasSetAutodialAddressA(
    IN LPCSTR lpszAddress,
    IN DWORD dwReserved,
    IN LPRASAUTODIALENTRYA lpRasAutodialEntries,
    IN DWORD dwcbRasAutodialEntries,
    IN DWORD dwcRasAutodialEntries
    )
{
    NTSTATUS status;

    DWORD dwErr,
          dwcEntries,
          dwcb = 0,
          i;

    PWCHAR lpszAddressW;

    LPRASAUTODIALENTRYW lpRasAutodialEntriesW = NULL;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify parameters.
    //
    if (    lpRasAutodialEntries != NULL
        &&  lpRasAutodialEntries->dwSize
            != sizeof (RASAUTODIALENTRYA))
    {
        return ERROR_INVALID_SIZE;
    }

    if (!dwcbRasAutodialEntries != !dwcRasAutodialEntries)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Convert the address to Unicode.
    //
    if (lpszAddress)
    {
        lpszAddressW = strdupAtoWAnsi(lpszAddress);
    }
    else
    {
        lpszAddressW = NULL;
    }
    if (lpszAddress != NULL && lpszAddressW == NULL)
    {
        return GetLastError();
    }

    if (lpRasAutodialEntries != NULL)
    {
        //
        // Allocate an W buffer as to fit the same
        // number of entries as the user's A buffer.
        //
        dwcEntries =   dwcbRasAutodialEntries
                     / sizeof (RASAUTODIALENTRYA);

        dwcb = dwcEntries * sizeof (RASAUTODIALENTRYW);
        if (!dwcb)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto done;
        }

        lpRasAutodialEntriesW = (LPRASAUTODIALENTRYW)Malloc(dwcb);
        if (lpRasAutodialEntriesW == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }

        //
        // Copy the user's A buffer into the W buffer.
        //
        for (i = 0; i < dwcRasAutodialEntries; i++)
        {
            lpRasAutodialEntriesW[i].dwSize = sizeof (RASAUTODIALENTRYW);
            lpRasAutodialEntriesW[i].dwFlags = 
              lpRasAutodialEntries[i].dwFlags;
            lpRasAutodialEntriesW[i].dwDialingLocation =
              lpRasAutodialEntries[i].dwDialingLocation;

            strncpyAtoWAnsi(
              lpRasAutodialEntriesW[i].szEntry,
              lpRasAutodialEntries[i].szEntry,
              sizeof(lpRasAutodialEntriesW[i].szEntry) / sizeof(WCHAR));
        }
    }

    //
    // Call the W version to do the work.
    //
    dwErr = RasSetAutodialAddressW(
              lpszAddressW,
              dwReserved,
              lpRasAutodialEntriesW,
              dwcb,
              dwcRasAutodialEntries);
    if (dwErr)
    {
        goto done;
    }

done:
    //
    // Free resources
    //
    if (lpszAddressW != NULL)
    {
        Free(lpszAddressW);
    }

    if (lpRasAutodialEntriesW != NULL)
    {
        Free(lpRasAutodialEntriesW);
    }

    return dwErr;
}


DWORD APIENTRY
RasEnumAutodialAddressesW(
    OUT     LPWSTR *lppRasAutodialAddresses,
    IN OUT  LPDWORD lpdwcbRasAutodialAddresses,
    OUT     LPDWORD lpdwcRasAutodialAddresses)
{
    HKEY hkeyBase,
         hkeyAddresses = NULL;

    HKEY hkcu;         

    BOOL fClose;

    DWORD dwErr,
          dwNumSubKeys,
          dwMaxSubKeyLen,
          dwMaxClassLen;

    DWORD dwNumValues,
          dwMaxValueLen,
          dwMaxValueData,
          dwSecDescLen;

    DWORD i,
          j = 0,
          dwDisp,
          dwSize,
          dwTotalSize = 0,
          dwCopyRemain = 0;

    FILETIME ftLastWriteTime;

    LPWSTR lpszAddress = NULL,
           lpszBuf,
           *lppAddresses = NULL;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasEnumAutodialAddressesW");

    //
    // Verify parameters.
    //
    if (    lpdwcbRasAutodialAddresses == NULL
        ||  lpdwcRasAutodialAddresses == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwErr = DwOpenUsersRegistry(&hkcu, &fClose);

    if(ERROR_SUCCESS != dwErr)
    {   
        return dwErr;
    }

    //
    // Open the registry.
    //
    dwErr = RegOpenKeyEx(
              hkcu,
              AUTODIAL_REGBASE,
              0,
              KEY_READ,
              &hkeyBase);
    if (dwErr)
    {
        dwErr = 0;
        goto done;
    }

    dwErr = RegOpenKeyEx(
              hkeyBase,
              AUTODIAL_REGADDRESSBASE,
              0,
              KEY_READ,
              &hkeyAddresses);

    RegCloseKey(hkeyBase);

    if (dwErr)
    {
        dwErr = 0;
        goto done;
    }

    //
    // Determine the number of address subkeys.
    //
    // .Net bug# 509437 Potential buffer overflow in RasGetAutodialAddressW and
    // RasEnumAutodialAddressesW
    //
    dwErr = RegQueryInfoKey(
              hkeyAddresses,
              NULL,
              NULL,
              NULL,
              &dwNumSubKeys,
              &dwMaxSubKeyLen,
              &dwMaxClassLen,
              &dwNumValues,
              &dwMaxValueLen,
              &dwMaxValueData,
              &dwSecDescLen,
              &ftLastWriteTime);

    if (    dwErr
        ||  !dwNumSubKeys)
    {
        goto done;
    }

    //
    // Allocate a buffer large enough to hold
    // a pointer to each of the subkeys.
    //
    dwTotalSize = dwNumSubKeys * sizeof (LPWSTR);
    lppAddresses = Malloc(dwTotalSize);

    if (lppAddresses == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    ZeroMemory(lppAddresses, dwTotalSize);

    //
    // Allocate a buffer large enough to hold
    // the longest address value.
    //
    lpszAddress = Malloc((dwMaxSubKeyLen + 1) * sizeof (WCHAR));
    if (lpszAddress == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    for (i = 0, j = 0; i < dwNumSubKeys; i++)
    {
        dwSize = dwMaxSubKeyLen + 1;
        dwErr = RegEnumKey(
                  hkeyAddresses,
                  i,
                  lpszAddress,
                  dwSize);
        if (dwErr)
        {
            continue;
        }

        lppAddresses[j++] = strdupW(lpszAddress);
        dwTotalSize += (dwSize + 1) * sizeof (WCHAR);
    }

    //
    // Now we can check to see if the user's
    // buffer is large enough.
    //
    if (    lppRasAutodialAddresses == NULL
        ||  *lpdwcbRasAutodialAddresses < dwTotalSize)
    {
        dwErr = ERROR_BUFFER_TOO_SMALL;
        goto done;
    }

    //
    // Copy the pointers and the strings to the
    // user's buffer.
    //
    lpszBuf = (LPWSTR)&lppRasAutodialAddresses[j];

    //
    // So that we don't over overrun the caller's buffer we need to keep track
    // of how much we have copied.
    //
    dwCopyRemain = *lpdwcbRasAutodialAddresses;

    for (i = 0; i < j; i++)
    {
        DWORD dwTempSize;

        lppRasAutodialAddresses[i] = lpszBuf;
        dwTempSize = wcslen(lppAddresses[i]);

        lstrcpyn(
            lpszBuf,
            lppAddresses[i],
            dwCopyRemain);

        lpszBuf += dwTempSize + 1;
        dwCopyRemain -= dwTempSize;

        if (dwCopyRemain < 1)
        {
            break;
        }
    }

done:
    //
    // Set return sizes and count.
    //
    *lpdwcbRasAutodialAddresses = dwTotalSize;
    *lpdwcRasAutodialAddresses = j;

    //
    // Free resources.
    //
    if (hkeyAddresses != NULL)
    {
        RegCloseKey(hkeyAddresses);
    }

    if(fClose)
    {
        NtClose(hkcu);
    }

    //
    // Free the array of LPWSTRs.
    //
    if (lppAddresses != NULL)
    {
        for (i = 0; i < dwNumSubKeys; i++)
        {
            if (lppAddresses[i] != NULL)
            {
                Free(lppAddresses[i]);
            }
        }
        Free(lppAddresses);
    }
    Free0(lpszAddress);

    return dwErr;
}


DWORD APIENTRY
RasEnumAutodialAddressesA(
    OUT     LPSTR   *lppRasAutodialAddresses,
    IN OUT  LPDWORD lpdwcbRasAutodialAddresses,
    OUT     LPDWORD lpdwcRasAutodialAddresses
    )
{
    DWORD dwErr,
          dwcb,
          dwcAddresses = 0,
          dwcbAddresses = 0,
          i,
          dwCopyRemain = 0;

    LPWSTR *lppRasAutodialAddressesW = NULL;

    LPSTR lpszAddress;

    //
    // Verify parameters.
    //
    if (    lpdwcbRasAutodialAddresses == NULL
        ||  lpdwcRasAutodialAddresses == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Call the W version to determine
    // how big the W buffer should be.
    //
    dwErr = RasEnumAutodialAddressesW(NULL,
                                      &dwcb,
                                      &dwcAddresses);

    if (    dwErr
        &&  dwErr != ERROR_BUFFER_TOO_SMALL)
    {
        return dwErr;
    }

    //
    // Now we can figure out if the user's A
    // buffer is big enough.
    //
    dwcbAddresses = dwcb - (dwcAddresses * sizeof (LPWSTR));
    if (    lppRasAutodialAddresses == NULL
        ||  *lpdwcbRasAutodialAddresses <
            (dwcAddresses * sizeof (LPSTR)
            + (dwcbAddresses / sizeof (WCHAR))))
    {
        dwErr = ERROR_BUFFER_TOO_SMALL;
        goto done;
    }

    //
    // Allocate an W buffer as specified by
    // the W call.
    //
    lppRasAutodialAddressesW = (LPWSTR *)Malloc(dwcb);
    if (lppRasAutodialAddressesW == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Call the W version again to get
    // the actual list of addresses.
    //
    dwErr = RasEnumAutodialAddressesW(
              lppRasAutodialAddressesW,
              &dwcb,
              &dwcAddresses);
    if (dwErr)
    {
        goto done;
    }

    //
    // So that we don't over overrun the caller's buffer we need to keep track
    // of how much we have copied.
    //
    dwCopyRemain = *lpdwcbRasAutodialAddresses;

    //
    // Copy the W addresses back into the user's
    // A buffer.
    //
    lpszAddress = (LPSTR)&lppRasAutodialAddresses[dwcAddresses];
    for (i = 0; i < dwcAddresses; i++)
    {
        DWORD dwTempSize;

        lppRasAutodialAddresses[i] = lpszAddress;
        dwTempSize = wcslen(lppRasAutodialAddressesW[i]);

        strncpyWtoAAnsi(
            lpszAddress,
            lppRasAutodialAddressesW[i],
            dwCopyRemain);

        lpszAddress += dwTempSize + 1;
        dwCopyRemain -= dwTempSize;

        if (dwCopyRemain < 1)
        {
            break;
        }
    }

done:
    //
    // Set return size and count.
    //
    *lpdwcbRasAutodialAddresses =
      (dwcAddresses * sizeof (LPSTR))
      + (dwcbAddresses / sizeof (WCHAR));

    *lpdwcRasAutodialAddresses = dwcAddresses;

    //
    // Free resources.
    //
    if (lppRasAutodialAddressesW != NULL)
    {
        Free(lppRasAutodialAddressesW);
    }

    return dwErr;
}


DWORD APIENTRY
RasSetAutodialEnableW(
    IN DWORD dwDialingLocation,
    IN BOOL fEnabled
    )
{
    HKEY    hkeyBase,
            hkeyDisabled = NULL;

    DWORD   dwcb,
            dwErr,
            dwDisp;

    BOOL fClose;            

    WCHAR   szLocation[16];
    DWORD   dwfEnabled = (DWORD)!fEnabled;

    HKEY hkcu;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasSetAutodialEnableW");

    dwErr = DwOpenUsersRegistry(&hkcu, &fClose);

    if(ERROR_SUCCESS != dwErr)
    {
        return dwErr;
    }

    //
    // Open the registry.
    //
    dwErr = RegCreateKeyEx(
              hkcu,
              AUTODIAL_REGBASE,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hkeyBase,
              &dwDisp);
    if (dwErr)
    {
        goto done;
    }

    dwErr = RegCreateKeyEx(
              hkeyBase,
              AUTODIAL_REGDISABLEDBASE,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hkeyDisabled,
              &dwDisp);

    RegCloseKey(hkeyBase);

    if (dwErr)
    {
        goto done;
    }

    //
    // Set the value.
    //
    _snwprintf(
        szLocation,
        sizeof(szLocation) / sizeof(WCHAR),
        L"%d",
        dwDialingLocation);

    dwErr = RegSetValueEx(
              hkeyDisabled,
              szLocation,
              0,
              REG_DWORD,
              (LPBYTE)&dwfEnabled,
              sizeof (DWORD));

    if (dwErr)
    {
        goto done;
    }

done:

    if(NULL != hkeyDisabled)
    {
        //
        // Free resources.
        //
        RegCloseKey(hkeyDisabled);
    }

    if(fClose)
    {
        NtClose(hkcu);
    }

    return dwErr;
}


DWORD APIENTRY
RasSetAutodialEnableA(
    IN DWORD dwDialingLocation,
    IN BOOL fEnabled
    )
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    return RasSetAutodialEnableW(dwDialingLocation, fEnabled);
}


DWORD APIENTRY
RasGetAutodialEnableW(
    IN  DWORD dwDialingLocation,
    OUT LPBOOL lpfEnabled
    )
{
    HKEY    hkeyBase = NULL,
            hkeyDisabled = NULL;

    HKEY    hkcu;            
    DWORD   dwcb,
            dwErr,
            dwDisp,
            dwType = REG_DWORD,
            dwSize;

    WCHAR szLocation[16];

    DWORD dwfDisabled = 0;

    BOOL fClose;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetAutodialEnableW");
    //
    // Verify parameters.
    //
    if (lpfEnabled == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwErr = DwOpenUsersRegistry(&hkcu, &fClose);

    if(ERROR_SUCCESS != dwErr)
    {   
        return dwErr;
    }

    //
    // Open the registry.
    //
    dwErr = RegOpenKeyEx(
              hkcu,
              AUTODIAL_REGBASE,
              0,
              KEY_READ,
              &hkeyBase);

    if (dwErr)
    {
        goto done;
    }

    dwErr = RegOpenKeyEx(
              hkeyBase,
              AUTODIAL_REGDISABLEDBASE,
              0,
              KEY_READ,
              &hkeyDisabled);

    RegCloseKey(hkeyBase);

    if (dwErr)
    {
        goto done;
    }

    //
    // Get the value.
    //
    _snwprintf(szLocation,
             sizeof(szLocation) / sizeof(WCHAR),
             L"%d",
             dwDialingLocation);

    dwSize = sizeof (DWORD);

    dwErr = RegQueryValueEx(
              hkeyDisabled,
              szLocation,
              NULL,
              &dwType,
              (PVOID)&dwfDisabled,
              &dwSize);

    if (dwErr)
    {
        goto done;
    }

    //
    // Verify type of value read from
    // the registry.  If it's not a
    // DWORD, then set it to the default
    // value.
    //
    if (dwType != REG_DWORD)
    {
        dwfDisabled = 0;
    }

done:
    //
    // Free resources.
    //
    if (hkeyDisabled != NULL)
    {
        RegCloseKey(hkeyDisabled);
    }

    *lpfEnabled = !(BOOLEAN)dwfDisabled;

    if(fClose)
    {
        NtClose(hkcu);
    }

    return 0;
}


DWORD APIENTRY
RasGetAutodialEnableA(
    IN DWORD dwDialingLocation,
    OUT LPBOOL lpfEnabled
    )
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    return RasGetAutodialEnableW(
                    dwDialingLocation,
                    lpfEnabled);
}


DWORD
SetDefaultDword(
    IN DWORD dwValue,
    OUT LPVOID lpvValue,
    OUT LPDWORD lpdwcbValue
    )
{
    DWORD dwOrigSize;
    LPDWORD lpdwValue;

    dwOrigSize = *lpdwcbValue;

    *lpdwcbValue = sizeof (DWORD);

    if (dwOrigSize < sizeof (DWORD))
    {
        return ERROR_BUFFER_TOO_SMALL;
    }

    lpdwValue = (LPDWORD)lpvValue;

    *lpdwValue = dwValue;

    return 0;
}


DWORD
AutodialParamSetDefaults(
    IN DWORD dwKey,
    OUT LPVOID lpvValue,
    OUT LPDWORD lpdwcbValue
    )
{
    DWORD dwErr;

    if (    lpvValue == NULL
        ||  lpdwcbValue == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    switch (dwKey)
    {
    case RASADP_DisableConnectionQuery:
        dwErr = SetDefaultDword(0, lpvValue, lpdwcbValue);
        break;

    case RASADP_LoginSessionDisable:
        dwErr = SetDefaultDword(0, lpvValue, lpdwcbValue);
        break;

    case RASADP_SavedAddressesLimit:
        dwErr = SetDefaultDword(100, lpvValue, lpdwcbValue);
        break;

    case RASADP_FailedConnectionTimeout:
        dwErr = SetDefaultDword(5, lpvValue, lpdwcbValue);
        break;

    //Set this timeout to be 60 seconds for whistler bug 336524
    //
    case RASADP_ConnectionQueryTimeout:
        dwErr = SetDefaultDword(60, lpvValue, lpdwcbValue);
        break;

    default:
        dwErr = ERROR_INVALID_PARAMETER;
        break;
    }

    return dwErr;
}


DWORD
VerifyDefaultDword(
    IN LPVOID lpvValue,
    IN LPDWORD lpdwcbValue
    )
{
    if (lpvValue == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    return (*lpdwcbValue == sizeof (DWORD) ? 0 : ERROR_INVALID_SIZE);
}


DWORD
AutodialVerifyParam(
    IN DWORD dwKey,
    IN LPVOID lpvValue,
    OUT LPDWORD lpdwType,
    IN OUT LPDWORD lpdwcbValue
    )
{
    DWORD dwErr;

    switch (dwKey)
    {
    case RASADP_DisableConnectionQuery:
        *lpdwType = REG_DWORD;
        dwErr = VerifyDefaultDword(lpvValue, lpdwcbValue);
        break;

    case RASADP_LoginSessionDisable:
        *lpdwType = REG_DWORD;
        dwErr = VerifyDefaultDword(lpvValue, lpdwcbValue);
        break;

    case RASADP_SavedAddressesLimit:
        *lpdwType = REG_DWORD;
        dwErr = VerifyDefaultDword(lpvValue, lpdwcbValue);
        break;

    case RASADP_FailedConnectionTimeout:
        *lpdwType = REG_DWORD;
        dwErr = VerifyDefaultDword(lpvValue, lpdwcbValue);
        break;

    case RASADP_ConnectionQueryTimeout:
        *lpdwType = REG_DWORD;
        dwErr = VerifyDefaultDword(lpvValue, lpdwcbValue);
        break;

    default:
        dwErr = ERROR_INVALID_PARAMETER;
        break;
    }

    return dwErr;
}


DWORD APIENTRY
RasSetAutodialParamW(
    IN DWORD dwKey,
    IN LPVOID lpvValue,
    IN DWORD dwcbValue
    )
{
    HKEY hkeyBase,
         hkeyControl = NULL;

    HKEY hkcu;         

    LPWSTR lpszKey;

    DWORD dwErr,
          dwType,
          dwDisp;

    BOOL fClose;          

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasSetAutodialParamW");

    dwErr = AutodialVerifyParam(dwKey,
                                lpvValue,
                                &dwType,
                                &dwcbValue);

    if (dwErr)
    {
        return dwErr;
    }

    dwErr = DwOpenUsersRegistry(&hkcu, &fClose);

    if(ERROR_SUCCESS != dwErr)
    {
        return dwErr;
    }

    //
    // Open the registry.
    //
    dwErr = RegCreateKeyEx(
              hkcu,
              AUTODIAL_REGBASE,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hkeyBase,
              &dwDisp);

    if (dwErr)
    {
        goto done;
    }

    dwErr = RegCreateKeyEx(
              hkeyBase,
              AUTODIAL_REGCONTROLBASE,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hkeyControl,
              &dwDisp);

    RegCloseKey(hkeyBase);

    if (dwErr)
    {
        goto done;
    }

    //
    // Set the value.
    //
    dwErr = RegSetValueEx(
              hkeyControl,
              AutodialParamRegKeys[dwKey].szKey,
              0,
              dwType,
              (LPBYTE)lpvValue,
              dwcbValue);
    //
    // Free resources.
    //
done:
    if (hkeyControl != NULL)
        RegCloseKey(hkeyControl);

    if(fClose)
    {
        NtClose(hkcu);
    }

    return dwErr;
}


DWORD APIENTRY
RasSetAutodialParamA(
    IN DWORD    dwKey,
    IN LPVOID   lpvValue,
    IN DWORD    dwcbValue
    )
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    return RasSetAutodialParamW(dwKey,
                                lpvValue,
                                dwcbValue);
}


DWORD APIENTRY
RasGetAutodialParamW(
    IN  DWORD   dwKey,
    OUT LPVOID  lpvValue,
    OUT LPDWORD lpdwcbValue
    )
{
    HKEY hkeyBase, hkeyControl = NULL;
    DWORD dwErr, dwType;
    HKEY hkcu;
    BOOL fClose;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetAutodialParamW");

    //
    // Verify parameters.
    //
    if (    lpvValue == NULL
        ||  lpdwcbValue == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Initialize the return value with the default.
    //
    dwErr = AutodialParamSetDefaults(dwKey,
                                     lpvValue,
                                     lpdwcbValue);
    if (dwErr)
    {
        return dwErr;
    }

    dwErr = DwOpenUsersRegistry(&hkcu, &fClose);

    if(ERROR_SUCCESS != dwErr)
    {
        return dwErr;
    }

    //
    // Open the registry.
    //
    dwErr = RegOpenKeyEx(
              hkcu,
              AUTODIAL_REGBASE,
              0,
              KEY_READ,
              &hkeyBase);

    if (dwErr)
    {
        goto done;
    }

    dwErr = RegOpenKeyEx(
              hkeyBase,
              AUTODIAL_REGCONTROLBASE,
              0,
              KEY_READ,
              &hkeyControl);

    RegCloseKey(hkeyBase);

    if (dwErr)
    {
        goto done;
    }

    dwErr = RegQueryValueEx(
              hkeyControl,
              AutodialParamRegKeys[dwKey].szKey,
              NULL,
              &dwType,
              lpvValue,
              lpdwcbValue);

    if (dwErr)
    {
        goto done;
    }

done:
    //
    // Free resources.
    //
    if (hkeyControl != NULL)
    {
        RegCloseKey(hkeyControl);
    }

    if(fClose)
    {
        NtClose(hkcu);
    }

    return 0;
}


DWORD APIENTRY
RasGetAutodialParamA(
    IN  DWORD   dwKey,
    OUT LPVOID  lpvValue,
    OUT LPDWORD lpdwcbValue
    )
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    return RasGetAutodialParamW(dwKey,
                                lpvValue,
                                lpdwcbValue);
}


/*++

Routine Description:

    Will return phonebook entry information not returned by any
    other rasapis. This is needed by DDM to do redial on link
    failure etc.
    This call lives in rasapi.dll instead of DDM because calls
    to the phonebook library pull in a lot of static library code
    and since rasapi already links to this code and DDM loads
    rasapi.dll it is more efficient to put it here.
    This call is private. The prototype is defined in DDM. This is
    called only by DDM.

Arguments:

Return Value:

            NO_ERROR         - Success
            Non-zero returns - Failure

--*/

DWORD
DDMGetPhonebookInfo(
    LPWSTR  lpwsPhonebookName,
    LPWSTR  lpwsPhonebookEntry,
    LPDWORD lpdwNumSubEntries,
    LPDWORD lpdwNumRedialAttempts,
    LPDWORD lpdwNumSecondsBetweenAttempts,
    BOOL *  lpfRedialOnLinkFailure,
    CHAR *  szzPppParameters,
    LPDWORD lpdwMode,
    PVOID * ppvContext,
    PVOID   pvSubEntryEnumHandler,
    PVOID   pvSubEntryEnumHandlerContext
)
{
    DWORD      dwRetCode = NO_ERROR;
    PBFILE     file;
    PBFILE *   pfile;
    PBENTRY*   pEntry = NULL;
    DTLNODE*   pNode  = NULL;
    BOOL       fIpPrioritizeRemote = TRUE;
    BOOL       fIpVjCompression  = TRUE;
    DWORD      dwIpAddressSource = PBUFVAL_ServerAssigned;
    CHAR*      pszIpAddress      = NULL;
    DWORD      dwIpNameSource    = PBUFVAL_ServerAssigned;
    CHAR*      pszIpDnsAddress   = NULL;
    CHAR*      pszIpDns2Address  = NULL;
    CHAR*      pszIpWinsAddress  = NULL;
    CHAR*      pszIpWins2Address = NULL;
    CHAR*      pszIpDnsSuffix    = NULL;

    
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    dwRetCode = LoadRasmanDllAndInit();

    if (dwRetCode)
    {
        return dwRetCode;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    if(NULL == ppvContext)
    {
        pfile = &file;
        
        dwRetCode = ReadPhonebookFile( lpwsPhonebookName,
                                       NULL,
                                       lpwsPhonebookEntry,
                                       RPBF_ReadOnly, pfile );
        if (dwRetCode != NO_ERROR)
        {
            return( dwRetCode );
        }
    }
    else if(NULL == *ppvContext)
    {   
        //
        // Allocate the pfile structure
        //
        pfile = LocalAlloc(LPTR, sizeof(PBFILE));
        
        if(NULL == pfile)
        {
            return E_OUTOFMEMORY;
        }

        dwRetCode = ReadPhonebookFile(lpwsPhonebookName,
                                         NULL,
                                         NULL,
                                         RPBF_ReadOnly, pfile);

        if(dwRetCode != NO_ERROR)
        {
            LocalFree(pfile);
            pfile = NULL;
            return dwRetCode;
        }
    }
    else
    {
        pfile = *ppvContext;
    }

    if(NULL == ppvContext)
    {
        if ((pNode = DtlGetFirstNode(pfile->pdtllistEntries)) == NULL)
        {
            dwRetCode = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
            goto done;
        }
    }
    else
    {
        pNode = EntryNodeFromName(pfile->pdtllistEntries,
                                    lpwsPhonebookEntry);

        if(pNode == NULL)
        {
            dwRetCode = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
            goto done;
        }
    }

    if ((pEntry = (PBENTRY* )DtlGetData(pNode)) == NULL)
    {   
        dwRetCode = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
        goto done;
    }

    *lpdwNumSubEntries              = DtlGetNodes(pEntry->pdtllistLinks);
    *lpdwNumRedialAttempts          = pEntry->dwRedialAttempts;
    *lpdwNumSecondsBetweenAttempts  = pEntry->dwRedialSeconds;
    *lpfRedialOnLinkFailure         = pEntry->fRedialOnLinkFailure;
    *lpdwMode                       = pEntry->dwDialMode;
    

    ClearParamBuf( szzPppParameters );

    fIpPrioritizeRemote = pEntry->fIpPrioritizeRemote;

    AddFlagToParamBuf(
            szzPppParameters, PBUFKEY_IpPrioritizeRemote,
            fIpPrioritizeRemote );

    fIpVjCompression = pEntry->fIpHeaderCompression;

    AddFlagToParamBuf(
            szzPppParameters, PBUFKEY_IpVjCompression,
            fIpVjCompression );

    dwIpAddressSource = pEntry->dwIpAddressSource;

    AddLongToParamBuf(
            szzPppParameters, PBUFKEY_IpAddressSource,
            (LONG )dwIpAddressSource );

    pszIpAddress = strdupWtoA(pEntry->pszIpAddress);

    AddStringToParamBuf(
            szzPppParameters, PBUFKEY_IpAddress, pszIpAddress );

    Free(pszIpAddress);

    dwIpNameSource = pEntry->dwIpNameSource;

    AddLongToParamBuf(
            szzPppParameters, PBUFKEY_IpNameAddressSource,
            (LONG )dwIpNameSource );

    pszIpDnsAddress = strdupWtoA(pEntry->pszIpDnsAddress);

    AddStringToParamBuf(
            szzPppParameters, PBUFKEY_IpDnsAddress,
            pszIpDnsAddress );

    Free(pszIpDnsAddress);

    pszIpDns2Address = strdupWtoA(pEntry->pszIpDns2Address);

    AddStringToParamBuf(
            szzPppParameters, PBUFKEY_IpDns2Address,
            pszIpDns2Address );

    Free(pszIpDns2Address);

    pszIpWinsAddress = strdupWtoA(pEntry->pszIpWinsAddress);

    AddStringToParamBuf(
            szzPppParameters, PBUFKEY_IpWinsAddress,
            pszIpWinsAddress );

    Free(pszIpWinsAddress);

    pszIpWins2Address = strdupWtoA(pEntry->pszIpWins2Address);

    AddStringToParamBuf(
            szzPppParameters, PBUFKEY_IpWins2Address,
            pszIpWins2Address );

    Free(pszIpWins2Address);

    AddLongToParamBuf(
        szzPppParameters,
        PBUFKEY_IpDnsFlags,
        (LONG )pEntry->dwIpDnsFlags);

    pszIpDnsSuffix = strdupWtoA(pEntry->pszIpDnsSuffix);

    AddStringToParamBuf(
        szzPppParameters,
        PBUFKEY_IpDnsSuffix,
        pszIpDnsSuffix);

    Free(pszIpDnsSuffix);

    //
    // Now Iterate over all links and call SubEntryEnumHandler
    // if available
    //
    if(NULL != pvSubEntryEnumHandler)
    {
        SUBENTRY_ENUM_HANDLER SubEntryEnumHandler =
                (SUBENTRY_ENUM_HANDLER) pvSubEntryEnumHandler;
        PBLINK *pLink;
        TCHAR szDeviceType[RAS_MaxDeviceType + 1];

        ZeroMemory(szDeviceType, sizeof(szDeviceType));
        
        for (pNode = DtlGetFirstNode(pEntry->pdtllistLinks);
             pNode;
             pNode = DtlGetNextNode(pNode))
        {
            pLink = (PBLINK *) DtlGetData(pNode);

            if(pLink == NULL)
            {
                continue;
            }

            //
            // Set device information.
            //
            switch (pLink->pbport.pbdevicetype)
            {
                case PBDT_Isdn:
                    lstrcpyn(
                        szDeviceType,
                        RASDT_Isdn,
                        sizeof(szDeviceType) / sizeof(TCHAR));

                    break;

                case PBDT_X25:
                    lstrcpyn(
                        szDeviceType,
                        RASDT_X25,
                        sizeof(szDeviceType) / sizeof(TCHAR));

                    break;

                case PBDT_Pad:
                    lstrcpyn(
                        szDeviceType,
                        RASDT_Pad,
                        sizeof(szDeviceType) / sizeof(TCHAR));

                    break;

                case PBDT_Other:
                case PBDT_Irda:
                case PBDT_Vpn:
                case PBDT_Serial:
                case PBDT_Atm:
                case PBDT_Parallel:
                case PBDT_Sonet:
                case PBDT_Sw56:
                case PBDT_FrameRelay:
                case PBDT_PPPoE:
                {
                    DWORD dwErr;

                    dwErr = GetRasmanDeviceType(
                        pLink,
                        szDeviceType);

                    if (ERROR_SUCCESS == dwErr)
                    {
                        //
                        // Convert the device type to lower case
                        // to be consistent with the predefined
                        // types.
                        //
                        _tcslwr(szDeviceType);
                    }

                    break;
                }
                default:
                    lstrcpyn(
                        szDeviceType,
                        RASDT_Modem,
                        sizeof(szDeviceType) / sizeof(TCHAR));

                    break;

            }


            SubEntryEnumHandler(
                    pvSubEntryEnumHandlerContext,
                    szDeviceType);
        }
    }

done:

    if(     (NULL == ppvContext)
        ||  (NO_ERROR != dwRetCode))
    {
        ClosePhonebookFile( pfile );

        if(pfile != &file)
        {
            LocalFree(pfile);
        }
        
        if(NULL != ppvContext)
        {
            *ppvContext = NULL;
        }
    }
    else
    {
        *ppvContext = pfile;
    }

    return( dwRetCode );
}

VOID
DDMFreePhonebookContext(VOID *pvContext)
{
    if(NULL == pvContext)
    {
        return;
    }

    ClosePhonebookFile((PBFILE *)pvContext);
    LocalFree(pvContext);
}


DWORD APIENTRY
RasIsRouterConnection(
    IN HRASCONN hrasconn
    )
{
    DWORD dwErr;
    DWORD i, dwcbPorts, dwcPorts;
    RASMAN_PORT *lpPorts;
    RASMAN_INFO info;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Get the ports associated with the
    // connection.
    //
    dwcbPorts = dwcPorts = 0;
    dwErr = g_pRasEnumConnectionPorts(NULL,
                                      (HCONN)hrasconn,
                                      NULL,
                                      &dwcbPorts,
                                      &dwcPorts);

    //
    // If there are no ports associated with
    // the connection then return ERROR_NO_MORE_ITEMS.
    //
    if (    (   !dwErr
            &&  !dwcPorts)
        ||  dwErr != ERROR_BUFFER_TOO_SMALL)
    {
        return 0;
    }

    lpPorts = Malloc(dwcbPorts);
    if (lpPorts == NULL)
    {
        return 0;
    }

    dwErr = g_pRasEnumConnectionPorts(NULL,
                                      (HCONN)hrasconn,
                                      lpPorts,
                                      &dwcbPorts,
                                      &dwcPorts);
    if (dwErr)
    {
        Free(lpPorts);
        return 0;
    }

    //
    // Enumerate the ports associated with
    // the connection to find the requested
    // subentry.
    //
    dwErr = g_pRasGetInfo(NULL,
                          lpPorts[0].P_Handle,
                          &info);
    if (dwErr)
    {
        //
        // .Net bug# 509407 Memory leak in function RasIsRouterConnection, in
        // error return path
        //
        Free(lpPorts);
        return 0;
    }

    //
    // Free resources.
    //
    Free(lpPorts);

    return (info.RI_CurrentUsage & CALL_ROUTER) ? 1 : 0;
}

DWORD APIENTRY
RasInvokeEapUI(
        HRASCONN            hRasConn,
        DWORD               dwSubEntry,
        LPRASDIALEXTENSIONS lpRasDialExtensions,
        HWND                hwnd
        )
{
    DWORD dwErr = 0;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if(     0 == hRasConn
        ||  NULL == lpRasDialExtensions)
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto done;
    }

    if (sizeof (RASDIALEXTENSIONS) != lpRasDialExtensions->dwSize)
    {
        dwErr = ERROR_INVALID_SIZE;
        goto done;
    }

    //
    // Call the function that does all the work
    //
    dwErr = InvokeEapUI(hRasConn,
                        dwSubEntry,
                        lpRasDialExtensions,
                        hwnd);

done:
    return dwErr;
}

DWORD APIENTRY
RasGetLinkStatistics(
        HRASCONN    hRasConn,
        DWORD       dwSubEntry,
        RAS_STATS   *lpStatistics
        )
{
    DWORD dwErr = SUCCESS;
    HPORT hPort;
    DWORD dwSize;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if(     0 == hRasConn
        ||  0 == dwSubEntry
        ||  NULL == lpStatistics
        ||  (sizeof(RAS_STATS) != lpStatistics->dwSize))
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

#if DBG
    ASSERT(sizeof(RAS_STATS) ==
           sizeof(DWORD) * (MAX_STATISTICS_EXT + 3));
#endif

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        goto done;
    }

    if (DwRasInitializeError)
    {
        dwErr = DwRasInitializeError;
        goto done;
    }

    //
    // Get statistics corresponding to this subentry
    //
    dwErr = g_pRasLinkGetStatistics(
                        NULL,
                        (HCONN) hRasConn,
                        dwSubEntry,
                        (LPBYTE)
                        &(lpStatistics->dwBytesXmited)
                        );

    if(SUCCESS != dwErr)
    {
        RASAPI32_TRACE1("RasLinkGetStatistics: failed to get "
                "statistics. %d",
                dwErr);

        goto done;
    }

done:

    return dwErr;

}

DWORD APIENTRY
RasGetConnectionStatistics(
        HRASCONN    hRasConn,
        RAS_STATS   *lpStatistics
        )
{
    DWORD dwErr = SUCCESS;
    HPORT hPort;
    DWORD dwSize;
    DWORD dwSubEntry;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if(     0 == hRasConn
        ||  NULL == lpStatistics
        ||  (sizeof(RAS_STATS) != lpStatistics->dwSize))
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

#if DBG
    ASSERT(sizeof(RAS_STATS) ==
           sizeof(DWORD) * (MAX_STATISTICS_EXT + 3));
#endif

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        goto done;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Get the connection statistics
    //
    dwErr = g_pRasConnectionGetStatistics(
                        NULL,
                        (HCONN) hRasConn,
                        (LPBYTE)
                        &(lpStatistics->dwBytesXmited));

    if(SUCCESS != dwErr)
    {
        RASAPI32_TRACE1("RasGetConnectionStatistics: failed "
               "to get stats. %d",
               dwErr);

        goto done;
    }


done:
    return dwErr;
}

DWORD APIENTRY
RasClearLinkStatistics(
            HRASCONN    hRasConn,
            DWORD       dwSubEntry
            )
{
    DWORD dwErr = SUCCESS;
    HPORT hPort;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        goto done;
    }

    if (DwRasInitializeError)
    {
        dwErr = DwRasInitializeError;
        goto done;
    }

    //
    // Get the port
    //
    dwErr = SubEntryPort(hRasConn,
                         dwSubEntry,
                         &hPort);
    if(SUCCESS != dwErr)
    {
        RASAPI32_TRACE1("RasClearLinkStatistics: failed to "
               "get port. %d",
               dwErr);

        goto done;
    }

    //
    // Clear stats
    //
    dwErr = g_pRasPortClearStatistics(NULL, hPort);

    if(SUCCESS != dwErr)
    {
        RASAPI32_TRACE1("RasClearLinkStatistics: failed to "
                "clear stats. %d",
                dwErr);

        goto done;
    }

done:
    return dwErr;
}

DWORD APIENTRY
RasClearConnectionStatistics(
                    HRASCONN hRasConn
                    )
{
    DWORD dwErr = SUCCESS;
    HPORT hPort;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        goto done;
    }

    if (DwRasInitializeError)
    {
        dwErr = DwRasInitializeError;
        goto done;
    }

    dwErr = g_pRasGetHportFromConnection(
                            NULL,
                            (HCONN) hRasConn,
                            &hPort
                            );

    if(SUCCESS != dwErr)
    {
        RASAPI32_TRACE1("RasClearConnectionStatistics: "
               "failed to clear stats. %d",
                dwErr);

        goto done;
    }

    //
    // Clear stats
    //
    dwErr = g_pRasBundleClearStatistics(NULL, hPort);
    if(SUCCESS != dwErr)
    {
        RASAPI32_TRACE1("RasClearConnectionStatistics: "
               "failed to clear stats.  %d",
               dwErr);

        goto done;
    }

done:
    return dwErr;
}



DWORD APIENTRY
RasGetEapUserDataW(HANDLE  hToken,
                   LPCWSTR pszPhonebook,
                   LPCWSTR pszEntry,
                   BYTE    *pbEapData,
                   DWORD   *pdwSizeofEapData)
{
    DWORD dwErr = ERROR_SUCCESS;
    DTLNODE *pdtlnode = NULL;
    PBENTRY *pEntry = NULL;
    STARTUPINFO startupinfo;
    BOOL fRouter = FALSE;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetEapUserDataW");

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        goto done;
    }

    if (DwRasInitializeError)
    {
        dwErr = DwRasInitializeError;
        goto done;
    }

    //
    // Validate parameters
    //
    if (NULL == pdwSizeofEapData)
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    //
    // Load the phonebook file.
    //

    dwErr = ReadEntryFromSystem(
                    pszPhonebook,
                    pszEntry,
                    RPBF_NoCreate,
                    NULL,
                    &pdtlnode,
                    NULL);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    pEntry = (PBENTRY *)DtlGetData(pdtlnode);

    ASSERT(pEntry);

    fRouter = IsRouterPhonebook(pszPhonebook);

    //
    // Ask rasman to do the work.
    //
    dwErr = g_pRasGetEapUserInfo(
                hToken,
                pbEapData,
                pdwSizeofEapData,
                pEntry->pGuid,
                fRouter,
                pEntry->dwCustomAuthKey);

done:

    //
    // Clean up.
    //
    if (pdtlnode)
    {
        DestroyEntryNode(pdtlnode);
    }

    RASAPI32_TRACE1("RasGetEapUserDataW. 0x%x",
            dwErr);

    return dwErr;
}

DWORD APIENTRY
RasSetEapUserDataW(HANDLE  hToken,
                   LPCWSTR pszPhonebook,
                   LPCWSTR pszEntry,
                   BYTE    *pbEapData,
                   DWORD   dwSizeofEapData)
{
    DWORD dwErr  = ERROR_SUCCESS;
    BOOL  fClear = FALSE;

    DTLNODE *pdtlnode = NULL;

    PBENTRY *pEntry = NULL;

    STARTUPINFO startupinfo;

    BOOL fRouter = FALSE;

    BOOL fPbkOpened = FALSE;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasSetEapUserDataW");

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        goto done;
    }

    if (DwRasInitializeError)
    {
        dwErr = DwRasInitializeError;
        goto done;
    }

    //
    // Validate parameters
    //
    if (    (0 == dwSizeofEapData)
        ||  (NULL == pbEapData))
    {
        fClear = TRUE;
    }

    //
    // Load the phonebook file.
    //

    dwErr = ReadEntryFromSystem(
                pszPhonebook,
                pszEntry,
                RPBF_NoCreate,
                NULL,
                &pdtlnode,
                NULL);


    if(SUCCESS != dwErr)
    {
        goto done;
    }

    fPbkOpened = TRUE;

    pEntry = (PBENTRY *)DtlGetData(pdtlnode);

    ASSERT(pEntry);

    fRouter = IsRouterPhonebook(pszPhonebook);

    //
    // Ask rasman to do the work.
    //
    dwErr = g_pRasSetEapUserInfo(
                        hToken,
                        pEntry->pGuid,
                        pbEapData,
                        dwSizeofEapData,
                        fClear,
                        fRouter,
                        pEntry->dwCustomAuthKey);

done:

    if (pdtlnode)
    {
        DestroyEntryNode(pdtlnode);
    }

    RASAPI32_TRACE1("RasSetEapUserDataW. 0x%x",
            dwErr);

    return dwErr;
}

DWORD APIENTRY
RasGetEapUserDataA(HANDLE hToken,
                   LPCSTR pszPhonebook,
                   LPCSTR pszEntry,
                   BYTE   *pbEapData,
                   DWORD  *pdwSizeofEapData)
{
    DWORD dwErr = ERROR_SUCCESS;

    WCHAR szPhonebookW[MAX_PATH];

    WCHAR szEntryNameW[RAS_MaxEntryName + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if(NULL == pdwSizeofEapData)
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (pszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    pszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the lpszEntry string to Unicode.
    //
    if (pszEntry != NULL)
    {
        strncpyAtoWAnsi(szEntryNameW,
                    pszEntry,
                    RAS_MaxEntryName + 1);
    }

    dwErr = RasGetEapUserDataW(
                     hToken,
                       (NULL != pszPhonebook)
                     ? szPhonebookW
                     : NULL,
                       (NULL != pszEntry)
                     ? szEntryNameW
                     : NULL,
                     pbEapData,
                     pdwSizeofEapData);

done:

    return dwErr;

}

DWORD APIENTRY
RasSetEapUserDataA(HANDLE hToken,
                   LPCSTR pszPhonebook,
                   LPCSTR pszEntry,
                   BYTE   *pbEapData,
                   DWORD  dwSizeofEapData)
{
    DWORD dwErr = ERROR_SUCCESS;

    WCHAR szPhonebookW[MAX_PATH];

    WCHAR szEntryNameW[RAS_MaxEntryName + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Convert the pszPhonebook string to Unicode.
    //
    if (pszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    pszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the pszEntry string to Unicode.
    //
    if (pszEntry != NULL)
    {
        strncpyAtoWAnsi(szEntryNameW,
                    pszEntry,
                    RAS_MaxEntryName + 1);
    }

    dwErr = RasSetEapUserDataW(
                     hToken,
                       (NULL != pszPhonebook)
                     ? szPhonebookW
                     : NULL,
                       (NULL != pszEntry)
                     ? szEntryNameW
                     : NULL,
                     pbEapData,
                     dwSizeofEapData);

    return dwErr;
}

DWORD APIENTRY
RasGetCustomAuthDataW(
            LPCWSTR pszPhonebook,
            LPCWSTR pszEntry,
            BYTE    *pbCustomAuthData,
            DWORD   *pdwSizeofCustomAuthData)
{
    DWORD dwErr = ERROR_SUCCESS;

    DTLNODE *pdtlnode = NULL;

    PBENTRY *pEntry = NULL;

    DWORD cbCustomAuthData;
    DWORD cbData = 0;
    PBYTE pbData = NULL;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetCustomAuthDataW");

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        goto done;
    }

    if (DwRasInitializeError)
    {
        dwErr = DwRasInitializeError;
        goto done;
    }

    //
    // Validate parameters
    //
    if (NULL == pdwSizeofCustomAuthData)
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    cbCustomAuthData = *pdwSizeofCustomAuthData;

    dwErr = ReadEntryFromSystem(
                    pszPhonebook,
                    pszEntry,
                    RPBF_NoCreate,
                    NULL,
                    &pdtlnode,
                    NULL);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    pEntry = (PBENTRY *)DtlGetData(pdtlnode);

    ASSERT(pEntry);

    dwErr = DwGetCustomAuthData(pEntry,
                                &cbData,
                                &pbData);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    *pdwSizeofCustomAuthData = cbData;

    if(     (cbCustomAuthData < cbData)
        ||  (NULL == pbCustomAuthData))
    {
        dwErr = ERROR_BUFFER_TOO_SMALL;
        goto done;
    }

    memcpy(pbCustomAuthData,
           pbData,
           *pdwSizeofCustomAuthData);

done:

    //
    // Clean up.
    //
    if (pdtlnode)
    {
        DestroyEntryNode(pdtlnode);
    }

    RASAPI32_TRACE1("RasGetCustomAuthDataW. 0x%x",
            dwErr);

    return dwErr;
}

DWORD APIENTRY
RasSetCustomAuthDataW(
        LPCWSTR pszPhonebook,
        LPCWSTR pszEntry,
        BYTE    *pbCustomAuthData,
        DWORD   cbCustomAuthData
        )
{
    DWORD dwErr = ERROR_SUCCESS;

    PBFILE pbfile;

    DTLNODE *pdtlnode = NULL;

    PBENTRY *pEntry = NULL;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasSetCustomAuthDataW");

    ZeroMemory(&pbfile, sizeof(PBFILE));

    pbfile.hrasfile = -1;

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        goto done;
    }

    if (DwRasInitializeError)
    {
        dwErr = DwRasInitializeError;
        goto done;
    }

    dwErr = GetPbkAndEntryName(
                        pszPhonebook,
                        pszEntry,
                        RPBF_NoCreate,
                        &pbfile,
                        &pdtlnode);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    pEntry = (PBENTRY *)DtlGetData(pdtlnode);

    ASSERT(pEntry);

    dwErr = DwSetCustomAuthData(
                pEntry,
                cbCustomAuthData,
                pbCustomAuthData);

    if(ERROR_SUCCESS != dwErr)
    {
        goto done;
    }

    pEntry->fDirty = TRUE;

    WritePhonebookFile(&pbfile, NULL);

done:

    //
    // Clean up.
    //
    ClosePhonebookFile(&pbfile);

    RASAPI32_TRACE1("RasSetCustomAuthDataW. 0x%x",
            dwErr);

    return dwErr;
}

DWORD APIENTRY
RasGetCustomAuthDataA(
        LPCSTR pszPhonebook,
        LPCSTR pszEntry,
        BYTE   *pbCustomAuthData,
        DWORD  *pdwSizeofCustomAuthData)
{
    DWORD dwErr = ERROR_SUCCESS;

    WCHAR szPhonebookW[MAX_PATH];

    WCHAR szEntryNameW[RAS_MaxEntryName + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if(NULL == pdwSizeofCustomAuthData)
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (pszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    pszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the lpszEntry string to Unicode.
    //
    if (pszEntry != NULL)
    {
        strncpyAtoWAnsi(szEntryNameW,
                    pszEntry,
                    RAS_MaxEntryName + 1);
    }

    dwErr = RasGetCustomAuthDataW(
                       (NULL != pszPhonebook)
                     ? szPhonebookW
                     : NULL,
                       (NULL != pszEntry)
                     ? szEntryNameW
                     : NULL,
                     pbCustomAuthData,
                     pdwSizeofCustomAuthData);

done:

    return dwErr;

}

DWORD APIENTRY
RasSetCustomAuthDataA(
        LPCSTR pszPhonebook,
        LPCSTR pszEntry,
        BYTE   *pbCustomAuthData,
        DWORD  dwSizeofCustomAuthData
        )
{
    DWORD dwErr = ERROR_SUCCESS;

    WCHAR szPhonebookW[MAX_PATH];

    WCHAR szEntryNameW[RAS_MaxEntryName + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Convert the pszPhonebook string to Unicode.
    //
    if (pszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    pszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the pszEntry string to Unicode.
    //
    if (pszEntry != NULL)
    {
        strncpyAtoWAnsi(szEntryNameW,
                    pszEntry,
                    RAS_MaxEntryName + 1);
    }

    dwErr = RasSetCustomAuthDataW(
                       (NULL != pszPhonebook)
                     ? szPhonebookW
                     : NULL,
                       (NULL != pszEntry)
                     ? szEntryNameW
                     : NULL,
                     pbCustomAuthData,
                     dwSizeofCustomAuthData
                     );

    return dwErr;
}


DWORD APIENTRY
RasQueryRedialOnLinkFailure(
                    LPCTSTR pszPhonebook,
                    LPCTSTR pszEntry,
                    BOOL   *pfEnabled)
{
    DWORD dwErr = SUCCESS;
    PBENTRY *pEntry;
    DTLNODE *pdtlnode = NULL;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if(NULL == pfEnabled)
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    *pfEnabled = FALSE;

    dwErr = GetPbkAndEntryName(
                pszPhonebook,
                pszEntry,
                0,
                NULL,
                &pdtlnode);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    pEntry = (PBENTRY *) DtlGetData(pdtlnode);

    *pfEnabled = pEntry->fRedialOnLinkFailure;

    if (pdtlnode)
    {
        DestroyEntryNode( pdtlnode );
    }

done:
    return dwErr;
}

DWORD APIENTRY
RasGetEapUserIdentityW(
    IN      LPCWSTR                 pszPhonebook,
    IN      LPCWSTR                 pszEntry,
    IN      DWORD                   dwFlags,
    IN      HWND                    hwnd,
    OUT     LPRASEAPUSERIDENTITYW*  ppRasEapUserIdentity
)
{
    DWORD       dwErr               = ERROR_SUCCESS;
    DTLNODE*    pdtlnode            = NULL;
    PBENTRY*    pEntry              = NULL;
    HKEY        hkeyBase            = NULL;
    HKEY        hkeyEap             = NULL;
    BYTE*       pbDataIn            = NULL;
    BYTE*       pbDataOut           = NULL;
    WCHAR*      pwszIdentity        = NULL;
    WCHAR*      pwszDllPath         = NULL;
    HINSTANCE   hInstanceDll        = NULL;
    DWORD       cbDataIn            = 0;
    WCHAR       szEapNumber[20];
    DWORD       dwValue;
    DWORD       dwSize;
    DWORD       cbDataOut;
    RASEAPGETIDENTITY   pRasEapGetIdentity = NULL;
    RASEAPFREEMEMORY    pRasEapFreeMemory  = NULL;
    DWORD       cbCustomData;
    PBYTE       pbCustomData;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetEapUserIdentityW");

    if (NULL == ppRasEapUserIdentity)
    {
        return(ERROR_INVALID_ADDRESS);
    }

    *ppRasEapUserIdentity = NULL;

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        return(dwErr);
    }

    if (DwRasInitializeError)
    {
        return(DwRasInitializeError);
    }

    //
    // Load the phonebook file.
    //

    dwErr = ReadEntryFromSystem(
                    pszPhonebook,
                    pszEntry,
                    RPBF_NoCreate,
                    NULL,
                    &pdtlnode,
                    NULL);

    if (SUCCESS != dwErr)
    {
        goto done;
    }

    pEntry = (PBENTRY *)DtlGetData(pdtlnode);

    ASSERT(pEntry);

    if (!(pEntry->dwAuthRestrictions & AR_F_AuthEAP))
    {
        dwErr = ERROR_INVALID_FUNCTION_FOR_ENTRY;
        goto done;
    }

    //
    // Convert the EAP number to a string
    //
    _itow(pEntry->dwCustomAuthKey, szEapNumber, 10);

    //
    // Open the registry.
    //
    dwErr = RegOpenKeyEx(
              HKEY_LOCAL_MACHINE,
              EAP_REGBASE,
              0,
              KEY_READ,
              &hkeyBase);

    if (dwErr)
    {
        goto done;
    }

    //
    // Open the registry.
    //
    dwErr = RegOpenKeyEx(
              hkeyBase,
              szEapNumber,
              0,
              KEY_READ,
              &hkeyEap);

    if (dwErr)
    {
        goto done;
    }

    //
    // Does this EAP support RasEapGetIdentity?
    //
    dwSize = sizeof(dwValue);

    dwErr = RegQueryValueEx(
                hkeyEap,
                EAP_REGINVOKE_NAMEDLG,
                NULL,
                NULL,
                (BYTE*)&dwValue,
                &dwSize);

    if (   (dwErr)
        || (dwValue != 0))
    {
        dwErr = ERROR_INVALID_FUNCTION_FOR_ENTRY;
        goto done;
    }

    //
    // Get the per user data size
    //
    dwSize = 0;

    dwErr = RasGetEapUserDataW(
                NULL,
                pszPhonebook,
                pszEntry,
                NULL,
                &dwSize);

    if (dwErr == ERROR_BUFFER_TOO_SMALL)
    {
        pbDataIn = Malloc(dwSize);

        if(NULL == pbDataIn)
        {
            dwErr = GetLastError();
            goto done;
        }

        //
        // Get the per user data
        //
        dwErr = RasGetEapUserDataW(
                    NULL,
                    pszPhonebook,
                    pszEntry,
                    pbDataIn,
                    &dwSize);

        if (dwErr != NO_ERROR)
        {
            goto done;
        }

        cbDataIn = dwSize;
    }
    else if (NO_ERROR != dwErr)
    {
        goto done;
    }

    //
    // Get the EAP dll's path ...
    //
    dwErr = GetRegExpandSz(
                hkeyEap,
                EAP_REGIDENTITY_PATH,
                &pwszDllPath);

    if (dwErr != 0)
    {
        goto done;
    }

    //
    // ... and load it
    //
    hInstanceDll = LoadLibrary(pwszDllPath);

    if (NULL == hInstanceDll)
    {
        dwErr = GetLastError();
        goto done;
    }

    //
    // Get the function pointer to call
    //
    pRasEapGetIdentity = (RASEAPGETIDENTITY) GetProcAddress(
                                hInstanceDll,
                                EAP_RASEAPGETIDENTITY);
    pRasEapFreeMemory = (RASEAPFREEMEMORY) GetProcAddress(
                                hInstanceDll,
                                EAP_RASEAPFREEMEMORY);

    if (   (NULL == pRasEapGetIdentity)
        || (NULL == pRasEapFreeMemory))
    {
        dwErr = GetLastError();
        goto done;
    }

    //
    // Get the data from the EAP dll
    //
    if (dwFlags & RASEAPF_NonInteractive)
    {
        hwnd = NULL;
    }

    if (IsRouterPhonebook(pszPhonebook))
    {
        dwFlags |= RAS_EAP_FLAG_ROUTER;
    }

    dwErr = DwGetCustomAuthData(
                    pEntry,
                    &cbCustomData,
                    &pbCustomData);

    if(ERROR_SUCCESS != dwErr)
    {
        goto done;
    }

    dwErr = pRasEapGetIdentity(
                pEntry->dwCustomAuthKey,
                hwnd,
                dwFlags,
                pszPhonebook,
                pszEntry,
                pbCustomData,
                cbCustomData,
                pbDataIn,
                cbDataIn,
                &pbDataOut,
                &cbDataOut,
                &pwszIdentity);

    if (dwErr != NO_ERROR)
    {
        goto done;
    }

    //
    // Allocate the structure.
    //
    *ppRasEapUserIdentity = Malloc(sizeof(RASEAPUSERIDENTITYW) - 1 + cbDataOut);

    if (NULL == *ppRasEapUserIdentity)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    wcsncpy((*ppRasEapUserIdentity)->szUserName, pwszIdentity, UNLEN);
    (*ppRasEapUserIdentity)->szUserName[UNLEN] = 0;
    (*ppRasEapUserIdentity)->dwSizeofEapInfo = cbDataOut;
    CopyMemory((*ppRasEapUserIdentity)->pbEapInfo, pbDataOut, cbDataOut);

done:

    //
    // Clean up.
    //
    if (pdtlnode)
    {
        DestroyEntryNode(pdtlnode);
    }

    if (NULL != hkeyBase)
    {
        RegCloseKey(hkeyBase);
    }

    if (NULL != hkeyEap)
    {
        RegCloseKey(hkeyEap);
    }

    if (NULL != pbDataIn)
    {
        Free(pbDataIn);
    }

    if (NULL != pwszDllPath)
    {
        Free(pwszDllPath);
    }

    if (NULL != pRasEapFreeMemory)
    {
        if (NULL != pbDataOut)
        {
            pRasEapFreeMemory(pbDataOut);
        }

        if (NULL != pwszIdentity)
        {
            pRasEapFreeMemory((BYTE*)pwszIdentity);
        }
    }

    if (NULL != hInstanceDll)
    {
        FreeLibrary(hInstanceDll);
    }

    RASAPI32_TRACE1("RasGetEapUserIdentityW. 0x%x", dwErr);

    return dwErr;
}

DWORD APIENTRY
RasGetEapUserIdentityA(
    IN      LPCSTR                  pszPhonebook,
    IN      LPCSTR                  pszEntry,
    IN      DWORD                   dwFlags,
    IN      HWND                    hwnd,
    OUT     LPRASEAPUSERIDENTITYA*  ppRasEapUserIdentity
)
{
    DWORD                   dwErr                               = ERROR_SUCCESS;
    WCHAR                   szPhonebookW[MAX_PATH];
    WCHAR                   szEntryNameW[RAS_MaxEntryName + 1];
    LPRASEAPUSERIDENTITYW   pRasEapUserIdentityW                = NULL;
    DWORD                   dwSizeofEapInfo;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if (NULL == ppRasEapUserIdentity)
    {
        return(ERROR_INVALID_ADDRESS);
    }

    *ppRasEapUserIdentity = NULL;

    //
    // Convert the pszPhonebook string to Unicode.
    //
    if (pszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    pszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the pszEntry string to Unicode.
    //
    if (pszEntry != NULL)
    {
        strncpyAtoWAnsi(szEntryNameW,
                    pszEntry,
                    RAS_MaxEntryName + 1);
    }

    //
    // Call the W version to do all the work.
    //
    dwErr = RasGetEapUserIdentityW(
                       (NULL != pszPhonebook)
                     ? szPhonebookW
                     : NULL,
                       (NULL != pszEntry)
                     ? szEntryNameW
                     : NULL,
                     dwFlags,
                     hwnd,
                     &pRasEapUserIdentityW);

    if (dwErr != NO_ERROR)
    {
        goto done;
    }

    //
    // Allocate the structure.
    //
    dwSizeofEapInfo = pRasEapUserIdentityW->dwSizeofEapInfo;
    *ppRasEapUserIdentity = Malloc(
                    sizeof(RASEAPUSERIDENTITYA) - 1 + dwSizeofEapInfo);

    if (NULL == *ppRasEapUserIdentity)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    //
    // Copy the fields from the W buffer
    // to the A buffer.
    //

    strncpyWtoAAnsi((*ppRasEapUserIdentity)->szUserName,
               pRasEapUserIdentityW->szUserName,
               sizeof((*ppRasEapUserIdentity)->szUserName));
    (*ppRasEapUserIdentity)->dwSizeofEapInfo = dwSizeofEapInfo;
    CopyMemory((*ppRasEapUserIdentity)->pbEapInfo,
               pRasEapUserIdentityW->pbEapInfo,
               dwSizeofEapInfo);

done:

    if (NULL != pRasEapUserIdentityW)
    {
        Free(pRasEapUserIdentityW);
    }

    return dwErr;
}

VOID APIENTRY
RasFreeEapUserIdentityW(
    IN  LPRASEAPUSERIDENTITYW   pRasEapUserIdentity
)
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if (NULL != pRasEapUserIdentity)
    {
        Free(pRasEapUserIdentity);
    }
}

VOID APIENTRY
RasFreeEapUserIdentityA(
    IN  LPRASEAPUSERIDENTITYA   pRasEapUserIdentity
)
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if (NULL != pRasEapUserIdentity)
    {
        Free(pRasEapUserIdentity);
    }
}

DWORD APIENTRY
RasDeleteSubEntryW(
        LPCWSTR pszPhonebook,
        LPCWSTR pszEntry,
        DWORD   dwSubEntryId)
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    return DwDeleteSubEntry(
                pszPhonebook,
                pszEntry,
                dwSubEntryId);
}

DWORD APIENTRY
RasDeleteSubEntryA(
        LPCSTR pszPhonebook,
        LPCSTR pszEntry,
        DWORD  dwSubEntryId)
{
    WCHAR wszPhonebook[MAX_PATH + 1];
    WCHAR wszEntry[RAS_MaxEntryName + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if(     (NULL == pszEntry)
        ||  (0 == dwSubEntryId))
    {
        return E_INVALIDARG;
    }

    if(NULL != pszPhonebook)
    {
        strncpyAtoWAnsi(wszPhonebook,   
                        pszPhonebook,
                        MAX_PATH);
    }

    strncpyAtoWAnsi(wszEntry,
                    pszEntry,
                    RAS_MaxEntryName);

    return RasDeleteSubEntryW(
                (NULL != pszPhonebook) ? wszPhonebook : NULL,
                wszEntry,
                dwSubEntryId);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\extapi\src\rasdial.c ===
/* Copyright (c) 1992, Microsoft Corporation, all rights reserved
**
** rasdial.c
** Remote Access External APIs
** RasDial API and subroutines
**
** 10/12/92 Steve Cobb
**
** CODEWORK:
**
**   * Strange error codes may be returned if the phonebook entry (or caller's
**     overrides) do not match the port configuration, e.g. if a modem entry
**     refers to a port configured for local PAD.  Should add checks to give
**     better error codes in this case.
*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <extapi.h>
#include <stdlib.h>

#include <lmwksta.h>
#include <lmapibuf.h>
#include <winsock.h>

#define SECS_ListenTimeout  120
#define SECS_ConnectTimeout 120

extern BOOL g_FRunningInAppCompatMode;

VOID            StartSubentries(RASCONNCB *prasconncb);

VOID            SuspendSubentries(RASCONNCB *prasconncb);

VOID            ResumeSubentries(RASCONNCB *prasconncb);

BOOLEAN         IsSubentriesSuspended(RASCONNCB *prasconncb);

VOID            RestartSubentries(RASCONNCB *prasconncb);

VOID            SyncDialParamsSubentries(RASCONNCB *prasconncb);

VOID            SetSubentriesBundled(RASCONNCB *prasconncb);

RASCONNSTATE    MapSubentryState(RASCONNCB *prasconncb);

VOID            RasDialTryNextAddress(IN RASCONNCB** pprasconncb);

DWORD           LoadMprApiDll();

BOOL            CaseInsensitiveMatch(IN LPCWSTR pszStr1, IN LPCWSTR pszStr2);

DWORD APIENTRY
RasDialA(
    IN  LPRASDIALEXTENSIONS lpextensions,
    IN  LPCSTR              lpszPhonebookPath,
    IN  LPRASDIALPARAMSA    lprdp,
    IN  DWORD               dwNotifierType,
    IN  LPVOID              notifier,
    OUT LPHRASCONN          lphrasconn )
{
    RASDIALPARAMSW  rdpw;
    ANSI_STRING     ansiString;
    UNICODE_STRING  unicodeString;
    NTSTATUS        ntstatus = STATUS_SUCCESS;
    DWORD           dwErr = NO_ERROR;

    if (    !lprdp
        ||  !lphrasconn)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Verify caller's buffer version.
    //
    if (    !lprdp
        || (    lprdp->dwSize != sizeof(RASDIALPARAMSA)
            &&  lprdp->dwSize != sizeof(RASDIALPARAMSA_V351)
            &&  lprdp->dwSize != sizeof(RASDIALPARAMSA_V400)
            &&  lprdp->dwSize != sizeof(RASDIALPARAMSA_WINNT35J)))
    {
        return ERROR_INVALID_SIZE;
    }


    //Securey password, for .Net 534499 LH 754400
    SafeEncodePasswordBuf(lprdp->szPassword);
    //
    // Make Unicode buffer version of caller's RASDIALPARAMS.
    //
    rdpw.dwSize = sizeof(RASDIALPARAMSW);

    if (lprdp->dwSize == sizeof(RASDIALPARAMSA))
    {
        strncpyAtoWAnsi(rdpw.szEntryName,
                    lprdp->szEntryName,
                    sizeof(rdpw.szEntryName) / sizeof(WCHAR));

        strncpyAtoWAnsi(rdpw.szPhoneNumber,
                    lprdp->szPhoneNumber,
                    sizeof(rdpw.szPhoneNumber) / sizeof(WCHAR));

        strncpyAtoWAnsi(rdpw.szCallbackNumber,
                    lprdp->szCallbackNumber,
                    sizeof(rdpw.szCallbackNumber) / sizeof(WCHAR));

        strncpyAtoWAnsi(rdpw.szUserName,
                    lprdp->szUserName,
                    sizeof(rdpw.szUserName) / sizeof(WCHAR));

        SafeDecodePasswordBuf(lprdp->szPassword);

        strncpyAtoWAnsi(rdpw.szPassword,
                    lprdp->szPassword,
                    sizeof(rdpw.szPassword) / sizeof(WCHAR));

        SafeEncodePasswordBuf(lprdp->szPassword);
        SafeEncodePasswordBuf(rdpw.szPassword);

        strncpyAtoWAnsi(rdpw.szDomain,
                    lprdp->szDomain,
                    sizeof(rdpw.szDomain) / sizeof(WCHAR));

        rdpw.dwSubEntry     = lprdp->dwSubEntry;
        rdpw.dwCallbackId   = lprdp->dwCallbackId;

    }

    else if (lprdp->dwSize == sizeof(RASDIALPARAMSA_V400))
    {
        RASDIALPARAMSA_V400* prdp = (RASDIALPARAMSA_V400* )lprdp;

        strncpyAtoWAnsi(rdpw.szEntryName,
                    prdp->szEntryName,
                    sizeof(rdpw.szEntryName) / sizeof(WCHAR));

        strncpyAtoWAnsi(rdpw.szPhoneNumber,
                    prdp->szPhoneNumber,
                    sizeof(rdpw.szPhoneNumber) / sizeof(WCHAR));

        strncpyAtoWAnsi(rdpw.szCallbackNumber,
                    prdp->szCallbackNumber,
                    sizeof(rdpw.szCallbackNumber) / sizeof(WCHAR));

        strncpyAtoWAnsi(rdpw.szUserName,
                    prdp->szUserName,
                    sizeof(rdpw.szUserName) / sizeof(WCHAR));

        SafeDecodePasswordBuf(prdp->szPassword);

        strncpyAtoWAnsi(rdpw.szPassword,
                    prdp->szPassword,
                    sizeof(rdpw.szPassword) / sizeof(WCHAR));

        SafeEncodePasswordBuf(prdp->szPassword);
        SafeEncodePasswordBuf(rdpw.szPassword);

        strncpyAtoWAnsi(rdpw.szDomain,
                    prdp->szDomain,
                    sizeof(rdpw.szDomain) / sizeof(WCHAR));

        rdpw.dwSubEntry     = 0;
        rdpw.dwCallbackId   = 0;

    }

    else if (lprdp->dwSize == sizeof (RASDIALPARAMSA_WINNT35J))
    {
        RASDIALPARAMSA_WINNT35J* prdp =
                (RASDIALPARAMSA_WINNT35J *)lprdp;

        strncpyAtoWAnsi(rdpw.szEntryName,
                     prdp->szEntryName,
                     RAS_MaxEntryName_V351 + 1);

        strncpyAtoWAnsi(rdpw.szPhoneNumber,
                    prdp->szPhoneNumber,
                    sizeof(rdpw.szPhoneNumber) / sizeof(WCHAR));

        strncpyAtoWAnsi(rdpw.szCallbackNumber,
                     prdp->szCallbackNumber,
                     RAS_MaxCallbackNumber_V351 + 1);

        strncpyAtoWAnsi(rdpw.szUserName,
                    prdp->szUserName,
                    sizeof(rdpw.szUserName) / sizeof(WCHAR));

        SafeDecodePasswordBuf(prdp->szPassword);

        strncpyAtoWAnsi(rdpw.szPassword,
                    prdp->szPassword,
                    sizeof(rdpw.szPassword) / sizeof(WCHAR));

        SafeEncodePasswordBuf(prdp->szPassword);
        SafeEncodePasswordBuf(rdpw.szPassword);

        strncpyAtoWAnsi(rdpw.szDomain,
                    prdp->szDomain,
                    sizeof(rdpw.szDomain) / sizeof(WCHAR));

        rdpw.dwSubEntry     = 0;
        rdpw.dwCallbackId   = 0;

    }

    else
    {
        RASDIALPARAMSA_V351* prdp = (RASDIALPARAMSA_V351* )lprdp;

        strncpyAtoWAnsi(rdpw.szEntryName,
                     prdp->szEntryName,
                     RAS_MaxEntryName_V351 + 1);

        strncpyAtoWAnsi(rdpw.szPhoneNumber,
                    prdp->szPhoneNumber,
                    sizeof(rdpw.szPhoneNumber) / sizeof(WCHAR));

        strncpyAtoWAnsi(rdpw.szCallbackNumber,
                     prdp->szCallbackNumber,
                     RAS_MaxCallbackNumber_V351 + 1);

        strncpyAtoWAnsi(rdpw.szUserName,
                    prdp->szUserName,
                    sizeof(rdpw.szUserName) / sizeof(WCHAR));

        SafeDecodePasswordBuf(prdp->szPassword);

        strncpyAtoWAnsi(rdpw.szPassword,
                    prdp->szPassword,
                    sizeof(rdpw.szPassword) / sizeof(WCHAR));

        SafeEncodePasswordBuf(prdp->szPassword);
        SafeEncodePasswordBuf(rdpw.szPassword);

        strncpyAtoWAnsi(rdpw.szDomain,
                    prdp->szDomain,
                    sizeof(rdpw.szDomain) / sizeof(WCHAR));

        rdpw.dwSubEntry     = 0;
        rdpw.dwCallbackId   = 0;
    }

    //
    // Make Unicode version of caller's string argument.
    //
    if (lpszPhonebookPath)
    {
        RtlInitAnsiString(&ansiString, lpszPhonebookPath);

        RtlInitUnicodeString(&unicodeString, NULL);

        ntstatus = RtlAnsiStringToUnicodeString(&unicodeString,
                                                &ansiString,
                                                TRUE );
    }

    if (!NT_SUCCESS(ntstatus))
    {
        dwErr =  RtlNtStatusToDosError(ntstatus);
        goto done;
    }

    //
    // Call the Unicode version to do all the work.
    //

    SafeDecodePasswordBuf(rdpw.szPassword);
    
    dwErr = RasDialW(lpextensions,
                     (lpszPhonebookPath)
                     ? unicodeString.Buffer
                     : NULL,
                     (RASDIALPARAMSW* )&rdpw,
                     dwNotifierType,
                     notifier,
                     lphrasconn);

    SafeWipePasswordBuf(rdpw.szPassword);

    if (lpszPhonebookPath)
    {
        RtlFreeUnicodeString( &unicodeString );
    }

done:

    SafeDecodePasswordBuf(lprdp->szPassword);

    return dwErr;
}


DWORD APIENTRY
RasDialW(
    IN  LPRASDIALEXTENSIONS lpextensions,
    IN  LPCWSTR             lpszPhonebookPath,
    IN  LPRASDIALPARAMSW    lpparams,
    IN  DWORD               dwNotifierType,
    IN  LPVOID              notifier,
    OUT LPHRASCONN          lphrasconn )

/*++

Routine Description:

        Establish a connection with a RAS server.  The call is
        asynchronous, i.e. it returns before the connection is
        actually established.  The status may be monitored with
        RasConnectStatus and/or by specifying a callback/window
        to receive notification events/messages.

Arguments:

        lpextensions - is caller's extensions structure, used to
                       select advanced options and enable extended
                       features, or NULL indicating default values
                       should be used for all extensions.

        lpszPhonebookPath - is the full path to the phonebook file
                            or NULL indicating that the default
                            phonebook on the local machine should
                            be used.

        lpparams - is caller's buffer containing a description of the
                   connection to be established.

        dwNotifierType - defines the form of 'notifier'.

                0xFFFFFFFF:  'notifier' is a HWND to receive
                              notification messages
                0            'notifier' is a RASDIALFUNC callback
                1            'notifier' is a RASDIALFUNC1 callback
                2            'notifier' is a RASDIALFUNC2 callback

        notifier - may be NULL for no notification (synchronous
                   operation), in which case 'dwNotifierType' is
                   ignored.

        *lphrasconn -  is set to the RAS connection handle associated
                       with the new connection on successful return.

Return Value:

        Returns 0 if successful, otherwise a non-0 error code.

--*/
{
    DWORD           dwErr;
    DWORD           dwfOptions          = 0;
    ULONG_PTR       reserved            = 0;
    HWND            hwndParent          = NULL;
    RASDIALPARAMSW  params;
    BOOL            fEnableMultilink    = FALSE;
    ULONG_PTR        reserved1           = 0;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasDialW...");

    if (    !lpparams
        ||  !lphrasconn)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    (   lpparams->dwSize != sizeof( RASDIALPARAMSW )
            &&  lpparams->dwSize != sizeof( RASDIALPARAMSW_V351 )
            &&  lpparams->dwSize != sizeof( RASDIALPARAMSW_V400 ))
        ||  (   lpextensions
            &&  lpextensions->dwSize != sizeof(RASDIALEXTENSIONS)
            &&  lpextensions->dwSize != sizeof(RASDIALEXTENSIONS_401)))
    {
        return ERROR_INVALID_SIZE;
    }

    if (    NULL != notifier
        &&  0 != dwNotifierType
        &&  1 != dwNotifierType
        &&  2 != dwNotifierType
        &&  0xFFFFFFFF != dwNotifierType)
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError != 0)
    {
        return DwRasInitializeError;
    }


    do
    {

        //gangz
        //For secure password bug .Net 754400
        SafeEncodePasswordBuf(lpparams->szPassword);
        if (lpextensions)
        {
            hwndParent  = lpextensions->hwndParent;
            dwfOptions  = lpextensions->dwfOptions;
            reserved    = lpextensions->reserved;

            if (lpextensions->dwSize == sizeof (RASDIALEXTENSIONS))
            {
                reserved1 = lpextensions->reserved1;
            }
            else
            {
                //
                // This should tell us that that this
                // is most likely an nt4 client.
                //
                reserved1 = 0xFFFFFFFF;
            }
        }

        //
        // Make a copy of caller's parameters so we can fill in
        // any "*" callback number or domain from the phonebook
        // without changing caller's "input" buffer.  Eliminate
        // the V401 vs V400 vs V351 issue while we're at it.
        //
        if (lpparams->dwSize == sizeof(RASDIALPARAMSW_V351))
        {
            //
            // Convert the V351 structure to a V401 version.
            //
            RASDIALPARAMSW_V351* prdp = (RASDIALPARAMSW_V351* )lpparams;

            params.dwSize = sizeof(RASDIALPARAMSW);

            lstrcpyn(params.szEntryName,
                     prdp->szEntryName,
                     sizeof(params.szEntryName) / sizeof(WCHAR));

            lstrcpyn(params.szPhoneNumber,
                     prdp->szPhoneNumber,
                     sizeof(params.szPhoneNumber) / sizeof(WCHAR));

            lstrcpyn(params.szCallbackNumber,
                     prdp->szCallbackNumber,
                     sizeof(params.szCallbackNumber) / sizeof(WCHAR));

            lstrcpyn(params.szUserName,
                     prdp->szUserName,
                     sizeof(params.szUserName) / sizeof(WCHAR));

            SafeDecodePasswordBuf(prdp->szPassword);
            lstrcpyn(params.szPassword,
                     prdp->szPassword,
                     sizeof(params.szPassword) / sizeof(WCHAR));
            SafeEncodePasswordBuf(prdp->szPassword);
            SafeEncodePasswordBuf(params.szPassword);


            lstrcpyn(params.szDomain,
                     prdp->szDomain,
                     sizeof(params.szDomain) / sizeof(WCHAR));

            params.dwSubEntry = 0;
        }
        else if (lpparams->dwSize == sizeof(RASDIALPARAMSW_V400))
        {
            //
            // Convert the V400 structure to a V401 version.
            //
            RASDIALPARAMSW_V400* prdp = (RASDIALPARAMSW_V400* )lpparams;

            params.dwSize = sizeof(RASDIALPARAMSW);

            lstrcpyn(params.szEntryName,
                     prdp->szEntryName,
                     sizeof(params.szEntryName) / sizeof(WCHAR));

            lstrcpyn(params.szPhoneNumber,
                     prdp->szPhoneNumber,
                     sizeof(params.szPhoneNumber) / sizeof(WCHAR));

            lstrcpyn(params.szCallbackNumber,
                     prdp->szCallbackNumber,
                     sizeof(params.szCallbackNumber) / sizeof(WCHAR));

            lstrcpyn(params.szUserName,
                     prdp->szUserName,
                     sizeof(params.szUserName) / sizeof(WCHAR));

            SafeDecodePasswordBuf(prdp->szPassword);
            lstrcpyn(params.szPassword,
                     prdp->szPassword,
                     sizeof(params.szPassword) / sizeof(WCHAR));
            SafeEncodePasswordBuf(prdp->szPassword);
            SafeEncodePasswordBuf(params.szPassword);

            lstrcpyn(params.szDomain,
                     prdp->szDomain,
                     sizeof(params.szDomain) / sizeof(WCHAR));

            params.dwSubEntry = 0;
        }
        else
        {
            SafeDecodePasswordBuf(lpparams->szPassword);
            memcpy( &params,
                    lpparams,
                    sizeof(params) );

            SafeEncodePasswordBuf(lpparams->szPassword);
            SafeEncodePasswordBuf(params.szPassword);

            fEnableMultilink = TRUE;
        }

        //
        // no need to pass dwfOptions, reserved
        // reserved1 parameters since lpextensions is
        // being passed into this call anyway - bug filed
        // already on this.
        //

        //decode password before passing it to _RasDial
        SafeDecodePasswordBuf(params.szPassword);
        
        dwErr = _RasDial(lpszPhonebookPath,
                         dwfOptions,
                         fEnableMultilink,
                         reserved,
                         &params,
                         hwndParent,
                         dwNotifierType,
                         notifier,
                         reserved1,
                         lpextensions,
                         lphrasconn);

        SafeWipePasswordBuf( params.szPassword );

        RASAPI32_TRACE1("RasDialA done(%d)", dwErr);

    }
    while(FALSE);

    //Decode before return
    SafeDecodePasswordBuf(lpparams->szPassword);

    return dwErr;
}

// To call this function correctly(as far as password fields in it)
// The pPrimary is always generated by calling CreateConnectionBlock(NULL)
// Then the szOldPassword and prasconncb->rasdialparams.szPassword can be 
// properly encoded
//
RASCONNCB *
CreateConnectionBlock(
    IN RASCONNCB *pPrimary
    )
{
    DTLNODE* pdtlnode = DtlCreateSizedNode(sizeof(RASCONNCB), 0);
    RASCONNCB *prasconncb;

    if (!pdtlnode)
    {
        return NULL;
    }

    EnterCriticalSection(&RasconncbListLock);

    DtlAddNodeFirst(PdtllistRasconncb, pdtlnode);

    LeaveCriticalSection(&RasconncbListLock);

    prasconncb                  = (RASCONNCB *)
                                  DtlGetData( pdtlnode );

    prasconncb->asyncmachine.freefuncarg = pdtlnode;
    prasconncb->psyncResult     = NULL;
    prasconncb->fTerminated     = FALSE;
    prasconncb->dwDeviceLineCounter = 0;

    prasconncb->fDialSingleLink = FALSE;

    prasconncb->fRasdialRestart = FALSE;

    prasconncb->fTryNextLink = TRUE;

    if (pPrimary != NULL)
    {
        //
        // Copy most of the values from the primary.
        //
        prasconncb->hrasconn                = pPrimary->hrasconn;
        prasconncb->rasconnstate            = 0;
        prasconncb->rasconnstateNext        = 0;
        prasconncb->dwError                 = 0;
        prasconncb->dwExtendedError         = 0;
        prasconncb->dwSavedError            = 0;
        prasconncb->pEntry                  = pPrimary->pEntry;
        prasconncb->hport                   = INVALID_HPORT;
        prasconncb->hportBundled            = INVALID_HPORT;

        lstrcpyn(prasconncb->szUserKey,
                 pPrimary->szUserKey,
                 sizeof(prasconncb->szUserKey) / sizeof(WCHAR));

        prasconncb->reserved                = pPrimary->reserved;
        prasconncb->dwNotifierType          = pPrimary->dwNotifierType;
        prasconncb->notifier                = pPrimary->notifier;
        prasconncb->hwndParent              = pPrimary->hwndParent;
        prasconncb->unMsg                   = pPrimary->unMsg;
        prasconncb->pEntry                  = pPrimary->pEntry;

        memcpy( &prasconncb->pbfile,
                &pPrimary->pbfile,
                sizeof (prasconncb->pbfile));

        memcpy( &prasconncb->rasdialparams,
                &pPrimary->rasdialparams,
                sizeof (RASDIALPARAMS));

        //copy password area separately
        //Clear out the newly allocated buffer first in case it wrongly happens to contain the crypt signature.
        //
        RtlSecureZeroMemory(prasconncb->rasdialparams.szPassword, sizeof(prasconncb->rasdialparams.szPassword) );

        //(1) When CryptProtectData() used
        //SafeCopyPasswordBuf will always encode the destination buffer
        //(2) when CryptProtectMemory() used, it just directly copy the data so in order to be
        // logically correctly, the pPrimary should be gernerated by CreateConnectionBlock as well
        //
        SafeCopyPasswordBuf(prasconncb->rasdialparams.szPassword,pPrimary->rasdialparams.szPassword);
            
        prasconncb->fAllowPause             = pPrimary->fAllowPause;
        prasconncb->fPauseOnScript          = pPrimary->fPauseOnScript;
        prasconncb->fDefaultEntry           = pPrimary->fDefaultEntry;
        prasconncb->fDisableModemSpeaker    = pPrimary->fDisableModemSpeaker;
        prasconncb->fDisableSwCompression   = pPrimary->fDisableSwCompression;
        prasconncb->dwUserPrefMode          = pPrimary->dwUserPrefMode;
        prasconncb->fUsePrefixSuffix        = pPrimary->fUsePrefixSuffix;
        prasconncb->fNoClearTextPw          = pPrimary->fNoClearTextPw;
        prasconncb->fRequireEncryption      = pPrimary->fRequireEncryption;
        prasconncb->fLcpExtensions          = pPrimary->fLcpExtensions;
        prasconncb->dwfPppProtocols         = pPrimary->dwfPppProtocols;

        memcpy( prasconncb->szzPppParameters,
                pPrimary->szzPppParameters,
                sizeof (prasconncb->szzPppParameters));

        //copy password area separately
        //
        //Clear out the newly allocated buffer in case it  happens to contain the crypt signature.
        //
        RtlSecureZeroMemory(prasconncb->szOldPassword, sizeof(prasconncb->szOldPassword) );
        
        //SafeCopyPasswordBuf will always encode the destination buffer
        //
        SafeCopyPasswordBuf(prasconncb->szOldPassword, pPrimary->szOldPassword);
            

        prasconncb->fRetryAuthentication        = pPrimary->fRetryAuthentication;
        prasconncb->fMaster                     = FALSE;
        prasconncb->dwfSuspended                = pPrimary->dwfSuspended;
        prasconncb->fStopped                    = FALSE;
        prasconncb->fCleanedUp                  = FALSE;
        prasconncb->fDeleted                    = FALSE;
        prasconncb->fOldPasswordSet             = pPrimary->fOldPasswordSet;
        prasconncb->fUpdateCachedCredentials    = pPrimary->fUpdateCachedCredentials;
#if AMB
        prasconncb->dwAuthentication            = pPrimary->dwAuthentication;
#endif
        prasconncb->fPppMode                    = pPrimary->fPppMode;
        prasconncb->fUseCallbackDelay           = pPrimary->fUseCallbackDelay;
        prasconncb->wCallbackDelay              = pPrimary->wCallbackDelay;
        prasconncb->fIsdn                       = pPrimary->fIsdn;
        prasconncb->fModem                      = pPrimary->fModem;
        prasconncb->asyncmachine.oneventfunc    = pPrimary->asyncmachine.oneventfunc;
        prasconncb->asyncmachine.cleanupfunc    = pPrimary->asyncmachine.cleanupfunc;
        prasconncb->asyncmachine.freefunc       = pPrimary->asyncmachine.freefunc;
        prasconncb->asyncmachine.pParam         = (VOID* )prasconncb;
        prasconncb->dwIdleDisconnectSeconds     = pPrimary->dwIdleDisconnectSeconds;
        prasconncb->fPppEapMode                 = pPrimary->fPppEapMode;

        {
            DWORD dwVpnProts;

            for(dwVpnProts = 0;
                dwVpnProts < NUMVPNPROTS;
                dwVpnProts ++)
            {
                prasconncb->ardtVpnProts[dwVpnProts] =
                    pPrimary->ardtVpnProts[dwVpnProts];
            }
        }

        prasconncb->dwCurrentVpnProt = pPrimary->dwCurrentVpnProt;

        //
        // Copy eapinfo if present
        //
        if(0 != pPrimary->RasEapInfo.dwSizeofEapInfo)
        {
            prasconncb->RasEapInfo.pbEapInfo =
                LocalAlloc(LPTR,
                           pPrimary->RasEapInfo.dwSizeofEapInfo);

            if(NULL == prasconncb->RasEapInfo.pbEapInfo)
            {
                DeleteRasconncbNode(prasconncb);
                return NULL;
            }

            prasconncb->RasEapInfo.dwSizeofEapInfo =
                pPrimary->RasEapInfo.dwSizeofEapInfo;

            memcpy(prasconncb->RasEapInfo.pbEapInfo,
                   pPrimary->RasEapInfo.pbEapInfo,
                   prasconncb->RasEapInfo.dwSizeofEapInfo);
        }
        else
        {
            //
            // .Net bug# 508327 memory leak in file rasdial.c function
            // CreateConnectionBlock
            //
            prasconncb->RasEapInfo.pbEapInfo = NULL;
            prasconncb->RasEapInfo.dwSizeofEapInfo = 0;
        }

        //
        // Initialize the state machine for
        // this connection block.
        //
        if (StartAsyncMachine(&prasconncb->asyncmachine,
                            prasconncb->hrasconn))
        {
            DeleteRasconncbNode( prasconncb );
            return NULL;
        }

        //
        // Link together all connection blocks
        // for the same entry.
        //
        prasconncb->fMultilink  = pPrimary->fMultilink;
        prasconncb->fBundled    = FALSE;

        InsertTailList( &pPrimary->ListEntry,
                        &prasconncb->ListEntry);
    }
    else
    {
        prasconncb->pbfile.hrasfile = -1;
        
        InitializeListHead(&prasconncb->ListEntry);

        InitializeListHead(&prasconncb->asyncmachine.ListEntry);

        prasconncb->asyncmachine.hport = INVALID_HPORT;
        
        //gangz
        //Even encode the password when create it. other places will assume it is encoded already
        //
        RtlSecureZeroMemory(prasconncb->rasdialparams.szPassword,
                sizeof(prasconncb->rasdialparams.szPassword) );
        RtlSecureZeroMemory(prasconncb->szOldPassword,
                sizeof(prasconncb->szOldPassword));
                
        SafeEncodePasswordBuf(prasconncb->rasdialparams.szPassword);
        SafeEncodePasswordBuf(prasconncb->szOldPassword);
    
    }

    return prasconncb;
}


VOID
AssignVpnProtsOrder(RASCONNCB *prasconncb)
{
    DWORD dwVpnStrategy = prasconncb->pEntry->dwVpnStrategy;
    DWORD dwVpnProt;

    RASDEVICETYPE ardtDefaultOrder[NUMVPNPROTS] =
                        {
                            RDT_Tunnel_L2tp,
                            RDT_Tunnel_Pptp,
                        };

    RASDEVICETYPE *prdtVpnProts = prasconncb->ardtVpnProts;

    //
    // Initialize the vpn prot order to default.
    //
    for(dwVpnProt = 0;
        dwVpnProt < NUMVPNPROTS;
        dwVpnProt++)
    {
        prdtVpnProts[dwVpnProt]
            = ardtDefaultOrder[dwVpnProt];
    }

    switch (dwVpnStrategy & 0x0000FFFF)
    {
        case VS_Default:
        {
            break;
        }

        case VS_PptpOnly:
        {
            prdtVpnProts[0] = RDT_Tunnel_Pptp;

            for(dwVpnProt = 1;
                dwVpnProt < NUMVPNPROTS;
                dwVpnProt ++)
            {
                prdtVpnProts[dwVpnProt] = -1;
            }

            break;
        }

        case VS_L2tpOnly:
        {
            prdtVpnProts[0] = RDT_Tunnel_L2tp;

            for(dwVpnProt = 1;
                dwVpnProt < NUMVPNPROTS;
                dwVpnProt ++)
            {
                prdtVpnProts[dwVpnProt] = -1;
            }

            break;
        }

        case VS_PptpFirst:
        {
            DWORD dwSaveProt = prdtVpnProts[0];

            for(dwVpnProt = 0;
                dwVpnProt < NUMVPNPROTS;
                dwVpnProt ++)
            {
                if(RDT_Tunnel_Pptp == prdtVpnProts[dwVpnProt])
                {
                    break;
                }
            }

            ASSERT(dwVpnProt != NUMVPNPROTS);

            prdtVpnProts[0] = RDT_Tunnel_Pptp;
            prdtVpnProts[dwVpnProt] = dwSaveProt;

            break;
        }

        case VS_L2tpFirst:
        {
            DWORD dwSaveProt = prdtVpnProts[0];

            for(dwVpnProt = 0;
                dwVpnProt < NUMVPNPROTS;
                dwVpnProt ++)
            {
                if(RDT_Tunnel_L2tp == prdtVpnProts[dwVpnProt])
                {
                    break;
                }
            }

            ASSERT(dwVpnProt != NUMVPNPROTS);

            prdtVpnProts[0] = RDT_Tunnel_L2tp;
            prdtVpnProts[dwVpnProt] = dwSaveProt;

            break;

        }

        default:
        {
#if DBG
            ASSERT(FALSE);
#endif
            break;
        }
    }
}

VOID SetUpdateCachedCredentialsFlag(RASCONNCB *prasconncb,
                              RASDIALPARAMS *prasdialparams)
{
    DWORD dwErr = ERROR_SUCCESS;
    
    //
    // If the user is logged into the same domain
    // as he is dialing into, note this fact so 
    // that we can update cached credentials.
    //
    WKSTA_USER_INFO_1* pwkui1 = NULL;

    dwErr = NetWkstaUserGetInfo(NULL,
                                1, (LPBYTE *) &pwkui1);

    if(     (ERROR_SUCCESS == dwErr)
        &&  (prasconncb->dwUserPrefMode != UPM_Logon))
    {
        if(     (   (TEXT('\0') != prasdialparams->szDomain[0])
                &&  (0 == lstrcmpi(prasdialparams->szDomain,
                        pwkui1->wkui1_logon_domain)))
            ||  (   (TEXT('\0')== prasdialparams->szDomain[0])
                &&  prasconncb->pEntry->fAutoLogon))
        {                                            
            if(         ((TEXT('\0') != 
                            prasdialparams->szUserName[0])
                    &&  (0 == 
                            lstrcmpi(prasdialparams->szUserName,
                                    pwkui1->wkui1_username))
                ||      ((TEXT('\0') == 
                                prasdialparams->szUserName[0])
                    &&  prasconncb->pEntry->fAutoLogon)))
            {
                prasconncb->fUpdateCachedCredentials = TRUE;
            }
        }
        
        NetApiBufferFree(pwkui1);
    }
}
                                

DWORD
_RasDial(
    IN    LPCTSTR             lpszPhonebookPath,
    IN    DWORD               dwfOptions,
    IN    BOOL                fEnableMultilink,
    IN    ULONG_PTR           reserved,
    IN    RASDIALPARAMS*      prasdialparams,
    IN    HWND                hwndParent,
    IN    DWORD               dwNotifierType,
    IN    LPVOID              notifier,
    IN    ULONG_PTR           reserved1,
    IN    RASDIALEXTENSIONS   *lpExtensions,
    IN OUT LPHRASCONN         lphrasconn )

/*++

 Routine Description:

        Core RasDial routine called with dial params
        converted to V40 and structure sizes are
        already verified.

        Otherwise, like RasDial.

Arguments:

Return Value:

--*/
{
    DWORD        dwErr;
    BOOL         fAllowPause = (dwfOptions & RDEOPT_PausedStates)
                             ? TRUE : FALSE;
    RASCONNCB*   prasconncb;
    RASCONNSTATE rasconnstate;
    HRASCONN     hrasconn = *lphrasconn;
    BOOL         fNewEntry;
    HANDLE       hDone;
    PDWORD       pdwSubEntryInfo = NULL;
    DWORD        dwSubEntries;
    DWORD        dwEntryAlreadyConnected = 0;
    
    RASAPI32_TRACE1("_RasDial(%S)", (*lphrasconn) 
                            ? TEXT("resume") 
                            : TEXT("start"));

    if (DwRasInitializeError != 0)
    {
        return DwRasInitializeError;
    }

    //gangz for the security push for password
    //Validate  prasdialparams before encode it,
    // So any other function returns happen before this encode
    // should return directly and not goto done:
    //
    if( NULL == prasdialparams ||
         sizeof(RASDIALPARAMSW) != prasdialparams->dwSize )
    {
        return ERROR_INVALID_PARAMETER;
    }

    SafeEncodePasswordBuf(prasdialparams->szPassword );
    
    fNewEntry = FALSE;

    if (    hrasconn
        && (prasconncb = ValidatePausedHrasconn(hrasconn)))
    {
        //
        // Restarting an existing connection after a pause state...
        // Set the appropriate resume state for the paused state.
        //
        switch (prasconncb->rasconnstate)
        {
            case RASCS_Interactive:
                rasconnstate = RASCS_DeviceConnected;
                break;

            case RASCS_RetryAuthentication:
            {
                SetUpdateCachedCredentialsFlag(prasconncb, prasdialparams);
                //
                // Whistler bug: 345824 Include Windows logon domain not
                // enabled on a VPN connection
                //
                if ( ( prasdialparams ) && ( prasconncb->pEntry ) &&
                     ( 0 < lstrlen ( prasdialparams->szDomain ) ) &&
                     ( !prasconncb->pEntry->fPreviewDomain ) )
                {
                    prasconncb->pEntry->fPreviewDomain = TRUE;
                    prasconncb->pEntry->fDirty = TRUE;
                }

                /*
                //
                // If user is resuming from a retry where where
                // he tried a new password on an "authenticate
                // with current username/pw" entry, note this
                // so the cached logon credentials can be
                // updated as soon as server tells us the
                // re-authentication succeeded.
                //
                if (    prasconncb->rasdialparams.szUserName[0]
                        == TEXT('\0')
                    &&  0 == lstrcmp(
                                 prasconncb->rasdialparams.szDomain,
                                 prasdialparams->szDomain))
                {
                    //
                    // Must look up the logged on user's name since
                    // "" username cannot be used by caller where
                    // auto-logon password is overridden
                    // (what a pain).
                    //
                    DWORD dwErr;
                    WKSTA_USER_INFO_1* pwkui1 = NULL;

                    dwErr = NetWkstaUserGetInfo(NULL,
                                                1,
                                                (LPBYTE* )&pwkui1);

                    if (dwErr == 0)
                    {
                        TCHAR szLoggedOnUser[ UNLEN + 1 ];

                        strncpyWtoT(    szLoggedOnUser,
                                        pwkui1->wkui1_username,
                                        UNLEN + 1 );

                        if (lstrcmp(
                                szLoggedOnUser,
                                prasdialparams->szUserName ) == 0)
                        {
                            prasconncb->fUpdateCachedCredentials = TRUE;
                        }
                        
                        NetApiBufferFree( pwkui1 );
                }
                    else
                    {
                        RASAPI32_TRACE1("NetWkstaUserGetInfo done(%d)", dwErr);
                    }

                }

                */

                rasconnstate = RASCS_AuthRetry;
                break;
            }

            case RASCS_InvokeEapUI:
            {

#if DBG
                ASSERT(     0xFFFFFFFF != reserved1
                        &&  0 != reserved1 );
#endif

                //
                // Save the context that will be passed to ppp
                // in RASCS_AuthRetry state
                //
                prasconncb->reserved1 = reserved1;

                rasconnstate = RASCS_AuthRetry;
                break;

            }

            case RASCS_CallbackSetByCaller:
                rasconnstate = RASCS_AuthCallback;
                break;

            case RASCS_PasswordExpired:
            {
                //
                // If the user is logged into the same domain
                // as he is dialing into, note this fact so 
                // that we can update cached credentials.
                //
                WKSTA_USER_INFO_1* pwkui1 = NULL;

                //
                // If the user didn't set the old password with the
                // RasSetOldPassword call, then give old behavior,
                // i.e. implicitly use the password previously
                // entered.
                //
                if (!prasconncb->fOldPasswordSet)
                {

                    SafeCopyPasswordBuf(prasconncb->szOldPassword, prasconncb->rasdialparams.szPassword);
                   
                }


               //gangz
               // actually, there is no need to decode the password, SetUpdateCachedCredentialsFlag
               // doesn't need it. just in case of future change in that funciton
               ///
               SafeDecodePasswordBuf(prasdialparams->szPassword );
               SetUpdateCachedCredentialsFlag(prasconncb, prasdialparams);
               SafeEncodePasswordBuf(prasdialparams->szPassword );

                /*
                //
                // If user is resuming after changing the password
                // of the currently logged on user, note this so
                // the cached logon credentials can be updated
                // as soon as server tells us the password
                // change succeeded.
                //
                if (prasconncb->rasdialparams.szUserName[0]
                                    == '\0')
                {
                    prasconncb->fUpdateCachedCredentials = TRUE;
                }
                */

                rasconnstate = RASCS_AuthChangePassword;
                break;
            }

            default:

                //
                // The entry is not in the paused state.  Assume
                // it's an NT 3.1 caller would didn't figure out
                // to set the HRASCONN to NULL before starting
                // up.  (The NT 3.1 docs did not make it
                // absolutely clear that the inital handle
                // should be NULL)
                //
                fNewEntry = TRUE;
        }

        RASAPI32_TRACE1( "fUpdateCachedCredentials=%d",
                prasconncb->fUpdateCachedCredentials);
    }
    else if (   (NULL != hrasconn)
            &&  !g_FRunningInAppCompatMode)
    {
        dwErr =  ERROR_NO_CONNECTION;
        goto done;
    }
    else
    {
        fNewEntry = TRUE;
    }


    if (fNewEntry)
    {
        DTLNODE         *pdtlnode;
        DWORD           dwMask;
        RAS_DIALPARAMS  dialparams;
        LONG            dwIdleDisconnectSeconds;

        //
        // If this is being called from the custom dialer
        // and there is no entry name return an error.
        //
        if(     (dwfOptions & RDEOPT_CustomDial)
            &&  TEXT('\0') == prasdialparams->szEntryName[0])
        {
            dwErr= ERROR_CANNOT_DO_CUSTOMDIAL;
            goto done;
        }

        //
        // Starting a new connection...
        // Create an empty control block and link it into the
        // global list of control blocks.  The HRASCONN is
        // really the address of a control block.
        //
        prasconncb = CreateConnectionBlock(NULL);

        if (prasconncb == NULL)
        {
            dwErr =  ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }

        //
        // Open the phonebook and find the entry,
        // if specified.
        //
        if (prasdialparams->szEntryName[0] != TEXT('\0'))
        {
            //
            // We can't specify the entry name here because
            // we might have to write the phonebook file at
            // the end, and the phonebook library doesn't
            // support this.
            //
            dwErr = GetPbkAndEntryName(
                            lpszPhonebookPath,
                            prasdialparams->szEntryName,
                            RPBF_NoCreate 
                            |((dwfOptions & RDEOPT_Router) 
                            ? RPBF_Router : 0 ),
                            &prasconncb->pbfile,
                            &pdtlnode);

            if(SUCCESS != dwErr)
            {
                DeleteRasconncbNode(prasconncb);
                goto done;
            }
        }
        else
        {

            pdtlnode = CreateEntryNode(TRUE);

            if (pdtlnode == NULL)
            {
                RASAPI32_TRACE("CreateEntryNode returned NULL");

                DeleteRasconncbNode(prasconncb);

                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto done;
            }

        }

        prasconncb->pEntry = (PBENTRY *)DtlGetData(pdtlnode);
        ASSERT(prasconncb->pEntry);

        //
        // if a custom dialer is specified and this is not
        // being called from the custom dialer, it means
        // that it is being called from rasapi - RasDial
        // directly. Do the custom dial with no ui in that
        // case
        //
        if(     (NULL != prasconncb->pEntry->pszCustomDialerName)
            &&  (TEXT('\0') != prasconncb->pEntry->pszCustomDialerName[0])
            &&  (0 == (RDEOPT_CustomDial & dwfOptions)))
        {

            CHAR *pszSysPbk = NULL;

            //
            // Dup the phonebook file path if its not specified
            //
            if(NULL == lpszPhonebookPath)
            {
                pszSysPbk = strdupTtoA(prasconncb->pbfile.pszPath);
                if(NULL == pszSysPbk)
                {
                    DeleteRasconncbNode(prasconncb);
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    goto done;
                }
            }

            //
            // Delete the rasconncb we created for this connection
            //
            DeleteRasconncbNode(prasconncb);

            //Decode the password before calling custom dialer
            SafeDecodePasswordBuf(prasdialparams->szPassword );

            dwErr = DwCustomDial(lpExtensions,
                                 lpszPhonebookPath,
                                 pszSysPbk,
                                 prasdialparams,
                                 dwNotifierType,
                                 notifier,
                                 lphrasconn);

            SafeEncodePasswordBuf(prasdialparams->szPassword );

            if(pszSysPbk)
            {
                Free(pszSysPbk);
            }

        goto done;
        }

        prasconncb->fBundled = FALSE;        

        prasconncb->fDialSingleLink = FALSE;
        
        //
        // Look up the subentry.
        //
        if ( prasconncb->pEntry->dwDialMode == RASEDM_DialAsNeeded )
        {
            dwSubEntries = 
                DtlGetNodes(prasconncb->pEntry->pdtllistLinks);

            if (    0 == prasdialparams->dwSubEntry
                ||  prasdialparams->dwSubEntry > dwSubEntries )
            {
                prasdialparams->dwSubEntry = 1;
            }
            else
            {
                prasconncb->fDialSingleLink = TRUE;
            }
        }
        else if (    (prasconncb->pEntry->dwDialMode == RASEDM_DialAll)
                 &&  (0 == prasdialparams->dwSubEntry))
        {
            prasdialparams->dwSubEntry = 1;
        }
        else
        {
            dwSubEntries =
                DtlGetNodes(prasconncb->pEntry->pdtllistLinks);

            if (    0 == prasdialparams->dwSubEntry
                ||  prasdialparams->dwSubEntry > dwSubEntries )
            {
                prasdialparams->dwSubEntry = 1;
            }
            else
            {
                HRASCONN hConnEntry = NULL;
                CHAR *pszPbook = NULL;
                CHAR *pszentry = NULL;

                if(NULL != lpszPhonebookPath)
                {
                    pszPbook = strdupTtoA(lpszPhonebookPath);

                }
                else
                {
                    pszPbook = strdupTtoA(prasconncb->pbfile.pszPath);
                }

                if(NULL == pszPbook)
                {
                    DeleteRasconncbNode(prasconncb);
                    dwErr= ERROR_NOT_ENOUGH_MEMORY;
                    goto done;
                }
                
                pszentry = strdupTtoA(prasdialparams->szEntryName);

                if(NULL == pszentry)
                {
                    Free0(pszPbook);
                    DeleteRasconncbNode(prasconncb);
                    dwErr =  ERROR_NOT_ENOUGH_MEMORY;
                    goto done;
                }

                //
                // A valid subentry was specified. In this case
                // override the RASEDM_DialAll and dial only the
                // subentry specified.
                //
                prasconncb->fDialSingleLink = TRUE;
                // prasconncb->fMultilink = TRUE;

                //
                // Also check to see if this entry is already connected
                // i.e some other subentry in this entry is already up
                // and mark this entry as bundled if it is.
                //
                if(ERROR_SUCCESS == g_pRasGetHConnFromEntry(
                                &hConnEntry,
                                pszPbook,
                                pszentry))
                {
                    RASAPI32_TRACE2("Marking subentry %d as bundled because"
                    " the connection %ws is areadly up",
                    prasdialparams->dwSubEntry,
                    prasdialparams->szEntryName);
                    
                    prasconncb->fBundled = TRUE;
                }

                Free0(pszPbook);
                Free(pszentry);
                                
            }
        }

        RASAPI32_TRACE1("looking up subentry %d",
                prasdialparams->dwSubEntry);

        pdtlnode = DtlNodeFromIndex(
                    prasconncb->pEntry->pdtllistLinks,
                    prasdialparams->dwSubEntry - 1);

        //
        // If the subentry doesn't exist, then
        // return an error.
        //
        if (pdtlnode == NULL)
        {
            DeleteRasconncbNode(prasconncb);
            dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
            goto done;
        }

        prasconncb->pLink = (PBLINK *)DtlGetData(pdtlnode);
        ASSERT(prasconncb->pLink);

        //
        // Finish setting up the default phonebook entry.
        //
        if (prasdialparams->szEntryName[0] == TEXT('\0'))
        {
            DTLLIST *pdtllistPorts;
            PBPORT *pPort;

            dwErr = LoadPortsList(&pdtllistPorts);

            if (dwErr)
            {
                DeleteRasconncbNode(prasconncb);

                goto done;
            }

            //
            // Set the default entry to reference
            // the first device.
            //
            pdtlnode = DtlNodeFromIndex(pdtllistPorts, 0);

            if (pdtlnode == NULL)
            {
                DtlDestroyList(pdtllistPorts, DestroyPortNode);

                DeleteRasconncbNode(prasconncb);

                dwErr = ERROR_PORT_NOT_AVAILABLE;
                goto done;
            }

            pPort = (PBPORT *)DtlGetData(pdtlnode);
            ASSERT(pPort);

            dwErr = CopyToPbport(&prasconncb->pLink->pbport,
                                    pPort);

            if (dwErr)
            {
                DtlDestroyList(pdtllistPorts, DestroyPortNode);

                DeleteRasconncbNode(prasconncb);

                goto done;
            }

            DtlDestroyList(pdtllistPorts, DestroyPortNode);
        }

        //
        // Read the stashed information about this
        // entry to get the default domain.
        //
        dwMask = DLPARAMS_MASK_DOMAIN | DLPARAMS_MASK_OLDSTYLE;

        dwErr = g_pRasGetDialParams(
                    prasconncb->pEntry->dwDialParamsUID,
                    &dwMask,
                    &dialparams);

        if (    !dwErr
            &&  (dwMask & DLPARAMS_MASK_DOMAIN))
        {
            strncpyWtoT(
                prasconncb->szDomain,
                dialparams.DP_Domain,
                sizeof(prasconncb->szDomain) / sizeof(TCHAR));
        }

        //
        // Now get user preferences.
        //
        if (dwfOptions & RDEOPT_IgnoreModemSpeaker)
        {
            prasconncb->fDisableModemSpeaker =
              (dwfOptions & RDEOPT_SetModemSpeaker)
              ? FALSE : TRUE;
        }
        else
        {
            prasconncb->fDisableModemSpeaker =
                        (prasconncb->pLink != NULL) ?
                         !prasconncb->pLink->fSpeaker :
                         FALSE;
        }

        if (dwfOptions & RDEOPT_IgnoreSoftwareCompression)
        {
            prasconncb->fDisableSwCompression =
              !(dwfOptions & RDEOPT_SetSoftwareCompression);
        }
        else
        {
            prasconncb->fDisableSwCompression =
                            (prasconncb->pEntry != NULL)
                            ? !prasconncb->pEntry->fSwCompression
                            :  FALSE;
        }

        if (dwfOptions & RDEOPT_Router)
        {
            prasconncb->dwUserPrefMode = UPM_Router;
        }
        else if (dwfOptions & RDEOPT_NoUser)
        {
            prasconncb->dwUserPrefMode = UPM_Logon;
        }
        else
        {
            prasconncb->dwUserPrefMode = UPM_Normal;
        }

        if(dwfOptions & RDEOPT_UseCustomScripting)
        {
            prasconncb->fUseCustomScripting = TRUE;
        }

        //
        // Only enable prefix/suffix when there is no
        // override phone number.
        //
        prasconncb->fUsePrefixSuffix =
                        ((dwfOptions & RDEOPT_UsePrefixSuffix)
                    &&  (*prasdialparams->szPhoneNumber == '\0'))
                        ? TRUE
                        : FALSE;

        //
        // Set the handle NULL in case the user passed in an
        // invalid non-NULL handle, on the initial dial.
        //
        hrasconn = 0;

        prasconncb->fAlreadyConnected = FALSE;

        {
            CHAR szPhonebookPath [MAX_PATH];
            CHAR szEntryName [MAX_ENTRYNAME_SIZE];
            CHAR szRefEntryName[MAX_ENTRYNAME_SIZE];
            CHAR szRefPhonebookPath[MAX_PATH];

            dwSubEntries =
                    DtlGetNodes(prasconncb->pEntry->pdtllistLinks);

            pdwSubEntryInfo = LocalAlloc (
                                LPTR,
                                dwSubEntries * sizeof(DWORD));

            if (NULL == pdwSubEntryInfo)
            {
                DeleteRasconncbNode (prasconncb);
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto done;
            }

            strncpyTtoA(szPhonebookPath,
                       prasconncb->pbfile.pszPath,
                       sizeof(szPhonebookPath));

            strncpyTtoA(szEntryName,
                       prasconncb->pEntry->pszEntryName,
                       sizeof(szEntryName));

            if(prasconncb->pEntry->pszPrerequisiteEntry)
            {
                strncpyTtoA(szRefEntryName,
                           prasconncb->pEntry->pszPrerequisiteEntry,
                           sizeof(szRefEntryName));
            }
            else
            {
                *szRefEntryName = '\0';
            }

            if(prasconncb->pEntry->pszPrerequisitePbk)
            {
                strncpyTtoA(szRefPhonebookPath,
                           prasconncb->pEntry->pszPrerequisitePbk,
                           sizeof(szRefPhonebookPath));
            }
            else
            {
                *szRefPhonebookPath = '\0';
            }

            RASAPI32_TRACE("RasCreateConnection...");

            dwErr = g_pRasCreateConnection(
                                &prasconncb->hrasconn,
                                dwSubEntries,
                                &dwEntryAlreadyConnected,
                                pdwSubEntryInfo,
                                (prasconncb->fDialSingleLink)
                                ? RASEDM_DialAsNeeded
                                : RASEDM_DialAll,
                                prasconncb->pEntry->pGuid,
                                szPhonebookPath,
                                szEntryName,
                                szRefPhonebookPath,
                                szRefEntryName);

            RASAPI32_TRACE3(
              "RasCreateConnection(%d) hrasconn=%d, "
              "ConnectionAlreadyPresent=%d",
              dwErr,
              prasconncb->hrasconn,
              dwEntryAlreadyConnected);

            if(RCS_CONNECTING == (RASMAN_CONNECTION_STATE)
                                 dwEntryAlreadyConnected)
            {
                RASAPI32_TRACE("Entry is already in the process of"
                      " connecting");

                dwErr = ERROR_DIAL_ALREADY_IN_PROGRESS;

                if(NULL != pdwSubEntryInfo)
                {
                    LocalFree(pdwSubEntryInfo);
                    pdwSubEntryInfo = NULL;
                }

                DeleteRasconncbNode(prasconncb);
                goto done;
            }

            if (    NO_ERROR == dwErr
                &&  pdwSubEntryInfo[0])
            {
                prasconncb->fAlreadyConnected = TRUE;
            }
        }

        if (dwErr)
        {
            if (pdwSubEntryInfo)
            {
                LocalFree (pdwSubEntryInfo);
                pdwSubEntryInfo = NULL;
            }

            DeleteRasconncbNode(prasconncb);
            goto done;
        }

        hrasconn = (HRASCONN)prasconncb->hrasconn;
        rasconnstate = 0;

        prasconncb->hport           = INVALID_HPORT;

        prasconncb->dwNotifierType  = dwNotifierType;

        prasconncb->notifier        = notifier;

        prasconncb->hwndParent      = hwndParent;

        prasconncb->reserved        = reserved;

        prasconncb->fAllowPause     = fAllowPause;

        prasconncb->fPauseOnScript  =
                    (dwfOptions & RDEOPT_PausedStates)
                     ? TRUE : FALSE;

        if(     (NULL != lpExtensions)
            &&  (sizeof(RASDIALEXTENSIONS) == lpExtensions->dwSize)
            &&  (0 != lpExtensions->RasEapInfo.dwSizeofEapInfo))
        {
            //
            // Make a local copy of this buffer. This is not
            // very optimized but the user of this api may
            // not know when to free this pointer.
            //
            prasconncb->RasEapInfo.pbEapInfo =
                LocalAlloc(
                    LPTR,
                    lpExtensions->RasEapInfo.dwSizeofEapInfo);

            if(NULL == prasconncb->RasEapInfo.pbEapInfo)
            {
                dwErr = GetLastError();
                //
                // .Net bug# 508334 Resource created by CreateEntryNode is not
                // released in error return paths
                //
                DeleteRasconncbNode(prasconncb);
                //
                // .Net bug# 508343 Memory leak in _RasDial. pdwSubEntryInfo is
                // not relased in error return path
                //
                if (pdwSubEntryInfo)
                {
                    LocalFree(pdwSubEntryInfo);
                }
                goto done;
            }

            prasconncb->RasEapInfo.dwSizeofEapInfo =
                lpExtensions->RasEapInfo.dwSizeofEapInfo;

            memcpy(prasconncb->RasEapInfo.pbEapInfo,
                   lpExtensions->RasEapInfo.pbEapInfo,
                   prasconncb->RasEapInfo.dwSizeofEapInfo);

        }
        else
        {
            prasconncb->RasEapInfo.dwSizeofEapInfo = 0;
            prasconncb->RasEapInfo.pbEapInfo = NULL;
        }

        if (dwNotifierType == 0xFFFFFFFF)
        {
            prasconncb->unMsg = RegisterWindowMessageA(RASDIALEVENT);

            if (prasconncb->unMsg == 0)
            {
                prasconncb->unMsg = WM_RASDIALEVENT;
            }
        }
        else
        {
            prasconncb->unMsg = WM_RASDIALEVENT;
        }

        prasconncb->fDefaultEntry =
            (prasdialparams->szEntryName[0] == TEXT('\0'));

        SafeDecodePasswordBuf(prasconncb->szOldPassword);
        prasconncb->szOldPassword[ 0 ]          = TEXT('\0');
        SafeEncodePasswordBuf(prasconncb->szOldPassword);
        
        prasconncb->fRetryAuthentication        = FALSE;
        prasconncb->fMaster                     = FALSE;
        prasconncb->dwfSuspended                = SUSPEND_Start;
        prasconncb->fStopped                    = FALSE;
        prasconncb->fCleanedUp                  = FALSE;
        prasconncb->fDeleted                    = FALSE;
        prasconncb->fOldPasswordSet             = FALSE;
        prasconncb->fUpdateCachedCredentials    = FALSE;
        prasconncb->fPppEapMode                 = FALSE;

        //
        // Create the correct avpnprotsarray
        //
        AssignVpnProtsOrder(prasconncb);

        prasconncb->dwCurrentVpnProt = 0;

        /*
        if (    prasconncb->fDialSingleLink
            ||  (prasconncb->pEntry->dwDialMode
            == RASEDM_DialAsNeeded))
        {
            prasconncb->fMultilink = TRUE;
        }
        else
        {
            prasconncb->fMultilink = FALSE;
        }
        */

        // prasconncb->fBundled = FALSE;

        //
        // Get the idle disconnect timeout.  If there is a
        // timeout specified in the entry, then use it;
        // otherwise, get the one specified in the user
        // preferences.
        //
        dwIdleDisconnectSeconds = 0;

        if ((prasconncb->pEntry->dwfOverridePref
                 & RASOR_IdleDisconnectSeconds))
        {
            if(0 == prasconncb->pEntry->lIdleDisconnectSeconds)
            {
                dwIdleDisconnectSeconds = 0xFFFFFFFF;
            }
            else
            {
                dwIdleDisconnectSeconds =
                    (DWORD) prasconncb->pEntry->lIdleDisconnectSeconds;
            }
        }
        else
        {
            PBUSER pbuser;

            dwErr = GetUserPreferences(NULL,
                                      &pbuser,
                                      prasconncb->dwUserPrefMode);

            RASAPI32_TRACE2("GetUserPreferences(%d), "
                    "dwIdleDisconnectSeconds=%d",
                    dwErr,
                    pbuser.dwIdleDisconnectSeconds);

            if (dwErr)
            {
                if ( pdwSubEntryInfo )
                {
                    LocalFree ( pdwSubEntryInfo );
                }

                g_pRasRefConnection(prasconncb->hrasconn,
                                    FALSE,
                                    NULL);

                DeleteRasconncbNode(prasconncb);

                goto done;
            }

            dwIdleDisconnectSeconds = pbuser.dwIdleDisconnectSeconds;
            DestroyUserPreferences(&pbuser);
        }

/*
        //
        // Round the idle disconnect seconds to minutes.
        //
        if (dwIdleDisconnectSeconds)
        {
            prasconncb->dwIdleDisconnectMinutes =
              (dwIdleDisconnectSeconds + 59) / 60;
        }

        RASAPI32_TRACE1("dwIdleDisconnectMinutes=%d",
                  prasconncb->dwIdleDisconnectMinutes);

*/        

        if(dwIdleDisconnectSeconds)
        {
            prasconncb->dwIdleDisconnectSeconds =
                            dwIdleDisconnectSeconds;
        }

        RASAPI32_TRACE1("dwIdleDisconnectSeconds=%d",
                prasconncb->dwIdleDisconnectSeconds);

        if (!dwEntryAlreadyConnected)
        {
            // If the connection is not already up
            // Initialize projection information so we
            // get consistent results during the dialing
            // process.
            //
            memset(&prasconncb->PppProjection,
                '\0', sizeof(prasconncb->PppProjection));

            prasconncb->PppProjection.nbf.dwError       =

                prasconncb->PppProjection.ipx.dwError   =

                prasconncb->PppProjection.ip.dwError    =
                            ERROR_PPP_NO_PROTOCOLS_CONFIGURED;

            prasconncb->hportBundled = INVALID_HPORT;

            memset(&prasconncb->AmbProjection,
                  '\0',
                  sizeof (prasconncb->AmbProjection));

            prasconncb->AmbProjection.Result =
                                    ERROR_PROTOCOL_NOT_CONFIGURED;

            memset(&prasconncb->SlipProjection,
                  '\0',
                  sizeof (prasconncb->SlipProjection));

            prasconncb->SlipProjection.dwError =
                                    ERROR_PROTOCOL_NOT_CONFIGURED;

            RASAPI32_TRACE("SaveProjectionResults...");

            dwErr = SaveProjectionResults(prasconncb);

            RASAPI32_TRACE1("SaveProjectionResults(%d)", dwErr);
        }

    }  // if (fNewEntry)

    //
    // Set/update RASDIALPARAMS for the connection.  Can't just
    // read from caller's buffer since the call is asynchronous.
    // If we are restarting RasDial, then we need to save the
    // subentry away and restore it after the memcpy because
    // it may have been 0 in the caller's original version.
    //
    {
        DWORD dwSubEntry;

        if (!fNewEntry)
        {
            dwSubEntry = prasconncb->rasdialparams.dwSubEntry;
        }

       //Decode the password
        SafeDecodePasswordBuf(prasdialparams->szPassword );
        SafeWipePasswordBuf(prasconncb->rasdialparams.szPassword);
        
        memcpy(&prasconncb->rasdialparams,
              prasdialparams,
              prasdialparams->dwSize);

        SafeEncodePasswordBuf (prasconncb->rasdialparams.szPassword);
        SafeEncodePasswordBuf(prasdialparams->szPassword );

        if (!fNewEntry)
        {
            prasconncb->rasdialparams.dwSubEntry = dwSubEntry;

            //
            // Update the rasdialparams for all the subentries.
            //
            SafeDecodePasswordBuf (prasconncb->rasdialparams.szPassword);
            SafeDecodePasswordBuf (prasconncb->szOldPassword);
            
            SyncDialParamsSubentries(prasconncb);
            
            SafeEncodePasswordBuf (prasconncb->rasdialparams.szPassword);
            SafeEncodePasswordBuf (prasconncb->szOldPassword);
        }
    }


    //
    // Initialize the state machine.  If the state is non-0 we
    // are resuming from a paused state, the machine is
    // already in place (blocked) and just the next
    // state need be set.
    //
    prasconncb->rasconnstateNext = rasconnstate;

    //
    // Enter CriticalSection here so that the async worker thread
    // is not stopped before we are done with our initialization
    // of the link.
    //
    EnterCriticalSection(&csStopLock);

    if (rasconnstate == 0)
    {
        if (    prasconncb->fDefaultEntry
            &&  prasconncb->rasdialparams.szPhoneNumber[0]
                == TEXT('\0'))
        {
            if (pdwSubEntryInfo)
            {
                LocalFree (pdwSubEntryInfo);
            }

            g_pRasRefConnection(prasconncb->hrasconn,
                                FALSE, NULL);

            //
            // No phone number or entry name...gotta
            // have one or the other.
            //
            DeleteRasconncbNode(prasconncb);
            LeaveCriticalSection(&csStopLock);
            dwErr =  ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
            goto done;
        }

        //
        // Read the PPP-related fields from the phonebook
        // entry (or set defaults if default entry).
        //
        if ((dwErr = ReadPppInfoFromEntry(prasconncb)) != 0)
        {
            if (pdwSubEntryInfo)
            {
                LocalFree (pdwSubEntryInfo);
            }

            g_pRasRefConnection(prasconncb->hrasconn, FALSE, NULL);

            DeleteRasconncbNode(prasconncb);

            LeaveCriticalSection(&csStopLock);

            goto done;
        }

        prasconncb->asyncmachine.oneventfunc =
                            (ONEVENTFUNC )OnRasDialEvent;

        prasconncb->asyncmachine.cleanupfunc =
                            (CLEANUPFUNC )RasDialCleanup;

        prasconncb->asyncmachine.freefunc =
                            (FREEFUNC) RasDialFinalCleanup;

        prasconncb->asyncmachine.pParam =
                            (VOID* )prasconncb;

        prasconncb->rasconnstate = 0;

        if (0 !=
            (dwErr =
                StartAsyncMachine(&prasconncb->asyncmachine,
                                   prasconncb->hrasconn)))
        {
            if (pdwSubEntryInfo)
            {
                LocalFree (pdwSubEntryInfo);
            }

            g_pRasRefConnection(prasconncb->hrasconn,
                                FALSE, NULL);

            DeleteRasconncbNode(prasconncb);

            LeaveCriticalSection(&csStopLock);

            goto done;
        }

    }

    *lphrasconn = hrasconn;

    dwSubEntries = DtlGetNodes(prasconncb->pEntry->pdtllistLinks);

    if(prasconncb->pEntry->dwDialMode != 0)
    {
        if(dwSubEntries > 1)
        {
            prasconncb->fMultilink = TRUE;
        }
        else
        {
            prasconncb->fMultilink = FALSE;
        }
    }
    else
    {
        prasconncb->fMultilink = FALSE;
    }

    //
    // If this is a multilinked subentry, then create
    // separate connection blocks for each subentry.
    // The async machine will multiplex its work over
    // all connection blocks in round-robin order.
    //
    if (    fNewEntry
        &&  prasconncb->pEntry->dwDialMode == RASEDM_DialAll
        &&  fEnableMultilink
        &&  !prasconncb->fDialSingleLink)
    {
        DTLNODE     *pdtlnode;
        RASCONNCB   *prasconncb2;
        DWORD       *pdwSubentryInfo = NULL;

        DWORD       i;

        /*                    

        if (1 == dwSubEntries)
        {
            //
            // If there is only one link in the bundle don't
            // multilink.
            //
            prasconncb->fMultilink = FALSE;
        }

        */


        for (i = 1; i < dwSubEntries; i++)
        {

            RASAPI32_TRACE1("Creating connection block for subentry %d",
                  i + 1);

            prasconncb2 = CreateConnectionBlock(prasconncb);

            if (prasconncb2 == NULL)
            {
                if (pdwSubEntryInfo)
                {
                    LocalFree (pdwSubEntryInfo);
                }

                DeleteRasconncbNode(prasconncb);

                LeaveCriticalSection(&csStopLock);

                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto done;
            }

            //
            // Look up the subentry.
            //
            pdtlnode = DtlNodeFromIndex(
                        prasconncb->pEntry->pdtllistLinks,
                        i);

            ASSERT(pdtlnode);
            prasconncb2->pLink = (PBLINK *)
                                 DtlGetData(pdtlnode);

            ASSERT(prasconncb->pLink);
            prasconncb2->rasdialparams.dwSubEntry = i + 1;

            if (dwEntryAlreadyConnected)
            {
                if (pdwSubEntryInfo[i])
                {
                    prasconncb2->fAlreadyConnected = TRUE;
                }
                else
                {
                    prasconncb2->fAlreadyConnected = FALSE;
                }
            }
        }
    }

    //
    // Start all the state machines at the same time.
    //
    StartSubentries(prasconncb);
    hDone = prasconncb->asyncmachine.hDone;

    if (pdwSubEntryInfo)
    {
        LocalFree (pdwSubEntryInfo);
    }

    if(NULL == notifier)
    {
        prasconncb->psyncResult = &dwErr;
    }

    LeaveCriticalSection(&csStopLock);

    //
    // If caller provided a notifier then return, i.e.
    // operate asynchronously. Otherwise, operate
    // synchronously (from caller's point of view).
    //
    if (notifier)
    {
        dwErr = 0;
        goto done;
    }
    else
    {
        //
        // Moved the cleanup of prasconncb in the synchronous
        // case to the Asyncmachine worker thread. prasconncb
        // is freed when the waitfor... returns.
        //
        RASAPI32_TRACE("_RasDial: Waiting for async worker to terminate...");

        WaitForSingleObject(hDone, INFINITE);

        RASAPI32_TRACE("_RasDial: Async worker terminated");

       goto done;
    }

done:

    SafeDecodePasswordBuf(prasdialparams->szPassword );
    
    return dwErr;
}

BOOL
ErrorWorthRetryingOnAnotherModem(
	IN DWORD dwError )
{
    switch(dwError)
    {
        case ERROR_NO_CARRIER:
        case ERROR_NO_DIALTONE:
        case ERROR_PORT_NOT_AVAILABLE:
            return TRUE;

        default:
            return FALSE;
    }
}

DWORD
OnRasDialEvent(
    IN ASYNCMACHINE* pasyncmachine,
    IN BOOL          fDropEvent )

/*++

Routine Description:

        Called by asynchronous state machine whenever one of the
        events is signalled.  'pasyncmachine' is the address of
        the async machine.'fDropEvent' is true if the "connection
        dropped" event occurred,otherwise the "state done" event
        occurred.

Arguments:

Return Value:

        Returns true to end the state machine, false to continue.

--*/
{
    DWORD      dwErr;
    RASCONNCB* prasconncb = (RASCONNCB* )pasyncmachine->pParam;
    BOOL       fPortClose = FALSE;

    //
    // Detect errors that may have occurred.
    //
    if (fDropEvent)
    {
        //
        // Connection dropped notification received.
        //
        RASMAN_INFO info;

        RASAPI32_TRACE("Link dropped!");

        prasconncb->rasconnstate = RASCS_Disconnected;

        if(     (SUCCESS == prasconncb->dwSavedError)
            ||  (PENDING == prasconncb->dwSavedError))
        {            
            prasconncb->dwError = ERROR_DISCONNECTION;
        }
        else
        {
            prasconncb->dwError = prasconncb->dwSavedError;
        }

        //
        // Convert the reason the line was dropped into a more
        // specific error code if available.
        //
        RASAPI32_TRACE("RasGetInfo...");

        dwErr = g_pRasGetInfo( NULL,
                               prasconncb->hport,
                               &info );

        RASAPI32_TRACE1("RasGetInfo done(%d)", dwErr);

        if (    (dwErr == 0)
            &&  (SUCCESS == prasconncb->dwError))
        {
            prasconncb->dwError =
                ErrorFromDisconnectReason(info.RI_DisconnectReason);

#ifdef AMB
            if (    prasconncb->fPppMode
                &&  prasconncb->fIsdn
                &&  prasconncb->dwAuthentication == AS_PppThenAmb
                &&  prasconncb->dwError == ERROR_REMOTE_DISCONNECTION
                &&  !prasconncb->fMultilink)
            {
                //
                // This is what happens when PPP ISDN tries to talk
                // to a down-level server.  The ISDN frame looks
                // enough like a PPP frame to the old ISDN driver
                // that it gets passed to the old server who sees
                // it's not AMB and drops the line. We do *not*
                // do this with multilink connections.
                //
                RASAPI32_TRACE("PPP ISDN disconnected, try AMB");

                prasconncb->dwRestartOnError = RESTART_DownLevelIsdn;
                prasconncb->fPppMode = FALSE;
            }
#endif
        }
        else if(ERROR_PORT_NOT_OPEN == dwErr)
        {
            if(0 != info.RI_LastError)
            {
                RASAPI32_TRACE1("Port was close because of %d",
                       info.RI_LastError);

                prasconncb->dwError = info.RI_LastError;
                dwErr = info.RI_LastError;
            }
        }
    }
    else if (pasyncmachine->dwError != 0)
    {
        RASAPI32_TRACE("Async machine error!");

        //
        // A system call in the async machine mechanism failed.
        //
        prasconncb->dwError = pasyncmachine->dwError;
    }
    else if (prasconncb->dwError == PENDING)
    {
        prasconncb->dwError = 0;

        if (prasconncb->hport != INVALID_HPORT)
        {
            RASMAN_INFO info;

            RASAPI32_TRACE("RasGetInfo...");

            dwErr = g_pRasGetInfo( NULL,
                                   prasconncb->hport,
                                   &info );

            RASAPI32_TRACE1("RasGetInfo done(%d)", dwErr);

            if (    (dwErr != 0)
                ||  ((dwErr = info.RI_LastError) != 0))
            {
                if(ERROR_PORT_NOT_OPEN == dwErr)
                {
                    //
                    // Try to find out why this
                    // port was disconnected.
                    //
                    if(0 != info.RI_LastError)
                    {
#if DBG
                        RASAPI32_TRACE1("Mapping Async err to"
                               " lasterror=%d",
                               info.RI_LastError);
#endif
                        dwErr = info.RI_LastError;
                    }
                }

                //
                // A pending RAS Manager call failed.
                //
                prasconncb->dwError = dwErr;

                RASAPI32_TRACE1("Async failure=%d", dwErr);

                //
                // if the rasdial machine is waiting for this
                // device to be connected or a listen to be
                // posted and the async operation failed
                // in rasman, close the port after notifying the
                // clients that the connect or the post listen
                // failed.
                //
                if (    RASCS_WaitForCallback
                        == prasconncb->rasconnstate
                    ||  RASCS_ConnectDevice
                        == prasconncb->rasconnstate)
                {
                    RASAPI32_TRACE2("RDM: Marking port %d for closure in "
                           "RASCS = %d",
                           prasconncb->hport,
                           prasconncb->rasconnstate);

                    fPortClose = TRUE;
                }
            }
        }
    }
    else if (       (prasconncb->dwError != 0)
                &&  (prasconncb->rasconnstate == RASCS_OpenPort)
                &&  (INVALID_HPORT != prasconncb->hport))
    {
        RASAPI32_TRACE2("RDM: Marking port %d for closure in "
               "RASCS = %d!!!!!",
               prasconncb->hport,
               prasconncb->rasconnstate);

        fPortClose = TRUE;
    }

    if (prasconncb->dwError == 0)
    {
        //
        // Last state completed cleanly so move to next state.
        //
        if ( prasconncb->fAlreadyConnected )
        {
            RASAPI32_TRACE("OnRasDialEvent: Setting state to connected - "
                  "is already connected!");

            prasconncb->rasconnstate = RASCS_Connected;
        }
        else
        {
            prasconncb->rasconnstate =
                    prasconncb->rasconnstateNext;

        }
    }
    else if (   (RASET_Vpn == prasconncb->pEntry->dwType)
            &&  (RASCS_DeviceConnected > prasconncb->rasconnstate)
            &&  (prasconncb->iAddress < prasconncb->cAddresses)
            &&  (NULL != prasconncb->pAddresses)
            &&  (prasconncb->dwError != ERROR_NO_CERTIFICATE)
            &&  (prasconncb->dwError != ERROR_OAKLEY_NO_CERT)
            &&  (prasconncb->dwError != ERROR_CERT_FOR_ENCRYPTION_NOT_FOUND)
            &&  (prasconncb->hport != INVALID_HPORT))
    {
        EnterCriticalSection(&csStopLock);

        RasDialTryNextAddress(&prasconncb);

        LeaveCriticalSection(&csStopLock);
    }
    else if (prasconncb->dwRestartOnError != 0)
    {
        //
        // Last state failed, but we're in "restart on error"
        // mode so we can attempt to restart.
        //
        EnterCriticalSection(&csStopLock);

        //
        // Don't attempt to try other numbers if the port
        // failed to open.
        // BUG 84132.
        //
        ASSERT(NULL != prasconncb->pLink);

        //
        // Don't try alternate phone numbers (hunt) in
        // the following cases:
        // 1. if the port didn't open successfully
        // 2. if the user has disabled this in the phone
        //    book - TryNextAlternateOnFail=0 in the phone
        //    book for this entry.
        // 3. if an override phone number is specified - from
        //    the ui this can happen if the user either picked
        //    different phonenumber from the drop down list
        //    than the one displayed originally or modified
        //    the originally displayed number.
        //
        if (    prasconncb->hport != INVALID_HPORT
            &&  prasconncb->pLink->fTryNextAlternateOnFail
            &&  TEXT('\0')
                == prasconncb->rasdialparams.szPhoneNumber[0])
        {
            RasDialRestart(&prasconncb);
        }
        else
        {
            RASAPI32_TRACE1 ("Not Restarting rasdial as port is not open. %d",
                     prasconncb->dwError);
        }

        LeaveCriticalSection(&csStopLock);
    }

    //
    // If we failed before or at the DeviceConnect
    // state and if the dialMode is set to try next
    // link , try to dial the next link. Skip dial 
    // next link for VPN and DCC devices. It doesn't
    // make much sense to dial next link for these
    // devices.
    //
    if(     0 != prasconncb->dwError
        &&  RASCS_DeviceConnected > prasconncb->rasconnstate
        &&  RASET_Vpn != prasconncb->pEntry->dwType
        &&  RASET_Direct != prasconncb->pEntry->dwType
        &&  !prasconncb->fDialSingleLink
        &&  prasconncb->fTryNextLink
        &&  !prasconncb->fTerminated
        &&  ErrorWorthRetryingOnAnotherModem(prasconncb->dwError))
        // &&  0 == prasconncb->pEntry->dwDialMode)
    {
        //
        // Get a lock so that prasconncb is not blown
        // away from under us - by HangUp for example
        //
        EnterCriticalSection(&csStopLock);

        RasDialTryNextLink(&prasconncb);

        LeaveCriticalSection(&csStopLock);
    }

    if(     0 != prasconncb->dwError
        &&  RASCS_DeviceConnected > prasconncb->rasconnstate
        &&  RASET_Vpn == prasconncb->pEntry->dwType)
    {
        EnterCriticalSection(&csStopLock);

        RasDialTryNextVpnDevice(&prasconncb);

        LeaveCriticalSection(&csStopLock);
    }

    if (    prasconncb->rasconnstate == RASCS_Connected
        &&  !prasconncb->fAlreadyConnected)
    {

        BOOL fPw = FALSE;

        //
        // If we are dialing a single-link entry that gets
        // bundled with another entry, then we haven't saved
        // the projection information yet.  The restriction
        // on this behavior is that the connection to which
        // this connection is getting bundled must already
        // have projection information.  This is not guaranteed
        // if both entries are being dialed simultaneously.
        // It is assumed this is not the case.  We fail the
        // bundled connection if we cannot get the projection
        // information on the first try.
        //
        if (    !prasconncb->fMultilink 
            &&   prasconncb->hportBundled != INVALID_HPORT)
        {
            RASMAN_INFO info;
            DWORD dwSize;

            //
            // The new connection was bundled with an existing
            // connection.  Retrieve the PPP projection
            // information for the connection to which it was
            // bundled and duplicate it for the new
            // connection.
            //
            RASAPI32_TRACE1(
              "Single link entry bundled to hport %d",
              prasconncb->hportBundled);
            //
            // Get the projection information
            // for the connection to which this
            // port was bundled.
            //
            dwErr = g_pRasGetInfo(
                      NULL,
                      prasconncb->hportBundled,
                      &info);
            //
            // If we can't get the projection information
            // for the bundled port, then we need to
            // terminate this link.
            //
            if (dwErr)
            {
                RASAPI32_TRACE2("RasGetInfo, hport=%d, failed. rc=0x%x",
                       prasconncb->hportBundled,
                       dwErr);

                       
                prasconncb->dwError =
                        ERROR_PPP_NO_PROTOCOLS_CONFIGURED;

                goto update;
            }

            dwSize = sizeof (prasconncb->PppProjection);

            dwErr = g_pRasGetConnectionUserData(
                      info.RI_ConnectionHandle,
                      CONNECTION_PPPRESULT_INDEX,
                      (PBYTE)&prasconncb->PppProjection,
                      &dwSize);

            if (dwErr)
            {
                RASAPI32_TRACE2("RasGetConnectionUserData, hport=%d failed. rc=0x%x",
                      info.RI_ConnectionHandle,
                      dwErr);
                prasconncb->dwError = ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
                goto update;
            }

            //
            // Save the projection results.
            //
            RASAPI32_TRACE("SaveProjectionResults...");
            dwErr = SaveProjectionResults(prasconncb);
            RASAPI32_TRACE1("SaveProjectionResults(%d)", dwErr);
        }

        //
        // Check to see if the connection happened using the
        // credentials in the default store. If it did then
        // don't save anything in the users store in lsa.
        //
        {
            DWORD rc = ERROR_SUCCESS;
            RAS_DIALPARAMS dialparams;            
            DWORD dwMask;

            ZeroMemory(&dialparams, sizeof(RAS_DIALPARAMS));

            dwMask = DLPARAMS_MASK_USERNAME
                   | DLPARAMS_MASK_DOMAIN
                   | DLPARAMS_MASK_PASSWORD;

            rc = g_pRasGetDialParams(
                        prasconncb->pEntry->dwDialParamsUID,
                        &dwMask,
                        &dialparams);

            if(     (ERROR_SUCCESS == rc)
                &&  (   (dwMask & DLPARAMS_MASK_DEFAULT_CREDS)
                    ||  (dwMask & DLPARAMS_MASK_PASSWORD)))
            {
                fPw = TRUE;
            }
        }


        //
        // For entries that authenticate with the
        // current username/password, we only save
        // the domain.  Otherwise, we save everything.
        //
        if (    !fPw
            &&  !prasconncb->fRetryAuthentication)
        {
            DWORD dwMask;

            SafeDecodePasswordBuf(prasconncb->rasdialparams.szPassword);

            if (prasconncb->pEntry->fAutoLogon)
            {
                dwMask =    DLPARAMS_MASK_PHONENUMBER
                        |   DLPARAMS_MASK_CALLBACKNUMBER
                        |   DLPARAMS_MASK_USERNAME
                        |   DLPARAMS_MASK_PASSWORD
                        |   DLPARAMS_MASK_DOMAIN
                        |   DLPARAMS_MASK_SUBENTRY
                        |   DLPARAMS_MASK_OLDSTYLE;

                (void)SetEntryDialParamsUID(
                        prasconncb->pEntry->dwDialParamsUID,
                        dwMask,
                        &prasconncb->rasdialparams,
                        TRUE);

                dwMask =    DLPARAMS_MASK_DOMAIN
                        |   DLPARAMS_MASK_OLDSTYLE;

                (void)SetEntryDialParamsUID(
                        prasconncb->pEntry->dwDialParamsUID,
                        dwMask,
                        &prasconncb->rasdialparams,
                        FALSE);
            }
            else
            {
                // Note: DLPARAMS_MASK_PASSWORD removed as it has been decided
                //       that "automatically" saving it here without user's
                //       input is too big a security hole for NT.  This is a
                //       small incompatibility with Win9x, which really should
                //       also make this change.
                //
                dwMask =    DLPARAMS_MASK_PHONENUMBER
                        |   DLPARAMS_MASK_CALLBACKNUMBER
                        |   DLPARAMS_MASK_USERNAME
                        |   DLPARAMS_MASK_DOMAIN
                        |   DLPARAMS_MASK_SUBENTRY
                        |   DLPARAMS_MASK_OLDSTYLE;

                (void)SetEntryDialParamsUID(
                        prasconncb->pEntry->dwDialParamsUID,
                        dwMask,
                        &prasconncb->rasdialparams,
                        FALSE);
            }

            SafeEncodePasswordBuf(prasconncb->rasdialparams.szPassword);
        }

        if (!prasconncb->fDefaultEntry)
        {
            PBLINK *pLink = prasconncb->pLink;

            //
            // Reorder the hunt group order if the
            // entry specifies it. 
            //
            if (    pLink->fPromoteAlternates
                &&  DtlGetNodes(pLink->pdtllistPhones) > 1)
            {
                DTLNODE *pdtlnode = DtlNodeFromIndex(
                                      pLink->pdtllistPhones,
                                      prasconncb->iPhoneNumber);

                RASAPI32_TRACE1(
                  "Promoting hunt group number index %d to top",
                  prasconncb->iPhoneNumber);
                DtlRemoveNode(
                  pLink->pdtllistPhones,
                  pdtlnode);
                DtlAddNodeFirst(
                  pLink->pdtllistPhones,
                  pdtlnode);
                prasconncb->pEntry->fDirty = TRUE;
            }

            //
            // Write the phonebook out if we had to
            // modify it during the dialing process.
            // Ignore errors if we get them.  Note
            // the phonebook entry could become dirty
            // from SetAuthentication() or the code
            // above.
            //
            if (prasconncb->pEntry->fDirty)
            {
                RASAPI32_TRACE("Writing phonebook");
                (void)WritePhonebookFile(&prasconncb->pbfile,
                                         NULL);
            }
        }
    }

    //
    // Update the connection states in rasman.
    //

update:

    if (prasconncb->hport != INVALID_HPORT)
    {
        RASCONNSTATE rasconnstate;
        //
        // If we are not the last subentry in the connection
        // then only report RASCS_SubEntryConnected state.
        //
        rasconnstate = prasconncb->rasconnstate;
        RASAPI32_TRACE1("setting rasman state to %d",
                rasconnstate);

        dwErr = g_pRasSetPortUserData(
                  prasconncb->hport,
                  PORT_CONNSTATE_INDEX,
                  (PBYTE)&rasconnstate,
                  sizeof (rasconnstate));

        dwErr = g_pRasSetPortUserData(
                  prasconncb->hport,
                  PORT_CONNERROR_INDEX,
                  (PBYTE)&prasconncb->dwError,
                  sizeof (prasconncb->dwError));
    }
    //
    // Inform rasman that the connection
    // has been authenticated.
    //
    if (    (MapSubentryState(prasconncb) 
            == RASCS_Connected) 
        ||  (MapSubentryState(prasconncb)
            == RASCS_SubEntryConnected))
    {
        RASAPI32_TRACE("RasSignalNewConnection...");
        dwErr = g_pRasSignalNewConnection(
                    (HCONN)prasconncb->hrasconn);

        RASAPI32_TRACE1("RasSignalNewConnection(%d)", dwErr);
    }

    //
    // Notify caller's app of change in state.
    //
    if (prasconncb->notifier)
    {
        DWORD dwNotifyResult;
        RASCONNSTATE rasconnstate =
                MapSubentryState(prasconncb);

        DTLNODE *pdtlnode;

        if (    RASCS_AuthRetry != rasconnstate
            ||  !prasconncb->fPppEapMode)
        {
            dwNotifyResult =
              NotifyCaller(
                prasconncb->dwNotifierType,
                prasconncb->notifier,
                (HRASCONN)prasconncb->hrasconn,
                prasconncb->rasdialparams.dwSubEntry,
                prasconncb->rasdialparams.dwCallbackId,
                prasconncb->unMsg,
                rasconnstate,
                prasconncb->dwError,
                prasconncb->dwExtendedError);

            switch (dwNotifyResult)
            {
            case 0:
                RASAPI32_TRACE1(
                  "Discontinuing callbacks for hrasconn 0x%x",
                  prasconncb->hrasconn);

                //
                // If the notifier procedure returns FALSE, then
                // we discontinue all callbacks for this
                // connection.
                //
                EnterCriticalSection(&RasconncbListLock);
                for (pdtlnode = DtlGetFirstNode(PdtllistRasconncb);
                     pdtlnode;
                     pdtlnode = DtlGetNextNode(pdtlnode))
                {
                    RASCONNCB *prasconncbTmp = DtlGetData(pdtlnode);

                    ASSERT(prasconncbTmp);

                    if(prasconncbTmp->hrasconn
                        == prasconncb->hrasconn)
                    {
                        prasconncbTmp->notifier = NULL;

                        RASAPI32_TRACE2(
                           "Cleared notifier for hrasconn 0x%x "
                           "subentry %d",
                            prasconncbTmp->hrasconn,
                            prasconncbTmp->rasdialparams.dwSubEntry);
                    }

                }
                LeaveCriticalSection(&RasconncbListLock);

                break;

            case 2:
                RASAPI32_TRACE1(
                  "Reloading phonebook entry for hrasconn 0x%x",
                  prasconncb->hrasconn);


                ReloadRasconncbEntry(prasconncb);

                break;

            default:
                // no special handling required
                break;
            }
        }
    }

    if (fPortClose)
    {
        DWORD dwErrT;

        EnterCriticalSection(&csStopLock);

        if (RASCS_ConnectDevice
                == prasconncb->rasconnstate)
        {
            RASMAN_INFO ri;

            dwErrT = g_pRasGetInfo(
                        NULL,
                        prasconncb->hport,
                        &ri);

            RASAPI32_TRACE2("RDM: RasGetInfo, port=%d returned %d",
                    prasconncb->hport,
                    dwErrT);

            if(   (ERROR_SUCCESS == dwErrT)
                &&  (0 == (ri.RI_CurrentUsage & CALL_IN)))
            {                
            
            
                RASAPI32_TRACE1("RDM: DisconnectPort %d...",
                        prasconncb->hport);

                dwErrT = RasPortDisconnect(
                                prasconncb->hport,
                                INVALID_HANDLE_VALUE );

                RASAPI32_TRACE1("RDM: DisconnectPort comleted. %d",
                        dwErrT);
            }                    
        }

        RASAPI32_TRACE1("RDM: PortClose %d ...",
                prasconncb->hport);

        dwErrT = g_pRasPortClose(prasconncb->hport);

        RASAPI32_TRACE2("RDM: PortClose %d Completed. %d",
                prasconncb->hport, dwErrT);

        LeaveCriticalSection( &csStopLock );

    }


    //
    // If we're connected or a fatal error occurs or user
    // hung up, the state machine will end.
    //
    if (    prasconncb->rasconnstate & RASCS_DONE
        ||  prasconncb->dwError != 0
        || (    fDropEvent
            &&  !IsListEmpty(&prasconncb->ListEntry)))
    {
        RASAPI32_TRACE2(
          "Quitting s=%d,e=%d",
          prasconncb->rasconnstate,
          prasconncb->dwError);

        //
        // If the first link fails during a multilink
        // connection during PPP authentication phase,
        // then other links are currently suspeneded,
        // and must be restarted.
        //
        if (IsSubentriesSuspended(prasconncb))
        {
            RASAPI32_TRACE("resetting remaining subentries");
            RestartSubentries(prasconncb);
        }

        return TRUE;
    }

    if (!(prasconncb->rasconnstate & RASCS_PAUSED))
    {
        //
        // Execute the next state and block waiting for
        // it to finish.  This is not done if paused
        // because user will eventually call RasDial
        // to resume and unblock via the _RasDial
        // kickstart.
        //
        prasconncb->rasconnstateNext =
            RasDialMachine(
                prasconncb->rasconnstate,
                prasconncb,
                hDummyEvent,
                hDummyEvent );

    }

    return FALSE;
}


VOID
RasDialCleanup(
    IN ASYNCMACHINE* pasyncmachine )

/*++

Routine Description:

        Called by async machine just before exiting.

Arguments:

Return Value:

--*/
{
    DWORD      dwErr;
    DTLNODE*   pdtlnode;
    RASCONNCB* prasconncb = (RASCONNCB* )pasyncmachine->pParam;
    RASCONNCB* prasconncbTmp;
    HCONN      hconn = prasconncb->hrasconn;

    RASAPI32_TRACE("RasDialCleanup...");

    EnterCriticalSection(&RasconncbListLock);

    for (pdtlnode = DtlGetFirstNode( PdtllistRasconncb );
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode ))
    {
        prasconncbTmp = (RASCONNCB* )DtlGetData( pdtlnode );

        ASSERT(prasconncbTmp);

        if (    prasconncbTmp == prasconncb
            &&  !prasconncbTmp->fCleanedUp)
        {
            CleanUpRasconncbNode(pdtlnode);
            break;
        }
    }

    LeaveCriticalSection(&RasconncbListLock);

    RASAPI32_TRACE("RasDialCleanUp done.");
}


VOID
RasDialFinalCleanup(
    IN ASYNCMACHINE* pasyncmachine,
    DTLNODE *pdtlnode
    )
{
    RASCONNCB* prasconncb = (RASCONNCB* )pasyncmachine->pParam;

    RASAPI32_TRACE1("RasDialFinalCleanup: deallocating prasconncb=0x%x",
            prasconncb);

    EnterCriticalSection(&csStopLock);

    //
    // Make sure the connection block is
    // off the list.
    //
    DeleteRasconncbNode(prasconncb);

    //
    // Finally free the connection block.
    //
    FinalCleanUpRasconncbNode(pdtlnode);

    LeaveCriticalSection(&csStopLock);
}


DWORD
ComputeLuid(
    PLUID pLuid
    )

/*++

Routine Description:

        Compute a LUID for RasPppStart.  This code was
        stolen from rasppp.

Arguments:

Return Value:

--*/

{
    HANDLE           hToken = NULL;
    TOKEN_STATISTICS TokenStats;
    DWORD            TokenStatsSize;
    DWORD            dwErr = ERROR_SUCCESS;
    
    //
    // Salamonian code to get LUID for authentication.
    // This is only required for "auto-logon"
    // authentication.
    //
    if (!OpenProcessToken(GetCurrentProcess(),
                          TOKEN_QUERY,
                          &hToken))
    {
        dwErr = GetLastError();
        goto done;
    }

    if (!GetTokenInformation(hToken,
                             TokenStatistics,
                             &TokenStats,
                             sizeof(TOKEN_STATISTICS),
                             &TokenStatsSize))
    {
        dwErr = GetLastError();
        goto done;
    }

    //
    // "This will tell us if there was an API failure
    // (means our buffer wasn't big enough)"
    //
    if (TokenStatsSize > sizeof(TOKEN_STATISTICS))
    {
        dwErr = GetLastError();
        goto done;
    }

    *pLuid = TokenStats.AuthenticationId;

done:
    if(NULL != hToken)
    {
        CloseHandle(hToken);
    }
    
    return dwErr;
}

VOID
SaveVpnStrategyInformation(RASCONNCB *prasconncb)
{
    DWORD dwVpnStrategy = prasconncb->pEntry->dwVpnStrategy;
    DWORD dwCurrentProt = prasconncb->dwCurrentVpnProt;

    RASAPI32_TRACE("SaveVpnStrategyInformation...");

    if(     (VS_PptpOnly == (dwVpnStrategy & 0x0000FFFF))
        ||  (VS_L2tpOnly == (dwVpnStrategy & 0x0000FFFF)))
    {
        goto done;
    }

    ASSERT(dwCurrentProt < NUMVPNPROTS);

    switch (prasconncb->ardtVpnProts[dwCurrentProt])
    {
        case RDT_Tunnel_Pptp:
        {
            RASAPI32_TRACE1("Saving %d as the vpn strategy",
                   VS_PptpFirst);

            prasconncb->pEntry->dwVpnStrategy = VS_PptpFirst;
            break;
        }

        case RDT_Tunnel_L2tp:
        {
            RASAPI32_TRACE1("Saving %d as the vpn strategy",
                   VS_L2tpFirst);

            prasconncb->pEntry->dwVpnStrategy = VS_L2tpFirst;
            break;
        }

        default:
        {
            ASSERT(FALSE);
        }
    }

    //
    // Dirty the entry so that this entry is saved
    // in OnRasDialEvent..
    //
    prasconncb->pEntry->fDirty = TRUE;

done:

    RASAPI32_TRACE("SaveVpnStrategyInformation done");

    return;
}

DWORD
DwPppSetCustomAuthData(RASCONNCB *prasconncb)
{
    DWORD retcode = SUCCESS;
    PBYTE pbBuffer = NULL;
    DWORD dwSize = 0;

    //
    // Get the connectiondata thats stashed away
    // in rasman
    //
    retcode = RasGetPortUserData(
                    prasconncb->hport,
                    PORT_CUSTOMAUTHDATA_INDEX,
                    NULL,
                    &dwSize);

    if(ERROR_BUFFER_TOO_SMALL != retcode)
    {
        goto done;
    }

    pbBuffer = Malloc(dwSize);

    if(NULL == pbBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    retcode = RasGetPortUserData(
                    prasconncb->hport,
                    PORT_CUSTOMAUTHDATA_INDEX,
                    pbBuffer,
                    &dwSize);

    if(SUCCESS != retcode)
    {
        goto done;
    }

    /*
    //
    // Free previous custom auth stuff if we have it.
    //
    Free0(prasconncb->pEntry->pCustomAuthData);
    

    //
    // Save the customauthdata
    //
    prasconncb->pEntry->cbCustomAuthData = dwSize;
    prasconncb->pEntry->pCustomAuthData = pbBuffer;
    */

    retcode = DwSetCustomAuthData(
            prasconncb->pEntry,
            dwSize,
            pbBuffer);

    if(ERROR_SUCCESS != retcode)
    {
        goto done;
    }

    prasconncb->pEntry->fDirty = TRUE;

done:
    //
    // .Net bug# 508336 Memory leak in file rasdial.c, function
    // DwPppSetCustomAuthData
    //
    if (pbBuffer)
    {
        Free(pbBuffer);
    }
    return retcode;
}

VOID
UpdateCachedCredentials(IN RASCONNCB* prasconncb)
{
    //
    //  Make sure we have a non-NULL pointer and that
    //  we are not operating at WinLogon (which the UPM_Logon
    //  signifies).
    //
    if (prasconncb  && (prasconncb->dwUserPrefMode != UPM_Logon))
    {
        DWORD dwIgnoredErr = 0;
        CHAR szUserNameA[UNLEN + 1] = {0};
        CHAR szPasswordA[PWLEN + 1] = {0};
        CHAR szDomainA[2* (DNLEN + 1)] = {0};

        RASAPI32_TRACE("RasSetCachedCredentials...");


        strncpyTtoAAnsi(
            szUserNameA,
            prasconncb->rasdialparams.szUserName,
            sizeof(szUserNameA));

            
        SafeDecodePasswordBuf(
            prasconncb->rasdialparams.szPassword
            );

        strncpyTtoAAnsi(
            szPasswordA,
            prasconncb->rasdialparams.szPassword,
            sizeof(szPasswordA));

        SafeEncodePasswordBuf   (
            prasconncb->rasdialparams.szPassword
            );
            
        strncpyTtoAAnsi(
            szDomainA,
            prasconncb->rasdialparams.szDomain,
            sizeof(szDomainA));

        dwIgnoredErr = g_pRasSetCachedCredentials(
            szUserNameA,
            szDomainA,
            szPasswordA);

        SafeWipePasswordBuf(szPasswordA);
        
        RASAPI32_TRACE1("RasSetCachedCredentials done($%x)",
               dwIgnoredErr);

        prasconncb->fUpdateCachedCredentials = FALSE;
    }
}

RASCONNSTATE
RasDialMachine(
    IN RASCONNSTATE rasconnstate,
    IN RASCONNCB*   prasconncb,
    IN HANDLE       hEventAuto,
    IN HANDLE       hEventManual )

/*++

Routine Description:

        Executes 'rasconnstate'.  This routine always results
        in a "done" event on completion of each state, either
        directly (before returning) or by passing off the
        event to an asynchronous RAS Manager call.


Arguments:

        prasconncb - is the address of the control block.

        hEventAuto - is the auto-reset "done" event for passing
                     to asynchronous RAS Manager and Auth calls.

        hEventManual - is the manual-reset "done" event for
                       passing to asynchronous RasPpp calls.

Return Value:

        Returns the state that will be entered when/if the
        "done" event occurs and indicates success.

--*/

{
    DWORD        dwErr = 0;

    DWORD        dwExtErr = 0;

    BOOL         fAsyncState = FALSE;

    PBENTRY      *pEntry = prasconncb->pEntry;

    RASCONNSTATE rasconnstateNext = 0;

    RAS_CONNECTIONPARAMS params;

    BOOL         fEnteredCS = FALSE;

    switch (rasconnstate)
    {
        case RASCS_OpenPort:
        {
            RASAPI32_TRACE("RASCS_OpenPort");

            //
            // At this point, the current line in the HRASFILE
            // is assumed to be the section header of the
            // selected entry (or fDefaultEntry is true).
            // Set the domain parameter to the one in the
            // phonebook if caller does not specify a
            // domain or specifies "*".
            //
            if (    !prasconncb->fDefaultEntry
                &&  (   prasconncb->rasdialparams.szDomain[0]
                        == TEXT(' ')
                    ||  prasconncb->rasdialparams.szDomain[0]
                        == TEXT('*')))
            {
                lstrcpyn(prasconncb->rasdialparams.szDomain,
                         prasconncb->szDomain,
                         sizeof(prasconncb->rasdialparams.szDomain) /
                            sizeof(WCHAR));
            }

            //
            // check to see if the connection has already been
            // hung. If so then rasdialmachine is trying to dial a
            // connection which has already been hung. bail.
            //
            EnterCriticalSection(&csStopLock);

            fEnteredCS = TRUE;

            if (prasconncb->fTerminated)
            {
                dwErr = ERROR_PORT_NOT_AVAILABLE;

                RASAPI32_TRACE1(
                    "RasdialMachine: Trying to connect a "
                    "terminated connection!!. dwErr = %d",
                     dwErr);

                break;
            }

            //
            // Open the port including "any port" cases.
            //
            if ((dwErr = DwOpenPort(prasconncb)) != 0)
            {
                //
                // Copy the saved error if we couldn't open
                // the port
                //
                if(     ERROR_PORT_NOT_AVAILABLE == dwErr
                    &&  ERROR_SUCCESS != prasconncb->dwSavedError)
                {
                    dwErr = prasconncb->dwSavedError;
                    prasconncb->dwError = dwErr;
                }

                break;
             }

            //
            // Save the dialparamsuid with the port so that
            // rasman can get the password if required to
            // pass to ppp
            //
            RASAPI32_TRACE1("RasSetPortUserData(dialparamsuid) for %d",
                    prasconncb->hport);

            dwErr = RasSetPortUserData(
                prasconncb->hport,
                PORT_DIALPARAMSUID_INDEX,
                (PBYTE) &prasconncb->pEntry->dwDialParamsUID,
                sizeof(DWORD));

            RASAPI32_TRACE1("RasSetPortUserData returned %x", dwErr);
             

            //
            // Enable rasman events for this port.
            //
            if ((dwErr = EnableAsyncMachine(
                           prasconncb->hport,
                           &prasconncb->asyncmachine,
                           ASYNC_ENABLE_ALL)) != 0)
            {
                break;
            }

            //
            //Set the media parameters.
            //
            if ((dwErr = SetMediaParams(prasconncb)) != 0)
            {
                break;
            }

            //
            // Set the connection parameters for
            // bandwidth-on-demand, idle disconnect,
            // and redial-on-link-failure in rasman.
            //
            dwErr = ReadConnectionParamsFromEntry(prasconncb,
                                                  &params);
            if (dwErr)
            {
                break;
            }

            RASAPI32_TRACE("RasSetConnectionParams...");

            dwErr = g_pRasSetConnectionParams(prasconncb->hrasconn,
                                              &params);


            if (dwErr)
            {
                /*
                DWORD dwSavedErr = dwErr;

                //
                // It is possible we can fail the
                // RasSetConnectionParams call because
                // the caller has invoked RasHangUp in
                // another thread.  If this happens,
                // then neither the RasHangUp invoked
                // by the caller or the subsequent call
                // to RasDestroyConnection in
                // RasDialCleanUp will close
                // the port.  We close the
                // port here.
                //
                RASAPI32_TRACE1("RasPortClose(%d)...", prasconncb->hport);

                dwErr = g_pRasPortClose(prasconncb->hport);

                RASAPI32_TRACE1("RasPortClose(%d)", dwErr);

                //
                // Set dwErr back to the original error.
                //
                dwErr = dwSavedErr;

                */

                RASAPI32_TRACE1("RasSetConnectionParams(%d)", dwErr);

                break;

            }
            RASAPI32_TRACE1("RasSetConnectionParams(%d)", dwErr);

            //
            // Associate the port with the new connection
            // in rasman.
            //
            RASAPI32_TRACE2(
              "RasAddConnectionPort(%S,%d)...",
              prasconncb->szUserKey,
              prasconncb->rasdialparams.dwSubEntry);

            dwErr = g_pRasAddConnectionPort(
                      prasconncb->hrasconn,
                      prasconncb->hport,
                      prasconncb->rasdialparams.dwSubEntry);

            RASAPI32_TRACE1("RasAddConnectionPort(%d)", dwErr);

            if (dwErr)
            {
                break;
            }

            rasconnstateNext = RASCS_PortOpened;

            break;
        }

        case RASCS_PortOpened:
        {
            RASAPI32_TRACE("RASCS_PortOpened");

            //
            // Construct the phone number here so it
            // is available in the RASCS_ConnectDevice
            // state.
            //
            dwErr = ConstructPhoneNumber(prasconncb);
            if (dwErr)
            {
                break;
            }

            //
            // Loop connecting devices until there
            // are no more left.
            //
            rasconnstateNext =
                (   (prasconncb->fDefaultEntry
                ||  FindNextDevice(prasconncb)))
                    ? RASCS_ConnectDevice
                    : RASCS_AllDevicesConnected;
            break;
        }

        case RASCS_ConnectDevice:
        {
            TCHAR szType[ RAS_MAXLINEBUFLEN + 1 ];
            TCHAR szName[ RAS_MAXLINEBUFLEN + 1 ];
            BOOL fTerminal = FALSE;

            RASAPI32_TRACE("RASCS_ConnectDevice");

            if(     (prasconncb->pEntry->dwType == RASET_Vpn)
                &&  (0 == prasconncb->cAddresses))
            {
                CHAR *pszPhoneNumberA =
                        strdupTtoA(prasconncb->szPhoneNumber);
                        
                struct in_addr addr;

                if(NULL == pszPhoneNumberA)
                {
                    dwErr = E_OUTOFMEMORY;
                    break;
                }

                if(-1 == inet_addr(pszPhoneNumberA))
                {
                    _strlwr(pszPhoneNumberA);
                    RasSetAddressDisable(prasconncb->szPhoneNumber,
                                       TRUE);
                    
                    dwErr = DwRasGetHostByName(
                                pszPhoneNumberA,
                                &prasconncb->pAddresses,
                                &prasconncb->cAddresses);
                    
                    RasSetAddressDisable(prasconncb->szPhoneNumber,
                                       FALSE);

                    if(ERROR_SUCCESS != dwErr)
                    {
                        Free0(pszPhoneNumberA);
                        break;
                    }

                    prasconncb->iAddress = 1;                        
                    
                    RASAPI32_TRACE2("DwRasGetHostByName returned"
                        " cAddresses=%d for %ws",
                        prasconncb->cAddresses,
                        prasconncb->szPhoneNumber);

                }
                else
                {
                    prasconncb->pAddresses = LocalAlloc(LPTR, sizeof(DWORD));
                    if(NULL == prasconncb->pAddresses)
                    {
                        dwErr = GetLastError();

                        RASAPI32_TRACE1("Failed to allocate pAddresses. 0x%x",
                                dwErr);
                        //
                        // .Net bug# 508337 Memory leak in error return paths
                        // in function RasDialMachine, file rasdial.c
                        //
                        Free0(pszPhoneNumberA);
                        break;
                    }

                    *prasconncb->pAddresses = inet_addr(pszPhoneNumberA);
                    prasconncb->cAddresses = 1;
                    prasconncb->iAddress = 1;
                    prasconncb->iAddress = 1;
                }

                Free0(pszPhoneNumberA);
            }

            //
            // Set device parameters for the device currently
            // connecting based on device subsection entries
            // and/or passed API parameters.
            //
            if (prasconncb->fDefaultEntry)
            {
                if ((dwErr =
                    SetDefaultDeviceParams(prasconncb,
                                           szType, szName )) != 0)
                {
                    break;
                }
            }
            else
            {
                if (    (dwErr = SetDeviceParams(
                            prasconncb, szType,
                            szName, &fTerminal )) != 0
                    &&  dwErr != ERROR_DEVICENAME_NOT_FOUND)
                {
                    break;
                }

                RASAPI32_TRACE3(
                  "SetDeviceParams(%S, %S, %d)",
                  szType,
                  szName,
                  fTerminal);

            }

            if (CaseInsensitiveMatch(szType, TEXT(MXS_MODEM_TXT)) == TRUE)
            {
                //
                // For modem's, get the callback delay from RAS
                // Manager and store in control block for use by
                // Authentication.
                //
                CHAR szTypeA[RAS_MaxDeviceType + 1];
                CHAR szNameA[RAS_MaxDeviceName + 1];
                CHAR* pszValue = NULL;
                LONG  lDelay = -1;

                strncpyTtoA(szTypeA, szType, sizeof(szTypeA));

                strncpyTtoA(szNameA, szName, sizeof(szNameA));

                if (GetRasDeviceString(
                            prasconncb->hport,
                            szTypeA, szNameA,
                            MXS_CALLBACKTIME_KEY,
                            &pszValue, XLATE_None ) == 0)
                {
                    lDelay = atol( pszValue );
                    Free( pszValue );
                }

                if (lDelay > 0)
                {
                    prasconncb->fUseCallbackDelay = TRUE;
                    prasconncb->wCallbackDelay = (WORD )lDelay;
                }

                prasconncb->fModem = TRUE;
            }
            else if (CaseInsensitiveMatch(szType, TEXT(ISDN_TXT)) == TRUE)
            {
                //
                // Need to know this for the PppThenAmb down-level
                // ISDN case.
                //
                prasconncb->fIsdn = TRUE;
                prasconncb->fUseCallbackDelay = TRUE;
                prasconncb->wCallbackDelay = 10;
            }

            //
            // The special switch name, "Terminal", sends the user
            // into interactive mode.
            //
            if (    (fTerminal)
                &&  (   (prasconncb->pEntry->dwCustomScript != 1)
                    ||  (!prasconncb->fUseCustomScripting)))
            {
                if (prasconncb->fAllowPause)
                {
                    rasconnstateNext = RASCS_Interactive;
                }
                else
                {
                    dwErr = ERROR_INTERACTIVE_MODE;
                }

                break;
            }

            //
            // Enable ipsec on the tunnel if its l2tp and
            // requires encryption
            //
            if(     (RASET_Vpn == prasconncb->pEntry->dwType)
                //&&  (prasconncb->pEntry->dwDataEncryption != DE_None)
                &&  (prasconncb->dwCurrentVpnProt < NUMVPNPROTS)
                &&  (RDT_Tunnel_L2tp == prasconncb->ardtVpnProts[
                                    prasconncb->dwCurrentVpnProt]))
            {
                DWORD dwStatus = ERROR_SUCCESS;
                RAS_L2TP_ENCRYPTION eDataEncryption = 0;
                
                if(DE_Require == 
                        prasconncb->pEntry->dwDataEncryption)
                {
                    eDataEncryption = RAS_L2TP_REQUIRE_ENCRYPTION;
                }
                else if (DE_RequireMax == 
                            prasconncb->pEntry->dwDataEncryption)
                {
                    eDataEncryption = RAS_L2TP_REQUIRE_MAX_ENCRYPTION;
                }
                else if(DE_IfPossible == 
                            prasconncb->pEntry->dwDataEncryption)
                {
                    eDataEncryption = RAS_L2TP_OPTIONAL_ENCRYPTION;
                }
                else if(DE_None ==
                            prasconncb->pEntry->dwDataEncryption)
                {
                    eDataEncryption = RAS_L2TP_NO_ENCRYPTION;
                }
                else
                {
                    ASSERT(FALSE);
                }

                //
                // Make the uid available to user so that
                // Presharedkey can be retrieved if required.
                //
                dwErr = RasSetPortUserData(
                    prasconncb->hport,
                    PORT_DIALPARAMSUID_INDEX,
                    (PBYTE) &prasconncb->pEntry->dwDialParamsUID,
                    sizeof(DWORD));
        
                RASAPI32_TRACE1("RasEnableIpSec(%d)..",
                        prasconncb->hport);

                dwErr = g_pRasEnableIpSec(prasconncb->hport,
                                          TRUE,
                                          FALSE,
                                          eDataEncryption);

                RASAPI32_TRACE1("RasEnableIpSec done. %d",
                       dwErr);

                if(     (ERROR_SUCCESS != dwErr)
                    &&  (eDataEncryption != RAS_L2TP_OPTIONAL_ENCRYPTION)
                    &&  (eDataEncryption != RAS_L2TP_NO_ENCRYPTION))
                {
                    break;
                }
                else
                {
                    //
                    // We ignore the error if its optional encryption and
                    // attempt to bring up the l2tp tunnel
                    //
                    dwErr = ERROR_SUCCESS;
                    
                }

                //
                // Do Ike now before we hit l2tp with a linemakecall
                //
                RASAPI32_TRACE1("RasDoIke on hport %d...", prasconncb->hport);
                dwErr = RasDoIke(NULL, prasconncb->hport, &dwStatus);
                RASAPI32_TRACE2("RasDoIke done. Err=0x%x, Status=0x%x",
                       dwErr,
                       dwStatus);

                if(ERROR_SUCCESS == dwErr)
                {
                    dwErr = dwStatus;
                }

                if(ERROR_SUCCESS != dwErr)
                {
                    break;
                }

                /*
                if(     (ERROR_SUCCESS != dwErr)
                    &&  (eDataEncryption != RAS_L2TP_OPTIONAL_ENCRYPTION)
                    &&  (eDataEncryption != RAS_L2TP_NO_ENCRYPTION))
                {
                    break;
                }
                else
                {
                    //
                    // We ignore the error if its optional encryption and
                    // attempt to bring up the l2tp tunnel
                    //
                    dwErr = ERROR_SUCCESS;
                    
                }
                */
            }

            RASAPI32_TRACE2("RasDeviceConnect(%S,%S)...",
                   szType,
                   szName);

            {
                CHAR szTypeA[RAS_MaxDeviceType + 1];
                CHAR szNameA[RAS_MaxDeviceName + 1];

                strncpyTtoA(szTypeA, szType, sizeof(szTypeA));
                strncpyTtoA(szNameA, szName, sizeof(szNameA));
                dwErr = g_pRasDeviceConnect(
                            prasconncb->hport,
                            szTypeA,
                            szNameA,
                            SECS_ConnectTimeout,
                            hEventAuto );
            }

            RASAPI32_TRACE1("RasDeviceConnect done(%d)",
                   dwErr);

            //
            // Mark this as an async operation only if
            // RasDeviceConnect returns PENDING
            //
            if (PENDING == dwErr)
            {
                fAsyncState = TRUE;
            }

            //
            // If RASMAN couldn't find the device and it is a
            // switch device and the name of the switch is an
            // existing disk-file, assume it is a dial-up script.
            //
            if (    (    (dwErr == ERROR_DEVICENAME_NOT_FOUND)
                    &&  (CaseInsensitiveMatch(
                            szType,
                            TEXT(MXS_SWITCH_TXT)) == TRUE)
                    &&  ((GetFileAttributes(szName) != 0xFFFFFFFF)
                    ||  (prasconncb->fUseCustomScripting))))
            {
                //
                // This is a switch device which RASMAN didn't
                // recognize, and which points to a valid
                // filename. It might be a Dial-Up script,
                // so we process it here
                //

                dwErr = NO_ERROR;
                fAsyncState = FALSE;


                if(     (1 == prasconncb->pEntry->dwCustomScript)
                    &&  (prasconncb->fUseCustomScripting))
                {
                    //
                    // Caller wants to run the custom script for this
                    // entry. Make the call out. Decode the password
                    // we stored before making the call out.
                    //
                    SafeDecodePasswordBuf(
                        prasconncb->rasdialparams.szPassword);
                        
                    dwErr = DwCustomTerminalDlg(
                                prasconncb->pbfile.pszPath,
                                prasconncb->hrasconn,
                                prasconncb->pEntry,
                                prasconncb->hwndParent,
                                &prasconncb->rasdialparams,
                                NULL);

                    SafeEncodePasswordBuf(
                        prasconncb->rasdialparams.szPassword);

                }
                else if(1 == prasconncb->pEntry->dwCustomScript)
                {
                    dwErr = ERROR_INTERACTIVE_MODE;
                    break;
                }
                
                //
                // If the caller doesn't allow pauses or doesn't
                // want to pause when a script is encountered,
                // handle the script; Otherwise, let the caller
                // process the script.
                //
                else if (    !prasconncb->fAllowPause
                    ||  !prasconncb->fPauseOnScript
                    ||  !fTerminal)
                {
                    //
                    // Caller won't handle script, run it ourselves
                    // and go into "DeviceConnected" mode
                    //

                    CHAR szIpAddress[17] = "";
                    CHAR szUserName[UNLEN+1], szPassword[PWLEN+1];

                    RASDIALPARAMS* pparams =
                                    &prasconncb->rasdialparams;

                    strncpyTtoAAnsi(
                        szUserName,
                        pparams->szUserName,
                        sizeof(szUserName));

                        
                    SafeDecodePasswordBuf(  pparams->szPassword);
                    strncpyTtoAAnsi(
                        szPassword,
                        pparams->szPassword,
                        sizeof(szPassword));
                    SafeEncodePasswordBuf(pparams->szPassword);

                    //
                    // Run the script
                    //
                    dwErr = RasScriptExecute(
                                (HRASCONN)prasconncb->hrasconn,
                                prasconncb->pEntry, szUserName,
                                szPassword, szIpAddress);

                    //Zero out the password buffer
                    RtlSecureZeroMemory(szPassword, sizeof(szPassword));
                    
                    if (    dwErr == NO_ERROR
                        &&  szIpAddress[0])
                    {
                        Free0(prasconncb->pEntry->pszIpAddress);
                        prasconncb->pEntry->pszIpAddress =
                            strdupAtoT(szIpAddress);
                    }
                }
                else
                {
                    //
                    // Caller will handle script, go into
                    // interactive mode
                    //
                    rasconnstateNext = RASCS_Interactive;
                    break;
                }
            }
            else if (    dwErr != 0
                     &&  dwErr != PENDING)
            {
                break;
            }

            rasconnstateNext = RASCS_DeviceConnected;
            break;
        }

        case RASCS_DeviceConnected:
        {
            RASAPI32_TRACE("RASCS_DeviceConnected");

            //
            // Turn off hunt group functionality.
            //
            prasconncb->dwRestartOnError = 0;
            prasconncb->cPhoneNumbers = 0;

            //
            // Get the modem connect response and stash it in the
            // RASMAN user data.
            //
            if (prasconncb->fModem)
            {
                CHAR szTypeA[RAS_MaxDeviceType + 1],
                     szNameA[RAS_MaxDeviceName + 1];
                CHAR* psz = NULL;

                //
                // Assumption is made here that a modem will never
                // appear in the device chain unless it is the
                // physically attached device (excluding switches).
                //
                strncpyTtoA(szTypeA, prasconncb->szDeviceType, sizeof(szTypeA));

                strncpyTtoA(szNameA, prasconncb->szDeviceName, sizeof(szNameA));

                GetRasDeviceString(
                  prasconncb->hport,
                  szTypeA,
                  szNameA,
                  MXS_MESSAGE_KEY,
                  &psz,
                  XLATE_ErrorResponse );

                if (psz)
                {
                    dwErr = g_pRasSetPortUserData(
                              prasconncb->hport,
                              PORT_CONNRESPONSE_INDEX,
                              psz,
                              strlen(psz) + 1);

                    Free( psz );

                    if (dwErr)
                        break;
                }

                prasconncb->fModem = FALSE;
            }

            if(     (RASET_Vpn == prasconncb->pEntry->dwType)
                &&  (prasconncb->dwCurrentVpnProt < NUMVPNPROTS))
            {
                SaveVpnStrategyInformation(prasconncb);
            }

            rasconnstateNext =
                    (   !prasconncb->fDefaultEntry
                    &&  FindNextDevice(prasconncb))
                        ? RASCS_ConnectDevice
                        : RASCS_AllDevicesConnected;
            break;
        }

        case RASCS_AllDevicesConnected:
        {
            RASAPI32_TRACE("RASCS_AllDevicesConnected");

            RASAPI32_TRACE("RasPortConnectComplete...");

            dwErr = g_pRasPortConnectComplete(prasconncb->hport);

            RASAPI32_TRACE1("RasPortConnectComplete done(%d)", dwErr);

            if (dwErr != 0)
            {
                break;
            }

            {
                TCHAR* pszIpAddress = NULL;
                BOOL   fHeaderCompression = FALSE;
                BOOL   fPrioritizeRemote = TRUE;
                DWORD  dwFrameSize = 0;

                //
                // Scan the phonebook entry to see if this is a
                // SLIP entry and, if so, read the SLIP-related
                // fields.
                //
                if ((dwErr = ReadSlipInfoFromEntry(
                        prasconncb,
                        &pszIpAddress,
                        &fHeaderCompression,
                        &fPrioritizeRemote,
                        &dwFrameSize )) != 0)
                {
                    break;
                }

                if (pszIpAddress)
                {
                    //
                    // It's a SLIP entry.  Set framing based on
                    // user's choice of header compression.
                    //
                    RASAPI32_TRACE1(
                      "RasPortSetFraming(f=%d)...",
                      fHeaderCompression);

                    dwErr = g_pRasPortSetFraming(
                        prasconncb->hport,
                        (fHeaderCompression)
                        ? SLIPCOMP
                        : SLIPCOMPAUTO,
                        NULL, NULL );

                    RASAPI32_TRACE1("RasPortSetFraming done(%d)", dwErr);

                    if (dwErr != 0)
                    {
                        Free( pszIpAddress );
                        break;
                    }

                    //
                    // Tell the TCP/IP components about the SLIP
                    // connection, and activate the route.
                    //
                    dwErr = RouteSlip(
                        prasconncb, pszIpAddress,
                        fPrioritizeRemote,
                        dwFrameSize );

                    if (dwErr)
                    {
                        Free(pszIpAddress);
                        break;
                    }

                    //
                    // Update the projection information.
                    //
                    prasconncb->SlipProjection.dwError = 0;
                    lstrcpyn(
                        prasconncb->SlipProjection.szIpAddress,
                        pszIpAddress,
                        sizeof(prasconncb->SlipProjection.szIpAddress) /
                            sizeof(WCHAR));

                    Free( pszIpAddress );

                    if (dwErr != 0)
                    {
                        break;
                    }

                    //
                    // Copy the IP address into the SLIP
                    // projection results structure.
                    //
                    memset( &prasconncb->PppProjection,
                        '\0', sizeof(prasconncb->PppProjection) );

                    prasconncb->PppProjection.nbf.dwError =
                        prasconncb->PppProjection.ipx.dwError =
                        prasconncb->PppProjection.ip.dwError =
                            ERROR_PPP_NO_PROTOCOLS_CONFIGURED;

                    prasconncb->AmbProjection.Result =
                        ERROR_PROTOCOL_NOT_CONFIGURED;

                    prasconncb->AmbProjection.achName[ 0 ] = '\0';

                    RASAPI32_TRACE("SaveProjectionResults...");
                    dwErr = SaveProjectionResults(prasconncb);
                    RASAPI32_TRACE1("SaveProjectionResults(%d)", dwErr);

                    rasconnstateNext = RASCS_Connected;

                    Sleep(5);

                    break;
                }
            }

            rasconnstateNext = RASCS_Authenticate;
            break;
        }

        case RASCS_Authenticate:
        {
            RASDIALPARAMS* prasdialparams = &prasconncb->rasdialparams;
            LUID luid;

            RASAPI32_TRACE("RASCS_Authenticate");

            if (prasconncb->fPppMode)
            {
                RAS_FRAMING_INFO finfo;
                DWORD dwCallbackMode = 0;
                
                //
                // Set PPP framing.
                //
                memset((char* )&finfo, '\0', sizeof(finfo));

                finfo.RFI_SendACCM = finfo.RFI_RecvACCM =
                                                0xFFFFFFFF;

                finfo.RFI_MaxRSendFrameSize =
                    finfo.RFI_MaxRRecvFrameSize = 1600;

                finfo.RFI_SendFramingBits =
                    finfo.RFI_RecvFramingBits = PPP_FRAMING;

                RASAPI32_TRACE("RasPortSetFramingEx(PPP)...");

                dwErr = g_pRasPortSetFramingEx(prasconncb->hport, &finfo);

                RASAPI32_TRACE1("RasPortSetFramingEx done(%d)", dwErr);

                if (dwErr != 0)
                {
                    break;
                }

                //
                // If we are dialing simultaneous subentries,
                // then we have to synchronize the other subentries
                // with the first subentry to call PppStart.  This
                // is because if there is an authentication retry,
                // we only want the first subentry to get the
                // new credentials, allowing the other subentries
                // to bypass this state and use the new credentials
                // the first time around.
                //
                RASAPI32_TRACE2(
                  "subentry %d has suspend state %d",
                  prasconncb->rasdialparams.dwSubEntry,
                  prasconncb->dwfSuspended);

                if(prasconncb->dwfSuspended == SUSPEND_InProgress)
                {
                    RASAPI32_TRACE1(
                        "subentry %d waiting for authentication",
                        prasconncb->rasdialparams.dwSubEntry);
                        SuspendAsyncMachine(&prasconncb->asyncmachine,
                        TRUE);

                    //
                    // Set the next state to be equivalent
                    // to the current state, and don't let
                    // the client's notifier to be informed.
                    //
                    fAsyncState = TRUE;

                    rasconnstateNext = rasconnstate;
                    break;
                }
                else if (prasconncb->dwfSuspended == SUSPEND_Start)
                {
                    RASAPI32_TRACE1(
                      "subentry %d suspending all other subentries",
                      prasconncb->rasdialparams.dwSubEntry);
                    SuspendSubentries(prasconncb);

                    //
                    // Set this subentry as the master.  It
                    // will be the only subentry to do PPP
                    // authentication while the other subentries
                    // are suspended.
                    prasconncb->fMaster = TRUE;

                    prasconncb->dwfSuspended = SUSPEND_Master;
                }

                //
                // Start PPP authentication.
                // Fill in configuration parameters.
                //
                prasconncb->cinfo.dwConfigMask = 0;
                if (prasconncb->fUseCallbackDelay)
                {
                    prasconncb->cinfo.dwConfigMask
                        |= PPPCFG_UseCallbackDelay;
                }

                if (!prasconncb->fDisableSwCompression)
                {
                    prasconncb->cinfo.dwConfigMask
                        |= PPPCFG_UseSwCompression;
                }

                if (prasconncb->dwfPppProtocols & NP_Nbf)
                {
                    prasconncb->cinfo.dwConfigMask
                        |= PPPCFG_ProjectNbf;
                }

                if (prasconncb->dwfPppProtocols & NP_Ipx)
                {
                    prasconncb->cinfo.dwConfigMask
                        |= PPPCFG_ProjectIpx;
                }

                if (prasconncb->dwfPppProtocols & NP_Ip)
                {
                    prasconncb->cinfo.dwConfigMask
                        |= PPPCFG_ProjectIp;
                }

                //
                // [pmay] derive auth restrictions based on new flags
                //
                if (  prasconncb->pEntry->dwAuthRestrictions
                    & AR_F_AuthPAP)
                {
                    prasconncb->cinfo.dwConfigMask |=
                                PPPCFG_NegotiatePAP;
                }

                if (  prasconncb->pEntry->dwAuthRestrictions
                    & AR_F_AuthSPAP)
                {
                    prasconncb->cinfo.dwConfigMask |=
                                PPPCFG_NegotiateSPAP;
                }

                if (  prasconncb->pEntry->dwAuthRestrictions
                    & AR_F_AuthMD5CHAP)
                {
                    prasconncb->cinfo.dwConfigMask |=
                                PPPCFG_NegotiateMD5CHAP;
                }

                if (  prasconncb->pEntry->dwAuthRestrictions
                    & AR_F_AuthMSCHAP)
                {
                    prasconncb->cinfo.dwConfigMask |=
                                PPPCFG_NegotiateMSCHAP;
                }

                if (  prasconncb->pEntry->dwAuthRestrictions
                    & AR_F_AuthMSCHAP2)
                {
                    prasconncb->cinfo.dwConfigMask |=
                                PPPCFG_NegotiateStrongMSCHAP;
                }

                if ( prasconncb->pEntry->dwAuthRestrictions
                    & AR_F_AuthW95MSCHAP)
                {
                    prasconncb->cinfo.dwConfigMask |=
                                ( PPPCFG_UseLmPassword
                                | PPPCFG_NegotiateMSCHAP) ;
                }
                    

                if (  prasconncb->pEntry->dwAuthRestrictions
                    & AR_F_AuthEAP)
                {
                    prasconncb->cinfo.dwConfigMask |=
                                PPPCFG_NegotiateEAP;
                }

                if (DE_Require == prasconncb->pEntry->dwDataEncryption)
                {
                    if(     (RASET_Vpn != prasconncb->pEntry->dwType)
                        ||  (prasconncb->dwCurrentVpnProt < NUMVPNPROTS))
                    {                                            
                        prasconncb->cinfo.dwConfigMask
                            |= (  PPPCFG_RequireEncryption 
                                | PPPCFG_RequireStrongEncryption);
                    }                                
                                
                }
                else if (DE_RequireMax == prasconncb->pEntry->dwDataEncryption)
                {
                    if(     (RASET_Vpn != prasconncb->pEntry->dwType)
                        ||  (prasconncb->dwCurrentVpnProt < NUMVPNPROTS))
                    {                                            
                        prasconncb->cinfo.dwConfigMask 
                            |= PPPCFG_RequireStrongEncryption;
                    }
                }
                else if(DE_IfPossible == prasconncb->pEntry->dwDataEncryption)
                {
                    prasconncb->cinfo.dwConfigMask
                        &= ~(  PPPCFG_RequireEncryption
                             | PPPCFG_RequireStrongEncryption
                             | PPPCFG_DisableEncryption);
                }
                else if(prasconncb->pEntry->dwDataEncryption == DE_None)
                {
                    prasconncb->cinfo.dwConfigMask
                        |= PPPCFG_DisableEncryption;
                }

                if (prasconncb->fLcpExtensions)
                {
                    prasconncb->cinfo.dwConfigMask
                        |= PPPCFG_UseLcpExtensions;
                }

                if (   prasconncb->fMultilink
                    || prasconncb->pEntry->fNegotiateMultilinkAlways)
                {
                    prasconncb->cinfo.dwConfigMask
                        |= PPPCFG_NegotiateMultilink;
                }

                if (prasconncb->pEntry->fAuthenticateServer)
                {
                    prasconncb->cinfo.dwConfigMask
                        |= PPPCFG_AuthenticatePeer;
                }

                //
                // Set no bits if IfPossible
                //
                /*
                if(prasconncb->pEntry->dwDataEncryption == DE_IfPossible)
                {
                }

                */

                if(RASEDM_DialAsNeeded == prasconncb->pEntry->dwDialMode)
                {
                    if(DtlGetNodes(prasconncb->pEntry->pdtllistLinks) > 1)
                    {
                        prasconncb->cinfo.dwConfigMask
                            |= PPPCFG_NegotiateBacp;
                    }
                }

                if (prasconncb->pEntry->dwfOverridePref 
                    & RASOR_CallbackMode)
                {
                    dwCallbackMode = prasconncb->pEntry->dwCallbackMode;
                }
                else
                {
                    PBUSER pbuser;
                    
                    //
                    // Retrieve this from the user prefs
                    //
                    dwErr = g_pGetUserPreferences(
                                        NULL, 
                                        &pbuser, 
                                        prasconncb->dwUserPrefMode);

                    if(ERROR_SUCCESS != dwErr)
                    {   
                        RASAPI32_TRACE1("GetUserPrefs failed. rc=0x%x",
                               dwErr);

                        break;                               
                    }

                    dwCallbackMode = pbuser.dwCallbackMode;
                    
                    DestroyUserPreferences(&pbuser);
                }
                
                if (CBM_No == dwCallbackMode)
                {
                    prasconncb->cinfo.dwConfigMask
                            |= PPPCFG_NoCallback;
                }

                prasconncb->cinfo.dwCallbackDelay = 
                    (DWORD )prasconncb->wCallbackDelay;


                dwErr = ComputeLuid(&luid);

                if(*prasdialparams->szUserName == TEXT('\0'))
                {
                    if(ERROR_SUCCESS != dwErr)
                    {
                        break;
                    }

                    CopyMemory(&prasconncb->luid, &luid, sizeof(LUID));
                }

                if(ERROR_SUCCESS == dwErr)
                {
                    dwErr = g_pRasSetConnectionUserData(
                                prasconncb->hrasconn,
                                CONNECTION_LUID_INDEX,
                                (PBYTE) &luid,
                                sizeof(LUID));
                }
                
#if 0                
                //
                // Compute a luid for PPP if the
                // szUserName is NULL.
                //
                if (*prasdialparams->szUserName == TEXT('\0'))
                {
                    dwErr = ComputeLuid(&prasconncb->luid);

                    if (dwErr)
                    {
                        break;
                    }
                }

                //
                // Save the dialparamsuid with the port so that
                // rasman can get the password if required to
                // pass to ppp
                //
                RASAPI32_TRACE1("RasSetPortUserData(dialparamsuid) for %d",
                        prasconncb->hport);

                dwErr = RasSetPortUserData(
                    prasconncb->hport,
                    PORT_DIALPARAMSUID_INDEX,
                    (PBYTE) &prasconncb->pEntry->dwDialParamsUID,
                    sizeof(DWORD));

                RASAPI32_TRACE1("RasSetPortUserData returned %x", dwErr);

                //
                // This is not fatal.
                // 
                dwErr = 0;

#endif                
                /*

                if(     (RASET_Vpn == prasconncb->pEntry->dwType)
                    &&  (DE_Require ==
                        & prasconncb->pEntry->dwDataEncryption))
                {
                    prasconncb->cinfo.dwConfigMask |=
                            (   PPPCFG_RequireEncryption
                            |   PPPCFG_RequireStrongEncryption);
                }

                */

                RASAPI32_TRACE1(
                  "RasPppStart(cfg=%d)...",
                  prasconncb->cinfo.dwConfigMask);

                {
                    CHAR szUserNameA[UNLEN + 1],
                         szPasswordA[PWLEN + 1];

                    CHAR szDomainA[2 * (DNLEN + 1)];

                    CHAR szPortNameA[MAX_PORT_NAME + 1];

                    CHAR szPhonebookPath[ MAX_PATH ];

                    CHAR szEntryName[ MAX_ENTRYNAME_SIZE ];

                    CHAR szPhoneNumber[ RAS_MaxPhoneNumber + 1];

                    PPP_BAPPARAMS BapParams;

                    DWORD dwFlags = 0;

                    DWORD cbData = 0;
                    PBYTE pbData = NULL;

                    DWORD dwSubEntries;

                    //
                    // Set PhonebookPath and EntryName in rasman
                    //
                    strncpyTtoAAnsi(
                        szPhonebookPath,
                        prasconncb->pbfile.pszPath,
                        sizeof(szPhonebookPath));

                    strncpyTtoAAnsi(
                        szEntryName,
                        prasconncb->pEntry->pszEntryName,
                        sizeof(szEntryName));

                    strncpyTtoAAnsi(
                        szPhoneNumber,
                        prasconncb->szPhoneNumber,
                        sizeof(szPhoneNumber));

                    RASAPI32_TRACE1(
                        "RasSetRasdialInfo %d...",
                        prasconncb->hport);

                    dwErr = DwGetCustomAuthData(
                                prasconncb->pEntry,
                                &cbData,
                                &pbData);

                    if(ERROR_SUCCESS != dwErr)
                    {
                        RASAPI32_TRACE1("DwGetCustomAuthData failed. 0x%x",
                                dwErr);

                        break; 
                    }

                    dwErr = g_pRasSetRasdialInfo(
                            prasconncb->hport,
                            szPhonebookPath,
                            szEntryName,
                            szPhoneNumber,
                            cbData,
                            pbData);

                    RASAPI32_TRACE2("RasSetRasdialInfo %d done. e = %d",
                                prasconncb->hport, dwErr);

                    if (dwErr)
                    {
                        break;
                    }

                    if(     (prasconncb->pEntry->dwTcpWindowSize >= 0x1000)
                      &&   (prasconncb->pEntry->dwTcpWindowSize <= 0xFFFF))
                    {                      
                        //
                        // Save the tcp window size with rasman
                        //
                        dwErr = g_pRasSetConnectionUserData(
                                    prasconncb->hrasconn,
                                    CONNECTION_TCPWINDOWSIZE_INDEX,
                                    (PBYTE) &prasconncb->pEntry->dwTcpWindowSize,
                                    sizeof(DWORD));
                    }                                
                                

                    if(prasconncb->RasEapInfo.dwSizeofEapInfo)
                    {
                        RASAPI32_TRACE1("RasSetEapLogonInfo %d...",
                                prasconncb->hport);

                        dwErr = g_pRasSetEapLogonInfo(
                                prasconncb->hport,
                                (UPM_Logon == prasconncb->dwUserPrefMode),
                                &prasconncb->RasEapInfo);

                        RASAPI32_TRACE3("RasSetEapLogonInfo %d(upm=%d) done. e=%d",
                                prasconncb->hport,
                                prasconncb->dwUserPrefMode,
                                dwErr);
                    }

                    if(dwErr)
                    {
                        break;
                    }

                    
                    strncpyTtoAAnsi(
                        szUserNameA,
                        prasdialparams->szUserName,
                        sizeof(szUserNameA));


                   SafeDecodePasswordBuf(prasdialparams->szPassword);
                   strncpyTtoAAnsi(
                        szPasswordA,
                        prasdialparams->szPassword,
                        sizeof(szPasswordA));
                    SafeEncodePasswordBuf(prasdialparams->szPassword);

                    strncpyWtoAAnsi(
                        szDomainA,
                        prasdialparams->szDomain,
                        sizeof(szDomainA));

                    if (!pEntry->fAutoLogon
                        && szUserNameA[ 0 ] == '\0'
                        && szPasswordA[ 0 ] == '\0')
                    {
                        if(pEntry->dwType == RASET_Direct)
                        {
                            // Windows9x DCC implements "no password mode"
                            // as doing authentication and checking for 
                            // no password, rather than just not authenti
                            // cating (don't ask me why).  This creates a 
                            // conflict with the RasDial API definition of
                            // empty username and password mapping to "use
                            // Windows credentials".  Workaround that here
                            // by substituting "guest" for the username.
                            //
                            lstrcpynA(
                                szUserNameA,
                                "guest",
                                sizeof(szUserNameA));
                        }
                    }

                    strncpyTtoA(
                        szPortNameA,
                        prasconncb->szPortName,
                        sizeof(szPortNameA));

                    dwSubEntries =
                        DtlGetNodes(prasconncb->pEntry->pdtllistLinks);

                    if(dwSubEntries > 1)
                    {
                        BapParams.dwDialMode =
                            prasconncb->pEntry->dwDialMode;
                    }
                    else
                    {
                        BapParams.dwDialMode = RASEDM_DialAll;
                    }

                    BapParams.dwDialExtraPercent =
                              prasconncb->pEntry->dwDialPercent;

                    BapParams.dwDialExtraSampleSeconds =
                               prasconncb->pEntry->dwDialSeconds;

                    BapParams.dwHangUpExtraPercent =
                               prasconncb->pEntry->dwHangUpPercent;

                    BapParams.dwHangUpExtraSampleSeconds =
                               prasconncb->pEntry->dwHangUpSeconds;

                    if(     ((!prasconncb->pEntry->fShareMsFilePrint)
                         &&   (!prasconncb->pEntry->fBindMsNetClient))
                        ||  (prasconncb->pEntry->dwIpNbtFlags == 0)) 
                    {
                        dwFlags |= PPPFLAGS_DisableNetbt;
                    }

                    dwErr = g_pRasPppStart(
                          prasconncb->hport,
                          szPortNameA,
                          szUserNameA,
                          szPasswordA,
                          szDomainA,
                          &prasconncb->luid,
                          &prasconncb->cinfo,
                          (LPVOID)prasconncb->reserved,
                          prasconncb->szzPppParameters,
                          FALSE,
                          hEventManual,
                          prasconncb->dwIdleDisconnectSeconds,
                          (prasconncb->pEntry->fRedialOnLinkFailure)
                          ? TRUE : FALSE,
                          &BapParams,
                          !(prasconncb->fAllowPause),
                          prasconncb->pEntry->dwCustomAuthKey,
                          dwFlags);

                    //Wipe out the password buffer
                    RtlSecureZeroMemory(szPasswordA,sizeof(szPasswordA));
                }

                RASAPI32_TRACE1("RasPppStart done(%d)", dwErr);
            }
            else
            {
                AUTH_CONFIGURATION_INFO info;

                //
                // Set RAS framing.
                //
                RASAPI32_TRACE("RasPortSetFraming(RAS)...");

                dwErr = g_pRasPortSetFraming(
                    prasconncb->hport, RAS, NULL, NULL );

                RASAPI32_TRACE1("RasPortSetFraming done(%d)", dwErr);

                if (dwErr != 0)
                {
                    break;
                }

                //
                // Load rascauth.dll.
                //
                dwErr = LoadRasAuthDll();
                if (dwErr != 0)
                {
                    break;
                }

                //
                // Start AMB authentication.
                //
                info.Protocol = ASYBEUI;

                info.NetHandle = (DWORD )-1;

                info.fUseCallbackDelay =
                        prasconncb->fUseCallbackDelay;

                info.CallbackDelay =
                        prasconncb->wCallbackDelay;

                info.fUseSoftwareCompression =
                    !prasconncb->fDisableSwCompression;

                info.fForceDataEncryption =
                    prasconncb->fRequireEncryption;

                info.fProjectIp = FALSE;

                info.fProjectIpx = FALSE;

                info.fProjectNbf = TRUE;

                RASAPI32_TRACE("AuthStart...");

                {
                    CHAR szUserNameA[UNLEN + 1],
                         szPasswordA[PWLEN + 1];

                    CHAR szDomainA[2 * (DNLEN + 1)];


                    strncpyTtoAAnsi(
                        szUserNameA,
                        prasdialparams->szUserName,
                        sizeof(szUserNameA));

                    SafeDecodePasswordBuf(prasdialparams->szPassword);
                    strncpyTtoAAnsi(
                        szPasswordA,
                        prasdialparams->szPassword,
                        sizeof(szPasswordA));
                    SafeEncodePasswordBuf(prasdialparams->szPassword);

                    strncpyTtoAAnsi(
                        szDomainA,
                        prasdialparams->szDomain,
                        sizeof(szDomainA));

                    dwErr = g_pAuthStart(
                              prasconncb->hport,
                              szUserNameA,
                              szPasswordA,
                              szDomainA,
                              &info,
                              hEventAuto );

                    RtlSecureZeroMemory(szPasswordA,sizeof(szPasswordA));

                }

                RASAPI32_TRACE1("AuthStart done(%d)n", dwErr);

                //
                // In case we failed-over from PPP, make sure
                // the PPP event isn't set.
                //
                ResetEvent(hEventManual);
            }

            if (dwErr != 0)
            {
                break;
            }

            fAsyncState = TRUE;
            rasconnstateNext = RASCS_AuthNotify;
            break;
        }

        case RASCS_AuthNotify:
        {
            if (prasconncb->fPppMode)
            {
                PPP_MESSAGE msg;

                RASAPI32_TRACE("RASCS_AuthNotify");

                RASAPI32_TRACE("RasPppGetInfo...");

                dwErr = g_pRasPppGetInfo(prasconncb->hport, &msg);

                RASAPI32_TRACE2(
                  "RasPppGetInfo done(%d), dwMsgId=%d",
                  dwErr,
                  msg.dwMsgId);

                //
                // If we ever get an error from RasPppGetInfo,
                // it is fatal, and we should report the link
                // as disconnected.
                //
                if (dwErr != 0)
                {
                    RASAPI32_TRACE("RasPppGetInfo failed; terminating link");
                    dwErr = ERROR_REMOTE_DISCONNECTION;
                    break;
                }

                switch (msg.dwMsgId)
                {

                    case PPPMSG_PppDone:
                        rasconnstateNext = RASCS_Authenticated;

                        break;

                    case PPPMSG_PppFailure:
                        dwErr = msg.ExtraInfo.Failure.dwError;

#ifdef AMB
                        if (    prasconncb->dwAuthentication
                                == AS_PppThenAmb
                            &&  dwErr == ERROR_PPP_NO_RESPONSE)
                        {
                            //
                            // Not a PPP server.  Restart
                            // authentiation in AMB mode.
                            //
                            RASAPI32_TRACE("No response, try AMB");

                            //
                            // Terminate the PPP connection since
                            // we are going to now try AMB.
                            //
                            RASAPI32_TRACE("RasPppStop...");

                            dwErr = g_pRasPppStop(prasconncb->hport);

                            RASAPI32_TRACE1("RasPppStop(%d)", dwErr);

                            //
                            // Only failover to AMB for non-multilink
                            // connection attempts.
                            //
                            if (!prasconncb->fMultilink)
                            {
                                dwErr = 0;
                                prasconncb->fPppMode = FALSE;
                                rasconnstateNext = RASCS_Authenticate;
                            }
                            else
                            {
                                dwErr = ERROR_PPP_NO_RESPONSE;
                            }
                            break;
                        }
#endif

                        dwExtErr =
                            msg.ExtraInfo.Failure.dwExtendedError;

                        break;

                    case PPPMSG_AuthRetry:
                        if (prasconncb->fAllowPause)
                        {
                            rasconnstateNext =
                                    RASCS_RetryAuthentication;
                        }
                        else
                        {
                            dwErr = ERROR_AUTHENTICATION_FAILURE;
                        }

                        break;

                    case PPPMSG_Projecting:
                       if (prasconncb->fUpdateCachedCredentials)
                       {
                           //
                           // If we get here, a change-password or
                           // retry-authentication operation
                           // affecting the currently logged
                           // on user's credentials has
                           // succeeded.
                           //
                           UpdateCachedCredentials(prasconncb);
                        }

                        rasconnstateNext = RASCS_AuthProject;
                        break;

                    case PPPMSG_InvokeEapUI:
                    {
                        if (prasconncb->fAllowPause)
                        {
                            rasconnstateNext = RASCS_InvokeEapUI;
                        }
                        else
                        {
                            RASAPI32_TRACE("RDM: Cannot Invoke EapUI if "
                                  "pausedstates are not allowed");

                            dwErr = ERROR_INTERACTIVE_MODE;

                            break;
                        }

                        if (0xFFFFFFFF == prasconncb->reserved1)
                        {
                            RASAPI32_TRACE("RDM: Cannot invoke eap ui for a "
                                  "4.0 app running on nt5");

                            dwErr = ERROR_AUTHENTICATION_FAILURE;

                            break;
                        }

                        prasconncb->fPppEapMode = TRUE;

                        break;
                    }

                    case PPPMSG_ProjectionResult:
                    {
                        //
                        // Stash the full projection result for
                        // retrieval with RasGetProjectionResult.
                        // PPP and AMB are mutually exclusive so
                        // set AMB to "none".
                        //

                        RASAPI32_TRACE(
                        "RASCS_AuthNotify:PPPMSG_ProjectionResult"
                        );

                        prasconncb->AmbProjection.Result =
                            ERROR_PROTOCOL_NOT_CONFIGURED;

                        prasconncb->AmbProjection.achName[0] = '\0';

                        prasconncb->SlipProjection.dwError =

                            ERROR_PROTOCOL_NOT_CONFIGURED;

                        memcpy(
                            &prasconncb->PppProjection,
                            &msg.ExtraInfo.ProjectionResult,
                            sizeof(prasconncb->PppProjection) );

                        RASAPI32_TRACE1(
                            "hportBundleMember=%d",
                            prasconncb->PppProjection.lcp.hportBundleMember);

                        if (prasconncb->PppProjection.lcp.hportBundleMember
                                != INVALID_HPORT)
                        {
                            //
                            // We want caller to be able to determine the
                            // new connection was bundled.  We first save
                            // the hport away for later use.
                            //
                            prasconncb->hportBundled =
                            prasconncb->PppProjection.lcp.hportBundleMember;

                            prasconncb->PppProjection.lcp.hportBundleMember =
                                (HPORT) 1;
                        }
                        else
                        {
                            //
                            // Ansi-ize the NetBIOS name.
                            //
                            // Whistler bug 292981 rasapi32.dll prefast
                            // warnings
                            //
                            OemToCharBuffA(
                                prasconncb->PppProjection.nbf.szName,
                                prasconncb->PppProjection.nbf.szName,
                                strlen(prasconncb->PppProjection.nbf.szName)
                                    + 1 );
                        }

                        RASAPI32_TRACE4(
                          "fPppMode=%d, fBundled=%d, hportBundled=%d, "
                          "hportBundleMember=%d",
                          prasconncb->fPppMode,
                          prasconncb->fBundled,
                          prasconncb->hportBundled,
                          prasconncb->PppProjection.lcp.hportBundleMember);

                        if (prasconncb->PppProjection.lcp.hportBundleMember
                            == INVALID_HPORT)
                        {
                            if (prasconncb->fBundled)
                            {
                                //
                                // If another link has already received
                                // complete projection information, then
                                // the server doesn't support multilink,
                                // and we have to drop the link.
                                //
                                RASAPI32_TRACE(
                                  "Multilink subentry not bundled; "
                                  "terminating link");

                                dwErr = ERROR_REMOTE_DISCONNECTION;

                                break;
                            }
                            else
                            {
                                SetSubentriesBundled(prasconncb);
                                //
                                // Save the projection results in
                                // rasman.
                                //
                                RASAPI32_TRACE("SaveProjectionResults...");
                                dwErr = SaveProjectionResults(prasconncb);
                                RASAPI32_TRACE1(
                                  "SaveProjectionResults(%d)",
                                  dwErr);

                                if (dwErr)
                                {
                                    break;
                                }
                            }
                        }

                        prasconncb->fProjectionComplete = TRUE;
                        rasconnstateNext = RASCS_Projected;
                        break;
                    }

                    case PPPMSG_CallbackRequest:
                        rasconnstateNext = RASCS_AuthCallback;
                        break;

                    case PPPMSG_Callback:
                        rasconnstateNext = RASCS_PrepareForCallback;
                        break;

                    case PPPMSG_ChangePwRequest:
                        if (prasconncb->fAllowPause)
                        {
                            rasconnstateNext = RASCS_PasswordExpired;
                        }
                        else
                        {
                            dwErr = ERROR_PASSWD_EXPIRED;
                        }
                        break;

                    case PPPMSG_LinkSpeed:
                        rasconnstateNext = RASCS_AuthLinkSpeed;
                        break;

                    case PPPMSG_Progress:
                        rasconnstateNext = RASCS_AuthNotify;
                        fAsyncState = TRUE;
                        break;

                    case PPPMSG_SetCustomAuthData:
                    {
                        RASAPI32_TRACE("dwSetcustomAuthData..");
                        dwErr = DwPppSetCustomAuthData(prasconncb);
                        RASAPI32_TRACE1("dwSetCustomAuthData. rc=0x%x",
                                dwErr);
                                
                        //
                        // The error is not fatal.
                        //
                        dwErr = ERROR_SUCCESS;
                        fAsyncState = TRUE;
                        rasconnstateNext = RASCS_AuthNotify;
                        break;
                    }

                    default:

                        //
                        // Should not happen.
                        //
                        RASAPI32_TRACE1("Invalid PPP auth state=%d", msg.dwMsgId);
                        dwErr = ERROR_INVALID_AUTH_STATE;
                        break;
                }
            }
            else
            {
                AUTH_CLIENT_INFO info;

                RASAPI32_TRACE("RASCS_AuthNotify");

                RASAPI32_TRACE("AuthGetInfo...");

                g_pAuthGetInfo( prasconncb->hport, &info );

                RASAPI32_TRACE1("AuthGetInfo done, type=%d", info.wInfoType);

                switch (info.wInfoType)
                {
                    case AUTH_DONE:
                        prasconncb->fServerIsPppCapable =
                            info.DoneInfo.fPppCapable;

                        rasconnstateNext = RASCS_Authenticated;

                        break;

                    case AUTH_RETRY_NOTIFY:
                        if (prasconncb->fAllowPause)
                        {
                            rasconnstateNext = RASCS_RetryAuthentication;
                        }
                        else
                        {
                            dwErr = ERROR_AUTHENTICATION_FAILURE;
                        }

                        break;

                    case AUTH_FAILURE:
                        dwErr = info.FailureInfo.Result;
                        dwExtErr = info.FailureInfo.ExtraInfo;
                        break;

                    case AUTH_PROJ_RESULT:
                    {
                        //
                        // Save the projection result for retrieval
                        // with RasGetProjectionResult.  AMB and PPP
                        // projection are mutually exclusive so set
                        // PPP projection to "none".
                        //
                        memset(
                            &prasconncb->PppProjection, '\0',
                            sizeof(prasconncb->PppProjection) );

                        prasconncb->PppProjection.nbf.dwError =
                            prasconncb->PppProjection.ipx.dwError =
                            prasconncb->PppProjection.ip.dwError =
                                ERROR_PPP_NO_PROTOCOLS_CONFIGURED;

                        prasconncb->SlipProjection.dwError =
                            ERROR_PROTOCOL_NOT_CONFIGURED;

                        if (info.ProjResult.NbProjected)
                        {
                            prasconncb->AmbProjection.Result = 0;
                            prasconncb->AmbProjection.achName[0] = '\0';
                        }
                        else
                        {
                            memcpy(
                                &prasconncb->AmbProjection,
                                &info.ProjResult.NbInfo,
                                sizeof(prasconncb->AmbProjection) );

                            if (prasconncb->AmbProjection.Result == 0)
                            {
                                //
                                // Should not happen according to
                                // MikeSa (but did once).
                                //
                                prasconncb->AmbProjection.Result =
                                    ERROR_UNKNOWN;
                            }
                            else if (prasconncb->AmbProjection.Result
                                     == ERROR_NAME_EXISTS_ON_NET)
                            {
                                //
                                // Ansi-ize the NetBIOS name.
                                //
                                // Whistler bug 292981 rasapi32.dll prefast
                                // warnings
                                //
                                OemToCharBuffA(
                                    prasconncb->AmbProjection.achName,
                                    prasconncb->AmbProjection.achName,
                                    strlen(prasconncb->AmbProjection.achName)
                                        + 1 );
                            }
                        }

                        //
                        // Save the projection results in
                        // rasman.
                        //
                        RASAPI32_TRACE("SaveProjectionResults...");
                        dwErr = SaveProjectionResults(prasconncb);
                        RASAPI32_TRACE1("SaveProjectionResults(%d)", dwErr);

                        if (dwErr)
                        {
                            break;
                        }

                        prasconncb->fProjectionComplete = TRUE;
                        rasconnstateNext = RASCS_Projected;
                        break;
                    }

                    case AUTH_REQUEST_CALLBACK_DATA:
                        rasconnstateNext = RASCS_AuthCallback;
                        break;

                    case AUTH_CALLBACK_NOTIFY:
                        rasconnstateNext = RASCS_PrepareForCallback;
                        break;

                    case AUTH_CHANGE_PASSWORD_NOTIFY:
                        if (prasconncb->fAllowPause)
                            rasconnstateNext = RASCS_PasswordExpired;
                        else
                            dwErr = ERROR_PASSWD_EXPIRED;
                        break;

                    case AUTH_PROJECTING_NOTIFY:
                        rasconnstateNext = RASCS_AuthProject;
                        break;

                    case AUTH_LINK_SPEED_NOTIFY:
                        rasconnstateNext = RASCS_AuthLinkSpeed;
                        break;

                    default:
                        //
                        // Should not happen.
                        //
                        RASAPI32_TRACE1("Invalid AMB auth state=%d",
                                info.wInfoType);

                        dwErr = ERROR_INVALID_AUTH_STATE;
                        break;
                }
            }
            break;
        }

        case RASCS_AuthRetry:
        {
            RASDIALPARAMS* prasdialparams =
                    &prasconncb->rasdialparams;

            RASAPI32_TRACE("RASCS_AuthRetry");

            if (prasconncb->fPppMode)
            {
                if (    0xFFFFFFFF != prasconncb->reserved1
                    &&  0 != prasconncb->reserved1 )
                {
                    s_InvokeEapUI *pInfo = (s_InvokeEapUI *)
                                            prasconncb->reserved1;

                    RASAPI32_TRACE("RasPppSetEapInfo...");

                    //
                    // We came here from RASCS_InvokeEapUI. Set the
                    // information with PPP
                    //
                    dwErr = g_pRasPppSetEapInfo(
                                 prasconncb->hport,
                                 pInfo->dwContextId,
                                 pInfo->dwSizeOfUIContextData,
                                 pInfo->pUIContextData);

                    RASAPI32_TRACE1("RasPppSetEapInfo done(%d)", dwErr);

                    if ( 0 == dwErr )
                    {
                        LocalFree(pInfo->pUIContextData);
                        LocalFree(pInfo);
                    }

                    prasconncb->fPppEapMode = FALSE;

                    prasconncb->reserved1 = 0;
                }
                else
                {

                    CHAR szUserNameA[UNLEN + 1], szPasswordA[PWLEN + 1];
                    CHAR szDomainA[2 * (DNLEN + 1)];

                    RASAPI32_TRACE("RasPppRetry...");

                    strncpyTtoAAnsi(
                        szUserNameA,
                        prasdialparams->szUserName,
                        sizeof(szUserNameA));

                    SafeDecodePasswordBuf(prasdialparams->szPassword);
                    strncpyTtoAAnsi(
                        szPasswordA,
                        prasdialparams->szPassword,
                        sizeof(szPasswordA));
                    SafeEncodePasswordBuf(prasdialparams->szPassword);

                    strncpyTtoAAnsi(
                        szDomainA,
                        prasdialparams->szDomain,
                        sizeof(szDomainA));

                    dwErr = g_pRasPppRetry(
                        prasconncb->hport,
                        szUserNameA,
                        szPasswordA,
                        szDomainA );

                    RtlSecureZeroMemory(szPasswordA,sizeof(szPasswordA));

                    RASAPI32_TRACE1("RasPppRetry done(%d)", dwErr);
                }


                if (dwErr != 0)
                {
                    break;
                }
            }
#ifdef AMB
            else
            {
                RASAPI32_TRACE("AuthRetry...");

                {
                    CHAR szUserNameA[UNLEN + 1],
                         szPasswordA[PWLEN + 1];
                    CHAR szDomainA[2 * (DNLEN + 1)];


                    strncpyTtoAAnsi(
                        szUserNameA,
                        prasdialparams->szUserName,
                        sizeof(szUserNameA));

                    SafeDecodePasswordBuf(prasdialparams->szPassword);

                    strncpyTtoAAnsi(
                        szPasswordA,
                        prasdialparams->szPassword,
                        sizeof(szPasswordA));
                    SafeEncodePasswordBuf(prasdialparams->szPassword);

                    strncpyTtoAAnsi(
                        szDomainA,
                        prasdialparams->szDomain,
                        sizeof(szDomainA));

                    g_pAuthRetry(
                        prasconncb->hport,
                        szUserNameA,
                        szPasswordA,
                        szDomainA );

                    RtlSecureZeroMemory(szPasswordA,sizeof(szPasswordA));

                }

                RASAPI32_TRACE("AuthRetry done");
            }
#endif

            //
            // Set this flag to prevent us from saving
            // the previous credentials over the new
            // ones the caller may have just set.
            //
            prasconncb->fRetryAuthentication = TRUE;

            fAsyncState = TRUE;
            rasconnstateNext = RASCS_AuthNotify;
            break;
        }

        case RASCS_AuthCallback:
        {
            RASDIALPARAMS* prasdialparams =
                    &prasconncb->rasdialparams;

            RASAPI32_TRACE("RASCS_AuthCallback");

            if (lstrcmp(prasdialparams->szCallbackNumber,
                        TEXT("*") ) == 0)
            {
                PBUSER pbuser;
                DWORD  dwCallbackMode;

                //
                // API caller says he wants to be prompted for a
                // callback number.
                //
                RASAPI32_TRACE("GetUserPreferences");
                dwErr = GetUserPreferences(
                                NULL,
                                &pbuser,
                                prasconncb->dwUserPrefMode);

                RASAPI32_TRACE1("GetUserPreferences=%d", dwErr);

                if (dwErr)
                {
                    break;
                }

                if (prasconncb->pEntry->dwfOverridePref
                    & RASOR_CallbackMode)
                {
                    dwCallbackMode =
                        prasconncb->pEntry->dwCallbackMode;
                }
                else
                {
                    dwCallbackMode = pbuser.dwCallbackMode;
                }

                RASAPI32_TRACE1("dwCallbackMode=%d", dwCallbackMode);

                //
                // Determine the callback number.
                //
                switch (dwCallbackMode)
                {
                case CBM_Yes:
                    if (GetCallbackNumber(prasconncb, &pbuser))
                    {
                        break;
                    }

                    // fall through
                case CBM_No:
                    prasdialparams->szCallbackNumber[0]
                                    = TEXT('\0');
                    break;

                case CBM_Maybe:
                    if (prasconncb->fAllowPause)
                    {
                        rasconnstateNext =
                                RASCS_CallbackSetByCaller;
                    }
                    else
                    {
                        dwErr = ERROR_BAD_CALLBACK_NUMBER;
                    }
                    break;
                }

                //
                // Free user preferences block.
                //
                DestroyUserPreferences(&pbuser);

            }
            if (    !dwErr
                &&  rasconnstateNext != RASCS_CallbackSetByCaller)
            {
                //
                // Send the server the callback number or an empty
                // string to indicate no callback.  Then, re-enter
                // Authenticate state since the server will signal
                // the event again.
                //
                if (prasconncb->fPppMode)
                {
                    RASAPI32_TRACE("RasPppCallback...");

                    {
                        CHAR szCallbackNumberA[RAS_MaxCallbackNumber + 1];

                        strncpyTtoA(
                            szCallbackNumberA,
                            prasdialparams->szCallbackNumber,
                            sizeof(szCallbackNumberA));

                        dwErr = g_pRasPppCallback(
                                  prasconncb->hport,
                                  szCallbackNumberA);
                    }

                    RASAPI32_TRACE1("RasPppCallback done(%d)", dwErr);

                    if (dwErr != 0)
                    {
                        break;
                    }
                }
#ifdef AMB
                else
                {
                    RASAPI32_TRACE("AuthCallback...");

                    {
                        CHAR szCallbackNumberA[RAS_MaxCallbackNumber + 1];

                        strncpyTtoA(szCallbackNumberA,
                                    prasdialparams->szCallbackNumber,
                                    sizeof(szCallbackNumberA));

                        g_pAuthCallback(prasconncb->hport,
                                        szCallbackNumberA);
                    }

                    RASAPI32_TRACE("AuthCallback done");
                }
#endif

                fAsyncState = TRUE;
                rasconnstateNext = RASCS_AuthNotify;
            }

            break;
        }

        case RASCS_AuthChangePassword:
        {
            RASDIALPARAMS* prasdialparams = &prasconncb->rasdialparams;

            RASAPI32_TRACE("RASCS_AuthChangePassword");

            if (prasconncb->fPppMode)
            {
                RASAPI32_TRACE("RasPppChangePassword...");

                {
                    CHAR szUserNameA[UNLEN + 1];
                    CHAR szOldPasswordA[PWLEN + 1], szPasswordA[PWLEN + 1];


                    strncpyTtoAAnsi(
                        szUserNameA,
                        prasdialparams->szUserName,
                        sizeof(szUserNameA));

                    SafeDecodePasswordBuf(prasconncb->szOldPassword);
                    SafeDecodePasswordBuf(prasdialparams->szPassword);

                    strncpyTtoAAnsi(
                        szOldPasswordA,
                        prasconncb->szOldPassword,
                        sizeof(szOldPasswordA));

                    strncpyTtoAAnsi(
                        szPasswordA,
                        prasdialparams->szPassword,
                        sizeof(szPasswordA));

                    SafeEncodePasswordBuf(prasconncb->szOldPassword);
                    SafeEncodePasswordBuf(prasdialparams->szPassword);

                    dwErr = g_pRasPppChangePassword(
                              prasconncb->hport,
                              szUserNameA,
                              szOldPasswordA,
                              szPasswordA );


                    RtlSecureZeroMemory(szPasswordA, sizeof(szPasswordA));
                    RtlSecureZeroMemory(szOldPasswordA, sizeof(szOldPasswordA));
                }

                RASAPI32_TRACE1("RasPppChangePassword done(%d)", dwErr);

                if (dwErr != 0)
                {
                    break;
                }
            }
#ifdef AMB
            else
            {
                RASAPI32_TRACE("AuthChangePassword...");

                {
                    CHAR szUserNameA[UNLEN + 1];
                    CHAR szOldPasswordA[PWLEN + 1],
                         szPasswordA[PWLEN + 1];


                    strncpyTtoAAnsi(szUserNameA,
                               prasdialparams->szUserName,
                               sizeof(szUserNameA));

                    SafeDecodePasswordBuf(
                        prasconncb->szOldPassword
                        );

                    SafeDecodePasswordBuf(
                        prasdialparams->szPassword
                        );

                    strncpyTtoAAnsi(szOldPasswordA,
                               prasconncb->szOldPassword,
                               sizeof(szOldPasswordA));

                    strncpyTtoAAnsi(szPasswordA,
                               prasdialparams->szPassword,
                               sizeof(szPasswordA));

                    SafeEncodePasswordBuf(
                        prasconncb->szOldPassword
                        );

                    SafeEncodePasswordBuf(
                        prasdialparams->szPassword
                        );

                    g_pAuthChangePassword(
                        prasconncb->hport,
                        szUserNameA,
                        szOldPasswordA,
                        szPasswordA );

                    RtlSecureZeroMemory(szPasswordA,sizeof(szPasswordA));
                    RtlSecureZeroMemory(szPasswordA,sizeof(szOldPasswordA));

                }

                RASAPI32_TRACE("AuthChangePassword done");
            }
#endif

            fAsyncState = TRUE;
            rasconnstateNext = RASCS_AuthNotify;
            break;
        }

        case RASCS_ReAuthenticate:
        {
            RASDIALPARAMS *prasdialparams =
                    &prasconncb->rasdialparams;

            RASAPI32_TRACE("RASCS_ReAuth...");

            RASAPI32_TRACE("RasPortConnectComplete...");

            dwErr = g_pRasPortConnectComplete(
                                prasconncb->hport
                                );

            RASAPI32_TRACE1("RasPortConnectComplete done(%d)", dwErr);

            if (dwErr != 0)
            {
                break;
            }

            if (prasconncb->fPppMode)
            {
                RASMAN_PPPFEATURES features;

                //
                // Set PPP framing.
                //
                memset( (char* )&features, '\0', sizeof(features) );
                features.ACCM = 0xFFFFFFFF;

                RASAPI32_TRACE("RasPortSetFraming(PPP)...");

                dwErr = g_pRasPortSetFraming(
                            prasconncb->hport,
                            PPP, &features,
                            &features );

                RASAPI32_TRACE1("RasPortSetFraming done(%d)", dwErr);

                //
                // Save the dialparamsuid with the port so that
                // rasman can get the password if required to
                // pass to ppp
                //
                RASAPI32_TRACE1("RasSetPortUserData(reauth,paramsuid) for %d",
                        prasconncb->hport);

                dwErr = RasSetPortUserData(
                    prasconncb->hport,
                    PORT_DIALPARAMSUID_INDEX,
                    (PBYTE) &prasconncb->pEntry->dwDialParamsUID,
                    sizeof(DWORD));

                RASAPI32_TRACE1("RasSetPortUserData returned %x", dwErr);

                //
                // This is not fatal.
                // 
                dwErr = 0;
                
                RASAPI32_TRACE1(
                  "RasPppStart(cfg=%d)...",
                  prasconncb->cinfo.dwConfigMask);

                {
                    CHAR szUserNameA[UNLEN + 1],
                         szPasswordA[PWLEN + 1];

                    CHAR szDomainA[2 * (DNLEN + 1)];

                    CHAR szPortNameA[MAX_PORT_NAME + 1];

                    CHAR szPhonebookPath[ MAX_PATH ];

                    CHAR szEntryName[ MAX_ENTRYNAME_SIZE ];

                    CHAR szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];

                    PPP_BAPPARAMS BapParams;

                    DWORD dwSubEntries;

                    DWORD cbData = 0;
                    PBYTE pbData = NULL;

                    DWORD dwFlags = 0;

                    //
                    // Set PhonebookPath and EntryName in rasman
                    //
                    strncpyTtoAAnsi(
                        szPhonebookPath,
                        prasconncb->pbfile.pszPath,
                        sizeof(szPhonebookPath));

                    strncpyTtoAAnsi(
                        szEntryName,
                        prasconncb->pEntry->pszEntryName,
                        sizeof(szEntryName));

                    strncpyTtoAAnsi(
                        szPhoneNumber,
                        prasconncb->szPhoneNumber,
                        sizeof(szPhoneNumber));

                    RASAPI32_TRACE1("RasSetRasdialInfo %d...",
                           prasconncb->hport);

                    dwErr = DwGetCustomAuthData(
                                prasconncb->pEntry,
                                &cbData,
                                &pbData);

                    if(ERROR_SUCCESS != dwErr)
                    {
                        RASAPI32_TRACE1("DwGetCustomAuthData failed", dwErr);
                        break;
                    }

                    dwErr = g_pRasSetRasdialInfo(
                                prasconncb->hport,
                                szPhonebookPath,
                                szEntryName,
                                szPhoneNumber,
                                cbData,
                                pbData);

                    RASAPI32_TRACE2("RasSetRasdialInfo %d done. e = %d",
                            prasconncb->hport,
                            dwErr);

                    if (dwErr)
                    {
                        break;
                    }

                    if(prasconncb->RasEapInfo.dwSizeofEapInfo)
                    {
                        RASAPI32_TRACE1("RasSetEapLogonInfo %d...",
                                prasconncb->hport);

                        dwErr = g_pRasSetEapLogonInfo(
                                prasconncb->hport,
                                (UPM_Logon == prasconncb->dwUserPrefMode),
                                &prasconncb->RasEapInfo);

                        RASAPI32_TRACE3("RasSetEapLogonInfo %d(upm=%d) done. e=%d",
                                prasconncb->hport,
                                (UPM_Logon == prasconncb->dwUserPrefMode),
                                dwErr);
                    }

                    if(dwErr)
                    {
                        break;
                    }



                    strncpyTtoAAnsi(
                        szUserNameA,
                        prasdialparams->szUserName,
                        sizeof(szUserNameA));

                    SafeDecodePasswordBuf(prasdialparams->szPassword);

                    strncpyTtoAAnsi(
                        szPasswordA,
                        prasdialparams->szPassword,
                        sizeof(szPasswordA));

                    SafeEncodePasswordBuf(prasdialparams->szPassword);

                    strncpyTtoAAnsi(
                        szDomainA,
                        prasdialparams->szDomain,
                        sizeof(szDomainA));

                    if (!pEntry->fAutoLogon
                        && szUserNameA[ 0 ] == '\0'
                        && szPasswordA[ 0 ] == '\0')
                    {
                        if(pEntry->dwType == RASET_Direct)
                        {
                            // Windows9x DCC implements "no password mode"
                            // as doing authentication and checking for 
                            // no password, rather than just not authenti
                            // cating (don't ask me why).  This creates a 
                            // conflict with the RasDial API definition of
                            // empty username and password mapping to "use
                            // Windows credentials".  Workaround that here
                            // by substituting "guest" for the username.
                            //
                            lstrcpynA(
                                szUserNameA,
                                "guest",
                                sizeof(szUserNameA));
                        }

                        if (szDomainA[ 0 ] == '\0')
                        {
                            // default the domain name to the nt logon
                            // domain name if username/pwd/domain are all
                            // "". Bug 337591
                            //
                            WKSTA_USER_INFO_1 *pInfo = NULL;
                            DWORD dwError = SUCCESS;

                            RASAPI32_TRACE("NetWkstaUserGetInfo...");
                            dwError = NetWkstaUserGetInfo(
                                                    NULL,
                                                    1,
                                                    (LPBYTE*) &pInfo);

                            RASAPI32_TRACE1("NetWkstaUserGetInfo. rc=%d",
                                    dwError);

                            if(pInfo)
                            {
                                if(dwError == 0)
                                {
                                    strncpyWtoAAnsi(szDomainA,
                                             pInfo->wkui1_logon_domain,
                                             sizeof(szDomainA));
                                }

                                NetApiBufferFree(pInfo);
                            }
                        }
                    }

                    strncpyTtoA(
                        szPortNameA,
                        prasconncb->szPortName,
                        sizeof(szPortNameA));

                    dwSubEntries = DtlGetNodes (
                                    prasconncb->pEntry->pdtllistLinks
                                    );

                    if ( dwSubEntries > 1 )
                    {
                        BapParams.dwDialMode =
                            prasconncb->pEntry->dwDialMode;
                    }
                    else
                    {
                        BapParams.dwDialMode = RASEDM_DialAll;
                    }

                    BapParams.dwDialExtraPercent =
                                    prasconncb->pEntry->dwDialPercent;

                    BapParams.dwDialExtraSampleSeconds =
                                    prasconncb->pEntry->dwDialSeconds;

                    BapParams.dwHangUpExtraPercent =
                                    prasconncb->pEntry->dwHangUpPercent;

                    BapParams.dwHangUpExtraSampleSeconds =
                                    prasconncb->pEntry->dwHangUpSeconds;

                    if(     (!prasconncb->pEntry->fShareMsFilePrint)
                        &&  (!prasconncb->pEntry->fBindMsNetClient))
                    {
                        dwFlags |= PPPFLAGS_DisableNetbt;
                    }
                    
                    dwErr = g_pRasPppStart(
                              prasconncb->hport,
                              szPortNameA,
                              szUserNameA,
                              szPasswordA,
                              szDomainA,
                              &prasconncb->luid,
                              &prasconncb->cinfo,
                              (LPVOID)prasconncb->reserved,
                              prasconncb->szzPppParameters,
                              TRUE,
                              hEventManual,
                              prasconncb->dwIdleDisconnectSeconds,
                              (prasconncb->pEntry->fRedialOnLinkFailure) ?
                              TRUE : FALSE,
                              &BapParams,
                              !(prasconncb->fAllowPause),
                              prasconncb->pEntry->dwCustomAuthKey,
                              dwFlags);

                    RtlSecureZeroMemory(szPasswordA,sizeof(szPasswordA));

                }

                RASAPI32_TRACE1("RasPppStart done(%d)", dwErr);
            }
#ifdef AMB
            else
            {   //
                // Set RAS framing.
                //
                RASAPI32_TRACE("RasPortSetFraming(RAS)...");

                dwErr = g_pRasPortSetFraming(
                    prasconncb->hport, RAS, NULL, NULL );

                RASAPI32_TRACE1("RasPortSetFraming done(%d)", dwErr);
            }
#endif

            if (dwErr != 0)
            {
                break;
            }

            //
            // ...fall thru...
            //
        }

        case RASCS_AuthAck:
        case RASCS_AuthProject:
        case RASCS_AuthLinkSpeed:
        {
            RASDIALPARAMS* prasdialparams = &prasconncb->rasdialparams;

            RASAPI32_TRACE("RASCS_(ReAuth)/AuthAck/Project/Speed");


            if (prasconncb->fPppMode)
            {
                //
                // If we have previously suspended other
                // subentries to wait for a successful PPP
                // authentication, we resume them now.
                //
                if (    prasconncb->dwfSuspended == SUSPEND_Master
                    &&  !IsListEmpty(&prasconncb->ListEntry))
                {
                    ResumeSubentries(prasconncb);
                    prasconncb->dwfSuspended = SUSPEND_Done;
                }
            }
#ifdef AMB
            else
            {
                RASAPI32_TRACE("AuthContinue...");

                g_pAuthContinue( prasconncb->hport );

                RASAPI32_TRACE("AuthContinue done");
            }
#endif

            fAsyncState = TRUE;
            rasconnstateNext = RASCS_AuthNotify;
            break;
        }

        case RASCS_Authenticated:
        {
            RASAPI32_TRACE("RASCS_Authenticated");


#ifdef AMB
            if (    prasconncb->dwAuthentication == AS_PppThenAmb
                && !prasconncb->fPppMode)
            {
                //
                // AMB worked and PPP didn't, so try AMB first next time.
                //
                prasconncb->dwAuthentication = AS_AmbThenPpp;
            }
            else if (   prasconncb->dwAuthentication == AS_AmbThenPpp
                     && (   prasconncb->fPppMode
                         || prasconncb->fServerIsPppCapable))
            {
                //
                // Either PPP worked and AMB didn't, or AMB worked but the
                // server also has PPP.  Try PPP first next time.
                //
                prasconncb->dwAuthentication = AS_PppThenAmb;
            }

            //
            // Write the strategy to the phonebook.
            //
            SetAuthentication(prasconncb,
                    prasconncb->dwAuthentication);
#endif

            rasconnstateNext = RASCS_Connected;

            break;
        }

        case RASCS_PrepareForCallback:
        {
            RASAPI32_TRACE("RASCS_PrepareForCallback");

            dwErr = ResetAsyncMachine(
                    &prasconncb->asyncmachine
                    );

            //
            // Disable the disconnect processing
            // in the async machine, since we don't
            // want to terminate the connection after
            // we disconnect the port below.
            //
            dwErr = EnableAsyncMachine(
                      prasconncb->hport,
                      &prasconncb->asyncmachine,
                      ASYNC_MERGE_DISCONNECT);

            RASAPI32_TRACE("RasPortDisconnect...");

            dwErr = g_pRasPortDisconnect(prasconncb->hport,
                                         INVALID_HANDLE_VALUE );

            RASAPI32_TRACE1("RasPortDisconnect done(%d)", dwErr);

            if(     dwErr != 0
                &&  dwErr != PENDING)
            {
                break;
            }

            fAsyncState = TRUE;
            rasconnstateNext = RASCS_WaitForModemReset;
            break;
        }

        case RASCS_WaitForModemReset:
        {
            DWORD dwDelay = (DWORD )
                            ((prasconncb->wCallbackDelay / 2)
                            * 1000L);

            RASAPI32_TRACE("RASCS_WaitForModemReset");

            if (prasconncb->fUseCallbackDelay)
                Sleep( dwDelay );

            rasconnstateNext = RASCS_WaitForCallback;
            break;
        }

        case RASCS_WaitForCallback:
        {
            RASAPI32_TRACE("RASCS_WaitForCallback");

            RASAPI32_TRACE("RasPortListen...");

            dwErr = g_pRasPortListen(
                        prasconncb->hport,
                        SECS_ListenTimeout,
                        hEventAuto );

            RASAPI32_TRACE1("RasPortListen done(%d)", dwErr);

            if (    dwErr != 0
                &&  dwErr != PENDING)
            {
                break;
            }

            fAsyncState = TRUE;
            rasconnstateNext = RASCS_ReAuthenticate;
            break;
        }

        case RASCS_Projected:
        {
            RASMAN_INFO ri;

            RASAPI32_TRACE("RASCS_Projected");

            RASAPI32_TRACE("RasGetInfo...");

            dwErr = g_pRasGetInfo(NULL,
                                  prasconncb->hport,
                                  &ri);

            RASAPI32_TRACE1("RasGetInfo done(%d)", dwErr);

            if (dwErr)
            {
                break;
            }

            prasconncb->hrasconnOrig = prasconncb->hrasconn;

            prasconncb->hrasconn = ri.RI_ConnectionHandle;

            RASAPI32_TRACE("RasSetConnectionUserData...");

            //
            // Save the fPppMode in rasman.
            //
            dwErr = g_pRasSetConnectionUserData(
                      prasconncb->hrasconn,
                      CONNECTION_PPPMODE_INDEX,
                      (PBYTE)&prasconncb->fPppMode,
                      sizeof (prasconncb->fPppMode));

            RASAPI32_TRACE2(
                "RasSetConnectionUserData done(%d). PppMode=%d",
                dwErr, prasconncb->fPppMode );

            if (dwErr)
            {
                break;
            }

            if (prasconncb->fPppMode)
            {
                //
                // If at least one protocol succeeded, we can
                // continue.
                //
                if (    (prasconncb->PppProjection.lcp.hportBundleMember
                        == (HANDLE) 1)
                    ||  (prasconncb->PppProjection.nbf.dwError == 0)
                    ||  (prasconncb->PppProjection.ipx.dwError == 0)
                    ||  (prasconncb->PppProjection.ip.dwError == 0))
                {
                    fAsyncState = TRUE;
                    rasconnstateNext = RASCS_AuthNotify;

                    break;
                }

                //
                // If none of the protocols succeeded, then
                // we return ERROR_PPP_NO_PROTOCOLS_CONFIGURED,
                // not a protocol-specific error.
                //
                dwErr = ERROR_PPP_NO_PROTOCOLS_CONFIGURED;

            }
#ifdef AMB
            else
            {
                if (prasconncb->AmbProjection.Result == 0)
                {
                    //
                    // Save the projection information to
                    // rasman.
                    //
                    dwErr = SaveProjectionResults(prasconncb);
                    if (dwErr)
                        break;

                    rasconnstateNext = RASCS_AuthAck;
                    break;
                }

                dwErr = prasconncb->AmbProjection.Result;
            }
#endif

            break;
        }

    }


    prasconncb->dwError = dwErr;
    prasconncb->dwExtendedError = dwExtErr;

    RASAPI32_TRACE2("RDM errors=%d,%d", dwErr, dwExtErr);

    if (    !fAsyncState
        &&  !prasconncb->fStopped)
    {
        RASAPI32_TRACE1("RasDialMachine: SignalDone: prasconncb=0x%x",
                prasconncb);

        SignalDone( &prasconncb->asyncmachine );
    }

    if (fEnteredCS)
    {
        LeaveCriticalSection(&csStopLock);
    }

    return rasconnstateNext;
}


VOID
RasDialRestart(
    IN RASCONNCB** pprasconncb )

/*++

Routine Description:

        Called when an error has occurred in 'dwRestartOnError'
        mode. This routine does all cleanup necessary to restart
        the connection in state 0 (or not, as indicated). A new
        prasconncb structure is created here and the members
        copied from the old prasconncb structure. NOTE: The old
        prasconncb structure should be destroyed when the port
        associated with the connection is closed. Do not destr
        oy the old connection here.

Arguments:

Return Value:

--*/
{
    DWORD dwErr;
    RASCONNCB *prasconncbT;
    DTLNODE *pdtlnode;
    RASCONNCB *prasconncb = *pprasconncb;

    RASAPI32_TRACE("RasDialRestart");

    ASSERT(     prasconncb->dwRestartOnError != RESTART_HuntGroup
            ||  prasconncb->cPhoneNumbers>0);

    if (    prasconncb->dwRestartOnError
            == RESTART_DownLevelIsdn
        || (    (prasconncb->dwRestartOnError
                == RESTART_HuntGroup)
            &&  (++prasconncb->iPhoneNumber
                < prasconncb->cPhoneNumbers)))
    {
        if (prasconncb->dwRestartOnError == RESTART_DownLevelIsdn)
        {
            prasconncb->dwRestartOnError = 0;
        }

        RASAPI32_TRACE2(
          "Restart=%d, iPhoneNumber=%d",
          prasconncb->dwRestartOnError,
          prasconncb->iPhoneNumber);

        ASSERT(prasconncb->hport != INVALID_HPORT);

        RASAPI32_TRACE1("(ER) RasPortClose(%d)...", prasconncb->hport);

        dwErr = g_pRasPortClose( prasconncb->hport );

        RASAPI32_TRACE1("(ER) RasPortClose done(%d)", dwErr);

        RASAPI32_TRACE("(ER) RasPppStop...");

        g_pRasPppStop(prasconncb->hport);

        RASAPI32_TRACE("(ER) RasPppStop done");

        prasconncbT = CreateConnectionBlock(prasconncb);
        if (prasconncbT == NULL)
        {
            prasconncb->dwError = ERROR_NOT_ENOUGH_MEMORY;
            return;
        }

        //
        // Look up the subentry.
        //
        pdtlnode = DtlNodeFromIndex(
                     prasconncb->pEntry->pdtllistLinks,
                     prasconncb->rasdialparams.dwSubEntry - 1);

        prasconncbT->pLink = (PBLINK *)DtlGetData(pdtlnode);

        prasconncbT->rasdialparams.dwSubEntry
                = prasconncb->rasdialparams.dwSubEntry;

        prasconncbT->cPhoneNumbers =
                        prasconncb->cPhoneNumbers;

        prasconncbT->iPhoneNumber =
                        prasconncb->iPhoneNumber;

        prasconncbT->fMultilink =
                        prasconncb->fMultilink;

        prasconncbT->fBundled = prasconncb->fBundled;

        prasconncbT->fTerminated =
                        prasconncb->fTerminated;

        prasconncbT->dwRestartOnError =
                        prasconncb->dwRestartOnError;

        prasconncbT->cDevices = prasconncb->cDevices;

        prasconncbT->iDevice = prasconncb->iDevice;

        prasconncbT->hrasconnOrig = prasconncb->hrasconnOrig;

        prasconncbT->dwDeviceLineCounter =
                    prasconncb->dwDeviceLineCounter;

        if(NULL == prasconncb->notifier)                    
        {
            prasconncbT->asyncmachine.hDone = 
                prasconncb->asyncmachine.hDone;

            prasconncbT->psyncResult = prasconncb->psyncResult;                
                
            prasconncb->asyncmachine.hDone = NULL;
            prasconncb->psyncResult = NULL;
        }

        prasconncb->notifier = NULL;

        prasconncb->fRasdialRestart = TRUE;

        RASAPI32_TRACE2(
            "RasdialRestart: Replacing 0x%x with 0x%x",
            prasconncb, prasconncbT);

        prasconncb = prasconncbT;

        prasconncb->hport = INVALID_HPORT;

        prasconncb->dwError = 0;

        dwErr = ResetAsyncMachine(&prasconncb->asyncmachine);

        prasconncb->rasconnstate = 0;

        *pprasconncb = prasconncbT;

    }
}

VOID
RasDialTryNextAddress(
    IN RASCONNCB** pprasconncb )
{
    DWORD dwErr;
    RASCONNCB *prasconncbT;
    DTLNODE *pdtlnode;
    RASCONNCB *prasconncb = *pprasconncb;
    struct in_addr addr;
    // TCHAR *pszPhoneNumber;

    RASAPI32_TRACE("RasDialTryNextAddress");

    RASAPI32_TRACE1(
      "RasDialTryNextAddress, iAddress=%d",
      prasconncb->iAddress);

    ASSERT(RASET_Vpn == prasconncb->pEntry->dwType);      

    ASSERT(prasconncb->hport != INVALID_HPORT);

    RASAPI32_TRACE1("(TryNextAddress) RasPortClose(%d)...",
            prasconncb->hport);

    dwErr = g_pRasPortClose(prasconncb->hport);

    RASAPI32_TRACE1("(TryNextAddress) RasPortClose done(%d)",
            dwErr);

    RASAPI32_TRACE("(TryNextAddress) RasPppStop...");

    g_pRasPppStop(prasconncb->hport);

    RASAPI32_TRACE("(TryNextAddress) RasPppStop done");

    prasconncbT = CreateConnectionBlock(prasconncb);
    if (prasconncbT == NULL)
    {
        prasconncb->dwError = ERROR_NOT_ENOUGH_MEMORY;
        return;
    }

    prasconncbT->iAddress = prasconncb->iAddress + 1;
    prasconncbT->cAddresses = prasconncb->cAddresses;
    prasconncbT->pAddresses = prasconncb->pAddresses;
    prasconncb->pAddresses = NULL;
    prasconncb->iAddress = prasconncb->cAddresses = 0;

    prasconncbT->pLink = prasconncb->pLink;

    prasconncbT->rasdialparams.dwSubEntry
            = prasconncb->rasdialparams.dwSubEntry;

    prasconncbT->cPhoneNumbers =
                    prasconncb->cPhoneNumbers;

    prasconncbT->iPhoneNumber =
                    prasconncb->iPhoneNumber;

    prasconncbT->fMultilink =
                    prasconncb->fMultilink;

    prasconncbT->fBundled = prasconncb->fBundled;

    prasconncbT->fTerminated =
                    prasconncb->fTerminated;

    prasconncbT->dwRestartOnError =
                    prasconncb->dwRestartOnError;

    prasconncbT->cDevices = prasconncb->cDevices;

    prasconncbT->iDevice = prasconncb->iDevice;

    prasconncbT->hrasconnOrig = prasconncb->hrasconnOrig;

    prasconncbT->dwDeviceLineCounter =
                prasconncb->dwDeviceLineCounter;

    if(NULL == prasconncb->notifier)
    {
        prasconncbT->asyncmachine.hDone = 
                        prasconncb->asyncmachine.hDone;
        prasconncb->asyncmachine.hDone = NULL;

        prasconncbT->psyncResult = prasconncb->psyncResult;
        prasconncb->psyncResult = NULL;
    }

    prasconncb->notifier = NULL;
    
    RASAPI32_TRACE2(
        "RasdialTryNextAddress: Replacing 0x%x with 0x%x",
        prasconncb, prasconncbT);

    prasconncb = prasconncbT;

    prasconncb->hport = INVALID_HPORT;

    prasconncb->dwError = 0;

    dwErr = ResetAsyncMachine(&prasconncb->asyncmachine);

    prasconncb->rasconnstate = 0;

    *pprasconncb = prasconncbT;
}


/*++

Routine Description:

        This function is called when an error occurs in the
        RasDialMachine at or before reaching RASCS_DeviceConnect
        state and if the RDM is in DialMode 0. The next device 
        on the alternates list will be tried only when the 
        PortOpenEx failed for the current device. PortOpenEx 
        failing for a device means that either all the lines on 
        the device are busy or we have already tried all the 
        lines of the device but failed to connect. If PortOpenEx
        passed for the device but we encountered an error at some
        other state, we try to find another line on the device. 
        PortOpenEx will fail now if the device doesn't have any 
        more lines and the next time this function is called it 
        will move on to the next device on the alternates list.

Arguments:

        pprasconncb - This is an in/out parameter. This is address
                      of connectionblock to the connection that
                      failedto connect when in, its the connection
                      block of the new attempt to be made when out.
                      The in prasconncb will be destroyed when the
                      PortClose causes the asyncmachine for that
                      connection to shutdown. If the error occurs
                      in RASCS_PortOpen state, there won't be a
                      PortClose and the prasconncb structure passed
                      can be reused. As this prasconncb is destroyed
                      when PortClose is called, its illegal to
                      destroy the connection block here.

Return Value:

        void

--*/
VOID
RasDialTryNextLink(RASCONNCB **pprasconncb)
{
    DWORD       dwErr         = SUCCESS;
    RASCONNCB   *prasconncb   = *pprasconncb;
    RASCONNCB   *prasconncbT;
    DTLNODE     *pdtlnode;
    PBLINK      *pLink;

    RASAPI32_TRACE("RasDialTryNextLink...");

    //
    // We should not get called here if we are
    // not in "try next link if this link fails"
    // mode
    //
    // ASSERT(0 == prasconncb->pEntry->dwDialMode);

    ASSERT(NULL != prasconncb->pLink);
    ASSERT(NULL != prasconncb->pEntry->pdtllistLinks);

    if(RASEDM_DialAll != prasconncb->pEntry->dwDialMode)
    {
        //
        // Get the next link to dial
        //
        for (pdtlnode = DtlGetFirstNode(prasconncb->pEntry->pdtllistLinks);
             pdtlnode;
             pdtlnode = DtlGetNextNode(pdtlnode))
        {
            if(prasconncb->pLink == (PBLINK *) DtlGetData(pdtlnode))
            {
                break;
            }
        }
        
        ASSERT(NULL != pdtlnode);

        pdtlnode = DtlGetNextNode(pdtlnode);

        if(     NULL == pdtlnode
            &&  INVALID_HPORT == prasconncb->hport)
        {
            //
            // No more links for you!! Come back next dial!
            //
            RASAPI32_TRACE("RasDialTryNextLink: No more links");

            //
            // Restore the saved error if we ran out of
            // links
            //
            if(     (ERROR_PORT_NOT_AVAILABLE ==
                        prasconncb->dwError)

                &&  (0 != prasconncb->dwSavedError))
            {
                prasconncb->dwError = prasconncb->dwSavedError;
            }

            goto done;
        }
    }

    if(INVALID_HPORT != prasconncb->hport)
    {
        prasconncbT = CreateConnectionBlock(prasconncb);
        if (prasconncbT == NULL)
        {
            prasconncb->dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }
        
        prasconncbT->pLink = prasconncb->pLink;
    }
    else
    {
        //
        // if we haven't gone past state 0 no point in
        // allocating a new connection block. Goto the
        // next link and restart.
        //
        if(RASEDM_DialAll != prasconncb->pEntry->dwDialMode)
        {
            prasconncb->pLink =
                    (PBLINK *) DtlGetData(pdtlnode);
                    
            //
            // Reset this to 0 so that rasman starts looking
            // for an available line on this device from the
            // start.
            //
            prasconncb->dwDeviceLineCounter = 0;

        }                
        else
        {
            //
            // In the case of dial all, we just increment the
            // counter so that the next link in the device is
            // tried.
            //
            prasconncb->dwDeviceLineCounter += 1;
        }

        ASSERT(NULL != prasconncb->pLink);

        //
        // Save the error we received for the previous
        // try.
        //
        if(PENDING != prasconncb->dwError)
        {
            prasconncb->dwSavedError = prasconncb->dwError;
        }

        prasconncb->dwError = 0;

        goto done;
    }

    //
    // No failures from here. If you add anything that
    // fails beyond this point, Free the connectionblock
    // prasconncbT , if it was allocated , at the exit
    // point done. Note that we move to the next link on
    // the alternates list only if the RasDialMachine
    // encountered a failure in the RASCS_PortOpen state.
    // Otherwise just increment the counter so that rasman
    // tries to open the next line on this device -  which
    // will fail in RASCS_PortOpen state if such a line
    // doesn't exist.
    //
    /*
    if( INVALID_HPORT == prasconncb->hport)
    {
        prasconncbT->pLink = (PBLINK *) DtlGetData(pdtlnode);

        ASSERT(NULL != prasconncbT->pLink);
    }
    else
    {
        prasconncbT->pLink = prasconncb->pLink;
    }

    */

    prasconncbT->rasdialparams.dwSubEntry
                    = prasconncb->rasdialparams.dwSubEntry;

    prasconncbT->cPhoneNumbers = prasconncb->cPhoneNumbers;

    prasconncbT->iPhoneNumber = 0;

    prasconncbT->fMultilink = prasconncb->fMultilink;

    prasconncbT->fBundled = prasconncb->fBundled;

    prasconncbT->fTerminated = prasconncb->fTerminated;

    prasconncbT->dwRestartOnError
                    = prasconncb->dwRestartOnError;

    prasconncbT->cDevices = prasconncb->cDevices;

    prasconncbT->iDevice = prasconncb->iDevice;

    prasconncbT->hrasconnOrig = prasconncb->hrasconnOrig;

    prasconncb->fRasdialRestart = TRUE;
    

    prasconncbT->hport = INVALID_HPORT;

    if(NULL == prasconncb->notifier)
    {
        prasconncbT->asyncmachine.hDone = 
            prasconncb->asyncmachine.hDone;
        prasconncb->asyncmachine.hDone = NULL;

        prasconncbT->psyncResult = prasconncb->psyncResult;
        prasconncb->psyncResult = NULL;
    }

    //
    // Save the error we got for the previous
    // try
    //
    if(PENDING != prasconncb->dwError)
    {
        prasconncbT->dwSavedError =
                prasconncb->dwError;
    }

    prasconncbT->dwError = 0;

    prasconncbT->dwDeviceLineCounter
            = prasconncb->dwDeviceLineCounter + 1;

    dwErr = ResetAsyncMachine(&prasconncbT->asyncmachine);

    prasconncbT->rasconnstate = 0;

    *pprasconncb = prasconncbT;
    RASAPI32_TRACE2(
        "RasdialTryNextLink: Replacing 0x%x with 0x%x",
        prasconncb, prasconncbT);

    //
    // NULL out the notifier for prasconncb - we don't
    // want to call back on this link anymore..
    //
    prasconncb->notifier = NULL;


    if(INVALID_HPORT != prasconncb->hport)
    {

        RASAPI32_TRACE2("RasDialTryNextLink:iDevice=%d,"
                "cDevices=%d",
                prasconncb->iDevice,
                prasconncb->cDevices);

        if(     (prasconncb->rasconnstate >= RASCS_DeviceConnected)
            ||  (prasconncb->iDevice > 1))
        {
            //
            // This means we tried to dial a switch which failed
            // to connect and so we should bring down the modem
            // connection before closing the  port.
            //
            RASAPI32_TRACE1("RasDialTryNextLink: RasPortDisconnect(%d)...",
                    prasconncb->hport);

            dwErr = g_pRasPortDisconnect(prasconncb->hport,
                                         INVALID_HANDLE_VALUE);

            RASAPI32_TRACE1("RasDialTryNextLink: RasPortDisconnect done(%d)",
                    dwErr);
        }                
    
        RASAPI32_TRACE1("RasDialTryNextLink: RasPortClose(%d)...",
                prasconncb->hport);

        dwErr = g_pRasPortClose(prasconncb->hport);

        RASAPI32_TRACE1("RasDialTryNextLink: RasPortClose done(%d)",
               dwErr);

        RASAPI32_TRACE("(ER) RasPppStop...");

        g_pRasPppStop(prasconncb->hport);

        RASAPI32_TRACE("(ER) RasPppStop done");

        //
        // Save the error here - otherwise we may end up giving the
        // horrible ERROR_DISCONNECTION error
        //
        prasconncb->dwSavedError = prasconncb->dwError;
    }


done:

    RASAPI32_TRACE1("RasDialTryNextLink done(%d)", dwErr);

    return;
}


/*++

Routine Description:


Arguments:


Return Value:

        void

--*/
VOID
RasDialTryNextVpnDevice(RASCONNCB **pprasconncb)
{
    DWORD dwErr = SUCCESS;

    RASCONNCB *prasconncb = *pprasconncb;

    RASCONNCB *prasconncbT;

    DTLNODE *pdtlnode;

    CHAR szDeviceName[MAX_DEVICE_NAME + 1];

    RASDEVICETYPE rdt;

    DWORD dwVpnStrategy = prasconncb->pEntry->dwVpnStrategy;

    TCHAR *pszDeviceName = NULL;

    RASAPI32_TRACE("RasDialTryNextVpnDevice...");

    ASSERT(RASET_Vpn == prasconncb->pEntry->dwType);

    ASSERT(prasconncb->dwCurrentVpnProt < NUMVPNPROTS);

    prasconncb->dwCurrentVpnProt += 1;

    //
    // If autodetect mode is not set or if
    // we have already tried both vpn devices
    // quit.
    //
    if(     (VS_PptpOnly == dwVpnStrategy)
        ||  (VS_L2tpOnly == dwVpnStrategy))
    {
        goto done;
    }

    // If we've exhausted all vpn protocols, then send the
    // specific error that explains this to the user
    //
    // Whistler Bug 
    //
    if (prasconncb->dwCurrentVpnProt >= NUMVPNPROTS)
    {
        prasconncb->dwError = dwErr = ERROR_AUTOMATIC_VPN_FAILED;
        goto done;
    }
    
    rdt = prasconncb->ardtVpnProts[prasconncb->dwCurrentVpnProt];

    /*
    //
    // Get the device
    //
    RASAPI32_TRACE1("RasGetDeviceName(%d)..",
           rdt);

    dwErr = g_pRasGetDeviceName(rdt,
                                szDeviceName);

    RASAPI32_TRACE1("RasGetDeviceName. rc=%d",
           dwErr);

    if(ERROR_SUCCESS != dwErr)
    {
        //
        // Clear the error
        //
        prasconncb->dwError = ERROR_SUCCESS;
        goto done;
    }

    pszDeviceName = StrDupTFromA(szDeviceName);

    if(NULL == pszDeviceName)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    //
    // Set the device
    //
    Free0(prasconncb->pLink->pbport.pszDevice);

    prasconncb->pLink->pbport.pszDevice = pszDeviceName; */

    if(INVALID_HPORT == prasconncb->hport)
    {
        if(PENDING != prasconncb->dwError)
        {
            prasconncb->dwSavedError = prasconncb->dwError;
        }
        prasconncb->dwError = ERROR_SUCCESS;
        goto done;
    }

    prasconncbT = CreateConnectionBlock(prasconncb);

    if (prasconncbT == NULL)
    {
        prasconncb->dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    //
    // No failures from here. If you add anything that
    // fails beyond this point, Free the connectionblock
    // prasconncbT , if it was allocated , at the exit
    // point done.
    //
    prasconncbT->rasdialparams.dwSubEntry
                    = prasconncb->rasdialparams.dwSubEntry;

    prasconncbT->cPhoneNumbers = prasconncb->cPhoneNumbers;

    prasconncbT->iPhoneNumber = 0;

    prasconncbT->fMultilink = prasconncb->fMultilink;

    prasconncbT->fBundled = prasconncb->fBundled;

    prasconncbT->fTerminated = prasconncb->fTerminated;

    prasconncbT->dwRestartOnError
                    = prasconncb->dwRestartOnError;

    prasconncbT->cDevices = prasconncb->cDevices;

    prasconncbT->iDevice = prasconncb->iDevice;

    prasconncbT->hrasconnOrig = prasconncb->hrasconnOrig;

    prasconncbT->fRasdialRestart = TRUE;

    prasconncbT->hport = INVALID_HPORT;

    prasconncbT->pLink = prasconncb->pLink;

    prasconncbT->cAddresses = prasconncbT->iAddress = 0;
    prasconncbT->pAddresses = NULL;

    if(PENDING != prasconncb->dwError)
    {
        prasconncbT->dwSavedError = prasconncb->dwError;
    }

    if(NULL == prasconncb->notifier)
    {
        prasconncbT->asyncmachine.hDone = 
                            prasconncb->asyncmachine.hDone;
        prasconncb->asyncmachine.hDone = NULL;

        prasconncbT->psyncResult = prasconncb->psyncResult;
        prasconncb->psyncResult = NULL;
    }

    prasconncb->notifier = NULL;
    
    prasconncbT->dwError = 0;

    dwErr = ResetAsyncMachine(&prasconncbT->asyncmachine);

    prasconncbT->rasconnstate = 0;

    *pprasconncb = prasconncbT;

    RASAPI32_TRACE2(
        "RasDialTryNextVpnDevice: Replacing 0x%x with 0x%x",
        prasconncb, prasconncbT);


    if(INVALID_HPORT != prasconncb->hport)
    {
        RASAPI32_TRACE1("RasDialTryNextVpnDevice: RasPortClose(%d)...",
                prasconncb->hport);

        dwErr = g_pRasPortClose(prasconncb->hport);

        RASAPI32_TRACE1("RasDialTryNextVpnDevice: RasPortClose done(%d)",
               dwErr);

        RASAPI32_TRACE("(ER) RasPppStop...");

        g_pRasPppStop(prasconncb->hport);

        RASAPI32_TRACE("(ER) RasPppStop done");
    }


done:

    RASAPI32_TRACE1("RasDialTryNextVpnDevice done(%d)",
           dwErr);

    return;
}

VOID
StartSubentries(
    IN RASCONNCB *prasconncb
    )
{
    PLIST_ENTRY pEntry;

    //
    // Kickstart the async machine for all subentries
    // in a connection.
    //
    RASAPI32_TRACE1(
      "starting subentry %d",
      prasconncb->rasdialparams.dwSubEntry);
    SignalDone(&prasconncb->asyncmachine);

    for (pEntry = prasconncb->ListEntry.Flink;
         pEntry != &prasconncb->ListEntry;
         pEntry = pEntry->Flink)
    {
        RASCONNCB *prcb =
            CONTAINING_RECORD(pEntry, RASCONNCB, ListEntry);

        if (!prcb->fRasdialRestart)
        {
            RASAPI32_TRACE1(
              "starting subentry %d",
              prcb->rasdialparams.dwSubEntry);

            SignalDone(&prcb->asyncmachine);
        }
    }
}


VOID
SuspendSubentries(
    IN RASCONNCB *prasconncb
    )
{
    PLIST_ENTRY pEntry;

    //
    // Suspend all subentries in the connection except
    // for the supplied one.
    //
    for (pEntry = prasconncb->ListEntry.Flink;
         pEntry != &prasconncb->ListEntry;
         pEntry = pEntry->Flink)
    {
        RASCONNCB *prcb =
            CONTAINING_RECORD(pEntry, RASCONNCB, ListEntry);

        if (!prcb->fRasdialRestart)
        {
            RASAPI32_TRACE1(
              "suspending subentry %d",
              prcb->rasdialparams.dwSubEntry);

            prcb->dwfSuspended = SUSPEND_InProgress;
        }
    }
}


BOOLEAN
IsSubentriesSuspended(
    IN RASCONNCB *prasconncb
    )
{
    BOOLEAN fSuspended = FALSE;
    PLIST_ENTRY pEntry;

    for (pEntry = prasconncb->ListEntry.Flink;
         pEntry != &prasconncb->ListEntry;
         pEntry = pEntry->Flink)
    {
        RASCONNCB *prcb =
            CONTAINING_RECORD(pEntry, RASCONNCB, ListEntry);

        fSuspended = (prcb->dwfSuspended == SUSPEND_InProgress);

        if (fSuspended)
        {
            break;
        }
    }

    return fSuspended;
}


VOID
RestartSubentries(
    IN RASCONNCB *prasconncb
    )
{
    PLIST_ENTRY pEntry;

    for (pEntry = prasconncb->ListEntry.Flink;
         pEntry != &prasconncb->ListEntry;
         pEntry = pEntry->Flink)
    {
        RASCONNCB *prcb =
            CONTAINING_RECORD(pEntry, RASCONNCB, ListEntry);

        //
        // Resume the suspended async machines.
        //
        SuspendAsyncMachine(&prcb->asyncmachine, FALSE);

        prcb->dwfSuspended = SUSPEND_Start;

    }
}


VOID
ResumeSubentries(
    IN RASCONNCB *prasconncb
    )
{
    PLIST_ENTRY pEntry;

    //
    // Restart all subentries in the connection except
    // for the supplied one.
    //
    for (pEntry = prasconncb->ListEntry.Flink;
         pEntry != &prasconncb->ListEntry;
         pEntry = pEntry->Flink)
    {
        RASCONNCB *prcb =
            CONTAINING_RECORD(pEntry, RASCONNCB, ListEntry);

        RASAPI32_TRACE1(
          "resuming subentry %d",
          prcb->rasdialparams.dwSubEntry);

        //
        // Resume the suspended async machines.
        //
        SuspendAsyncMachine(&prcb->asyncmachine, FALSE);
        prcb->dwfSuspended = SUSPEND_Done;
    }
}


VOID
SyncDialParamsSubentries(
    IN RASCONNCB *prasconncb
    )
{
    PLIST_ENTRY pEntry;
    DWORD dwSubEntry;

    //
    // Reset the rasdialparams for all subentries except
    // for the supplied one.
    //
    SafeEncodePasswordBuf(prasconncb->rasdialparams.szPassword);
    SafeEncodePasswordBuf(prasconncb->szOldPassword);

    for (pEntry = prasconncb->ListEntry.Flink;
         pEntry != &prasconncb->ListEntry;
         pEntry = pEntry->Flink)
    {
        RASCONNCB *prcb =
            CONTAINING_RECORD(pEntry, RASCONNCB, ListEntry);

        RASAPI32_TRACE1(
          "syncing rasdialparams for subentry %d",
          prcb->rasdialparams.dwSubEntry);

        dwSubEntry = prcb->rasdialparams.dwSubEntry;

        SafeWipePasswordBuf(
            prcb->rasdialparams.szPassword);

        SafeDecodePasswordBuf(prasconncb->rasdialparams.szPassword);
           
        memcpy(
          (CHAR *)&prcb->rasdialparams,
          (CHAR *)&prasconncb->rasdialparams,
          prasconncb->rasdialparams.dwSize);

        SafeEncodePasswordBuf(prasconncb->rasdialparams.szPassword);
        SafeEncodePasswordBuf(prcb->rasdialparams.szPassword);

        prcb->rasdialparams.dwSubEntry = dwSubEntry;

        
    }

    SafeDecodePasswordBuf(prasconncb->rasdialparams.szPassword);
    SafeDecodePasswordBuf(prasconncb->szOldPassword);
    
}


VOID
SetSubentriesBundled(
    IN RASCONNCB *prasconncb
    )
{
    PLIST_ENTRY pEntry;
    HPORT hport;

    RASAPI32_TRACE("SetSubEntriesBundled");

    //
    // Set that we have received full
    // projection information from one
    // of the links.
    //
    prasconncb->fBundled = TRUE;
    for (pEntry = prasconncb->ListEntry.Flink;
         pEntry != &prasconncb->ListEntry;
         pEntry = pEntry->Flink)
    {
        RASCONNCB *prcb =
            CONTAINING_RECORD(pEntry, RASCONNCB, ListEntry);

        prcb->fBundled = TRUE;
    }
}


RASCONNSTATE
MapSubentryState(
    IN RASCONNCB *prasconncb
    )
{
    RASCONNSTATE rasconnstate = prasconncb->rasconnstate;

    if (!IsListEmpty(&prasconncb->ListEntry)) {

        //
        // If there are still subentries attempting to
        // connect, then map the connected/disconnected
        // states into subentry states.
        //
        if (prasconncb->rasconnstate == RASCS_Connected)
        {
            rasconnstate = RASCS_SubEntryConnected;
        }
        else if (prasconncb->rasconnstate == RASCS_Disconnected)
        {
            rasconnstate = RASCS_SubEntryDisconnected;
        }
    }

    return rasconnstate;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\extapi\src\rf.h ===
/*****************************************************************************
**              Microsoft Rasfile Library
**              Copyright (C) Microsoft Corp., 1992
**
** File Name : rf.h
**
** Revision History :
**      July 10, 1992   David Kays      Created
**
** Description :
**      Rasfile file internal header.
******************************************************************************/

#ifndef _RF_
#define _RF_

// Un-comment these, or use C_DEFINES in sources to turn on Unicode
// #define _UNICODE
// #define UNICODE

#include <stdarg.h>     /* For va_list */

#include <excpt.h>      /* for EXCEPTION_DISPOSITION in winbase.h */
#include <windef.h>     /* definition of common types */
#include <winbase.h>    /* win API exports */
#include <winnt.h>      /* definition of string types, e.g. LPSTR */

#ifndef _UNICODE
#include <winnls.h>
#include <mbstring.h>
#define  _MyCMB(_s) ((const unsigned char *)(_s))
#endif

#include <stddef.h>
#include <tchar.h>
#include <stdlib.h>
#include <string.h>
#include <share.h>

#include "rasfile.h"

//kslksl
#define  DEBUG_MEMORY

#ifdef DEBUG_MEMORY
//kslksl
typedef struct _MEM_HDR {
    LIST_ENTRY Link;
    ULONG Signature;
    ULONG Id;
    PDWORD Tail;
} MEM_HDR, *PMEM_HDR;   

PVOID
DebugAlloc(
    DWORD sz,
    DWORD Flags,
    DWORD Id
    );
VOID
DebugFree(
    PVOID mem
    );
    
#endif

typedef struct _RASFILE;

LPVOID
PrivMalloc(DWORD sz, struct _RASFILE * pRasfile);

VOID
PrivFree(struct _RASFILE * pRasfile);


/* Heap allocation macros allowing easy substitution of alternate heap.  These
** are used by the other utility sections.
*/
#ifndef EXCL_HEAPDEFS
/* kslksl
#define Malloc(c)    (void*)GlobalAlloc(0,(c))
#define Realloc(p,c) (void*)GlobalReAlloc((p),(c),GMEM_MOVEABLE)
#define Free(p)      (void*)GlobalFree(p)
*/
#ifdef DEBUG_MEMORY
#define Malloc(c)    (void*)DebugAlloc((c), 0 , 1)
//#define Realloc(p,c) (void*)HeapReAlloc(GetProcessHeap(), 0, (p),(c))
#define Free(p)      DebugFree(p)

#elif
#define Malloc(c)    (void*)HeapAlloc(GetProcessHeap(),0,(c))
#define Realloc(p,c) (void*)HeapReAlloc(GetProcessHeap(), 0, (p),(c))
#define Free(p)      (void*)HeapFree(GetProcessHeap(), 0, p)

#endif
#endif

// line tags
typedef BYTE            LineType;
#define TAG_SECTION     RFL_SECTION
#define TAG_HDR_GROUP   RFL_GROUP
#define TAG_BLANK       RFL_BLANK
#define TAG_COMMENT     RFL_COMMENT
#define TAG_KEYVALUE    RFL_KEYVALUE
#define TAG_COMMAND     RFL_COMMAND

// states during file loading
#define SEEK            1
#define FILL            2

// for searching, finding, etc.
#define BEGIN           1
#define END             2
#define NEXT            3
#define PREV            4

#define FORWARD         1
#define BACKWARD        2


//
// RASFILE parameters
//

// move rasfile parameters into ras\inc\rasfile.h so that ui\common can also 
// used them

#define LBRACKETSTR             "["
#define RBRACKETSTR             "]"
#define LBRACKETCHAR            '['
#define RBRACKETCHAR            ']'

//
// line buffer linked list - one linked list per section
//
typedef struct LineNode
{
    struct LineNode *next;
    struct LineNode *prev;
    CHAR            *pszLine;   // char buffer holding the line
    BYTE            mark;       // user defined mark for this line
    LineType        type;       // is this line a comment?
} *PLINENODE;

#define newLineNode(pRasfile)       (PLINENODE) PrivMalloc(sizeof(struct LineNode), pRasfile)

//
// Private Memory structure
//
typedef struct
{
    LIST_ENTRY  List;
    PCHAR       pvCurPtr;
    DWORD       dwMemoryFree;
} PRIV_MEM, *PPRIV_MEM;


//
// RASFILE control block
//
typedef struct _RASFILE
{
    PLINENODE   lpRasLines;     // list of loaded RASFILE lines
    PLINENODE   lpLine;         // pointer to current line node
    PFBISGROUP  pfbIsGroup;     // user function which determines if
                                //       a line is a group delimiter
    HANDLE      hFile;          // file handle
    DWORD       dwMode;         // file mode bits
    BOOL        fDirty;         // file modified bit
    CHAR        *lpIOBuf;       // temporary I/O buffer
    DWORD       dwIOBufIndex;   // index into temp I/O buffer
    CHAR        szFilename [MAX_PATH];      // full file path name
    CHAR        szSectionName [RAS_MAXSECTIONNAME + 1];     // section to load
    PRIV_MEM    PrivMemory;    // private memory for storing strings
} RASFILE;

//
// internal utility routines
//

// list routine
VOID            listInsert(PLINENODE l, PLINENODE elem);

// rffile.c support
BOOL            rasLoadFile( RASFILE * );
LineType        rasParseLineTag( RASFILE *, LPCSTR );
LineType        rasGetLineTag( RASFILE *, LPCSTR );
BOOL            rasInsertLine( RASFILE *, LPCSTR, BYTE, BYTE * );
BOOL            rasWriteFile( RASFILE *, LPCSTR );
BOOL            rasGetFileLine( RASFILE *, LPSTR, DWORD * );
BOOL            rasPutFileLine( HANDLE, LPCSTR );

// rfnav.c support
PLINENODE       rasNavGetStart( RASFILE *, RFSCOPE, BYTE );
BOOL            rasLineInScope( RASFILE *, RFSCOPE );
PLINENODE       rasGetStartLine (RASFILE *, RFSCOPE, BYTE );
BOOL            rasFindLine( HRASFILE , BYTE, RFSCOPE, BYTE, BYTE );
VOID            rasExtractSectionName( LPCSTR, LPSTR );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\extapi\src\tstr.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    tstr.h

ABSTRACT
    String conversion routines

AUTHOR
    Anthony Discolo (adiscolo) 19-Dec-1996

REVISION HISTORY

--*/

#ifndef _TSTR_H_
#define _TSTR_H_

CHAR *
StrdupWtoA(
    IN LPCWSTR psz,
    IN DWORD dwCp
    );

WCHAR *
StrdupAtoW(
    IN LPCSTR psz,
    IN DWORD dwCp
    );

VOID
StrncpyWtoA(
    OUT CHAR *pszDst,
    IN LPCWSTR pszSrc,
    INT cb,
    IN DWORD dwCp
    );

VOID
StrncpyAtoW(
    OUT WCHAR *pszDst,
    IN LPCSTR pszSrc,
    INT cb,
    IN DWORD dwCp
    );

CHAR *
strdupA(
    IN LPCSTR psz
    );

WCHAR *
strdupW(
    IN LPCWSTR psz
    );

size_t
wcslenU(
    IN const WCHAR UNALIGNED *psz
    );

WCHAR *
strdupWU(
    IN const WCHAR UNALIGNED *psz
    );

// 
// Define string conversion variants for code pages used
// in public RAS api's.
//
#define strdupWtoA(_x) StrdupWtoA((_x), CP_UTF8)
#define strdupAtoW(_x) StrdupAtoW((_x), CP_UTF8)
#define strncpyWtoA(_x, _y, _z) StrncpyWtoA((_x), (_y), (_z), CP_UTF8)
#define strncpyAtoW(_x, _y, _z) StrncpyAtoW((_x), (_y), (_z), CP_UTF8)

#define strdupWtoAAnsi(_x) StrdupWtoA((_x), CP_ACP)
#define strdupAtoWAnsi(_x) StrdupAtoW((_x), CP_ACP)
#define strncpyWtoAAnsi(_x, _y, _z) StrncpyWtoA((_x), (_y), (_z), CP_ACP)
#define strncpyAtoWAnsi(_x, _y, _z) StrncpyAtoW((_x), (_y), (_z), CP_ACP)

#ifdef UNICODE
#define strdupTtoA      strdupWtoA
#define strdupTtoW      strdupW
#define strdupAtoT      strdupAtoW
#define strdupWtoT      strdupW
#define strncpyTtoA     strncpyWtoA
#define strncpyTtoW     wcsncpy
#define strncpyAtoT     strncpyAtoW
#define strncpyWtoT     wcsncpy

#define strdupTtoAAnsi      strdupWtoAAnsi
#define strdupTtoWAnsi      strdupW
#define strdupAtoTAnsi      strdupAtoWAnsi
#define strdupWtoTAnsi      strdupW
#define strncpyTtoAAnsi     strncpyWtoAAnsi
#define strncpyTtoWAnsi     wcsncpy
#define strncpyAtoTAnsi     strncpyAtoWAnsi
#define strncpyWtoTAnsi     wcsncpy

#else
#define strdupTtoA      strdupA
#define strdupTtoW      strdupAtoW
#define strdupAtoT      strdupA
#define strdupWtoT      strdupWtoA
#define strncpyTtoA     strncpy
#define strncpyTtoW     strncpyAtoW
#define strncpyAtoT     strncpy
#define strncpyWtoT     strncpyWtoA

#define strdupTtoAAnsi      strdupA
#define strdupTtoWAnsi      strdupAtoWAnsi
#define strdupAtoTAnsi      strdupA
#define strdupWtoTAnsi      strdupWtoAAnsi
#define strncpyTtoAAnsi     strncpy
#define strncpyTtoWAnsi     strncpyAtoWAnsi
#define strncpyAtoTAnsi     strncpy
#define strncpyWtoTAnsi     strncpyWtoAAnsi

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\extapi\src\rfedit.c ===
/*****************************************************************************
**              Microsoft Rasfile Library
**              Copyright (C) Microsoft Corp., 1992
**
** File Name : rfedit.c
**
** Revision History :
**      July 10, 1992   David Kays      Created
**
** Description :
**      Rasfile file line editing routines.
******************************************************************************/

#include "rf.h"
#include "mbstring.h"

extern RASFILE *gpRasfiles[];

//
// .Net bug# 512378 Possible random memory access. unvalidated value used as
// array index
//
// move the macro into ras\inc\rasfile.h so that ui\common directory can also 
// use them

/*
 * RasfileGetLine :
 *      Returns a readonly pointer to the current line.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *
 * Return Values :
 *      A valid string pointer if there is a current line, NULL otherwise.
 */
const LPCSTR APIENTRY
RasfileGetLine( HRASFILE hrasfile )
{
    RASFILE     *pRasfile;

    if (!VALIDATEHRASFILE(hrasfile))
    {
        return NULL;
    }

    pRasfile = gpRasfiles[hrasfile];

    if (pRasfile->lpLine == pRasfile->lpRasLines)
        return NULL;

    return pRasfile->lpLine->pszLine;
}

/*
 * RasfileGetLineText :
 *      Loads caller's buffer with the text of the current line.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      lpszLine - the buffer to load with the current line.
 *
 * Return Values :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfileGetLineText( HRASFILE hrasfile, LPSTR lpszLine )
{
    RASFILE     *pRasfile;

    if (!VALIDATEHRASFILE(hrasfile))
    {
        return FALSE;
    }

    pRasfile = gpRasfiles[hrasfile];

    if (pRasfile->lpLine == pRasfile->lpRasLines)
        return FALSE;

    lstrcpynA(lpszLine, pRasfile->lpLine->pszLine, RAS_MAXLINEBUFLEN);
    return TRUE;
}

/*
 * RasfilePutLineText :
 *      Set the text of the current line to the given text.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      lpszLine - buffer containing new line text.
 *
 * Return Values :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfilePutLineText( HRASFILE hrasfile, LPCSTR lpszLine )
{
    RASFILE     *pRasfile;

    if (!VALIDATEHRASFILE(hrasfile))
    {
        return FALSE;
    }

    pRasfile = gpRasfiles[hrasfile];

    if (lstrlenA(lpszLine) > RAS_MAXLINEBUFLEN)
        return FALSE;
    if (pRasfile->lpLine == pRasfile->lpRasLines)
        return FALSE;

    if (lstrlenA(lpszLine) > lstrlenA(pRasfile->lpLine->pszLine))
    {
        CHAR* psz = PrivMalloc(lstrlenA(lpszLine) + 1, pRasfile );
        if (psz)
            pRasfile->lpLine->pszLine=psz;
        else
            return FALSE;
    }

    lstrcpynA(pRasfile->lpLine->pszLine, lpszLine, RAS_MAXLINEBUFLEN);

    pRasfile->lpLine->type = rasParseLineTag(pRasfile,lpszLine);

    pRasfile->fDirty = TRUE;
    return TRUE;
}

/*
 * RasfileGetLineMark :
 *      Returns the user-defined mark value for the current line.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *
 * Return Values :
 *      The current line's mark value or 0 if there is no current line
 *      or the current line is not marked.
 */
BYTE APIENTRY
RasfileGetLineMark( HRASFILE hrasfile )
{
    RASFILE     *pRasfile;

    if (!VALIDATEHRASFILE(hrasfile))
    {
        return FALSE;
    }

    pRasfile = gpRasfiles[hrasfile];

    if (pRasfile->lpLine == pRasfile->lpRasLines)
        return FALSE;

    return pRasfile->lpLine->mark;
}

/*
 * RasfilePutLineMark :
 *      Marks the current line with the given number.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      bMark - value to mark the current line with.
 *
 * Return Values :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfilePutLineMark( HRASFILE hrasfile, BYTE bMark )
{
    RASFILE     *pRasfile;

    if (!VALIDATEHRASFILE(hrasfile))
    {
        return FALSE;
    }

    pRasfile = gpRasfiles[hrasfile];

    if (pRasfile->lpLine == pRasfile->lpRasLines)
        return FALSE;

    pRasfile->lpLine->mark = bMark;
    return TRUE;
}

/*
 * RasfileGetLineType :
 *      Returns the current line's type bit mask.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *
 * Return Values :
 *      The current line's bit mask if current line is valid, 0 otherwise.
 */
BYTE APIENTRY
RasfileGetLineType( HRASFILE hrasfile )
{
    RASFILE     *pRasfile;

    if (!VALIDATEHRASFILE(hrasfile))
    {
        return FALSE;
    }

    pRasfile = gpRasfiles[hrasfile];

    if (pRasfile->lpLine == pRasfile->lpRasLines)
        return FALSE;

    return pRasfile->lpLine->type & RFL_ANY;
}

/*
 * RasfileInsertLine :
 *      Inserts a line before or after the current line with the
 *      given text.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      lpszLine - the text of the inserted line.
 *      fBefore - TRUE to insert before the current line, FALSE to
 *                insert after the current line.
 *
 * Return Values :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfileInsertLine( HRASFILE hrasfile, LPCSTR lpszLine, BOOL fBefore )
{
    RASFILE     *pRasfile;
    PLINENODE   lpLineNode;

    if (!VALIDATEHRASFILE(hrasfile))
    {
        return FALSE;
    }

    pRasfile = gpRasfiles[hrasfile];

    if (!(lpLineNode = newLineNode(pRasfile)))
        return FALSE;

    {
        CHAR* psz = PrivMalloc(lstrlenA(lpszLine) + 1, pRasfile);

        if (psz)
            lpLineNode->pszLine = psz;
        else
        {
            return FALSE;
        }
    }

    lstrcpynA(lpLineNode->pszLine, lpszLine, lstrlenA(lpszLine) + 1);
    lpLineNode->type = rasParseLineTag(pRasfile,lpszLine);
    lpLineNode->mark = 0;

    if (fBefore)
        listInsert(pRasfile->lpLine->prev,lpLineNode);
    else
        listInsert(pRasfile->lpLine,lpLineNode);

    pRasfile->fDirty = TRUE;
    return TRUE;
}

/*
 * RasfileDeleteLine :
 *      Delete the current line.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *
 * Return Values :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfileDeleteLine( HRASFILE hrasfile )
{
    RASFILE     *pRasfile;
    PLINENODE   lpOldLine;

    if (!VALIDATEHRASFILE(hrasfile))
    {
        return FALSE;
    }

    pRasfile = gpRasfiles[hrasfile];

    if (pRasfile->lpLine == pRasfile->lpRasLines)
        return FALSE;

    lpOldLine = pRasfile->lpLine;
    pRasfile->lpLine = lpOldLine->next;

    /* delete lpOldLine from the list of lines */
    lpOldLine->next->prev = lpOldLine->prev;
    lpOldLine->prev->next = lpOldLine->next;

    pRasfile->fDirty = TRUE;
    return TRUE;
}

/*
 * RasfileGetSectionName :
 *      Return the current section name in the given buffer.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      lpszSectionName - buffer to load the section name into.
 *
 * Return Values :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfileGetSectionName( HRASFILE hrasfile, LPSTR lpszSectionName )
{
    RASFILE* pRasfile;

    if (!VALIDATEHRASFILE(hrasfile))
    {
        return FALSE;
    }

    pRasfile = gpRasfiles[ hrasfile ];

    if (pRasfile->lpLine == pRasfile->lpRasLines)
        return FALSE;
    if (!(pRasfile->lpLine->type & TAG_SECTION))
        return FALSE;

    rasExtractSectionName( pRasfile->lpLine->pszLine, lpszSectionName );
    return TRUE;
}

/*
 * RasfilePutSectionName :
 *      Set the current line to a section line of the given name.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      lpszSectionName - name of the section.
 *
 * Return Values :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfilePutSectionName( HRASFILE hrasfile, LPCSTR lpszSectionName )
{
    INT iSize = 0;
    RASFILE     *pRasfile;

    if (!VALIDATEHRASFILE(hrasfile))
    {
        return FALSE;
    }

    pRasfile = gpRasfiles[hrasfile];

    if (pRasfile->lpLine == pRasfile->lpRasLines)
        return FALSE;

    iSize = lstrlenA(lpszSectionName);

    /* remember to include '[' and ']' in string length for section */
    if ((iSize + 2) > lstrlenA(pRasfile->lpLine->pszLine))
    {
        CHAR* psz = PrivMalloc(iSize + 3, pRasfile);

        if (psz)
            pRasfile->lpLine->pszLine=psz;
        else
            return FALSE;
    }
    lstrcpynA(pRasfile->lpLine->pszLine, LBRACKETSTR, iSize + 3);

    strncat(
        pRasfile->lpLine->pszLine,
        lpszSectionName,
        (iSize + 3) - strlen(pRasfile->lpLine->pszLine));

    strncat(
        pRasfile->lpLine->pszLine,
        RBRACKETSTR,
        (iSize + 3) - strlen(pRasfile->lpLine->pszLine));

    pRasfile->lpLine->type = TAG_SECTION;

    pRasfile->fDirty = TRUE;
    return TRUE;
}

/*
 * RasfileGetKeyValueFields :
 *      Returns the key and value fields from a KEYVALUE line into the
 *      given buffers.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      lpszKey - buffer to load the key into.
 *      lpszValue - buffer to load the value string into.
 *
 * Return Values :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfileGetKeyValueFields( HRASFILE hrasfile, LPSTR lpszKey, LPSTR lpszValue )
{
    RASFILE     *pRasfile;
    CHAR        *lpszLine;
    CHAR        *pch;
    INT         cchKey;

    if (!VALIDATEHRASFILE(hrasfile))
    {
        return FALSE;
    }

    pRasfile = gpRasfiles[hrasfile];

    if (pRasfile->lpLine == pRasfile->lpRasLines)
        return FALSE;
    if (!(pRasfile->lpLine->type & TAG_KEYVALUE ))
        return FALSE;

    lpszLine = pRasfile->lpLine->pszLine;

    // skip white space
    //
    while ((*lpszLine == ' ') || (*lpszLine == '\t'))
    {
        lpszLine++;
    }

    // find the position of the first delimiter for keywords
    //
    cchKey = 0;
    pch = lpszLine;
    while ((*pch != '=') && (*pch != ' ') && (*pch != '\t') && *pch)
    {
        pch++;
        cchKey++;
    }

    if (lpszKey != NULL)
    {
        // Copy the key we just identified to the output parameter.
        // Add the extra 1 for the way lstrcpyn works.  (It includes the
        // null terminator it always copies in the count.)
        //
        lstrcpynA(lpszKey, lpszLine, cchKey + 1);
    }

    // find beginning of value string - skip white space and '='
    //
    while ((*pch == ' ') || (*pch == '\t') || (*pch == '='))
    {
        pch++;
    }

    if (lpszValue != NULL)
    {
        lstrcpynA(lpszValue, pch, RAS_MAXLINEBUFLEN);
    }

    return TRUE;
}


/*
 * RasfilePutKeyValueFields :
 *      Sets the current line to a KEYVALUE line with the given key and
 *      value strings.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      lpszKey - buffer containing the key string.
 *      lpszValue - buffer containing the value string.
 *
 * Return Values :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfilePutKeyValueFields( HRASFILE hrasfile, LPCSTR lpszKey, LPCSTR lpszValue )
{
    RASFILE *pRasfile;
    INT     size;

    if (!VALIDATEHRASFILE(hrasfile))
    {
        return FALSE;
    }

    pRasfile = gpRasfiles[hrasfile];

    if (pRasfile->lpLine == pRasfile->lpRasLines)
        return FALSE;
    if ((size = lstrlenA(lpszKey) + lstrlenA(lpszValue)) > RAS_MAXLINEBUFLEN - 1)
        return FALSE;

    /* remember to include the '=' in string length for key=value string */
    if ((size + 1) > lstrlenA(pRasfile->lpLine->pszLine))
    {
        CHAR* psz=PrivMalloc(size + 2, pRasfile);

        if (psz)
            pRasfile->lpLine->pszLine=psz;
        else
            return FALSE;
    }
    lstrcpynA(pRasfile->lpLine->pszLine, lpszKey, size + 2);

    strncat(
        pRasfile->lpLine->pszLine,
        "=",
        (size + 2) - strlen(pRasfile->lpLine->pszLine));

    strncat(
        pRasfile->lpLine->pszLine,
        lpszValue,
        (size + 2) - strlen(pRasfile->lpLine->pszLine));

    pRasfile->lpLine->type =
    rasParseLineTag(pRasfile,pRasfile->lpLine->pszLine);

    pRasfile->fDirty = TRUE;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\extapi\src\rffile.c ===
/*****************************************************************************
**              Microsoft Rasfile Library
**              Copyright (C) Microsoft Corp., 1992
**
** File Name : rffile.c
**
** Revision History :
**      July 10, 1992   David Kays      Created
**      Dec  12, 1992   Ram   Cherala   Added RFM_KEEPDISKFILEOPEN and support
**                                      code.  This is required to ensure that
**                                      multiple users of rasfile can do file
**                                      operations without any problems.
**
** Description :
**        Rasfile file management routines.
******************************************************************************/

#include "rf.h"

ULONG
__cdecl
DbgPrint(
    PCH Format,
    ...
    );

void
__forceinline
InitializeListHead(
     PLIST_ENTRY ListHead
    )
{
    ListHead->Flink = ListHead->Blink = ListHead;
}

void
__forceinline
InsertHeadList(
     PLIST_ENTRY ListHead,
     PLIST_ENTRY Entry
    )
{
    PLIST_ENTRY Flink;

    Flink = ListHead->Flink;
    Entry->Flink = Flink;
    Entry->Blink = ListHead;
    Flink->Blink = Entry;
    ListHead->Flink = Entry;
}
//===============================



/* Global list of pointers to RASFILE control blocks */
RASFILE  *gpRasfiles[MAX_RASFILES];

/*
 * RasfileLoad :
 *      Loads a file for editing/reading.  Sets the current line to the
 *      first line in the file.
 *
 * Arguments :
 *      lpszPath - full path name for file
 *      dwMode   - mode to open the file
 *              RFM_SYSFORMAT - DOS config.sys style file
 *              RFM_CREATE - create file if it does not exist
 *              RFM_READONLY - open file for reading only
 *              RFM_LOADCOMMENTS - load comments also
 *              RFM_ENUMSECTIONS - load section headers only
 *              RFM_KEEPDISKFILEOPEN - donot close the disk file after read
 *      lpszSection - name of the section to load or NULL for all sections
 *      pfbIsGroup - pointer to user-defined function which returns true
 *                   if a line of text is a group delimiter.
 *
 * Return Value :
 *      A handle to the file if successful, -1 otherwise.
 */

HRASFILE APIENTRY
RasfileLoadEx( LPCSTR lpszPath, DWORD dwMode,
             LPCSTR lpszSection, PFBISGROUP pfbIsGroup,
             IN OPTIONAL FILETIME* pTime)
{
    DWORD       shflag;
    HRASFILE    hRasfile;
    RASFILE     *pRasfile;
    static BOOL fInited = FALSE;

    if (! fInited)
    {
        memset(gpRasfiles,0,MAX_RASFILES*sizeof(HRASFILE *));
        fInited = TRUE;
    }

    if (lstrlenA(lpszPath) >= MAX_PATH)
        return -1;

    for (hRasfile = 0; hRasfile < MAX_RASFILES; hRasfile++)
        if (! gpRasfiles[hRasfile])
            break;

    if (hRasfile >= MAX_RASFILES)
        return -1;
    
    if (!(pRasfile = (RASFILE *) Malloc(sizeof(RASFILE))))
        return -1;

    gpRasfiles[hRasfile] = pRasfile;

    InitializeListHead(&pRasfile->PrivMemory.List); //kslksl
    pRasfile->PrivMemory.dwMemoryFree = 0; //kslksl
    
    pRasfile->dwMode = dwMode;
    if (dwMode & RFM_READONLY)
        shflag = FILE_SHARE_READ | FILE_SHARE_WRITE;  /* read/write access */
    else
        shflag = FILE_SHARE_READ;                     /* deny write access */

    /* if the file doesn't exist and RFM_CREATE is not set then return -1 */
    if (((pRasfile->hFile =
          CreateFileA(lpszPath,GENERIC_READ,shflag,
                      NULL,OPEN_EXISTING,FILE_ATTRIBUTE_READONLY,
                      NULL)) == INVALID_HANDLE_VALUE) &&
        !(dwMode & RFM_CREATE))
    {
        Free(gpRasfiles[hRasfile]);
        gpRasfiles[hRasfile] = NULL;
        return -1;
    }
    else if ((pRasfile->hFile != INVALID_HANDLE_VALUE) &&
             (GetFileType(pRasfile->hFile) != FILE_TYPE_DISK)
            )
    {
        CloseHandle(pRasfile->hFile);
        pRasfile->hFile = INVALID_HANDLE_VALUE;
        Free(gpRasfiles[hRasfile]);
        gpRasfiles[hRasfile] = NULL;
        return -1;
    }

    // Record the last modified time we know about with the file
    //
    if (pTime)
    {
        BOOL fOk;
        BY_HANDLE_FILE_INFORMATION Info;

        fOk = GetFileInformationByHandle(pRasfile->hFile, &Info);
        if (fOk)
        {
            *pTime = Info.ftLastWriteTime;
        }
    }
    
    /* if the file doesn't exist and RFM_CREATE is set then everything is OK,
        we buffer everything we need in memory and thus we don't need to have
        an empty file hanging around */

    lstrcpynA(pRasfile->szFilename, lpszPath, sizeof(pRasfile->szFilename));
    /* if no specific section is to be loaded, or the Rasfile is new,
        set szSectionName[0] to '\0' */
    if (lpszSection == NULL || dwMode & RFM_ENUMSECTIONS ||
        pRasfile->hFile == INVALID_HANDLE_VALUE)
        pRasfile->szSectionName[0] = '\0';  /* no section name to load */
    else
        lstrcpynA(
            pRasfile->szSectionName,
            lpszSection,
            sizeof(pRasfile->szSectionName));

    pRasfile->pfbIsGroup = pfbIsGroup;
    if (! rasLoadFile(pRasfile))
    {
        Free(gpRasfiles[hRasfile]);
        gpRasfiles[hRasfile] = NULL;
        return -1;
    }
    pRasfile->fDirty = FALSE;

/* RAMC changes begin */

    if (!(dwMode & RFM_KEEPDISKFILEOPEN))
    {
        if (pRasfile->hFile != INVALID_HANDLE_VALUE)
        {
            if (! CloseHandle(pRasfile->hFile))
                return -1;
            pRasfile->hFile = INVALID_HANDLE_VALUE ;
        }
    }

/* RAMC changes end */

    return hRasfile;
}

HRASFILE APIENTRY
RasfileLoad( LPCSTR lpszPath, DWORD dwMode,
             LPCSTR lpszSection, PFBISGROUP pfbIsGroup )
{
    return RasfileLoadEx(lpszPath, dwMode, lpszSection, pfbIsGroup, NULL);
}


VOID APIENTRY
RasfileLoadInfo(
               HRASFILE         hrasfile,
               RASFILELOADINFO* pInfo )

/* Loads caller's buffer, 'pInfo' with the original RasfileLoad parameters
** for 'hrasfile'.
*/
{
    if (VALIDATEHRASFILE(hrasfile))
    {
        RASFILE* prasfile = gpRasfiles[hrasfile];

        lstrcpynA(pInfo->szPath, prasfile->szFilename, sizeof(pInfo->szPath));
        pInfo->dwMode = prasfile->dwMode;
        lstrcpynA(
            pInfo->szSection,
            prasfile->szSectionName,
            sizeof(pInfo->szSection));
        pInfo->pfbIsGroup = prasfile->pfbIsGroup;
    }

    return;
}


/*
 * RasfileWrite :
 *      Writes the memory image of the file to disk.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      lpszPath - full path name of file to write to, or NULL to use
 *                 the same name as was used for RasfileLoad().
 *
 * Return Value :
 *      TRUE if successful, FALSE if not.
 */

BOOL APIENTRY
RasfileWrite( HRASFILE hrasfile, LPCSTR lpszPath )
{
    RASFILE     *pRasfile;

    if (!VALIDATEHRASFILE(hrasfile))
    {
        return FALSE;
    }

    pRasfile = gpRasfiles[hrasfile];

    /* don't write the file if it was opened for READONLY, or if
        only a single section was loaded */
    if (pRasfile->dwMode & RFM_READONLY ||
        pRasfile->szSectionName[0] != '\0')
        return FALSE;
    if (! pRasfile->fDirty)
        return TRUE;

    return rasWriteFile(pRasfile,lpszPath);
}



/*
 * RasfileClose :
 *      Closes the file and releases all resources.
 *
 * Arguments :
 *      hrasfile - the file handle of the Rasfile to close.
 *
 * Return Value :
 *      TRUE if successful, FALSE if not.
 */

BOOL APIENTRY
RasfileClose( HRASFILE hrasfile )
{
    RASFILE    *pRasfile;
    PLINENODE  lpLineNode;

    if (!VALIDATEHRASFILE(hrasfile))
    {
        return FALSE;
    }

    pRasfile = gpRasfiles[hrasfile];

    if (pRasfile->hFile != INVALID_HANDLE_VALUE)
        CloseHandle(pRasfile->hFile);

    PrivFree(pRasfile); //kslksl

    Free(pRasfile);
    gpRasfiles[hrasfile] = NULL;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\extapi\src\rfnav.c ===
/*****************************************************************************
**              Microsoft Rasfile Library
**              Copyright (C) Microsoft Corp., 1992
**
** File Name : rfnav.c
**
** Revision History :
**      July 10, 1992   David Kays      Created
**
** Description :
**      Rasfile file navigation routines.
******************************************************************************/

#include <windows.h>
#include "rf.h"

#include <mbstring.h>
#include "tstr.h"
extern RASFILE *gpRasfiles[];

/*
 * RasfileFindFirstLine :
 *      Sets the current line to the first line of the given type in the
 *      given scope.  If the current line is already at the first line
 *      of the given scope, it is not moved and the call is successful.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      bType   - the type(s) of line to search for.
 *      rfscope - the scope of the search.
 *
 * Return Value :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfileFindFirstLine( HRASFILE hrasfile, BYTE bType, RFSCOPE rfscope )
{
    return rasFindLine(hrasfile,bType,rfscope,BEGIN,FORWARD);
}

/*
 * RasfileFindLastLine :
 *      Sets the current line to the last line of the given type in the
 *      given scope.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      bType   - the type(s) of line to search for.
 *      rfscope - the scope of the search.
 *
 * Return Value :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfileFindLastLine( HRASFILE hrasfile, BYTE bType, RFSCOPE rfscope )
{
    return rasFindLine(hrasfile,bType,rfscope,END,BACKWARD);
}

/*
 * RasfileFindPrevLine :
 *      Sets the current line to the nearest preceding line of the given
 *      type in the given scope.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      bType   - the type(s) of line to search for.
 *      rfscope - the scope of the search.
 *
 * Return Value :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfileFindPrevLine( HRASFILE hrasfile, BYTE bType, RFSCOPE rfscope )
{
    return rasFindLine(hrasfile,bType,rfscope,PREV,BACKWARD);
}

/*
 * RasfileFindNextLine :
 *      Sets the current line to the nearest following line of the given
 *      type in the given scope.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      bType   - the type(s) of line to search for.
 *      rfscope - the scope of the search.
 *
 * Return Value :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfileFindNextLine( HRASFILE hrasfile, BYTE bType, RFSCOPE rfscope )
{
    return rasFindLine(hrasfile,bType,rfscope,NEXT,FORWARD);
}

/*
 * RasfileFindNextKeyLine :
 *  Finds the next key value line in the given scope that matches
 *  he given key.
 *
 * Arguments :
 *  hrasfile - file handle obtained from RasfileLoad().
 *  lpszKey     - the key to search for
 *  rfscope - the scope of the search
 *
 * Return Value :
 *  TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfileFindNextKeyLine(HRASFILE hrasfile, LPCSTR lpszKey, RFSCOPE rfscope)
{
    RASFILE     *pRasfile;
    PLINENODE   lpOldLine;
    CHAR        *lpszLine;
    CHAR        *pch;
    size_t      cchKey = lstrlenA(lpszKey);
    size_t      cchToFirstDelim;

    // For whistler 523586
    if (!VALIDATEHRASFILE(hrasfile))
    {
        return FALSE;
    }

    pRasfile = gpRasfiles[hrasfile];

    lpOldLine = pRasfile->lpLine;
    while (1)
    {
        if (!RasfileFindNextLine(hrasfile,RFL_KEYVALUE,rfscope))
            break;

        lpszLine = pRasfile->lpLine->pszLine;

        // skip white space
        //
        while ((*lpszLine == ' ') || (*lpszLine == '\t'))
        {
            lpszLine++;
        }

        // find the position of the first delimiter for keywords
        //
        cchToFirstDelim = 0;
        pch = lpszLine;
        while ((*pch != '=') && (*pch != ' ') && (*pch != '\t') && *pch)
        {
            pch++;
            cchToFirstDelim++;
        }

        if ((cchToFirstDelim == cchKey) &&
            (0 == _strnicmp(lpszLine, lpszKey, cchKey)))
        {
            return TRUE;
        }
        // else continue
    }

    pRasfile->lpLine = lpOldLine;
    return FALSE;
}


/*
 * RasfileFindNextMarkedLine :
 *      Finds the line with the given mark.  The search is started from
 *      the beginning of the file.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      bMark - the mark to search for.
 *
 * Return Value :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfileFindMarkedLine(HRASFILE hrasfile, BYTE bMark)
{
    RASFILE             *pRasfile;
    PLINENODE           lpLineNode;

    if (!VALIDATEHRASFILE(hrasfile))
    {
        return FALSE;
    }

    pRasfile = gpRasfiles[hrasfile];

    for (lpLineNode = pRasfile->lpRasLines->next;
        lpLineNode != pRasfile->lpRasLines;
        lpLineNode = lpLineNode->next)
    {
        if (lpLineNode->mark == bMark)
        {
            pRasfile->lpLine = lpLineNode;
            return TRUE;
        }
    }

    return FALSE;
}

/*
 * RasfileFindSectionLine :
 *      Finds the next section line that matches the given section name.
 *
 * Arguments :
 *  hrasfile - file handle obtained from RasfileLoad().
 *  lpszSection - the section name to search for.
 *  fStartAtBof - TRUE to indicate that the search should start from
 *                the beginning of the file, FALSE to start from the
 *                current line.
 *
 * Return Value :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfileFindSectionLine(HRASFILE hrasfile, LPCSTR lpszSection, BOOL fStartAtBof)
{
    RASFILE   *pRasfile;
    PLINENODE lpLine;
    CHAR*      szSection = NULL;
    WCHAR*     pwszGivenSection = NULL;
    WCHAR*     pwszNextSection = NULL;
    BOOL       bRet = FALSE;

    if (!VALIDATEHRASFILE(hrasfile))
    {
        return FALSE;
    }

    pRasfile = gpRasfiles[hrasfile];

    // Allocate buffers from heap.  XP 339346
    //
    szSection = Malloc(MAX_LINE_SIZE * sizeof(CHAR));
    pwszGivenSection = Malloc(MAX_LINE_SIZE * sizeof(WCHAR));
    pwszNextSection = Malloc(MAX_LINE_SIZE * sizeof(WCHAR));

    if (szSection && pwszGivenSection && pwszNextSection)
    {
        strncpyAtoW(pwszGivenSection, lpszSection, MAX_LINE_SIZE);

        for (lpLine = fStartAtBof ? pRasfile->lpRasLines->next : pRasfile->lpLine;
            lpLine != pRasfile->lpRasLines;
            lpLine = lpLine->next)
        {
            if (lpLine->type & TAG_SECTION)
            {
                rasExtractSectionName( lpLine->pszLine, szSection );

                strncpyAtoW(pwszNextSection, szSection, MAX_LINE_SIZE);

                if (_wcsicmp( pwszGivenSection, pwszNextSection ) == 0)
                {
                    pRasfile->lpLine = lpLine;

                    bRet = TRUE;
                    break;
                }

            }
        }
    }        

    // Cleanup
    if (szSection)        
    {
        Free(szSection);
    }        
    if (pwszGivenSection) 
    {
        Free(pwszGivenSection);
    }        
    if (pwszNextSection)  
    {
        Free(pwszNextSection);
    }        

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\extapi\src\tstr.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    tstr.c

ABSTRACT
    String conversion routines

AUTHOR
    Anthony Discolo (adiscolo) 19-Dec-1996

REVISION HISTORY

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <extapi.h>
#include <tapi.h>


CHAR *
strdupA(
    IN LPCSTR psz
    )
{
    INT cb = strlen(psz);
    CHAR *pszNew = NULL;

    if (cb) {
        pszNew = Malloc(cb + 1);
        if (pszNew == NULL) {
            DbgPrint("strdupA: LocalAlloc failed\n");
            return NULL;
        }
        strncpy(pszNew, psz, cb + 1);
    }

    return pszNew;
}


WCHAR *
strdupW(
    IN LPCWSTR psz
    )
{
    INT cb = wcslen(psz);
    WCHAR *pszNew = NULL;

    if (cb) {
        pszNew = Malloc((cb + 1) * sizeof (WCHAR));
        if (pszNew == NULL) {
            DbgPrint("strdupW: LocalAlloc failed\n");
            return NULL;
        }
        lstrcpyn(pszNew, psz, cb + 1);
    }

    return pszNew;
}


CHAR *
StrdupWtoA(
    IN LPCWSTR psz,
    IN DWORD dwCp
    )
{
    CHAR* pszNew = NULL;

    if (psz != NULL) {
        DWORD cb;

        cb = WideCharToMultiByte(dwCp, 0, psz, -1, NULL, 0, NULL, NULL);
        ASSERT(cb);

        pszNew = (CHAR*)Malloc(cb);
        if (pszNew == NULL) {
            TRACE("strdupWtoA: Malloc failed");
            return NULL;
        }

        cb = WideCharToMultiByte(dwCp, 0, psz, -1, pszNew, cb, NULL, NULL);
        if (!cb) {
            Free(pszNew);
            TRACE("strdupWtoA: conversion failed");
            return NULL;
        }
    }

    return pszNew;
}


WCHAR *
StrdupAtoW(
    IN LPCSTR psz,
    IN DWORD dwCp
    )
{
    WCHAR* pszNew = NULL;

    if (psz != NULL) {
        DWORD cb;

        cb = MultiByteToWideChar(dwCp, 0, psz, -1, NULL, 0);
        ASSERT(cb);

        pszNew = Malloc(cb * sizeof(WCHAR));
        if (pszNew == NULL) {
            TRACE("strdupAtoW: Malloc failed");
            return NULL;
        }

        cb = MultiByteToWideChar(dwCp, 0, psz, -1, pszNew, cb);
        if (!cb) {
            Free(pszNew);
            TRACE("strdupAtoW: conversion failed");
            return NULL;
        }
    }

    return pszNew;
}


VOID
StrncpyWtoA(
    OUT CHAR *pszDst,
    IN LPCWSTR pszSrc,
    INT cb,
    DWORD dwCp
    )
{
    *pszDst = '\0';
    if (pszSrc != NULL) {
        if (!WideCharToMultiByte(dwCp, 0, pszSrc, -1, pszDst, cb, NULL, NULL))
            TRACE("strncpyWtoA: conversion failed");
        pszDst[cb-1] = '\0';
    }
}


VOID
StrncpyAtoW(
    OUT WCHAR *pszDst,
    IN LPCSTR pszSrc,
    INT cb,
    DWORD dwCp
    )
{
    *pszDst = L'\0';
    if (pszSrc != NULL) {
        if (!MultiByteToWideChar(dwCp, 0, pszSrc, -1, pszDst, cb))
            TRACE("strncpyAtoW: conversion failed");
        pszDst[cb-1] = L'\0';
    }
}

size_t
wcslenU(
    IN const WCHAR UNALIGNED *pszU
    )
{
    size_t len = 0;

    if (pszU == NULL)
        return 0;
    while (*pszU != L'\0') {
        pszU++;
        len++;
    }
    return len;
}


WCHAR *
strdupWU(
    IN const WCHAR UNALIGNED *pszU
    )
{
    WCHAR *psz;
    DWORD dwcb;

    if (pszU == NULL)
        return NULL;
    dwcb = (wcslenU(pszU) + 1) * sizeof (WCHAR);
    psz = Malloc(dwcb);
    if (psz == NULL)
        return NULL;
    RtlCopyMemory(psz, pszU, dwcb);

    return psz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\extapi\src\rfutil.c ===
/*****************************************************************************
**              Microsoft Rasfile Library
**              Copyright (C) Microsoft Corp., 1992
**
** File Name : rfutil.c
**
** Revision History :
**      July 10, 1992   David Kays      Created
**      Dec  21, 1992   Ram Cherala     Added a check to rasGetFileLine to
**                                      ensure that we terminate if a file
**                                      has no terminating new line. <M001>
**
** Description :
**      Rasfile interal utility routines.
******************************************************************************/

#include "rf.h"
#include "mbstring.h"
#include "raserror.h"

ULONG
__cdecl
DbgPrint(
    PCH Format,
    ...
    );

VOID
NTAPI
DbgBreakPoint(
    VOID
    );

void
__forceinline
InitializeListHead(
     PLIST_ENTRY ListHead
    )
{
    ListHead->Flink = ListHead->Blink = ListHead;
}

void
__forceinline
InsertHeadList(
     PLIST_ENTRY ListHead,
     PLIST_ENTRY Entry
    )
{
    PLIST_ENTRY Flink;

    Flink = ListHead->Flink;
    Entry->Flink = Flink;
    Entry->Blink = ListHead;
    Flink->Blink = Entry;
    ListHead->Flink = Entry;
}
    
extern RASFILE *gpRasfiles[];

/*
 * rffile.c support routines
 */

VOID
FixCorruptFile(RASFILE *pRasfile)
{
    //
    // If we find a corrupt phonebook, try
    // to rename the phonebook as <filename>.pbk.bad
    // and return an error. This way the next
    // time we start with no phonebook and force
    // the user to create a phonebook.
    //

    if(lstrlenA(pRasfile->szFilename))
    {
        CHAR *pszFileName = NULL;
        DWORD dwSize =
                2 * (lstrlenA(pRasfile->szFilename) + lstrlenA(".bad") + 1);

        pszFileName = (CHAR *) LocalAlloc(LPTR, dwSize);

        if(NULL != pszFileName)
        {
            lstrcpynA(pszFileName, pRasfile->szFilename, dwSize);
            strncat(pszFileName, ".bad", dwSize - strlen(pszFileName));

            //
            // We ignore errors here because there's
            // nothing much we can do in error cases.
            //
            if(!DeleteFileA(pszFileName))
            {
                DWORD ret = GetLastError();
            }

            if(!MoveFileA(pRasfile->szFilename, 
                     pszFileName))
            {
                DWORD ret = GetLastError();
            }

            LocalFree(pszFileName);
        }
    }
}

/*
 * rasLoadFile :
 *      Loads a Rasfile from disk into memory.  Lines are parsed
 *      and the linked list of RASFILE control block lines is created.
 *
 * Arguments :
 *      pRasfile - pointer to a Rasfile control block
 *
 * Return Value :
 *      TRUE if the file is successfully loaded, FALSE otherwise.
 *
 * Remarks :
 *      Called by API RasfileLoad() only.
 */
BOOL rasLoadFile( RASFILE *pRasfile )
{
    CHAR                szLinebuf[MAX_LINE_SIZE];
    PLINENODE           lpRasLines;
    LineType            tag;
    BYTE                state;
    DWORD               dwErr = ERROR_SUCCESS;

    if (lpRasLines = newLineNode(pRasfile))
        pRasfile->lpRasLines = lpRasLines;
    else
        return FALSE;

    lpRasLines->next = lpRasLines->prev = lpRasLines;

    /* pRasfile->hFile == INVALID_HANDLE_VALUE iff a new Rasfile is loaded */
    if (pRasfile->hFile == INVALID_HANDLE_VALUE)
    {
        pRasfile->lpLine = lpRasLines;
        return TRUE;
    }

    if (pRasfile->dwMode & RFM_SYSFORMAT ||
        pRasfile->szSectionName[0] == '\0')
        state = FILL;   /* loading the whole file, set seek to FILL */
    else
        state = SEEK;   /* loading a single section, must SEEK to find it */

    /* set up temp buffer for file read */
    {
        CHAR* psz = Malloc(TEMP_BUFFER_SIZE);

        if (psz)
            pRasfile->lpIOBuf = psz;
        else
        {
            pRasfile->lpRasLines = NULL;
            return FALSE;
        }
    }

    pRasfile->dwIOBufIndex = TEMP_BUFFER_SIZE;
    for (;;)
    {
        /* get next line from the file */
        if (! rasGetFileLine(pRasfile,szLinebuf, &dwErr))
        {
            if(ERROR_SUCCESS != dwErr)
            {
                pRasfile->lpRasLines = NULL;
                CloseHandle(pRasfile->hFile);
                Free(pRasfile->lpIOBuf);
                    
                if(ERROR_CORRUPT_PHONEBOOK == dwErr)
                {
                    FixCorruptFile(pRasfile);
                }
                
                return FALSE;
            }
            
            break;
        }
        tag = rasParseLineTag(pRasfile,szLinebuf);
        /* finished loading if rasInsertLine() returns TRUE */
        if (rasInsertLine(pRasfile,szLinebuf,tag,&state) == TRUE)
            break;
    }
    pRasfile->lpLine = pRasfile->lpRasLines->next;

    Free(pRasfile->lpIOBuf);

    return TRUE;
}

/*
 * rasParseLineTag :
 *      Calls rasGetLineTag() to determine the tag value for a line,
 *      checks if the line is a GROUP header, then returns the final
 *      tag value for the line.
 *
 * Arguments :
 *      pRasfile - pointer to Rasfile control block
 *      lpszLine - pointer to Rasfile line
 *
 * Return Value :
 *      The tag value for the given line.
 *
 * Remarks :
 *      Called by rasLoadFile() and APIs RasfilePutLineText() and
 *      RasfileInsertLine() only.
 */
LineType rasParseLineTag( RASFILE *pRasfile, LPCSTR lpszLine )
{
    LineType    type;

    type = rasGetLineTag( pRasfile, lpszLine );
    /* check if this line is a GROUP line also */
    if (pRasfile->pfbIsGroup != NULL &&
        (*(pRasfile->pfbIsGroup))(lpszLine))
        return type | TAG_HDR_GROUP;
    else
        return type;
}


/*
 * rasGetLineTag :
 *      Determines the tag value for a line and returns this value.
 *
 * Arguments :
 *      pRasfile - pointer to Rasfile control block
 *      lpszLine - pointer to Rasfile line.
 *
 * Return Value :
 *      The tag value for the given line, excluding the check for a
 *      GROUP line.
 *
 * Remarks :
 *      Called by rasParseLineTag() only.
 */
LineType rasGetLineTag( RASFILE *pRasfile, LPCSTR lpszLine )
{
    LPCSTR      ps;

    ps = lpszLine;
    /* skip white space */
    for (; *ps == ' ' || *ps == '\t' ; ps++)
        ;
    if (*ps == '\0')
        return TAG_BLANK;

    if ((pRasfile->dwMode & RFM_SYSFORMAT) &&
             ((*ps == 'r') || (*ps == 'R') || (*ps == '@')))
    {
        if (*ps == '@')
            /* skip white space */
            for (; *ps == ' ' || *ps == '\t' ; ps++)
                ;
        if (!_strnicmp(ps,"rem ",4))
            return TAG_COMMENT;
    }
    else
    {  /* .ini style */
        if (*ps == ';')
            return TAG_COMMENT;
        if (*ps == LBRACKETCHAR)
            return TAG_SECTION;
    }
    /* already checked for COMMENT or SECTION */
    /* check for KEYVALUE or COMMAND now */
    if (strchr(lpszLine, '='))
        return TAG_KEYVALUE;
    else
        return TAG_COMMAND;
}

#ifdef DEBUG_MEMORY
PVOID
DebugAlloc(
    DWORD sz,
    DWORD Flags,
    DWORD Id
    )
{
    PMEM_HDR Ptr;


    // allign for 64 bit
    sz = (sz + 63) & 0xFFFFFFc0;
    
    Ptr = (PMEM_HDR)HeapAlloc(GetProcessHeap(), 0,(sz)+sizeof(MEM_HDR)+sizeof(DWORD));
    if (Ptr==NULL)
        return NULL;

    Ptr->Signature = 0xabcdefaa;
    Ptr->Tail =  (PDWORD)((PCHAR)Ptr + sz + sizeof(MEM_HDR));
    *Ptr->Tail = 0xabcdefbb;
    Ptr->Id = Id;
    
    return (PVOID)((PCHAR)Ptr+sizeof(MEM_HDR));
}
#endif


LPVOID
PrivMalloc(DWORD sz, RASFILE * pRasfile)
{

    PVOID Mem; // return memory ptr

    if (sz > 16000)
        return NULL;
        
    #if defined(_X86_)
    sz = (sz + 15) & 0xFFFFFFF0; /*allign for 32 bit*/
    #else
    sz = (sz + 63) & 0xFFFFFFc0; /*allign for 64 bit*/    
    #endif //defined(_IA64_)
    
    // memory available
    if (pRasfile->PrivMemory.dwMemoryFree > sz)
    {
        Mem = pRasfile->PrivMemory.pvCurPtr;
        pRasfile->PrivMemory.pvCurPtr = pRasfile->PrivMemory.pvCurPtr + sz;
        pRasfile->PrivMemory.dwMemoryFree -= sz;
    }
    // allocate memory
    else
    {
        PLIST_ENTRY ple;
        DWORD AllocSize = sz>16334? sz+1000 : 16334;
                
        ple = (PLIST_ENTRY) Malloc(AllocSize);
        if (!ple)
            return NULL;

        InsertHeadList(&pRasfile->PrivMemory.List, ple);
        Mem = pRasfile->PrivMemory.pvCurPtr = (PCHAR)ple + sizeof(LIST_ENTRY);
        pRasfile->PrivMemory.pvCurPtr = pRasfile->PrivMemory.pvCurPtr + sz;
        pRasfile->PrivMemory.dwMemoryFree = AllocSize - sz - sizeof(LIST_ENTRY);
    }
    
    return (LPVOID)Mem;
}


#ifdef DEBUG_MEMORY

VOID
DebugFree(
    PVOID mem
    )
{
    PMEM_HDR Ptr = (PMEM_HDR)((PCHAR)mem - sizeof(MEM_HDR));

    if (Ptr->Signature != 0xabcdefaa) {
        DbgPrint("\n=======================\n"
                "Freeing Invalid memory:%0x:Id:%0x\n", (ULONG_PTR)Ptr, Ptr->Id
        );
        return;
    }
    if (*Ptr->Tail != 0xabcdefbb) {
        DbgPrint("\n=======================\n"
                "Freeing Invalid memory:Tail corrupted:%0x:Id:%0x\n", (
                ULONG_PTR)Ptr, Ptr->Id);
        return;
    }

    Ptr->Signature = 0xaafedcba;
    *Ptr->Tail = 0xbbfedcba;

    HeapFree(GetProcessHeap(), 0, Ptr);
}
#endif


VOID
PrivFree(RASFILE * pRasfile)
{
    PLIST_ENTRY pHead, ple;
    
    pHead = &pRasfile->PrivMemory.List;
    for (ple=pHead->Flink;  ple!=pHead; )
    {
        ple = ple->Flink;
        Free(ple->Blink);
    }
    InitializeListHead(&pRasfile->PrivMemory.List);
    pRasfile->PrivMemory.pvCurPtr = NULL;
    pRasfile->PrivMemory.dwMemoryFree = 0;
    return;
}


/*
 * rasInsertLine :
 *  Inserts the given line into the linked list of Rasfile control block
 *  lines if the given state and line tag match correctly.
 *
 * Arguments :
 *  pRasfile - pointer to Rasfile control block
 *  lpszLine - pointer to Rasfile line which may be inserted
 *  tag      - tag value for lpszLine obtained from rasParseLineTag().
 *  state    - current state of rasLoadFile() :
 *      FILL - the lines of a section (or whole file) are currently
 *              being loaded
 *      SEEK - the correct section to load is currently being searched
 *              for
 *
 * Return Value :
 *  TRUE if the current line was the last Rasfile line to load, FALSE
 *  otherwise.
 *
 * Remarks :
 *  Called by rasLoadFile() only.
 */
BOOL rasInsertLine( RASFILE *pRasfile, LPCSTR lpszLine,
                    BYTE tag, BYTE *state )
{
    PLINENODE    lpLineNode;

    if (tag & TAG_SECTION)
    {
        // if a particular section has been being filled and a new
        // section header is encountered, we're done
        //
        if ((*state == FILL) && (pRasfile->szSectionName[0] != '\0'))
        {
            return TRUE;
        }

        // return if this is not the section we're looking for
        //
        if (pRasfile->szSectionName[0] != '\0')
        {
            // Find the left and right brackets.  Search from the beginning
            // of the line for the left bracket and from the end of the line
            // for the right bracket.
            //
            CHAR* pchLeftBracket  = strchr (lpszLine, LBRACKETCHAR);
            CHAR* pchRightBracket = strrchr(lpszLine, RBRACKETCHAR);

            if (pchLeftBracket && pchRightBracket &&
                (pchLeftBracket < pchRightBracket))
            {
                INT cchSectionName = (INT)(pchRightBracket - pchLeftBracket - 1);

                if (!(cchSectionName == lstrlenA(pRasfile->szSectionName) &&
                     (0 == _strnicmp(pchLeftBracket + 1,
                            pRasfile->szSectionName, cchSectionName))))
                {
                    return FALSE;
                }
            }
        }

        *state = FILL;
    }
    /* for non-section header lines, no action is taken if :
    we're seeking for a section still, we're only enumerating sections, or
    the line is a comment or blank and we're not loading comment lines */
    else if (*state == SEEK ||
             pRasfile->dwMode & RFM_ENUMSECTIONS ||
             (tag & (TAG_COMMENT | TAG_BLANK) &&
              !(pRasfile->dwMode & RFM_LOADCOMMENTS)))
    {
        return FALSE;
    }

    if (!(lpLineNode = newLineNode(pRasfile))) //kslksldel
    {
        return FALSE;
    }

    {
        CHAR* psz = (CHAR*)PrivMalloc((lstrlenA(lpszLine) + 1), pRasfile); //kslksl

        if (psz)
            lpLineNode->pszLine = psz;
        else
        {
            return FALSE;
        }
    }

    pRasfile->lpLine=lpLineNode;

    /* insert the new line to the end of the Rasfile line list */
    listInsert(pRasfile->lpRasLines->prev,lpLineNode);
    lpLineNode->mark = 0;
    lpLineNode->type = tag;

    lstrcpynA(lpLineNode->pszLine, lpszLine, lstrlenA(lpszLine) + 1);

    return FALSE;
}

/*
 * rasWriteFile :
 *      Write the memory image of the given Rasfile to the given
 *      filename or to the original loaded file name if the given
 *      filename is NULL.
 *
 * Arguments :
 *      pRasfile - pointer to Rasfile control block
 *      lpszPath - path name of the file to write to or NULL if the
 *                 same name that was used to load should be used.
 *
 * Return Value :
 *      TRUE if successful, FALSE otherwise.
 *
 * Remarks :
 *      Called by API RasfileWrite() only.
 */
BOOL rasWriteFile( RASFILE *pRasfile, LPCSTR lpszPath )
{
    HANDLE              fhNew;
    PLINENODE           lpLine;

    /* (re)open file for writing/reading */
    if (lpszPath == NULL)
    {
        /* close and re-open same file as empty file for writing */

        if (pRasfile->hFile != INVALID_HANDLE_VALUE )
        {
           if( !CloseHandle(pRasfile->hFile) )
           {
                return FALSE;
           }

           pRasfile->hFile = INVALID_HANDLE_VALUE;
        }

        // For bug 537369       gangz
        if ((fhNew = CreateFileA(pRasfile->szFilename,
                                 GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ,
                                 NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,
                                 NULL)) == INVALID_HANDLE_VALUE)
        {
            pRasfile->hFile = INVALID_HANDLE_VALUE;
            return FALSE;
        }
        else if (GetFileType(fhNew) != FILE_TYPE_DISK)
        {
            CloseHandle(fhNew);
            pRasfile->hFile = INVALID_HANDLE_VALUE;
            return FALSE;
        }
    }
    else
    {
        if ((fhNew = CreateFileA(lpszPath,
                                 GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ,
                                 NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,
                                 NULL)) == INVALID_HANDLE_VALUE)
        {
            return FALSE;
        }
        else if (GetFileType(fhNew) != FILE_TYPE_DISK)
        {
            CloseHandle(fhNew);
            return FALSE;
        }
    }

    /* write out file */
    for (lpLine = pRasfile->lpRasLines->next;
        lpLine != pRasfile->lpRasLines;
        lpLine = lpLine->next)
    {
        rasPutFileLine(fhNew,lpLine->pszLine);
    }

    
    // For bug 537369       gangz
    if( INVALID_HANDLE_VALUE != fhNew)
    {
         CloseHandle( fhNew );
         pRasfile->hFile = fhNew = INVALID_HANDLE_VALUE;
    }

    return TRUE;
}

/*
 * rasGetFileLine :
 *      Get the next line of text from the given open Rasfile.
 *
 * Arguments :
 *      pRasfile - pointer to Rasfile control block.
 *      lpLine - buffer to hold the next line
 *
 * Return Value :
 *      TRUE if successful, FALSE if EOF was reached.
 *
 * Comments :
 *      All lines in Rasfile files are assumed to end in a newline (i.e.,
 *      no incomplete lines followed by an EOF
 */
BOOL rasGetFileLine( RASFILE *pRasfile, LPSTR lpLine, DWORD *pErr )
{
    DWORD       dwBytesRead = 0, dwCharsRead = 0;
    DWORD       dwChars = 0;

    for (;;)
    {
        if (pRasfile->dwIOBufIndex == TEMP_BUFFER_SIZE)
        {
            if(!ReadFile(pRasfile->hFile,pRasfile->lpIOBuf,
                     TEMP_BUFFER_SIZE,&dwBytesRead,NULL))
            {
                return FALSE;
            }

            dwCharsRead = dwBytesRead;
            pRasfile->dwIOBufIndex = 0;
            if (dwBytesRead == 0)
                return FALSE;
            if (dwCharsRead < TEMP_BUFFER_SIZE)
                pRasfile->lpIOBuf[dwCharsRead] = '\0';
        }
        if (pRasfile->lpIOBuf[pRasfile->dwIOBufIndex] == '\0')
            return FALSE;

        /* fill lpLine with the next line */
        for (; pRasfile->dwIOBufIndex < TEMP_BUFFER_SIZE ;)
        {
            *lpLine = pRasfile->lpIOBuf[pRasfile->dwIOBufIndex++];
            dwChars += 1;

            if(dwChars >= (MAX_LINE_SIZE - 1))
            {
                *pErr = ERROR_CORRUPT_PHONEBOOK;
                return FALSE;
            }
            
            // replace all CR/LF pairs with null
            if (*lpLine == '\r')
                continue;
            else if (*lpLine == '\n')
            {
                *lpLine = '\0';
                return TRUE;
            }
/*<M001>*/
            else if (*lpLine == '\0')
                return TRUE;
/*<M001>*/
            else
                lpLine++;
        }
        /* possibly continue outer for loop to read a new file block */
    }
}

/*
 * rasPutFileLine :
 *      Write the line of text to the given Rasfile file.
 *
 * Arguments :
 *      hFile - pointer to open file
 *      lpLine - buffer containing the line to write (without newline)
 *
 * Return Value :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL rasPutFileLine( HANDLE hFile, LPCSTR lpLine )
{
    DWORD       dwWritten;
    CHAR        szBuf[2*MAX_LINE_SIZE + 2];

    lstrcpynA(szBuf,lpLine, MAX_LINE_SIZE - 2);
    strncat(szBuf, "\r\n", 3);   // don't forget the CR/LF pair
    WriteFile(hFile,szBuf,lstrlenA(szBuf),&dwWritten,NULL);
    return TRUE;
}

/*
 * rfnav.c support routines
 */

/*
 * rasNavGetStart :
 *      Returns the starting line for a Rasfile find line
 *      search to begin.  Calls rasLineInScope() and rasGetStartLine()
 *      to do all the work.
 *
 * Arguments :
 *      pRasfile - pointer to Rasfile control block
 *      rfscope - the scope in which to look for the start line
 *      place - where in the scope the start line is :
 *              BEGIN - the first line in the scope
 *              END - the last line in the scope
 *              NEXT - the next line in the scope
 *              PREV - the previous line in the scope
 *
 * Return Value :
 *      A valid PLINE if a line at the given place in the given scope
 *      could be found, otherwise NULL.
 *
 * Remarks :
 *      Called by rasFindLine() only.
 */
PLINENODE rasNavGetStart( RASFILE *pRasfile, RFSCOPE rfscope, BYTE place )
{
    PLINENODE           lpNewLine;

    /* check error conditions */
    /* if place is NEXT or PREV, there must be a current line, and the
        next/prev line must be valid */
    if (place == NEXT || place == PREV)
    {
        if (pRasfile->lpLine == pRasfile->lpRasLines)
            return NULL;
        lpNewLine = (place == NEXT) ?
                    pRasfile->lpLine->next : pRasfile->lpLine->prev;
        if (lpNewLine == pRasfile->lpRasLines)
            return NULL;                /* no next or prev line */
    }

    if (! rasLineInScope( pRasfile, rfscope ))
        return NULL;
    return rasGetStartLine( pRasfile, rfscope, place );
}

/*
 * rasLineInScope :
 *      Determines whether the current line for the given Rasfile control
 *      block is currently within the given scope.
 *
 * Arguments :
 *      pRasfile - pointer to Rasfile control block
 *      rfscope - scope to check current line's residence within
 *
 * Return Value :
 *      TRUE if the current line is within the given scope, FALSE otherwise.
 *
 * Remarks :
 *      Called by rasNavGetStart() only.
 */
BOOL rasLineInScope( RASFILE *pRasfile, RFSCOPE rfscope )
{
    PLINENODE   lpLine;
    BYTE        tag;

    if (rfscope == RFS_FILE)
        return TRUE;
    if (pRasfile->lpLine == pRasfile->lpRasLines)
        return FALSE;
    tag = (rfscope == RFS_SECTION) ? TAG_SECTION : TAG_HDR_GROUP;
    for (lpLine = pRasfile->lpLine; lpLine != pRasfile->lpRasLines;
        lpLine = lpLine->prev)
    {
        if (lpLine->type & tag)
            return TRUE;
        /* not in GROUP scope if a new section is encountered first */
        if ((lpLine->type & TAG_SECTION) && (tag == TAG_HDR_GROUP))
            return FALSE;
    }
    return FALSE;
}


/*
 * rasGetStartLine :
 *      Returns the Rasfile line which is in the given place in the
 *      given scope of the Rasfile passed.
 *
 * Arguments :
 *      pRasfile - pointer to Rasfile control block
 *      rfscope -  the scope in which to search for the proper line
 *      place -  which line in the given scope to return
 *
 * Return Value :
 *      A valid PLINE if a line at the given place in the given scope
 *      could be found, otherwise NULL.
 *
 * Remarks :
 *      Called by rasNavGetStart() only.
 */
PLINENODE rasGetStartLine( RASFILE *pRasfile, RFSCOPE rfscope, BYTE place )
{
    PLINENODE   lpLine;
    BYTE        tag;

    tag = (rfscope == RFS_SECTION) ? TAG_SECTION : TAG_SECTION | TAG_HDR_GROUP;
    switch (place)
    {
        case NEXT :
            if (rfscope == RFS_FILE) return pRasfile->lpLine->next;
            /* return NULL if the next line is a line of the given scope */
            else  return (pRasfile->lpLine->next->type & tag) ?
                NULL : pRasfile->lpLine->next;
        case PREV :
            if (rfscope == RFS_FILE) return pRasfile->lpLine->prev;
            /* return NULL if the current line is a line of the given scope */
            else  return (pRasfile->lpLine->type & tag) ?
                NULL : pRasfile->lpLine->prev;
        case BEGIN :
            if (rfscope == RFS_FILE) return pRasfile->lpRasLines->next;
            /* else */
            /* search backward for the correct tag */
            for (lpLine = pRasfile->lpLine;
                !(lpLine->type & tag);
                lpLine = lpLine->prev)
                ;
            return lpLine;
        case END :
            if (rfscope == RFS_FILE) return pRasfile->lpRasLines->prev;
            /* else */
            /* search forward for the correct tag */
            for (lpLine = pRasfile->lpLine->next;
                lpLine != pRasfile->lpRasLines &&
                !(lpLine->type & tag);
                lpLine = lpLine->next)
                ;
            return lpLine->prev;
    }

    return NULL;
}

/*
 * rasFindLine :
 *      Finds a line of the given type in the given scope, starting
 *      at the location in the scope described by 'begin' and searching
 *      in the direction given by 'where'.  Sets the current line to this
 *      line if found.
 *
 * Arguments :
 *      hrasfile - Rasfile handle obtained by call to RasfileLoad()
 *      bType   - the type of line being searched for
 *      rfscope - the scope to in which to search for the line
 *      bStart - where in the given scope to begin the search for a line of
 *              of the given type (see rasNavGetStart()).
 *      bDirection - which direction to make the search in :
 *              FORWARD - check lines following the start line
 *              BACKWARD - check line preceding the start line
 *
 * Return Value :
 *      TRUE if a line of the proper type in the given scope is found
 *      and current line is set to this line, FALSE otherwise.
 *
 * Remarks :
 *      Called by APIs RasfileFindFirstLine(), RasfileFindLastLine(),
 *      RasfileFindNextLine(), and RasfileFindPrevLine() only.
 */
BOOL rasFindLine( HRASFILE hrasfile,  BYTE bType,
                  RFSCOPE rfscope, BYTE bStart, BYTE bDirection )
{
    RASFILE             *pRasfile;
    PLINENODE           lpLine;
    BYTE                tag;

    //For whistler 523586
    if (!VALIDATEHRASFILE(hrasfile))
    {
        return FALSE;
    }

    pRasfile = gpRasfiles[hrasfile];

    if ((lpLine = rasNavGetStart(pRasfile,rfscope,bStart)) == NULL)
        return FALSE;
    tag = (rfscope == RFS_SECTION) ? TAG_SECTION : TAG_SECTION | TAG_HDR_GROUP;

    for (; lpLine != pRasfile->lpRasLines;
        lpLine = (bDirection == BACKWARD ) ?
        lpLine->prev : lpLine->next)
    {
        /* did we find the correct line? */
        if (lpLine->type & bType)
        {
            pRasfile->lpLine = lpLine;
            return TRUE;
        }

        /* backward non-file search ends after we've checked the
           beginning line for the group or section */
        if (rfscope != RFS_FILE && bDirection == BACKWARD &&
            (lpLine->type & tag))
            return FALSE;
        /* forward non-file search ends if the next line is a new
           group header or section, respectively */
        if (rfscope != RFS_FILE && bDirection == FORWARD &&
            (lpLine->next->type & tag))
            return FALSE;
    }
    return FALSE;
}


VOID
rasExtractSectionName(
                     IN  LPCSTR pszSectionLine,
                     OUT LPSTR pszSectionName )

/* Extracts the section name from the []ed line text, 'pszSectionLine',
** and loads it into caller's 'pszSectionName' buffer.
*/
{
    LPCSTR pchAfterLBracket;
    LPCSTR pchLastRBracket;
    LPCSTR psz;

    pchAfterLBracket =
    pszSectionLine + _mbscspn( pszSectionLine, LBRACKETSTR ) + 1;
    pchLastRBracket = NULL;

    for (psz = pchAfterLBracket; *psz; ++psz)
    {
        if (*psz == RBRACKETCHAR)
            pchLastRBracket = psz;
    }

    if (!pchLastRBracket)
        pchLastRBracket = psz;

#ifndef _UNICODE
    for (psz = pchAfterLBracket;
        psz != pchLastRBracket;)
    {
        if (IsDBCSLeadByte(*psz))
        {
            *pszSectionName++ = *psz++;
        }

        *pszSectionName++ = *psz++;
    }
#else
    for (psz = pchAfterLBracket;
        psz != pchLastRBracket;
        *pszSectionName++ = *psz++);
#endif

    *pszSectionName = '\0';
}


/*
 * List routine
 */

/*
 * listInsert :
 *      Inserts an element into a linked list.  Element 'elem' is
 *      inserted after list element 'l'.
 *
 * Arguments :
 *      l - list
 *      elem - element to insert
 *
 * Return Value :
 *      None.
 *
 */
void listInsert( PLINENODE l, PLINENODE elem )
{
    elem->next = l->next;
    elem->prev = l;
    l->next->prev = elem;
    l->next = elem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\extapi\xlate\dummy.c ===
/* dummy.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\extapi\src\wow.c ===
/* Copyright (c) 1994, Microsoft Corporation, all rights reserved
**
** wow.c
** Remote Access External APIs
** WOW entry points
**
** 04/02/94 Steve Cobb
*/


#include <extapi.h>


DWORD FAR PASCAL
RasDialWow(
    IN  LPSTR            lpszPhonebookPath,
    IN  LPRASDIALPARAMSA lpparams,
    IN  HWND             hwndNotify,
    IN  DWORD            dwRasDialEventMsg,
    OUT LPHRASCONN       lphrasconn )

    /* As for RasDialA except...
    **
    ** 'hwndNotify' identifies the window to receive RasDial event
    ** notifications.  It must not be NULL.
    **
    ** 'dwRasDialEventMsg' is the message number to use for RasDial event
    ** notifications.
    */
{
    DWORD dwErr;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE4(
      "RasDialWow(pb=%s,en=%s,h=%p,em=%d)",
      lpszPhonebookPath,
      lpparams->szEntryName,
      hwndNotify,
      dwRasDialEventMsg);

    dwErr = RasDialA(
        NULL, lpszPhonebookPath, lpparams,
        1, RasDialFunc1Wow, lphrasconn );

    if (dwErr == 0)
    {
        /* Set the Win16 notification HWND and message number in the control
        ** block.
        */
        RASCONNCB* prasconncb = ValidateHrasconn( *lphrasconn );

        if(NULL == prasconncb)
        {
            return ERROR_NO_CONNECTION;
        }
        
        prasconncb->hwndNotifyWow = hwndNotify;
        prasconncb->unMsgWow = (UINT )dwRasDialEventMsg;
    }

    return dwErr;
}


VOID WINAPI
RasDialFunc1Wow(
    HRASCONN     hrasconn,
    UINT         unMsg,
    RASCONNSTATE rasconnstate,
    DWORD        dwError,
    DWORD        dwExtendedError )

    /* NT WOW notifier function.  Filters any notifications not expected by
    ** Win16 and passes on the rest.
    */
{
    RASCONNCB* prasconncb;

    RASAPI32_TRACE4("RasDial32WFunc1(h=%d,em=%d,s=%d,e=%d,xe=%d)",
      hrasconn,
      unMsg,
      rasconnstate,
      dwError);
    RASAPI32_TRACE1("RasDial32WFunc1(xe=%d)", dwExtendedError);

    (void )unMsg;
    (void )dwExtendedError;

    if (!(prasconncb = ValidateHrasconn( hrasconn )))
        return;

    /* Wait for RasDialWow to fill in the WOW notification information before
    ** handling the first notification.
    */
    while (!prasconncb->hwndNotifyWow)
        Sleep( 1000L );

    /* Filter the Projected state which is not expected in Win16.
    */
    if (rasconnstate == RASCS_Projected)
        return;

    /* Note: 0xFFFF0000 is what a NULL 16-bit HWND gets mapped to before it is
    **       passed to 32-bit by the generic thunk layer.
    */
    if (prasconncb->hwndNotifyWow != (HWND )INVALID_HANDLE_VALUE)
    {
        /* Pass the notification to Win16.
        */
        RASAPI32_TRACE("Send to Win16...");

        SendMessageA(
            prasconncb->hwndNotifyWow, prasconncb->unMsgWow,
            (WPARAM )rasconnstate, (LPARAM )dwError );

        RASAPI32_TRACE("Send to Win16 done");
    }
}


DWORD FAR PASCAL
RasEnumConnectionsWow(
    OUT    LPRASCONNA lprasconn,
    IN OUT LPDWORD    lpcb,
    OUT    LPDWORD    lpcConnections )

    /* Pass thru with correct call convention.
    */
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasEnumConnectionsWow");

    return
        RasEnumConnectionsA(
            lprasconn,
            lpcb,
            lpcConnections );
}


DWORD FAR PASCAL
RasEnumEntriesWow(
    IN     LPSTR           reserved,
    IN     LPSTR           lpszPhonebookPath,
    OUT    LPRASENTRYNAMEA lprasentryname,
    IN OUT LPDWORD         lpcb,
    OUT    LPDWORD         lpcEntries )

    /* Pass thru with correct call convention.
    */
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasEnumEntriesWow");

    return
        RasEnumEntriesA(
            reserved,
            lpszPhonebookPath,
            lprasentryname,
            lpcb,
            lpcEntries );
}


DWORD FAR PASCAL
RasGetConnectStatusWow(
    IN  HRASCONN         hrasconn,
    OUT LPRASCONNSTATUSA lprasconnstatus )

    /* Pass thru with correct call convention.
    */
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetConnectStatusWow");

    return
        RasGetConnectStatusA(
            hrasconn,
            lprasconnstatus );
}


DWORD FAR PASCAL
RasGetErrorStringWow(
    IN  UINT  ResourceId,
    OUT LPSTR lpszString,
    IN  DWORD InBufSize )

    /* Pass thru with correct call convention.
    */
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetErrorStringWow");

    return
        RasGetErrorStringA(
            ResourceId,
            lpszString,
            InBufSize );
}


DWORD FAR PASCAL
RasHangUpWow(
    IN HRASCONN hrasconn )

    /* Pass thru with correct call convention.
    */
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasHangUpWow");

    return
        RasHangUpA(
            hrasconn );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\bpopup.h ===
//============================================================================
// Copyright(c) 1996, Microsoft Corporation
//
// File:    bpopup.h
//
// History:
//  Abolade Gbadegesin      Mar-2-1996      Created.
//
// This file contains public declarations for the Bubble-Popup window class.
// A bubble-popup provides functionality similar to that of a tooltip, 
// in that it displays text for a brief period and then hides itself.
// This class differs in that it uses DrawText for its output, thus allowing
// multi-line text formatted using tabs. Further, the user is required
// to tell the bubble-popup when to show itself.
//
// To create a bubble-popup, call BubblePopup_Create().
// This returns an HWND (to be later destroyed using DestroyWindow()).
// The text of the bubble-popup can be set and retrieved using WM_SETTEXT
// and WM_GETTEXT (and hence the macros {Get,Set}WindowText().
//
// Set the period for which a popup is active by calling BubblePopup_SetTimeout
// and activate the popup by calling BubblePopup_Activate.
// While a popup is activated, changes to its text are reflected immediately.
// If BubblePopup_Activate is called while the popup is already active,
// the countdown (till the window is hidden) is started again.
//============================================================================


#ifndef _BPOPUP_H_
#define _BPOPUP_H_


// Window class name for bubble-popups

#define WC_BUBBLEPOPUP      TEXT("BubblePopup")


// Messages accepted by bubble-popups

#define BPM_FIRST           (WM_USER + 1)
#define BPM_ACTIVATE        (BPM_FIRST + 0)
#define BPM_DEACTIVATE      (BPM_FIRST + 1)
#define BPM_SETTIMEOUT      (BPM_FIRST + 2)

BOOL
BubblePopup_Init(
    IN  HINSTANCE   hinstance
    );

#define BubblePopup_Create(hinstance) \
        CreateWindow( \
            WC_BUBBLEPOPUP, NULL, 0, 0, 0, 0, 0, NULL, 0, (hinstance), NULL \
            )

#define BubblePopup_Activate(hwnd) \
        (VOID)SendMessage((HWND)hwnd, BPM_ACTIVATE, 0, 0)
#define BubblePopup_Deactivate(hwnd) \
        (VOID)SendMessage((HWND)hwnd, BPM_DEACTIVATE, 0, 0)
#define BubblePopup_SetTimeout(hwnd, uiTimeout) \
        (VOID)SendMessage((HWND)hwnd, BPM_SETTIMEOUT, 0,(LPARAM)(UINT)uiTimeout)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\dtl.h ===
// Copyright (c) 1992, Microsoft Corporation, all rights reserved
//
// dtl.h
// Double-threaded linked list header
//
// 06/28/92 Steve Cobb

#ifndef _DTL_H_
#define _DTL_H_


#include <nouiutil.h>  // Heap definitions

// Forward declarations
//
typedef struct _DTLNODE DTLNODE;
typedef struct _DTLLIST DTLLIST;


// Double-threaded linked list node control block.  There is one node for each
// entry in a list.
//
// Applications should not access this structure directly.
//
typedef struct
_DTLNODE
{
    DTLNODE* pdtlnodePrev; // Address of previous node or NULL if none
    DTLNODE* pdtlnodeNext; // Address of next node or NULL if none
    VOID*    pData;        // Address of user's data
    LONG_PTR lNodeId;      // User-defined node identification code
}
DTLNODE;


// Double-threaded linked list control block.  There is one for each list.
//
// Applications should not access this structure directly.
//
typedef struct
_DTLLIST
{
    DTLNODE* pdtlnodeFirst; // Address of first node or NULL if none
    DTLNODE* pdtlnodeLast;  // Address of last node or NULL if none
    LONG     lNodes;        // Number of nodes in list
    LONG_PTR lListId;       // User-defined list identification code
}
DTLLIST;


// List node duplication function.  See DuplicateList.
//
typedef DTLNODE* (*PDUPNODE)( IN DTLNODE* );

// List node free function.  See FreeList.
//
typedef VOID (*PDESTROYNODE)( IN DTLNODE* );

// List node comparison function.  See MergeSort.
//
typedef IN (*PCOMPARENODE)( IN DTLNODE*, IN DTLNODE* );


// Macros and function prototypes.
//
#define DtlGetData( pdtlnode )        ((pdtlnode)->pData)
#define DtlGetNodeId( pdtlnode )      ((pdtlnode)->lNodeId)
#define DtlGetFirstNode( pdtllist )   ((pdtllist)->pdtlnodeFirst)
#define DtlGetListId( pdtllist )      ((pdtllist)->lListId)
#define DtlGetNextNode( pdtlnode )    ((pdtlnode)->pdtlnodeNext)
#define DtlGetNodes( pdtllist )       ((pdtllist)->lNodes)
#define DtlGetPrevNode( pdtlnode )    ((pdtlnode)->pdtlnodePrev)
#define DtlGetLastNode( pdtllist )    ((pdtllist)->pdtlnodeLast)
#define DtlPutData( pdtlnode, p )     ((pdtlnode)->pData = (p))
#define DtlPutNodeId( pdtlnode, l )   ((pdtlnode)->lNodeId = (LONG )(l))
#define DtlPutListCode( pdtllist, l ) ((pdtllist)->lListId = (LONG )(l))

DTLNODE* DtlAddNodeAfter( DTLLIST*, DTLNODE*, DTLNODE* );
DTLNODE* DtlAddNodeBefore( DTLLIST*, DTLNODE*, DTLNODE* );
DTLNODE* DtlAddNodeFirst( DTLLIST*, DTLNODE* );
DTLNODE* DtlAddNodeLast( DTLLIST*, DTLNODE* );
DTLLIST* DtlCreateList( LONG );
DTLNODE* DtlCreateNode( VOID*, LONG_PTR );
DTLNODE* DtlCreateSizedNode( LONG, LONG_PTR );
VOID     DtlDestroyList( DTLLIST*, PDESTROYNODE );
VOID     DtlDestroyNode( DTLNODE* );
DTLNODE* DtlDeleteNode( DTLLIST*, DTLNODE* );
DTLLIST* DtlDuplicateList( DTLLIST*, PDUPNODE, PDESTROYNODE );
VOID     DtlMergeSort( DTLLIST*, PCOMPARENODE );
VOID     DtlSwapLists( DTLLIST*, DTLLIST* );

DTLNODE* DtlNodeFromIndex( DTLLIST*, LONG );
DTLNODE* DtlRemoveNode( DTLLIST*, DTLNODE* );


#endif // _DTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\common.h ===
//
// Copyright (c) Microsoft Corporation 1993-1995
//
// common.h
//
// Declares common and useful data structures, macros and functions.
// These items are broken down into the following sections.  Defining
// the associated flags will inhibit definition of the indicated
// items.
//
// NORTL            - run-time library functions
// NOBASICS         - basic macros
// NOMEM            - memory management, dynamic array functions
// NODA             - dynamic array functions
// NOSHAREDHEAP     - shared heap functions
// NOFILEINFO       - FileInfo functions
// NOCOLOR          - helper macros to derive COLOR_ values from state
// NODRAWTEXT       - enhanced version of DrawText
// NODIALOGHELPER   - dialog helper functions
// NOMESSAGESTRING  - construct message string functions
// NOSTRING         - string functions
// NOPATH           - path whacking functions
// NODEBUGHELP      - debug routines
// NOSYNC           - synchronization (critical sections, etc.)
// NOPROFILE        - profile (.ini) support functions
//
// Optional defines are:
//
// WANT_SHELL_SUPPORT   - include SH* function support
// SZ_MODULE            - debug string prepended to debug spew
// SHARED_DLL           - DLL is in shared memory (may require 
//                        per-instance data)
// SZ_DEBUGSECTION      - .ini section name for debug options
// SZ_DEBUGINI          - .ini name for debug options
//
// This is the "master" header.  The associated files are:
//
//  common.c
//  path.c
//  mem.c, mem.h
//  profile.c
//
//
// History:
//  04-26-95 ScottH     Transferred from Briefcase code
//                      Added controlling defines
//

#ifndef __COMMON_H__
#define __COMMON_H__

#ifdef RC_INVOKED
// Turn off a bunch of stuff to ensure that RC files compile OK
#define NOMEM
#define NOCOLOR
#define NODRAWTEXT
#define NODIALOGHELPER
#define NOMESSAGESTRING
#define NOSTRING
#define NODEBUGHELP
#define NODA
#define NOSYNC
#define NOPROFILE
#endif // RC_INVOKED

#ifdef _INC_OLE
#define WANT_OLE_SUPPORT
#endif

// Check for any conflicting defines...

#if !defined(WANT_SHELL_SUPPORT) && !defined(NOFILEINFO)
#pragma message("FileInfo routines need WANT_SHELL_SUPPORT.  Not providing FileInfo routines.")
#define NOFILEINFO
#endif

#if !defined(NOFILEINFO) && defined(NOMEM)
#pragma message("FileInfo routines need NOMEM undefined.  Overriding.")
#undef NOMEM
#endif

#if !defined(NOFILEINFO) && defined(NOMESSAGESTRING)
#pragma message("FileInfo routines need NOMESSAGESTRING undefined.  Overriding.")
#undef NOMESSAGESTRING
#endif

#if !defined(NOFILEINFO) && defined(NOSTRING)
#pragma message("FileInfo routines need NOSTRING undefined.  Overriding.")
#undef NOSTRING
#endif

#if !defined(NOMESSAGESTRING) && defined(NOMEM)
#pragma message("ConstructMessage routines need NOMEM undefined.  Overriding.")
#undef NOMEM
#endif

#if !defined(NOPATH) && defined(NOSTRING)
#pragma message("Path routines need NOSTRING undefined.  Overriding.")
#undef NOSTRING
#endif

#if !defined(NODA) && defined(NOMEM)
#pragma message("Dynamic Array routines need NOMEM undefined.  Overriding.")
#undef NOMEM
#endif

#if !defined(NOSHAREDHEAP) && defined(NOMEM)
#pragma message("Shared memory routines need NOMEM undefined.  Overriding.")
#undef NOMEM
#endif

#if !defined(NOPROFILE) && defined(NODEBUGHELP)
#pragma message("Debug profiling routines need NODEBUGHELP undefined.  Overriding.")
#undef NODEBUGHELP
#endif



// Other include files...

#if !defined(NOFILEINFO) && !defined(_SHLOBJ_H_)
#include <shlobj.h>
#endif


//
// Basics
//
#ifndef NOBASICS

#define Unref(x)        x

#ifdef DEBUG
#define INLINE
#define DEBUG_CODE(x)   x
#else
#define INLINE          __inline
#define DEBUG_CODE(x)   
#endif

// General flag macros
//
#define SetFlag(obj, f)             (obj |= (f))
#define ToggleFlag(obj, f)          (obj ^= (f))
#define ClearFlag(obj, f)           (obj &= ~(f))
#define IsFlagSet(obj, f)           (BOOL)(((obj) & (f)) == (f))  
#define IsFlagClear(obj, f)         (BOOL)(((obj) & (f)) != (f))  

#define InRange(id, idFirst, idLast)  ((UINT)(id-idFirst) <= (UINT)(idLast-idFirst))

// Standard buffer lengths
//
#define MAX_BUF                     260
#define MAX_BUF_MSG                 520
#define MAX_BUF_MED                 64
#define MAX_BUF_SHORT               32

#define NULL_CHAR                   '\0'
#define CCH_NUL                     (sizeof(TCHAR))
#define ARRAY_ELEMENTS(rg)          (sizeof(rg) / sizeof((rg)[0]))

// Comparison return values
//
#define CMP_GREATER                 1
#define CMP_LESSER                  (-1)
#define CMP_EQUAL                   0

// Count of characters to count of bytes
//
#define CbFromCch(cch)              ((cch)*sizeof(TCHAR))

// Swap values
//
#define Swap(a, b)      ((DWORD)(a) ^= (DWORD)(b) ^= (DWORD)(a) ^= (DWORD)(b))

// 64-bit macros
//
#define HIDWORD(_qw)                (DWORD)((_qw)>>32)
#define LODWORD(_qw)                (DWORD)(_qw)

// Calling declarations
//
#define PUBLIC                      FAR PASCAL
#define CPUBLIC                     FAR _cdecl
#define PRIVATE                     NEAR PASCAL

// Data segments
//
#define DATASEG_READONLY            ".text"
#define DATASEG_PERINSTANCE         ".instanc"
#define DATASEG_SHARED              ".data"

// Range of resource ID indexes are 0x000 - 0x7ff
#define IDS_BASE                    0x1000
#define IDS_ERR_BASE                (IDS_BASE + 0x0000)
#define IDS_OOM_BASE                (IDS_BASE + 0x0800)
#define IDS_MSG_BASE                (IDS_BASE + 0x1000)
#define IDS_RANDO_BASE              (IDS_BASE + 0x1800)
#define IDS_COMMON_BASE             (IDS_BASE + 0x2000)

#ifndef DECLARE_STANDARD_TYPES
// For a type "FOO", define the standard derived types PFOO, CFOO, and PCFOO.
//
#define DECLARE_STANDARD_TYPES(type)      typedef type *P##type; \
                                          typedef const type C##type; \
                                          typedef const type *PC##type;
#endif

// Zero-initialize data-item
//
#define ZeroInit(pobj, type)        MyZeroMemory(pobj, sizeof(type))

// Copy chunk of memory
//
#define BltByte(pdest, psrc, cb)    MyMoveMemory(pdest, psrc, cb)

#endif // NOBASICS


//
// Run-time library replacements
//
#ifdef NORTL

// (implemented privately)
LPSTR   PUBLIC lmemmove(LPSTR dst, LPCSTR src, int count);
LPSTR   PUBLIC lmemset(LPSTR dst, char val, UINT count);

#define MyZeroMemory(p, cb)             lmemset((LPSTR)(p), 0, cb)
#define MyMoveMemory(pdest, psrc, cb)   lmemmove((LPSTR)(pdest), (LPCSTR)(psrc), cb)

#else // NORTL

#define MyZeroMemory                    ZeroMemory
#define MyMoveMemory                    MoveMemory

#endif // NORTL


//
// Memory and dynamic array functions
//
#ifndef NOMEM
#include "mem.h"
#endif // NOMEM


//
// Message string helpers
//
#ifndef NOMESSAGESTRING

LPSTR   PUBLIC ConstructVMessageString(HINSTANCE hinst, LPCSTR pszMsg, va_list *ArgList);
BOOL    PUBLIC ConstructMessage(LPSTR * ppsz, HINSTANCE hinst, LPCSTR pszMsg, ...);

#define SzFromIDS(hinst, ids, pszBuf, cchBuf)   (LoadString(hinst, ids, pszBuf, cchBuf), pszBuf)

int PUBLIC MsgBox(HINSTANCE hinst, HWND hwndOwner, LPCSTR pszText, LPCSTR pszCaption, HICON hicon, DWORD dwStyle, ...);

// Additional MB_ flags
#define MB_WARNING      (MB_OK | MB_ICONWARNING)
#define MB_INFO         (MB_OK | MB_ICONINFORMATION)
#define MB_ERROR        (MB_OK | MB_ICONERROR)
#define MB_QUESTION     (MB_YESNO | MB_ICONQUESTION)

#endif // NOMESSAGESTRING


//
// String functions
//
#ifndef NOSTRING

int     PUBLIC AnsiToInt(LPCSTR pszString);
int     PUBLIC lstrnicmp(LPCSTR psz1, LPCSTR psz2, UINT count);
LPSTR   PUBLIC AnsiChr(LPCSTR psz, WORD wMatch);

#define IsSzEqual(sz1, sz2)         (BOOL)(lstrcmpi(sz1, sz2) == 0)
#define IsSzEqualC(sz1, sz2)        (BOOL)(lstrcmp(sz1, sz2) == 0)

#endif // NOSTRING


//
// FileInfo functions
//
#ifndef NOFILEINFO

// FileInfo struct that contains file time/size info
//
typedef struct _FileInfo
    {
    HICON   hicon;
    FILETIME ftMod;
    DWORD   dwSize;         // size of the file
    DWORD   dwAttributes;   // attributes
    LPARAM  lParam;
    LPSTR   pszDisplayName; // points to the display name
    char    szPath[1];      
    } FileInfo;

#define FIGetSize(pfi)          ((pfi)->dwSize)
#define FIGetPath(pfi)          ((pfi)->szPath)
#define FIGetDisplayName(pfi)   ((pfi)->pszDisplayName)
#define FIGetAttributes(pfi)    ((pfi)->dwAttributes)
#define FIIsFolder(pfi)         (IsFlagSet((pfi)->dwAttributes, SFGAO_FOLDER))

// Flags for FICreate
#define FIF_DEFAULT             0x0000
#define FIF_ICON                0x0001
#define FIF_DONTTOUCH           0x0002
#define FIF_FOLDER              0x0004

HRESULT PUBLIC FICreate(LPCSTR pszPath, FileInfo ** ppfi, UINT uFlags);
BOOL    PUBLIC FISetPath(FileInfo ** ppfi, LPCSTR pszPathNew, UINT uFlags);
BOOL    PUBLIC FIGetInfoString(FileInfo * pfi, LPSTR pszBuf, int cchBuf);
void    PUBLIC FIFree(FileInfo * pfi);

void    PUBLIC FileTimeToDateTimeString(LPFILETIME pft, LPSTR pszBuf, int cchBuf);

// Resource string IDs
#define IDS_BYTES                   (IDS_COMMON_BASE + 0x000)
#define IDS_ORDERKB                 (IDS_COMMON_BASE + 0x001)
#define IDS_ORDERMB                 (IDS_COMMON_BASE + 0x002)
#define IDS_ORDERGB                 (IDS_COMMON_BASE + 0x003)
#define IDS_ORDERTB                 (IDS_COMMON_BASE + 0x004)
#define IDS_DATESIZELINE            (IDS_COMMON_BASE + 0x005)

#endif // NOFILEINFO


//
// Color-from-owner-draw-state macros
//
#ifndef NOCOLOR

#define ColorText(nState)           (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT)
#define ColorBk(nState)             (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHT : COLOR_WINDOW)
#define ColorMenuText(nState)       (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHTTEXT : COLOR_MENUTEXT)
#define ColorMenuBk(nState)         (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHT : COLOR_MENU)
#define GetImageDrawStyle(nState)   (((nState) & ODS_SELECTED) ? ILD_SELECTED : ILD_NORMAL)

#endif // NOCOLOR


//
// Dialog helper functions
//
#ifndef NODIALOGHELPER

// Sets the dialog handle in the given data struct on first
// message that the dialog gets (WM_SETFONT).
//
#define SetDlgHandle(hwnd, msg, lp)     if((msg)==WM_SETFONT) (lp)->hdlg=(hwnd);

int     PUBLIC DoModal (HWND hwndParent, DLGPROC lpfnDlgProc, UINT uID, LPARAM lParam);
VOID    PUBLIC SetRectFromExtent(HDC hdc, LPRECT lprc, LPCSTR lpcsz);

#endif // NODIALOGHELPER


//
// Enhanced form of DrawText()
//
#ifndef NODRAWTEXT

// Flags for MyDrawText()
#define MDT_DRAWTEXT        0x00000001                                  
#define MDT_ELLIPSES        0x00000002                                  
#define MDT_LINK            0x00000004                                  
#define MDT_SELECTED        0x00000008                                  
#define MDT_DESELECTED      0x00000010                                  
#define MDT_DEPRESSED       0x00000020                                  
#define MDT_EXTRAMARGIN     0x00000040                                  
#define MDT_TRANSPARENT     0x00000080
#define MDT_LEFT            0x00000100
#define MDT_RIGHT           0x00000200
#define MDT_CENTER          0x00000400
#define MDT_VCENTER         0x00000800
#define MDT_CLIPPED         0x00001000

#ifndef CLR_DEFAULT         // (usually defined in commctrl.h)
#define CLR_DEFAULT         0xFF000000L
#endif

void    PUBLIC MyDrawText(HDC hdc, LPCSTR pszText, RECT FAR* prc, UINT flags, int cyChar, int cxEllipses, COLORREF clrText, COLORREF clrTextBk);
void    PUBLIC GetCommonMetrics(WPARAM wParam);

extern int g_cxLabelMargin;
extern int g_cxBorder;
extern int g_cyBorder;

extern COLORREF g_clrHighlightText;
extern COLORREF g_clrHighlight;
extern COLORREF g_clrWindowText;
extern COLORREF g_clrWindow;

extern HBRUSH g_hbrHighlight;
extern HBRUSH g_hbrWindow;

#endif // NODRAWTEXT

//
// Synchronization
//
#ifndef NOSYNC

#define INIT_EXCLUSIVE()        Common_InitExclusive();
#define ENTER_EXCLUSIVE()       Common_EnterExclusive();
#define LEAVE_EXCLUSIVE()       Common_LeaveExclusive();
#define ASSERT_EXCLUSIVE()      ASSERT(0 < g_cRefCommonCS)
#define ASSERT_NOT_EXCLUSIVE()  ASSERT(0 == g_cRefCommonCS)

extern UINT g_cRefCommonCS;

void    PUBLIC Common_InitExclusive(void);
void    PUBLIC Common_EnterExclusive(void);
void    PUBLIC Common_LeaveExclusive(void);

// Safe version of MsgWaitMultipleObjects()
//
DWORD   PUBLIC MsgWaitObjectsSendMessage(DWORD cObjects, LPHANDLE phObjects, DWORD dwTimeout);

#else // NOSYNC

#define INIT_EXCLUSIVE()        
#define ENTER_EXCLUSIVE()       
#define LEAVE_EXCLUSIVE()       
#define ASSERT_EXCLUSIVE()      
#define ASSERT_NOT_EXCLUSIVE()  

#endif // NOSYNC


//
// Path whacking functions
//
#ifndef NOPATH

BOOL    PUBLIC WPPathIsRoot(LPCSTR pszPath);
BOOL    PUBLIC WPPathIsUNC(LPCSTR pszPath);
LPSTR   PUBLIC WPRemoveBackslash(LPSTR lpszPath);
LPSTR   PUBLIC WPRemoveExt(LPCSTR pszPath, LPSTR pszBuf);
LPSTR   PUBLIC WPFindNextComponentI(LPCSTR lpszPath);
void    PUBLIC WPMakePresentable(LPSTR pszPath);
BOOL    PUBLIC WPPathsTooLong(LPCSTR pszFolder, LPCSTR pszName);
void    PUBLIC WPCanonicalize(LPCSTR pszPath, LPSTR pszBuf);
LPSTR   PUBLIC WPFindFileName(LPCSTR pPath);
BOOL    PUBLIC WPPathExists(LPCSTR pszPath);
LPCSTR  PUBLIC WPFindEndOfRoot(LPCSTR pszPath);
BOOL    PUBLIC WPPathIsPrefix(LPCSTR lpcszPath1, LPCSTR lpcszPath2);

#ifdef WANT_SHELL_SUPPORT
LPSTR   PUBLIC WPGetDisplayName(LPCSTR pszPath, LPSTR pszBuf);

// Events for WPNotifyShell
typedef enum _notifyshellevent
    {
    NSE_CREATE       = 0,
    NSE_MKDIR,
    NSE_UPDATEITEM,
    NSE_UPDATEDIR
    } NOTIFYSHELLEVENT;

void    PUBLIC WPNotifyShell(LPCSTR pszPath, NOTIFYSHELLEVENT nse, BOOL bDoNow);
#endif

#endif // NOPATH


//
// Profile (.ini) support functions
//
// (Currently all profile functions are for DEBUG use only
#ifndef DEBUG
#define NOPROFILE
#endif
#ifndef NOPROFILE

#ifndef SZ_DEBUGINI
#pragma message("SZ_DEBUGINI is not #defined.  Assuming \"rover.ini\".")
#define SZ_DEBUGINI   "rover.ini"
#endif
#ifndef SZ_DEBUGSECTION
#pragma message("SZ_DEBUGSECTION is not #defined.  Assuming [Debug].")
#define SZ_DEBUGSECTION   "Debug"
#endif

BOOL    PUBLIC ProcessIniFile(void);

#else // NOPROFILE

#define ProcessIniFile()

#endif // NOPROFILE


//
// Debug helper functions
//


// Break flags
#define BF_ONTHREADATT      0x00000001
#define BF_ONTHREADDET      0x00000002
#define BF_ONPROCESSATT     0x00000004
#define BF_ONPROCESSDET     0x00000008
#define BF_ONVALIDATE       0x00000010
#define BF_ONOPEN           0x00000020
#define BF_ONCLOSE          0x00000040

// Trace flags
#define TF_ALWAYS           0x00000000
#define TF_WARNING          0x00000001
#define TF_ERROR            0x00000002
#define TF_GENERAL          0x00000004      // Standard messages
#define TF_FUNC             0x00000008      // Trace function calls
// (Upper 16 bits reserved for user)

#if defined(NODEBUGHELP) || !defined(DEBUG)

#define DEBUG_BREAK  1 ? (void)0 : (void)
#define ASSERT(f)
#define EVAL(f)      (f)
#define ASSERT_MSG   1 ? (void)0 : (void)
#define DEBUG_MSG    1 ? (void)0 : (void)
#define TRACE_MSG    1 ? (void)0 : (void)

#define VERIFY_SZ(f, szFmt, x)          (f)
#define VERIFY_SZ2(f, szFmt, x1, x2)    (f)

#define DBG_ENTER(fn)
#define DBG_ENTER_SZ(fn, sz)
#define DBG_ENTER_DTOBJ(fn, pdtobj, sz)
#define DBG_ENTER_RIID(fn, riid)   

#define DBG_EXIT(fn)                            
#define DBG_EXIT_TYPE(fn, dw, pfnStrFromType)
#define DBG_EXIT_INT(fn, n)
#define DBG_EXIT_BOOL(fn, b)
#define DBG_EXIT_US(fn, us)
#define DBG_EXIT_UL(fn, ul)
#define DBG_EXIT_PTR(fn, ptr)                            
#define DBG_EXIT_HRES(fn, hres)   

#else // defined(NODEBUGHELP) || !defined(DEBUG)

extern DWORD g_dwDumpFlags;
extern DWORD g_dwBreakFlags;
extern DWORD g_dwTraceFlags;

// Debugging macros
//
#ifndef SZ_MODULE
#pragma message("SZ_MODULE is not #defined.  Debug spew will use UNKNOWN module.")
#define SZ_MODULE   "UNKNOWN"
#endif

#define DEBUG_CASE_STRING(x)    case x: return #x
#define DEBUG_STRING_MAP(x)     { x, #x }

#define ASSERTSEG

// Use this macro to declare message text that will be placed
// in the CODE segment (useful if DS is getting full)
//
// Ex: DEBUGTEXT(szMsg, "Invalid whatever: %d");
//
#define DEBUGTEXT(sz, msg) \
    static const char ASSERTSEG sz[] = msg;

void    PUBLIC CommonDebugBreak(DWORD flag);
void    PUBLIC CommonAssertFailed(LPCSTR szFile, int line);
void    CPUBLIC CommonAssertMsg(BOOL f, LPCSTR pszMsg, ...);
void    CPUBLIC CommonDebugMsg(DWORD mask, LPCSTR pszMsg, ...);

LPCSTR  PUBLIC Dbg_SafeStr(LPCSTR psz);

#define DEBUG_BREAK     CommonDebugBreak

// ASSERT(f)  -- Generate "assertion failed in line x of file.c"
//               message if f is NOT true.
//
#define ASSERT(f)                                                       \
    {                                                                   \
        DEBUGTEXT(szFile, __FILE__);                                    \
        if (!(f))                                                       \
            CommonAssertFailed(szFile, __LINE__);                       \
    }
#define EVAL        ASSERT

// ASSERT_MSG(f, msg, args...)  -- Generate wsprintf-formatted msg w/params
//                          if f is NOT true.
//
#define ASSERT_MSG   CommonAssertMsg

// TRACE_MSG(mask, msg, args...) - Generate wsprintf-formatted msg using
//                          specified debug mask.  System debug mask
//                          governs whether message is output.
//
#define DEBUG_MSG    CommonDebugMsg
#define TRACE_MSG    DEBUG_MSG

// VERIFY_SZ(f, msg, arg)  -- Generate wsprintf-formatted msg w/ 1 param
//                          if f is NOT true 
//
#define VERIFY_SZ(f, szFmt, x)   ASSERT_MSG(f, szFmt, x)


// VERIFY_SZ2(f, msg, arg1, arg2)  -- Generate wsprintf-formatted msg w/ 2
//                          param if f is NOT true 
//
#define VERIFY_SZ2(f, szFmt, x1, x2)   ASSERT_MSG(f, szFmt, x1, x2)



// DBG_ENTER(fn)  -- Generates a function entry debug spew for
//                          a function 
//
#define DBG_ENTER(fn)                  \
    TRACE_MSG(TF_FUNC, " > " #fn "()")


// DBG_ENTER_SZ(fn, sz)  -- Generates a function entry debug spew for
//                          a function that accepts a string as one of its
//                          parameters.
//
#define DBG_ENTER_SZ(fn, sz)                  \
    TRACE_MSG(TF_FUNC, " > " #fn "(..., \"%s\",...)", Dbg_SafeStr(sz))


#ifdef WANT_OLE_SUPPORT
// DBG_ENTER_RIID(fn, riid)  -- Generates a function entry debug spew for
//                          a function that accepts an riid as one of its
//                          parameters.
//
#define DBG_ENTER_RIID(fn, riid)                  \
    TRACE_MSG(TF_FUNC, " > " #fn "(..., %s,...)", Dbg_GetRiidName(riid))
#endif


// DBG_EXIT(fn)  -- Generates a function exit debug spew 
//
#define DBG_EXIT(fn)                              \
        TRACE_MSG(TF_FUNC, " < " #fn "()")

// DBG_EXIT_TYPE(fn, dw, pfnStrFromType)  -- Generates a function exit debug 
//                          spew for functions that return <type>.
//
#define DBG_EXIT_TYPE(fn, dw, pfnStrFromType)                   \
        TRACE_MSG(TF_FUNC, " < " #fn "() with %s", (LPCSTR)pfnStrFromType(dw))

// DBG_EXIT_INT(fn, us)  -- Generates a function exit debug spew for
//                          functions that return an INT.
//
#define DBG_EXIT_INT(fn, n)                       \
        TRACE_MSG(TF_FUNC, " < " #fn "() with %d", (int)(n))

// DBG_EXIT_BOOL(fn, b)  -- Generates a function exit debug spew for
//                          functions that return a boolean.
//
#define DBG_EXIT_BOOL(fn, b)                      \
        TRACE_MSG(TF_FUNC, " < " #fn "() with %s", (b) ? (LPSTR)"TRUE" : (LPSTR)"FALSE")

// DBG_EXIT_US(fn, us)  -- Generates a function exit debug spew for
//                          functions that return a USHORT.
//
#define DBG_EXIT_US(fn, us)                       \
        TRACE_MSG(TF_FUNC, " < " #fn "() with %#x", (USHORT)(us))

// DBG_EXIT_UL(fn, ul)  -- Generates a function exit debug spew for
//                          functions that return a ULONG.
//
#define DBG_EXIT_UL(fn, ul)                   \
        TRACE_MSG(TF_FUNC, " < " #fn "() with %#lx", (ULONG)(ul))

// DBG_EXIT_PTR(fn, pv)  -- Generates a function exit debug spew for
//                          functions that return a pointer.
//
#define DBG_EXIT_PTR(fn, pv)                   \
        TRACE_MSG(TF_FUNC, " < " #fn "() with %#lx", (LPVOID)(pv))

// DBG_EXIT_HRES(fn, hres)  -- Generates a function exit debug spew for
//                          functions that return an HRESULT.
//
#define DBG_EXIT_HRES(fn, hres)     DBG_EXIT_TYPE(fn, hres, Dbg_GetScode)

#endif // defined(NODEBUGHELP) || !defined(DEBUG)

//
// TRACING macros specific to RASSCRPIT
//
extern DWORD g_dwRasscrptTraceId;

#define RASSCRPT_TRACE_INIT(module) DebugInitEx(module, &g_dwRasscrptTraceId)
#define RASSCRPT_TRACE_TERM() DebugTermEx(&g_dwRasscrptTraceId)

#define RASSCRPT_TRACE(a)               TRACE_ID(g_dwRasscrptTraceId, a)
#define RASSCRPT_TRACE1(a,b)            TRACE_ID1(g_dwRasscrptTraceId, a,b)
#define RASSCRPT_TRACE2(a,b,c)          TRACE_ID2(g_dwRasscrptTraceId, a,b,c)
#define RASSCRPT_TRACE3(a,b,c,d)        TRACE_ID3(g_dwRasscrptTraceId, a,b,c,d)
#define RASSCRPT_TRACE4(a,b,c,d,e)      TRACE_ID4(g_dwRasscrptTraceId, a,b,c,d,e)
#define RASSCRPT_TRACE5(a,b,c,d,e,f)    TRACE_ID5(g_dwRasscrptTraceId, a,b,c,d,e,f)
#define RASSCRPT_TRACE6(a,b,c,d,e,f,g)  TRACE_ID6(g_dwRasscrptTraceId, a,b,c,d,e,f,g)

#endif // __COMMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\extapi\src\util.c ===
/* Copyright (c) 1992, Microsoft Corporation, all rights reserved
**
** util.c
** Remote Access External APIs
** Utility routines
**
** 10/12/92 Steve Cobb
*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <extapi.h>
#include <stdlib.h>
#include <winreg.h>
#include <winsock.h>
#include <shlobj.h>
#include <rasapip.h>
#include <rtutils.h>

BOOL
CaseInsensitiveMatch(
    IN LPCWSTR pszStr1,
    IN LPCWSTR pszStr2
    );

//
// TRUE when rasman.dll has been
// successfully loaded and initailized.
// See LoadRasmanDllAndInit().
//
DWORD FRasInitialized = FALSE;
BOOL g_FRunningInAppCompatMode = FALSE;

HINSTANCE hinstIpHlp = NULL;
HINSTANCE hinstAuth = NULL;
HINSTANCE hinstScript = NULL;
HINSTANCE hinstMprapi = NULL;

//
// Gurdeepian dword byte-swapping macro.
//
#define net_long(x) (((((unsigned long)(x))&0xffL)<<24) | \
                     ((((unsigned long)(x))&0xff00L)<<8) | \
                     ((((unsigned long)(x))&0xff0000L)>>8) | \
                     ((((unsigned long)(x))&0xff000000L)>>24))

// XP 338217
//
#define Clear0(x) Free0(x); (x)=NULL

// 
// Initializes the ras api logging and debugging facility.  This should be the first
// api called in every function exported from the dll.
//
DWORD g_dwRasApi32TraceId = INVALID_TRACEID;

// XP 395648
//
// We use this global variable to cache whether we are the rasman process so
// that IsRasmanProcess doesn't have to execute for each rasapi.
//
DWORD g_dwIsRasmanProcess = 2;      // 2=don't know, 1=yes, 0=no

DWORD
RasApiDebugInit()
{
    // XP 395648
    //
    // Registering for trace notifications from the rasman process 
    // can leak tokens because of impersonation.
    //
    if (g_dwIsRasmanProcess == 2)
    {
        g_dwIsRasmanProcess = (IsRasmanProcess()) ? 1 : 0;
    }
    
    if (g_dwIsRasmanProcess == 0)
    {
        DebugInitEx("RASAPI32", &g_dwRasApi32TraceId);
    }
    
    return 0;
}

DWORD
RasApiDebugTerm()
{
    // XP 395648
    //
    // Registering for trace notifications from the rasman process 
    // can leak tokens because of impersonation.
    //
    if (g_dwIsRasmanProcess == 2)
    {
        g_dwIsRasmanProcess = (IsRasmanProcess()) ? 1 : 0;
    }
    
    if (g_dwIsRasmanProcess == 0)
    {
        DebugTermEx(&g_dwRasApi32TraceId);
    }
    
    return 0;
}
    
BOOL
FRunningInAppCompatMode()
{
    BOOL fResult = FALSE;
    TCHAR *pszCommandLine = NULL;
    TCHAR *psz;

    pszCommandLine = StrDup(GetCommandLine());

    if(NULL == pszCommandLine)
    {
        goto done;
    }

    psz = pszCommandLine + lstrlen(pszCommandLine);

    while(      (TEXT('\\') != *psz)
            &&  (psz != pszCommandLine))
    {
        psz--;
    }

    if(TEXT('\\') == *psz)
    {
        psz++;
    }

    if(     (TRUE == CaseInsensitiveMatch(psz, TEXT("INETINFO.EXE")))
        ||  (TRUE == CaseInsensitiveMatch(psz, TEXT("WSPSRV.EXE"))))
    {
        fResult = TRUE;
    }

done:

    if(NULL != pszCommandLine)
    {
        Free(pszCommandLine);
    }

    return fResult;
}

                     

VOID
ReloadRasconncbEntry(
    RASCONNCB*  prasconncb )

/*++

Routine Description:

    Reload the phonebook entry for the given RASCONNCB

Arguments:

Return Value:

--*/

{
    DWORD       dwErr;
    DTLNODE*    pdtlnode;
    PLIST_ENTRY pEntry;
    TCHAR*      pszPath;


    //
    // Before we close the phonebook save the
    // path, since we don't have it stored anywhere
    // else.
    //
    pszPath = StrDup(prasconncb->pbfile.pszPath);

    if (pszPath == NULL)
    {
        prasconncb->dwError = ERROR_NOT_ENOUGH_MEMORY;
        return;
    }

    ClosePhonebookFile(&prasconncb->pbfile);

    dwErr = GetPbkAndEntryName(
                    pszPath,
                    prasconncb->rasdialparams.szEntryName,
                    RPBF_NoCreate,
                    &prasconncb->pbfile,
                    &pdtlnode);

    Free(pszPath);

    if(dwErr)
    {
        prasconncb->dwError = dwErr;
        return;
    }

    prasconncb->pEntry = (PBENTRY *)DtlGetData(pdtlnode);
    ASSERT(prasconncb->pEntry);

    //
    // Find the link.
    //
    pdtlnode = DtlNodeFromIndex(
                 prasconncb->pEntry->pdtllistLinks,
                 prasconncb->rasdialparams.dwSubEntry - 1);

    if (pdtlnode == NULL)
    {
        prasconncb->dwError = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
        return;
    }

    prasconncb->pLink = (PBLINK *)DtlGetData(pdtlnode);
    ASSERT(prasconncb->pLink);

    //
    // Reset the phonebook entry for all subentries
    // in the connection, since a field in it has
    // changed.
    //
    for (pEntry = prasconncb->ListEntry.Flink;
         pEntry != &prasconncb->ListEntry;
         pEntry = pEntry->Flink)
    {
        RASCONNCB *prcb = CONTAINING_RECORD(pEntry, RASCONNCB, ListEntry);

        //
        // Set the phonebook descriptor.
        //
        memcpy(
          &prcb->pbfile,
          &prasconncb->pbfile,
          sizeof (prcb->pbfile));

        //
        // Set the entry.
        //
        prcb->pEntry = prasconncb->pEntry;

        //
        // Recalculate the link.
        //
        pdtlnode = DtlNodeFromIndex(
                     prcb->pEntry->pdtllistLinks,
                     prcb->rasdialparams.dwSubEntry - 1);

        if (pdtlnode == NULL)
        {
            prasconncb->dwError = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
            break;
        }

        prcb->pLink = (PBLINK *)DtlGetData(pdtlnode);
        ASSERT(prcb->pLink);
    }
}


VOID
FinalCleanUpRasconncbNode(
    DTLNODE *pdtlnode
    )
{
    RASCONNCB*  prasconncb          = DtlGetData(pdtlnode);
    RASCONNCB*  prasconncbTmp;
    BOOL        fConnectionPresent  = FALSE;
    DTLNODE*    pdtlnodeTmp;

    RASAPI32_TRACE1(
      "FinalCleanUpRasconncbNode: deallocating prasconncb=0x%x",
      prasconncb);

    EnterCriticalSection(&RasconncbListLock);

    //
    // Make sure the subentry list is empty.
    //
    ASSERT(IsListEmpty(&prasconncb->ListEntry));

    //
    // make sure that we still have the connection block
    //
    for (pdtlnodeTmp = DtlGetFirstNode( PdtllistRasconncb );
         pdtlnodeTmp;
         pdtlnodeTmp = DtlGetNextNode( pdtlnodeTmp ))
    {
        prasconncbTmp = (RASCONNCB* )DtlGetData( pdtlnodeTmp );

        ASSERT(prasconncbTmp);

        if (prasconncbTmp == prasconncb)
        {
            fConnectionPresent = TRUE;
            break;
        }
    }


    if (!fConnectionPresent)
    {
        RASAPI32_TRACE1(
            "FinalCleanupRasconncbNode: connection 0x%x not found",
            prasconncb);

        LeaveCriticalSection(&RasconncbListLock);

        return;
    }

    if(NULL != prasconncb->RasEapInfo.pbEapInfo)
    {
        LocalFree(prasconncb->RasEapInfo.pbEapInfo);
        prasconncb->RasEapInfo.pbEapInfo = NULL;
        prasconncb->RasEapInfo.dwSizeofEapInfo = 0;
    }

    if(NULL != prasconncb->pAddresses)
    {
        LocalFree(prasconncb->pAddresses);
        prasconncb->iAddress = prasconncb->cAddresses = 0;
    }

    //
    // Finally free the connection block.
    //
    pdtlnode = DtlDeleteNode( PdtllistRasconncb, pdtlnode );

    //
    // If there are no more connection blocks
    // on the list, then shutdown the asyncmachine
    // worker thread.
    //
    RASAPI32_TRACE1(
        "FinalCleanUpRasconncbNode: %d nodes remaining",
        DtlGetNodes(PdtllistRasconncb));

    if (!DtlGetNodes(PdtllistRasconncb))
    {
        ShutdownAsyncMachine();
    }

    LeaveCriticalSection(&RasconncbListLock);
}


VOID
DeleteRasconncbNodeCommon(
    IN DTLNODE *pdtlnode
    )
{
    RASCONNCB *prasconncb = (RASCONNCB *)DtlGetData(pdtlnode);

    ASSERT(prasconncb);

    //
    // If we've already deleted this node, then return.
    //
    if (prasconncb->fDeleted)
    {
        return;
    }

    RASAPI32_TRACE1(
        "DeleteRasconncbNodeCommon: prasconncb=0x%x",
        prasconncb);

    //gangz
    //Safely wipe out password first
    //
    SafeWipePasswordBuf(prasconncb->rasdialparams.szPassword);
    SafeWipePasswordBuf(prasconncb->szOldPassword);

    //
    // If we are the only one using the
    // phonebook structure, close it.
    //
    if (!IsListEmpty(&prasconncb->ListEntry))
    {
        RemoveEntryList(&prasconncb->ListEntry);
        InitializeListHead(&prasconncb->ListEntry);
    }
    else if (!prasconncb->fDefaultEntry)
    {
        ClosePhonebookFile(&prasconncb->pbfile);
    }

    // if this is a synchronous operation, fill in the
    // error
    if (prasconncb->psyncResult)
    {
        *(prasconncb->psyncResult) = prasconncb->dwError;
    }

    //
    // Make sure the async work item is
    // unregistered.
    //
    CloseAsyncMachine( &prasconncb->asyncmachine );

    //
    // Set the deleted flag to prevent us from
    // attempting to delete the node twice.
    //
    prasconncb->fDeleted = TRUE;

    //
    // If there is not yet a port associated with
    // the async machine's connection block, then
    // we free the memory associated with the
    // connection block now.  Otherwise, we have
    // to wait for the asyncmachine worker thread
    // to receive the last I/O completion port event
    // from rasman, at which time the
    // asyncmachine->freefunc is called.
    //
    if (prasconncb->asyncmachine.hport == INVALID_HPORT)
    {
        FinalCleanUpRasconncbNode(pdtlnode);
    }
}


VOID
DeleteRasconncbNode(
    IN RASCONNCB* prasconncb )

/*++

Routine Description:

    Remove 'prasconncb' from the PdtllistRasconncb list
    and release all resources associated with it.

Arguments:

Return Value:

--*/

{
    DWORD       dwErr;
    DTLNODE*    pdtlnode;
    RASCONNCB*  prasconncbTmp;

    EnterCriticalSection(&RasconncbListLock);

    //
    // Enumerate all connections to make sure we
    // are still on the list.
    //
    for (pdtlnode = DtlGetFirstNode( PdtllistRasconncb );
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode ))
    {
        prasconncbTmp = (RASCONNCB* )DtlGetData( pdtlnode );

        ASSERT(prasconncbTmp);

        if (prasconncbTmp == prasconncb)
        {
            DeleteRasconncbNodeCommon(pdtlnode);
            break;
        }
    }

    LeaveCriticalSection(&RasconncbListLock);
}


VOID
CleanUpRasconncbNode(
    IN DTLNODE *pdtlnode
    )
{
    DWORD dwErr;
    RASCONNCB *prasconncb = (RASCONNCB *)DtlGetData(pdtlnode);

    ASSERT(prasconncb);

    RASAPI32_TRACE("CleanUpRasconncbNode");

    //
    // Stop the async machine before we close the
    // port.
    //
    if (!prasconncb->fStopped)
    {
        prasconncb->fStopped = TRUE;

        StopAsyncMachine(&prasconncb->asyncmachine);

    }

    //
    // rascauth.dll may not have been loaded,
    // so test the function pointer first.
    //
    if (g_pAuthStop != NULL)
    {
        //
        // It is always safe to call AuthStop, i.e. if AuthStart
        // was never called or the HPORT is invalid it may return
        // an error but won't crash.
        //
        RASAPI32_TRACE("(CU) AuthStop...");

        g_pAuthStop( prasconncb->hport );

        RASAPI32_TRACE("(CU) AuthStop done");
    }

    if (prasconncb->dwError)
    {
        RASMAN_INFO info;

        //
        // Stop PPP on error.
        //
        RASAPI32_TRACE("(CU) RasPppStop...");

        g_pRasPppStop(prasconncb->hport);

        RASAPI32_TRACE("(CU) RasPppStop done");

    }

    //
    // Set the flag that notes we've cleaned up
    // this connection block.
    //
    prasconncb->fCleanedUp = TRUE;

    //
    // If there is no user thread waiting
    // for this connection, then free the
    // connection block now.
    //
    DeleteRasconncbNodeCommon(pdtlnode);

    RASAPI32_TRACE("CleanUpRasconncbNode done");
}


DWORD
ErrorFromDisconnectReason(
    IN RASMAN_DISCONNECT_REASON reason )

/*++

Routine Description:

    Converts disconnect reason 'reason' (retrieved from
    RASMAN_INFO) into an equivalent error code. Returns
    the result of the conversion.

Arguments:

Return Value:

--*/

{
    DWORD dwError = ERROR_DISCONNECTION;

    if (reason == REMOTE_DISCONNECTION)
    {
        dwError = ERROR_REMOTE_DISCONNECTION;
    }
    else if (reason == HARDWARE_FAILURE)
    {
        dwError = ERROR_HARDWARE_FAILURE;
    }
    else if (reason == USER_REQUESTED)
    {
        dwError = ERROR_USER_DISCONNECTION;
    }

    return dwError;
}


IPADDR
IpaddrFromAbcd(
    IN TCHAR* pchIpAddress )

/*++

Routine Description:

    Convert caller's a.b.c.d IP address string to the
    numeric equivalent in big-endian, i.e. Motorola format.

Arguments:

Return Value:

    Returns the numeric IP address or 0 if formatted
    incorrectly.

--*/

{
    INT  i;
    LONG lResult = 0;

    for (i = 1; i <= 4; ++i)
    {
        LONG lField = _ttol( pchIpAddress );

        if (lField > 255)
        {
            return (IPADDR )0;
        }

        lResult = (lResult << 8) + lField;

        while (     *pchIpAddress >= TEXT('0')
                &&  *pchIpAddress <= TEXT('9'))
        {
            pchIpAddress++;
        }

        if (    i < 4
            &&  *pchIpAddress != TEXT('.'))
        {
            return (IPADDR )0;
        }

        pchIpAddress++;
    }

    return (IPADDR )(net_long( lResult ));
}


DWORD
LoadRasiphlpDll()

/*++

Routine Description:

    Loads the RASIPHLP.DLL and it's entrypoints.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0
    error code.

--*/

{
    static BOOL fRasiphlpDllLoaded = FALSE;

    if (fRasiphlpDllLoaded)
    {
        return 0;
    }

    if (    !(hinstIpHlp = LoadLibrary( TEXT("RASIPHLP.DLL")))
        ||  !(PHelperSetDefaultInterfaceNet =
                (HELPERSETDEFAULTINTERFACENET )GetProcAddress(
                    hinstIpHlp, "HelperSetDefaultInterfaceNet" )))
    {
        return GetLastError();
    }

    fRasiphlpDllLoaded = TRUE;

    return 0;
}

DWORD
LoadMprApiDll()
{
    static BOOL fMprapiDllLoaded = FALSE;

    if(fMprapiDllLoaded)
    {
        return 0;
    }

    if(     !(hinstMprapi = LoadLibrary(TEXT("mprapi.dll")))
        ||  !(PMprAdminIsServiceRunning =
                (MPRADMINISSERVICERUNNING) GetProcAddress(
                        hinstMprapi, "MprAdminIsServiceRunning")))
    {
        return GetLastError();
    }

    fMprapiDllLoaded = TRUE;

    return 0;
}

DWORD
DwOpenDefaultEntry(RASCONNCB *prasconncb)
{
    DWORD dwErr = SUCCESS;

    dwErr = OpenMatchingPort(prasconncb);

    return dwErr;
}

DWORD
DwGetDeviceName(RASCONNCB *prasconncb,
                CHAR      *pszDeviceName)
{
    DWORD dwErr = ERROR_SUCCESS;

    ASSERT(prasconncb->dwCurrentVpnProt < NUMVPNPROTS);

    RASAPI32_TRACE1("RasGetDeviceName(rdt=%d)...",
          prasconncb->ardtVpnProts[prasconncb->dwCurrentVpnProt]);

    dwErr = g_pRasGetDeviceName(
            prasconncb->ardtVpnProts[prasconncb->dwCurrentVpnProt],
            pszDeviceName);

    RASAPI32_TRACE1("RasGetDeviceName. 0x%x",
           dwErr);

    return dwErr;
}

DWORD
DwOpenPort(RASCONNCB *prasconncb)
{
    DWORD dwErr = SUCCESS;
    DWORD dwFlags = 0;

    RASAPI32_TRACE("DwOpenPort");

    if(     (prasconncb->fDefaultEntry)
        ||  (RASET_Direct == prasconncb->pEntry->dwType))
    {
        //
        // Get all ports and try to open a port
        // of devicetype modem
        //
        dwErr = DwOpenDefaultEntry(prasconncb);

        goto done;
    }

    lstrcpyn(prasconncb->szUserKey,
            prasconncb->pEntry->pszEntryName,
            sizeof(prasconncb->szUserKey) / sizeof(WCHAR));

    //
    // Open any port on the specified device. RasPortOpen
    // will loop over all ports on the device and open
    // one if available.
    //
    if(     UPM_Normal == prasconncb->dwUserPrefMode)
    {
        dwFlags = CALL_OUT;
    }
    else if(UPM_Logon  == prasconncb->dwUserPrefMode)
    {
        dwFlags = CALL_OUT|CALL_LOGON;
    }
    else if(UPM_Router == prasconncb->dwUserPrefMode)
    {
        dwFlags = CALL_ROUTER;

        if(RASET_Broadband == prasconncb->pEntry->dwType)
        {
            dwFlags = CALL_OUTBOUND_ROUTER;
        }
    }

    {
        CHAR szDeviceName[MAX_DEVICE_NAME + 1];

        if(RASET_Vpn == prasconncb->pEntry->dwType)
        {

            dwErr = DwGetDeviceName(prasconncb,
                                    szDeviceName);

            if(ERROR_SUCCESS != dwErr)
            {
                if(     (ERROR_DEVICETYPE_DOES_NOT_EXIST != dwErr)

                    ||  (   ERROR_DEVICETYPE_DOES_NOT_EXIST
                                == dwErr
                        &&  ERROR_SUCCESS
                                == prasconncb->dwSavedError))
                {
                    prasconncb->dwSavedError = dwErr;
                }

                RASAPI32_TRACE1("DwGetDeviceName failed. 0x%x",
                       dwErr);

                goto done;
            }
        }
        else
        {
            strncpyWtoAAnsi(szDeviceName,
                       prasconncb->pLink->pbport.pszDevice,
                       sizeof(szDeviceName));
        }

        //
        // Open the port
        //
        RASAPI32_TRACE2("DwOpenPort: RasPortOpenEx(%s,%d)...",
                szDeviceName,
                prasconncb->dwDeviceLineCounter);

        dwErr = g_pRasPortOpenEx(
                    szDeviceName,
                    prasconncb->dwDeviceLineCounter,
                    &prasconncb->hport,
                    hDummyEvent,
                    &dwFlags);

        RASAPI32_TRACE2("DwOpenPort: RasPortOpenEx done(%d). Flags=0x%x",
                dwErr,
                dwFlags);

        if (dwErr == 0)
        {
            RASMAN_INFO ri;
            
            ZeroMemory(&ri, sizeof(RASMAN_INFO));

            //
            // Get the information on the port we just
            // opened so that we can copy the portname,
            // etc.
            //
            dwErr = g_pRasGetInfo(NULL,
                                  prasconncb->hport,
                                  &ri);

            if(0 != dwErr)
            {
                RASAPI32_TRACE2("DwOpenPort: RasGetInfo(%d) failed with %d",
                        prasconncb->hport, dwErr);

                goto done;
            }

            strncpyAtoTAnsi(
                prasconncb->szPortName,
                ri.RI_szPortName,
                sizeof(prasconncb->szPortName) / sizeof(TCHAR));

            strncpyAtoTAnsi(
                prasconncb->szDeviceType,
                ri.RI_szDeviceType,
                sizeof(prasconncb->szDeviceType) / sizeof(TCHAR));

            strncpyAtoTAnsi(
                prasconncb->szDeviceName,
                ri.RI_szDeviceName,
                sizeof(prasconncb->szDeviceName) / sizeof(TCHAR));

            RASAPI32_TRACE1("DwOpenPort: PortOpened = %S",
                    prasconncb->szPortName);
        }
    }

done:

    if(     (ERROR_NO_MORE_ITEMS == dwErr)
        &&  (ERROR_SUCCESS == prasconncb->dwSavedError)
        &&  (CALL_DEVICE_NOT_FOUND & dwFlags))
    {
        prasconncb->dwSavedError = ERROR_CONNECTING_DEVICE_NOT_FOUND;
    }

    if(     (RASEDM_DialAll == prasconncb->pEntry->dwDialMode)
        &&  (ERROR_NO_MORE_ITEMS == dwErr))
    {
        prasconncb->fTryNextLink = FALSE;
    }

    RASAPI32_TRACE1("DwOpenPort done. %d", dwErr);

    return ( (dwErr) ? ERROR_PORT_NOT_AVAILABLE : 0);
}


DWORD
OpenMatchingPort(
    IN OUT RASCONNCB* prasconncb )

/*++

Routine Description:

    Opens the port indicated in the entry (or default entry)
    and fills in the port related members of the connection
    control block.

Arguments:

Return Value:

    Returns 0 if successful, or a non-0 error code.

--*/

{
    DWORD        dwErr;
    RASMAN_PORT* pports;
    RASMAN_PORT* pport;
    INT          i;
    DWORD        dwPorts;
    TCHAR        szPort[RAS_MAXLINEBUFLEN + 1];
    BOOL         fAny       = FALSE;
    BOOL         fTypeMatch,
                 fPortMatch;
    PBENTRY      *pEntry    = prasconncb->pEntry;
    PBLINK       *pLink     = prasconncb->pLink;
    PBDEVICETYPE pbdtWant;

    RASAPI32_TRACE("OpenMatchingPort");

    if (prasconncb->fDefaultEntry)
    {
        //
        // No phonebook entry.  Default to any modem port
        // and UserKey of ".<phonenumber>".
        //
        fAny        = TRUE;
        szPort[0]   = TEXT('\0');
        pbdtWant    = PBDT_Modem;

        prasconncb->szUserKey[ 0 ] = TEXT('.');

        lstrcpyn(
            prasconncb->szUserKey + 1,
            prasconncb->rasdialparams.szPhoneNumber,
            (sizeof(prasconncb->szUserKey) / sizeof(WCHAR)) - 1);
    }
    else
    {
        //
        // Phonebook entry.  Get the port name and type.
        //
        lstrcpyn(
            prasconncb->szUserKey,
            pEntry->pszEntryName,
            sizeof(prasconncb->szUserKey) / sizeof(WCHAR));

        lstrcpyn(
            szPort,
            pLink->pbport.pszPort,
            sizeof(szPort) / sizeof(TCHAR));

        pbdtWant = pLink->pbport.pbdevicetype;

    }

    prasconncb->fTryNextLink = FALSE;

    dwErr = GetRasPorts(NULL, &pports, &dwPorts );

    if (dwErr != 0)
    {
        return dwErr;
    }

again:

    //
    // Loop thru enumerated ports to find and open a matching one...
    //
    dwErr = ERROR_PORT_NOT_AVAILABLE;

    for (i = 0, pport = pports; i < (INT )dwPorts; ++i, ++pport)
    {
        PBDEVICETYPE pbdt;
        RASMAN_INFO info;

        //
        // Only interested in dial-out or biplex ports,
        // depending on who called us.
        //
        if (    prasconncb->dwUserPrefMode == UPM_Normal
            &&  !(pport->P_ConfiguredUsage & CALL_OUT))
        {
            continue;
        }

        if (    prasconncb->dwUserPrefMode == UPM_Router
            &&  !(pport->P_ConfiguredUsage & CALL_ROUTER))
        {
            continue;
        }

        {
            TCHAR szPortName[MAX_PORT_NAME],
                  szDeviceType[MAX_DEVICETYPE_NAME];

            strncpyAtoT(
                szPortName,
                pport->P_PortName,
                sizeof(szPortName) / sizeof(TCHAR));

            strncpyAtoT(
                szDeviceType,
                pport->P_DeviceType,
                sizeof(szDeviceType) / sizeof(TCHAR));

            pbdt = PbdevicetypeFromPszType(szDeviceType);

            fTypeMatch = (pbdt == pbdtWant);

            fPortMatch = !lstrcmpi(szPortName, szPort);
        }

        //
        // Only interested in dial-out ports if the port is closed.
        // Biplex port Opens, on the other hand, may succeed even
        // if the port is open.
        //
        if (    pport->P_ConfiguredUsage == CALL_OUT
            &&  pport->P_Status != CLOSED)
        {
            continue;
        }

        RASAPI32_TRACE4("OpenMatchingPort: (%d,%d), (%s,%S)",
                pbdt,
                pbdtWant,
                pport->P_PortName,
                szPort);

        //
        // Only interested in devices matching caller's port or
        // of the same type as caller's "any" specification.
        //
        if (    fAny
            && (    !fTypeMatch
                ||  fPortMatch))
        {
            continue;
        }

        if (    !fAny
            &&  !fPortMatch)
        {
            continue;
        }

        dwErr = g_pRasGetInfo( NULL,
                               pport->P_Handle,
                               &info );
        if (    !dwErr
            &&  info.RI_ConnectionHandle != (HCONN)NULL)
        {
            RASAPI32_TRACE("OpenMatchinPort: port in use by another "
                  "connection!");

            dwErr = ERROR_PORT_NOT_AVAILABLE;

            continue;
        }

        //
        // We also don't want to open a port whose
        // state may be changing.
        //
        if (    !dwErr
            &&  info.RI_PortStatus != CLOSED
            &&  info.RI_ConnState != LISTENING)
        {
            RASAPI32_TRACE2(
              "OpenMatchingPort: port state changing: "
              "RI_PortStatus=%d, RI_ConnState=%d",
              info.RI_PortStatus,
              info.RI_ConnState);

            dwErr = ERROR_PORT_NOT_AVAILABLE;

            continue;
        }

        RASAPI32_TRACE1("RasPortOpen(%S)...", szPort);

        dwErr = g_pRasPortOpen(
                pport->P_PortName,
                &prasconncb->hport,
                hDummyEvent );

        RASAPI32_TRACE1("RasPortOpen done(%d)", dwErr);

        if (dwErr == 0)
        {
            strncpyAtoTAnsi(
                prasconncb->szPortName,
                pport->P_PortName,
                sizeof(prasconncb->szPortName) / sizeof(TCHAR));

            strncpyAtoTAnsi(
                prasconncb->szDeviceType,
                pport->P_DeviceType,
                sizeof(prasconncb->szDeviceType) / sizeof(TCHAR));

            strncpyAtoTAnsi(
                prasconncb->szDeviceName,
                pport->P_DeviceName,
                sizeof(prasconncb->szDeviceName) / sizeof(TCHAR));

            break;
        }

        //
        //
        // If we are searching for a particular port,
        // there is no reason to continue.
        //
        if (!fAny)
        {
            break;
        }
    }

    //
    // If we get here, the open was unsuccessful.
    // If this is our first time through, then we
    // reiterate looking for a device of the same
    // type.  If this is not our first time through,
    // then we simply finish our second iteration
    // over the devices.
    // For BAP we don't want to do this - doesn't make
    // sense.
    // For Direct Connect devices, we are looking for
    // the particular port. We don't want to open
    // matching ports..
    //
    if (    (dwErr)
        &&  (!fAny)
        &&  (RASET_Direct != prasconncb->pEntry->dwType)
        &&  (0 == (prasconncb->pEntry->dwDialMode
                   & RASEDM_DialAsNeeded)))
    {
        RASAPI32_TRACE("Starting over looking for any like device");

        fAny = TRUE;

        goto again;
    }

    else if (   dwErr
            &&  (prasconncb->pEntry->dwDialMode
                 & RASEDM_DialAsNeeded))
    {
        RASAPI32_TRACE1(
            "OpenMatchingPort: %d. Not iterating over other ports "
            "because of BAP",
            dwErr);
    }


    Free( pports );

    return dwErr ? ERROR_PORT_NOT_AVAILABLE : 0;
}


DWORD
ReadPppInfoFromEntry(
    IN  RASCONNCB* prasconncb )

/*++

Routine Description:

    Reads PPP information from the current phonebook entry.
    'h' is the handle of the phonebook file.  'prasconncb'
    is the address of the current connection control block.

Arguments:

Return Value:

    Returns 0 if succesful, otherwise a non-0 error code.

--*/

{
    DWORD       dwErr;
    DWORD       dwfExcludedProtocols    = 0;
    DWORD       dwRestrictions          = AR_AuthAny;
    BOOL        fDataEncryption         = FALSE;
    DWORD       dwfInstalledProtocols;
    PBENTRY*    pEntry                  = prasconncb->pEntry;
    BOOL  fIpPrioritizeRemote   = TRUE;
    BOOL  fIpVjCompression      = TRUE;
    DWORD dwIpAddressSource     = PBUFVAL_ServerAssigned;
    CHAR* pszIpAddress          = NULL;
    DWORD dwIpNameSource        = PBUFVAL_ServerAssigned;
    CHAR* pszIpDnsAddress       = NULL;
    CHAR* pszIpDns2Address      = NULL;
    CHAR* pszIpWinsAddress      = NULL;
    CHAR* pszIpWins2Address     = NULL;
    CHAR* pszIpDnsSuffix        = NULL;


    //
    // Get the installed protocols depending on being called
    // from router/client
    //
    if ( prasconncb->dwUserPrefMode & UPM_Router )
    {
        dwfInstalledProtocols =
                GetInstalledProtocolsEx(NULL,
                                        TRUE,
                                        FALSE,
                                        TRUE );
    }
    else
    {
        dwfInstalledProtocols =
                GetInstalledProtocolsEx(NULL,
                                        FALSE,
                                        TRUE,
                                        FALSE);
    }

    if (prasconncb->fDefaultEntry)
    {
        //
        // Set "default entry" defaults.
        //
        prasconncb->dwfPppProtocols = dwfInstalledProtocols;

        prasconncb->fPppMode        = TRUE;

#ifdef AMB
        prasconncb->dwAuthentication = AS_PppThenAmb;
/*#else
        prasconncb->dwAuthentication = AS_PppOnly; */
#endif
        prasconncb->fNoClearTextPw = FALSE;

        prasconncb->fLcpExtensions = TRUE;

        prasconncb->fRequireEncryption = FALSE;
        return 0;
    }

    dwRestrictions = pEntry->dwAuthRestrictions;

    // [pmay] derive auth restrictions based on new flags
    // if (    dwRestrictions == AR_AuthTerminal
    //     &&  !prasconncb->fAllowPause)
    // {
    //     return ERROR_INTERACTIVE_MODE;
    // }

    //
    // PPP LCP extension RFC options enabled.
    //
    prasconncb->fLcpExtensions = pEntry->fLcpExtensions;

    //
    // PPP data encryption required.
    //
    fDataEncryption = (     (pEntry->dwDataEncryption != DE_None)
                        &&  (pEntry->dwDataEncryption != DE_IfPossible));

    // [pmay] derive auth restrictions based on new flags
    prasconncb->fNoClearTextPw = !(dwRestrictions & AR_F_AuthPAP);

    // [pmay] AR_AuthMsEncrypted => only AR_F_MSCHAP is set
    // if (dwRestrictions == AR_AuthMsEncrypted)
    if (    (dwRestrictions & AR_F_AuthMSCHAP)
        &&  (fDataEncryption))
    {
        prasconncb->fRequireEncryption = TRUE;
    }

    if(     (dwRestrictions & AR_F_AuthMSCHAP2)
        &&  (fDataEncryption))
    {
        prasconncb->fRequireEncryption = TRUE;
    }

    //
    // PPP protocols to request is the installed protocols
    // less this entry's excluded protocols.
    //
    dwfExcludedProtocols = pEntry->dwfExcludedProtocols;

    prasconncb->dwfPppProtocols =
        dwfInstalledProtocols & ~(dwfExcludedProtocols);

    /*
    prasconncb->dwAuthentication = AS_PppOnly;
    */

    //
    // Adjust the authentication strategy if indicated.
    //
    if (    prasconncb->dwfPppProtocols == 0
        ||  prasconncb->pEntry->dwBaseProtocol == BP_Ras)
    {

        /*
        if (dwfInstalledProtocols & NP_Nbf)
        {
            prasconncb->dwAuthentication = AS_AmbOnly;
        }
        else
        {
            return ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
        } */

        return ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
    }

#if AMB
    else if (prasconncb->dwAuthentication == (DWORD )-1)
    {
        //
        // Choosing a PPP default.  If NBF is installed,
        // consider AMBs as a possibility.  Otherwise, use
        // PPP only.
        //
        if (dwfInstalledProtocols & NP_Nbf)
        {
            prasconncb->dwAuthentication = AS_PppThenAmb;
        }
        else
        {
            prasconncb->dwAuthentication = AS_PppOnly;
        }
    }
    else if (   prasconncb->dwAuthentication == AS_PppThenAmb
             || prasconncb->dwAuthentication == AS_AmbThenPpp)
    {
        //
        // Using an AMB dependent PPP strategy.  If NBF is
        // not installed, eliminate the AMB dependency.
        //
        if (!(dwfInstalledProtocols & NP_Nbf))
        {
            prasconncb->dwAuthentication = AS_PppOnly;
        }
    }
    else if (prasconncb->dwAuthentication == AS_PppOnly)
    {
        //
        // Using a PPP strategy without considering AMBs.
        // If NBF if installed, add AMBs as a fallback.
        //
        if (dwfInstalledProtocols & NP_Nbf)
        {
            prasconncb->dwAuthentication = AS_PppThenAmb;
        }
    }
#endif

#if 0
    //
    // Check to make sure we haven't specified
    // AMB as the authentication strategy.
    //
    if (    prasconncb->dwAuthentication == AS_PppThenAmb
        ||  prasconncb->dwAuthentication == AS_AmbThenPpp)
    {
        prasconncb->dwAuthentication = AS_PppOnly;
    }
    else if (prasconncb->dwAuthentication == AS_AmbOnly)
        return ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
#endif

    //
    // The starting authentication mode is set to whatever
    // comes first in the specified authentication order.
    //
    /*
    prasconncb->fPppMode =
        (   prasconncb->dwAuthentication != AS_AmbThenPpp
         && prasconncb->dwAuthentication != AS_AmbOnly); */

    prasconncb->fPppMode = TRUE;

    //
    // Load the UI->CP parameter buffer with options we want
    // to pass to the PPP CPs (currently just IPCP).
    //
    do {

        ClearParamBuf( prasconncb->szzPppParameters );

        //
        // PPP protocols to request is the installed protocols
        // less the this entry's excluded protocols.
        //
        fIpPrioritizeRemote = pEntry->fIpPrioritizeRemote;

        AddFlagToParamBuf(
            prasconncb->szzPppParameters,
            PBUFKEY_IpPrioritizeRemote,
            fIpPrioritizeRemote );

        fIpVjCompression = pEntry->fIpHeaderCompression;

        AddFlagToParamBuf(
            prasconncb->szzPppParameters,
            PBUFKEY_IpVjCompression,
            fIpVjCompression );

        dwIpAddressSource = pEntry->dwIpAddressSource;

        AddLongToParamBuf(
            prasconncb->szzPppParameters,
            PBUFKEY_IpAddressSource,
            (LONG )dwIpAddressSource );

        pszIpAddress = strdupWtoA(pEntry->pszIpAddress);

        if(NULL == pszIpAddress)
        {
            break;
        }

        AddStringToParamBuf(
            prasconncb->szzPppParameters,
            PBUFKEY_IpAddress, pszIpAddress );

        //Free(pszIpAddress);

        dwIpNameSource = pEntry->dwIpNameSource;

        AddLongToParamBuf(
            prasconncb->szzPppParameters,
            PBUFKEY_IpNameAddressSource,
            (LONG )dwIpNameSource );

        pszIpDnsAddress = strdupWtoA(pEntry->pszIpDnsAddress);

        if(NULL == pszIpDnsAddress)
        {
            break;
        }

        AddStringToParamBuf(
            prasconncb->szzPppParameters,
            PBUFKEY_IpDnsAddress,
            pszIpDnsAddress );

        //Free(pszIpDnsAddress);

        pszIpDns2Address = strdupWtoA(pEntry->pszIpDns2Address);

        if(NULL == pszIpDns2Address)
        {
            break;
        }

        AddStringToParamBuf(
            prasconncb->szzPppParameters,
            PBUFKEY_IpDns2Address,
            pszIpDns2Address );

        //Free(pszIpDns2Address);

        pszIpWinsAddress = strdupWtoA(pEntry->pszIpWinsAddress);

        if(NULL == pszIpWinsAddress)
        {
            break;
        }

        AddStringToParamBuf(
            prasconncb->szzPppParameters,
            PBUFKEY_IpWinsAddress,
            pszIpWinsAddress );

        //Free(pszIpWinsAddress);

        pszIpWins2Address = strdupWtoA(pEntry->pszIpWins2Address);
    
        if(NULL == pszIpWins2Address)
        {
            break;
        }

        AddStringToParamBuf(
            prasconncb->szzPppParameters,
            PBUFKEY_IpWins2Address,
            pszIpWins2Address );

        //Free(pszIpWins2Address);

        AddLongToParamBuf(
            prasconncb->szzPppParameters,
            PBUFKEY_IpDnsFlags,
            (LONG )prasconncb->pEntry->dwIpDnsFlags);
        
        pszIpDnsSuffix = strdupWtoA(pEntry->pszIpDnsSuffix);

        if(NULL == pszIpDnsSuffix)
        {
            break;
        }

        AddStringToParamBuf(
            prasconncb->szzPppParameters,
            PBUFKEY_IpDnsSuffix,
            pszIpDnsSuffix);

        //Free(pszIpDnsSuffix);

    } while(FALSE);

    Free0(pszIpAddress);
    Free0(pszIpDnsAddress);
    Free0(pszIpDns2Address);
    Free0(pszIpWinsAddress);
    Free0(pszIpWins2Address);
    Free0(pszIpDnsSuffix);

    return 0;
}



DWORD
ReadConnectionParamsFromEntry(
    IN  RASCONNCB* prasconncb,
    OUT PRAS_CONNECTIONPARAMS pparams)

/*++

Routine Description:

   Reads connection management information from the
   current phonebook entry. 'prasconncb' is the address
   of the current connection control block.

Arguments:

Return Value:

   Returns 0 if succesful, otherwise a non-0 error code.

--*/

{
    DWORD dwErr;
    PBENTRY *pEntry = prasconncb->pEntry;

    pparams->CP_ConnectionFlags = 0;

    if(     pEntry->fRedialOnLinkFailure
        &&  (0 == (prasconncb->dwUserPrefMode & UPM_Logon)))
    {
        pparams->CP_ConnectionFlags |= CONNECTION_REDIALONLINKFAILURE;
    }

    if(pEntry->fShareMsFilePrint)
    {
        pparams->CP_ConnectionFlags |= CONNECTION_SHAREFILEANDPRINT;
    }

    if(pEntry->fBindMsNetClient)
    {
        pparams->CP_ConnectionFlags |= CONNECTION_BINDMSNETCLIENT;
    }

    if(pEntry->fUseRasCredentials)
    {
        pparams->CP_ConnectionFlags |= CONNECTION_USERASCREDENTIALS;
    }

    if(pEntry->dwIpSecFlags & AR_F_IpSecPSK)
    {
        pparams->CP_ConnectionFlags |= CONNECTION_USEPRESHAREDKEY;
    }
    
    pparams->CP_IdleDisconnectSeconds =
            (DWORD) pEntry->lIdleDisconnectSeconds;

    strncpyTtoA(
        pparams->CP_Phonebook,
        prasconncb->pbfile.pszPath,
        sizeof(pparams->CP_Phonebook));

    strncpyTtoA(
        pparams->CP_PhoneEntry,
        prasconncb->szUserKey,
        sizeof(pparams->CP_PhoneEntry));

    return 0;
}


DWORD
ReadSlipInfoFromEntry(
    IN  RASCONNCB* prasconncb,
    OUT TCHAR**    ppszIpAddress,
    OUT BOOL*      pfHeaderCompression,
    OUT BOOL*      pfPrioritizeRemote,
    OUT DWORD*     pdwFrameSize )

/*++

Routine Description:

   Only if the entry is a SLIP entry is non-NULL IP
   address returned, in which case the string should
   be freed by the caller.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0 error code.

--*/

{
    PBENTRY *pEntry = prasconncb->pEntry;

    *ppszIpAddress          = NULL;
    *pfHeaderCompression    = FALSE;
    *pdwFrameSize           = 0;

    //
    // If it's a default entry, it's not SLIP.
    //
    if (prasconncb->fDefaultEntry)
    {
        return 0;
    }

    //
    // Find the base protocol.  If it's not SLIP, were done.
    //
    if (pEntry->dwBaseProtocol != BP_Slip)
    {
        return 0;
    }

    //
    // Make sure IP is installed and Terminal mode can be
    // supported as these are required by SLIP.
    //
    if (!(GetInstalledProtocolsEx(
                NULL, FALSE, TRUE, FALSE) & NP_Ip))
    {
        return ERROR_SLIP_REQUIRES_IP;
    }

    //
    // Read SLIP parameters from phonebook entry.
    //
    *pfHeaderCompression    = pEntry->fIpHeaderCompression;
    *pfPrioritizeRemote     = pEntry->fIpPrioritizeRemote;
    *pdwFrameSize           = pEntry->dwFrameSize;
    *ppszIpAddress          = StrDup(pEntry->pszIpAddress);

    return 0;
}


DWORD
RouteSlip(
    IN RASCONNCB* prasconncb,
    IN TCHAR*     pszIpAddress,
    IN BOOL       fPrioritizeRemote,
    IN DWORD      dwFrameSize )

/*++

Routine Description:

    Does all the network setup to activate the SLIP route.

Arguments:

Return Value:

    Returns 0 if successful, otherwise an non-0 error code.

--*/

{
    DWORD            dwErr;
    RASMAN_ROUTEINFO route;
    WCHAR*           pwszRasAdapter;
    IPADDR           ipaddr = IpaddrFromAbcd( pszIpAddress );
    PBENTRY*         pEntry = prasconncb->pEntry;

    //
    // Register SLIP connection with RASMAN so he can
    // disconnect it properly.
    //
    RASAPI32_TRACE("RasPortRegisterSlip...");

    //
    // If both file/printsharing and the MS Net Client
    // are disabled then we need to tell the stack not
    // to send any netbios/netbt traffic over the link
    //
    if(     (!prasconncb->pEntry->fShareMsFilePrint)
        &&  (!prasconncb->pEntry->fBindMsNetClient))
    {
        DWORD dwFlags;

        dwFlags = PPPFLAGS_DisableNetbt;

        g_pRasSetPortUserData(prasconncb->hport,
                              PORT_SLIPFLAGS_INDEX,
                              (PBYTE)&dwFlags,
                              sizeof(dwFlags));
    }

    dwErr = g_pRasPortRegisterSlip(
              prasconncb->hport,
              ipaddr,
              dwFrameSize,
              fPrioritizeRemote,
              pEntry->pszIpDnsAddress,
              pEntry->pszIpDns2Address,
              pEntry->pszIpWinsAddress,
              pEntry->pszIpWins2Address);

    RASAPI32_TRACE1("RasPortRegisterSlip done(%d)", dwErr);

    if (dwErr != 0)
    {
        return dwErr;
    }

    return 0;
}

#if AMB
VOID
SetAuthentication(
    IN RASCONNCB* prasconncb,
    IN DWORD      dwAuthentication )

/*++

Routine Description:

    Sets the authentication strategy parameter in the
    phonebook entry to 'dwAuthentication'.  No error
    is returned as it is not considered fatal if this
    "optimization" can't be made.

Arguments:

Return Value:

--*/

{

    if (prasconncb->fDefaultEntry)
    {
        return;
    }

    prasconncb->pEntry->dwAuthentication = dwAuthentication;
    prasconncb->pEntry->fDirty = TRUE;

    return;
}
#endif


DWORD
SetDefaultDeviceParams(
    IN  RASCONNCB* prasconncb,
    OUT TCHAR*      pszType,
    OUT TCHAR*      pszName )

/*++

Routine Description:

    Set the default DEVICE settings, i.e. the phone
    number and modem speaker settings.  'prasconncb'
    is the current connection control block.'pszType'
    and 'pszName' are set to the device type and name
    of the device, i.e. "modem" and "Hayes Smartmodem
    2400".

Arguments:

Return Value:

    Returns 0 or a non-0 error code.

--*/

{
    DWORD dwErr;
    PBLINK* pLink = prasconncb->pLink;

    do
    {
        //
        // Make sure a modem is attached to the port.
        //
        if (CaseInsensitiveMatch(
            prasconncb->szDeviceType,
            TEXT(MXS_MODEM_TXT) ) == FALSE)
        {
            dwErr = ERROR_WRONG_DEVICE_ATTACHED;
            break;
        }

        lstrcpyn(
            pszType,
            TEXT(MXS_MODEM_TXT),
            RAS_MAXLINEBUFLEN + 1);

        lstrcpyn(
            pszName,
            prasconncb->szDeviceName,
            RAS_MAXLINEBUFLEN + 1);

        //
        // Set the phone number.
        //
        if ((dwErr = SetDeviceParamString(
                prasconncb->hport, TEXT(MXS_PHONENUMBER_KEY),
                prasconncb->rasdialparams.szPhoneNumber,
                pszType, pszName )) != 0)
        {
            break;
        }

        //
        // Set the modem speaker flag.
        //
        if ((dwErr = SetDeviceParamString(
                prasconncb->hport, TEXT(MXS_SPEAKER_KEY),
                (prasconncb->fDisableModemSpeaker)
                ? TEXT("0")
                : TEXT("1"),
                pszType, pszName )) != 0)
        {
            break;
        }

        {
            CHAR szTypeA[RAS_MaxDeviceType + 1];
            BYTE* pBlob;
            DWORD cbBlob;

            //
            // Setup a unimodem blob containing default
            // settings, less any settings that cannot
            // apply to RAS, plus the phonebook settings
            // user has specified, and tell RASMAN to
            // use it.
            //
            strncpyTtoA(szTypeA, pszType, sizeof(szTypeA));

            dwErr = GetRasUnimodemBlob(
                    NULL,
                    prasconncb->hport, szTypeA,
                    &pBlob, &cbBlob );

            if (cbBlob > 0)
            {
                UNIMODEMINFO info;

                info.fHwFlow    = pLink->fHwFlow;
                info.fEc        = pLink->fEc;
                info.fEcc       = pLink->fEcc;
                info.dwBps      = pLink->dwBps;
                info.fSpeaker   = !prasconncb->fDisableModemSpeaker;

                info.fOperatorDial          = FALSE;
                info.fUnimodemPreTerminal   = FALSE;

                UnimodemInfoToBlob( &info, pBlob );

                RASAPI32_TRACE("RasSetDevConfig");

                dwErr = g_pRasSetDevConfig(
                    prasconncb->hport, szTypeA,
                    pBlob, cbBlob );

                RASAPI32_TRACE1("RasSetDevConfig=%d",dwErr);

                Free0( pBlob );
            }

            if (dwErr != 0)
            {
                return dwErr;
            }
        }
    }
    while (FALSE);

    return dwErr;
}


BOOL
FindNextDevice(
    IN RASCONNCB *prasconncb
    )
{
    BOOL        fFound  = FALSE;
    DWORD       dwErr;
    PBENTRY*    pEntry  = prasconncb->pEntry;
    PBLINK*     pLink   = prasconncb->pLink;
    TCHAR       szType[RAS_MaxDeviceType + 1];
    TCHAR       szName[RAS_MaxDeviceName + 1];

    //
    // Get device type from port structure.
    //
    if (prasconncb->iDevice < prasconncb->cDevices)
    {
        //
        // Set default device type and name.
        //
        lstrcpyn(
            szType,
            prasconncb->szDeviceType,
            sizeof(szType) / sizeof(TCHAR));

        lstrcpyn(
            szName,
            prasconncb->szDeviceName,
            sizeof(szName) / sizeof(TCHAR));

        switch (pLink->pbport.pbdevicetype)
        {
        case PBDT_Modem:
        case PBDT_Pad:
        case PBDT_Switch:
            switch (prasconncb->iDevice)
            {
            case 0:
                if (        (pLink->pbport.fScriptBefore
                        ||  pLink->pbport.fScriptBeforeTerminal)
                    && !(pLink->pbport.pbdevicetype == PBDT_Modem)
                    )
                {
                    fFound = TRUE;

                    lstrcpyn(
                        szType,
                        TEXT(MXS_SWITCH_TXT),
                        sizeof(szType) / sizeof(TCHAR));

                    if (pLink->pbport.pszScriptBefore != NULL)
                    {
                        lstrcpyn(
                            szName,
                            pLink->pbport.pszScriptBefore,
                            sizeof(szName) / sizeof(TCHAR));
                    }

                    break;
                }

                // fall through
            case 1:
                if (CaseInsensitiveMatch(
                        prasconncb->szDeviceType,
                        TEXT(MXS_MODEM_TXT)) == TRUE)
                {
                    fFound = TRUE;
                    break;
                }

                // fall through
            case 2:
                if (pEntry->pszX25Network != NULL)
                {
                    lstrcpyn(
                        szType,
                        TEXT(MXS_PAD_TXT),
                        sizeof(szType) / sizeof(TCHAR));

                    fFound = TRUE;
                    break;
                }

                // fall through
            case 3:
                if (    pEntry->fScriptAfter
                    ||  pEntry->fScriptAfterTerminal
                    ||  (1 == pEntry->dwCustomScript))
                {
                    lstrcpyn(
                        szType,
                        TEXT(MXS_SWITCH_TXT),
                        sizeof(szType) / sizeof(TCHAR));

                    if (pEntry->pszScriptAfter != NULL)
                    {
                        lstrcpyn(
                            szName,
                            pEntry->pszScriptAfter,
                            sizeof(szName) / sizeof(TCHAR));
                    }

                    fFound = TRUE;
                    break;
                }

                // fall through
            }
            break;

        case PBDT_Isdn:
            lstrcpyn(szType, TEXT(ISDN_TXT), sizeof(szType) / sizeof(TCHAR));
            fFound = TRUE;
            break;

        case PBDT_X25:
            lstrcpyn(szType, TEXT(X25_TXT), sizeof(szType) / sizeof(TCHAR));
            fFound = TRUE;
            break;

        case PBDT_Irda:
            lstrcpyn(szType, RASDT_Irda, sizeof(szType) / sizeof(TCHAR));
            fFound = TRUE;
            break;

        case PBDT_Vpn:
            lstrcpyn(szType, RASDT_Vpn, sizeof(szType) / sizeof(TCHAR));

            if(prasconncb->iDevice == 0)
                fFound = TRUE;

            break;

        case PBDT_Serial:
            lstrcpyn(szType, RASDT_Serial, sizeof(szType) / sizeof(TCHAR));
            if(prasconncb->iDevice == 0)
                fFound = TRUE;

            break;

        case PBDT_Atm:
            lstrcpyn(szType, RASDT_Atm, sizeof(szType) / sizeof(TCHAR));
            if(prasconncb->iDevice == 0)
                fFound = TRUE;

            break;

        case PBDT_Parallel:
            lstrcpyn(szType, RASDT_Parallel, sizeof(szType) / sizeof(TCHAR));
            if(prasconncb->iDevice == 0)
                fFound = TRUE;

            break;

        case PBDT_Sonet:
            lstrcpyn(szType, RASDT_Sonet, sizeof(szType) / sizeof(TCHAR));
            if(prasconncb->iDevice == 0)
                fFound = TRUE;

            break;

        case PBDT_Sw56:
            lstrcpyn(szType, RASDT_SW56, sizeof(szType) / sizeof(TCHAR));
            if(prasconncb->iDevice == 0)
                fFound = TRUE;

            break;

        case PBDT_FrameRelay:
            lstrcpyn(szType, RASDT_FrameRelay, sizeof(szType) / sizeof(TCHAR));
            if(prasconncb->iDevice == 0)
                fFound = TRUE;

            break;

        case PBDT_PPPoE:
            lstrcpyn(szType, RASDT_PPPoE, sizeof(szType) / sizeof(TCHAR));
            if(prasconncb->iDevice == 0)
                fFound = TRUE;
            break;

        //
        // Fall through is intentional
        //

        default:
            //
            // For the default case, we don't assume a multi stage
            // connect. We can assume there is only one device if
            // its not any of the above PBDT's
            //
            if(prasconncb->iDevice == 0)
            {

                lstrcpyn(
                    szType,
                    pLink->pbport.pszMedia,
                    sizeof(szType) / sizeof(TCHAR));

                fFound = TRUE;
            }
            break;
        }
    }

    if (fFound)
    {
        if (pLink->pbport.pbdevicetype == PBDT_Pad)
        {
            if (CaseInsensitiveMatch(
                    pEntry->pszX25Network,
                    TEXT(MXS_PAD_TXT)) == FALSE)
            {
                lstrcpyn(
                    szName,
                    pEntry->pszX25Network,
                    sizeof(szName) / sizeof(TCHAR));
            }
        }

        //
        // Store the device type and name in rasman
        // for the RasGetConnectStatus API.
        //
        //
        RASAPI32_TRACE2("FindNextDevice: (%S, %S)", szType, szName);

        dwErr = g_pRasSetPortUserData(
                  prasconncb->hport,
                  PORT_DEVICETYPE_INDEX,
                  (PCHAR)szType,
                  sizeof (szType));

        dwErr = g_pRasSetPortUserData(
                  prasconncb->hport,
                  PORT_DEVICENAME_INDEX,
                  (PCHAR)szName,
                  sizeof (szName));
    }

    return fFound;
}


DWORD
SetDeviceParamString(
    IN HPORT hport,
    IN TCHAR* pszKey,
    IN TCHAR* pszValue,
    IN TCHAR* pszType,
    IN TCHAR* pszName )

/*++

Routine Description:

    Set device info on port 'hport' with the given parameters.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0 error code.

--*/

{
    DWORD              dwErr;
    RASMAN_DEVICEINFO* pinfo;
    RAS_PARAMS*        pparam;

    if (!(pinfo = Malloc(  sizeof(RASMAN_DEVICEINFO)
                         + RAS_MAXLINEBUFLEN )))
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pinfo->DI_NumOfParams = 1;
    pparam                = pinfo->DI_Params;
    pparam->P_Attributes  = 0;
    pparam->P_Type        = String;
    pparam->P_Value.String.Data = (LPSTR )(pparam + 1);

    strncpyTtoAAnsi(pparam->P_Key, pszKey, sizeof(pparam->P_Key));

    strncpyTtoAAnsi(pparam->P_Value.String.Data, pszValue, RAS_MAXLINEBUFLEN);

    pparam->P_Value.String.Length = strlen(pparam->P_Value.String.Data) + 1;

    if(     (FALSE == CaseInsensitiveMatch(pszKey,TEXT("password")))
        &&  (FALSE == CaseInsensitiveMatch(pszKey, TEXT("phonenumber"))))
    {
        RASAPI32_TRACE2("RasDeviceSetInfo(%S=%S)...",
                pszKey,
                pszValue);
    }

    {
        CHAR szTypeA[RAS_MaxDeviceType + 1],
             szNameA[RAS_MaxDeviceName + 1];

        strncpyTtoAAnsi(szTypeA, pszType, sizeof(szTypeA));
        strncpyTtoAAnsi(szNameA, pszName, sizeof(szNameA));

        dwErr = g_pRasDeviceSetInfo(
                    hport, szTypeA,
                    szNameA, pinfo );
    }

    RASAPI32_TRACE1("RasDeviceSetInfo done(%d)", dwErr);

    Free( pinfo );

    return dwErr;
}


DWORD
SetDeviceParamNumber(
    IN HPORT    hport,
    IN TCHAR*   pszKey,
    IN DWORD    dwValue,
    IN TCHAR*   pszType,
    IN TCHAR*   pszName )

/*++

Routine Description:

    Set device info on port 'hport' with the given parameters.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0 error code.

--*/

{
    DWORD              dwErr;
    RASMAN_DEVICEINFO* pinfo;
    RAS_PARAMS*        pparam;

    if (!(pinfo = Malloc( sizeof(RASMAN_DEVICEINFO) )))
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pinfo->DI_NumOfParams   = 1;
    pparam                  = pinfo->DI_Params;
    pparam->P_Attributes    = 0;
    pparam->P_Type          = Number;
    pparam->P_Value.Number  = dwValue;

    strncpyTtoA(pparam->P_Key, pszKey, sizeof(pparam->P_Key));

    RASAPI32_TRACE2("RasDeviceSetInfo(%S=%d)...", pszKey, dwValue);

    {
        CHAR szTypeA[MAX_DEVICETYPE_NAME], szNameA[MAX_DEVICE_NAME];

        strncpyTtoA(szTypeA, pszType, sizeof(szTypeA));
        strncpyTtoA(szNameA, pszName, sizeof(szNameA));

        dwErr = g_pRasDeviceSetInfo(
                    hport, szTypeA,
                    szNameA, pinfo );
    }

    RASAPI32_TRACE1("RasDeviceSetInfo done(%d)", dwErr);

    Free( pinfo );

    return dwErr;
}


DWORD
SetDeviceParams(
    IN  RASCONNCB* prasconncb,
    OUT TCHAR*      pszType,
    OUT TCHAR*      pszName,
    OUT BOOL*      pfTerminal )

/*++

Routine Description:

    Set RAS Manager information for each device.  The
    current device is defined by prasconncb->iDevice.
    'prasconncb' is the current connection control block.
    'pszType' and 'pszName' are set to the device type
    and name of the device, i.e. "modem" and "Hayes
    Smartmodem 2400".

Arguments:

Return Value:

    '*pfTerminal' is set true if the device is a switch
    of type "Terminal",false otherwise.

--*/

{
    DWORD              dwErr = 0;
    DWORD              iPhoneNumber = 0;
    RAS_PARAMS*        pparam;
    RASMAN_DEVICEINFO* pdeviceinfo;
    BOOL               fModem;
    BOOL               fIsdn;
    BOOL               fPad;
    BOOL               fSwitch;
    BOOL               fX25;
    PBENTRY*           pEntry = prasconncb->pEntry;
    PBLINK*            pLink = prasconncb->pLink;

    *pfTerminal = FALSE;

    //
    // Default device name is that attached to the port.
    //
    lstrcpyn(pszName, prasconncb->szDeviceName, RAS_MAXLINEBUFLEN + 1);

    switch (pLink->pbport.pbdevicetype)
    {
    case PBDT_Modem:
    case PBDT_Pad:
    case PBDT_Switch:
        switch (prasconncb->iDevice)
        {
        case 0:
            if (    (   pLink->pbport.fScriptBefore
                    ||  pLink->pbport.fScriptBeforeTerminal)
                && !(pLink->pbport.pbdevicetype == PBDT_Modem)
                )
            {

                lstrcpyn(pszType, TEXT(MXS_SWITCH_TXT), RAS_MAXLINEBUFLEN + 1);

                if (pLink->pbport.pszScriptBefore != NULL)
                {
                    lstrcpyn(
                        pszName,
                        pLink->pbport.pszScriptBefore,
                        RAS_MAXLINEBUFLEN + 1);
                }
                prasconncb->iDevice = 1;

                *pfTerminal = (pLink->pbport.fScriptBeforeTerminal);
                break;
            }
            // fall through
        case 1:
            if (CaseInsensitiveMatch(
                    prasconncb->szDeviceType,
                    TEXT(MXS_MODEM_TXT)) == TRUE)
            {
                lstrcpyn(pszType, TEXT(MXS_MODEM_TXT), RAS_MAXLINEBUFLEN + 1);

                prasconncb->iDevice = 2;

                break;
            }
            // fall through
        case 2:
            if (pEntry->pszX25Network != NULL)
            {
                lstrcpyn(pszType, TEXT(MXS_PAD_TXT), RAS_MAXLINEBUFLEN + 1);

                prasconncb->iDevice = 3;

                break;
            }
            // fall through
        case 3:
            if (    pEntry->fScriptAfter
                ||  pEntry->fScriptAfterTerminal
                ||  pEntry->dwCustomScript)
            {
                lstrcpyn(pszType, TEXT(MXS_SWITCH_TXT), RAS_MAXLINEBUFLEN + 1);

                if (pEntry->pszScriptAfter != NULL)
                {
                    lstrcpyn(pszName, pEntry->pszScriptAfter, RAS_MAXLINEBUFLEN + 1);
                }

                prasconncb->iDevice = 4;
                *pfTerminal = pEntry->fScriptAfterTerminal;

                if(pEntry->dwCustomScript == 1)
                {
                    *pfTerminal = TRUE;
                }

                break;
            }
            // fall through
        default:
            return FALSE;
        }
        break;

    case PBDT_Isdn:
        lstrcpyn(pszType, TEXT(ISDN_TXT), RAS_MAXLINEBUFLEN + 1);
        prasconncb->iDevice = 1;
        break;

    case PBDT_X25:
        lstrcpyn(pszType, TEXT(X25_TXT), RAS_MAXLINEBUFLEN + 1);
        prasconncb->iDevice = 1;
        break;

    default:
        lstrcpyn(pszType, pLink->pbport.pszMedia, RAS_MAXLINEBUFLEN + 1);
        prasconncb->iDevice = 1;
        break;
    }

    fModem  = (CaseInsensitiveMatch(
                pszType,
                TEXT(MXS_MODEM_TXT) ) == TRUE);

    fIsdn   = (CaseInsensitiveMatch(
                pszType,
                TEXT(ISDN_TXT) ) == TRUE);

    fPad    = (CaseInsensitiveMatch(
                pszType,
                TEXT(MXS_PAD_TXT) ) == TRUE);

    fSwitch = (CaseInsensitiveMatch(
                pszType,
                TEXT(MXS_SWITCH_TXT) ) == TRUE);

    fX25    = (CaseInsensitiveMatch(
                pszType,
                TEXT(X25_TXT)) == TRUE);

    if (fModem)
    {
        //
        // Make sure a modem is attached to the port.
        //
        if (lstrcmpi( prasconncb->szDeviceType, pszType ) != 0)
        {
            return ERROR_WRONG_DEVICE_ATTACHED;
        }

        //
        // Set the modem speaker flag which is global to all entries.
        //
        if ((dwErr = SetDeviceParamString(
                prasconncb->hport, TEXT(MXS_SPEAKER_KEY),
                (prasconncb->fDisableModemSpeaker)
                ? TEXT("0") : TEXT("1"),
                pszType, pszName )) != 0)
        {
            return dwErr;
        }
    }

    //
    // Set up hunt group if indicated.
    //
    if (!prasconncb->cPhoneNumbers)
    {
        prasconncb->cPhoneNumbers =
            DtlGetNodes(pLink->pdtllistPhones);

        //
        // If multiple phone numbers were found turn on local
        // error handling, i.e. don't report failures to API
        // caller until all numbers are tried.
        //
        if (prasconncb->cPhoneNumbers > 1)
        {
            RASAPI32_TRACE1(
              "Hunt group of %d begins",
              prasconncb->cPhoneNumbers);

            prasconncb->dwRestartOnError = RESTART_HuntGroup;
        }
    }

    //
    // Pass device parameters to RAS Manager, interpreting
    // special features as required.
    //
    if (fModem)
    {
        if (prasconncb->fOperatorDial)
        {
            //
            // Special case to recognize MXS Operator Dial
            // mode and override any phone number with an
            // empty number.
            //
            prasconncb->rasdialparams.szPhoneNumber[ 0 ] = '\0';

            dwErr = SetDeviceParamString(
                        prasconncb->hport,
                        TEXT(MXS_AUTODIAL_KEY),
                        TEXT("0"),
                        pszType, pszName );

            if (dwErr != 0)
            {
                return dwErr;
            }
        }

        //
        // Set the phone number.
        //
        dwErr = SetDeviceParamString(
                  prasconncb->hport,
                  TEXT(MXS_PHONENUMBER_KEY),
                  prasconncb->szPhoneNumber,
                  pszType,
                  pszName);
        if (dwErr)
        {
            return dwErr;
        }

        /* Indicate interactive mode for manual modem commands.  The
        ** manual modem commands flag is used only for connection and is
        ** not a "RAS Manager "info" parameter.
        // Support for mxsmodems is not present in nt5
        if (pLink->fManualDial)
            *pfTerminal = TRUE; */

        //
        // Set hardware flow control.
        //
        dwErr = SetDeviceParamString(
                  prasconncb->hport,
                  TEXT(MXS_HDWFLOWCONTROL_KEY),
                  pLink->fHwFlow ? TEXT("1") : TEXT("0"),
                  pszType,
                  pszName);

        if (dwErr)
        {
            return dwErr;
        }

        //
        // Set protocol.
        //
        dwErr = SetDeviceParamString(
                  prasconncb->hport,
                  TEXT(MXS_PROTOCOL_KEY),
                  pLink->fEc ? TEXT("1") : TEXT("0"),
                  pszType,
                  pszName);

        if (dwErr)
        {
            return dwErr;
        }

        //
        // Set compression.
        //
        dwErr = SetDeviceParamString(
                  prasconncb->hport,
                  TEXT(MXS_COMPRESSION_KEY),
                  pLink->fEcc ? TEXT("1") : TEXT("0"),
                  pszType,
                  pszName);

        if (dwErr)
        {
            return dwErr;
        }

        {
            CHAR szTypeA[RAS_MaxDeviceType + 1];
            BYTE* pBlob;
            DWORD cbBlob = 0;

            //
            // Setup a unimodem blob containing default settings,
            // less any settings that cannot apply to RAS, plus the
            // phonebook settings user has specified, and tell RASMAN
            // to use it.
            //
            strncpyTtoA(szTypeA, pszType, sizeof(szTypeA));

            // XP 281306
            //
            // Load the appropriate device settings.
            // 
            // This silly exercise is due to some bugs in the 
            // unimodem tapi service provider.  By the time the bugs
            // were discovered, it was too late to fix for XP so
            // this is the workaround.  
            //
            // Calling GetRasUnimodemBlobEx(fGlobal=TRUE) will cause 
            // rasman to read the "comm/datamodem/dialin" settings  
            // instead of the "comm/datamodem" settings it normally 
            // reads when fGlobal is FALSE.
            //
            // The "default" settings for a device as rendered in the 
            // control panel are actually the "comm/datamodem/dialin"
            // settings.
            //
            if ( prasconncb->pEntry->fGlobalDeviceSettings )
            {
                dwErr = GetRasUnimodemBlobEx(
                    NULL,
                    prasconncb->hport,
                    szTypeA,
                    TRUE,
                    &pBlob,
                    &cbBlob );
                    
                RASAPI32_TRACE1("SetDeviceParams: get glob devcfg %d", dwErr);
            }
            else
            {
                dwErr = GetRasUnimodemBlobEx(
                    NULL,
                    prasconncb->hport,
                    szTypeA,
                    FALSE,
                    &pBlob,
                    &cbBlob );
            }

            if (dwErr != 0)
            {
                return dwErr;
            }
            
            if (cbBlob > 0)
            {
                UNIMODEMINFO info;

                // Whistler bug 281306.  
                //
                // Ignore pbk settings when the global config flag is set.
                //
                if ( ! prasconncb->pEntry->fGlobalDeviceSettings )
                {
                    info.fHwFlow    = pLink->fHwFlow;
                    info.fEc        = pLink->fEc;
                    info.fEcc       = pLink->fEcc;
                    info.dwBps      = pLink->dwBps;
                    info.fSpeaker   = !prasconncb->fDisableModemSpeaker;
                    info.fOperatorDial = prasconncb->fOperatorDial;
                    info.dwModemProtocol = pLink->dwModemProtocol;

                    info.fUnimodemPreTerminal =
                        (   pLink->pbport.fScriptBeforeTerminal
                         && (pLink->pbport.pbdevicetype == PBDT_Modem)
                         ) ? TRUE : FALSE;

                    UnimodemInfoToBlob( &info, pBlob );
                }                    

                RASAPI32_TRACE("RasSetDevConfig");
                {
                    CHAR szSetTypeA[MAX_DEVICETYPE_NAME];

                    strncpyTtoA(szSetTypeA, pszType, sizeof(szSetTypeA));

                    dwErr = g_pRasSetDevConfig(
                                prasconncb->hport,
                                szSetTypeA, pBlob, cbBlob);
                }

                RASAPI32_TRACE1("RasSetDevConfig=%d",dwErr);

                Free0( pBlob );
            }

        }
    }
    else if (fIsdn)
    {
        TCHAR szNum[17];

        //
        // Set the line type.
        //
        _snwprintf(
            szNum,
            sizeof(szNum) / sizeof(TCHAR),
            TEXT("%d"),
            pLink->lLineType);

        dwErr = SetDeviceParamString(
                  prasconncb->hport,
                  TEXT(ISDN_LINETYPE_KEY),
                  szNum,
                  pszType,
                  pszName);

        if (dwErr)
        {
            return dwErr;
        }

        //
        // Set the fallback value.
        //
        dwErr = SetDeviceParamString(
                  prasconncb->hport,
                  TEXT(ISDN_FALLBACK_KEY),
                  pLink->fFallback ? TEXT("1") : TEXT("0"),
                  pszType,
                  pszName);

        if (dwErr)
        {
            return dwErr;
        }

        //
        // Set the Digi proprietary framing flags.
        //
        dwErr = SetDeviceParamString(
                  prasconncb->hport,
                  TEXT(ISDN_COMPRESSION_KEY),
                  pLink->fCompression ? TEXT("1") : TEXT("0"),
                  pszType,
                  pszName);

        if (dwErr)
        {
            return dwErr;
        }

        _snwprintf(
            szNum,
            sizeof(szNum) / sizeof(TCHAR),
            TEXT("%d"),
            pLink->lChannels);

        dwErr = SetDeviceParamString(
                  prasconncb->hport,
                  TEXT(ISDN_CHANNEL_AGG_KEY),
                  szNum,
                  pszType,
                  pszName);
        if (dwErr)
        {
            return dwErr;
        }

        //
        // Set the phone number.
        //
        dwErr = SetDeviceParamString(
                  prasconncb->hport,
                  TEXT(MXS_PHONENUMBER_KEY),
                  prasconncb->szPhoneNumber,
                  pszType,
                  pszName);

        if (dwErr)
        {
            return dwErr;
        }
    }
    else if (   fPad
            ||  fX25)
    {
        //
        // The PAD Type from the entry applies only if the port
        // is not configured as a local PAD.  In any case, PAD
        // Type is used only for connection and is not a RAS Manager
        // "info" parameter.
        //
        if (CaseInsensitiveMatch(
                prasconncb->szDeviceType,
                TEXT(MXS_PAD_TXT)) == FALSE)
        {
            lstrcpyn(pszName, pEntry->pszX25Network, RAS_MAXLINEBUFLEN + 1);
        }

        //
        // Set the X.25 address.
        //
        dwErr = SetDeviceParamString(
                  prasconncb->hport,
                  TEXT(X25_ADDRESS_KEY),
                  pEntry->pszX25Address,
                  pszType,
                  pszName);

        if (dwErr)
        {
            return dwErr;
        }

        //
        // Set the X.25 user data.
        //
        dwErr = SetDeviceParamString(
                  prasconncb->hport,
                  TEXT(X25_USERDATA_KEY),
                  pEntry->pszX25UserData,
                  pszType,
                  pszName);

        if (dwErr)
        {
            return dwErr;
        }

        //
        // Set the X.25 facilities.
        //
        dwErr = SetDeviceParamString(
                  prasconncb->hport,
                  TEXT(MXS_FACILITIES_KEY),
                  pEntry->pszX25Facilities,
                  pszType,
                  pszName);

        if (dwErr)
        {
            return dwErr;
        }
    }
    else if (fSwitch)
    {
    }
    else {

        if(RASET_Vpn == prasconncb->pEntry->dwType)
        {
            struct in_addr addr;
            DWORD iAddress = prasconncb->iAddress;
            TCHAR *pszPhoneNumber = NULL;
            CHAR *pszPhoneNumberA =
                        strdupTtoA(prasconncb->szPhoneNumber);

            if(NULL == pszPhoneNumberA)
            {
                dwErr = E_OUTOFMEMORY;
                return dwErr;
            }

            ASSERT(iAddress > 0);

            if(     (prasconncb->cAddresses > 1)
                ||  (inet_addr(pszPhoneNumberA)) == -1)
            {
                addr.s_addr = prasconncb->pAddresses[iAddress - 1];

                pszPhoneNumber = strdupAtoT(
                            inet_ntoa(addr));
            }
            else if(1 == prasconncb->cAddresses)
            {
                pszPhoneNumber = StrDup(prasconncb->szPhoneNumber);
            }

            if(NULL != pszPhoneNumber)
            {

                RASAPI32_TRACE2("SetDefaultParams: Using address %d=%ws",
                        iAddress - 1,
                        pszPhoneNumber);

                //
                // Set the phone number.
                //
                dwErr = SetDeviceParamString(
                          prasconncb->hport,
                          TEXT(MXS_PHONENUMBER_KEY),
                          pszPhoneNumber,
                          pszType,
                          pszName);
            }
            else
            {
                dwErr = E_OUTOFMEMORY;
            }

            Free(pszPhoneNumberA);
            Free0(pszPhoneNumber);
        }
        else
        {
            //
            // Set the phone number.
            //
            dwErr = SetDeviceParamString(
                      prasconncb->hport,
                      TEXT(MXS_PHONENUMBER_KEY),
                      prasconncb->szPhoneNumber,
                      pszType,
                      pszName);
        }                  

        if (dwErr)
        {
            return dwErr;
        }
    }


    __try
    {
        //gangz
        //For secure password bug .Net 534499 and  LH754400
        SafeDecodePasswordBuf ( prasconncb->rasdialparams.szPassword );

        if (    (   fModem
                ||  fPad
                ||  (   fSwitch
                    &&  !*pfTerminal))
            && (    prasconncb->rasdialparams.szUserName[0] != TEXT('\0')
                ||  prasconncb->rasdialparams.szPassword[0] != TEXT('\0')))
        {
            RASAPI32_TRACE1(
              "User/pw set for substitution (%S)",
              prasconncb->rasdialparams.szUserName);

            //
            // It's a serial device with clear-text user name
            // and password supplied.  Make the credentials
            // available for substitution use in script
            // files.
            //
            if ((dwErr = SetDeviceParamString(
                    prasconncb->hport, TEXT(MXS_USERNAME_KEY),
                    prasconncb->rasdialparams.szUserName,
                    pszType, pszName )) != 0)
            {
                __leave;//return
            }

            dwErr = SetDeviceParamString(
                prasconncb->hport, TEXT(MXS_PASSWORD_KEY),
                prasconncb->rasdialparams.szPassword,
                pszType, pszName );


            if (dwErr != 0)
            {
                __leave;
            }
        }

    }
    __finally
    {
            SafeEncodePasswordBuf ( prasconncb->rasdialparams.szPassword );
    }

    return dwErr;
}


DWORD
ConstructPhoneNumber(
    IN RASCONNCB *prasconncb
    )
{
    DWORD dwErr = 0;

    PBENTRY* pEntry = prasconncb->pEntry;

    PBLINK* pLink = prasconncb->pLink;

    TCHAR* pszNum = prasconncb->rasdialparams.szPhoneNumber;

    TCHAR* pszDisplayNum = pszNum;

    DTLNODE* pdtlnode;

    DTLNODE* pdtlnodePhone = NULL;

    WCHAR* pwszNum;

    PBUSER pbuser;

    PBPHONE *pPhone;

    dwErr = GetUserPreferences(NULL,
                               &pbuser,
                               prasconncb->dwUserPrefMode);
    if (dwErr)
    {
        return dwErr;
    }

    prasconncb->fOperatorDial = pbuser.fOperatorDial;

    ASSERT(pLink);

    if(     (pLink->pdtllistPhones)
        &&  (pdtlnodePhone = DtlGetFirstNode(
                            pLink->pdtllistPhones
                            )))
    {

        pPhone = (PBPHONE *)
                 DtlGetData(pdtlnodePhone);

        ASSERT(pPhone);

    }
    else
    {
        pPhone = NULL;
    }

    //
    // Construct the phone number.
    //

    //
    // Use of TAPI dialing properties is dependent only on
    // the entry flag and is never applied to an overridden
    // phone number, this to be consistent with Win95.
    //

    //
    // Use of prefix/suffix (even on overridden number) is
    // controlled by the RASDIALEXTENSIONS setting, this all
    // necessary for RASDIAL.EXE support.
    //
    if (    (   (NULL != pPhone)
            &&  (pPhone->fUseDialingRules)
            &&  (*pszNum == TEXT('\0')))
         || (   (NULL != pPhone)
            &&  (!pPhone->fUseDialingRules)
            &&  (prasconncb->fUsePrefixSuffix)))
    {
        HLINEAPP hlineApp = 0;
        TCHAR *pszDialNum;

        //
        // Calculate the dialable string to
        // be sent to the device.
        //
        pszDialNum = LinkPhoneNumberFromParts(
                       GetModuleHandle(NULL),
                       &hlineApp,
                       &pbuser,
                       prasconncb->pEntry,
                       pLink,
                       prasconncb->iPhoneNumber,
                       pszNum,
                       TRUE);

        //
        // Calculate the displayable string to
        // be returned in RasGetConnectStatus().
        //
        pszDisplayNum = LinkPhoneNumberFromParts(
                          GetModuleHandle(NULL),
                          &hlineApp,
                          &pbuser,
                          prasconncb->pEntry,
                          pLink,
                          prasconncb->iPhoneNumber,
                          pszNum,
                          FALSE);
        pszNum = pszDialNum;
    }
    else if (*pszNum == '\0')
    {
        //
        // Use only the base number.
        //
        pdtlnode = DtlNodeFromIndex(
                     pLink->pdtllistPhones,
                     prasconncb->iPhoneNumber);

        if (pdtlnode != NULL)
        {
            pPhone = (PBPHONE *) DtlGetData(pdtlnode);

            ASSERT(pPhone != NULL);

            pszNum = StrDup(pPhone->pszPhoneNumber);

            if(NULL == pszNum)
            {
                //
                // .Net bug# 522101 RASAPI32: Memory leak in file util.c,
                // function ConstructPhoneNumber, in error return path
                //
                DestroyUserPreferences(&pbuser);
                return GetLastError();
            }

            pszDisplayNum = pszNum;
        }
    }

    DestroyUserPreferences(&pbuser);

    if(NULL == pszNum)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Copy the resulting phone number
    // to the connection block
    //
    if (lstrlen(pszNum) > RAS_MaxPhoneNumber)
    {
        //
        // .Net bug# 522101 RASAPI32: Memory leak in file util.c, function
        // ConstructPhoneNumber, in error return path
        //
        Free(pszNum);
        return ERROR_PHONE_NUMBER_TOO_LONG;
    }

    //
    // Store the phone number in the connection block.
    //
    lstrcpyn(
        prasconncb->szPhoneNumber,
        pszNum,
        sizeof(prasconncb->szPhoneNumber) / sizeof(WCHAR));

#if DBG
    RASAPI32_TRACE1(
        "ConstructPhoneNumber: %S",
        prasconncb->szPhoneNumber);
#endif        

    //
    // Also store the constructed phone number
    // off the port so other applications (like
    // rasphone) can get this information.
    //
    dwErr = g_pRasSetPortUserData(
              prasconncb->hport,
              PORT_PHONENUMBER_INDEX,
              (PBYTE)pszDisplayNum,
              (lstrlen(pszDisplayNum) + 1) * sizeof (TCHAR));
    //
    // Free resources.
    //
    if (pszDisplayNum != pszNum)
    {
        Free(pszDisplayNum);
    }

    if (pszNum != prasconncb->rasdialparams.szPhoneNumber)
    {
        Free(pszNum);
    }

    return dwErr;
}


DWORD
SetMediaParam(
    IN HPORT hport,
    IN TCHAR* pszKey,
    IN TCHAR* pszValue )

/*++

Routine Description:

    Set port info on port 'hport' with the given parameters.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0 error code.

--*/

{
    DWORD            dwErr;
    RASMAN_PORTINFO* pinfo;
    RAS_PARAMS*      pparam;

    if (!(pinfo = Malloc(
                    sizeof(RASMAN_PORTINFO) + RAS_MAXLINEBUFLEN)))
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pinfo->PI_NumOfParams = 1;
    pparam = pinfo->PI_Params;
    pparam->P_Attributes = 0;
    pparam->P_Type = String;
    pparam->P_Value.String.Data = (LPSTR )(pparam + 1);

    strncpyTtoA(pparam->P_Key, pszKey, sizeof(pparam->P_Key));

    strncpyTtoA(pparam->P_Value.String.Data, pszValue, RAS_MAXLINEBUFLEN);

    pparam->P_Value.String.Length = strlen(pparam->P_Value.String.Data);

    RASAPI32_TRACE2("RasPortSetInfo(%S=%S)...", pszKey, pszValue);

    dwErr = g_pRasPortSetInfo(hport, pinfo);

    RASAPI32_TRACE1("RasPortSetInfo done(%d)", dwErr);

    Free( pinfo );

    return dwErr;
}


DWORD
SetMediaParams(
    IN RASCONNCB *prasconncb
    )

/*++

Routine Description:

    Set RAS Manager media information.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0 error code.

--*/

{
    DWORD            dwErr = 0;
    PBENTRY*         pEntry = prasconncb->pEntry;
    PBLINK*          pLink = prasconncb->pLink;

    if (pLink->pbport.pszMedia == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if (CaseInsensitiveMatch(
            pLink->pbport.pszMedia,
            TEXT(SERIAL_TXT)) == TRUE)
    {
        TCHAR szBps[64];

        prasconncb->cDevices = 4;
        prasconncb->iDevice = 0;

        //
        // Set the connect BPS only if it's not zero.
        //
        if (pLink->dwBps)
        {
            _snwprintf(
                szBps,
                sizeof(szBps) / sizeof(TCHAR),
                TEXT("%d"),
                pLink->dwBps);

            dwErr = SetMediaParam(
                      prasconncb->hport,
                      TEXT(SER_CONNECTBPS_KEY),
                      szBps);
        }
    }
    else if (CaseInsensitiveMatch(
                pLink->pbport.pszMedia,
                TEXT(ISDN_TXT)) == TRUE)
    {
        prasconncb->cDevices = 1;
        prasconncb->iDevice = 0;

        // no media params
    }
    else if (CaseInsensitiveMatch(
                pLink->pbport.pszMedia,
                TEXT(X25_TXT)) == TRUE)
    {
        prasconncb->cDevices = 1;
        prasconncb->iDevice = 0;

        // no media params
    }
    else
    {
        prasconncb->cDevices = 1;
        prasconncb->iDevice = 0;

        // no media params
    }

    return dwErr;
}


RASCONNCB*
ValidateHrasconn(
    IN HRASCONN hrasconn )

/*++

Routine Description:

    Converts RAS connection handle 'hrasconn' into the
    address of the corresponding RAS connection control
    block.

Arguments:

Return Value:

--*/

{
    RASCONNCB* prasconncb = NULL;
    DTLNODE*   pdtlnode;

    EnterCriticalSection(&RasconncbListLock);

    for (pdtlnode = DtlGetFirstNode( PdtllistRasconncb );
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode ))
    {
        prasconncb = (RASCONNCB* )DtlGetData( pdtlnode );
        if (prasconncb->hrasconn == (HCONN)hrasconn)
        {
            goto done;
        }
    }
    prasconncb = NULL;

done:
    LeaveCriticalSection(&RasconncbListLock);

    return prasconncb;
}


RASCONNCB*
ValidateHrasconn2(
    IN HRASCONN hrasconn,
    IN DWORD dwSubEntry
    )
{
    RASCONNCB* prasconncb = NULL;
    DTLNODE*   pdtlnode;


    //
    // Convert RAS connection handle 'hrasconn' and
    // dwSubEntry into the address of the corresponding
    // RAS connection control block.
    //
    EnterCriticalSection(&RasconncbListLock);

    for (pdtlnode = DtlGetFirstNode( PdtllistRasconncb );
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode ))
    {
        prasconncb = (RASCONNCB* )DtlGetData( pdtlnode );
        if (    prasconncb->hrasconn == (HCONN)hrasconn
            &&  prasconncb->rasdialparams.dwSubEntry == dwSubEntry
            &&  !prasconncb->fRasdialRestart)
        {
            goto done;
        }
    }
    prasconncb = NULL;

done:
    LeaveCriticalSection(&RasconncbListLock);

    return prasconncb;
}


RASCONNCB*
ValidatePausedHrasconn(
    IN HRASCONN hrasconn )

/*++

Routine Description:

    Converts RAS connection handle 'hrasconn' into
    the address of the corresponding RAS connection
    control block.

Arguments:

Return Value:

--*/

{
    RASCONNCB* prasconncb = NULL;
    DTLNODE*   pdtlnode;

    EnterCriticalSection(&RasconncbListLock);

    for (pdtlnode = DtlGetFirstNode( PdtllistRasconncb );
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode ))
    {
        prasconncb = (RASCONNCB* )DtlGetData( pdtlnode );

        if (    prasconncb->hrasconn == (HCONN)hrasconn
            &&  prasconncb->rasconnstate & RASCS_PAUSED)
        {
            goto done;
        }
    }
    prasconncb = NULL;

done:
    LeaveCriticalSection(&RasconncbListLock);

    return prasconncb;
}

/*

Routine Description:

    returns the connection block of a connection if the
    connection corresponding to the hrasconn and
    dwSubEntryId is in a paused and the dial mode
    is RASEDM_DialAsNeeded.returns the connection
    block corresponding to hrasconn if the connection
    is in a paused state and the dial mode is
    RASEDM_DialAll

Arguments::

    hrasconn

    dwSubEntry

Return Value::

    RASCONNCB * corresponding to the hrasconn

*/
RASCONNCB *
ValidatePausedHrasconnEx(IN HRASCONN hrasconn,
                         IN DWORD dwSubEntry)
{
    RASCONNCB   *prasconncb = NULL;
    DTLNODE     *pdtlnode;

    EnterCriticalSection(&RasconncbListLock);

    for (pdtlnode = DtlGetFirstNode( PdtllistRasconncb );
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode))
    {
        prasconncb = (RASCONNCB *)DtlGetData( pdtlnode) ;

        if (    prasconncb->hrasconn == (HCONN) hrasconn
            &&  prasconncb->rasconnstate & RASCS_PAUSED)
        {
            if (    (   (prasconncb->pEntry->dwDialMode
                        & RASEDM_DialAsNeeded)

                    &&  (prasconncb->rasdialparams.dwSubEntry
                        == dwSubEntry))

                ||  (prasconncb->pEntry->dwDialMode
                    & RASEDM_DialAll))
            {
                goto done;
            }
        }
    }

    prasconncb = NULL;

done:
    LeaveCriticalSection (&RasconncbListLock);

    return prasconncb;

}


#if 0
DWORD
RunApp(
    IN LPTSTR lpszApplication,
    IN LPTSTR lpszCmdLine
    )
{
    STARTUPINFO startupInfo;
    PROCESS_INFORMATION processInfo;

    //
    // Start the process.
    //
    RtlZeroMemory(
        &startupInfo,
        sizeof (startupInfo));

    startupInfo.cb = sizeof(STARTUPINFO);
    if (!CreateProcess(
          NULL,
          lpszCmdLine,
          NULL,
          NULL,
          FALSE,
          NORMAL_PRIORITY_CLASS|DETACHED_PROCESS,
          NULL,
          NULL,
          &startupInfo,
          &processInfo))
    {
        return GetLastError();
    }

    CloseHandle(processInfo.hThread);

    //
    // Wait for the process to exit.
    //
    for (;;)
    {
        DWORD dwExitCode;

        if (!GetExitCodeProcess(
                processInfo.hProcess,
                &dwExitCode))
        {
            break;
        }

        if (dwExitCode != STILL_ACTIVE)
        {
            break;
        }

        Sleep(2);
    }

    CloseHandle(processInfo.hProcess);

    return 0;
}
#endif


DWORD
StringToIpAddr(
    IN LPTSTR pszIpAddr,
    OUT RASIPADDR *pipaddr
    )
{
    DWORD   dwErr;
    CHAR    szIpAddr[17];
    PULONG  pul = (PULONG)pipaddr;

    strncpyTtoA(szIpAddr, pszIpAddr, 17);

    if('\0' != szIpAddr[0])
    {
        *pul = inet_addr(szIpAddr);
    }
    else
    {
        *pul = 0;
    }

    return 0;
}


DWORD
IpAddrToString(
    IN RASIPADDR* pipaddr,
    OUT LPTSTR*   ppszIpAddr
    )
{
    DWORD   dwErr;
    PCHAR   psz;
    LPTSTR  pszIpAddr;
    PULONG  pul = (PULONG)pipaddr;
    struct  in_addr in_addr;

    pszIpAddr = Malloc(17 * sizeof(TCHAR));
    if (pszIpAddr == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    in_addr.s_addr = *pul;

    psz = inet_ntoa(in_addr);

    if (psz == NULL)
    {
        DbgPrint("IpAddrToString: inet_ntoa failed!\n");
        Free(pszIpAddr);
        return WSAGetLastError();
    }

    strncpyAtoT(pszIpAddr, psz, 17);

    *ppszIpAddr = pszIpAddr;

    return 0;
}


DWORD
GetRasmanDeviceType(
    IN PBLINK *pLink,
    OUT LPTSTR pszDeviceType
    )
{
    INT         i;
    DWORD       dwErr;
    DWORD       dwcPorts;
    RASMAN_PORT *pports, *pport;
    PCHAR       pszPort = NULL;

    //
    // Retrieve the rasman device type for the port.
    //
    pszPort = strdupTtoA(pLink->pbport.pszPort);

    if (pszPort == NULL)
    {
        return GetLastError();
    }
    dwErr = GetRasPorts(NULL, &pports, &dwcPorts);

    if (dwErr)
    {
        goto done;
    }

    *pszDeviceType = TEXT('\0');

    for (i = 0,
         pport = pports;
         i < (INT )dwcPorts; ++i, ++pport)
    {
        if (!_stricmp(pport->P_PortName, pszPort))
        {
            strncpyAtoT(
                pszDeviceType,
                pport->P_DeviceType,
                RAS_MaxDeviceType + 1);

            break;
        }
    }
    Free(pports);

    //
    // If we couldn't match the port name,
    // then fallback to the media name.
    //
    if (*pszDeviceType == TEXT('\0'))
    {
        lstrcpyn(
            pszDeviceType,
            pLink->pbport.pszMedia,
            RAS_MaxDeviceType + 1);
    }

done:
    if (pszPort != NULL)
        Free(pszPort);

    return dwErr;
}


VOID
SetDevicePortName(
    IN TCHAR *pszDeviceName,
    IN TCHAR *pszPortName,
    OUT TCHAR *pszDevicePortName
    )
{
    //
    // Encode the port name after the
    // NULL character in the device name,
    // so it looks like:
    //
    //      <device name>\0<port name>\0
    //
    RtlZeroMemory(
        pszDevicePortName,
        (RAS_MaxDeviceName + 1) * sizeof (TCHAR));

    lstrcpyn(pszDevicePortName, pszDeviceName, RAS_MaxDeviceName + 1);

    if (pszPortName != NULL)
    {
        DWORD dwSize = lstrlen(pszDevicePortName) + 1;

        lstrcpyn(
            &pszDevicePortName[dwSize],
            pszPortName,
            (RAS_MaxDeviceName + 1) - dwSize);
    }
}


VOID
GetDevicePortName(
    IN TCHAR *pszDevicePortName,
    OUT TCHAR *pszDeviceName,
    OUT TCHAR *pszPortName
    )
{
    DWORD i, dwStart;

    //
    // Copy the device name.
    //
    lstrcpyn(pszDeviceName, pszDevicePortName, RAS_MaxDeviceName + 1);

    //
    // Check to see if there is a NULL
    // within MAX_PORT_NAME characters
    // after the device name's NULL.If
    // there is, the copy the characters
    // between the NULLs as the port name.
    //
    *pszPortName = TEXT('\0');

    dwStart = lstrlen(pszDeviceName) + 1;

    //
    // .Net bug# 522130 RASAPI32 Buffer overflow in util.c, function
    // GetDevicePortName
    //
    for (i = 0; (dwStart + i) < (RAS_MaxDeviceName + 1); i++)
    {
        if (pszDevicePortName[dwStart + i] == TEXT('\0'))
        {
            lstrcpyn(
                pszPortName,
                &pszDevicePortName[dwStart],
                MAX_PORT_NAME);

            break;

        }
    }
}


VOID
SetDevicePortNameFromLink(
    IN PBLINK *pLink,
    OUT TCHAR* pszDevicePortName
    )
{
    *pszDevicePortName = TEXT('\0');

    if (pLink->pbport.pszDevice != NULL)
    {
        SetDevicePortName(
            pLink->pbport.pszDevice,
            pLink->pbport.pszPort,
            pszDevicePortName);
    }
}


DWORD
PhonebookEntryToRasEntry(
    IN PBENTRY*     pEntry,
    OUT LPRASENTRY  lpRasEntry,
    IN OUT LPDWORD  lpdwcb,
    OUT LPBYTE      lpbDeviceConfig,
    IN OUT LPDWORD  lpcbDeviceConfig
    )
{
    DWORD       dwErr,
                dwcb,
                dwcbPhoneNumber;

    DWORD       dwnPhoneNumbers,
                dwnAlternatePhoneNumbers = 0;
    DWORD       dwcbOrig,
                dwcbOrigDeviceConfig = 0;

    DTLNODE*    pdtlnode;
    PTCHAR      pszPhoneNumber;
    PBLINK*     pLink;
    PBPHONE*    pPhone;
    DTLNODE*    pDefaultPhone = NULL;


    //
    // Set up to access information for the first link.
    //
    pdtlnode = DtlGetFirstNode(pEntry->pdtllistLinks);

    pLink = (PBLINK *)DtlGetData(pdtlnode);

    //
    // Determine up front if the buffer
    // is large enough.
    //
    dwcb = sizeof (RASENTRY);

    if(pLink->pdtllistPhones)
    {
        dwnPhoneNumbers = DtlGetNodes(pLink->pdtllistPhones);
    }
    else
    {
        dwnPhoneNumbers = 0;
    }

    if (dwnPhoneNumbers > 1)
    {
        dwnAlternatePhoneNumbers = dwnPhoneNumbers - 1;

        pdtlnode = DtlGetFirstNode(pLink->pdtllistPhones);

        for (pdtlnode = DtlGetNextNode(pdtlnode);
             pdtlnode != NULL;
             pdtlnode = DtlGetNextNode(pdtlnode))
        {
            TCHAR *pszNum = DtlGetData(pdtlnode);

            pPhone = DtlGetData(pdtlnode);

            pszNum = pPhone->pszPhoneNumber;

            ASSERT(pszNum);

            dwcb += (lstrlen(pszNum) + 1) * sizeof (TCHAR);
        }

        dwcb += sizeof (TCHAR);
    }

    //
    // Set the return buffer size.
    //
    dwcbOrig = *lpdwcb;

    *lpdwcb = dwcb;

    if (lpcbDeviceConfig != NULL)
    {
        dwcbOrigDeviceConfig = *lpcbDeviceConfig;

        *lpcbDeviceConfig = pLink->cbTapiBlob;
    }

    //
    // Return if the buffer is NULL or if
    // there is not enough room.
    //
    if (    lpRasEntry == NULL
        ||  dwcbOrig < dwcb
        ||  (   lpbDeviceConfig != NULL
            &&  dwcbOrigDeviceConfig < pLink->cbTapiBlob))
    {
        return ERROR_BUFFER_TOO_SMALL;
    }

    //
    // Get the first phonenumber from the first link.
    // This will be the primary phonenumber we use -
    // note that direct connect entries may not have
    // this number
    //
    if(     NULL != pLink->pdtllistPhones
        &&  NULL != DtlGetFirstNode(pLink->pdtllistPhones))
    {
        pPhone = (PBPHONE *)
                 DtlGetData(DtlGetFirstNode(pLink->pdtllistPhones));

        ASSERT(NULL != pPhone);
    }
    else
    {
        pPhone = NULL;
    }

    //
    // Set dwfOptions.
    //
    lpRasEntry->dwfOptions = 0;

    if (    pPhone
        &&  pPhone->fUseDialingRules)
    {
        lpRasEntry->dwfOptions |= RASEO_UseCountryAndAreaCodes;
    }

    if (pEntry->dwIpAddressSource == ASRC_RequireSpecific)
    {
        lpRasEntry->dwfOptions |= RASEO_SpecificIpAddr;
    }

    if (pEntry->dwIpNameSource == ASRC_RequireSpecific)
    {
        lpRasEntry->dwfOptions |= RASEO_SpecificNameServers;
    }

    if (pEntry->fIpHeaderCompression)
    {
        lpRasEntry->dwfOptions |= RASEO_IpHeaderCompression;
    }

    if (!pEntry->fLcpExtensions)
    {
        lpRasEntry->dwfOptions |= RASEO_DisableLcpExtensions;
    }

    if (pLink->pbport.fScriptBeforeTerminal)
    {
        lpRasEntry->dwfOptions |= RASEO_TerminalBeforeDial;
    }

    if (pEntry->fScriptAfterTerminal)
    {
        lpRasEntry->dwfOptions |= RASEO_TerminalAfterDial;
    }

    if (pEntry->fShowMonitorIconInTaskBar)
    {
        lpRasEntry->dwfOptions |= RASEO_ModemLights;
    }
    if (pEntry->fSwCompression)
    {
        lpRasEntry->dwfOptions |= RASEO_SwCompression;
    }

    if (   !(pEntry->dwAuthRestrictions & AR_F_AuthPAP)
        && !(pEntry->dwAuthRestrictions & AR_F_AuthEAP))
    {
        lpRasEntry->dwfOptions |= RASEO_RequireEncryptedPw;
        //
        // It does not matter if both of these flags are set at the same time.
        // RASEO_RequireMsEncryptedPw takes precedence over
        // RASEO_RequireEncryptedPw if both are set.
        //
        if (   !(pEntry->dwAuthRestrictions & AR_F_AuthSPAP)
            && !(pEntry->dwAuthRestrictions & AR_F_AuthMD5CHAP)
            && !(pEntry->dwAuthRestrictions & AR_F_AuthCustom))
        {
            lpRasEntry->dwfOptions |= RASEO_RequireMsEncryptedPw;
        }
    }

    if (    pEntry->dwDataEncryption != DE_None
        &&  pEntry->dwDataEncryption != DE_IfPossible)
    {
        lpRasEntry->dwfOptions |= RASEO_RequireDataEncryption;
    }

    //
    // RASEO_NetworkLogon is always FALSE
    //
    if (pEntry->fAutoLogon)
    {
        lpRasEntry->dwfOptions |= RASEO_UseLogonCredentials;
    }

    if (pLink->fPromoteAlternates)
    {
        lpRasEntry->dwfOptions |= RASEO_PromoteAlternates;
    }

    if(     !pEntry->fShareMsFilePrint
        ||  !pEntry->fBindMsNetClient)
    {
        lpRasEntry->dwfOptions |= RASEO_SecureLocalFiles;
    }

    if(NULL == pPhone)
    {
        //
        // Get Default phone values
        //
        pDefaultPhone = CreatePhoneNode();

        if(NULL == pDefaultPhone)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        pPhone = DtlGetData(pDefaultPhone);

    }

    ASSERT(NULL != pPhone);

    lpRasEntry->dwCountryID = pPhone->dwCountryID;
    lpRasEntry->dwCountryCode = pPhone->dwCountryCode;

    if(pPhone->pszAreaCode != NULL)
    {
        lstrcpyn(
            lpRasEntry->szAreaCode,
            pPhone->pszAreaCode,
            RAS_MaxAreaCode + 1);
    }
    else
    {
        *lpRasEntry->szAreaCode = TEXT('\0');
    }

    if(NULL != pDefaultPhone)
    {
        DestroyPhoneNode(pDefaultPhone);

        pPhone = NULL;
    }

    //
    // Set IP addresses.
    //
    if (lpRasEntry->dwfOptions & RASEO_SpecificIpAddr)
    {
        dwErr = StringToIpAddr(
                    pEntry->pszIpAddress,
                    &lpRasEntry->ipaddr);

        if (dwErr)
        {
            return dwErr;
        }
    }
    else
    {
        RtlZeroMemory(&lpRasEntry->ipaddr, sizeof (RASIPADDR));
    }

    if (lpRasEntry->dwfOptions & RASEO_SpecificNameServers)
    {
        dwErr = StringToIpAddr(
                  pEntry->pszIpDnsAddress,
                  &lpRasEntry->ipaddrDns);

        if (dwErr)
        {
            return dwErr;
        }

        dwErr = StringToIpAddr(
                  pEntry->pszIpDns2Address,
                  &lpRasEntry->ipaddrDnsAlt);

        if (dwErr)
        {
            return dwErr;
        }

        dwErr = StringToIpAddr(
                  pEntry->pszIpWinsAddress,
                  &lpRasEntry->ipaddrWins);

        if (dwErr)
        {
            return dwErr;
        }

        dwErr = StringToIpAddr(
                  pEntry->pszIpWins2Address,
                  &lpRasEntry->ipaddrWinsAlt);

        if (dwErr)
        {
            return dwErr;
        }
    }
    else
    {
        RtlZeroMemory(&lpRasEntry->ipaddrDns, sizeof (RASIPADDR));

        RtlZeroMemory(&lpRasEntry->ipaddrDnsAlt, sizeof (RASIPADDR));

        RtlZeroMemory(&lpRasEntry->ipaddrWins, sizeof (RASIPADDR));

        RtlZeroMemory(&lpRasEntry->ipaddrWinsAlt, sizeof (RASIPADDR));
    }

    //
    // Set protocol and framing information.
    //
    switch (pEntry->dwBaseProtocol)
    {
    case BP_Ras:
        lpRasEntry->dwFramingProtocol   = RASFP_Ras;
        lpRasEntry->dwFrameSize         = 0;
        lpRasEntry->dwfNetProtocols     = 0;
        break;

    case BP_Ppp:
        lpRasEntry->dwFramingProtocol = RASFP_Ppp;

        lpRasEntry->dwFrameSize = 0;

        lpRasEntry->dwfNetProtocols = 0;

        if (!(pEntry->dwfExcludedProtocols & NP_Nbf))
        {
            lpRasEntry->dwfNetProtocols |= RASNP_NetBEUI;
        }

        if (!(pEntry->dwfExcludedProtocols & NP_Ipx))
        {
            lpRasEntry->dwfNetProtocols |= RASNP_Ipx;
        }

        if (!(pEntry->dwfExcludedProtocols & NP_Ip))
        {
            lpRasEntry->dwfNetProtocols |= RASNP_Ip;
        }

        if (pEntry->fIpPrioritizeRemote)
        {
            lpRasEntry->dwfOptions |= RASEO_RemoteDefaultGateway;
        }

        //
        // Check for no protocols configured.  In this case,
        // set AMB framing.
        //
        if (!lpRasEntry->dwfNetProtocols)
        {
            lpRasEntry->dwFramingProtocol = RASFP_Ras;
        }

        break;

    case BP_Slip:
        lpRasEntry->dwFramingProtocol   = RASFP_Slip;
        lpRasEntry->dwFrameSize         = pEntry->dwFrameSize;
        lpRasEntry->dwfNetProtocols     = RASNP_Ip;

        if (pEntry->fIpPrioritizeRemote)
        {
            lpRasEntry->dwfOptions |= RASEO_RemoteDefaultGateway;
        }

        break;
    }

    //
    // Make sure only installed protocols get reported.
    //
    lpRasEntry->dwfNetProtocols &= GetInstalledProtocolsEx(
                                                NULL,
                                                FALSE,
                                                TRUE,
                                                FALSE);

    //
    // Set X.25 information.
    //
    *lpRasEntry->szScript = '\0';

    if (pEntry->fScriptAfterTerminal)
    {
        lpRasEntry->dwfOptions |= RASEO_TerminalAfterDial;
    }

    if (pEntry->fScriptAfter)
    {
        DWORD i, cdwDevices;
        RASMAN_DEVICE *pDevices;
        CHAR szScriptA[MAX_PATH];

        strncpyTtoA(szScriptA, pEntry->pszScriptAfter, sizeof(szScriptA));

        //
        // Get the list of switches to see if it is an
        // old-style script or a new style script.
        //
        dwErr = GetRasSwitches(NULL, &pDevices, &cdwDevices);
        if (dwErr)
        {
            return dwErr;
        }

        for (i = 0; i < cdwDevices; i++)
        {
            if (!_stricmp(pDevices[i].D_Name, szScriptA))
            {
                _snwprintf(
                    lpRasEntry->szScript,
                    sizeof(lpRasEntry->szScript) / sizeof(WCHAR),
                    TEXT("[%s"),
                    pEntry->pszScriptAfter);

                break;
            }
        }

        Free(pDevices);

        //
        // If we didn't find an old-style script match,
        // then it's a new-sytle script.
        //
        if (*lpRasEntry->szScript == TEXT('\0'))
        {
            _snwprintf(
                lpRasEntry->szScript,
                sizeof(lpRasEntry->szScript) / sizeof(WCHAR),
                TEXT("%s"),
                pEntry->pszScriptAfter);
        }
    }

    if (pEntry->pszX25Network != NULL)
    {
        lstrcpyn(
            lpRasEntry->szX25PadType,
            pEntry->pszX25Network,
            sizeof(lpRasEntry->szX25PadType) / sizeof(WCHAR));
    }
    else
    {
        *lpRasEntry->szX25PadType = TEXT('\0');
    }

    if (pEntry->pszX25Address != NULL)
    {
        lstrcpyn(
            lpRasEntry->szX25Address,
            pEntry->pszX25Address,
            sizeof(lpRasEntry->szX25Address) / sizeof(WCHAR));
    }
    else
    {
        *lpRasEntry->szX25Address = TEXT('\0');
    }

    if (pEntry->pszX25Facilities != NULL)
    {
        lstrcpyn(
            lpRasEntry->szX25Facilities,
            pEntry->pszX25Facilities,
            sizeof(lpRasEntry->szX25Facilities) / sizeof(WCHAR));
    }
    else
    {
        *lpRasEntry->szX25Facilities = TEXT('\0');
    }

    if (pEntry->pszX25UserData != NULL)
    {
        lstrcpyn(
            lpRasEntry->szX25UserData,
            pEntry->pszX25UserData,
            sizeof(lpRasEntry->szX25UserData) / sizeof(WCHAR));
    }
    else
    {
        *lpRasEntry->szX25UserData = TEXT('\0');
    }

    //
    // Set custom dial UI information.
    //
    if (    pEntry->pszCustomDialDll != NULL
        &&  pEntry->pszCustomDialFunc != NULL)
    {
        lstrcpyn(
          lpRasEntry->szAutodialDll,
          pEntry->pszCustomDialDll,
          sizeof (lpRasEntry->szAutodialDll) / sizeof (TCHAR));

        lstrcpyn(
          lpRasEntry->szAutodialFunc,
          pEntry->pszCustomDialFunc,
          sizeof (lpRasEntry->szAutodialFunc) / sizeof (TCHAR));
    }
    else
    {
        *lpRasEntry->szAutodialDll = TEXT('\0');
        *lpRasEntry->szAutodialFunc = TEXT('\0');
    }

    //
    // Set area code and primary phone number.
    //
    if (    pPhone
        &&  pPhone->pszAreaCode != NULL)
    {
        lstrcpyn(
          lpRasEntry->szAreaCode,
          pPhone->pszAreaCode,
          sizeof (lpRasEntry->szAreaCode) / sizeof (TCHAR));
    }
    else
    {
        *lpRasEntry->szAreaCode = TEXT('\0');
    }

    if(NULL != pLink->pdtllistPhones)
    {
        pdtlnode = DtlGetFirstNode(pLink->pdtllistPhones);
    }
    else
    {
        pdtlnode = NULL;
    }

    if (pdtlnode != NULL)
    {
        PBPHONE *pPhonePrimary = (PBPHONE *) DtlGetData(pdtlnode);
        TCHAR *pszNum;

        ASSERT(pPhonePrimary);

        pszNum = pPhonePrimary->pszPhoneNumber;

        ASSERT(pszNum);

        lstrcpyn(
          lpRasEntry->szLocalPhoneNumber,
          pszNum,
          sizeof (lpRasEntry->szLocalPhoneNumber)
                    / sizeof (TCHAR));
    }
    else
    {
        *lpRasEntry->szLocalPhoneNumber = TEXT('\0');
    }

    //
    // Copy the alternate phone numbers past the
    // end of the structure.
    //
    if (dwnAlternatePhoneNumbers)
    {
        PTCHAR pEnd = (PTCHAR)((ULONG_PTR)lpRasEntry
                                + sizeof (RASENTRY));

        lpRasEntry->dwAlternateOffset =
                     (DWORD)((ULONG_PTR) pEnd - (ULONG_PTR) lpRasEntry);

        for (pdtlnode = DtlGetNextNode(pdtlnode);
             pdtlnode != NULL;
             pdtlnode = DtlGetNextNode(pdtlnode))
        {
            PBPHONE *pPhoneSecondary = DtlGetData(pdtlnode);

            TCHAR *pszNum;

            ASSERT(pPhoneSecondary);

            pszNum = pPhoneSecondary->pszPhoneNumber;

            ASSERT(pszNum);

            pszPhoneNumber = StrDup(pszNum);

            if(NULL == pszPhoneNumber)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            ASSERT(pszPhoneNumber);

            dwcbPhoneNumber = lstrlen(pszPhoneNumber);

            lstrcpyn(
                pEnd,
                pszPhoneNumber,
                (INT )(((PTCHAR )lpRasEntry + dwcbOrig) - pEnd));

            Free(pszPhoneNumber);

            pEnd += dwcbPhoneNumber + 1;
        }

        //
        // Add an extra NULL character to
        // terminate the list.
        //
        *pEnd = TEXT('\0');
    }
    else
    {
        lpRasEntry->dwAlternateOffset = 0;
    }

    //
    // Set device information.
    //
    switch (pLink->pbport.pbdevicetype)
    {
    case PBDT_Isdn:
        lstrcpyn(
            lpRasEntry->szDeviceType,
            RASDT_Isdn,
            sizeof(lpRasEntry->szDeviceType) / sizeof(WCHAR));
        break;

    case PBDT_X25:
        lstrcpyn(
            lpRasEntry->szDeviceType,
            RASDT_X25,
            sizeof(lpRasEntry->szDeviceType) / sizeof(WCHAR));
        break;

    case PBDT_Other:
    case PBDT_Irda:
    case PBDT_Vpn:
    case PBDT_Serial:
    case PBDT_Atm:
    case PBDT_Parallel:
    case PBDT_Sonet:
    case PBDT_Sw56:
    case PBDT_FrameRelay:
    case PBDT_PPPoE:
    {
        dwErr = GetRasmanDeviceType(
                    pLink,
                    lpRasEntry->szDeviceType);
        if (dwErr)
        {
            return dwErr;
        }

        //
        // Convert the device type to lower case
        // to be consistent with the predefined
        // types.
        //
        _tcslwr(lpRasEntry->szDeviceType);
        break;
    }

    default:
        lstrcpyn(
            lpRasEntry->szDeviceType,
            RASDT_Modem,
            sizeof(lpRasEntry->szDeviceType) / sizeof(WCHAR));
        break;
    }

    SetDevicePortNameFromLink(pLink, lpRasEntry->szDeviceName);

    //
    // Set the TAPI configuration blob.
    //
    if (    lpbDeviceConfig != NULL
        &&  dwcbOrigDeviceConfig <= pLink->cbTapiBlob)
    {
        memcpy(
            lpbDeviceConfig,
            pLink->pTapiBlob,
            pLink->cbTapiBlob);
    }

    //
    // Copy the following fields over only
    // for a V401 structure or greater
    //
    if (    lpRasEntry->dwSize == sizeof (RASENTRY)
        ||  lpRasEntry->dwSize == sizeof (RASENTRYW_V500)
        ||  lpRasEntry->dwSize == sizeof (RASENTRYW_V401))
    {
        //
        // Set multilink information.
        //
        lpRasEntry->dwSubEntries =
                    DtlGetNodes(pEntry->pdtllistLinks);

        lpRasEntry->dwDialMode = pEntry->dwDialMode;

        lpRasEntry->dwDialExtraPercent =
                                    pEntry->dwDialPercent;

        lpRasEntry->dwDialExtraSampleSeconds =
                                    pEntry->dwDialSeconds;

        lpRasEntry->dwHangUpExtraPercent =
                                pEntry->dwHangUpPercent;

        lpRasEntry->dwHangUpExtraSampleSeconds =
                                pEntry->dwHangUpSeconds;

        //
        // Set idle timeout information.
        //
        lpRasEntry->dwIdleDisconnectSeconds =
                        pEntry->lIdleDisconnectSeconds;
                        
        if(1 == pEntry->dwCustomScript)
        {
            lpRasEntry->dwfOptions |= RASEO_CustomScript;
        }
    }

    //
    // Set the entry guid, EntryType
    // and encryptiontype if this is
    // nt5
    //
    if (    (sizeof (RASENTRY) == lpRasEntry->dwSize)
        ||  (sizeof (RASENTRYW_V500) == lpRasEntry->dwSize))
    {
        if (pEntry->pGuid)
        {
            lpRasEntry->guidId = *pEntry->pGuid;
        }

        lpRasEntry->dwType = pEntry->dwType;

        //
        // Encryption type
        //
        if (pEntry->dwDataEncryption != DE_None)
        {
            if(DE_Require == pEntry->dwDataEncryption)
            {
                lpRasEntry->dwEncryptionType = ET_Require;
            }
            else if(DE_RequireMax == pEntry->dwDataEncryption)
            {
                lpRasEntry->dwEncryptionType = ET_RequireMax;
            }
            else if(DE_IfPossible == pEntry->dwDataEncryption)
            {
                lpRasEntry->dwEncryptionType = ET_Optional;
            }
        }
        else
        {
            lpRasEntry->dwEncryptionType = ET_None;
        }

        /*
        //
        // Clear the authentication bits set if this is nt5.
        // we will set the new bits here
        //
        lpRasEntry->dwfOptions &= ~(RASEO_RequireMsEncryptedPw
                                  | RASEO_RequireEncryptedPw);

        */

        //
        // Set the authentication bits for nt5
        //
        if (pEntry->dwAuthRestrictions & AR_F_AuthMSCHAP)
        {
            lpRasEntry->dwfOptions |= RASEO_RequireMsCHAP;
        }

        if(pEntry->dwAuthRestrictions & AR_F_AuthMSCHAP2)
        {
            lpRasEntry->dwfOptions |= RASEO_RequireMsCHAP2;
        }

        if(pEntry->dwAuthRestrictions & AR_F_AuthW95MSCHAP)
        {
            lpRasEntry->dwfOptions |= RASEO_RequireW95MSCHAP;
        }

        if (pEntry->dwAuthRestrictions & AR_F_AuthPAP)
        {
            lpRasEntry->dwfOptions |= RASEO_RequirePAP;
        }

        if (pEntry->dwAuthRestrictions & AR_F_AuthMD5CHAP)
        {
            lpRasEntry->dwfOptions |= RASEO_RequireCHAP;
        }

        if (pEntry->dwAuthRestrictions & AR_F_AuthSPAP)
        {
            lpRasEntry->dwfOptions |= RASEO_RequireSPAP;
        }

        if (pEntry->dwAuthRestrictions & AR_F_AuthEAP)
        {
            lpRasEntry->dwfOptions |= RASEO_RequireEAP;

            if(     (0 != pEntry->dwCustomAuthKey)
                &&  (-1 != pEntry->dwCustomAuthKey))
            {
                lpRasEntry->dwCustomAuthKey =
                    pEntry->dwCustomAuthKey;
            }
        }

        if(pEntry->dwAuthRestrictions & AR_F_AuthCustom)
        {
            lpRasEntry->dwfOptions |= RASEO_Custom;
        }

        //
        // Set custom dial dll information.
        //
        if (NULL != pEntry->pszCustomDialerName)
        {
            lstrcpyn(
              lpRasEntry->szCustomDialDll,
              pEntry->pszCustomDialerName,
              sizeof ( lpRasEntry->szCustomDialDll)
                     / sizeof (TCHAR));

        }
        else
        {
            *lpRasEntry->szCustomDialDll = TEXT('\0');
        }

        //
        // Set the PreviewPhoneNumbers/SharedPhonenumbers
        //
        if(pEntry->fPreviewPhoneNumber)
        {
            lpRasEntry->dwfOptions |= RASEO_PreviewPhoneNumber;
        }

        if(pEntry->fSharedPhoneNumbers)
        {
            lpRasEntry->dwfOptions |= RASEO_SharedPhoneNumbers;
        }

        if(pEntry->fPreviewUserPw)
        {
            lpRasEntry->dwfOptions |= RASEO_PreviewUserPw;
        }

        if(pEntry->fPreviewDomain)
        {
            lpRasEntry->dwfOptions |= RASEO_PreviewDomain;
        }

        if(pEntry->fShowDialingProgress)
        {
            lpRasEntry->dwfOptions |= RASEO_ShowDialingProgress;
        }

        //
        // Copy the vpn strategy
        //
        lpRasEntry->dwVpnStrategy = pEntry->dwVpnStrategy;
    }

    if(lpRasEntry->dwSize == sizeof(RASENTRYW))
    {
        lpRasEntry->dwfOptions2 = 0;
        
        //
        // Set the FileAndPrint and ClientForMSNet bits
        //
        if(!pEntry->fShareMsFilePrint)
        {
            lpRasEntry->dwfOptions2 |= RASEO2_SecureFileAndPrint;
        }

        if(!pEntry->fBindMsNetClient)
        {
            lpRasEntry->dwfOptions2 |= RASEO2_SecureClientForMSNet;
        }

        if(!pEntry->fNegotiateMultilinkAlways)
        {
            lpRasEntry->dwfOptions2 |= RASEO2_DontNegotiateMultilink;
        }

        if(!pEntry->fUseRasCredentials)
        {
            lpRasEntry->dwfOptions2 |= RASEO2_DontUseRasCredentials;
        }

        if(pEntry->dwIpSecFlags & AR_F_IpSecPSK)
        {
            lpRasEntry->dwfOptions2  |= RASEO2_UsePreSharedKey;
        }

        if (! (pEntry->dwIpNbtFlags & PBK_ENTRY_IP_NBT_Enable))
        {
            lpRasEntry->dwfOptions2 |= RASEO2_DisableNbtOverIP;
        }

        if (pEntry->dwUseFlags & PBK_ENTRY_USE_F_Internet)
        {
            lpRasEntry->dwfOptions2 |= RASEO2_Internet;
        }

        // Whislter bug 281306
        //
        if (pEntry->fGlobalDeviceSettings)
        {
            lpRasEntry->dwfOptions2 |= RASEO2_UseGlobalDeviceSettings;
        }

        if(pEntry->pszIpDnsSuffix)
        {
            lstrcpyn(lpRasEntry->szDnsSuffix,
                     pEntry->pszIpDnsSuffix,
                     RAS_MaxDnsSuffix);
        }
        else
        {
            lpRasEntry->szDnsSuffix[0] = TEXT('\0');
        }

        if ((pEntry->pszPrerequisiteEntry) && (pEntry->dwType == RASET_Vpn))
        {
            lstrcpyn(lpRasEntry->szPrerequisiteEntry,
                     pEntry->pszPrerequisiteEntry,
                     RAS_MaxEntryName);
        }
        else
        {
            lpRasEntry->szPrerequisiteEntry[0] = TEXT('\0');
        }

        if((pEntry->pszPrerequisitePbk) && (pEntry->dwType == RASET_Vpn))
        {
            lstrcpyn(lpRasEntry->szPrerequisitePbk,
                     pEntry->pszPrerequisitePbk,
                     MAX_PATH);
        }
        else
        {
            lpRasEntry->szPrerequisitePbk[0] = TEXT('\0');
        }

        // Whistler bug 300933
        //
        lpRasEntry->dwTcpWindowSize = pEntry->dwTcpWindowSize;

        // XP 351608
        //
        lpRasEntry->dwRedialCount = pEntry->dwRedialAttempts;
        lpRasEntry->dwRedialPause = pEntry->dwRedialSeconds;

        // XP 370815
        // 
        if (pEntry->fRedialOnLinkFailure)
        {
            lpRasEntry->dwfOptions2 |= RASEO2_ReconnectIfDropped;
        }
        
        // XP 403967
        //
        if (pEntry->fSharedPhoneNumbers)
        {
            lpRasEntry->dwfOptions2 |= RASEO2_SharePhoneNumbers;
        }
        
    }

    return 0;
}

DWORD
CreateAndInitializePhone(
            LPTSTR      lpszAreaCode,
            DWORD       dwCountryCode,
            DWORD       dwCountryID,
            LPTSTR      lpszPhoneNumber,
            BOOL        fUseDialingRules,
            LPTSTR      lpszComment,
            DTLNODE**   ppdtlnode)
{
    DWORD    dwRetCode = ERROR_SUCCESS;
    PBPHONE* pPhone;
    DTLNODE* pdtlnode;

    pdtlnode = CreatePhoneNode();
    if (pdtlnode == NULL)
    {
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    pPhone = (PBPHONE *) DtlGetData(pdtlnode);

    if(lpszAreaCode)
    {
        pPhone->pszAreaCode = StrDup(lpszAreaCode);
        if(NULL == pPhone->pszAreaCode)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }
    }
    else
    {
        pPhone->pszAreaCode = NULL;
    }

    pPhone->dwCountryCode   = dwCountryCode;
    pPhone->dwCountryID     = dwCountryID;

    pPhone->fUseDialingRules = fUseDialingRules;

    if(lpszPhoneNumber)
    {
        pPhone->pszPhoneNumber  = StrDup(lpszPhoneNumber);
        if(NULL == pPhone->pszPhoneNumber)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }
    }
    else
    {
        pPhone->pszPhoneNumber = NULL;
    }

    if(pPhone->pszComment)
    {
        pPhone->pszComment = StrDup(lpszComment);
        if(NULL == pPhone->pszComment)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }
    }
    else
    {
        pPhone->pszComment = NULL;
    }

    *ppdtlnode = pdtlnode;

done:
    //
    // .Net bug# 522164 RASAPI32: Memory leak in function 
    // RasSubEntryToPhonebookLink
    //
    if ((dwRetCode != ERROR_SUCCESS) &&
        (pdtlnode != NULL)
       )
    {
        DestroyPhoneNode(pdtlnode);
    }

    return dwRetCode;
}

void
SetBogusPortInformation(PBLINK *pLink, DWORD dwType)
{
    PBPORT *pPort = &pLink->pbport;
    
    if (dwType == RASET_Phone)
    {
        pPort->pszMedia = StrDup( TEXT(SERIAL_TXT) );
        pPort->pbdevicetype = PBDT_Modem;

        pPort->dwFlags |= PBP_F_BogusDevice;
    }
    else if (dwType == RASET_Vpn)
    {
        pPort->pszMedia = StrDup( TEXT("rastapi") );
        pPort->pbdevicetype = PBDT_Vpn;
    }
    else
    {
        pPort->pszMedia = StrDup( TEXT(SERIAL_TXT) );
        pPort->pbdevicetype = PBDT_Null;

        pPort->dwFlags |= PBP_F_BogusDevice;
    }
}

DWORD
RasEntryToPhonebookEntry(
    IN LPCTSTR      lpszEntry,
    IN LPRASENTRY   lpRasEntry,
    IN DWORD        dwcb,
    IN LPBYTE       lpbDeviceConfig,
    IN DWORD        dwcbDeviceConfig,
    OUT PBENTRY     *pEntry
    )
{
    DWORD           dwErr, dwcbStr;
    DTLNODE         *pdtlnode;
    PBDEVICETYPE    pbdevicetype;
    PBLINK          *pLink;
    DTLLIST         *pdtllistPorts;
    PBPORT          *pPort;
    DWORD           i, cwDevices;
    RASMAN_DEVICE   *pDevices;
    TCHAR           szDeviceName[RAS_MaxDeviceName + 1];
    TCHAR           szPortName[MAX_PORT_NAME];
    DTLNODE         *pNodePhone;
    LPTSTR          pszAreaCode;
    PBPHONE         *pPhone;
    BOOL            fScriptBefore;
    BOOL            fScriptBeforeTerminal = FALSE;
    LPTSTR          pszScriptBefore;
    BOOL            fNewEntry = FALSE;

    //
    // Set up to access information for the first link.
    //
    pdtlnode = DtlGetFirstNode(pEntry->pdtllistLinks);

    pLink = (PBLINK *)DtlGetData(pdtlnode);

    ASSERT(NULL != pLink);

    fScriptBefore = pLink->pbport.fScriptBeforeTerminal;
    pszScriptBefore = pLink->pbport.pszScriptBefore;

    if(NULL == pEntry->pszEntryName)
    {
        fNewEntry = TRUE;
    }
    
    //
    // Get entry name.
    //
    Free0( pEntry->pszEntryName );

    pEntry->pszEntryName = StrDup(lpszEntry);

    //
    // Get dwfOptions.
    //
    pEntry->dwIpAddressSource =
      lpRasEntry->dwfOptions & RASEO_SpecificIpAddr ?
        ASRC_RequireSpecific : ASRC_ServerAssigned;

    pEntry->dwIpNameSource =
      lpRasEntry->dwfOptions & RASEO_SpecificNameServers ?
        ASRC_RequireSpecific : ASRC_ServerAssigned;

    switch (lpRasEntry->dwFramingProtocol)
    {
    case RASFP_Ppp:

        //
        // Get PPP-based information.
        //
        pEntry->dwBaseProtocol = BP_Ppp;

#if AMB
        pEntry->dwAuthentication = AS_PppThenAmb;
#endif

        pEntry->fIpHeaderCompression =
          (BOOL)lpRasEntry->dwfOptions & RASEO_IpHeaderCompression;

        pEntry->fIpPrioritizeRemote =
          (BOOL)lpRasEntry->dwfOptions & RASEO_RemoteDefaultGateway;

        //
        // Get specified IP addresses.
        //
        if (pEntry->dwIpAddressSource == ASRC_RequireSpecific)
        {
            Clear0(pEntry->pszIpAddress);
            dwErr = IpAddrToString(
                                &lpRasEntry->ipaddr,
                                &pEntry->pszIpAddress);
            if (dwErr)
                return dwErr;
        }
        else
        {
            pEntry->pszIpAddress = NULL;
        }

        if (pEntry->dwIpNameSource == ASRC_RequireSpecific)
        {
            Clear0(pEntry->pszIpDnsAddress);
            dwErr = IpAddrToString(
                        &lpRasEntry->ipaddrDns,
                        &pEntry->pszIpDnsAddress);

            if (dwErr)
            {
                return dwErr;
            }

            Clear0(pEntry->pszIpDns2Address);
            dwErr = IpAddrToString(
                        &lpRasEntry->ipaddrDnsAlt,
                        &pEntry->pszIpDns2Address);

            if (dwErr)
            {
                return dwErr;
            }

            Clear0(pEntry->pszIpWinsAddress);
            dwErr = IpAddrToString(
                        &lpRasEntry->ipaddrWins,
                        &pEntry->pszIpWinsAddress);

            if (dwErr)
            {
                return dwErr;
            }

            Clear0(pEntry->pszIpWins2Address);
            dwErr = IpAddrToString(
                        &lpRasEntry->ipaddrWinsAlt,
                        &pEntry->pszIpWins2Address);
            if (dwErr)
            {
                return dwErr;
            }
        }
        else
        {
            pEntry->pszIpDnsAddress     = NULL;
            pEntry->pszIpDns2Address    = NULL;
            pEntry->pszIpWinsAddress    = NULL;
            pEntry->pszIpWins2Address   = NULL;
        }

        //
        // Get protocol information.
        //
        pEntry->dwfExcludedProtocols = 0;

        if (!(lpRasEntry->dwfNetProtocols & RASNP_NetBEUI))
        {
            pEntry->dwfExcludedProtocols |= NP_Nbf;
        }

        if (!(lpRasEntry->dwfNetProtocols & RASNP_Ipx))
        {
            pEntry->dwfExcludedProtocols |= NP_Ipx;
        }

        if (!(lpRasEntry->dwfNetProtocols & RASNP_Ip))
        {
            pEntry->dwfExcludedProtocols |= NP_Ip;
        }

        break;

    case RASFP_Slip:

        //
        // Get SLIP-based information.
        //
        pEntry->dwBaseProtocol   = BP_Slip;
#if AMB
        pEntry->dwAuthentication = AS_PppThenAmb;
#endif

        pEntry->dwFrameSize      = lpRasEntry->dwFrameSize;

        pEntry->fIpHeaderCompression =
          (BOOL)lpRasEntry->dwfOptions & RASEO_IpHeaderCompression;

        pEntry->fIpPrioritizeRemote =
          (BOOL)lpRasEntry->dwfOptions & RASEO_RemoteDefaultGateway;

        //
        // Get protocol information.
        //
        pEntry->dwfExcludedProtocols = (NP_Nbf|NP_Ipx);

        if (pEntry->dwIpAddressSource == ASRC_RequireSpecific)
        {
            Clear0(pEntry->pszIpAddress);
            dwErr = IpAddrToString(
                        &lpRasEntry->ipaddr,
                        &pEntry->pszIpAddress);

            if (dwErr)
            {
                return dwErr;
            }
        }
        else
        {
            pEntry->pszIpAddress = NULL;
        }
        if (pEntry->dwIpNameSource == ASRC_RequireSpecific)
        {
            Clear0(pEntry->pszIpDnsAddress);
            dwErr = IpAddrToString(
                        &lpRasEntry->ipaddrDns,
                        &pEntry->pszIpDnsAddress);

            if (dwErr)
            {
                return dwErr;
            }

            Clear0(pEntry->pszIpDns2Address);
            dwErr = IpAddrToString(
                            &lpRasEntry->ipaddrDnsAlt,
                            &pEntry->pszIpDns2Address);

            if (dwErr)
            {
                return dwErr;
            }

            Clear0(pEntry->pszIpWinsAddress);
            dwErr = IpAddrToString(
                        &lpRasEntry->ipaddrWins,
                        &pEntry->pszIpWinsAddress);

            if (dwErr)
            {
                return dwErr;
            }

            Clear0(pEntry->pszIpWins2Address);
            dwErr = IpAddrToString(
                        &lpRasEntry->ipaddrWinsAlt,
                        &pEntry->pszIpWins2Address);

            if (dwErr)
            {
                return dwErr;
            }
        }
        else
        {
            pEntry->pszIpDnsAddress   = NULL;
            pEntry->pszIpDns2Address  = NULL;
            pEntry->pszIpWinsAddress  = NULL;
            pEntry->pszIpWins2Address = NULL;
        }
        break;
    case RASFP_Ras:

        //
        // Get AMB-based information.
        //
        pEntry->dwBaseProtocol   = BP_Ras;
#if AMB
        pEntry->dwAuthentication = AS_AmbOnly;
#endif

        break;
    }

    pEntry->fLcpExtensions =
      (BOOL)!(lpRasEntry->dwfOptions & RASEO_DisableLcpExtensions);

    //
    // If terminal before/after dial options are set,
    // then update the entry.  Otherwise, leave it as it
    // is.
    //
    if(lpRasEntry->dwfOptions & RASEO_TerminalBeforeDial)
    {
        fScriptBeforeTerminal = TRUE;
    }

    if(lpRasEntry->dwfOptions & RASEO_TerminalAfterDial)
    {
        pEntry->fScriptAfterTerminal = TRUE;
    }
    else
    {
        pEntry->fScriptAfterTerminal = FALSE;
    }


    pEntry->fShowMonitorIconInTaskBar =
        (BOOL) (lpRasEntry->dwfOptions & RASEO_ModemLights);

    pEntry->fSwCompression =
      (BOOL)(lpRasEntry->dwfOptions & RASEO_SwCompression);

    if (lpRasEntry->dwfOptions & RASEO_RequireMsEncryptedPw)
    {
        pEntry->dwAuthRestrictions = AR_F_AuthAnyMSCHAP;
    }
    else if (lpRasEntry->dwfOptions & RASEO_RequireEncryptedPw)
    {
        pEntry->dwAuthRestrictions =    AR_F_AuthSPAP
                                    |   AR_F_AuthMD5CHAP
                                    |   AR_F_AuthAnyMSCHAP;
    }
    else
    {
        pEntry->dwAuthRestrictions = AR_F_TypicalUnsecure;
    }

    pEntry->dwDataEncryption =
        (lpRasEntry->dwfOptions & RASEO_RequireDataEncryption)
      ? DE_Mppe40bit
      : DE_None;

    pEntry->fAutoLogon =
      (BOOL)(lpRasEntry->dwfOptions & RASEO_UseLogonCredentials);

    pLink->fPromoteAlternates =
      (BOOL)(lpRasEntry->dwfOptions & RASEO_PromoteAlternates);

    pEntry->fShareMsFilePrint = pEntry->fBindMsNetClient =
      (BOOL) !(lpRasEntry->dwfOptions & RASEO_SecureLocalFiles);

    //
    // Make sure that the network components section in the
    // phonebook correspond to the values user is setting.
    //
    EnableOrDisableNetComponent(
            pEntry, 
            TEXT("ms_msclient"),
            pEntry->fBindMsNetClient);

    EnableOrDisableNetComponent(
            pEntry, 
            TEXT("ms_server"),
            pEntry->fShareMsFilePrint);

    if (*lpRasEntry->szAreaCode != TEXT('\0'))
    {
        //
        // Make sure the area code does not contain
        // non-numeric characters.
        //
        if (!ValidateAreaCode(lpRasEntry->szAreaCode))
        {
            return ERROR_INVALID_PARAMETER;
        }

        pszAreaCode = StrDup(lpRasEntry->szAreaCode);
    }
    else
    {
        pszAreaCode = NULL;
    }

    //
    // Get script information.
    //
    if (lpRasEntry->szScript[0] == TEXT('['))
    {
        //
        // Verify the switch is valid.
        //
        dwErr = GetRasSwitches(NULL, &pDevices, &cwDevices);
        if (!dwErr)
        {
            CHAR szScriptA[MAX_PATH];

            strncpyTtoA(szScriptA, lpRasEntry->szScript, sizeof(szScriptA));
            for (i = 0; i < cwDevices; i++)
            {
                if (!_stricmp(pDevices[i].D_Name, &szScriptA[1]))
                {
                    pEntry->fScriptAfter = TRUE;

                    Clear0(pEntry->pszScriptAfter);
                    pEntry->pszScriptAfter =
                            StrDup(&lpRasEntry->szScript[1]);

                    if (pEntry->pszScriptAfter == NULL)
                    {
                        dwErr = GetLastError();
                    }
                    break;
                }
            }
            Free(pDevices);

            if (dwErr)
            {
                return dwErr;
            }
        }
    }
    else if (lpRasEntry->szScript[0] != TEXT('\0'))
    {
        pEntry->fScriptAfter = TRUE;

        Clear0(pEntry->pszScriptAfter);
        pEntry->pszScriptAfter = StrDup(lpRasEntry->szScript);

        if (pEntry->pszScriptAfter == NULL)
        {
            return GetLastError();
        }
    }
    else
    {
        Clear0(pEntry->pszScriptAfter);
        pEntry->fScriptAfter = FALSE;

        if(pLink->pbport.pszScriptBefore)
        {
            Free(pLink->pbport.pszScriptBefore);
            pLink->pbport.pszScriptBefore = NULL;
            pszScriptBefore = NULL;
        }

        pLink->pbport.fScriptBefore = FALSE;
        fScriptBefore = FALSE;
    }

    //
    // Get X.25 information.
    //
    pEntry->pszX25Network = NULL;
    if (*lpRasEntry->szX25PadType != TEXT('\0'))
    {
        //
        // Verify the X25 network is valid.
        //
        dwErr = GetRasPads(&pDevices, &cwDevices);
        if (!dwErr)
        {
            CHAR szX25PadTypeA[RAS_MaxPadType + 1];

            strncpyTtoA(
                szX25PadTypeA,
                lpRasEntry->szX25PadType,
                sizeof(szX25PadTypeA));

            for (i = 0; i < cwDevices; i++)
            {
                if (!_stricmp(pDevices[i].D_Name, szX25PadTypeA))
                {
                    Clear0(pEntry->pszX25Network);
                    pEntry->pszX25Network = StrDup(lpRasEntry->szX25PadType);
                    break;
                }
            }

            Free(pDevices);
        }
    }

    Clear0(pEntry->pszX25Address);
    pEntry->pszX25Address =
        lstrlen(lpRasEntry->szX25Address)
        ? StrDup(lpRasEntry->szX25Address)
        : NULL;

    Clear0(pEntry->pszX25Facilities);
    pEntry->pszX25Facilities =
        lstrlen(lpRasEntry->szX25Facilities)
        ? StrDup(lpRasEntry->szX25Facilities)
        : NULL;

    Clear0(pEntry->pszX25UserData);
    pEntry->pszX25UserData =
        lstrlen(lpRasEntry->szX25UserData)
        ? StrDup(lpRasEntry->szX25UserData)
        : NULL;

    //
    // Get custom dial UI information.
    //
    Clear0(pEntry->pszCustomDialDll);
    pEntry->pszCustomDialDll =
        lstrlen(lpRasEntry->szAutodialDll)
        ? StrDup(lpRasEntry->szAutodialDll)
        : NULL;

    Clear0(pEntry->pszCustomDialFunc);
    pEntry->pszCustomDialFunc =
        lstrlen(lpRasEntry->szAutodialFunc)
        ? StrDup(lpRasEntry->szAutodialFunc)
        : NULL;

    //
    // Get primary phone number.  Clear out any existing
    // numbers.
    //
    DtlDestroyList(pLink->pdtllistPhones, DestroyPhoneNode);

    pLink->pdtllistPhones = DtlCreateList(0);

    if(NULL == pLink->pdtllistPhones)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if (*lpRasEntry->szLocalPhoneNumber != '\0')
    {

        if(CreateAndInitializePhone(
                        pszAreaCode,
                        lpRasEntry->dwCountryCode,
                        lpRasEntry->dwCountryID,
                        lpRasEntry->szLocalPhoneNumber,
                        !!(lpRasEntry->dwfOptions
                         & RASEO_UseCountryAndAreaCodes),
                        lpRasEntry->szDeviceName,
                        &pdtlnode))
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        DtlAddNodeFirst(pLink->pdtllistPhones, pdtlnode);
    }

    //
    // Get the alternate phone numbers.
    //
    if (lpRasEntry->dwAlternateOffset)
    {
        PTCHAR pszPhoneNumber =
        (PTCHAR)((ULONG_PTR)lpRasEntry
                + lpRasEntry->dwAlternateOffset);

        while (*pszPhoneNumber != TEXT('\0'))
        {

            if(CreateAndInitializePhone(
                            pszAreaCode,
                            lpRasEntry->dwCountryCode,
                            lpRasEntry->dwCountryID,
                            pszPhoneNumber,
                            !!(lpRasEntry->dwfOptions
                             & RASEO_UseCountryAndAreaCodes),
                            lpRasEntry->szDeviceName,
                            &pdtlnode))
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            DtlAddNodeLast(pLink->pdtllistPhones, pdtlnode);

            pszPhoneNumber += lstrlen(pszPhoneNumber) + 1;
        }
    }

    //
    // Get device information.
    //
    dwErr = LoadPortsList(&pdtllistPorts);

    if (dwErr)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get the encoded device name/port
    // and check for a match.
    //
    GetDevicePortName(
        lpRasEntry->szDeviceName,
        szDeviceName, szPortName);

    pPort = PpbportFromPortAndDeviceName(
                pdtllistPorts,
                szPortName,
                ((szDeviceName[ 0 ]) ? szDeviceName : NULL) );

    if (pPort != NULL)
    {
        if (CopyToPbport(&pLink->pbport, pPort))
        {
            pPort = NULL;
        }
    }

    //
    // Search for a device name match.
    //
    if (pPort == NULL)
    {
        for (pdtlnode = DtlGetFirstNode(pdtllistPorts);
             pdtlnode != NULL;
             pdtlnode = DtlGetNextNode(pdtlnode))
        {
            PBPORT *pPortTmp = (PBPORT *)DtlGetData(pdtlnode);

            if (    (pPortTmp->pszDevice != NULL)
                &&  (!lstrcmpi(pPortTmp->pszDevice, szDeviceName))
                &&  (!CopyToPbport(&pLink->pbport, pPortTmp)))
            {
                pPort = pPortTmp;
                break;
            }
        }
    }

    //
    // If we don't have a match, then
    // pick the first device of the
    // same type.
    //
    if (pPort == NULL)
    {
        pbdevicetype = PbdevicetypeFromPszType(
                        lpRasEntry->szDeviceType
                        );

        //
        // Initialize dwErr in case
        // we fall through the loop
        // without finding a match.
        //
        // dwErr = ERROR_INVALID_PARAMETER;

        //
        // Look for a port with the same
        // device type.
        //
        for (pdtlnode = DtlGetFirstNode(pdtllistPorts);
             pdtlnode != NULL;
             pdtlnode = DtlGetNextNode(pdtlnode))
        {
            pPort = (PBPORT *)DtlGetData(pdtlnode);

            if (pPort->pbdevicetype == pbdevicetype)
            {
                // XP 358859
                //
                // Validate the port against the entry type if 
                // possible.
                //
                if (    (lpRasEntry->dwSize == sizeof (RASENTRY))
                    ||  (lpRasEntry->dwSize == sizeof (RASENTRYW_V500)))
                {
                    if (lpRasEntry->dwType == RASET_Phone)
                    {
                        if (RASET_Phone != EntryTypeFromPbport(pPort))
                        {
                            continue;
                        }
                    }
                }
            
                dwErr = CopyToPbport(&pLink->pbport, pPort);

                break;
            }
        }

        if(NULL == pdtlnode)
        {
            if(fNewEntry)
            {
                //
                // Hack to make CM connections work.
                // Remove this code after beta
                // and just return an error in this case. The api
                // should not be setting bogus information.
                //
                SetBogusPortInformation(pLink, pEntry->dwType);
            }

            pPort = NULL;
        }
        
        //
        // If the device is a modem,
        // then set the default modem settings.
        //
        if (pbdevicetype == PBDT_Modem)
        {
            SetDefaultModemSettings(pLink);
        }
    }

    // pmay: 401682
    // 
    // Update the preferred device.  Whenever this api is called,
    // we can assume that the user wants the given device to 
    // be sticky.
    //
    if (pPort)
    {
        Clear0(pEntry->pszPreferredDevice);
        pEntry->pszPreferredDevice = StrDup(pPort->pszDevice);
        
        Clear0(pEntry->pszPreferredPort);
        pEntry->pszPreferredPort = StrDup(pPort->pszPort);

        //For whistler bug 402522
        //
        pEntry->dwPreferredModemProtocol = pPort->dwModemProtDefault;
                        
    }

    //
    // Copy the remembered values
    //
    pLink->pbport.fScriptBefore = fScriptBefore;
    pLink->pbport.fScriptBeforeTerminal = fScriptBeforeTerminal;
    pLink->pbport.pszScriptBefore = pszScriptBefore;

    DtlDestroyList(pdtllistPorts, DestroyPortNode);

    if (dwErr)
    {
        return dwErr;
    }

    //
    // Copy the TAPI configuration blob.
    //
    if (lpbDeviceConfig != NULL && dwcbDeviceConfig)
    {
        Free0(pLink->pTapiBlob);

        pLink->pTapiBlob = Malloc(dwcbDeviceConfig);

        if (pLink->pTapiBlob == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        memcpy(pLink->pTapiBlob,
               lpbDeviceConfig,
               dwcbDeviceConfig);

        pLink->cbTapiBlob = dwcbDeviceConfig;
    }

    //
    // Copy the following fields over only for
    // a V401 structure or above.
    //
    if (    (lpRasEntry->dwSize == sizeof (RASENTRY))
        ||  (lpRasEntry->dwSize == sizeof (RASENTRYW_V500))
        ||  (lpRasEntry->dwSize == sizeof (RASENTRYW_V401)))
    {

        if(lpRasEntry->dwDialMode == 0)
        {
            pEntry->dwDialMode = 0;
        }
        else
        {
            pEntry->dwDialMode =    lpRasEntry->dwDialMode
                                 == RASEDM_DialAsNeeded
                                 ?  RASEDM_DialAsNeeded
                                 :  RASEDM_DialAll;
        }                             

        //
        // Get multilink and idle timeout information.
        //
        pEntry->dwDialPercent =
                lpRasEntry->dwDialExtraPercent;

        pEntry->dwDialSeconds =
            lpRasEntry->dwDialExtraSampleSeconds;

        pEntry->dwHangUpPercent =
                lpRasEntry->dwHangUpExtraPercent;

        pEntry->dwHangUpSeconds =
                lpRasEntry->dwHangUpExtraSampleSeconds;

        //
        // Get idle disconnect information.
        //
        pEntry->lIdleDisconnectSeconds =
                    lpRasEntry->dwIdleDisconnectSeconds;

        //
        // if the user is setting the dwIdleDisconnect
        // Seconds through apis then override the user
        // preferences.
        //
        if (pEntry->lIdleDisconnectSeconds)
        {
            pEntry->dwfOverridePref |= RASOR_IdleDisconnectSeconds;
        }
        
        //
        // CustomScript
        //
        pEntry->dwCustomScript = !!(    RASEO_CustomScript
                                    &   lpRasEntry->dwfOptions);
    }

    // 287667.  Make sure that the size of the structure is recent
    // enough to check the dwType value
    //
    if (    (lpRasEntry->dwSize == sizeof (RASENTRY))
        ||  (lpRasEntry->dwSize == sizeof (RASENTRYW_V500)))
    {        
        if(RASET_Phone != lpRasEntry->dwType)
        {
            pEntry->fPreviewPhoneNumber = FALSE;
            pEntry->fSharedPhoneNumbers = FALSE;
        }
    }        
    
    //
    // Copy the following information only if its nt5
    //
    if(     (lpRasEntry->dwSize == sizeof(RASENTRYW_V500))
        ||  (lpRasEntry->dwSize == sizeof(RASENTRY)))
    {
        //
        // Connection type
        //
        pEntry->dwType = lpRasEntry->dwType;

        //
        // Clear the Encryption type. We set it below
        // for nt5 - default to Mppe40Bit.
        //
        pEntry->dwDataEncryption = 0;

        /*
        if(     (ET_40Bit & lpRasEntry->dwEncryptionType)
            ||  (   (0 == lpRasEntry->dwEncryptionType)
                &&  (  RASEO_RequireDataEncryption
                     & lpRasEntry->dwfOptions)))
        {
            pEntry->dwDataEncryption |= DE_Mppe40bit;
        }

        if(ET_128Bit & lpRasEntry->dwEncryptionType)
        {
            pEntry->dwDataEncryption |= DE_Mppe128bit;
        }
        */

        if(     (ET_Require == lpRasEntry->dwEncryptionType)
            ||  (   (0 == lpRasEntry->dwEncryptionType)
                &&  (   RASEO_RequireDataEncryption
                    &   lpRasEntry->dwfOptions)))
        {
            pEntry->dwDataEncryption = DE_Require;
        }
        else if (ET_RequireMax == lpRasEntry->dwEncryptionType)
        {
            pEntry->dwDataEncryption = DE_RequireMax;
        }
        else if (ET_Optional == lpRasEntry->dwEncryptionType)
        {
            pEntry->dwDataEncryption = DE_IfPossible;
        }

        //
        // Clear the authrestrictions for nt5 if the user didn't
        // specify any authentication protocol.
        //
        if(     (!(lpRasEntry->dwfOptions & RASEO_RequireMsEncryptedPw))
            &&  (!(lpRasEntry->dwfOptions & RASEO_RequireEncryptedPw)))
        {
            pEntry->dwAuthRestrictions = 0;
        }

        //
        // Set the new authentication bits based on options defined
        // in NT5.
        //
        if(RASEO_RequireMsCHAP & lpRasEntry->dwfOptions)
        {
            pEntry->dwAuthRestrictions |= (AR_F_AuthMSCHAP | AR_F_AuthCustom);
        }

        if(RASEO_RequireMsCHAP2 & lpRasEntry->dwfOptions)
        {
            pEntry->dwAuthRestrictions |= (AR_F_AuthMSCHAP2 | AR_F_AuthCustom);
        }

        if(RASEO_RequireW95MSCHAP & lpRasEntry->dwfOptions)
        {
            pEntry->dwAuthRestrictions |= (AR_F_AuthW95MSCHAP | AR_F_AuthCustom);
        }

        if(RASEO_RequireCHAP & lpRasEntry->dwfOptions)
        {
            pEntry->dwAuthRestrictions |= (AR_F_AuthMD5CHAP | AR_F_AuthCustom);
        }

        if(RASEO_RequirePAP & lpRasEntry->dwfOptions)
        {
            pEntry->dwAuthRestrictions |= (AR_F_AuthPAP | AR_F_AuthCustom);
        }

        if(RASEO_RequireSPAP & lpRasEntry->dwfOptions)
        {
            pEntry->dwAuthRestrictions |= (AR_F_AuthSPAP | AR_F_AuthCustom);
        }

        if(RASEO_RequireEAP & lpRasEntry->dwfOptions)
        {
            pEntry->dwAuthRestrictions |= AR_F_AuthEAP;

            if(     (0 != lpRasEntry->dwCustomAuthKey)
                &&  (-1  != lpRasEntry->dwCustomAuthKey))
            {
                pEntry->dwCustomAuthKey =
                    lpRasEntry->dwCustomAuthKey;
            }
        }

        if(RASEO_Custom & lpRasEntry->dwfOptions)
        {
            pEntry->dwAuthRestrictions |= AR_F_AuthCustom;
        }

        if(0 == pEntry->dwAuthRestrictions)
        {
            pEntry->dwAuthRestrictions = AR_F_TypicalUnsecure;
        }

        if(     (lpRasEntry->dwfOptions & RASEO_RequireEncryptedPw)
            ||  (lpRasEntry->dwfOptions & RASEO_RequireMsEncryptedPw))
        {
            pEntry->dwAuthRestrictions &= ~(AR_F_AuthPAP);
        }
        

        //
        // Get custom dial UI information.
        //
        Clear0(pEntry->pszCustomDialerName);
        pEntry->pszCustomDialerName =
            lstrlen(lpRasEntry->szCustomDialDll)
            ? StrDup(lpRasEntry->szCustomDialDll)
            : NULL;

        //
        // Set fSharedPhoneNumbers/fPreviewPhoneNumbers
        //
        pEntry->fSharedPhoneNumbers = !!( RASEO_SharedPhoneNumbers
                                        & lpRasEntry->dwfOptions);

        pEntry->fPreviewPhoneNumber = !!(  RASEO_PreviewPhoneNumber
                                          & lpRasEntry->dwfOptions);

        pEntry->fPreviewUserPw = !!(  RASEO_PreviewUserPw
                                    & lpRasEntry->dwfOptions);

        pEntry->fPreviewDomain = !!(  RASEO_PreviewDomain
                                    & lpRasEntry->dwfOptions);

        pEntry->fShowDialingProgress = !!(  RASEO_ShowDialingProgress
                                          & lpRasEntry->dwfOptions);

        //
        // Vpn strategy
        //
        pEntry->dwVpnStrategy = lpRasEntry->dwVpnStrategy;

    }

    if(lpRasEntry->dwSize == sizeof(RASENTRY))
    {
        //
        // If the legacy RASEO bit is set, we don't want to do
        // anything. Otherwise we break legacy.
        //
        if(     (lpRasEntry->dwfOptions2 & RASEO2_SecureFileAndPrint)
            ||  (lpRasEntry->dwfOptions2 & RASEO2_SecureClientForMSNet))
        {
            pEntry->fShareMsFilePrint = 
                !(lpRasEntry->dwfOptions2 & RASEO2_SecureFileAndPrint);
                
            EnableOrDisableNetComponent(
                    pEntry, 
                    TEXT("ms_server"),
                    pEntry->fShareMsFilePrint);

            pEntry->fBindMsNetClient =
                !(lpRasEntry->dwfOptions2 & RASEO2_SecureClientForMSNet);
                
            EnableOrDisableNetComponent(
                    pEntry, 
                    TEXT("ms_msclient"),
                    pEntry->fBindMsNetClient);
        }

        if(lpRasEntry->dwfOptions2 & RASEO2_DontNegotiateMultilink)
        {
            pEntry->fNegotiateMultilinkAlways = FALSE;
        }
        else
        {
            pEntry->fNegotiateMultilinkAlways = TRUE;
        }

        if(lpRasEntry->dwfOptions2 & RASEO2_DontUseRasCredentials)
        {
            pEntry->fUseRasCredentials = FALSE;
        }
        else
        {
            pEntry->fUseRasCredentials = TRUE;
        }

        if(lpRasEntry->dwfOptions2 & RASEO2_UsePreSharedKey)
        {
            pEntry->dwIpSecFlags |= AR_F_IpSecPSK;
        }
        else
        {
            pEntry->dwIpSecFlags &= ~(AR_F_IpSecPSK);
        }

        if (lpRasEntry->dwfOptions2 & RASEO2_DisableNbtOverIP)
        {
            pEntry->dwIpNbtFlags = 0;
        }
        else
        {
            pEntry->dwIpNbtFlags = PBK_ENTRY_IP_NBT_Enable;
        }

        if (lpRasEntry->dwfOptions2 & RASEO2_Internet)
        {
            pEntry->dwUseFlags = PBK_ENTRY_USE_F_Internet;
        }
        else
        {
            pEntry->dwUseFlags = 0;
        }

        // Whislter bug 281306
        //
        pEntry->fGlobalDeviceSettings = 
            !!(lpRasEntry->dwfOptions2 & RASEO2_UseGlobalDeviceSettings);

        Clear0(pEntry->pszIpDnsSuffix);
        if(TEXT('\0') != lpRasEntry->szDnsSuffix[0])
        {
            pEntry->pszIpDnsSuffix = StrDup(lpRasEntry->szDnsSuffix);
        }
        else
        {
            pEntry->pszIpDnsSuffix = NULL;
        }

        // Whistler bug 300933
        //
        // Window size must be between 4K and 65K.  No particular increment needed
        // as the stack will calculate the correct value based on MTU.
        //
        // 0= use system default
        //
        if ((lpRasEntry->dwTcpWindowSize == 0) ||
             ((lpRasEntry->dwTcpWindowSize < 64*1024) && 
              (lpRasEntry->dwTcpWindowSize > 4*1024)))
        {             
            pEntry->dwTcpWindowSize = lpRasEntry->dwTcpWindowSize;
        }           

        if ((TEXT('\0') != lpRasEntry->szPrerequisiteEntry[0]) && 
            (RASET_Vpn == lpRasEntry->dwType))
        {
            // XP bug 339970
            //
            // Don't allow the entry to require itself to be dialed
            //
            if (lstrcmpi(lpRasEntry->szPrerequisiteEntry, lpszEntry))
            {
                Clear0(pEntry->pszPrerequisiteEntry);
                pEntry->pszPrerequisiteEntry = 
                    StrDup(lpRasEntry->szPrerequisiteEntry);
            }
            else
            {
                return ERROR_INVALID_PARAMETER;
            }
        }
        else
        {
            pEntry->pszPrerequisiteEntry = NULL;
        }

        if ((TEXT('\0') != lpRasEntry->szPrerequisitePbk[0]) && 
            (RASET_Vpn == lpRasEntry->dwType))
        {
            Clear0(pEntry->pszPrerequisitePbk);
            pEntry->pszPrerequisitePbk = 
                StrDup(lpRasEntry->szPrerequisitePbk);
        }
        else
        {
            pEntry->pszPrerequisitePbk = NULL;
        }

        // XP 351608
        //
        if (lpRasEntry->dwRedialCount <= RAS_MaxRedialCount)
        {
            pEntry->dwRedialAttempts = lpRasEntry->dwRedialCount;
        }
        else
        {
            return ERROR_INVALID_PARAMETER;
        }

        // XP 351608
        //
        if (lpRasEntry->dwRedialPause <= RAS_RedialPause10m)
        {
            pEntry->dwRedialSeconds = lpRasEntry->dwRedialPause;
        }
        else
        {
            return ERROR_INVALID_PARAMETER;
        }

        // XP 370815
        // 
        pEntry->fRedialOnLinkFailure = 
            !!(lpRasEntry->dwfOptions2 & RASEO2_ReconnectIfDropped);
    
        // XP 403967
        //
        pEntry->fSharedPhoneNumbers = 
            !!(lpRasEntry->dwfOptions2 & RASEO2_SharePhoneNumbers);
            
    }

    //
    // Set dirty bit so this entry will get written out.
    //
    pEntry->fDirty = TRUE;

    return 0;
}


DWORD
PhonebookLinkToRasSubEntry(
    PBLINK*         pLink,
    LPRASSUBENTRY   lpRasSubEntry,
    LPDWORD         lpdwcb,
    LPBYTE          lpbDeviceConfig,
    LPDWORD         lpcbDeviceConfig
    )
{
    DWORD       dwErr,
                dwcb,
                dwcbPhoneNumber;
    DWORD       dwnPhoneNumbers,
                dwnAlternatePhoneNumbers = 0;
    DWORD       dwcbOrig,
                dwcbOrigDeviceConfig;
    DTLNODE*    pdtlnode;
    PTCHAR      pszPhoneNumber;
    PBPHONE*    pPhone;

    //
    // Determine up front if the buffer
    // is large enough.
    //
    dwcb = sizeof (RASSUBENTRY);

    dwnPhoneNumbers = DtlGetNodes(
                        pLink->pdtllistPhones
                        );

    if (dwnPhoneNumbers > 1)
    {
        dwnAlternatePhoneNumbers = dwnPhoneNumbers - 1;

        pdtlnode = DtlGetFirstNode(
                        pLink->pdtllistPhones
                        );

        for (pdtlnode = DtlGetNextNode(pdtlnode);
             pdtlnode != NULL;
             pdtlnode = DtlGetNextNode(pdtlnode))
        {

            TCHAR *pszNum;

            pPhone = (PBPHONE *) DtlGetData(pdtlnode);

            pszNum = pPhone->pszPhoneNumber;

            ASSERT(pszNum);

            dwcb += (lstrlen(pszNum) + 1) * sizeof (TCHAR);

        }
        dwcb += sizeof (TCHAR);
    }

    //
    // Set the return buffer size.
    //
    dwcbOrig = *lpdwcb;

    dwcbOrigDeviceConfig =
        lpcbDeviceConfig != NULL ? *lpcbDeviceConfig : 0;

    *lpdwcb = dwcb;

    if (lpcbDeviceConfig != NULL)
    {
        *lpcbDeviceConfig = pLink->cbTapiBlob;
    }

    //
    // Return if the buffer is NULL or if
    // there is not enough room.
    //
    if (    (lpRasSubEntry == NULL )
        ||  (dwcbOrig < dwcb)
        ||  (   (lpbDeviceConfig != NULL)
            &&  (dwcbOrigDeviceConfig < pLink->cbTapiBlob)))
    {
        return ERROR_BUFFER_TOO_SMALL;
    }

    //
    // Set dwfFlags.
    //
    lpRasSubEntry->dwfFlags = 0;

    //
    // Copy primary phone number
    //
    pdtlnode = DtlGetFirstNode(pLink->pdtllistPhones);
    if (pdtlnode != NULL)
    {
        TCHAR *pszNum;

        pPhone = (PBPHONE *) DtlGetData(pdtlnode);

        pszNum = pPhone->pszPhoneNumber;

        ASSERT(pszNum);

        lstrcpyn(
          lpRasSubEntry->szLocalPhoneNumber,
          pszNum,
          RAS_MaxPhoneNumber + 1);
    }
    else
    {
        *lpRasSubEntry->szLocalPhoneNumber = TEXT('\0');
    }

    //
    // Copy the alternate phone numbers past the
    // end of the structure.
    //
    if (dwnAlternatePhoneNumbers)
    {
        PTCHAR pEnd = (PTCHAR)((ULONG_PTR)lpRasSubEntry
                              + sizeof (RASSUBENTRY));

        lpRasSubEntry->dwAlternateOffset = (DWORD)((ULONG_PTR) pEnd
                                         - (ULONG_PTR) lpRasSubEntry);

        for (pdtlnode = DtlGetNextNode(pdtlnode);
             pdtlnode != NULL;
             pdtlnode = DtlGetNextNode(pdtlnode))
        {
            TCHAR *pszNum;

            pPhone = (PBPHONE *) DtlGetData(pdtlnode);

            ASSERT(pPhone);

            pszNum = pPhone->pszPhoneNumber;

            ASSERT(pszNum);

            pszPhoneNumber = StrDup(pszNum);

            if(NULL == pszPhoneNumber)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            dwcbPhoneNumber = lstrlen(pszPhoneNumber);

            lstrcpyn(
                pEnd,
                pszPhoneNumber,
                (INT )(((PTCHAR )lpRasSubEntry + dwcbOrig) - pEnd));

            Free(pszPhoneNumber);

            pEnd += dwcbPhoneNumber + 1;
        }

        //
        // Add an extra NULL character to
        // terminate the list.
        //
        *pEnd = '\0';
    }
    else
    {
        lpRasSubEntry->dwAlternateOffset = 0;
    }

    //
    // Set device information.
    //
    switch (pLink->pbport.pbdevicetype)
    {
    case PBDT_Isdn:
        lstrcpyn(
            lpRasSubEntry->szDeviceType,
            RASDT_Isdn,
            sizeof(lpRasSubEntry->szDeviceType) / sizeof(WCHAR));

        break;

    case PBDT_X25:
        lstrcpyn(
            lpRasSubEntry->szDeviceType,
            RASDT_X25,
            sizeof(lpRasSubEntry->szDeviceType) / sizeof(WCHAR));

        break;

    case PBDT_Pad:
        lstrcpyn(
            lpRasSubEntry->szDeviceType,
            RASDT_Pad,
            sizeof(lpRasSubEntry->szDeviceType) / sizeof(WCHAR));

        break;

    case PBDT_Other:
    case PBDT_Irda:
    case PBDT_Vpn:
    case PBDT_Serial:
    case PBDT_Atm:
    case PBDT_Parallel:
    case PBDT_Sonet:
    case PBDT_Sw56:
    case PBDT_FrameRelay:
    case PBDT_PPPoE:
    {
        dwErr = GetRasmanDeviceType(
                    pLink,
                    lpRasSubEntry->szDeviceType);

        if (dwErr)
        {
            return dwErr;
        }

        //
        // Convert the device type to lower case
        // to be consistent with the predefined
        // types.
        //
        _tcslwr(lpRasSubEntry->szDeviceType);
        break;
    }
    default:
        lstrcpyn(
            lpRasSubEntry->szDeviceType,
            RASDT_Modem,
            sizeof(lpRasSubEntry->szDeviceType) / sizeof(WCHAR));

        break;

    }

    SetDevicePortNameFromLink(
                        pLink,
                        lpRasSubEntry->szDeviceName);

    //
    // Set the TAPI configuration blob.
    //
    if (    lpbDeviceConfig != NULL
        &&  dwcbOrigDeviceConfig <= pLink->cbTapiBlob)
    {
        memcpy(
            lpbDeviceConfig,
            pLink->pTapiBlob,
            pLink->cbTapiBlob);
    }

    return 0;
}


DWORD
RasSubEntryToPhonebookLink(
    PBENTRY*        pEntry,
    LPRASSUBENTRY   lpRasSubEntry,
    DWORD           dwcb,
    LPBYTE          lpbDeviceConfig,
    DWORD           dwcbDeviceConfig,
    PBLINK*         pLink
    )
{
    DWORD           dwErr, dwcbStr;
    DTLNODE         *pdtlnode;
    PBDEVICETYPE    pbdevicetype;
    DTLLIST         *pdtllistPorts;
    PBPORT          *pPort;
    WORD            i, cwDevices;
    RASMAN_DEVICE   *pDevices;
    TCHAR           szDeviceName[RAS_MaxDeviceName + 1];
    TCHAR           szPortName[MAX_PORT_NAME];
    PBPHONE         *pPhone;

    //
    // Get primary phone number.  Clear out any existing
    // numbers.
    //
    DtlDestroyList(pLink->pdtllistPhones, DestroyPhoneNode);

    pLink->pdtllistPhones = DtlCreateList(0);

    if (*lpRasSubEntry->szLocalPhoneNumber != TEXT('\0'))
    {
        //
        // The areacode/etc. will have to be
        // inherited from the entry properties.
        //
        pdtlnode = CreatePhoneNode();
        if (pdtlnode == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        pPhone = (PBPHONE *) DtlGetData(pdtlnode);

        pPhone->pszPhoneNumber = StrDup(
                            lpRasSubEntry->szLocalPhoneNumber
                            );

        if(NULL == pPhone->pszPhoneNumber)
        {
            //
            // .Net bug# 522164 RASAPI32: Memory leak in function
            // RasSubEntryToPhonebookLink
            //
            DestroyPhoneNode(pdtlnode);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        DtlAddNodeFirst(pLink->pdtllistPhones, pdtlnode);
    }

    //
    // Get the alternate phone numbers.
    //
    if (lpRasSubEntry->dwAlternateOffset)
    {
        PTCHAR pszPhoneNumber =
                    (PTCHAR)((ULONG_PTR)lpRasSubEntry
                    + lpRasSubEntry->dwAlternateOffset);

        while (*pszPhoneNumber != TEXT('\0'))
        {
            pdtlnode = CreatePhoneNode();

            if (pdtlnode == NULL)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            pPhone = (PBPHONE *) DtlGetData(pdtlnode);

            pPhone->pszPhoneNumber = StrDup(
                            pszPhoneNumber
                            );

            if(NULL == pPhone->pszPhoneNumber)
            {
                //
                // .Net bug# 522164 RASAPI32: Memory leak in function
                // RasSubEntryToPhonebookLink
                //
                DestroyPhoneNode(pdtlnode);
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            DtlAddNodeLast(pLink->pdtllistPhones, pdtlnode);

            pszPhoneNumber += lstrlen(pszPhoneNumber) + 1;
        }
    }

    //
    // Get device information.
    //
    dwErr = LoadPortsList(&pdtllistPorts);
    if (dwErr)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get the encoded device name/port
    // and check for a match.
    //
    GetDevicePortName(
        lpRasSubEntry->szDeviceName,
        szDeviceName, szPortName);

    pPort = PpbportFromPortAndDeviceName(
                pdtllistPorts,
                szPortName,
                ((szDeviceName[ 0 ]) ? szDeviceName : NULL) );

    if (pPort != NULL)
    {
        if (CopyToPbport(&pLink->pbport, pPort))
        {
            pPort = NULL;
        }
    }

    //
    // Search for a device name match.
    //
    if (pPort == NULL)
    {
        for (pdtlnode = DtlGetFirstNode(pdtllistPorts);
             pdtlnode != NULL;
             pdtlnode = DtlGetNextNode(pdtlnode))
        {
            PBPORT *pPortTmp = (PBPORT *)DtlGetData(pdtlnode);

            if (    pPortTmp->pszDevice != NULL
                &&  !lstrcmpi(pPortTmp->pszDevice, szDeviceName)
                &&  !CopyToPbport(&pLink->pbport, pPortTmp))
            {
                pPort = pPortTmp;
                break;
            }
        }
    }

    //
    // If we don't have a match, then
    // pick the first device of the
    // same type.
    //
    if (pPort == NULL)
    {
        pbdevicetype = PbdevicetypeFromPszType(
                            lpRasSubEntry->szDeviceType
                            );

        //
        // Initialize dwErr in case
        // we fall through the loop
        // without finding a match.
        //
        dwErr = ERROR_INVALID_PARAMETER;

        //
        // Look for a port with the same
        // device type.
        //
        for (pdtlnode = DtlGetFirstNode(pdtllistPorts);
             pdtlnode != NULL;
             pdtlnode = DtlGetNextNode(pdtlnode))
        {
            pPort = (PBPORT *)DtlGetData(pdtlnode);

            if (pPort->pbdevicetype == pbdevicetype)
            {
                dwErr = CopyToPbport(&pLink->pbport, pPort);

                //
                // If the device is a modem,
                // then set the default modem settings.
                //
                if (pbdevicetype == PBDT_Modem)
                {
                    SetDefaultModemSettings(pLink);
                }

                break;
            }
        }
    }

    DtlDestroyList(pdtllistPorts, DestroyPortNode);
    if (dwErr)
    {
        return dwErr;
    }

    //
    // Copy the TAPI configuration blob.
    //
    if (lpbDeviceConfig != NULL && dwcbDeviceConfig)
    {
        Free0(pLink->pTapiBlob);

        pLink->pTapiBlob = Malloc(dwcbDeviceConfig);

        if (pLink->pTapiBlob == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        memcpy(
            pLink->pTapiBlob,
            lpbDeviceConfig,
            dwcbDeviceConfig);

        pLink->cbTapiBlob = dwcbDeviceConfig;
    }

    //
    // Set dirty bit so this entry will get written out.
    //
    pEntry->fDirty = TRUE;

    return 0;
}


DWORD
RenamePhonebookEntry(
    IN PBFILE *ppbfile,
    IN LPCTSTR lpszOldEntry,
    IN LPCTSTR lpszNewEntry,
    IN DTLNODE *pdtlnode
    )
{
    DWORD dwErr;
    PBENTRY *pEntry = (PBENTRY *)DtlGetData(pdtlnode);

    //
    // Make sure the new entry name is valid.
    //
    if (!ValidateEntryName(lpszNewEntry))
    {
        return ERROR_INVALID_NAME;
    }

    //
    // Remove it from the list of phonebook entries.
    //
    DtlRemoveNode(ppbfile->pdtllistEntries, pdtlnode);

    //
    // Change the name and set the dirty bit.
    //
    DtlAddNodeLast(ppbfile->pdtllistEntries, pdtlnode);

    Free(pEntry->pszEntryName);

    pEntry->pszEntryName = StrDup(lpszNewEntry);

    pEntry->fDirty = TRUE;

    dwErr = DwSendRasNotification(ENTRY_RENAMED,
                                  pEntry,
                                  ppbfile->pszPath,
                                  NULL);

    return 0;
}


//Input password in lprasdialparams is in clear text
//
DWORD
SetEntryDialParamsUID(
    IN DWORD dwUID,
    IN DWORD dwMask,
    IN LPRASDIALPARAMS lprasdialparams,
    IN BOOL fDelete
    )
{
    DWORD dwErr = NO_ERROR;
    RAS_DIALPARAMS dialparams;

    //
    // Convert the rasapi32 dialparams to
    // rasman dialparams, taking into account
    // the version of the structure the user
    // has passed in.
    //
    dialparams.DP_Uid = dwUID;

    SafeEncodePasswordBuf(lprasdialparams->szPassword);

#ifdef UNICODE
    if (lprasdialparams->dwSize == sizeof (RASDIALPARAMSW_V351))
    {
        RASDIALPARAMSW_V351 *prdp =
                        (RASDIALPARAMSW_V351 *)lprasdialparams;
#else
    if (lprasdialparams->dwSize == sizeof (RASDIALPARAMSA_V351))
    {
        RASDIALPARAMSA_V351 *prdp =
                        (RASDIALPARAMSA_V351 *)lprasdialparams;
#endif
        strncpyTtoW(
            dialparams.DP_PhoneNumber,
            prdp->szPhoneNumber,
            sizeof(dialparams.DP_PhoneNumber) / sizeof(WCHAR));

        strncpyTtoW(
            dialparams.DP_CallbackNumber,
            prdp->szCallbackNumber,
            sizeof(dialparams.DP_CallbackNumber) / sizeof(WCHAR));

        strncpyTtoW(
            dialparams.DP_UserName,
            prdp->szUserName,
            sizeof(dialparams.DP_UserName) / sizeof(WCHAR));

        SafeDecodePasswordBuf(prdp->szPassword);

        strncpyTtoW(
            dialparams.DP_Password,
            prdp->szPassword,
            sizeof(dialparams.DP_Password) / sizeof(WCHAR));

        SafeEncodePasswordBuf(prdp->szPassword);
        SafeEncodePasswordBuf(dialparams.DP_Password);

        strncpyTtoW(
            dialparams.DP_Domain,
            prdp->szDomain,
            sizeof(dialparams.DP_Domain) / sizeof(WCHAR));
    }
    else
    {
        //
        // V400 and V401 structures only differ by the
        // the addition of the dwSubEntry field, which
        // we test below.
        //
        strncpyTtoW(
            dialparams.DP_PhoneNumber,
            lprasdialparams->szPhoneNumber,
            sizeof(dialparams.DP_PhoneNumber) / sizeof(WCHAR));

        strncpyTtoW(
            dialparams.DP_CallbackNumber,
            lprasdialparams->szCallbackNumber,
            sizeof(dialparams.DP_CallbackNumber) / sizeof(WCHAR));

        strncpyTtoW(
            dialparams.DP_UserName,
            lprasdialparams->szUserName,
            sizeof(dialparams.DP_UserName) / sizeof(WCHAR));

        SafeDecodePasswordBuf(lprasdialparams->szPassword);

        strncpyTtoW(
            dialparams.DP_Password,
            lprasdialparams->szPassword,
            sizeof(dialparams.DP_Password) / sizeof(WCHAR));

        SafeEncodePasswordBuf(lprasdialparams->szPassword);
        SafeEncodePasswordBuf(dialparams.DP_Password);

        strncpyTtoW(
            dialparams.DP_Domain,
            lprasdialparams->szDomain,
            sizeof(dialparams.DP_Domain) / sizeof(WCHAR));
    }

    if (lprasdialparams->dwSize == sizeof (RASDIALPARAMS))
    {
        dialparams.DP_SubEntry = lprasdialparams->dwSubEntry;
    }
    else
    {
        dialparams.DP_SubEntry = 1;
    }

     //
     // Set the dial parameters in rasman.
     //
    SafeDecodePasswordBuf(dialparams.DP_Password);
    
    dwErr = g_pRasSetDialParams(dwUID,
                               dwMask,
                               &dialparams,
                               fDelete);

    SafeWipePasswordBuf(dialparams.DP_Password);

    //Decode the input password as it was.
    SafeDecodePasswordBuf(lprasdialparams->szPassword);

    return dwErr;                               
}


DWORD
GetAsybeuiLana(
    IN  HPORT hport,
    OUT BYTE* pbLana )

/*++

Routine Description:

    Loads caller's '*pbLana' with the LANA associated with
    NBF or AMB connection on port 'hport' or 0xFF if none.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0 error code.
    Note that caller is trusted to pass only an 'hport'
    associated with AMB or NBF.

--*/

{
    DWORD         dwErr;
    RAS_PROTOCOLS protocols;
    DWORD         cProtocols = 0;
    DWORD         i;

    *pbLana = 0xFF;

    RASAPI32_TRACE("RasPortEnumProtocols");

    dwErr = g_pRasPortEnumProtocols(NULL,
                                    hport,
                                    &protocols,
                                    &cProtocols );

    RASAPI32_TRACE1("RasPortEnumProtocols done(%d)",
            dwErr);

    if (dwErr != 0)
    {
        return dwErr;
    }

    for (i = 0; i < cProtocols; ++i)
    {
        if (protocols.RP_ProtocolInfo[ i ].RI_Type == ASYBEUI)
        {
            *pbLana = protocols.RP_ProtocolInfo[ i ].RI_LanaNum;

            RASAPI32_TRACE1("bLana=%d", (INT)*pbLana);

            break;
        }
    }

    return 0;
}


DWORD
SubEntryFromConnection(
    IN LPHRASCONN lphrasconn
    )
{
    DWORD dwErr, dwSubEntry = 1;
    RASMAN_INFO info;

    if (IS_HPORT(*lphrasconn))
    {
        HPORT hport = HRASCONN_TO_HPORT(*lphrasconn);

        //
        // The HRASCONN passed in is actually a
        // rasman HPORT.  Get the subentry index
        // from rasman.
        //
        dwErr = g_pRasGetInfo(NULL,
                              hport,
                              &info);
        if (dwErr)
        {
            RASAPI32_TRACE1(
                "SubEntryFromConnection: RasGetInfo"
                " failed (dwErr=%d)",
                dwErr);

            *lphrasconn = (HRASCONN)NULL;

            return 0;
        }

        *lphrasconn = (HRASCONN)info.RI_ConnectionHandle;
        dwSubEntry = info.RI_SubEntry;
    }
    else
    {
        RASMAN_PORT *lpPorts;
        DWORD i, dwcbPorts, dwcPorts;

        //
        // Get the ports associated with the
        // connection.
        //
        dwcbPorts = dwcPorts = 0;
        dwErr = g_pRasEnumConnectionPorts(
                    NULL,
                    (HCONN)*lphrasconn,
                    NULL,
                    &dwcbPorts,
                    &dwcPorts);

        //
        // If there are no ports associated
        // with the connection then return
        // ERROR_NO_MORE_ITEMS.
        //
        if (    (   !dwErr
                &&  !dwcPorts)
            ||  dwErr != ERROR_BUFFER_TOO_SMALL)
        {
            return 0;
        }

        lpPorts = Malloc(dwcbPorts);
        if (lpPorts == NULL)
        {
            return 0;
        }

        dwErr = g_pRasEnumConnectionPorts(
                    NULL,
                    (HCONN)*lphrasconn,
                    lpPorts,
                    &dwcbPorts,
                    &dwcPorts);
        if (dwErr)
        {
            Free(lpPorts);
            return 0;
        }

        //
        // Get the subentry index for the port.
        //
        for (i = 0; i < dwcPorts; i++)
        {
            dwErr = g_pRasGetInfo(NULL,
                                  lpPorts[i].P_Handle,
                                  &info);

            if (    !dwErr
                &&  info.RI_ConnState == CONNECTED
                &&  info.RI_SubEntry)
            {
                dwSubEntry = info.RI_SubEntry;
                break;
            }
        }

        Free(lpPorts);
    }

    RASAPI32_TRACE2(
      "SubEntryFromConnection: "
      "hrasconn=0x%x, dwSubEntry=%d",
      *lphrasconn,
      dwSubEntry);

    return dwSubEntry;
}


DWORD
SubEntryPort(
    IN HRASCONN hrasconn,
    IN DWORD dwSubEntry,
    OUT HPORT *lphport
    )
{
    DWORD dwErr;
    DWORD i, dwcbPorts, dwcPorts;
    DWORD dwSubEntryMax = 0;
    RASMAN_PORT *lpPorts;
    RASMAN_INFO info;

    //
    // Verify parameters.
    //
    if (    lphport == NULL
        ||  !dwSubEntry)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get the ports associated with the
    // connection.
    //
    dwcbPorts = dwcPorts = 0;
    dwErr = g_pRasEnumConnectionPorts(
                NULL,
                (HCONN)hrasconn,
                NULL,
                &dwcbPorts,
                &dwcPorts);

    //
    // If there are no ports associated
    // with the connection then return
    // ERROR_NO_MORE_ITEMS.
    //
    if (    (   !dwErr
            &&  !dwcPorts)
        ||  dwErr != ERROR_BUFFER_TOO_SMALL)
    {
        return ERROR_NO_CONNECTION;
    }

    lpPorts = Malloc(dwcbPorts);
    if (lpPorts == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = g_pRasEnumConnectionPorts(
                NULL,
                (HCONN)hrasconn,
                lpPorts,
                &dwcbPorts,
                &dwcPorts);
    if (dwErr)
    {
        Free(lpPorts);
        return ERROR_NO_CONNECTION;
    }

    //
    // Enumerate the ports associated with
    // the connection to find the requested
    // subentry.
    //
    for (i = 0; i < dwcPorts; i++)
    {
        dwErr = g_pRasGetInfo(NULL,
                              lpPorts[i].P_Handle,
                              &info);
        if (dwErr)
        {
            continue;
        }

        //
        // Save the maximum subentry index.
        //
        if (info.RI_SubEntry > dwSubEntryMax)
        {
            dwSubEntryMax = info.RI_SubEntry;
        }

        if (info.RI_SubEntry == dwSubEntry)
        {
            *lphport = lpPorts[i].P_Handle;
            break;
        }
    }

    //
    // Free resources.
    //
    Free(lpPorts);

    if (info.RI_SubEntry == dwSubEntry)
    {
        return 0;
    }
    else if (dwSubEntry < dwSubEntryMax)
    {
        return ERROR_PORT_NOT_OPEN;
    }
    else
    {
        return ERROR_NO_MORE_ITEMS;
    }
}


VOID
CloseFailedLinkPorts()

/*++

Routine Description:

    Close any ports that are open but disconnected due to
    hardware failure or remote disconnection.  'pports'
    and 'cPorts' are the array and count of ports as
    returned by GetRasPorts.

Arguments:

Return Value:

--*/

{
    INT   i;
    DWORD dwErr;
    DWORD dwcPorts;
    RASMAN_PORT *pports = NULL, *pport;

    RASAPI32_TRACE("CloseFailedLinkPorts");

    dwErr = GetRasPorts(NULL, &pports, &dwcPorts);
    if (dwErr)
    {
        RASAPI32_TRACE1(
            "RasGetPorts failed (dwErr=%d)",
            dwErr);

        return;
    }

    for (i = 0, pport = pports; i < (INT )dwcPorts; ++i, ++pport)
    {
        RASAPI32_TRACE2(
            "Handle=%d, Status=%d",
            pport->P_Handle,
            pport->P_Status);

        if (pport->P_Status == OPEN)
        {
            RASMAN_INFO info;

            dwErr = g_pRasGetInfo(NULL,
                                  pport->P_Handle,
                                  &info );

            RASAPI32_TRACE5(
              "dwErr=%d, Handle=%d, ConnectionHandle=0x%x, "
              "ConnState=%d, DisconnectReason=%d",
              dwErr,
              pport->P_Handle,
              info.RI_ConnectionHandle,
              info.RI_ConnState,
              info.RI_DisconnectReason);

            if (!dwErr)
            {
                if (    info.RI_ConnState
                        == DISCONNECTED
                    &&  info.RI_ConnectionHandle
                        != (HCONN)NULL)
                {
                    RASCONNSTATE connstate;
                    DWORD dwSize = sizeof (connstate);

                    RASAPI32_TRACE1("Open disconnected port %d found",
                            pport->P_Handle);

                    dwErr = g_pRasGetPortUserData(
                              pport->P_Handle,
                              PORT_CONNSTATE_INDEX,
                              (PBYTE)&connstate,
                              &dwSize);

                    RASAPI32_TRACE2("dwErr=%d, connstate=%d",
                            dwErr, connstate);

                    if (    !dwErr
                        &&  dwSize == sizeof (RASCONNSTATE)
                        &&  (   connstate < RASCS_PrepareForCallback
                            ||  connstate > RASCS_WaitForCallback))
                    {
                        RASAPI32_TRACE1("RasPortClose(%d)...",
                                pport->P_Handle);

                        dwErr = g_pRasPortClose( pport->P_Handle );

                        RASAPI32_TRACE1("RasPortClose done(%d)",
                                dwErr);
                    }
                }
            }
        }
    }

    if (pports != NULL)
    {
        Free(pports);
    }

    RASAPI32_TRACE("CloseFailedLinkPorts done");
}


BOOL
GetCallbackNumber(
    IN RASCONNCB *prasconncb,
    IN PBUSER *ppbuser
    )
{
    DTLNODE *pdtlnode;
    CALLBACKINFO *pcbinfo;

    RASAPI32_TRACE("GetCallbackNumber");

    for (pdtlnode = DtlGetFirstNode(ppbuser->pdtllistCallback);
         pdtlnode != NULL;
         pdtlnode = DtlGetNextNode(pdtlnode))
    {
        BOOL fMatch;

        pcbinfo = DtlGetData(pdtlnode);
        ASSERT(pcbinfo);

        fMatch = FALSE;
        if (    pcbinfo->pszDeviceName != NULL
            &&  pcbinfo->pszPortName != NULL)
        {
            fMatch =
                (   !lstrcmpi(
                        pcbinfo->pszPortName,
                        prasconncb->szPortName)
                 && !lstrcmpi(
                        pcbinfo->pszDeviceName,
                        prasconncb->szDeviceName));
        }

        if (fMatch)
        {
            lstrcpyn(
              prasconncb->rasdialparams.szCallbackNumber,
              pcbinfo->pszNumber,
              sizeof(prasconncb->rasdialparams.szCallbackNumber) /
                sizeof(WCHAR));

            RASAPI32_TRACE1(
              "GetCallbackNumber: %S",
               prasconncb->rasdialparams.szCallbackNumber);

            return TRUE;
        }
    }

    RASAPI32_TRACE("GetCallbackNumber: not found!");
    return FALSE;
}


DWORD
SaveProjectionResults(
    IN RASCONNCB *prasconncb
    )
{
    DWORD dwErr;

    RASAPI32_TRACE2(
        "SaveProjectionResults: saving results "
        "(dwSubEntry=%d, nbf.dwError=%d)",
        prasconncb->rasdialparams.dwSubEntry,
        prasconncb->PppProjection.nbf.dwError);

    dwErr = g_pRasSetConnectionUserData(
              prasconncb->hrasconn,
              CONNECTION_PPPRESULT_INDEX,
              (PBYTE)&prasconncb->PppProjection,
              sizeof (prasconncb->PppProjection));
    if (dwErr)
    {
        return dwErr;
    }

    dwErr = g_pRasSetConnectionUserData(
              prasconncb->hrasconn,
              CONNECTION_AMBRESULT_INDEX,
              (PBYTE)&prasconncb->AmbProjection,
              sizeof (prasconncb->AmbProjection));

    if (dwErr)
    {
        return dwErr;
    }

    dwErr = g_pRasSetConnectionUserData(
              prasconncb->hrasconn,
              CONNECTION_SLIPRESULT_INDEX,
              (PBYTE)&prasconncb->SlipProjection,
              sizeof (prasconncb->SlipProjection));
    if (dwErr)
    {
        return dwErr;
    }

    return 0;
}


DWORD
LoadRasAuthDll()
{
    static BOOL fRasAuthDllLoaded = FALSE;

    if (fRasAuthDllLoaded)
    {
        return 0;
    }

    hinstAuth = LoadLibrary(TEXT("rascauth.dll"));
    if (hinstAuth == NULL)
    {
        return GetLastError();
    }

    if (
            (NULL == (g_pAuthCallback =
                (AUTHCALLBACK)GetProcAddress(
                                hinstAuth,
                                "AuthCallback")))

        ||  (NULL == (g_pAuthChangePassword =
                (AUTHCHANGEPASSWORD)GetProcAddress(
                                hinstAuth,
                                "AuthChangePassword")))

        ||  (NULL == (g_pAuthContinue =
                 (AUTHCONTINUE)GetProcAddress(
                                hinstAuth,
                                "AuthContinue")))

        ||  (NULL == (g_pAuthGetInfo =
                  (AUTHGETINFO)GetProcAddress(
                                hinstAuth,
                                "AuthGetInfo")))

        ||  (NULL == (g_pAuthRetry =
                  (AUTHRETRY)GetProcAddress(
                                hinstAuth,
                                "AuthRetry")))

        ||  (NULL == (g_pAuthStart =
                  (AUTHSTART)GetProcAddress(
                                hinstAuth,
                                "AuthStart")))
        ||  (NULL == (g_pAuthStop =
                (AUTHSTOP)GetProcAddress(
                                hinstAuth,
                                "AuthStop"))))
    {
        return GetLastError();
    }

    fRasAuthDllLoaded = TRUE;

    return 0;
}


DWORD
LoadRasScriptDll()
{
    static BOOL fRasScriptDllLoaded = FALSE;
    
    if (fRasScriptDllLoaded)
    {
        return 0;
    }

    hinstScript = LoadLibrary(TEXT("rasscrpt.dll"));

    if (hinstScript == NULL)
    {
        return GetLastError();
    }

    if (NULL == (g_pRasScriptExecute =
            (RASSCRIPTEXECUTE)GetProcAddress(
                                hinstScript,
                                "RasScriptExecute")))
    {
        return GetLastError();
    }

    fRasScriptDllLoaded = TRUE;
    return 0;
}


DWORD
LoadRasmanDllAndInit()
{
    if (FRasInitialized)
    {
        return 0;
    }

    RASAPI32_TRACE("LoadRasmanDll");
    if (LoadRasmanDll())
    {
        return GetLastError();
    }

    //
    // Success is returned if RasInitialize fails, in which
    // case none of the APIs will ever do anything but report
    // that RasInitialize failed.  All this is to avoid the
    // ugly system popup if RasMan service can't start.
    //
    if ((DwRasInitializeError = g_pRasInitialize()) != 0)
    {
        RASAPI32_TRACE1(
            "RasInitialize returned %d",
            DwRasInitializeError);

        return DwRasInitializeError;
    }

    FRasInitialized = TRUE;

    g_FRunningInAppCompatMode = FRunningInAppCompatMode();

    // pmay: 300166
    // 
    // We don't start rasauto automatically anymore. (win2k)
    //
    // pmay: 174997
    //
    // Due to several win9x app compat issues, we're enhancing
    // and re-enabling the rasauto service in whistler personal.
    //
    // pmay: 389988
    //
    // Ok take that back, it should not be started by our api's.
    // On personal sku, it should be auto-started.
    // Manually started elsewhere.
    //
    // g_pRasStartRasAutoIfRequired();

    return 0;
}

VOID
UnInitializeRAS()
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    FRasInitialized = FALSE;
}


VOID
UnloadDlls()
{
    if (hinstIpHlp != NULL)
    {
        FreeLibrary(hinstIpHlp);
        hinstIpHlp = NULL;
    }

    if (hinstAuth != NULL)
    {
        FreeLibrary(hinstAuth);
        hinstAuth = NULL;
    }

    if (hinstScript != NULL)
    {
        FreeLibrary(hinstScript);
        hinstScript = NULL;
    }

    if (hinstMprapi != NULL)
    {
        FreeLibrary(hinstMprapi);
        hinstMprapi = NULL;
    }
}

#define net_long(x) (((((unsigned long)(x))&0xffL)<<24) | \
                     ((((unsigned long)(x))&0xff00L)<<8) | \
                     ((((unsigned long)(x))&0xff0000L)>>8) | \
                     ((((unsigned long)(x))&0xff000000L)>>24))
/*++

Routine Description::

    Converts 'ipaddr' to a string in the a.b.c.d form and
    returns same in caller's 'pwszIpAddress' buffer.
    The buffer should be at least 16 wide characters long.

Arguments::

    dwIpAddress

    pwszIpAddress

Returns:

    None

--*/

VOID
ConvertIpAddressToString(
    IN DWORD    dwIpAddress,
    IN LPWSTR   pwszIpAddress
)
{
    WCHAR wszBuf[ 3 + 1 ];
    LONG  lNetIpaddr = net_long( dwIpAddress );

    LONG lA = (lNetIpaddr & 0xFF000000) >> 24;
    LONG lB = (lNetIpaddr & 0x00FF0000) >> 16;
    LONG lC = (lNetIpaddr & 0x0000FF00) >> 8;
    LONG lD = (lNetIpaddr & 0x000000FF);

    _ltow(lA, wszBuf, 10);
    wcsncpy(pwszIpAddress, wszBuf, 4);
    wcsncat(pwszIpAddress, L".", 2);

    _ltow(lB, wszBuf, 10);
    wcsncat(pwszIpAddress, wszBuf, 4);
    wcsncat(pwszIpAddress, L".", 2);

    _ltow(lC, wszBuf, 10);
    wcsncat(pwszIpAddress, wszBuf, 4);
    wcsncat(pwszIpAddress, L".", 2);

    _ltow(lD, wszBuf, 10);
    wcsncat(pwszIpAddress, wszBuf, 4);
}

/*++

Routine Description::

Arguments::

    bIpxAddress

    pwszIpxAddress

Returns:

    None

--*/
VOID
ConvertIpxAddressToString(
    IN PBYTE    bIpxAddress,
    IN LPWSTR   pwszIpxAddress
)
{
    _snwprintf(pwszIpxAddress,
             RAS_MaxIpxAddress + 1,
             TEXT("%2.2X%2.2X%2.2X%2.2X.%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X"),
             bIpxAddress[0],
             bIpxAddress[1],
             bIpxAddress[2],
             bIpxAddress[3],
             bIpxAddress[4],
             bIpxAddress[5],
             bIpxAddress[6],
             bIpxAddress[7],
             bIpxAddress[8],
             bIpxAddress[9]);
}

RASDEVICETYPE
GetDefaultRdt(DWORD dwType)
{
    RASDEVICETYPE rdt;

    switch(dwType)
    {
        case RASET_Phone:
        {
            rdt = RDT_Modem;
            break;
        }

        case RASET_Vpn:
        {
            rdt = RDT_Tunnel | RDT_Tunnel_Pptp;
            break;
        }
        case RASET_Direct:
        {
            rdt = RDT_Direct | RDT_Parallel;
            break;
        }

        default:
        {
            rdt = RDT_Other;
            break;
        }
    }

    return rdt;
}

DWORD
DwEnumEntriesFromPhonebook(
        LPCWSTR         lpszPhonebookPath,
        LPBYTE          lprasentryname,
        LPDWORD         lpcb,
        LPDWORD         lpcEntries,
        DWORD           dwSize,
        DWORD           dwFlags,
        BOOL            fViewInfo
        )
{
    DWORD   dwErr;
    PBFILE  pbfile;
    BOOL    fV351;
    DTLNODE *dtlnode;
    PBENTRY *pEntry;
    DWORD   dwInBufSize;

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError != 0)
    {
        return DwRasInitializeError;
    }

    ASSERT(NULL != lpszPhonebookPath);

    dwErr = ReadPhonebookFile(
              lpszPhonebookPath,
              NULL,
              NULL,
              RPBF_NoCreate,
              &pbfile);

    if (dwErr)
    {
        return ERROR_CANNOT_OPEN_PHONEBOOK;
    }

    fV351 = (   !fViewInfo
            &&  (dwSize == sizeof(RASENTRYNAMEW_V351)));

    *lpcEntries = 0;

    for (dtlnode = DtlGetFirstNode(pbfile.pdtllistEntries);
         dtlnode != NULL;
         dtlnode = DtlGetNextNode(dtlnode))
    {
        pEntry = (PBENTRY *)DtlGetData(dtlnode);

        ASSERT(pEntry);

        //
        // Skip the entry if this is a CM Type Entry and
        // the app is not compiled using nt50 or greater
        // ras headers. fViewInfo will be set only for
        // nt5
        //
        if(     RASET_Internet == pEntry->dwType
            &&  sizeof(RASENTRYNAMEW) != dwSize
            &&  !fViewInfo)
        {
            continue;
        }

        if (    !fV351
            ||  wcslen(pEntry->pszEntryName)
                <= RAS_MaxEntryName_V351)
        {
            ++(*lpcEntries);
        }
    }

    dwInBufSize = *lpcb;
    *lpcb       = *lpcEntries * dwSize;

    if (*lpcb > dwInBufSize)
    {
        dwErr = ERROR_BUFFER_TOO_SMALL;
        goto done;
    }

    for (dtlnode = DtlGetFirstNode(pbfile.pdtllistEntries);
         dtlnode != NULL;
         dtlnode = DtlGetNextNode(dtlnode))
    {
        pEntry = (PBENTRY *)DtlGetData(dtlnode);

        //
        // Skip the entry if this is a CM Type Entry and
        // the app is not compiled using nt50 or greater
        // ras headers
        //
        if(     RASET_Internet == pEntry->dwType
            &&  sizeof(RASENTRYNAMEW) != dwSize
            &&  !fViewInfo)
        {
            continue;
        }

        if (fV351)
        {
            RASENTRYNAMEW_V351* lprasentryname351 =
                (RASENTRYNAMEW_V351* )lprasentryname;

            lprasentryname351->dwSize = sizeof(RASENTRYNAMEW_V351);              

            //
            // Entries with names longer than expected are
            // discarded since these might not match the
            // longer entry at RasDial (if there was another
            // entry identical up to the truncation point).
            //
            if (wcslen(pEntry->pszEntryName)
                       <= RAS_MaxEntryName_V351)
            {
                lstrcpyn(lprasentryname351->szEntryName,
                         pEntry->pszEntryName,
                         sizeof(lprasentryname351->szEntryName) /
                             sizeof(WCHAR));
            }

            ++lprasentryname351;
            lprasentryname = (LPBYTE)lprasentryname351;
        }
        else if(!fViewInfo)
        {
            LPRASENTRYNAMEW lprasentrynamew =
                            (RASENTRYNAMEW *)lprasentryname;

            lprasentrynamew->dwSize = sizeof(RASENTRYNAMEW);                

            memset(
                lprasentrynamew->szEntryName,
                '\0',
                (RAS_MaxEntryName + 1) * sizeof (WCHAR));

            wcsncpy(
                lprasentrynamew->szEntryName,
                pEntry->pszEntryName,
                RAS_MaxEntryName);

            if(sizeof(RASENTRYNAMEW) == dwSize)
            {
                //
                // Also copy the phonebook path here
                //
                memset(
                    lprasentrynamew->szPhonebookPath,
                    '\0',
                    (MAX_PATH + 1) * sizeof (WCHAR));

                wcsncpy(
                    lprasentrynamew->szPhonebookPath,
                    lpszPhonebookPath,
                    MAX_PATH);

                //
                // Fill in the flags
                //
                lprasentrynamew->dwFlags = dwFlags;
            }

            if(sizeof(RASENTRYNAMEW_V401) == dwSize)
            {
                ((RASENTRYNAMEW_V401 *)
                lprasentryname) += 1;
            }
            else
            {
                ((RASENTRYNAMEW *)
                lprasentryname) += 1;
            }
        }
        else if(fViewInfo)
        {
            RASENUMENTRYDETAILS* pDetails =
                    (RASENUMENTRYDETAILS *)lprasentryname;

            dwErr = DwPbentryToDetails(
                        pEntry, 
                        lpszPhonebookPath,
                        !!(dwFlags & REN_AllUsers),
                        pDetails);
            if (dwErr != NO_ERROR)
            {
                break;
            }

            ((RASENUMENTRYDETAILS *) lprasentryname) += 1;
        }
    }

done:
    ClosePhonebookFile(&pbfile);
    return dwErr;
}

DWORD
DwEnumEntriesInDir(
    LPCTSTR     pszDirPath,
    DWORD       dwFlags,
    LPBYTE      lprasentryname,
    LPDWORD     lpcb,
    LPDWORD     lpcEntries,
    DWORD       dwSize,
    BOOL        fViewInfo
    )
{
    DWORD dwErr = SUCCESS;

    DWORD dwcEntries;

    DWORD dwcbLeft;

    TCHAR szFilePath[MAX_PATH + 1] = {0};

    WIN32_FIND_DATA wfdData;

    BOOL fFirstTime = TRUE;

    HANDLE hFindFile = INVALID_HANDLE_VALUE;

    BOOL fMem = FALSE;

    DWORD dwcb;

    ASSERT(lpcb);
    ASSERT(lpcEntries);
    ASSERT(lprasentryname);

    dwcbLeft    = *lpcb;
    *lpcb       = 0;
    *lpcEntries = 0;

    //
    // Enumerate entries in the phonebooks in this directory
    //
    while(SUCCESS == dwErr)
    {
        //
        // Whistler bug 292981 rasapi32.dll prefast warnings
        //
        if (!pszDirPath)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto done;
        }
        //
        // Append the filter to dir.
        //
        lstrcpyn(szFilePath, pszDirPath, sizeof(szFilePath) / sizeof(TCHAR));

        wcsncat(
            szFilePath,
            TEXT("*.pbk"),
            (sizeof(szFilePath) / sizeof(TCHAR)) - lstrlen(szFilePath));

        if(fFirstTime)
        {
            fFirstTime = FALSE;

            hFindFile = FindFirstFile(szFilePath,
                                      &wfdData);

            if(INVALID_HANDLE_VALUE == hFindFile)
            {
                dwErr = GetLastError();
            }
        }
        else
        {
            if(!FindNextFile(hFindFile,
                             &wfdData))
            {
                dwErr = GetLastError();
            }
        }

        if(     ERROR_NO_MORE_FILES == dwErr
            ||  ERROR_FILE_NOT_FOUND == dwErr
            ||  ERROR_PATH_NOT_FOUND == dwErr)
        {
            dwErr = SUCCESS;
            goto done;
        }
        else if(ERROR_SUCCESS != dwErr)
        {
            continue;
        }

        if(     FILE_ATTRIBUTE_DIRECTORY & wfdData.dwFileAttributes
            ||  (   REN_AllUsers == dwFlags
                &&  (CaseInsensitiveMatch(
                        wfdData.cFileName,
                        TEXT("router.pbk")) == TRUE)))
        {
            continue;
        }

        dwcb = dwcbLeft;

        //
        // Construct full path name to the pbk file
        //
        lstrcpyn(szFilePath, pszDirPath, sizeof(szFilePath) / sizeof(TCHAR));

        wcsncat(
            szFilePath,
            wfdData.cFileName,
            (sizeof(szFilePath) / sizeof(TCHAR)) - lstrlen(szFilePath));

        //
        // Enumerate all the entries from this
        // file
        //
        dwErr = DwEnumEntriesFromPhonebook(
                                    szFilePath,
                                    lprasentryname,
                                    &dwcb,
                                    &dwcEntries,
                                    dwSize,
                                    dwFlags,
                                    fViewInfo);
        if(     dwErr
            &&  ERROR_BUFFER_TOO_SMALL != dwErr)
        {
            goto done;
        }

        *lpcEntries += dwcEntries;
        *lpcb       += dwcb;

        if(ERROR_BUFFER_TOO_SMALL == dwErr)
        {
            fMem        = TRUE;
            dwcbLeft    = 0;
            dwErr       = SUCCESS;
        }
        else
        {
            (BYTE*)lprasentryname += (dwcEntries * dwSize);

            if(dwcbLeft > dwcb)
            {
                dwcbLeft -= dwcb;
            }
            else
            {
                dwcbLeft = 0;
            }
        }
    }

done:
    if(INVALID_HANDLE_VALUE != hFindFile)
    {
        FindClose(hFindFile);
    }

    if(     SUCCESS == dwErr
        &&  fMem)
    {
        dwErr = ERROR_BUFFER_TOO_SMALL;
    }

    return dwErr;
}


// 205217: (shaunco) Introduced this because we now enumerate REN_AllUsers
// phonebooks from two locations.  One is the "All Users" proflie which
// GetPhonebookDirectory(PBM_System) now returns; the other is the legacy
// %windir%\system32\ras directory.
//
DWORD
DwEnumEntriesForPbkMode(
    DWORD       dwFlags,
    LPBYTE      lprasentryname,
    LPDWORD     lpcb,
    LPDWORD     lpcEntries,
    DWORD       dwSize,
    BOOL        fViewInfo
    )
{
    BOOL  fMem = FALSE;
    DWORD dwErr = SUCCESS;
    DWORD dwcbLeft;
    DWORD dwcb;
    DWORD dwcEntries;
    TCHAR szDirPath[MAX_PATH + 1] = {0};

    ASSERT(lprasentryname);
    ASSERT(lpcb);
    ASSERT(lpcEntries);

    dwcbLeft    = *lpcb;
    *lpcb       = 0;
    *lpcEntries = 0;

    if(!GetPhonebookDirectory(
            (dwFlags & REN_AllUsers) ? PBM_System : PBM_Personal,
            szDirPath))
    {
        //
        // Treat this as no entries to enumerate.  Sometimes
        // we have problems enumerating the per-user directory.
        //
        dwErr = SUCCESS;
        goto done;
    }

    dwcb = dwcbLeft;
    dwErr = DwEnumEntriesInDir(szDirPath,
                               dwFlags,
                               lprasentryname,
                               &dwcb,
                               &dwcEntries,
                               dwSize,
                               fViewInfo);
    if(     dwErr
        &&  ERROR_BUFFER_TOO_SMALL != dwErr)
    {
        goto done;
    }

    *lpcEntries += dwcEntries;
    *lpcb       += dwcb;

    if(ERROR_BUFFER_TOO_SMALL == dwErr)
    {
        fMem        = TRUE;
        dwcbLeft    = 0;
        dwErr       = SUCCESS;
    }
    else
    {
        (BYTE*)lprasentryname += (dwcEntries * dwSize);

        if(dwcbLeft > dwcb)
        {
            dwcbLeft -= dwcb;
        }
        else
        {
            dwcbLeft = 0;
        }
    }

    // If for all users, handle the legacy %windir%\system32\ras directory.
    //
    if(dwFlags & REN_AllUsers)
    {
        UINT cch = GetSystemDirectory(szDirPath, MAX_PATH + 1);

        if (cch == 0 || cch > (MAX_PATH - (5 + 8 + 1 + 3)))
        {
            // Treat this as no entries to enumerate.  Return with
            // whatever dwErr is now.
            //
            goto done;
        }

        wcsncat(
            szDirPath,
            TEXT("\\Ras\\"),
            (sizeof(szDirPath) / sizeof(TCHAR)) - lstrlen(szDirPath));

        dwcb = dwcbLeft;
        dwErr = DwEnumEntriesInDir(szDirPath,
                                   dwFlags,
                                   lprasentryname,
                                   &dwcb,
                                   &dwcEntries,
                                   dwSize,
                                   fViewInfo);
        if(     dwErr
            &&  ERROR_BUFFER_TOO_SMALL != dwErr)
        {
            goto done;
        }

        *lpcEntries += dwcEntries;
        *lpcb       += dwcb;

        if(ERROR_BUFFER_TOO_SMALL == dwErr)
        {
            fMem        = TRUE;
            dwcbLeft    = 0;
            dwErr       = SUCCESS;
        }
    }

done:
    if(     SUCCESS == dwErr
        &&  fMem)
    {
        dwErr = ERROR_BUFFER_TOO_SMALL;
    }

    return dwErr;
}

DWORD
DwCustomHangUp(
    CHAR *      lpszPhonebook,
    CHAR *      lpszEntryName,
    HRASCONN    hRasconn)
{
    DWORD       dwErr       = ERROR_SUCCESS;
    HINSTANCE   hInstDll    = NULL;
    BOOL        fCustomDll;
    RASENTRY    re          = {0};
    DWORD       dwSize;
    TCHAR*      szPhonebookPath = NULL;
    TCHAR*      szEntryName = NULL;
    TCHAR       *pszExpandedPath = NULL;

    RasCustomHangUpFn pfnRasCustomHangUp = NULL;

    RASAPI32_TRACE("DwCustomHangUp..");

    ASSERT(NULL != lpszPhonebook);
    ASSERT(NULL != lpszEntryName);

    // XP 339346
    //
    szPhonebookPath = (TCHAR*) Malloc((MAX_PATH + 1) * sizeof(TCHAR));
    szEntryName = (TCHAR*) Malloc((MAX_ENTRYNAME_SIZE + 1) * sizeof(TCHAR));
    if ((!szPhonebookPath) || (!szEntryName))
    {
        goto done;
    }

    strncpyAtoT(szPhonebookPath,
               lpszPhonebook,
               MAX_PATH + 1);

    strncpyAtoT(szEntryName,
               lpszEntryName,
               MAX_ENTRYNAME_SIZE + 1);

    //
    // Get the DllName
    //
    re.dwSize = dwSize = sizeof(RASENTRY);

    dwErr = RasGetEntryProperties(
                        szPhonebookPath,
                        szEntryName,
                        &re,
                        &dwSize,
                        NULL,
                        NULL);

    if(ERROR_SUCCESS != dwErr)
    {
        goto done;
    }

    ASSERT(TEXT('\0') != re.szCustomDialDll[0]);

    dwErr = DwGetExpandedDllPath(re.szCustomDialDll,
                                 &pszExpandedPath);

    if(ERROR_SUCCESS != dwErr)
    {
        goto done;
    }

    //
    // Load the Custom Dll
    //
    if(     NULL == (hInstDll = LoadLibrary(pszExpandedPath))
        ||  NULL == (pfnRasCustomHangUp =
                        (RasCustomHangUpFn) GetProcAddress(
                                            hInstDll,
                                            "RasCustomHangUp"
                                            )))
    {
        dwErr = GetLastError();
        goto done;
    }

    ASSERT(NULL != pfnRasCustomHangUp);

    dwErr = (pfnRasCustomHangUp) (hRasconn);

done:
    Free0(szPhonebookPath);
    Free0(szEntryName);

    if(NULL != hInstDll)
    {
        FreeLibrary(hInstDll);
    }

    if(NULL != pszExpandedPath)
    {
        LocalFree(pszExpandedPath);
    }

    RASAPI32_TRACE1("DwCustomHangUp done. %d",
            dwErr);

    return dwErr;
}

DWORD
DwCustomDial(LPRASDIALEXTENSIONS lpExtensions,
             LPCTSTR             lpszPhonebook,
             CHAR                *pszSysPbk,
             LPRASDIALPARAMS     prdp,
             DWORD               dwNotifierType,
             LPVOID              pvNotifier,
             HRASCONN            *phRasConn)
{

    RasCustomDialFn pfnCustomDial     = NULL;
    DWORD           dwErr             = SUCCESS;
    CHAR            *pszPhonebookA    = NULL;
    CHAR            *pszEntryNameA    = NULL;
    HINSTANCE       hInstDll          = NULL;
    DWORD           dwFlags           = 0;

    //
    // Get the custom dial function
    //
    dwErr = DwGetCustomDllEntryPoint((LPTSTR) lpszPhonebook,
                                     prdp->szEntryName,
                                     NULL,
                                     (FARPROC *) &pfnCustomDial,
                                     &hInstDll,
                                     CUSTOM_RASDIAL,
                                     NULL);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    dwErr = DwGetEntryMode((LPTSTR) lpszPhonebook,
                           prdp->szEntryName,
                           NULL,
                           &dwFlags);

    if(ERROR_SUCCESS != dwErr)
    {
        goto done;
    }

    //
    // Make the function call
    //
    dwErr = pfnCustomDial(hInstDll,
                          lpExtensions,
                          lpszPhonebook,
                          prdp,
                          dwNotifierType,
                          pvNotifier,
                          phRasConn,
                          dwFlags);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    if(lpszPhonebook)
    {
        pszPhonebookA = strdupTtoA(lpszPhonebook);
    }
    else
    {
        pszPhonebookA = pszSysPbk;
    }

    pszEntryNameA = strdupTtoA(prdp->szEntryName);

    if(     NULL == pszPhonebookA
        ||  NULL == pszEntryNameA)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    //
    // Custom Rasdial succeeded. Mark the connection
    // in rasman.
    //
    dwErr = g_pRasReferenceCustomCount((HCONN) NULL,
                                       TRUE,
                                       pszPhonebookA,
                                       pszEntryNameA,
                                       NULL);

done:

    if(NULL != pszPhonebookA)
    {
        Free(pszPhonebookA);
    }

    if(NULL != pszEntryNameA)
    {
        Free(pszEntryNameA);
    }

    return dwErr;
}

// Marks the default internet connection in a group of phonebook
// entries.
//
DWORD
DwMarkDefaultInternetConnnection(
    LPRASENUMENTRYDETAILS pEntries, 
    DWORD dwCount)
{
    DWORD dwErr = NO_ERROR, i, dwAdCount = 1, dwAdSize;
    RASAUTODIALENTRY adEntry;

    ZeroMemory(&adEntry, sizeof(adEntry));
    adEntry.dwSize = sizeof(adEntry);
    
    do
    {
        dwAdCount = 1;
        dwAdSize = sizeof(adEntry);
        dwErr = RasGetAutodialAddress(
                    NULL,
                    NULL,
                    &adEntry,
                    &dwAdSize,
                    &dwAdCount);
                    
        if (dwErr != NO_ERROR)
        {
            break;
        }

        for (i = 0; i < dwCount; i++)
        {
            // Initialize the flags to zero -- bug 247151
            //
            pEntries[i].dwFlagsPriv = 0;
        }

        for (i = 0; i < dwCount; i++)
        {
            // Mark the default internet connection if found
            //
            if (wcsncmp(
                    pEntries[i].szEntryName, 
                    adEntry.szEntry, 
                    sizeof(pEntries[i].szEntryName) / sizeof(WCHAR)) == 0)
            {
                pEntries[i].dwFlagsPriv |= REED_F_Default;
                break;
            }
        }
                    
    } while (FALSE);

    return dwErr;
}

// 
// Rename the default internet connection as appropriate
//
DWORD 
DwRenameDefaultConnection(
    LPCWSTR lpszPhonebook,
    LPCWSTR lpszOldEntry,
    LPCWSTR lpszNewEntry)
{
    RASAUTODIALENTRYW adEntry;
    DWORD dwErr = NO_ERROR, dwCount = 0, dwCb = 0;

    // Initialize
    //
    ZeroMemory(&adEntry, sizeof(adEntry));
    adEntry.dwSize = sizeof(adEntry);
    dwCb = sizeof(adEntry);
    dwCount = 1;

    do
    {
        // Discover the current default internet connection
        //
        dwErr = RasGetAutodialAddressW(
                    NULL,
                    NULL,
                    &adEntry,
                    &dwCb,
                    &dwCount);
        if (dwErr != NO_ERROR) 
        {
            break;
        }
        if ((dwCb != sizeof(adEntry)) ||
            (dwCount != 1))
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // Validate parameters and see if there is a match in the 
        // default connection name
        //
        if (lstrcmpi(lpszOldEntry, adEntry.szEntry))
        {
            // Not the default internet connection that is 
            // changing.  Return success.
            //
            break;
        }

        // So, we are changing the default connection.  
        //
        wcsncpy(
            adEntry.szEntry, 
            lpszNewEntry, 
            sizeof(adEntry.szEntry) / sizeof(WCHAR));
        dwErr = RasSetAutodialAddressW(
                    NULL,
                    0,
                    &adEntry,
                    sizeof(adEntry),
                    1);
    
    } while (FALSE);

    return dwErr;
}

DWORD APIENTRY
DwEnumEntryDetails(
    IN     LPCWSTR               lpszPhonebookPath,
    OUT    LPRASENUMENTRYDETAILS lprasentryname,
    IN OUT LPDWORD               lpcb,
    OUT    LPDWORD               lpcEntries )
{
    DWORD    dwErr = ERROR_SUCCESS;
    PBFILE   pbfile;
    DTLNODE  *dtlnode;
    PBENTRY  *pEntry;
    DWORD    dwInBufSize;
    BOOL     fStatus;
    DWORD    cEntries;
    DWORD    dwSize;
    LPRASENUMENTRYDETAILS pEntriesOrig = lprasentryname;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("DwEnumEntryDetails");

    if (!lpcb)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    !lprasentryname
        || (    lprasentryname->dwSize
                != sizeof(RASENUMENTRYDETAILS)))
    {
        return ERROR_INVALID_SIZE;
    }

    if (!lpcEntries)
    {
        lpcEntries = &cEntries;
    }

    dwSize = lprasentryname->dwSize;

    if(lpszPhonebookPath)
    {
        dwErr = DwEnumEntriesFromPhonebook(
                                lpszPhonebookPath,
                                (LPBYTE) lprasentryname,
                                lpcb,
                                lpcEntries,
                                dwSize,
                                (IsPublicPhonebook(
                                    (TCHAR *)lpszPhonebookPath)
                                ? REN_AllUsers
                                : REN_User),
                                TRUE);
        goto done;
    }
    else
    {
        DWORD   dwcb      = *lpcb;
        DWORD   dwcEntries;
        DWORD   dwcbLeft  = *lpcb;

        DWORD   dwErrSav  = SUCCESS;

        *lpcb       = 0;
        *lpcEntries = 0;

        //
        // Enumerate entries from all pbk files in
        // All Users
        //
        dwErr = DwEnumEntriesForPbkMode(REN_AllUsers,
                                        (LPBYTE) lprasentryname,
                                        &dwcb,
                                        &dwcEntries,
                                        dwSize,
                                        TRUE);

        if(     dwErr
            &&  ERROR_BUFFER_TOO_SMALL != dwErr)
        {
            goto done;
        }

        if(ERROR_BUFFER_TOO_SMALL == dwErr)
        {
            dwErrSav = dwErr;
            dwcbLeft = 0;
        }
        else
        {
            ((RASENUMENTRYDETAILS *)
            lprasentryname) += dwcEntries;

            dwcbLeft -= ((dwcbLeft >= dwcb) ? dwcb : 0);
        }

        *lpcb += dwcb;
        dwcb = dwcbLeft;

        if(lpcEntries)
        {
            *lpcEntries = dwcEntries;
        }

        dwcEntries = 0;

        //
        // Enumerate entries from all pbk files in
        // users profile
        //
        dwErr = DwEnumEntriesForPbkMode(REN_User,
                                        (LPBYTE) lprasentryname,
                                        &dwcb,
                                        &dwcEntries,
                                        dwSize,
                                        TRUE);
        if(     dwErr
            &&  ERROR_BUFFER_TOO_SMALL != dwErr)
        {
            goto done;
        }
        else if (SUCCESS == dwErr)
        {
            dwErr = dwErrSav;
        }

        *lpcb += dwcb;

        if(lpcEntries)
        {
            *lpcEntries += dwcEntries;
        }

        if(NO_ERROR == dwErr)
        {
            // Mark the default internet connection.  Ignore the error
            // return here, it's non-critical
            //
            // .Net bug# 513844 new verbose RASAPI32 prefast warnings
            //
            DwMarkDefaultInternetConnnection(
                pEntriesOrig,
                lpcEntries ? *lpcEntries : 0);
        }
    }

done:
    RASAPI32_TRACE1("DwEnumEntryDetails done. %d", dwErr);
    return dwErr;
}

DWORD APIENTRY
DwCloneEntry(LPCWSTR lpwszPhonebookPath,
             LPCWSTR lpwszSrcEntryName,
             LPCWSTR lpwszDstEntryName)
{
    DWORD dwErr = ERROR_SUCCESS;
    DTLNODE *pdtlnodeSrc = NULL;
    DTLNODE *pdtlnodeDst = NULL;
    PBFILE  pbfile;
    PBENTRY *pEntry;
    BOOL    fPhonebookOpened = FALSE;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Make some rudimentary parameter validation
    //
    if(     (NULL == lpwszSrcEntryName)
        ||  (NULL == lpwszDstEntryName)
        ||  (0 == lstrcmpi(lpwszSrcEntryName, lpwszDstEntryName)))

    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    //
    // Things are good. So open the phonebookfile and get the
    // src entry
    //
    dwErr = GetPbkAndEntryName(
                    lpwszPhonebookPath,
                    lpwszSrcEntryName,
                    RPBF_NoCreate,
                    &pbfile,
                    &pdtlnodeSrc);

    if(ERROR_SUCCESS != dwErr)
    {
        goto done;
    }

    fPhonebookOpened = TRUE;

    pdtlnodeDst = CloneEntryNode(pdtlnodeSrc);

    if(NULL == pdtlnodeDst)
    {
        dwErr = E_OUTOFMEMORY;
        goto done;
    }

    //
    // Change the entryname to the new entryname and
    // save the node in the phonebook
    //
    pEntry = (PBENTRY *) DtlGetData(pdtlnodeDst);

    ASSERT(NULL != pEntry);

    Free0(pEntry->pszEntryName);

    pEntry->pszEntryName = StrDup((LPCTSTR) lpwszDstEntryName);

    if(NULL == pEntry->pszEntryName)
    {
        dwErr = E_OUTOFMEMORY;
        goto done;
    }

    //
    // Add the entry to the file
    //
    DtlAddNodeLast(pbfile.pdtllistEntries, pdtlnodeDst);

    //
    // Dirty the entry and write the phonebook file
    //
    pEntry->fDirty = TRUE;

    WritePhonebookFile(&pbfile, NULL);

    dwErr = DwSendRasNotification(
                ENTRY_ADDED,
                pEntry,
                pbfile.pszPath,
                NULL);

done:

    if(fPhonebookOpened)
    {
        ClosePhonebookFile(&pbfile);
    }

    return dwErr;
}

void
EnumEntryHeaderCallback(PBFILE *pFile, void *pvContext)
{
    struct s_EntryHeaderContext
    {
        DWORD cEntries;
        DWORD dwSize;
        RASENTRYHEADER *pRasEntryHeader;
    } *pEntryHeader = (struct s_EntryHeaderContext *) pvContext;

    DTLNODE *pdtlnode;

    RASENTRYHEADER *pEntryBuffer = pEntryHeader->pRasEntryHeader;

    if(NULL == pFile)
    {
        goto done;
    }

    //
    // Run through all the entries in the phonebook and fill
    // in the EntryHeader structure
    //
    for (pdtlnode = DtlGetFirstNode(pFile->pdtllistEntries);
         pdtlnode != NULL;
         pdtlnode = DtlGetNextNode(pdtlnode))
    {
        pEntryHeader->cEntries += 1;

        if(pEntryHeader->dwSize >=
            (pEntryHeader->cEntries * sizeof(RASENTRYHEADER)))
        {

            CopyMemory(
                &pEntryBuffer[pEntryHeader->cEntries - 1],
                DtlGetData(pdtlnode),
                sizeof(RASENTRYHEADER));
        }
    }

done:
    return;

}


DWORD APIENTRY
DwEnumEntriesForAllUsers(
            DWORD *lpcb,
            DWORD *lpcEntries,
            RASENTRYHEADER * pRasEntryHeader)
{
    DWORD dwErr = SUCCESS;
    DWORD dwSize = 0;
    WCHAR szPbkPath[MAX_PATH + 1];


    struct s_EntryHeaderContext
    {
        DWORD cEntries;
        DWORD dwSize;
        RASENTRYHEADER *pRasEntryHeader;
    } EntryHeader;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if(     (NULL == lpcb)
        ||  (NULL == lpcEntries))
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    ZeroMemory(szPbkPath, sizeof(szPbkPath));

    if(!GetPhonebookDirectory(PBM_System, szPbkPath))
    {
        dwErr = ERROR_CANNOT_OPEN_PHONEBOOK;
        goto done;
    }

    ZeroMemory(&EntryHeader, sizeof(EntryHeader));

    EntryHeader.pRasEntryHeader = pRasEntryHeader;
    EntryHeader.dwSize = *lpcb;

    //
    // Enumerate entries from All Users dir
    //
    dwErr = DwEnumeratePhonebooksFromDirectory(
                szPbkPath,
                RPBF_HeaderType,
                (PBKENUMCALLBACK) EnumEntryHeaderCallback,
                &EntryHeader);

    if(SUCCESS != dwErr)
    {
        RASAPI32_TRACE1("Failed to enumerate from AllUsers pbk. rc=0x%x",
               dwErr);
    }

    ZeroMemory(szPbkPath, sizeof(szPbkPath));

    if(     (0 == (dwSize = GetSystemDirectory(szPbkPath, 
                            (sizeof(szPbkPath)/sizeof(WCHAR)))
                    ))
        ||  (dwSize * sizeof(WCHAR) > sizeof(szPbkPath)))
    {
        dwErr = ERROR_CANNOT_OPEN_PHONEBOOK;
        goto done;
    }

    wcsncat(
        szPbkPath,
        TEXT("\\Ras\\"),
        (sizeof(szPbkPath) / sizeof(WCHAR)) - lstrlen(szPbkPath));

    dwErr = DwEnumeratePhonebooksFromDirectory(
                szPbkPath,
                RPBF_HeaderType,
                (PBKENUMCALLBACK) EnumEntryHeaderCallback,
                &EntryHeader);

    *lpcEntries = EntryHeader.cEntries;

    if(*lpcb < EntryHeader.cEntries * sizeof(RASENTRYHEADER))
    {
        dwErr = ERROR_BUFFER_TOO_SMALL;
    }

    *lpcb = (EntryHeader.cEntries * sizeof(RASENTRYHEADER));

done:
    return dwErr;
}


DWORD
DwDeleteSubEntry(
    LPCWSTR lpszPhonebook,
    LPCWSTR lpszEntry,
    DWORD dwSubEntryId
    )
{
    DWORD dwErr = SUCCESS;
    DTLNODE *pdtlnode = NULL;
    PBFILE pbfile;
    DWORD dwSubEntries = 0;
    PBENTRY *pEntry = NULL;
    PBLINK *pLink = NULL;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if(     (NULL == lpszEntry)
        ||  (0 == dwSubEntryId))
    {
        RASAPI32_TRACE("DwDeleteSubEntry: invalid entryid or entryname specified");
        return E_INVALIDARG;
    }

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        RASAPI32_TRACE1("DwDeleteSubEntry: failed to init rasman. 0x%x",
                dwErr);
        return dwErr;
    }
    
    ZeroMemory(&pbfile, sizeof(pbfile));
    pbfile.hrasfile = -1;

    dwErr = GetPbkAndEntryName(
                lpszPhonebook,
                lpszEntry,
                0,
                &pbfile,
                &pdtlnode);

    if(     (ERROR_SUCCESS != dwErr)
        ||  (NULL == pdtlnode))
    {
        RASAPI32_TRACE("DwDeleteSubEntry: Entry not found");
        if(ERROR_SUCCESS == dwErr)
        {
            dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
        }
        goto done;
    }

    pEntry = (PBENTRY *) DtlGetData(pdtlnode);

    ASSERT(pEntry);

    dwSubEntries = DtlGetNodes(pEntry->pdtllistLinks);

    if(     (1 < dwSubEntries)
        &&  (dwSubEntryId <= dwSubEntries))
    {
        pdtlnode = DtlNodeFromIndex(
                        pEntry->pdtllistLinks,
                        dwSubEntryId - 1);

        if(NULL == pdtlnode)
        {
            RASAPI32_TRACE("DwDeleteSubEntry: subentry not found");
            dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
            goto done;
        }

        //
        // Found the link. Remove it from the list of links
        //
        pdtlnode = DtlRemoveNode(pEntry->pdtllistLinks,
                                 pdtlnode);

        ASSERT(pdtlnode);

        DtlDestroyNode(pdtlnode);

        pEntry->fDirty = TRUE;

        dwErr = WritePhonebookFile(&pbfile,NULL);
    }
    else
    {
        RASAPI32_TRACE1("DwDeletSubEntry: invalid subentry specified. %d",
              dwSubEntryId);

        dwErr = E_INVALIDARG;
    }

done:

    ClosePhonebookFile(&pbfile);

    RASAPI32_TRACE1("DwDeleteSubEntry done. 0x%x", dwErr);

    return dwErr;    
}

DWORD
DwRasUninitialize()
{
    DWORD dwErr = ERROR_SUCCESS;

    dwErr = RasmanUninitialize();

    FRasInitialized = FALSE;

    return dwErr;
}

//
// Prefast warns us that performing case-insensitive comparisions should always
// use CompareString for const's: Prefast Error 400-Using <function> to perform
// a case-insensitive compare to constant <string> will give unexpected results
// in non-English locales.
//
BOOL
CaseInsensitiveMatch(
    IN LPCWSTR pszStr1,
    IN LPCWSTR pszStr2
    )
{
    return (CompareString(
                LOCALE_INVARIANT,
                NORM_IGNORECASE,
                pszStr1,
                -1,
                pszStr2,
                -1) == CSTR_EQUAL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\debug.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** debug.h
** Debug and tracing macros
**
** 08/24/95 Steve Cobb
**
** To use TRACE/DUMP:
**
**     These calls encapsulate dynamically linking to the tracing utilities in
**     RTUTIL.DLL and provide shortcut macros to access them and to prevent
**     their inclusion in non-DBG builds.
**
**     Before calling any TRACE/DUMP macros call:
**         DEBUGINIT( "YOURMODULE" );
**
**     Use the TRACEx and DUMPx macros to print messages to the log as defined
**     by the associated RTUTIL.DLL routines.  Currently, this code is removed
**     from non-DBG builds.  A few examples:
**
**       TRACE("MyRoutine");
**       TRACE2("MyRoutine=%d,c=%s",dwErr,psz);
**
**     After done calling TRACE/DUMP macros call:
**         DEBUGTERM();
**
**     Exactly one file should have define the debug globals with the
**     following while all other files should include the header without
**     defining the manifest.
**
**         #define DEBUGGLOBALS
**         #include <debug.h>
**
**     Static libraries can safely use TRACE/DUMP without calling DEBUGINIT
**     and DEBUGTERM or defining DEBUGGLOBALS.  If the caller sets up these in
**     his module, the library trace will appear as part of caller's module
**     trace.
**
** To use ASSERT:
**
**     Use ASSERT to assert that a given expression is true, popping up a
**     dialog indicating the file and line number of the ASSERTION if it
**     fails.  It is not necessary to call DEBUGINIT and DEBUGTERM to use
**     ASSERT.  For example:
**
**         hwndOwner = GetParent( hwnd );
**         ASSERT(hwndOwner!=NULL);
*/

#ifndef _DEBUG_H_
#define _DEBUG_H_


#define FREETRACE 1


/*----------------------------------------------------------------------------
** Datatypes and global declarations (defined in debug.c)
**----------------------------------------------------------------------------
*/

#if (DBG || FREETRACE)

extern DWORD g_dwTraceId;

typedef DWORD (APIENTRY * TRACEREGISTEREXA)( LPCSTR, DWORD );
extern TRACEREGISTEREXA g_pTraceRegisterExA;

typedef DWORD (APIENTRY * TRACEDEREGISTERA)( DWORD );
extern TRACEDEREGISTERA g_pTraceDeregisterA;

typedef DWORD (APIENTRY * TRACEDEREGISTEREXA)( DWORD, DWORD );
extern TRACEDEREGISTEREXA g_pTraceDeregisterExA;

typedef DWORD (APIENTRY * TRACEPRINTFA)( DWORD, LPCSTR, ... );
extern TRACEPRINTFA g_pTracePrintfA;

typedef DWORD (APIENTRY * TRACEPRINTFEXA)( DWORD, DWORD, LPCSTR, ... );
extern TRACEPRINTFEXA g_pTracePrintfExA;

typedef DWORD (APIENTRY * TRACEDUMPEXA)( DWORD, DWORD, LPBYTE, DWORD, DWORD, BOOL, LPCSTR );
extern TRACEDUMPEXA g_pTraceDumpExA;

#endif // (DBG || FREETRACE)


/*----------------------------------------------------------------------------
** Macros
**----------------------------------------------------------------------------
*/

/* Debug macros.  This code does not appear in non-DBG builds unless FREETRACE
** is defined.
**
** The trailing number indicates the number of printf arguments in the format
** string.  TRACEW1 accepts a format string containing a single WCHAR*
** argument.  The argument is converted before output so that the output file
** remains entirely ANSI.
*/
#if (DBG || FREETRACE)

#define TRACE(a) \
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a)
#define TRACE1(a,b) \
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a,b)
#define TRACE2(a,b,c) \
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a,b,c)
#define TRACE3(a,b,c,d)\
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a,b,c,d)
#define TRACE4(a,b,c,d,e) \
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a,b,c,d,e)
#define TRACE5(a,b,c,d,e,f) \
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a,b,c,d,e,f)
#define TRACE6(a,b,c,d,e,f,g) \
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a,b,c,d,e,f,g)
#define TRACEX(l,a) \
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a)
#define TRACEX1(l,a,b) \
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a,b)
#define TRACEX2(l,a,b,c) \
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a,b,c)
#define TRACEX3(l,a,b,c,d)\
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a,b,c,d)
#define TRACEX4(l,a,b,c,d,e) \
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a,b,c,d,e)
#define TRACEX5(l,a,b,c,d,e,f) \
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a,b,c,d,e,f)
#define TRACEX6(l,a,b,c,d,e,f,h) \
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a,b,c,d,e,f,h)
#define TRACE_ID(id,a) \
            if (id != -1) g_pTracePrintfA(id,a)
#define TRACE_ID1(id,a,b) \
            if (id != -1) g_pTracePrintfA(id,a,b)
#define TRACE_ID2(id,a,b,c) \
            if (id != -1) g_pTracePrintfA(id,a,b,c)
#define TRACE_ID3(id,a,b,c,d)\
            if (id != -1) g_pTracePrintfA(id,a,b,c,d)
#define TRACE_ID4(id,a,b,c,d,e) \
            if (id != -1) g_pTracePrintfA(id,a,b,c,d,e)
#define TRACE_ID5(id,a,b,c,d,e,f) \
            if (id != -1) g_pTracePrintfA(id,a,b,c,d,e,f)
#define TRACE_ID6(id,a,b,c,d,e,f,h) \
            if (id != -1) g_pTracePrintfA(id,a,b,c,d,e,f,h)
#define TRACEW1(a,b) \
            if (g_dwTraceId!=-1) TracePrintfW1(a,b)
#define DUMPB(p,c) \
            if (g_dwTraceId!=-1) g_pTraceDumpExA(g_dwTraceId,1,(LPBYTE)p,c,1,1,NULL)
#define DUMPDW(p,c) \
            if (g_dwTraceId!=-1) g_pTraceDumpExA(g_dwTraceId,1,(LPBYTE)p,c,4,1,NULL)
#if defined(ASSERT)
#undef ASSERT
#endif

#if defined(ASSERTMSG)
#undef ASSERTMSG
#endif

#if DBG
#define ASSERT(a) \
            if (!(a)) Assert(#a,__FILE__,__LINE__)

#define ASSERTMSG(a) \
            Assert(#a, __FILE__,__LINE__)
#else
#define ASSERT(a)
#define ASSERTMSG(a)
#endif

#define DEBUGINIT(s) \
            DebugInit(s)
#define DEBUGTERM() \
            DebugTerm()

#else

#define TRACE(a)
#define TRACE1(a,b)
#define TRACE2(a,b,c)
#define TRACE3(a,b,c,d)
#define TRACE4(a,b,c,d,e)
#define TRACE5(a,b,c,d,e,f)
#define TRACE6(a,b,c,d,e,f,g)
#define TRACEX(l,a)
#define TRACEX1(l,a,b)
#define TRACEX2(l,a,b,c)
#define TRACEX3(l,a,b,c,d)
#define TRACEX4(l,a,b,c,d,e)
#define TRACEX5(l,a,b,c,d,e,f)
#define TRACEX6(l,a,b,c,d,e,f,g)
#define TRACEW1(a,b)
#define TRACE_ID(id,a)
#define TRACE_ID1(id,a,b)
#define TRACE_ID2(id,a,b,c)
#define TRACE_ID3(id,a,b,c,d)
#define TRACE_ID4(id,a,b,c,d,e)
#define TRACE_ID5(id,a,b,c,d,e,f)
#define TRACE_ID6(id,a,b,c,d,e,f,h)
#define DUMPB(p,c)
#define DUMPDW(p,c)
#if defined(ASSERT)
#undef ASSERT
#endif
#if defined(ASSERTMSG)
#undef ASSERTMSG
#endif
#define ASSERT(a)
#define ASSERTMSG(a)
#define DEBUGINIT(s)
#define DEBUGTERM()

#endif


/*----------------------------------------------------------------------------
** Prototypes (alphabetically)
**----------------------------------------------------------------------------
*/

DWORD
DebugInitEx(
    IN  CHAR* pszModule,
    OUT LPDWORD lpdwId);

VOID
DebugTermEx(
    OUT LPDWORD lpdwTraceId );

VOID
DebugInit(
    IN CHAR* pszModule );

VOID
DebugTerm(
    void );

VOID
Assert(
    IN const CHAR* pszExpression,
    IN const CHAR* pszFile,
    IN UINT        unLine );

VOID
TracePrintfW1(
    CHAR*  pszFormat,
    TCHAR* psz1 );


#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\eapcfg.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// eapcfg.h
// EAP configuration library
// Public header
//
// 11/25/97 Steve Cobb


#ifndef _EAPCFG_H_
#define _EAPCFG_H_


//----------------------------------------------------------------------------
// Constants
//----------------------------------------------------------------------------

// The default EAP key code, i.e. TLS.
//
#define EAPCFG_DefaultKey 13


//----------------------------------------------------------------------------
// Datatypes
//----------------------------------------------------------------------------

// EAP configuration DLL entrypoints.  These definitions must match the
// raseapif.h prototypes for RasEapInvokeConfigUI and RasEapFreeUserData.
//
typedef DWORD (APIENTRY * RASEAPFREE)( PBYTE );
typedef DWORD (APIENTRY * RASEAPINVOKECONFIGUI)( DWORD, HWND, DWORD, PBYTE, DWORD, PBYTE*, DWORD*);
typedef DWORD (APIENTRY * RASEAPGETIDENTITY)( DWORD, HWND, DWORD, const WCHAR*, const WCHAR*, PBYTE, DWORD, PBYTE, DWORD, PBYTE*, DWORD*, WCHAR** );

// Flags
//
#define EAPCFG_FLAG_RequireUsername   0x1
#define EAPCFG_FLAG_RequirePassword   0x2

// EAP configuration package definition.
//
typedef struct
_EAPCFG
{
    // The package's unique EAP algorithm code.
    //
    DWORD dwKey;

    // The friendly name of the package suitable for display to the user.
    //
    TCHAR* pszFriendlyName;

    // The SystemRoot-relative path to the package's configuration DLL.  May
    // be NULL indicating there is none.
    //
    TCHAR* pszConfigDll;

    // The SystemRoot-relative path to the package's identity DLL.  May
    // be NULL indicating there is none.
    //
    TCHAR* pszIdentityDll;

    // Flags that specify what standard credentials are required at dial
    // time.
    //
    DWORD dwStdCredentialFlags;

    // True if user is to be forced to run the configuration API for the
    // package, i.e. defaults are not sufficient.
    //
    BOOL fForceConfig;

    // True if the package provides MPPE encryption keys, false if not.
    //
    BOOL fProvidesMppeKeys;

    // The package's default configuration blob, which can be overwritten by
    // the configuration DLL.  May be NULL and 0 indicating there is none.
    //
    BYTE* pData;
    DWORD cbData;

    // Eap per user data to be stored in HKCU. This data is returned from
    // the EapInvokeConfigUI entrypoint in the eap dll.
    //
    BYTE* pUserData;
    DWORD cbUserData;

    // Set when the configuration DLL has been called on the package.  This is
    // not a registry setting.  It is provided for the convenience of the UI
    // only.
    //
    BOOL fConfigDllCalled;

    // Specifies the class ID of the configuration UI for remote machines.
    GUID guidConfigCLSID;
}
EAPCFG;


//----------------------------------------------------------------------------
// Prototypes
//----------------------------------------------------------------------------

DTLNODE*
CreateEapcfgNode(
    void );

VOID
DestroyEapcfgNode(
    IN OUT DTLNODE* pNode );

DTLNODE*
EapcfgNodeFromKey(
    IN DTLLIST* pList,
    IN DWORD dwKey );

DTLLIST*
ReadEapcfgList(
    IN TCHAR* pszMachine );


#endif // _EAPCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\inetcfgp.h ===
/*
    File    inetcfgp.h

    Private helper functions for dealing with inetcfg.  These
    functions are implemented in nouiutil.lib.

    Paul Mayfield, 1/5/98 (implementation by shaunco)
*/

#ifndef __nouiutil_inetcfgp_h
#define __nouiutil_inetcfgp_h

#define COBJMACROS

#include "objbase.h"
#include "netcfgx.h"
#include "netcfgp.h"
#include "netconp.h"

#ifdef _cplusplus
extern "C" {
#endif

HRESULT APIENTRY
HrCreateAndInitializeINetCfg (
    BOOL*       pfInitCom,
    INetCfg**   ppnc,
    BOOL        fGetWriteLock,
    DWORD       cmsTimeout,
    LPCWSTR     szwClientDesc,
    LPWSTR*     ppszwClientDesc);

HRESULT APIENTRY
HrUninitializeAndUnlockINetCfg(
    INetCfg*    pnc);

HRESULT APIENTRY
HrUninitializeAndReleaseINetCfg (
    BOOL        fUninitCom,
    INetCfg*    pnc,
    BOOL        fHasLock);

HRESULT APIENTRY
HrEnumComponentsInClasses (
    INetCfg*            pNetCfg,
    ULONG               cpguidClass,
    GUID**              apguidClass,
    ULONG               celt,
    INetCfgComponent**  rgelt,
    ULONG*              pceltFetched);

ULONG APIENTRY
ReleaseObj (void* punk);

HRESULT APIENTRY
HrCreateNetConnectionUtilities(
    INetConnectionUiUtilities ** ppncuu);


//Add this for bug 342810 328673
//
BOOL
IsGPAEnableFirewall(
    void);


#ifdef _cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\list.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    list.h
//============================================================================


#ifndef InitializeListHead


//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\mdm.h ===
/*
    File    mdm.h

    Library for dealing with and installing modems.

    Paul Mayfield, 5/20/98
*/

#ifndef __rassrvui_mdm_h
#define __rassrvui_mdm_h

//
// Definition of callback function used for enumerating
// com ports.  Return TRUE to stop enumeration, FALSE to
// continue.
//
typedef BOOL (*MdmPortEnumFuncPtr)(
                    IN PWCHAR pszPort,
                    IN HANDLE hData);

//
// Enumerates serial ports on the system
//
DWORD MdmEnumComPorts(
        IN MdmPortEnumFuncPtr pEnumFunc,
        IN HANDLE hData);


//
// Installs a null modem on the given port
//
DWORD MdmInstallNullModem(
        IN PWCHAR pszPort);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\intl.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** intl.h
** Remote Access international helpers
** Public header
*/

#ifndef _INTL_H_
#define _INTL_H_

/*----------------------------------------------------------------------------
** Constants
**----------------------------------------------------------------------------
*/

/* Flags to GetDurationString.
*/
#define GDSFLAG_Mseconds 0x00000001
#define GDSFLAG_Seconds  0x00000002
#define GDSFLAG_Minutes  0x00000004
#define GDSFLAG_Hours    0x00000008
#define GDSFLAG_Days     0x00000010
#define GDSFLAG_All      0x0000001F


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

DWORD
GetDurationString(
    IN DWORD dwMilliseconds,
    IN DWORD dwFormatFlags,
    IN OUT PTSTR pszBuffer,
    IN OUT DWORD *pdwBufSize );

DWORD
GetNumberString(
    IN DWORD dwNumber,
    IN OUT PTSTR pszBuffer,
    IN OUT PDWORD pdwBufSize );

PTSTR
padultoa(
    UINT  val,
    PTSTR pszBuf,
    INT   width );


#endif // _INTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\ipaddr.h ===
/* Copyright (c) 1991, Microsoft Corporation, all rights reserved

    ipaddr.h - TCP/IP Address custom control, global definitions

    November 10, 1992   - Greg Strange
*/

#ifndef _IPADDR_H_
#define _IPADDR_H_


// Messages sent to IPAddress controls

#define IP_CLEARADDRESS WM_USER+100 // no parameters
#define IP_SETADDRESS   WM_USER+101 // lparam = TCP/IP address
#define IP_GETADDRESS   WM_USER+102 // lresult = TCP/IP address
#define IP_SETRANGE     WM_USER+103 // wparam = field, lparam = range
#define IP_SETFOCUS     WM_USER+104 // wparam = field
#define IP_ISBLANK      WM_USER+105 // no parameters


// The following is a useful macro for passing the range values in the
// IP_SETRANGE message.

#define MAKERANGE(low,high) ((LPARAM)(WORD)(((BYTE)(high)<<8)+(BYTE)(low)))

// And this is a useful macro for making the IP Address to be passed
// as a LPARAM.

#define MAKEIPADDRESS(b1,b2,b3,b4) ((LPARAM)(((DWORD)(b1)<<24)+((DWORD)(b2)<<16)+((DWORD)(b3)<<8)+((DWORD)(b4))))

// Get individual number

#define FIRST_IPADDRESS(x)  ((x>>24) & 0xff)
#define SECOND_IPADDRESS(x) ((x>>16) & 0xff)
#define THIRD_IPADDRESS(x)  ((x>>8) & 0xff)
#define FOURTH_IPADDRESS(x) (x & 0xff)

// Use this function to force the ip address entered to 
// be contiguous (series of 1's followed by a series of 0's).
// This is useful for entering valid submasks
//
// Returns NO_ERROR if successful, error code otherwise
//
DWORD APIENTRY
IpAddr_ForceContiguous(
    HWND hwndIpAddr );

// Call this function once during initialization.

int FAR PASCAL
IpAddrInit(
    IN HANDLE hInstance,
    IN DWORD  dwErrorTitle,
    IN DWORD  dwBadIpAddrRange );


#endif // _IPADDR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\netguid.h ===
#pragma once

#include <initguid.h>
#include <devguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\loaddlls.h ===
/* Copyright (c) 1996, Microsoft Corporation, all rights reserved
**
** loaddlls.h
** RAS DLL load public header
**
** 02/17/96 Steve Cobb
*/

#ifndef _LOADDLLS_H_
#define _LOADDLLS_H_


#include <ras.h>    // Win32 RAS APIs
#include <rasdlg.h> // Win32 RAS UI APIs
#include <rasman.h> // RAS connection manager service
#include <rasppp.h> // PPP structure definitions

#define RASMERGE

/*----------------------------------------------------------------------------
** Datatypes and global declarations (defined in loaddlls.c)
**----------------------------------------------------------------------------
*/

/* RASAPI32.DLL entry points.
*/
#ifndef RASMERGE
extern HINSTANCE g_hRasapi32Dll;
#endif

typedef DWORD (APIENTRY * PRASCONNECTIONNOTIFICATION)( HRASCONN, HANDLE, DWORD );
extern PRASCONNECTIONNOTIFICATION g_pRasConnectionNotification;

typedef DWORD (APIENTRY * PRASDELETEENTRY)( LPTSTR, LPTSTR );
extern PRASDELETEENTRY g_pRasDeleteEntry;

typedef DWORD (APIENTRY * PRASDIAL)( LPRASDIALEXTENSIONS, LPTSTR, LPRASDIALPARAMS, DWORD, LPVOID, LPHRASCONN );
extern PRASDIAL g_pRasDial;

typedef DWORD (APIENTRY * PRASENUMENTRIES)( LPTSTR, LPTSTR, LPRASENTRYNAME, LPDWORD, LPDWORD );
extern PRASENUMENTRIES g_pRasEnumEntries;

typedef DWORD (APIENTRY * PRASENUMCONNECTIONS)( LPRASCONN, LPDWORD, LPDWORD );
extern PRASENUMCONNECTIONS g_pRasEnumConnections;

typedef DWORD (APIENTRY * PRASGETCONNECTSTATUS)( HRASCONN, LPRASCONNSTATUS );
extern PRASGETCONNECTSTATUS g_pRasGetConnectStatus;

typedef VOID (APIENTRY * PRASGETCONNECTRESPONSE)( HRASCONN, CHAR* );
extern PRASGETCONNECTRESPONSE g_pRasGetConnectResponse;

typedef DWORD (APIENTRY * PRASGETCREDENTIALS)( LPTSTR, LPTSTR, LPRASCREDENTIALS );
extern PRASGETCREDENTIALS g_pRasGetCredentials;

typedef DWORD (APIENTRY * PRASGETENTRYDIALPARAMS)( LPTSTR, LPRASDIALPARAMS, LPBOOL );
extern PRASGETENTRYDIALPARAMS g_pRasGetEntryDialParams;

typedef DWORD (APIENTRY * PRASGETERRORSTRING)( UINT, LPTSTR, DWORD );
extern PRASGETERRORSTRING g_pRasGetErrorString;

typedef DWORD (APIENTRY * PRASHANGUP)( HRASCONN );
extern PRASHANGUP g_pRasHangUp;

typedef DWORD (APIENTRY * PRASGETAUTODIALENABLE)( DWORD, LPBOOL );
extern PRASGETAUTODIALENABLE g_pRasGetAutodialEnable;

typedef DWORD (APIENTRY * PRASGETAUTODIALPARAM)( DWORD, LPVOID, LPDWORD );
extern PRASGETAUTODIALPARAM g_pRasGetAutodialParam;

typedef DWORD (APIENTRY * PRASGETPROJECTIONINFO)( HRASCONN, RASPROJECTION, LPVOID, LPDWORD );
extern PRASGETPROJECTIONINFO g_pRasGetProjectionInfo;

typedef DWORD (APIENTRY * PRASSETAUTODIALENABLE)( DWORD, BOOL );
extern PRASSETAUTODIALENABLE g_pRasSetAutodialEnable;

typedef DWORD (APIENTRY * PRASSETAUTODIALPARAM)( DWORD, LPVOID, DWORD );
extern PRASSETAUTODIALPARAM g_pRasSetAutodialParam;

typedef DWORD (APIENTRY * PRASGETSUBENTRYHANDLE)( HRASCONN, DWORD, LPHRASCONN );
extern PRASGETSUBENTRYHANDLE g_pRasGetSubEntryHandle;

typedef HPORT (APIENTRY * PRASGETHPORT)( HRASCONN );
extern PRASGETHPORT g_pRasGetHport;

typedef DWORD (APIENTRY * PRASSETCREDENTIALS)( LPTSTR, LPTSTR, LPRASCREDENTIALS, BOOL );
extern PRASSETCREDENTIALS g_pRasSetCredentials;

typedef DWORD (APIENTRY * PRASSETOLDPASSWORD)( HRASCONN, CHAR* );
extern PRASSETOLDPASSWORD g_pRasSetOldPassword;

typedef DWORD (APIENTRY * PRASGETCOUNTRYINFO)( LPRASCTRYINFO, LPDWORD );
extern PRASGETCOUNTRYINFO g_pRasGetCountryInfo;

typedef DWORD (APIENTRY * PRASINVOKEEAPUI)(HRASCONN, DWORD dwSubEntry, LPRASDIALEXTENSIONS, HWND );
extern PRASINVOKEEAPUI g_pRasInvokeEapUI;

typedef DWORD (APIENTRY * PRASSETEAPUSERDATA)( HANDLE, LPCTSTR, LPCTSTR, LPBYTE, LPDWORD );
extern PRASSETEAPUSERDATA g_pRasSetEapUserData;

typedef DWORD (APIENTRY * PRASGETENTRYPROPERTIES) (LPCTSTR, LPCTSTR, LPRASENTRY, LPDWORD, LPBYTE, LPDWORD);
extern PRASGETENTRYPROPERTIES g_pRasGetEntryProperties;

typedef DWORD (APIENTRY * PRASVALIDATEENTRYNAME) (LPCWSTR, LPCWSTR);
extern PRASVALIDATEENTRYNAME g_pRasValidateEntryName;


/* RASDLG.DLL entry points
*/
#ifndef RASMERGE
extern HINSTANCE g_hRasdlgDll;
#endif

typedef DWORD (APIENTRY * PRASPHONEBOOKDLG)( LPTSTR, LPTSTR, LPRASPBDLG );
extern PRASPHONEBOOKDLG g_pRasPhonebookDlg;

typedef DWORD (APIENTRY * PRASENTRYDLG)( LPTSTR, LPTSTR, LPRASENTRYDLG );
extern PRASENTRYDLG g_pRasEntryDlg;

typedef DWORD (APIENTRY * PROUTERENTRYDLG)( LPTSTR, LPTSTR, LPTSTR, LPRASENTRYDLG );
extern PROUTERENTRYDLG g_pRouterEntryDlg;

typedef DWORD (APIENTRY * PRASDIALDLG)( LPTSTR, LPTSTR, LPTSTR, LPRASDIALDLG );
extern PRASDIALDLG g_pRasDialDlg;


/* RASMAN.DLL entry points
*/
#ifndef RASMERGE
extern HINSTANCE g_hRasmanDll;
#endif

typedef DWORD (APIENTRY * PRASPORTCLEARSTATISTICS)( HANDLE, HPORT );
extern PRASPORTCLEARSTATISTICS g_pRasPortClearStatistics;

typedef DWORD (APIENTRY * PRASBUNDLECLEARSTATISTICS)( HANDLE, HPORT );
extern PRASBUNDLECLEARSTATISTICS g_pRasBundleClearStatistics;

typedef DWORD (APIENTRY * PRASBUNDLECLEARSTATISTICSEX)( HANDLE, HCONN );
extern PRASBUNDLECLEARSTATISTICSEX g_pRasBundleClearStatisticsEx;

typedef DWORD (APIENTRY * PRASDEVICEENUM)( HANDLE, PCHAR, PBYTE, PDWORD, PDWORD );
extern PRASDEVICEENUM g_pRasDeviceEnum;

typedef DWORD (APIENTRY * PRASDEVICEGETINFO)( HANDLE, HPORT, PCHAR, PCHAR, PBYTE, PDWORD );
extern PRASDEVICEGETINFO g_pRasDeviceGetInfo;

typedef DWORD (APIENTRY * PRASFREEBUFFER)( PBYTE );
extern PRASFREEBUFFER g_pRasFreeBuffer;

typedef DWORD (APIENTRY * PRASGETBUFFER)( PBYTE*, PDWORD );
extern PRASGETBUFFER g_pRasGetBuffer;

typedef DWORD (APIENTRY * PRASPORTGETFRAMINGEX)( HANDLE, HPORT, RAS_FRAMING_INFO* );
extern PRASPORTGETFRAMINGEX g_pRasPortGetFramingEx;

typedef DWORD (APIENTRY * PRASGETINFO)( HANDLE, HPORT, RASMAN_INFO* );
extern PRASGETINFO g_pRasGetInfo;

typedef DWORD (APIENTRY * PRASGETNDISWANDRIVERCAPS)( HANDLE, RAS_NDISWAN_DRIVER_INFO* );
extern PRASGETNDISWANDRIVERCAPS g_pRasGetNdiswanDriverCaps;

typedef DWORD (APIENTRY * PRASINITIALIZE)();
extern PRASINITIALIZE g_pRasInitialize;

typedef DWORD (APIENTRY * PRASINITIALIZENOWAIT)();
extern PRASINITIALIZE g_pRasInitializeNoWait;

typedef DWORD (APIENTRY * PRASPORTCANCELRECEIVE)( HPORT );
extern PRASPORTCANCELRECEIVE g_pRasPortCancelReceive;

typedef DWORD (APIENTRY * PRASPORTENUM)( HANDLE, PBYTE, PDWORD, PDWORD );
extern PRASPORTENUM g_pRasPortEnum;

typedef DWORD (APIENTRY * PRASPORTGETINFO)( HANDLE, HPORT, PBYTE, PDWORD );
extern PRASPORTGETINFO g_pRasPortGetInfo;

typedef DWORD (APIENTRY * PRASPORTGETSTATISTICS)( HANDLE, HPORT, PBYTE, PDWORD );
extern PRASPORTGETSTATISTICS g_pRasPortGetStatistics;

typedef DWORD (APIENTRY * PRASBUNDLEGETSTATISTICS)( HANDLE, HPORT, PBYTE, PDWORD );
extern PRASBUNDLEGETSTATISTICS g_pRasBundleGetStatistics;

typedef DWORD (APIENTRY * PRASPORTGETSTATISTICSEX)( HANDLE, HPORT, PBYTE, PDWORD );
extern PRASPORTGETSTATISTICSEX g_pRasPortGetStatisticsEx;

typedef DWORD (APIENTRY * PRASBUNDLEGETSTATISTICSEX)(HANDLE, HPORT, PBYTE, PDWORD);
extern PRASBUNDLEGETSTATISTICSEX g_pRasBundleGetStatisticsEx;

typedef DWORD (APIENTRY * PRASPORTRECEIVE)( HPORT, PBYTE, PDWORD, DWORD, HANDLE );
extern PRASPORTRECEIVE g_pRasPortReceive;

typedef DWORD (APIENTRY * PRASPORTRECEIVEEX ) ( HPORT, PBYTE, PDWORD );
extern PRASPORTRECEIVEEX g_pRasPortReceiveEx;

typedef DWORD (APIENTRY * PRASPORTSEND)( HPORT, PBYTE, DWORD );
extern PRASPORTSEND g_pRasPortSend;

typedef DWORD (APIENTRY * PRASPORTGETBUNDLE)(HANDLE,  HPORT, HBUNDLE* );
extern PRASPORTGETBUNDLE g_pRasPortGetBundle;

typedef DWORD (APIENTRY * PRASGETDEVCONFIG)( HANDLE, HPORT, PCHAR, PBYTE, DWORD* );
extern PRASGETDEVCONFIG g_pRasGetDevConfig;
extern PRASGETDEVCONFIG g_pRasGetDevConfigEx;

typedef DWORD (APIENTRY * PRASSETDEVCONFIG)(HPORT, PCHAR, PBYTE, DWORD );
extern PRASSETDEVCONFIG g_pRasSetDevConfig;

typedef DWORD (APIENTRY * PRASPORTOPEN)(PCHAR, HPORT*, HANDLE);
extern PRASPORTOPEN g_pRasPortOpen;

typedef DWORD (APIENTRY * PRASPORTREGISTERSLIP)(HPORT, DWORD, DWORD, BOOL,
                                                WCHAR*, WCHAR*, WCHAR*, WCHAR*);
extern PRASPORTREGISTERSLIP g_pRasPortRegisterSlip;

typedef DWORD (APIENTRY * PRASALLOCATEROUTE)(HPORT, RAS_PROTOCOLTYPE, BOOL,
                                             RASMAN_ROUTEINFO*);
extern PRASALLOCATEROUTE g_pRasAllocateRoute;

typedef DWORD (APIENTRY * PRASACTIVATEROUTE)(HPORT, RAS_PROTOCOLTYPE,
                                            RASMAN_ROUTEINFO*, PROTOCOL_CONFIG_INFO*);
extern PRASACTIVATEROUTE g_pRasActivateRoute;

typedef DWORD (APIENTRY * PRASACTIVATEROUTEEX)(HPORT, RAS_PROTOCOLTYPE, DWORD,
                                               RASMAN_ROUTEINFO*, PROTOCOL_CONFIG_INFO*);
extern PRASACTIVATEROUTEEX g_pRasActivateRouteEx;

typedef DWORD (APIENTRY * PRASDEVICESETINFO)(HPORT, PCHAR, PCHAR, RASMAN_DEVICEINFO*);
extern PRASDEVICESETINFO g_pRasDeviceSetInfo;

typedef DWORD (APIENTRY * PRASDEVICECONNECT)(HPORT, PCHAR, PCHAR, DWORD, HANDLE);
extern PRASDEVICECONNECT g_pRasDeviceConnect;

typedef DWORD (APIENTRY * PRASPORTSETINFO)(HPORT, RASMAN_PORTINFO*);
extern PRASPORTSETINFO g_pRasPortSetInfo;

typedef DWORD (APIENTRY * PRASPORTCLOSE)(HPORT);
extern PRASPORTCLOSE g_pRasPortClose;

typedef DWORD (APIENTRY * PRASPORTLISTEN)(HPORT, DWORD, HANDLE);
extern PRASPORTLISTEN g_pRasPortListen;

typedef DWORD (APIENTRY * PRASPORTCONNECTCOMPLETE)(HPORT);
extern PRASPORTCONNECTCOMPLETE g_pRasPortConnectComplete;

typedef DWORD (APIENTRY * PRASPORTDISCONNECT)(HPORT, HANDLE);
extern PRASPORTDISCONNECT g_pRasPortDisconnect;

typedef DWORD (APIENTRY * PRASREQUESTNOTIFICATION)(HPORT, HANDLE);
extern PRASREQUESTNOTIFICATION g_pRasRequestNotification;

typedef DWORD (APIENTRY * PRASPORTENUMPROTOCOLS)(HANDLE, HPORT, RAS_PROTOCOLS*, PDWORD);
extern PRASPORTENUMPROTOCOLS g_pRasPortEnumProtocols;

typedef DWORD (APIENTRY * PRASPORTSETFRAMING)(HPORT, RAS_FRAMING,
                                             RASMAN_PPPFEATURES*, RASMAN_PPPFEATURES*);
extern PRASPORTSETFRAMING g_pRasPortSetFraming;

typedef DWORD (APIENTRY * PRASPORTSETFRAMINGEX)(HPORT, RAS_FRAMING_INFO*);
extern PRASPORTSETFRAMINGEX g_pRasPortSetFramingEx;

typedef DWORD (APIENTRY * PRASSETCACHEDCREDENTIALS)(PCHAR, PCHAR, PCHAR);
extern PRASSETCACHEDCREDENTIALS g_pRasSetCachedCredentials;

typedef DWORD (APIENTRY * PRASGETDIALPARAMS)(DWORD, LPDWORD, PRAS_DIALPARAMS);
extern PRASGETDIALPARAMS g_pRasGetDialParams;

typedef DWORD (APIENTRY * PRASSETDIALPARAMS)(DWORD, DWORD, PRAS_DIALPARAMS, BOOL);
extern PRASSETDIALPARAMS g_pRasSetDialParams;

typedef DWORD (APIENTRY * PRASCREATECONNECTION) ( HCONN *, DWORD, DWORD *, DWORD *,
                                                  DWORD, GUID *, CHAR *, CHAR *,CHAR *, 
                                                  CHAR *);
extern PRASCREATECONNECTION g_pRasCreateConnection;

typedef DWORD (APIENTRY * PRASDESTROYCONNECTION)(HCONN);
extern PRASDESTROYCONNECTION g_pRasDestroyConnection;

typedef DWORD (APIENTRY * PRASCONNECTIONENUM)(HANDLE, HCONN*, LPDWORD, LPDWORD);
extern PRASCONNECTIONENUM g_pRasConnectionEnum;

typedef DWORD (APIENTRY * PRASADDCONNECTIONPORT)(HCONN, HPORT, DWORD);
extern PRASADDCONNECTIONPORT g_pRasAddConnectionPort;

typedef DWORD (APIENTRY * PRASENUMCONNECTIONPORTS)(HANDLE, HCONN, RASMAN_PORT*,
                                                   LPDWORD, LPDWORD);
extern PRASENUMCONNECTIONPORTS g_pRasEnumConnectionPorts;

typedef DWORD (APIENTRY * PRASGETCONNECTIONPARAMS)(HCONN, PRAS_CONNECTIONPARAMS);
extern PRASGETCONNECTIONPARAMS g_pRasGetConnectionParams;

typedef DWORD (APIENTRY * PRASSETCONNECTIONPARAMS)(HCONN, PRAS_CONNECTIONPARAMS);
extern PRASSETCONNECTIONPARAMS g_pRasSetConnectionParams;

typedef DWORD (APIENTRY * PRASGETCONNECTIONUSERDATA)(HCONN, DWORD, PBYTE, LPDWORD);
extern PRASGETCONNECTIONUSERDATA g_pRasGetConnectionUserData;

typedef DWORD (APIENTRY * PRASSETCONNECTIONUSERDATA)(HCONN, DWORD, PBYTE, DWORD);
extern PRASSETCONNECTIONUSERDATA g_pRasSetConnectionUserData;

typedef DWORD (APIENTRY * PRASGETPORTUSERDATA)(HCONN, DWORD, PBYTE, LPDWORD);
extern PRASGETPORTUSERDATA g_pRasGetPortUserData;

typedef DWORD (APIENTRY * PRASSETPORTUSERDATA)(HCONN, DWORD, PBYTE, DWORD);
extern PRASSETPORTUSERDATA g_pRasSetPortUserData;

typedef DWORD (APIENTRY * PRASADDNOTIFICATION)(HCONN, HANDLE, DWORD);
extern PRASADDNOTIFICATION g_pRasAddNotification;

typedef DWORD (APIENTRY * PRASSIGNALNEWCONNECTION)(HCONN);
extern PRASSIGNALNEWCONNECTION g_pRasSignalNewConnection;

typedef DWORD (APIENTRY * PRASPPPSTOP)(HPORT);
extern PRASPPPSTOP g_pRasPppStop;

typedef DWORD (APIENTRY * PRASPPPCALLBACK)(HPORT, CHAR*);
extern PRASPPPCALLBACK g_pRasPppCallback;

typedef DWORD (APIENTRY * PRASPPPCHANGEPASSWORD)(HPORT, CHAR*, CHAR*, CHAR*);
extern PRASPPPCHANGEPASSWORD g_pRasPppChangePassword;

typedef DWORD (APIENTRY * PRASPPPGETINFO)(HPORT, PPP_MESSAGE*);
extern PRASPPPGETINFO g_pRasPppGetInfo;

typedef DWORD (APIENTRY * PRASPPPRETRY)(HPORT, CHAR*, CHAR*, CHAR*);
extern PRASPPPRETRY g_pRasPppRetry;

typedef DWORD (APIENTRY *PRASPPPSTART)(HPORT, CHAR*, CHAR*, CHAR*, CHAR*, LUID*,
                                       PPP_CONFIG_INFO*, LPVOID, CHAR*,
                                       BOOL, HANDLE, DWORD, BOOL, PPP_BAPPARAMS*,
                                       BOOL, DWORD, DWORD);
extern PRASPPPSTART g_pRasPppStart;

typedef DWORD (APIENTRY * PRASSETIOCOMPLETIONPORT)(HPORT, HANDLE, PRAS_OVERLAPPED,
                                                   PRAS_OVERLAPPED, PRAS_OVERLAPPED,
                                                   PRAS_OVERLAPPED, HCONN);
extern PRASSETIOCOMPLETIONPORT g_pRasSetIoCompletionPort;

typedef DWORD (APIENTRY * PRASSENDPPPMESSAGETORASMAN) (PPP_MESSAGE *pPppMessage);
extern PRASSENDPPPMESSAGETORASMAN g_pRasSendPppMessageToRasman;

typedef DWORD (APIENTRY * PRASSETRASDIALINFO) (HPORT, CHAR*, CHAR*, CHAR *, DWORD, PBYTE);
extern PRASSETRASDIALINFO g_pRasSetRasdialInfo;

typedef DWORD (APIENTRY * PRASRPCCONNECT ) ( LPCTSTR, HANDLE * );
extern PRASRPCCONNECT g_pRasRpcConnect;

typedef DWORD (APIENTRY * PRASRPCDISCONNECT ) ( HANDLE * );
extern PRASRPCDISCONNECT g_pRasRpcDisconnect;

typedef DWORD (APIENTRY * PRASNUMPORTOPEN ) ();
extern PRASNUMPORTOPEN g_pRasNumPortOpen;

typedef DWORD (APIENTRY *PRASREFCONNECTION ) ( HCONN, BOOL, DWORD * );
extern PRASREFCONNECTION g_pRasRefConnection;

typedef DWORD (APIENTRY *PRASPPPGETEAPINFO) ( HCONN, DWORD, DWORD *, DWORD *,
                                              DWORD *, PBYTE);
extern PRASPPPGETEAPINFO g_pRasPppGetEapInfo;

typedef DWORD( APIENTRY *PRASPPPSETEAPINFO) (HPORT, DWORD, DWORD, PBYTE);
extern PRASPPPSETEAPINFO g_pRasPppSetEapInfo;

typedef DWORD(APIENTRY *PRASFINDPREREQUISITEENTRY) (HCONN, HCONN *);
extern PRASFINDPREREQUISITEENTRY g_pRasFindPrerequisiteEntry;

typedef DWORD(APIENTRY *PRASPORTOPENEX) (CHAR *, DWORD, HPORT *, HANDLE, DWORD *);
extern PRASPORTOPENEX g_pRasPortOpenEx;

typedef DWORD(APIENTRY *PRASLINKGETSTATISTICS) (HANDLE, HCONN, DWORD, PBYTE);
extern PRASLINKGETSTATISTICS g_pRasLinkGetStatistics;

typedef DWORD(APIENTRY *PRASCONNECTIONGETSTATISTICS) (HANDLE, HCONN, PBYTE);
extern PRASCONNECTIONGETSTATISTICS g_pRasConnectionGetStatistics;

typedef DWORD(APIENTRY *PRASGETHPORTFROMCONNECTION) (HANDLE, HCONN, HPORT *);
extern PRASGETHPORTFROMCONNECTION g_pRasGetHportFromConnection;

typedef DWORD(APIENTRY *PRASRPCBIND) (LPWSTR, HANDLE *, BOOL);
extern PRASRPCBIND g_pRasRpcBind;

typedef DWORD(APIENTRY *PRASREFERENCECUSTOMCOUNT) (HCONN ,BOOL, CHAR *, CHAR *, DWORD *);
extern PRASREFERENCECUSTOMCOUNT g_pRasReferenceCustomCount;

typedef DWORD(APIENTRY *PRASGETHCONNFROMENTRY) (HCONN *, CHAR *, CHAR *);
extern PRASGETHCONNFROMENTRY g_pRasGetHConnFromEntry;

typedef DWORD(APIENTRY *PRASGETDEVICENAME) (RASDEVICETYPE, CHAR *);
extern PRASGETDEVICENAME g_pRasGetDeviceName;

typedef DWORD(APIENTRY *PRASENABLEIPSEC) (HPORT, BOOL, BOOL, RAS_L2TP_ENCRYPTION);
extern PRASENABLEIPSEC g_pRasEnableIpSec;

typedef DWORD(APIENTRY *PRASISIPSECENABLED) (HPORT, BOOL *);
extern PRASISIPSECENABLED g_pRasIsIpSecEnabled;

typedef DWORD(APIENTRY *PRASGETEAPUSERINFO) (HANDLE, PBYTE, DWORD *, GUID *, BOOL, DWORD);
extern PRASGETEAPUSERINFO g_pRasGetEapUserInfo;
 
typedef DWORD(APIENTRY *PRASSETEAPUSERINFO) (HANDLE, GUID *, PBYTE, DWORD, BOOL, BOOL, DWORD);
extern PRASSETEAPUSERINFO g_pRasSetEapUserInfo;

typedef DWORD(APIENTRY *PRASSETEAPLOGONINFO) (HPORT, BOOL, RASEAPINFO *);
extern PRASSETEAPLOGONINFO g_pRasSetEapLogonInfo;

typedef DWORD(APIENTRY *PRASSTARTRASAUTOIFREQUIRED) (VOID);
extern PRASSTARTRASAUTOIFREQUIRED g_pRasStartRasAutoIfRequired;

/* MPRAPI.DLL entry points
*/
#ifndef RASMERGE
extern HINSTANCE g_hMpradminDll;
#endif

typedef DWORD (APIENTRY * PMPRADMININTERFACECREATE)(HANDLE,DWORD,LPBYTE,HANDLE*);
extern PMPRADMININTERFACECREATE g_pMprAdminInterfaceCreate;
typedef DWORD (APIENTRY * PMPRADMININTERFACEDELETE)(HANDLE,HANDLE);
extern PMPRADMININTERFACEDELETE g_pMprAdminInterfaceDelete;
typedef DWORD (APIENTRY * PMPRADMININTERFACEGETHANDLE)(HANDLE,LPWSTR,HANDLE*,BOOL);
extern PMPRADMININTERFACEGETHANDLE g_pMprAdminInterfaceGetHandle;
typedef DWORD (APIENTRY * PMPRADMININTERFACEGETCREDENTIALS)(LPWSTR,LPWSTR,LPWSTR,LPWSTR,LPWSTR);
extern PMPRADMININTERFACEGETCREDENTIALS g_pMprAdminInterfaceGetCredentials;
typedef DWORD (APIENTRY * PMPRADMININTERFACEGETCREDENTIALSEX)(HANDLE,HANDLE,DWORD,LPBYTE *);
extern PMPRADMININTERFACEGETCREDENTIALSEX g_pMprAdminInterfaceGetCredentialsEx;
typedef DWORD (APIENTRY * PMPRADMININTERFACESETCREDENTIALS)(LPWSTR,LPWSTR,LPWSTR,LPWSTR,LPWSTR);
extern PMPRADMININTERFACESETCREDENTIALS g_pMprAdminInterfaceSetCredentials;
typedef DWORD (APIENTRY * PMPRADMININTERFACESETCREDENTIALSEX)(HANDLE,HANDLE,DWORD,LPBYTE);
extern PMPRADMININTERFACESETCREDENTIALSEX g_pMprAdminInterfaceSetCredentialsEx;
typedef DWORD (APIENTRY * PMPRADMINBUFFERFREE)(LPVOID);
extern PMPRADMINBUFFERFREE  g_pMprAdminBufferFree;
typedef DWORD (APIENTRY * PMPRADMININTERFACETRANSPORTADD)(HANDLE,HANDLE,DWORD,LPBYTE,DWORD);
extern PMPRADMININTERFACETRANSPORTADD g_pMprAdminInterfaceTransportAdd;
typedef DWORD (APIENTRY * PMPRADMININTERFACETRANSPORTSETINFO)(HANDLE,HANDLE,DWORD,LPBYTE,DWORD);
extern PMPRADMININTERFACETRANSPORTSETINFO g_pMprAdminInterfaceTransportSetInfo;
typedef DWORD (APIENTRY * PMPRADMINSERVERDISCONNECT)(HANDLE);
extern PMPRADMINSERVERDISCONNECT g_pMprAdminServerDisconnect;
typedef DWORD (APIENTRY * PMPRADMINSERVERCONNECT)(LPWSTR,HANDLE*);
extern PMPRADMINSERVERCONNECT g_pMprAdminServerConnect;
typedef DWORD (APIENTRY * PMPRADMINTRANSPORTSETINFO)(HANDLE,DWORD,LPBYTE,DWORD,LPBYTE,DWORD);
extern PMPRADMINTRANSPORTSETINFO g_pMprAdminTransportSetInfo;
typedef DWORD (APIENTRY * PRASADMINSERVERCONNECT)(LPWSTR, HANDLE*);
extern PRASADMINSERVERCONNECT g_pRasAdminServerConnect;
typedef DWORD (APIENTRY * PRASADMINSERVERDISCONNECT)(HANDLE);
extern PRASADMINSERVERDISCONNECT g_pRasAdminServerDisconnect;
typedef DWORD (APIENTRY * PRASADMINBUFFERFREE)(LPVOID);
extern PRASADMINBUFFERFREE g_pRasAdminBufferFree;
typedef DWORD (APIENTRY * PRASADMINCONNECTIONENUM)(HANDLE, DWORD, LPBYTE*, DWORD, LPDWORD, LPDWORD, LPDWORD);
extern PRASADMINCONNECTIONENUM g_pRasAdminConnectionEnum;
typedef DWORD (APIENTRY * PRASADMINCONNECTIONGETINFO)(HANDLE, DWORD, HANDLE, LPBYTE*);
extern PRASADMINCONNECTIONGETINFO g_pRasAdminConnectionGetInfo;
typedef DWORD (APIENTRY * PRASADMINPORTENUM)(HANDLE, DWORD, HANDLE, LPBYTE*, DWORD, LPDWORD, LPDWORD, LPDWORD);
extern PRASADMINPORTENUM g_pRasAdminPortEnum;
typedef DWORD (APIENTRY * PRASADMINPORTGETINFO)(HANDLE, DWORD, HANDLE, LPBYTE*);
extern PRASADMINPORTGETINFO g_pRasAdminPortGetInfo;
typedef DWORD (APIENTRY * PRASADMINPORTDISCONNECT)(HANDLE, HANDLE);
extern PRASADMINPORTDISCONNECT g_pRasAdminPortDisconnect;
typedef DWORD (APIENTRY * PRASADMINUSERSETINFO)(LPCWSTR,LPCWSTR,DWORD,LPBYTE);
extern PRASADMINUSERSETINFO g_pRasAdminUserSetInfo;
typedef DWORD (APIENTRY * PMPRADMINUSERSERVERCONNECT)(PWCHAR, BOOL, PHANDLE);
extern PMPRADMINUSERSERVERCONNECT g_pMprAdminUserServerConnect;
typedef DWORD (APIENTRY * PMPRADMINUSERSERVERDISCONNECT)(HANDLE);
extern PMPRADMINUSERSERVERDISCONNECT g_pMprAdminUserServerDisconnect;
typedef DWORD (APIENTRY * PMPRADMINUSEROPEN)(HANDLE, PWCHAR, PHANDLE);
extern PMPRADMINUSEROPEN g_pMprAdminUserOpen;
typedef DWORD (APIENTRY * PMPRADMINUSERCLOSE)(HANDLE);
extern PMPRADMINUSERCLOSE g_pMprAdminUserClose;
typedef DWORD (APIENTRY * PMPRADMINUSERWRITE)(HANDLE, DWORD, LPBYTE);
extern PMPRADMINUSERWRITE g_pMprAdminUserWrite;
typedef DWORD (APIENTRY * PMPRCONFIGBUFFERFREE)(LPVOID);
extern PMPRCONFIGBUFFERFREE g_pMprConfigBufferFree;
typedef DWORD (APIENTRY * PMPRCONFIGSERVERCONNECT)(LPWSTR,HANDLE*);
extern PMPRCONFIGSERVERCONNECT g_pMprConfigServerConnect;
typedef VOID (APIENTRY * PMPRCONFIGSERVERDISCONNECT)(HANDLE);
extern PMPRCONFIGSERVERDISCONNECT g_pMprConfigServerDisconnect;
typedef DWORD (APIENTRY * PMPRCONFIGTRANSPORTGETINFO)(HANDLE,HANDLE,LPBYTE*,LPDWORD,LPBYTE*,LPDWORD,LPWSTR*);
extern PMPRCONFIGTRANSPORTGETINFO g_pMprConfigTransportGetInfo;
typedef DWORD (APIENTRY * PMPRCONFIGTRANSPORTSETINFO)(HANDLE,HANDLE,LPBYTE,DWORD,LPBYTE,DWORD,LPWSTR);
extern PMPRCONFIGTRANSPORTSETINFO g_pMprConfigTransportSetInfo;
typedef DWORD (APIENTRY * PMPRCONFIGTRANSPORTGETHANDLE)(HANDLE,DWORD,HANDLE*);
extern PMPRCONFIGTRANSPORTGETHANDLE g_pMprConfigTransportGetHandle;
typedef DWORD (APIENTRY * PMPRCONFIGINTERFACECREATE)(HANDLE,DWORD,LPBYTE,HANDLE*);
extern PMPRCONFIGINTERFACECREATE g_pMprConfigInterfaceCreate;
typedef DWORD (APIENTRY * PMPRCONFIGINTERFACEDELETE)(HANDLE,HANDLE);
extern PMPRCONFIGINTERFACEDELETE g_pMprConfigInterfaceDelete;
typedef DWORD (APIENTRY * PMPRCONFIGINTERFACEGETHANDLE)(HANDLE,LPWSTR,HANDLE*);
extern PMPRCONFIGINTERFACEGETHANDLE g_pMprConfigInterfaceGetHandle;
typedef DWORD (APIENTRY * PMPRCONFIGINTERFACEENUM)(HANDLE,DWORD,LPBYTE*,DWORD,LPDWORD,LPDWORD,LPDWORD);
extern PMPRCONFIGINTERFACEENUM g_pMprConfigInterfaceEnum;
typedef DWORD (APIENTRY * PMPRCONFIGINTERFACETRANSPORTADD)(HANDLE,HANDLE,DWORD,LPWSTR,LPBYTE,DWORD,HANDLE*);
extern PMPRCONFIGINTERFACETRANSPORTADD g_pMprConfigInterfaceTransportAdd;
typedef DWORD (APIENTRY * PMPRCONFIGINTERFACETRANSPORTGETINFO)(HANDLE,HANDLE,HANDLE,LPBYTE*,LPDWORD);
extern PMPRCONFIGINTERFACETRANSPORTGETINFO g_pMprConfigInterfaceTransportGetInfo;
typedef DWORD (APIENTRY * PMPRCONFIGINTERFACETRANSPORTSETINFO)(HANDLE,HANDLE,HANDLE,LPBYTE,DWORD);
extern PMPRCONFIGINTERFACETRANSPORTSETINFO g_pMprConfigInterfaceTransportSetInfo;
typedef DWORD (APIENTRY * PMPRCONFIGINTERFACETRANSPORTGETHANDLE)(HANDLE,HANDLE,DWORD,HANDLE*);
extern PMPRCONFIGINTERFACETRANSPORTGETHANDLE g_pMprConfigInterfaceTransportGetHandle;
typedef DWORD (APIENTRY * PMPRINFOCREATE)(DWORD,LPVOID*);
extern PMPRINFOCREATE g_pMprInfoCreate;
typedef DWORD (APIENTRY * PMPRINFODELETE)(LPVOID);
extern PMPRINFODELETE g_pMprInfoDelete;
typedef DWORD (APIENTRY * PMPRINFODUPLICATE)(LPVOID,LPVOID*);
extern PMPRINFODUPLICATE g_pMprInfoDuplicate;
typedef DWORD (APIENTRY * PMPRINFOBLOCKADD)(LPVOID,DWORD,DWORD,DWORD,LPBYTE,LPVOID*);
extern PMPRINFOBLOCKADD g_pMprInfoBlockAdd;
typedef DWORD (APIENTRY * PMPRINFOBLOCKREMOVE)(LPVOID,DWORD,LPVOID*);
extern PMPRINFOBLOCKREMOVE g_pMprInfoBlockRemove;
typedef DWORD (APIENTRY * PMPRINFOBLOCKSET)(LPVOID,DWORD,DWORD,DWORD,LPBYTE,LPVOID*);
extern PMPRINFOBLOCKSET g_pMprInfoBlockSet;
typedef DWORD (APIENTRY * PMPRINFOBLOCKFIND)(LPVOID,DWORD,LPDWORD,LPDWORD,LPBYTE*);
extern PMPRINFOBLOCKFIND g_pMprInfoBlockFind;

//
// Miscellaneous entry points.
//
// These are included for consistency because they
// are remotable by the RAS RPC interface.
//
typedef DWORD (*PGETINSTALLEDPROTOCOLS)();
extern PGETINSTALLEDPROTOCOLS g_pGetInstalledProtocols;

typedef DWORD (*PGETINSTALLEDPROTOCOLSEX)(HANDLE, BOOL, BOOL, BOOL);
extern PGETINSTALLEDPROTOCOLSEX g_pGetInstalledProtocolsEx;

typedef DWORD (*PGETUSERPREFERENCES)(HANDLE, PBUSER*, DWORD);
extern PGETUSERPREFERENCES g_pGetUserPreferences;

typedef DWORD (*PSETUSERPREFERENCES)(HANDLE, PBUSER*, DWORD);
extern PSETUSERPREFERENCES g_pSetUserPreferences;

typedef DWORD (WINAPI *PGETSYSTEMDIRECTORY)(HANDLE, LPTSTR, UINT);
extern PGETSYSTEMDIRECTORY g_pGetSystemDirectory;

/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

BOOL
IsRasmanServiceRunning(
    void );

DWORD
LoadMpradminDll(
    void );

DWORD
LoadRasapi32Dll(
    void );

DWORD
LoadRasdlgDll(
    void );

DWORD
LoadRasmanDll(
    void );

#if 0

DWORD
LoadRasRpcDll(
    LPTSTR  lpszServer
    );

#endif    

BOOL
Rasapi32DllLoaded(
    void
    );

BOOL
RasRpcDllLoaded(
    void
    );

LPTSTR
RemoteGetServerName(
        HANDLE hConnection
        );

DWORD
RemoteGetServerVersion(
    HANDLE hConnection
    );

BOOL
IsRasRemoteConnection(
    HANDLE hConnection
    );

VOID
UnloadMpradminDll(
    void );

VOID
UnloadRasapi32Dll(
    void );

VOID
UnloadRasdlgDll(
    void );

VOID
UnloadRasmanDll(
    void );

DWORD
UnloadRasRpcDll(
    void );

DWORD
InitializeConnection(
    LPTSTR lpszServer,
    HANDLE *pHConnection);

VOID
UninitializeConnection(
    HANDLE hConnection);


DWORD
RemoteGetInstalledProtocols(
    HANDLE hConnection
    );

DWORD
RemoteGetInstalledProtocolsEx(
    HANDLE hConnection,
    BOOL fRouter,
    BOOL fRasCli,
    BOOL fRasSrv );

UINT WINAPI
RemoteGetSystemDirectory(
    HANDLE hConnection,
    LPTSTR lpBuffer,
    UINT uSize );

DWORD
RemoteGetUserPreferences(
    HANDLE hConnection,
    OUT PBUSER* pPbuser,
    IN DWORD dwMode );

DWORD APIENTRY
RemoteRasDeleteEntry(
    HANDLE hConnection,
    LPTSTR lpszPhonebook,
    LPTSTR lpszEntry );


DWORD APIENTRY
RemoteRasDeviceEnum(
    HANDLE hConnection,
    PCHAR pszDeviceType,
    PBYTE lpDevices,
    PDWORD pwcbDevices,
    PDWORD pwcDevices );

DWORD APIENTRY
RemoteRasEnumConnections(
    HANDLE hConnection,
    LPRASCONN lpRasConn,
    LPDWORD lpdwcbRasConn,
    LPDWORD lpdwcRasConn );

DWORD APIENTRY
RemoteRasGetCountryInfo(
    HANDLE hConnection,
    LPRASCTRYINFO lpRasCountryInfo,
    LPDWORD lpdwcbRasCountryInfo );


DWORD APIENTRY
RemoteRasGetDevConfig(
    HANDLE hConnection,
    HPORT hport,
    PCHAR pszDeviceType,
    PBYTE lpConfig,
    LPDWORD lpcbConfig );

DWORD APIENTRY
RemoteRasGetErrorString(
    HANDLE hConnection,
    UINT uErrorValue,
    LPTSTR lpszBuf,
    DWORD cbBuf );


DWORD APIENTRY
RemoteRasPortEnum(
    HANDLE hConnection,
    PBYTE lpPorts,
    PDWORD pdwcbPorts,
    PDWORD pdwcPorts );

DWORD
RemoteSetUserPreferences(
    HANDLE hConnection,
    OUT PBUSER* pPbuser,
    IN DWORD dwMode );

DWORD APIENTRY
RemoteRasPortGetInfo(
    HANDLE hConnection,
        HPORT porthandle,
        PBYTE buffer,
        PDWORD pSize );

UINT WINAPI
RasGetSystemDirectory(
    HANDLE hConnection,
    LPTSTR lpBuffer,
    UINT uSize
    );

#endif // _LOADDLLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\mem.h ===
//
// Copyright (c) Microsoft Corporation 1993-1995
//
// mem.h
//
// Memory management functions.
//
// History:
//  09-27-94 ScottH     Partially taken from commctrl
//  04-29-95 ScottH     Taken from briefcase and cleaned up
//

#ifndef _MEM_H_
#define _MEM_H_

//
// Memory routines
//

#ifdef WIN32
//
// These macros are used in our controls, that in 32 bits we simply call
// LocalAlloc as to have the memory associated with the process that created
// it and as such will be cleaned up if the process goes away.
//

LPVOID  PUBLIC MemAlloc(HANDLE hheap, DWORD cb);
LPVOID  PUBLIC MemReAlloc(HANDLE hheap, LPVOID pb, DWORD cb);
BOOL    PUBLIC MemFree(HANDLE hheap, LPVOID pb);
DWORD   PUBLIC MemSize(HANDLE hheap, LPVOID pb);

#else // WIN32

// In 16 bit code we need the Allocs to go from our heap code as we do not
// want to limit them to 64K of data.  If we have some type of notification of
// 16 bit application termination, We may want to see if we can
// dedicate different heaps for different processes to cleanup...

#define MemAlloc(hheap, cb)       Alloc(cb)  /* calls to verify heap exists */
#define MemReAlloc(hheap, pb, cb) ReAlloc(pb, cb)
#define MemFree(hheap, pb)        Free(pb)
#define MemSize(hheap, pb)        GetSize((LPCVOID)pb)

#endif // WIN32

//  Mem_Terminate() must be called before the app/dll is terminated.
//
void PUBLIC Mem_Terminate();

//
// Non-shared memory allocation
//

//      void * GAlloc(DWORD cbBytes)
//
//          Alloc a chunk of memory.  Initialize to zero.
//
#define GAlloc(cbBytes)         GlobalAlloc(GPTR, cbBytes)

//      void * GReAlloc(void * pv, DWORD cbNewSize)
//
//          Realloc memory.  If pv is NULL, then this function will do
//          an alloc for you.  Initializes new portion to zero.
//
#define GReAlloc(pv, cbNewSize) GlobalReAlloc(pv, cbNewSize, GMEM_MOVEABLE | GMEM_ZEROINIT)

//      void GFree(void *pv)
//
//          Free pv if it is nonzero.
//
#define GFree(pv)               ((pv) ? GlobalFree(pv) : (void)0)

//      DWORD GGetSize(void *pv)
//
//          Get the size of a block allocated by GAlloc()
//
#define GGetSize(pv)            GlobalSize(pv)

//      type * GAllocType(type)                     (macro)
//
//          Alloc some memory the size of <type> and return 
//          pointer to <type>.
//
#define GAllocType(type)                (type *)GAlloc(sizeof(type))

//      type * GAllocArray(type, DWORD cNum)        (macro)
//
//          Alloc an array of data the size of <type>.  Returns
//          a pointer to <type>.
//
#define GAllocArray(type, cNum)          (type *)GAlloc(sizeof(type) * (cNum))

//      type * GReAllocArray(type, void * pb, DWORD cNum);
//
//          Realloc an array of <type>.  Returns a pointer to
//          <type>.  The returned pointer may differ from the 
//          given <pb> parameter.
//
#define GReAllocArray(type, pb, cNum)    (type *)GReAlloc(pb, sizeof(type) * (cNum))

//      (Re)allocates *ppszBuf and copies psz into *ppszBuf.  If
//      *ppszBuf is NULL, this function allocates memory to hold
//      psz.  If *ppszBuf is non-NULL, this function reallocates
//      memory to hold psz.  If psz is NULL, this function frees
//      *ppszBuf.
//
//      Returns TRUE if successful, FALSE if not.
//
BOOL    PUBLIC GSetString(LPSTR * ppszBuf, LPCSTR psz);

//      This function is like GSetString except it concatentates
//      psz onto *ppszBuf.
//
BOOL    PUBLIC GCatString(LPSTR * ppszBuf, LPCSTR psz);


//
// Shared memory allocation functions.
//
#ifndef NOSHAREDHEAP

//      PVOID SharedAlloc(DWORD cb);
//
//          Alloc a chunk of memory.  Initialize to zero.
//
PVOID   PUBLIC SharedAlloc(DWORD cb);                              

//      PVOID SharedReAlloc(PVOID pv, DWORD cb);
//
//          Realloc memory.  If pv is NULL, then this function will do
//          an alloc for you.  Initializes new portion to zero.
//
PVOID   PUBLIC SharedReAlloc(PVOID pv, DWORD cb);

//      void SharedFree(PVOID pv);
//
//          Free pv if it is nonzero.
//
void    PUBLIC _SharedFree(PVOID pv);
#define SharedFree(pv)                  ((pv) ? _SharedFree(pv) : (void)0)

//      DWORD SharedGetSize(PVOID pv);
//
//          Get the size of a block allocated by SharedAlloc()
//      
DWORD   PUBLIC SharedGetSize(PVOID pv);                      


//      type * SharedAllocType(type);                    (macro)
//
//          Alloc some memory the size of <type> and return 
//          pointer to <type>.
//
#define SharedAllocType(type)           (type *)SharedAlloc(sizeof(type))

//      type * SharedAllocArray(type, DWORD cNum);       (macro)
//
//          Alloc an array of data the size of <type>.  Returns
//          a pointer to <type>.
//
#define SharedAllocArray(type, cNum)    (type *)SharedAlloc(sizeof(type) * (cNum))

//      type * SharedReAllocArray(type, void * pb, DWORD cNum);
//
//          Realloc an array of <type>.  Returns a pointer to
//          <type>.  The returned pointer may differ from the 
//          given <pb> parameter.
//
#define SharedReAllocArray(type, pb, cNum) (type *)SharedReAlloc(pb, sizeof(type) * (cNum))

//      (Re)allocates *ppszBuf and copies psz into *ppszBuf.  If
//      *ppszBuf is NULL, this function allocates memory to hold
//      psz.  If *ppszBuf is non-NULL, this function reallocates
//      memory to hold psz.  If psz is NULL, this function frees
//      *ppszBuf.
//
//      Returns TRUE if successful, FALSE if not.
//
BOOL    PUBLIC SharedSetString(LPSTR * ppszBuf, LPCSTR psz);

#else  // NOSHAREDHEAP

#define SharedAlloc(cbBytes)            GAlloc(cbBytes)
#define SharedReAlloc(pv, cb)           GReAlloc(pv, cb)
#define SharedFree(pv)                  GFree(pv)
#define SharedGetSize(pv)               GGetSize(pv)
#define SharedAllocType(type)           (type *)SharedAlloc(sizeof(type))
#define SharedAllocArray(type, cNum)    (type *)SharedAlloc(sizeof(type) * (cNum))
#define SharedReAllocArray(type, pb, cNum) (type *)SharedReAlloc(pb, sizeof(type) * (cNum))
#define SharedSetString(ppszBuf, psz)   GSetString(ppszBuf, psz)

#endif // NOSHAREDHEAP



#ifndef NODA
//
// Structure Array
//
#define SA_ERR      ((DWORD)(-1))
#define SA_APPEND   NULL

typedef struct _SA FAR * HSA;                                            
typedef HSA *            PHSA;
                                                                          
BOOL    PUBLIC SACreateEx(PHSA phsa, DWORD cbItem, DWORD cItemGrow, HANDLE hheap, DWORD dwFlags);
#define        SACreate(phsa, cbItem, cItemGrow)    SACreateEx(phsa, cbItem, cItemGrow, NULL, SAF_DEFAULT)

// Flags for SACreate
#define SAF_DEFAULT     0x0000
#define SAF_SHARED      0x0001
#define SAF_HEAP        0x0002

typedef void (CALLBACK *PFNSAFREE)(LPVOID pv, LPARAM lParam);

BOOL    PUBLIC SADestroyEx(HSA hsa, PFNSAFREE pfnFree, LPARAM lParam);
#define        SADestroy(hsa)           SADestroyEx(hsa, NULL, 0)

BOOL    PUBLIC SAGetItem(HSA hsa, DWORD iItem, LPVOID pitem);        
BOOL    PUBLIC SAGetItemPtr(HSA hsa, DWORD iItem, LPVOID * ppv);
BOOL    PUBLIC SASetItem(HSA hsa, DWORD iItem, LPVOID pitem);        
BOOL    PUBLIC SAInsertItem(HSA hsa, LPDWORD pindex, LPVOID pitem);     
BOOL    PUBLIC SADeleteItem(HSA hsa, DWORD iItem);                      
BOOL    PUBLIC SADeleteAllItems(HSA hsa);                         
#define        SAGetCount(hsa)          (*(DWORD FAR*)(hsa))             
    
//                                                                      
// Pointer Array
//
#define PA_ERR      ((DWORD)(-1))
#define PA_APPEND   NULL

typedef struct _PA FAR * HPA;                                            
typedef HPA *            PHPA;
                                                                          
BOOL    PUBLIC PACreateEx(PHPA phpa, DWORD cItemGrow, HANDLE hheap, DWORD dwFlags);
#define        PACreate(phpa, cItemGrow)    (PACreateEx(phpa, cItemGrow, NULL, PAF_DEFAULT))

// Flags for PACreate
#define PAF_DEFAULT     0x0000
#define PAF_SHARED      0x0001
#define PAF_HEAP        0x0002

typedef void (CALLBACK *PFNPAFREE)(LPVOID pv, LPARAM lParam);

BOOL    PUBLIC PADestroyEx(HPA hpa, PFNPAFREE pfnFree, LPARAM lParam);
#define        PADestroy(hpa)           PADestroyEx(hpa, NULL, 0)

BOOL    PUBLIC PAClone(PHPA phpa, HPA hpa);                    
BOOL    PUBLIC PAGetPtr(HPA hpa, DWORD i, LPVOID * ppv);                          
BOOL    PUBLIC PAGetPtrIndex(HPA hpa, LPVOID pv, LPDWORD pindex);               
BOOL    PUBLIC PAGrow(HPA pdpa, DWORD cp);                           
BOOL    PUBLIC PASetPtr(HPA hpa, DWORD i, LPVOID p);             
BOOL    PUBLIC PAInsertPtr(HPA hpa, LPDWORD pindex, LPVOID pv);          
LPVOID  PUBLIC PADeletePtr(HPA hpa, DWORD i);
BOOL    PUBLIC PADeleteAllPtrsEx(HPA hpa, PFNPAFREE pfnFree, LPARAM lParam);
#define        PADeleteAllPtrs(hpa)     PADeleteAllPtrsEx(hpa, NULL, 0)
#define        PAGetCount(hpa)          (*(DWORD FAR*)(hpa))
#define        PAGetPtrPtr(hpa)         (*((LPVOID FAR* FAR*)((BYTE FAR*)(hpa) + 2*sizeof(DWORD))))
#define        PAFastGetPtr(hpa, i)     (PAGetPtrPtr(hpa)[i])  

typedef int (CALLBACK *PFNPACOMPARE)(LPVOID p1, LPVOID p2, LPARAM lParam);
                                                                          
BOOL   PUBLIC PASort(HPA hpa, PFNPACOMPARE pfnCompare, LPARAM lParam);
                                                                          
// Search array.  If PAS_SORTED, then array is assumed to be sorted      
// according to pfnCompare, and binary search algorithm is used.          
// Otherwise, linear search is used.                                      
//                                                                        
// Searching starts at iStart (0 to start search at beginning).          
//                                                                        
// PAS_INSERTBEFORE/AFTER govern what happens if an exact match is not   
// found.  If neither are specified, this function returns -1 if no exact 
// match is found.  Otherwise, the index of the item before or after the  
// closest (including exact) match is returned.                           
//                                                                        
// Search option flags                                                    
//                                                                        
#define PAS_SORTED             0x0001                                	  
#define PAS_INSERTBEFORE       0x0002                                    
#define PAS_INSERTAFTER        0x0004                                    
                                                                          
DWORD PUBLIC PASearch(HPA hpa, LPVOID pFind, DWORD iStart,
              PFNPACOMPARE pfnCompare,
              LPARAM lParam, UINT options);
#endif // NODA

#endif // _MEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\nouiutil.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** nouiutil.h
** No UI helper routines (no HWNDs required)
** Public header
**
** 08/25/95 Steve Cobb
*/

#pragma once
#ifndef _NOUIUTIL_H_
#define _NOUIUTIL_H_


/* Maximum length of string returned by LToT without terminating null.
*/
#define MAXLTOTLEN 11

/* Heap allocation macros allowing easy substitution of alternate heap.  These
** are used by the other utility sections.
*/
#ifndef EXCL_HEAPDEFS
#define Malloc(c)    (void*)GlobalAlloc(0,(c))
#define Realloc(p,c) (void*)GlobalReAlloc((p),(c),GMEM_MOVEABLE)
#define Free(p)      (void*)GlobalFree(p)
#endif

/* Bits returned by GetInstalledProtocols.
*/
#define NP_Nbf      0x1
#define NP_Ipx      0x2
#define NP_Ip       0x4
#define NP_Netmon   0x8


/* Definition of comparison function required by ShellSort and
** ShellSortIndirect.
** The comparison is essentially <arg1> - <arg2>, thus the function should
** return negative if the first item is less than the second, zero
** if the items are equal, and positive if the first item is greater
** than the second.
*/
typedef INT (*PFNCOMPARE)( VOID*, VOID* );

/* Linked list library.
*/
#ifndef EXCL_DTL_H
#include <dtl.h>
#endif

/* International formatting library.
*/
#ifndef EXCL_INTL_H
#include <intl.h>
#endif

/* User preference library.
*/
#ifndef EXCL_PBUSER_H
#include <pbuser.h>
#endif

/* RasApi utility library.
*/
#ifndef EXCL_RAUTIL_H
#include <rautil.h>
#endif

/* RasMan utility library.
*/
#ifndef EXCL_RMUTIL_H
#include <rmutil.h>
#endif

/* RAS DLL entrypoint loader library.
*/
#ifndef EXCL_LOADDLLS_H
#include <loaddlls.h>
#endif

/* EAP configuration utility library.
*/
#ifndef EXCL_EAPCFG_H
#include <eapcfg.h>
#endif

/* Node types used by MultiSz calls.
*/
#define NT_Psz 1
#define NT_Kv  2

//
// Defs to determine which entrypoint to load
//
#define CUSTOM_RASDIALDLG           0
#define CUSTOM_RASENTRYDLG          1
#define CUSTOM_RASDIAL              2
#define CUSTOM_RASDELETEENTRYNOTIFY 3

/*----------------------------------------------------------------------------
** Datatypes
**----------------------------------------------------------------------------
*/

/* Key/Value string pair.  The contents of a Kv node.
*/
#define KEYVALUE struct tagKEYVALUE
KEYVALUE
{
    TCHAR* pszKey;
    TCHAR* pszValue;
};

/* RAS-relevant Unimodem settings.
*/
#define UNIMODEMINFO struct tagUNIMODEMINFO
UNIMODEMINFO
{
    BOOL  fHwFlow;
    BOOL  fEc;
    BOOL  fEcc;
    DWORD dwBps;
    BOOL  fSpeaker;
    BOOL  fOperatorDial;
    BOOL  fUnimodemPreTerminal;
    DWORD dwModemProtocol;      // selected modem protocol
    DTLLIST *pListProtocols;    // list of available protocols
};


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

INT
ComparePszNode(
    IN DTLNODE* pNode1,
    IN DTLNODE* pNode2 );

DWORD
CreateDirectoriesOnPath(
    LPTSTR                  pszPath,
    LPSECURITY_ATTRIBUTES   psa);

DTLNODE*
CreateKvNode(
    IN LPCTSTR pszKey,
    IN LPCTSTR pszValue );

DTLNODE*
CreatePszNode(
    IN LPCTSTR psz );

VOID
DestroyKvNode(
    IN DTLNODE* pdtlnode );

VOID
DestroyPszNode(
    IN DTLNODE* pdtlnode );

BOOL
DeviceAndPortFromPsz(
    IN  TCHAR*  pszDP,
    OUT TCHAR** ppszDevice,
    OUT TCHAR** ppszPort );

DTLNODE*
DuplicateKvNode(
    IN DTLNODE* pdtlnode );

DTLNODE*
DuplicatePszNode(
    IN DTLNODE* pdtlnode );

BOOL
FFileExists(
    IN TCHAR* pszPath );

BOOL
FIsTcpipInstalled();

BOOL
FIsUserAdminOrPowerUser();

VOID*
Free0(
    VOID* p );

//for utilsys.c
TCHAR*
GetComputer(
    void );

TCHAR*
GetLogonDomain(
    void );

TCHAR*
GetLogonUser(
    void );


// For whistler 480871  gangz
//
DWORD
RasSrvIsRRASConfigured(
    OUT BOOL * pfConfig);

    
BOOL
IsFirewallAvailablePlatform(
    void);

BOOL
IsAdvancedServerPlatform(
    void);

BOOL
IsPersonalPlatform(
    void);

BOOL
IsStandaloneWKS(
    void);

BOOL
IsConsumerPlatform(
    void);
    
//end of definitions for utilsys.c

DWORD
GetInstalledProtocols(
    VOID );

DWORD
GetInstalledProtocolsEx(
    HANDLE hConnection,
    BOOL fRouter,
    BOOL fRasCli,
    BOOL fRasSrv );

VOID
GetRegBinary(
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT BYTE** ppbResult,
    OUT DWORD* pcbResult );

VOID
GetRegDword(
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT DWORD* pdwResult );

DWORD
GetRegExpandSz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT TCHAR** ppszResult );

DWORD
GetRegMultiSz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    IN OUT DTLLIST** ppListResult,
    IN DWORD dwNodeType );

DWORD
GetRegSz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT TCHAR** ppszResult );

DWORD
GetRegSzz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT TCHAR** ppszResult );

CHAR
HexChar(
    IN BYTE byte );

BYTE
HexValue(
    IN CHAR byte );

void
IpHostAddrToPsz(
    IN  DWORD   dwAddr,
    OUT LPTSTR  pszBuffer );

BOOL
IsAllWhite(
    IN LPCTSTR psz );

BOOL
IsNullTerminatedA(
    IN CHAR* psz,
    IN DWORD dwSize );

DWORD
IpPszToHostAddr(
    IN  LPCTSTR cp );

DWORD
GetRasUnimodemBlob(
    IN  HANDLE hConnection,
    IN  HPORT  hport,
    IN  CHAR*  pszDeviceType,
    OUT BYTE** ppBlob,
    OUT DWORD* pcbBlob );

DWORD
GetRasUnimodemBlobEx(
    IN  HANDLE hConnection,
    IN  HPORT  hport,
    IN  CHAR*  pszDeviceType,
    IN  BOOL   fGlobal,
    OUT BYTE** ppBlob,
    OUT DWORD* pcbBlob );

VOID
GetRasUnimodemInfo(
    IN  HANDLE        hConnection,
    IN  HPORT         hport,
    IN  CHAR*         pszDeviceType,
    OUT UNIMODEMINFO* pInfo );

TCHAR*
LToT(
    LONG   lValue,
    TCHAR* pszBuf,
    INT    nRadix );

TCHAR*
PszFromDeviceAndPort(
    IN TCHAR* pszDevice,
    IN TCHAR* pszPort );

LPCTSTR
PszLoadStringPcch (
        HINSTANCE   hinst,
        UINT        unId,
        int*        pcch);

LPCTSTR
PszLoadString (
        HINSTANCE   hinst,
        UINT        unId);

DWORD
RegDeleteTree(
    IN HKEY RootKey,
    IN TCHAR* SubKeyName );

BOOL
RegValueExists(
    IN HKEY hkey,
    IN TCHAR* pszValue );

BOOL
RestartComputer();

TCHAR*
StripPath(
    IN TCHAR* pszPath );

LONG
TToL(
    TCHAR *pszBuf );

TCHAR*
PszFromError(
    IN DWORD dwError );

TCHAR*
PszFromId(
    IN HINSTANCE hInstance,
    IN DWORD     dwStringId );

BOOL
RestartComputer();

VOID
SanitizeUnimodemBlob(
    IN OUT BYTE* pBlob );

VOID
SetDefaultUnimodemInfo(
    OUT UNIMODEMINFO* pInfo );

HFONT
SetFont(
    HWND   hwndCtrl,
    TCHAR* pszFaceName,
    BYTE   bfPitchAndFamily,
    INT    nPointSize,
    BOOL   fUnderline,
    BOOL   fStrikeout,
    BOOL   fItalic,
    BOOL   fBold );

DWORD
SetRegDword(
    IN HKEY hkey,
    IN TCHAR* pszName,
    IN DWORD dwValue );

DWORD
SetRegMultiSz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    IN DTLLIST* pListValues,
    IN DWORD dwNodeType );

DWORD
SetRegSz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    IN TCHAR* pszValue );

DWORD
SetRegSzz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    IN TCHAR* pszValue );

DWORD
ShellSort(
    IN VOID*        pItemTable,
    IN DWORD        dwItemSize,
    IN DWORD        dwItemCount,
    IN PFNCOMPARE   pfnCompare );

VOID
ShellSortIndirect(
    IN VOID*        pItemTable,
    IN VOID**       ppItemTable,
    IN DWORD        dwItemSize,
    IN DWORD        dwItemCount,
    IN PFNCOMPARE   pfnCompare );

TCHAR*
StrDup(
    LPCTSTR psz );

CHAR*
StrDupAFromT(
    LPCTSTR psz );

CHAR*
StrDupAFromTAnsi(
    LPCTSTR psz);
    
TCHAR*
StrDupTFromA(
    LPCSTR psz );

TCHAR*
StrDupTFromW(
    LPCWSTR psz );

WCHAR*
StrDupWFromA(
    LPCSTR psz );

TCHAR*
StrDupTFromAUsingAnsiEncoding(
    LPCSTR psz );
    
WCHAR*
StrDupWFromAUsingAnsiEncoding(
    LPCSTR psz );
    
WCHAR*
StrDupWFromT(
    LPCTSTR psz );

DWORD
StrCpyWFromA(
    WCHAR* pszDst,
    LPCSTR pszSrc,
    DWORD dwDstChars);
    
DWORD
StrCpyAFromW(
    LPSTR pszDst,
    LPCWSTR pszSrc, 
    DWORD dwDstChars);
    
DWORD
StrCpyWFromAUsingAnsiEncoding(
    WCHAR* pszDst,
    LPCSTR pszSrc,
    DWORD dwDstChars);
    
DWORD
StrCpyAFromWUsingAnsiEncoding(
    LPSTR pszDst,
    LPCWSTR pszSrc, 
    DWORD dwDstChars);
    
int
StrNCmpA(
    IN CHAR* psz1,
    IN CHAR* psz2,
    IN INT   nLen );

CHAR*
StrStrA(
    IN CHAR* psz1,
    IN CHAR* psz2 );

VOID
UnimodemInfoFromBlob(
    IN  BYTE*         pBlob,
    OUT UNIMODEMINFO* pInfo );

VOID
UnimodemInfoToBlob(
    IN     UNIMODEMINFO* pInfo,
    IN OUT BYTE*         pBlob );

TCHAR*
UnNull(
    TCHAR* psz );

#endif // _NOUIUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\pbk.h ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// pbk.h
// Remote Access phonebook file (.PBK) library
// Public header
//
// 06/20/95 Steve Cobb


#ifndef _PBK_H_
#define _PBK_H_


#include <windows.h>  // Win32 core
#include <nouiutil.h> // No-HWNDs utility library
#include <ras.h>      // Win32 RAS
#include <raserror.h> // Win32 RAS error codes
#include <rasfile.h>  // RAS configuration file library
#include <rasman.h>   // RAS Manager library
#include <rpc.h>      // UUID support
#include <rasapip.h>

//----------------------------------------------------------------------------
// Constants
//----------------------------------------------------------------------------

#define GLOBALSECTIONNAME    "."
#define GLOBALSECTIONNAMENEW ".GlobalSection"
#define PREFIXSECTIONNAME    ".Prefix"
#define SUFFIXSECTIONNAME    ".Suffix"

#define GROUPID_Media          "MEDIA="
#define GROUPKEY_Media         "MEDIA"
#define GROUPID_Device         "DEVICE="
#define GROUPKEY_Device        "DEVICE"
#define GROUPID_NetComponents  "NETCOMPONENTS="
#define GROUPKEY_NetComponents "NETCOMPONENTS"

// Project-specific maximums
//
// Note that the pbk and API use a different redial maximum than the RasDlg UI.
#define MAX_UI_REDIAL_ATTEMPTS  99
#define MAX_UI_REDIAL_CHARS     2
#define RAS_MaxRedialCount      999999999
#define RAS_RedialPause10m      600         // 600 seconds=10 min

// Pbport flags
//
#define PBP_F_PptpDevice    0x00000001
#define PBP_F_L2tpDevice    0x00000002
#define PBP_F_NullModem     0x00000004
#define PBP_F_BogusDevice   0x00000008      // pmay: 233287
#define PBP_F_PPPoEDevice   0x00000010      // gangz:whistler 345068

// ReadPhonebookFile flags
//
#define RPBF_ReadOnly    0x00000001
#define RPBF_HeadersOnly 0x00000002
#define RPBF_NoList      0x00000004
#define RPBF_NoCreate    0x00000008
#define RPBF_Router      0x00000010
#define RPBF_NoUser      0x00000020
#define RPBF_HeaderType  0x00000040
#define RPBF_AllUserPbk  0x00000080  // If no path, then global .pbk 346918

// PBENTRY.dwUsage
#define PBK_ENTRY_USE_F_Internet    0x1     // connection to Internet

// Base protocol definitions (see dwBaseProtocol).
//
#define BP_Ppp      1
#define BP_Slip     2
#define BP_Ras      3

#ifdef AMB

// Authentication strategy definitions (see dwAuthentication).
//
#define AS_Default    -1
#define AS_PppThenAmb 0
#define AS_AmbThenPpp 1
#define AS_PppOnly    2
#define AS_AmbOnly    3

#endif

// Net protocol bit definitions (see dwfExcludedProtocols)
//
// (The NP_* definitions have moved to nouiutil.h with the
//  GetInstalledProtocols routine)

// IP address source definitions (see dwIpAddressSource)
//
#define ASRC_ServerAssigned  1 // For router means "the ones in NCPA"
#define ASRC_RequireSpecific 2
#define ASRC_None            3 // Router only

// Security restrictions on authentication (see dwAuthRestrictions)
//
// Note: AR_AuthTerminal is defunct and is not written to the phonebook by the
//       new library.  It is, however, read and translated into AR_AuthAny,
//       fAutoLogon=0, and an after dialing terminal.
//
// Note: The AR_AuthXXX ordinals are replaced with AR_F_AuthXXX flags in NT5
//       to support the fact that these flags are not mutually exclusive.
//       You'll know if you need to upgrade the dwAuthRestrictions variable
//       because old phone books have this value set to 0 or have some of the
//       bottom 3 bits set.
//
// Note: The AR_F_AuthCustom bit is used a little differently.  It indicates
//       that the settings are made in "advanced" mode rather than "typical"
//       mode.  In "typical" mode the bits MUST correspond to one of the
//       AR_F_TypicalXxx sets.
//
// Note: The AR_F_AuthEAP bit is mutually exclusive of all other bits, except
//       the AR_F_AuthCustom bit.  When AR_F_AuthEap is specified without the
//       AR_F_AuthCustom bit EAP_TLS_PROTOCOL should be assumed.
//
// Note: The AR_F_AuthW95MSCHAP flag will not be set in the UI unless
//       AR_F_AuthMSCHAP is set.  This is a usability decision to steer user
//       away from misinterpreting the meaning of the W95 bit.
//
// The old scalar values (which should no eliminated from all non-PBK-upgrade
// code).
//
#define AR_AuthAny         0  // Upgrade to AR_F_TypicalUnsecure
#define AR_AuthTerminal    1  // Eliminate during upgrade
#define AR_AuthEncrypted   2  // Upgrade to AR_F_TypicalSecure
#define AR_AuthMsEncrypted 3  // Upgrade to AR_F_AuthMSCHAP
#define AR_AuthCustom      4  // Upgrade ORs in AR_F_AuthEAP

// The new bitmask style flags.
//
#define AR_F_AuthPAP       0x00000008
#define AR_F_AuthSPAP      0x00000010
#define AR_F_AuthMD5CHAP   0x00000020
#define AR_F_AuthMSCHAP    0x00000040
#define AR_F_AuthEAP       0x00000080  // See note above
#define AR_F_AuthCustom    0x00000100  // See note above
#define AR_F_AuthMSCHAP2   0x00000200
#define AR_F_AuthW95MSCHAP 0x00000400  // See note above

// the bitmask for IPSec Policy
#define AR_F_IpSecPSK               0x1
#define AR_F_IpSecUserCerts         0x2
#define AR_F_IpSecSpecificCerts     0x4

#define AR_F_AuthAnyMSCHAP (AR_F_AuthMSCHAP | AR_F_AuthW95MSCHAP | AR_F_AuthMSCHAP2)
#define AR_F_AuthNoMPPE    (AR_F_AuthPAP | AR_F_AuthSPAP | AR_F_AuthMD5CHAP)

// "Typical" authentication setting masks.  See 'dwAuthRestrictions'.
//
#define AR_F_TypicalUnsecure   (AR_F_AuthPAP | AR_F_AuthSPAP | AR_F_AuthMD5CHAP | AR_F_AuthMSCHAP | AR_F_AuthMSCHAP2)
#define AR_F_TypicalSecure     (AR_F_AuthMD5CHAP | AR_F_AuthMSCHAP | AR_F_AuthMSCHAP2)
#define AR_F_TypicalCardOrCert (AR_F_AuthEAP)

// "Typical" authentication setting constants.  See 'dwTypicalAuth'.
//
#define TA_Unsecure   1
#define TA_Secure     2
#define TA_CardOrCert 3

// Script mode (see dwScriptMode)
//
#define SM_None               0
#define SM_Terminal           1
#define SM_ScriptWithTerminal 2
#define SM_ScriptOnly         3

// Miscellaneous "no value" constants.
//
#define XN_None  0   // No X25 network
#define CPW_None -1  // No cached password

// Description field.  Move to ras.h if/when supported by
// RasGet/SetEntryProperties API.
//
#define RAS_MaxDescription 200

// 'OverridePref' bits.  Set indicates the corresponding value read from the
// phonebook should be used.  Clear indicates the global user preference
// should be used.
//
#define RASOR_RedialAttempts          0x00000001 // Always set in NT5
#define RASOR_RedialSeconds           0x00000002 // Always set in NT5
#define RASOR_IdleDisconnectSeconds   0x00000004 // Always set in NT5
#define RASOR_RedialOnLinkFailure     0x00000008 // Always set in NT5
#define RASOR_PopupOnTopWhenRedialing 0x00000010
#define RASOR_CallbackMode            0x00000020

// 'DwDataEncryption' codes.  These are now bitmask-ish for the convenience of
// the UI in building capability masks, though more than one bit will never be
// set in 'dwDataEncryption'.
//
#define DE_None          0x00000000 // Do not encrypt
#define DE_IfPossible    0x00000008 // Request encryption but none OK
#define DE_Require       0x00000100 // Require encryption of any strength
#define DE_RequireMax    0x00000200 // Require maximum strength encryption

// The following bit values are now defunct and are converted during phonebook
// upgrade to one of the above set.  References should be eliminated from
// non-PBK code.
//
#define DE_Mppe40bit    0x00000001 // Old DE_Weak. Setting for "Always encrypt data"
#define DE_Mppe128bit   0x00000002 // Old De_Strong. Setting for "Always encrypt data"
#define DE_IpsecDefault 0x00000004 // Setting for "Always encrypt data" for l2tp
#define DE_VpnAlways    0x00000010 // Setting for vpn conn to "Always encrypt data"
#define DE_PhysAlways   (DE_Mppe40bit | DE_Mppe128bit)

// 'dwDnsFlags' settings
//
// Used to determine the dns suffix registration behavior for an entry
//
// When 'dwDnsFlags' is 0, it means 'do not register'
//
#define DNS_RegPrimary         0x1     // register w/ primary domain suffix
#define DNS_RegPerConnection   0x2     // register w/ per-connection suffix
#define DNS_RegDhcpInform      0x4     // register w/ dhcp informed suffix
#define DNS_RegDefault         (DNS_RegPrimary)

// 'dwIpNbtFlags' settings
//
// Used to determine the whether to enable nbt over tcpip for the connection
//
#define PBK_ENTRY_IP_NBT_Enable 1

//-----------------------------------------------------------------------------
// Data types
//-----------------------------------------------------------------------------

// Provides shorthand to identify devices without re-parsing RAS Manager
// strings.  "Other" is anything not recognized as another specific type.
//
// Note: This datatype is stored in the registry preferences so the values
//       must not change over time.  For this reason, I have hard-coded the
//       value of each enumberated type.
//
typedef enum
_PBDEVICETYPE
{
    PBDT_None = 0,
    PBDT_Null = 1,
    PBDT_Other = 2,
    PBDT_Modem = 3,
    PBDT_Pad = 4,
    PBDT_Switch = 5,
    PBDT_Isdn = 6,
    PBDT_X25 = 7,
    PBDT_ComPort = 8,           // added for dcc wizard (nt5)
    PBDT_Irda = 10,             // added for nt5
    PBDT_Vpn = 11,
    PBDT_Serial = 12,
    PBDT_Atm = 13,
    PBDT_Parallel = 14,
    PBDT_Sonet = 15,
    PBDT_Sw56 = 16,
    PBDT_FrameRelay = 17,
    PBDT_PPPoE = 18
}
PBDEVICETYPE;


// RAS port information read from RASMAN.
//
// Each port (and link) is uniquely identified by port name.  If it were only
// that simple...
//
// In the old RAS model, the port name was the unique identifier that was
// presented to the user, and the user can have two same-type devices on two
// different ports.
//
// In TAPI/Unimodem, the "friendly" device name is the unique identifier
// that's presented to the user and the corresponding port is a property of
// the device.  If the port is changed and you dial it still finds the device
// you originally selected.  If you swap two devices on two ports it uses the
// one with the matching unique device name.  NT5 will follow this model.
//
typedef struct
_PBPORT
{
    // The port name is always unique, if configured.  Unconfigured port names
    // might not be unique.  This is never NULL.
    //
    TCHAR* pszPort;

    // Indicates the port is actually configured and not a remnant of an old
    // configuration read from the phonebook.
    //
    BOOL fConfigured;

    // The device name is the one from RASMAN when 'fConfigured' or the one
    // from the phonebook if not.  May be NULL with unconfigured ports as it
    // was not stored in old phonebooks.
    //
    TCHAR* pszDevice;

    // The media as it appears in the MEDIA= lines in the phonebook.  This is
    // usually but not always (for obscure historical reasons) the same as the
    // RASMAN media.  See PbMedia.
    //
    TCHAR* pszMedia;

    // Shorthand device type code derived from the RASMAN device type string.
    //
    PBDEVICETYPE pbdevicetype;

    // RASET_* entry type code of the link.  This is provided for the
    // convenience of the UI during link configuration.
    //
    DWORD dwType;

    // PBP_F_* flags that yield additional information concerning this port
    // that may be of use in rendering UI.
    DWORD dwFlags;

    // These are default settings read from RASMAN and are valid for modems
    // only.  See AppendPbportToList.
    //
    DWORD dwBpsDefault;
    BOOL fHwFlowDefault;
    BOOL fEcDefault;
    BOOL fEccDefault;
    DWORD fSpeakerDefault;
    DWORD dwModemProtDefault;
    DTLLIST* pListProtocols;

    // These are valid only for modems.
    //
    BOOL fScriptBeforeTerminal;
    BOOL fScriptBefore;
    TCHAR* pszScriptBefore;
}
PBPORT;


// Phonebook entry link phone number information.
//
typedef struct
_PBPHONE
{
    TCHAR* pszAreaCode;
    DWORD dwCountryCode;
    DWORD dwCountryID;
    TCHAR* pszPhoneNumber;
    BOOL fUseDialingRules;
    TCHAR* pszComment;
}
PBPHONE;


// Phonebook entry link information.  One per link, multiple per multi-link.
//
typedef struct
_PBLINK
{
    // Information about the port/device to which this link is attached.
    //
    PBPORT pbport;

    // These fields are set for modems only.  See SetDefaultModemSettings.
    //
    DWORD dwBps;
    BOOL fHwFlow;
    BOOL fEc;
    BOOL fEcc;
    DWORD fSpeaker;
    DWORD dwModemProtocol;          // pmay: 228565

    // These fields are set for ISDN only.  'LChannels' and 'fCompression' are
    // not used unless 'fProprietaryIsdn' is set.
    //
    BOOL fProprietaryIsdn;
    LONG lLineType;
    BOOL fFallback;
    BOOL fCompression;
    LONG lChannels;

    // Address and size of opaque device configuration block created/edited by
    // TAPI.  Currently, there are no TAPI devices that provide blob-editing
    // acceptable to RAS so these field are unused.
    //
    BYTE* pTapiBlob;
    DWORD cbTapiBlob;

    // Phone number information for the link.
    //
    // Note: The 'iLastSelectedPhone' field is used only when
    //       'fTryNextAlternateOnFail' is clear.  Otherwise, it is ignored and
    //       assumed 0 (top of list).  See bug 150958.
    //
    DTLLIST* pdtllistPhones;
    DWORD iLastSelectedPhone;
    BOOL fPromoteAlternates;
    BOOL fTryNextAlternateOnFail;

    // Indicates the link is enabled.  All links appearing in the file are
    // enabled.  This is provided for the convenience of the UI during link
    // configuration.
    //
    BOOL fEnabled;
}
PBLINK;


// Phonebook entry information.
//
typedef struct
_PBENTRY
{
    // Arbitrary name of entry and it's RASET_* entry type code.
    //
    TCHAR* pszEntryName;
    DWORD dwType;

    // General page fields.
    //
    DTLLIST* pdtllistLinks;
    BOOL fSharedPhoneNumbers;
    BOOL fGlobalDeviceSettings;         // whistler bug 281306
    BOOL fShowMonitorIconInTaskBar;
    TCHAR* pszPrerequisiteEntry;
    TCHAR* pszPrerequisitePbk;
    TCHAR* pszPreferredPort;
    TCHAR* pszPreferredDevice;

    //For .Net 639551
    //
    DWORD  dwPreferredBps;             // Port Speed
    BOOL   fPreferredHwFlow;           // Hardware Flow Control           
    BOOL   fPreferredEc;               // Error control protocol
    BOOL   fPreferredEcc;              // Compression Control
    DWORD  fPreferredSpeaker;          // Enable Modem Speaker
    
    DWORD  dwPreferredModemProtocol;    //For whislter bug 402522

    // Options page fields.
    //
    // Note: Fields marked (1) are ignored when 'fAutoLogon' is set.  Field
    //       marked (2) *may* be set when 'fPreviewUserPw' is not also set.
    //       In this case it means to include the domain in the authentication
    //       but to to prompt only when the 'fPreviewUserPw' is set.
    //       Otherwise, "save PW" with a domain does not include the domain
    //       (MarkL problem) which is wrong.  See also bug 212963 and 261374.
    //
    BOOL fShowDialingProgress;
    BOOL fPreviewUserPw;          // See above: 1
    BOOL fPreviewDomain;          // See above: 1, 2
    BOOL fPreviewPhoneNumber;

    DWORD dwDialMode;
    DWORD dwDialPercent;
    DWORD dwDialSeconds;
    DWORD dwHangUpPercent;
    DWORD dwHangUpSeconds;

    // How the connection was configured to be used.  
    //
    DWORD dwUseFlags;      // See PBK_ENTRY_USE_F_*
    
    // IPSec Policy fields for whisler bug 193987 gangz
    //
    DWORD dwIpSecFlags;

    // These fields are used in place of the equivalent user preference only
    // when the corresponding 'dwfOverridePref' bit is set.  In NT5, the
    // indicated fields become always per-entry, i.e. the corresponding
    // override bits are always set.
    //
    DWORD dwfOverridePref;

    DWORD dwRedialAttempts;       // Always per-entry in NT5
    DWORD dwRedialSeconds;        // Always per-entry in NT5
    LONG lIdleDisconnectSeconds;  // Always per-entry in NT5
    BOOL fRedialOnLinkFailure;    // Always per-entry in NT5

    // Security page fields.
    //
    DWORD dwAuthRestrictions;
    DWORD dwVpnStrategy;          // Valid for vpn entries only.  see VS_xxx
    DWORD dwDataEncryption;
    BOOL fAutoLogon;              // See dependencies on Option page flags
    BOOL fUseRasCredentials;

    // The selection in the "Typical" security listbox.  This is for the UI's
    // use only.  Others should refer to 'dwAuthRestrictions' for this
    // information.
    //
    DWORD dwTypicalAuth;

    // Note: CustomAuth fields have meaning only when dwAuthRestrictions
    //       includes AR_F_AuthCustom.  If the AR_F_Eap flag is set without
    //       AR_F_AuthCustom, it should be assumed to be the
    //       'EAPCFG_DefaultKey' protocol, currently EAP_TLS_PROTOCOL.
    //
    DWORD dwCustomAuthKey;
    BYTE* pCustomAuthData;
    DWORD cbCustomAuthData;

    BOOL fScriptAfterTerminal;
    BOOL fScriptAfter;
    TCHAR* pszScriptAfter;
    DWORD dwCustomScript;

    TCHAR* pszX25Network;
    TCHAR* pszX25Address;
    TCHAR* pszX25UserData;
    TCHAR* pszX25Facilities;

    // Network page fields.
    //
    DWORD dwBaseProtocol;
    DWORD dwfExcludedProtocols;
    BOOL fLcpExtensions;
    BOOL fSwCompression;
    BOOL fNegotiateMultilinkAlways;
    BOOL fSkipNwcWarning;
    BOOL fSkipDownLevelDialog;
    BOOL fSkipDoubleDialDialog;

    BOOL fShareMsFilePrint;
    BOOL fBindMsNetClient;

    // List of KEYVALUE nodes containing any key/value pairs found in the
    // NETCOMPONENT group of the entry.
    //
    DTLLIST* pdtllistNetComponents;

#ifdef AMB

    // Note: dwAuthentication is read-only.  The phonebook file value of this
    //       parameter is set by the RasDial API based on the result of
    //       authentication attempts.
    //
    DWORD dwAuthentication;

#endif

    // TCPIP settings sheet PPP or SLIP configuration information.
    // 'DwBaseProtocol' determines which.
    //
    BOOL fIpPrioritizeRemote;
    BOOL fIpHeaderCompression;
    TCHAR* pszIpAddress;
    TCHAR* pszIpDnsAddress;
    TCHAR* pszIpDns2Address;
    TCHAR* pszIpWinsAddress;
    TCHAR* pszIpWins2Address;
    DWORD dwIpAddressSource; // PPP only
    DWORD dwIpNameSource;    // PPP only
    DWORD dwFrameSize;       // SLIP only
    DWORD dwIpDnsFlags;        // DNS_* values
    DWORD dwIpNbtFlags;      // PBK_ENTRY_IP_NBT_*
    DWORD dwTcpWindowSize;   // Whistler bug 300933. 0=default
    TCHAR* pszIpDnsSuffix;     // The dns suffix for this connection

    // Router page.
    //
    DWORD dwCallbackMode;
    BOOL fAuthenticateServer;

    // Other fields not shown in UI.
    //
    TCHAR* pszCustomDialDll;
    TCHAR* pszCustomDialFunc;

    //
    // custom dialer name
    //
    TCHAR* pszCustomDialerName;

    // The UID of the cached password is fixed at entry creation.  The GUID is
    // also created at entry creation and used for inter-machine uniqueness.
    // This is currently used to identify an IP configuration to the external
    // TCP/IP dialogs.
    //
    DWORD dwDialParamsUID;
    GUID* pGuid;

    // To translate user's old entries, the user name and domain are read and
    // used as authentication defaults if no cached credentials exist.  They
    // are not rewritten to the entry.
    //
    TCHAR* pszOldUser;
    TCHAR* pszOldDomain;

    // Status flags.  'fDirty' is set when the entry has changed so as to
    // differ from the phonebook file on disk.  'fCustom' is set when the
    // entry contains a MEDIA and DEVICE (so RASAPI is able to read it) but
    // was not created by us.  When 'fCustom' is set only 'pszEntry' is
    // guaranteed valid and the entry cannot be edited.
    //
    BOOL fDirty;
    BOOL fCustom;
}
PBENTRY;


// Phonebook (.PBK) file information.
//
typedef struct
_PBFILE
{
    // Handle of phone book file.
    //
    HRASFILE hrasfile;

    // Fully qualified path to the phonebook.
    //
    TCHAR* pszPath;

    // Phonebook mode, system, personal, or alternate.
    //
    DWORD dwPhonebookMode;

    // Unsorted list of PBENTRY.  The list is manipulated by the Entry
    // dialogs.
    //
    DTLLIST* pdtllistEntries;

    HANDLE hConnection;
}
PBFILE;

typedef void (WINAPI *PBKENUMCALLBACK)( PBFILE *, VOID * );


// The callback number for a device.  This type is a node in the
// 'pdllistCallbackNumbers' below.
//
typedef struct
_CALLBACKNUMBER
{
    TCHAR* pszDevice;
    TCHAR* pszCallbackNumber;
}
CALLBACKNUMBER;


//----------------------------------------------------------------------------
// Prototypes
//----------------------------------------------------------------------------

VOID
ChangeEntryType(
    PBENTRY* ppbentry,
    DWORD dwType );

DTLNODE*
CloneEntryNode(
    DTLNODE* pdtlnodeSrc );

VOID
ClosePhonebookFile(
    IN OUT PBFILE* pFile );

DWORD
CopyToPbport(
    IN PBPORT* ppbportDst,
    IN PBPORT* ppbportSrc );

DTLNODE*
CreateEntryNode(
    BOOL fCreateLink );

DTLNODE*
CreateLinkNode(
    void );

DTLNODE*
CreatePhoneNode(
    void );

DTLNODE*
CreatePortNode(
    void );

VOID
DestroyEntryNode(
    IN DTLNODE* pdtlnode );

VOID
DestroyEntryTypeNode(
    IN DTLNODE *pdtlnode );

VOID
DestroyLinkNode(
    IN DTLNODE* pdtlnode );

VOID
DestroyPhoneNode(
    IN DTLNODE* pdtlnode );

VOID
DestroyPortNode(
    IN DTLNODE* pdtlnode );

VOID
DestroyProtocolNode(
    IN DTLNODE* pdtlnode );

DTLNODE*
DuplicateEntryNode(
    DTLNODE* pdtlnodeSrc );

DTLNODE*
DuplicateLinkNode(
    IN DTLNODE* pdtlnodeSrc );


DTLNODE*
DuplicatePhoneNode(
    IN DTLNODE* pdtlnodeSrc );

DTLNODE*
DuplicateProtocolNode(
    IN DTLNODE* pdtlnodeSrc );

VOID
EnableOrDisableNetComponent(
    IN PBENTRY* pEntry,
    IN LPCTSTR  pszComponent,
    IN BOOL     fEnable);

BOOL
FIsNetComponentListed(
    IN PBENTRY*     pEntry,
    IN LPCTSTR      pszComponent,
    OUT BOOL*       pfEnabled,
    OUT KEYVALUE**  ppKv);

DTLNODE*
EntryNodeFromName(
    IN DTLLIST* pdtllistEntries,
    IN LPCTSTR pszName );

DWORD
EntryTypeFromPbport(
    IN PBPORT* ppbport );

BOOL
GetDefaultPhonebookPath(
    IN DWORD dwFlags,
    OUT TCHAR** ppszPath );

DWORD
GetOverridableParam(
    IN PBUSER* pUser,
    IN PBENTRY* pEntry,
    IN DWORD dwfRasorBit );

BOOL
GetPhonebookPath(
    IN PBUSER* pUser,
    IN DWORD dwFlags,
    OUT TCHAR** ppszPath,
    OUT DWORD* pdwPhonebookMode );

BOOL
GetPhonebookDirectory(
    IN DWORD dwPhonebookMode,
    OUT TCHAR* pszPathBuf );

BOOL
GetPersonalPhonebookPath(
    IN TCHAR* pszFile,
    OUT TCHAR* pszPathBuf );

BOOL
GetPublicPhonebookPath(
    OUT TCHAR* pszPathBuf );

DWORD
InitializePbk(
    void );

DWORD
InitPersonalPhonebook(
    OUT TCHAR** ppszFile );

BOOL
IsPublicPhonebook(
    IN LPCTSTR pszPhonebookPath );

DWORD
ReadEntryFromSystem(
    IN  LPCTSTR          pszPhonebook,
    IN  LPCTSTR          pszEntry,
    IN  DWORD            dwFlags,
    IN  OUT PBFILE       *pFile,
    OUT DTLNODE          **ppdtlnode,
    OUT OPTIONAL WCHAR   **ppszFullPath);
    
DWORD
GetPbkAndEntryName(
    IN  LPCTSTR          pszPhonebook,
    IN  LPCTSTR          pszEntry,
    IN  DWORD            dwFlags,
    OUT PBFILE           *pFile,
    OUT DTLNODE          **ppdtlnode);

DWORD
LoadPadsList(
    OUT DTLLIST** ppdtllistPads );

DWORD
LoadPhonebookFile(
    IN TCHAR* pszPhonebookPath,
    IN TCHAR* pszSection,
    IN BOOL fHeadersOnly,
    IN BOOL fReadOnly,
    OUT HRASFILE* phrasfile,
    OUT BOOL* pfPersonal );

DWORD
LoadPortsList(
    OUT DTLLIST** ppdtllistPorts );

DWORD
LoadPortsList2(
    IN  HANDLE hConnection,
    OUT DTLLIST** ppdtllistPorts,
    IN  BOOL fRouter );

DWORD
LoadScriptsList(
    IN  HANDLE    hConnection,
    OUT DTLLIST** ppdtllistScripts );

PBDEVICETYPE
PbdevicetypeFromPszType(
    IN TCHAR* pszDeviceType );

PBDEVICETYPE
PbdevicetypeFromPszTypeA(
    IN CHAR* pszDeviceType );

PBPORT*
PpbportFromPortAndDeviceName(
    IN DTLLIST* pdtllistPorts,
    IN TCHAR* pszPort,
    IN TCHAR* pszDevice );

PBPORT*
PpbportFromNT4PortandDevice(
    IN DTLLIST* pdtlllistPorts,
    IN TCHAR*   pszPort,
    IN TCHAR*   pszDevice);

DWORD
RdtFromPbdt(PBDEVICETYPE pbdt,
            DWORD dwFlags);

DWORD
CalculatePhonebookPath(
    IN LPCTSTR pszPhonebookPath,
    IN PBUSER* pUser,
    IN DWORD dwFlags,
    OUT DWORD* lpdwMode,
    OUT LPTSTR* ppszFullPath);

DWORD
ReadPhonebookFile(
    IN LPCTSTR pszPhonebookPath,
    IN PBUSER* pUser,
    IN LPCTSTR pszSection,
    IN DWORD dwFlags,
    OUT PBFILE* pFile );

TCHAR *pszDeviceTypeFromRdt(
    RASDEVICETYPE rdt);

BOOL
SetDefaultModemSettings(
    IN PBLINK* pLink );

DWORD
SetPersonalPhonebookInfo(
    IN BOOL fPersonal,
    IN TCHAR* pszPath );

VOID
TerminatePbk(
    void );

DWORD
WritePhonebookFile(
    IN PBFILE* pFile,
    IN LPCTSTR pszSectionToDelete );

DWORD
UpgradePhonebookFile(
    IN LPCTSTR pszPhonebookPath,
    IN PBUSER* pUser,
    OUT BOOL* pfUpgraded );

BOOL
ValidateAreaCode(
    IN OUT TCHAR* pszAreaCode );

BOOL
ValidateEntryName(
    IN LPCTSTR pszEntry );


BOOL 
IsRouterPhonebook(LPCTSTR pszPhonebook);

DWORD
DwPbentryToDetails(
    IN  PBENTRY* pEntry,
    IN  LPCWSTR pszPhonebookPath,
    IN  BOOL fIsAllUsersPbk,
    OUT RASENUMENTRYDETAILS* pDetails);

DWORD
DwSendRasNotification(
    IN RASEVENTTYPE     Type,
    IN PBENTRY*         pEntry,
    IN LPCTSTR          pszPhonebookPath,
    IN HANDLE           hData);             // Extra Type-specific info

DWORD
DwGetCustomDllEntryPoint(
        LPCTSTR    lpszPhonebook,
        LPCTSTR    lpszEntry,
        BOOL       *pfCustomDllSpecified,
        FARPROC    *pfnCustomEntryPoint,
        HINSTANCE  *phInstDll,
        DWORD      dwFnId,
        LPTSTR     pszCustomDialerName
        );

DWORD
DwCustomDialDlg(
        LPTSTR          lpszPhonebook,
        LPTSTR          lpszEntry,
        LPTSTR          lpszPhoneNumber,
        LPRASDIALDLG    lpInfo,
        DWORD           dwFlags,
        BOOL            *pfStatus,
        PVOID           pvInfo,
        LPTSTR          pszCustomDialer);


DWORD
DwCustomEntryDlg(
        LPTSTR          lpszPhonebook,
        LPTSTR          lpszEntry,
        LPRASENTRYDLG   lpInfo,
        BOOL            *pfStatus);

DWORD
DwCustomDeleteEntryNotify(
        LPCTSTR          lpszPhonebook,
        LPCTSTR          lpszEntry,
        LPTSTR           pszCustomDialer);
        


DWORD
DwGetExpandedDllPath(LPTSTR pszDllPath,
                     LPTSTR *ppszExpandedDllPath);

DWORD
DwGetEntryMode( LPCTSTR pszPhonebook,
                LPCTSTR pszEntry,
                PBFILE *pFileIn,
                DWORD  *pdwFlags);

DWORD
DwEnumeratePhonebooksFromDirectory(
    TCHAR *pszDir,
    DWORD dwFlags,
    PBKENUMCALLBACK pfnCallback,
    VOID *pvContext
    );

DWORD
DwGetCustomAuthData(
    PBENTRY *pEntry,
    DWORD *pcbCustomAuthData,
    PBYTE *ppCustomAuthData
    );

DWORD
DwSetCustomAuthData(
    PBENTRY *pEntry,
    DWORD cbCustomAuthData,
    PBYTE pCustomAuthData
    );

DWORD
DwCustomTerminalDlg(
    TCHAR *pszPhonebook,
    HRASCONN hrasconn,
    PBENTRY *pEntry,
    HWND hwndDlg,
    RASDIALPARAMS *prdp,
    PVOID pvReserved
    );

DWORD
DwGetVpnDeviceName(
    DWORD dwVpnStrategy, 
    WCHAR *pszDeviceDefault, 
    WCHAR *pszDeviceName);
    
                
#endif // _PBK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\rasip.h ===
//****************************************************************************
//
//		       Microsoft NT Remote Access Service
//
//		       Copyright 1992-93
//
//
//  Revision History
//
//
//  12/9/93	Gurdeep Singh Pall	Created
//
//
//  Description: Shared structs between rasarp and ipcp
//
//****************************************************************************

#ifndef _RASIP_H_
#define _RASIP_H_

#define RASARP_DEVICE_NAME	L"\\\\.\\RASARP"

#define RASARP_DEVICE_NAME_NUC	"\\\\.\\RASARP"

#define FILE_DEVICE_RASARP	0x00009001

#define _RASARP_CONTROL_CODE(request,method)  ((FILE_DEVICE_RASARP)<<16 | (request<<2) | method)

#define IOCTL_RASARP_ACTIVITYINFO	_RASARP_CONTROL_CODE( 0, METHOD_BUFFERED )

#define IOCTL_RASARP_DISABLEIF		_RASARP_CONTROL_CODE( 1, METHOD_BUFFERED )

typedef ULONG IPADDR ;

struct IPLinkUpInfo {

#define CALLIN	0
#define CALLOUT 1

    ULONG	    I_Usage ;	// CALLIN, or CALLOUT

    IPADDR	    I_IPAddress ; // For client - the client's IP Address, for server
				  // the client's IP address.

    ULONG	    I_NetbiosFilter ; // 1 = ON, 0 - OFF.

} ;

typedef struct IPLinkUpInfo IPLinkUpInfo ;


struct ActivityInfo {

    IPADDR	    A_IPAddress ; // The address for which activity is requested.

    ULONG	    A_TimeSinceLastActivity ; // In minutes

} ;

typedef struct ActivityInfo ActivityInfo ;

#endif // _RASIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\pwutil.h ===
/* Copyright (c) 1993, Microsoft Corporation, all rights reserved
**
** ppputil.h
** Public header for miscellaneuos PPP common library functions.
*/

#ifndef _PWUTIL_H_
#define _PWUTIL_H_

#ifndef USE_PROTECT_MEMORY
#define USE_PROTECT_MEMORY
#endif


VOID
DecodePasswordA(
    CHAR* pszPassword
    );

VOID
DecodePasswordW(
    WCHAR* pszPassword
    );

VOID
EncodePasswordA(
    CHAR* pszPassword
    );

VOID
EncodePasswordW(
    WCHAR* pszPassword
    );

VOID
WipePasswordA(
    CHAR* pszPassword
    );

VOID
WipePasswordW(
    WCHAR* pszPassword
    );

//New safer APIs to protect password. for .Net 534499 and LH 754400
#ifdef USE_PROTECT_MEMORY
//dwInSize has to be multiple of 16 bytes.
DWORD EncryptMemoryInPlace(
        IN OUT PBYTE pbIn,
        IN DWORD dwInSize);

DWORD DecryptMemoryInPlace(
        IN OUT PBYTE pbIn,
        IN DWORD dwInSize);

DWORD WipeMemoryInPlace(
        IN OUT PBYTE pbIn,
        IN DWORD dwInSize);

DWORD CopyMemoryInPlace(
        IN OUT PBYTE pbDest,
        IN DWORD dwDestSize,
        IN PBYTE pbSrc,
        IN DWORD dwSrcSize);


DWORD TrimToMul16(
        IN DWORD dwSize);
#else
DWORD EncodePasswordInPlace(
        IN OUT PBYTE pbIn,
        IN DWORD dwInSize);

DWORD DecodePasswordInPlace(
        IN OUT PBYTE pbIn,
        IN DWORD dwInSize);

DWORD
WipePasswordInPlace(
        IN OUT PBYTE pbIn,
        IN DWORD dwInSize);

DWORD CopyPasswordInPlace(
        IN OUT PBYTE pbDest,
        IN DWORD dwDestSize,
        IN PBYTE pbSrc,
        IN DWORD dwSrcSize);


#endif

#ifdef UNICODE
#define     DecodePassword          DecodePasswordW
#define     EncodePassword          EncodePasswordW
#define     WipePassword            WipePasswordW
#else
#define     DecodePassword          DecodePasswordA
#define     EncodePassword          EncodePasswordA
#define     WipePassword            WipePasswordA
#endif

//!!!
//XXXXBuf macros are only meant for array buffers like szPassword[PWLEN+1];
//for pointers to strings, the calller has to use SafeEncodePassword and as such
//
#ifdef USE_PROTECT_MEMORY
#define     SafeEncodePassword              EncryptMemoryInPlace
#define     SafeDecodePassword              DecryptMemoryInPlace
#define     SafeWipePassword                WipeMemoryInPlace
#define     SafeCopyPassword                CopyMemoryInPlace
#define     SafeCopyPasswordBuf(x,y)        CopyMemoryInPlace((PBYTE)(x),TrimToMul16(sizeof((x))),(PBYTE)(y),TrimToMul16(sizeof((y))))
#define     SafeEncodePasswordBuf(x)        EncryptMemoryInPlace((PBYTE)(x),TrimToMul16(sizeof((x))))
#define     SafeDecodePasswordBuf(x)        DecryptMemoryInPlace((PBYTE)(x), TrimToMul16(sizeof((x))))
#define     SafeWipePasswordBuf(x)          WipeMemoryInPlace((PBYTE)(x), sizeof((x)))
#else
#define     SafeEncodePassword              EncodePasswordInPlace
#define     SafeDecodePassword              DecodePasswordInPlace
#define     SafeWipePassword                WipePasswordInPlace
#define     SafeCopyPassword                CopyPasswordInPlace
#define     SafeCopyPasswordBuf(x,y)        CopyPasswordInPlace((PBYTE)(x),sizeof((x)),(PBYTE)(y), sizeof((y)))
#define     SafeEncodePasswordBuf(x)        EncodePasswordInPlace((PBYTE)(x), sizeof((x)))
#define     SafeDecodePasswordBuf(x)        DecodePasswordInPlace((PBYTE)(x), sizeof((x)))
#define     SafeWipePasswordBuf(x)          WipePasswordInPlace((PBYTE)(x), sizeof((x)))
#endif


#endif // _PWUTIL_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\phonenum.h ===
// Copyright (c) 1996, Microsoft Corporation, all rights reserved
//
// phonenum.h
// Phone number building library
// Public header
//
// 03/06/96 Steve Cobb
//

#ifndef _PHONENUM_H_
#define _PHONENUM_H_


#include <pbk.h>
#include <tapi.h>


//----------------------------------------------------------------------------
// Prototypes
//----------------------------------------------------------------------------

TCHAR*
LinkPhoneNumberFromParts(
    IN HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    IN PBUSER* pUser,
    IN PBENTRY* pEntry,
    IN PBLINK* pLink,
    IN DWORD iPhoneNumber,
    IN TCHAR* pszOverrideNumber,
    IN BOOL fDialable );

TCHAR*
PhoneNumberFromParts(
    IN HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    IN PBUSER* pUser,
    IN PBPHONE* pPhone,
    IN BOOL fDownLevelIsdn,
    IN BOOL fDialable );

TCHAR*
PhoneNumberFromPrefixSuffix(
    IN TCHAR* pszBaseNumber,
    IN TCHAR* pszPrefix,
    IN TCHAR* pszSuffix );

TCHAR*
PhoneNumberFromPrefixSuffixEx(
    IN TCHAR* pszBaseNumber,
    IN TCHAR* pszPrefix,
    IN TCHAR* pszSuffix,
    IN BOOL fDownLevelIsdn );

TCHAR*
PhoneNumberFromTapiParts(
    IN HINSTANCE hInst,
    IN TCHAR* pszBaseNumber,
    IN TCHAR* pszAreaCode,
    IN DWORD dwCountryCode,
    IN OUT HLINEAPP* pHlineapp,
    IN BOOL fDialable );

TCHAR*
PhoneNumberFromTapiPartsEx(
    IN HINSTANCE hInst,
    IN TCHAR* pszBaseNumber,
    IN TCHAR* pszAreaCode,
    IN DWORD dwCountryCode,
    IN BOOL fDownLevelIsdn,
    IN OUT HLINEAPP* pHlineapp,
    IN BOOL fDialable );

VOID
PrefixSuffixFromLocationId(
    IN PBUSER* pUser,
    IN DWORD dwLocationId,
    OUT TCHAR** ppszPrefix,
    OUT TCHAR** ppszSuffix );


#endif // _PHONENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\rasp.h ===
/* Copyright (c) 1992, Microsoft Corporation, all rights reserved
**
** rasp.h
** Remote Access external API
** Private header for external API clients
*/

#ifndef _RASP_H_
#define _RASP_H_

/* Trusted entry points used by RASPHONE.
*/
HPORT    APIENTRY RasGetHport( HRASCONN );
HRASCONN APIENTRY RasGetHrasconn( HPORT );
VOID     APIENTRY RasGetConnectResponse( HRASCONN, CHAR* );
DWORD    APIENTRY RasSetNewPassword( HRASCONN, CHAR* );


/*----------------------------------------------------------------------------
** Off-version ras.h definitions
**----------------------------------------------------------------------------
*/

#include "pshpack4.h"

/* RAS structures as they appear to a caller in previous releases.  These are
** defined here because RASAPI32 needs to be able to access both old and new
** definitions in the same code.
*/

/* Windows NT 3.51 definitions.
*/

#define RAS_MaxEntryName_V351      20
#define RAS_MaxDeviceName_V351     32
#define RAS_MaxCallbackNumber_V351 48

/* Identifies an active RAS connection.  (See RasEnumConnections)
*/
#define RASCONNW_V351 struct tagRASCONNW_V351
RASCONNW_V351
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    WCHAR    szEntryName[ RAS_MaxEntryName_V351 + 1 ];
};

#define RASCONNA_V351 struct tagRASCONNA_V351
RASCONNA_V351
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    CHAR     szEntryName[ RAS_MaxEntryName_V351 + 1 ];
};

#define RASCONNW_V400 struct tagRASCONNW_V400
RASCONNW_V400
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    WCHAR    szEntryName[ RAS_MaxEntryName + 1 ];
    WCHAR    szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR    szDeviceName[ RAS_MaxDeviceName + 1 ];
};

#define RASCONNA_V400 struct tagRASCONNA_V400
RASCONNA_V400
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    CHAR     szEntryName[ RAS_MaxEntryName + 1 ];
    CHAR     szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR     szDeviceName[ RAS_MaxDeviceName + 1 ];
};

#define RASCONNA_V401 struct tagRASCONNA_V401
RASCONNA_V401
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    CHAR     szEntryName[ RAS_MaxEntryName + 1 ];
    CHAR     szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR     szDeviceName[ RAS_MaxDeviceName + 1 ];
    CHAR     szPhonebook [ MAX_PATH ];
    DWORD    dwSubEntry;
};

#define RASCONNW_V401 struct tagRASCONNW_V401
RASCONNW_V401
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    WCHAR    szEntryName[ RAS_MaxEntryName + 1 ];
    WCHAR    szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR    szDeviceName[ RAS_MaxDeviceName + 1 ];
    WCHAR    szPhonebook [ MAX_PATH ];
    DWORD    dwSubEntry;
};

#define RASCONNA_V500 struct tagRASCONNA_V500
RASCONNA_V500
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    CHAR     szEntryName[ RAS_MaxEntryName + 1 ];
    CHAR     szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR     szDeviceName[ RAS_MaxDeviceName + 1 ];
    CHAR     szPhonebook [ MAX_PATH ];
    DWORD    dwSubEntry;
    GUID     guidEntry;
};

#define RASCONNW_V500 struct tagRASCONNW_V500
RASCONNW_V500
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    WCHAR    szEntryName[ RAS_MaxEntryName + 1 ];
    WCHAR    szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR    szDeviceName[ RAS_MaxDeviceName + 1 ];
    WCHAR    szPhonebook [ MAX_PATH ];
    DWORD    dwSubEntry;
    GUID     guidEntry;
};


/* Describes the status of a RAS connection.  (See RasConnectionStatus)
*/
#define RASCONNSTATUSW_V351 struct tagRASCONNSTATUSW_V351
RASCONNSTATUSW_V351
{
    DWORD        dwSize;
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    WCHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR        szDeviceName[ RAS_MaxDeviceName_V351 + 1 ];
};

#define RASCONNSTATUSA_V351 struct tagRASCONNSTATUSA_V351
RASCONNSTATUSA_V351
{
    DWORD        dwSize;
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    CHAR         szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR         szDeviceName[ RAS_MaxDeviceName_V351 + 1 ];
};

#define RASCONNSTATUSW_V400 struct tagRASCONNSTATUSW_V400
RASCONNSTATUSW_V400
{
    DWORD        dwSize;
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    WCHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
};

#define RASCONNSTATUSA_V400 struct tagRASCONNSTATUSA_V400
RASCONNSTATUSA_V400
{
    DWORD        dwSize;
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    CHAR         szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR         szDeviceName[ RAS_MaxDeviceName + 1 ];
};

/* Describes connection establishment parameters.  (See RasDial)
*/
#define RASDIALPARAMSW_V351 struct tagRASDIALPARAMSW_V351
RASDIALPARAMSW_V351
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName_V351 + 1 ];
    WCHAR szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    WCHAR szCallbackNumber[ RAS_MaxCallbackNumber_V351 + 1 ];
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
};

#define RASDIALPARAMSA_V351 struct tagRASDIALPARAMSA_V351
RASDIALPARAMSA_V351
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName_V351 + 1 ];
    CHAR  szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    CHAR  szCallbackNumber[ RAS_MaxCallbackNumber_V351 + 1 ];
    CHAR  szUserName[ UNLEN + 1 ];
    CHAR  szPassword[ PWLEN + 1 ];
    CHAR  szDomain[ DNLEN + 1 ];
};

#define RASDIALPARAMSW_V400 struct tagRASDIALPARAMSW_V400
RASDIALPARAMSW_V400
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName + 1 ];
    WCHAR szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    WCHAR szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
};

#define RASDIALPARAMSA_V400 struct tagRASDIALPARAMSA_V400
RASDIALPARAMSA_V400
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];
    CHAR  szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    CHAR  szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    CHAR  szUserName[ UNLEN + 1 ];
    CHAR  szPassword[ PWLEN + 1 ];
    CHAR  szDomain[ DNLEN + 1 ];
};

/* Describes an enumerated RAS phone book entry name.  (See RasEntryEnum)
*/
#define RASENTRYNAMEW_V351 struct tagRASENTRYNAMEW_V351
RASENTRYNAMEW_V351
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName_V351 + 1 ];
};

#define RASENTRYNAMEA_V351 struct tagRASENTRYNAMEA_V351
RASENTRYNAMEA_V351
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName_V351 + 1 ];
};


#define RASENTRYNAMEW_V401 struct tagRASENTRYNAMEW_V401
RASENTRYNAMEW_V401
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName + 1 ];
};

#define RASENTRYNAMEA_V401 struct tagRASENTRYNAMEA_V401
RASENTRYNAMEA_V401
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];
};


/* A RAS phone book entry.
*/
#define RASENTRYW_V400 struct tagRASENTRYW_V400
RASENTRYW_V400
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    WCHAR       szAreaCode[ RAS_MaxAreaCode + 1 ];
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    WCHAR       szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    WCHAR       szAutodialDll[ MAX_PATH ];
    WCHAR       szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    WCHAR       szX25PadType[ RAS_MaxPadType + 1 ];
    WCHAR       szX25Address[ RAS_MaxX25Address + 1 ];
    WCHAR       szX25Facilities[ RAS_MaxFacilities + 1 ];
    WCHAR       szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
};


#define RASENTRYA_V400 struct tagRASENTRYA_V400
RASENTRYA_V400
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number.
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    CHAR        szAreaCode[ RAS_MaxAreaCode + 1 ];
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    CHAR        szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    CHAR        szAutodialDll[ MAX_PATH ];
    CHAR        szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    CHAR        szX25PadType[ RAS_MaxPadType + 1 ];
    CHAR        szX25Address[ RAS_MaxX25Address + 1 ];
    CHAR        szX25Facilities[ RAS_MaxFacilities + 1 ];
    CHAR        szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
};


/* A RAS phone book entry (v401)
*/
#define RASENTRYA_V401 struct tagRASENTRYA_V401
RASENTRYA_V401
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number.
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    CHAR        szAreaCode[ RAS_MaxAreaCode + 1 ];
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    CHAR        szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    CHAR        szAutodialDll[ MAX_PATH ];
    CHAR        szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    CHAR        szX25PadType[ RAS_MaxPadType + 1 ];
    CHAR        szX25Address[ RAS_MaxX25Address + 1 ];
    CHAR        szX25Facilities[ RAS_MaxFacilities + 1 ];
    CHAR        szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;

};

#define RASENTRYW_V401 struct tagRASENTRYW_V401
RASENTRYW_V401
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    WCHAR       szAreaCode[ RAS_MaxAreaCode + 1 ];
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    WCHAR       szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    WCHAR       szAutodialDll[ MAX_PATH ];
    WCHAR       szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    WCHAR       szX25PadType[ RAS_MaxPadType + 1 ];
    WCHAR       szX25Address[ RAS_MaxX25Address + 1 ];
    WCHAR       szX25Facilities[ RAS_MaxFacilities + 1 ];
    WCHAR       szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
};


#define RASENTRYA_V500 struct tagRASENTRYA_V500
RASENTRYA_V500
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number.
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    CHAR        szAreaCode[ RAS_MaxAreaCode + 1 ];
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    CHAR        szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    CHAR        szAutodialDll[ MAX_PATH ];
    CHAR        szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    CHAR        szX25PadType[ RAS_MaxPadType + 1 ];
    CHAR        szX25Address[ RAS_MaxX25Address + 1 ];
    CHAR        szX25Facilities[ RAS_MaxFacilities + 1 ];
    CHAR        szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
#if (WINVER >= 0x401)
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
#endif

#if (WINVER >= 0x500)

    //
    // Entry Type
    //
    DWORD       dwType;

    //
    // Encryption type
    //
    DWORD       dwEncryptionType;

    //
    // CustomAuthKey to be used for EAP
    //
    DWORD       dwCustomAuthKey;

    //
    // Guid of the connection
    //
    GUID        guidId;

    //
    // Custom Dial Dll
    //
    CHAR        szCustomDialDll[MAX_PATH];

    //
    // DwVpnStrategy
    //
    DWORD       dwVpnStrategy;
#endif

};


#define RASENTRYW_V500 struct tagRASENTRYW_V500
RASENTRYW_V500
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    WCHAR       szAreaCode[ RAS_MaxAreaCode + 1 ];
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    WCHAR       szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    WCHAR       szAutodialDll[ MAX_PATH ];
    WCHAR       szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    WCHAR       szX25PadType[ RAS_MaxPadType + 1 ];
    WCHAR       szX25Address[ RAS_MaxX25Address + 1 ];
    WCHAR       szX25Facilities[ RAS_MaxFacilities + 1 ];
    WCHAR       szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
#if (WINVER >= 0x401)
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
#endif

#if (WINVER >= 0x500)
    //
    // Entry Type
    //
    DWORD       dwType;

    //
    // EncryptionType
    //
    DWORD       dwEncryptionType;

    //
    // CustomAuthKey to be used for EAP
    //
    DWORD       dwCustomAuthKey;

    //
    // Guid of the connection
    //
    GUID        guidId;

    //
    // Custom Dial Dll
    //
    WCHAR       szCustomDialDll[MAX_PATH];

    //
    // Vpn Strategy
    //
    DWORD       dwVpnStrategy;
#endif
};


// RasSubEntry (<= v401)
#define RASSUBENTRYA_V401 struct tagRASSUBENTRYA_V401
RASSUBENTRYA_V401
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#define RASSUBENTRYW_V401 struct tagRASSUBENTRYW_V401
RASSUBENTRYW_V401
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};


/* RAS structures as they appeared in NT 3.5 prior to 3.51 additions.
*/


/* Windows NT 3.5 definitions.
*/

/* Describes the results of a PPP IP (Internet) projection.
*/
#define RASPPPIPW_V35 struct tagRASPPPIPW_V35
RASPPPIPW_V35
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpAddress[ RAS_MaxIpAddress + 1 ];
};

#define RASPPPIPA_V35 struct tagRASPPPIPA_V35
RASPPPIPA_V35
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szIpAddress[ RAS_MaxIpAddress + 1 ];
};

/* Describes the results of a PPP IP (Internet) projection.
*/
#define RASPPPIPW_V401 struct tagRASPPPIPW_V401
RASPPPIPW_V401
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpAddress[ RAS_MaxIpAddress + 1 ];

#ifndef WINNT35COMPATIBLE

    WCHAR szServerIpAddress[ RAS_MaxIpAddress + 1 ];

#endif
};

#define RASPPPIPA_V401 struct tagRASPPPIPA_V401
RASPPPIPA_V401
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szIpAddress[ RAS_MaxIpAddress + 1 ];

#ifndef WINNT35COMPATIBLE

    CHAR  szServerIpAddress[ RAS_MaxIpAddress + 1 ];

#endif
};

/* Describes the results of a PPP LCP/multi-link negotiation.
*/
#define RASPPPLCP_V401 struct tagRASPPPLCP_V401
RASPPPLCP_V401
{
    DWORD dwSize;
    BOOL  fBundled;
};

#define LPRASPPPLCP RASPPPLCP*

/*  Putting this here for backward compatibility with RASDIALPARAMS
*   structure as defined in FE version of nt 3.5
*/ 
#define RASDIALPARAMSA_WINNT35J struct tagRASDIALPARAMSA_WINNT35J
RASDIALPARAMSA_WINNT35J
{
    DWORD dwSize;
/* MSKK HitoshiT modified to supprot DBCS 94/9/2  */
    CHAR  szEntryName[ RAS_MaxEntryName_V351 * sizeof( USHORT ) + 1 ];
    CHAR  szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    CHAR  szCallbackNumber[ RAS_MaxCallbackNumber_V351 + 1 ];
    CHAR  szUserName[ UNLEN + 1 ];
    CHAR  szPassword[ PWLEN + 1 ];
    CHAR  szDomain[ DNLEN * sizeof( USHORT ) + 1 ];
};

/* Describes extended connection establishment options.  (See RasDial)
*/
#define RASDIALEXTENSIONS_401 struct tagRASDIALEXTENSIONS_401
RASDIALEXTENSIONS_401
{
    DWORD dwSize;
    DWORD dwfOptions;
    HWND  hwndParent;
    ULONG_PTR reserved;
};

#include "poppack.h"


#endif /*_RASP_H_*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\pbuser.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** pbuser.h
** Remote Access phonebook user preference library
** Public header
**
** 06/20/95 Steve Cobb
*/

#ifndef _PBUSER_H_
#define _PBUSER_H_

/*----------------------------------------------------------------------------
** Constants
**----------------------------------------------------------------------------
*/

/* User preference modes
*/
#define UPM_Normal 0
#define UPM_Logon  1
#define UPM_Router 2


/* User preference key and values.
*/
#define REGKEY_HkcuOldRas                TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Network\\RemoteAccess")
#define REGKEY_HkcuOldRasParent          TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Network")
#define REGKEY_HkcuOldRasRoot            TEXT("RemoteAccess")
#define REGKEY_HkuOldRasLogon            TEXT(".DEFAULT\\Software\\Microsoft\\RAS Phonebook")
#define REGKEY_HkcuRas                   TEXT("Software\\Microsoft\\RAS Phonebook")
#define REGKEY_HkuRasLogon               TEXT(".DEFAULT\\Software\\Microsoft\\RAS Logon Phonebook")
#define REGKEY_HklmRouter                TEXT("Software\\Microsoft\\Router Phonebook")
#define REGKEY_Callback                  TEXT("Callback")
#define REGKEY_Location                  TEXT("Location")
#define REGVAL_szNumber                  TEXT("Number")
#define REGVAL_dwDeviceType              TEXT("DeviceType")
#define REGVAL_dwPhonebookMode           TEXT("PhonebookMode")
#define REGVAL_szUsePersonalPhonebook    TEXT("UsePersonalPhonebook")
#define REGVAL_szPersonalPhonebookPath   TEXT("PersonalPhonebookPath")
#define REGVAL_szPersonalPhonebookFile   TEXT("PersonalPhonebookFile")
#define REGVAL_szAlternatePhonebookPath  TEXT("AlternatePhonebookPath")
#define REGVAL_fOperatorDial             TEXT("OperatorDial")
#define REGVAL_fPreviewPhoneNumber       TEXT("PreviewPhoneNumber")
#define REGVAL_fUseLocation              TEXT("UseLocation")
#define REGVAL_fShowLights               TEXT("ShowLights")
#define REGVAL_fShowConnectStatus        TEXT("ShowConnectStatus")
#define REGVAL_fNewEntryWizard           TEXT("NewEntryWizard")
#define REGVAL_dwRedialAttempts          TEXT("RedialAttempts")
#define REGVAL_dwRedialSeconds           TEXT("RedialSeconds")
#define REGVAL_dwIdleDisconnectSeconds   TEXT("IdleHangUpSeconds")
#define REGVAL_dwCallbackMode            TEXT("CallbackMode")
#define REGVAL_mszPhonebooks             TEXT("Phonebooks")
#define REGVAL_mszAreaCodes              TEXT("AreaCodes")
#define REGVAL_mszPrefixes               TEXT("Prefixes")
#define REGVAL_mszSuffixes               TEXT("Suffixes")
#define REGVAL_szLastCallbackByCaller    TEXT("LastCallbackByCaller")
#define REGVAL_dwPrefix                  TEXT("Prefix")
#define REGVAL_dwSuffix                  TEXT("Suffix")
#define REGVAL_dwXWindow                 TEXT("WindowX")
#define REGVAL_dwYWindow                 TEXT("WindowY")
#define REGVAL_szDefaultEntry            TEXT("DefaultEntry")
#define REGVAL_fCloseOnDial              TEXT("CloseOnDial")
#define REGVAL_fAllowLogonPhonebookEdits TEXT("AllowLogonPhonebookEdits")
#define REGVAL_fAllowLogonLocationEdits  TEXT("AllowLogonLocationEdits")
#define REGVAL_fUseAreaAndCountry        TEXT("UseAreaAndCountry")
#define REGVAL_dwMode                    TEXT("Mode")
#define REGVAL_dwFlags                   TEXT("Flags")
#define REGVAL_dwX                       TEXT("x")
#define REGVAL_dwY                       TEXT("y")
#define REGVAL_dwCx                      TEXT("cx")
#define REGVAL_dwCy                      TEXT("cy")
#define REGVAL_dwCxCol1                  TEXT("cxCol1")
#define REGVAL_dwStartPage               TEXT("StartPage")
#define REGVAL_dwXDlg                    TEXT("xDlg")
#define REGVAL_dwYDlg                    TEXT("yDlg")
#define REGVAL_dwCxDlgCol1               TEXT("cxDlgCol1")
#define REGVAL_dwCxDlgCol2               TEXT("cxDlgCol2")
#define REGVAL_szLastDevice              TEXT("LastDevice")
#define REGVAL_mszDeviceList             TEXT("DeviceList")
#define REGVAL_fSkipConnectComplete      TEXT("SkipConnectComplete")
#define REGVAL_fRedialOnLinkFailure      TEXT("RedialOnLinkFailure")
#define REGVAL_fExpandAutoDialQuery      TEXT("ExpandAutoDialQuery")
#define REGVAL_fPopupOnTopWhenRedialing  TEXT("PopupOnTopWhenRedialing")
#define REGVAL_dwVersion                 TEXT("Version")


/* Callback modes (see dwCallbackMode below).
*/
#define CBM_No    0
#define CBM_Maybe 1
#define CBM_Yes   2


/* Phonebook modes (see dwPhonebookMode below).
*/
#define PBM_System    0
#define PBM_Personal  1
#define PBM_Alternate 2
#define PBM_Router    3


/*----------------------------------------------------------------------------
** Datatypes
**----------------------------------------------------------------------------
*/

/* Information about a callback number.  See 'PBUSER.pdtllistCallback'.  Note
** that 'dwDeviceType' is a PBK PBDEVICETYPE enumeration cast to a DWORD.
*/
#define CALLBACKINFO struct tagCALLBACKINFO
CALLBACKINFO
{
    TCHAR* pszPortName;
    TCHAR* pszDeviceName;
    TCHAR* pszNumber;
    DWORD  dwDeviceType;
};


/* Information associated with a TAPI location number.
*/
#define LOCATIONINFO struct tagLOCATIONINFO
LOCATIONINFO
{
    DWORD  dwLocationId;
    DWORD  iPrefix;
    DWORD  iSuffix;
};


/* User preference information read from the "CURRENT_USER" registry.  This
** information applies to all "normal" user phonebooks plus the system
** phonebook.  The router phonebook may work differently.
*/
#define PBUSER struct tagPBUSER
PBUSER
{
    /* Appearance page.
    */
    BOOL fOperatorDial;
    BOOL fPreviewPhoneNumber;
    BOOL fUseLocation;
    BOOL fShowLights;
    BOOL fShowConnectStatus;
    BOOL fCloseOnDial;
    BOOL fAllowLogonPhonebookEdits;
    BOOL fAllowLogonLocationEdits;
    BOOL fSkipConnectComplete;
    BOOL fNewEntryWizard;

    /* Auto-dial page.
    */
    DWORD dwRedialAttempts;
    DWORD dwRedialSeconds;
    DWORD dwIdleDisconnectSeconds;
    BOOL  fRedialOnLinkFailure;
    BOOL  fPopupOnTopWhenRedialing;
    BOOL  fExpandAutoDialQuery;

    /* Callback page.
    **
    ** This list is of CALLBACKINFO.
    */
    DWORD    dwCallbackMode;
    DTLLIST* pdtllistCallback;
    TCHAR*   pszLastCallbackByCaller;

    /* Phone list page.
    */
    DWORD    dwPhonebookMode;
    TCHAR*   pszPersonalFile;
    TCHAR*   pszAlternatePath;
    DTLLIST* pdtllistPhonebooks;

    /* Area code strings, in MRU order.
    */
    DTLLIST* pdtllistAreaCodes;
    BOOL     fUseAreaAndCountry;

    /* Prefix/suffix information, i.e. the ordered string lists and the
    ** settings for a particular TAPI location.
    */
    DTLLIST* pdtllistPrefixes;
    DTLLIST* pdtllistSuffixes;
    DTLLIST* pdtllistLocations;

    /* Phonebook window position and last entry selected used by RASPHONE.EXE.
    */
    DWORD  dwXPhonebook;
    DWORD  dwYPhonebook;
    TCHAR* pszDefaultEntry;

    /* Set true if the structure has been initialized.
    */
    BOOL fInitialized;

    /* Set true if something's changed since the structure was read.
    */
    BOOL fDirty;
};


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

DTLNODE*
CreateLocationNode(
    IN DWORD dwLocationId,
    IN DWORD iPrefix,
    IN DWORD iSuffix );

DTLNODE*
CreateCallbackNode(
    IN TCHAR* pszPortName,
    IN TCHAR* pszDeviceName,
    IN TCHAR* pszNumber,
    IN DWORD  dwDeviceType );

VOID
DestroyLocationNode(
    IN DTLNODE* pNode );

VOID
DestroyCallbackNode(
    IN DTLNODE* pNode );

VOID
DestroyUserPreferences(
    IN PBUSER* pUser );

DTLNODE*
DuplicateLocationNode(
    IN DTLNODE* pNode );

DWORD
GetUserPreferences(
    IN HANDLE   hConnection,
    OUT PBUSER* pUser,
    IN  DWORD   dwMode );

DWORD
SetUserPreferences(
    IN HANDLE  hConnection,
    IN PBUSER* pUser,
    IN DWORD   dwMode );

// These two are provided as an optimization.  
// They write directly to the registry.
DWORD GetUserManualDialEnabling (
    IN OUT PBOOL pbEnabled,
    IN DWORD dwMode );
    
DWORD SetUserManualDialEnabling (
    IN BOOL bEnable,
    IN DWORD dwMode );

#endif // _PBUSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\popupdlg.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** popupdlg.h
** UI helper library
** Error and message dialog public header
**
** 08/25/95 Steve Cobb
*/

#ifndef _POPUPDLG_H_
#define _POPUPDLG_H_


/*----------------------------------------------------------------------------
** Datatypes
**----------------------------------------------------------------------------
*/

/* Extended arguments for the ErrorDlgUtil routine.  Designed so zeroed gives
** default behaviors.
*/
#define ERRORARGS struct tagERRORARGS
ERRORARGS
{
    /* Insertion strings for arguments %1 to %9 in the 'dwOperation' string,
    ** or NULLs if none.
    */
    TCHAR* apszOpArgs[ 9 ];

    /* Insertion strings for auxillary arguments %4 to %6 in the 'dwFormat'
    ** string, or NULLs if none.  (The standard arguments are %1=the
    ** 'dwOperation' string, %2=the decimal error number, and %3=the
    ** 'dwError'string.)
    */
    TCHAR* apszAuxFmtArgs[ 3 ];

    /* If 'fStringOutput' is true, the ErrorDlgUtil returns the formatted text
    ** string that would otherwise be displayed in the popup in 'pszOutput'.
    ** It is caller's responsibility to LocalFree the returned string.
    */
    BOOL   fStringOutput;
    TCHAR* pszOutput;
};


/* Extended arguments for the MsgDlgUtil routine.  Designed so zeroed gives
** default behaviors.
*/
#define MSGARGS struct tagMSGARGS
MSGARGS
{
    /* Insertion strings for arguments %1 to %9 in the 'dwMsg' string, or
    ** NULLs if none.
    */
    TCHAR* apszArgs[ 9 ];

    /* Currently, as for MessageBox, where defaults if 0 are MB_OK and
    ** MB_ICONINFORMATION.
    */
    DWORD dwFlags;

    /* If non-NULL, specifies a string overriding the loading of the 'dwMsg'
    ** parameter string.
    */
    TCHAR* pszString;

    /* If 'fStringOutput' is true, the MsgDlgUtil returns the formatted text
    ** string that would otherwise be displayed in the popup in 'pszOutput'.
    ** It is caller's responsibility to LocalFree the returned string.
    */
    BOOL   fStringOutput;
    TCHAR* pszOutput;
};


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

LRESULT CALLBACK
CenterDlgOnOwnerCallWndProc(
    int    code,
    WPARAM wparam,
    LPARAM lparam );

BOOL
GetErrorText(
    DWORD   dwError,
    TCHAR** ppszError );

int
ErrorDlgUtil(
    IN     HWND       hwndOwner,
    IN     DWORD      dwOperation,
    IN     DWORD      dwError,
    IN OUT ERRORARGS* pargs,
    IN     HINSTANCE  hInstance,
    IN     DWORD      dwTitle,
    IN     DWORD      dwFormat );

int
MsgDlgUtil(
    IN     HWND      hwndOwner,
    IN     DWORD     dwMsg,
    IN OUT MSGARGS*  pargs,
    IN     HINSTANCE hInstance,
    IN     DWORD     dwTitle );


#endif // _POPUPDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\rasrpclb.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    rasrpclb.h

ABSTRACT
    Header file for rasrpc client/server common routines

AUTHOR
    Anthony Discolo (adiscolo) 10-Sep-1996

REVISION HISTORY

--*/

#ifndef _RASRPCLIB_H
#define _RASRPCLIB_H

DWORD
RasToRpcPbuser(
    LPRASRPC_PBUSER pUser,
    PBUSER *pPbuser
    );

DWORD
RpcToRasPbuser(
    PBUSER *pPbuser,
    LPRASRPC_PBUSER pUser
    );

#endif // _RASRPCLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\rassapip.h ===
/******************************************************************\
*                     Microsoft Windows NT                         *
*               Copyright(c) Microsoft Corp., 1992                 *
\******************************************************************/

/*++

Module Name:

    RASSAPIP.H

Description:

    This file contains structure defs and defines used in implementing
    the RASADMIN APIs.


Author:

    Michael Salamone (MikeSa)   July 13,1992

Revision History:

--*/


#ifndef _RASSAPIP_H_
#define _RASAAPIP_H_


#define RASSAPI_MAX_CALLBACK_NUMBER_SIZE  48
#define RASSAPI_MAX_DEVICE_NAME_OLD       32

// 3rd party DLLs don't need this version information because they will only
// be administering a NT3.51 or greater server.
#define RAS_SERVER_20      20    // identifies a NT RAS 2.0 server

//
// Number of port statistics returned by a RAS 1.0 server
//
#define RAS10_MAX_STATISTICS 6

//
// RAS10 specific port statistics defines
//

#define RAS10_BYTES_RCVED         0
#define RAS10_BYTES_XMITED        1
#define RAS10_SERIAL_OVERRUN_ERR  2
#define RAS10_TIMEOUT_ERR         3
#define RAS10_FRAMING_ERR         4
#define RAS10_CRC_ERR             5


#define MEDIA_NAME_DEFAULT   L"SERIAL"
#define DEVICE_TYPE_DEFAULT  L"MODEM"
#define DEVICE_NAME_DEFAULT  L"UNKNOWN"

//
// structures used by down level RAS 1.x servers
//

typedef struct tagWpdStatisticsInfo
{
    ULONG stat_bytesreceived;
    ULONG stat_bytesxmitted;
    USHORT stat_overrunerr;
    USHORT stat_timeouterr;
    USHORT stat_framingerr;
    USHORT stat_crcerr;
} WpdStatisticsInfo;


struct dialin_user_info_0
{
    unsigned char duseri0_privilege_mask ;
    char duseri0_phone_number[RASSAPI_MAX_PHONENUMBER_SIZE + 1];
};


struct dialin_user_info_1
{
    struct dialin_user_info_0 duseri0;
    char duseri1_name[LM20_UNLEN+1];
};


struct dialin_user_info_2
{
    struct dialin_user_info_0 duseri0;
    USER_INFO_2 usri2;
};


struct dialin_port_info_0
{
    char dporti0_username[LM20_UNLEN+1];   // name of user using the port

    char dporti0_computer[NETBIOS_NAME_LEN+1]; // computer user dialed in from
                                               // Used when the admin wants to
                                               // send a message to this user

    unsigned short dporti0_comid;          // COM1 = 1 etc

    unsigned long dporti0_time;            // time user dialed in and
                                           // authenticated - number of seconds
                                           // since 00:00:00 Jan 1, 1970

    unsigned short dporti0_line_condition; // If RAS_PORT_AUTHENTICATED, then
                                           // comid, time username and computer
                                           // name fields are valid.

    unsigned short dporti0_modem_condition;
};


struct dialin_port_info_1
{
    struct dialin_port_info_0 dporti0;
    unsigned long dporti1_baud;
    WpdStatisticsInfo dporti1_stats;
};


struct dialin_server_info_0
{
    unsigned short dserveri0_total_ports;
    unsigned short dserveri0_ports_in_use;
};


//
// defined to support RAS 1.x - the max ports in RAS 2.0 and greater
// is 64 (could be greater)
//
#define RAS_MAX_SERVER_PORTS 16


//
// Max length of RAS 1.0 port name including terminating
// NULL character - eg., "COM16"
//
#define RAS10_MAX_PORT_NAME 6


//
// How long a client will wait for a pipe connection (milliseconds)
// if it is busy.
//
#define PIPE_CONNECTION_TIMEOUT   10000L


#define PIPE_BUFSIZE              512


//
// Name of pipe that will be used to process requests
//
#define	RASADMIN_PIPE  TEXT("\\pipe\\dialin\\adminsrv")


//
// Pipe path to which RASADMIN_PIPE should be concatenated for local
// machine
//
#define LOCAL_PIPE     TEXT("\\\\.")


//
// Request codes for RAS 1.x server
//
#define	RASADMINREQ_DISCONNECT_USER	1
#define	RASADMINREQ_GET_PORT_INFO	2
#define	RASADMINREQ_CLEAR_PORT_STATS	3
#define	RASADMINREQ_ENUM_PORTS		4	
#define	RASADMINREQ_GET_SERVER_INFO	5


//
// Request codes for RAS 2.0 server
//
#define RASADMIN20_REQ_DISCONNECT_USER    2001
#define RASADMIN20_REQ_GET_PORT_INFO      2002
#define RASADMIN20_REQ_CLEAR_PORT_STATS   2003
#define RASADMIN20_REQ_ENUM_PORTS         2004
#define RASADMIN20_REQ_ENUM_RESUME        2005


//
// This request code remains the same as in RAS 1.0
// so that, if RAS 1.0 admin tried to connect, it
// will get server info back, but not in the format
// that it recognizes.  It will then be unable to
// admin the RAS 2.0 server.
//
#define RASADMIN20_REQ_GET_SERVER_INFO    5


//
// These can be returned in the RetCode field of server response
// packet sent to the client.  These should not be changed in
// order to preserve compatibility with different versions of
// RASADMIN.
//
#define ERR_NO_SUCH_DEVICE                   635
#define ERR_SERVER_SYSTEM_ERR                636


//
// These are the packets sent back and forth between RAS 1.x server
// and the RASADMIN APIs.
//
struct PortEnumRequestPkt
{
    unsigned short Request;    // ENUM_PORTS
};                             // ENUM_PORTS_TOTALAVAIL


struct PortEnumReceivePkt
{
    unsigned short RetCode;
    unsigned short TotalAvail;
    struct dialin_port_info_0 Data[RAS_MAX_SERVER_PORTS];
};


struct DisconnectUserRequestPkt
{
    unsigned short Request;    // DISCONNECT_USER
    unsigned short ComId;
};


struct DisconnectUserReceivePkt
{
    unsigned short RetCode;
};


struct PortClearRequestPkt
{
    unsigned short Request;    // CLEAR_PORT_STATISTICS
    unsigned short ComId;
};


struct PortClearReceivePkt
{
    unsigned short RetCode;
};


struct ServerInfoRequestPkt
{
    unsigned short Request;    // GET_SERVER_INFO
};


struct ServerInfoReceivePkt
{
    unsigned short RetCode;
    struct dialin_server_info_0 Data;
};


struct PortInfoRequestPkt
{
    unsigned short Request;    // GET_PORT_INFO
    unsigned short ComId;
};


struct PortInfoReceivePkt
{
    unsigned short RetCode;
    struct dialin_port_info_1 Data;
};


//
// These are the packed structures that are sent out on the network.
// It is up to the receiver to unpack and convert to the proper endian
// for the host.
//
typedef struct _P_WPD_STATISTICS_INFO
{
    BYTE stat_bytesreceived[4];
    BYTE stat_bytesxmitted[4];
    BYTE stat_overrunerr[2];
    BYTE stat_timeouterr[2];
    BYTE stat_framingerr[2];
    BYTE stat_crcerr[2];
} P_WPD_STATISTICS_INFO, *PP_WPD_STATISTICS_INFO;


typedef struct _P_DIALIN_PORT_INFO_0
{
    BYTE dporti0_username[LM20_UNLEN+1];   // name of user using the port

    BYTE dporti0_computer[NETBIOS_NAME_LEN+1]; // computer user dialed in from
                                               // Used when the admin wants to
                                               // send a message to this user

    BYTE dporti0_comid[2];                 // COM1 = 1 etc

    BYTE dporti0_time[4];                  // time user dialed in and
                                           // authenticated - number of seconds
                                           // since 00:00:00 Jan 1, 1970

    BYTE dporti0_line_condition[2];        // If RAS_PORT_AUTHENTICATED, then
                                           // comid, time username and computer
                                           // name fields are valid.

    BYTE dporti0_modem_condition[2];
} P_DIALIN_PORT_INFO_0, *PP_DIALIN_PORT_INFO_0;


typedef struct _P_DIALIN_PORT_INFO_1
{
    P_DIALIN_PORT_INFO_0 dporti0;
    BYTE dporti1_baud[4];
    P_WPD_STATISTICS_INFO dporti1_stats;
} P_DIALIN_PORT_INFO_1, *PP_DIALIN_PORT_INFO_1;


typedef struct _P_DIALIN_SERVER_INFO_0
{
    BYTE dserveri0_total_ports[2];
    BYTE dserveri0_ports_in_use[2];
} P_DIALIN_SERVER_INFO_0, *PP_DIALIN_SERVER_INFO_0;


typedef struct _P_PORT_ENUM_REQUEST_PKT
{
    BYTE Request[2];    // ENUM_PORTS
} P_PORT_ENUM_REQUEST_PKT, *PP_PORT_ENUM_REQUEST_PKT;   // ENUM_PORTS_TOTALAVAIL


typedef struct _P_PORT_ENUM_RECEIVE_PKT
{
    BYTE RetCode[2];
    BYTE TotalAvail[2];
    P_DIALIN_PORT_INFO_0 Data[RAS_MAX_SERVER_PORTS];
} P_PORT_ENUM_RECEIVE_PKT, *PP_PORT_ENUM_RECEIVE_PKT;


typedef struct _P_DISCONNECT_USER_REQUEST_PKT
{
    BYTE Request[2];    // DISCONNECT_USER
    BYTE ComId[2];
} P_DISCONNECT_USER_REQUEST_PKT, *PP_DISCONNECT_USER_REQUEST_PKT;


typedef struct _P_DISCONNECT_USER_RECEIVE_PKT
{
    BYTE RetCode[2];
} P_DISCONNECT_USER_RECEIVE_PKT, *PP_DISCONNECT_USER_RECEIVE_PKT;


typedef struct _P_PORT_CLEAR_REQUEST_PKT
{
    BYTE Request[2];    // CLEAR_PORT_STATISTICS
    BYTE ComId[2];
} P_PORT_CLEAR_REQUEST_PKT, *PP_PORT_CLEAR_REQUEST_PKT;


typedef struct _P_PORT_CLEAR_RECEIVE_PKT
{
    BYTE RetCode[2];
} P_PORT_CLEAR_RECEIVE_PKT, *PP_PORT_CLEAR_RECEIVE_PKT;


typedef struct _P_SERVER_INFO_REQUEST_PKT
{
    BYTE Request[2];    // GET_SERVER_INFO
} P_SERVER_INFO_REQUEST_PKT, *PP_SERVER_INFO_REQUEST_PKT;


typedef struct _P_SERVER_INFO_RECEIVE_PKT
{
    BYTE RetCode[2];
    P_DIALIN_SERVER_INFO_0 Data;
} P_SERVER_INFO_RECEIVE_PKT, *PP_SERVER_INFO_RECEIVE_PKT;


typedef struct _P_PORT_INFO_REQUEST_PKT
{
    BYTE Request[2];    // GET_PORT_INFO
    BYTE ComId[2];
} P_PORT_INFO_REQUEST_PKT, *PP_PORT_INFO_REQUEST_PKT;


typedef struct _P_PORT_INFO_RECEIVE_PKT
{
    BYTE RetCode[2];
    P_DIALIN_PORT_INFO_1 Data;
} P_PORT_INFO_RECEIVE_PKT, *PP_PORT_INFO_RECEIVE_PKT;


//
// These are the packets sent back and forth between a RAS 2.0 server
// and the RASADMIN APIs
//
typedef struct tagPortEnumReceivePkt
{
    DWORD RetCode;
    WORD TotalAvail;
    RAS_PORT_0 *Data;
} PORT_ENUM_RECEIVE, *PPORT_ENUM_RECEIVE;


typedef struct tagPortInfoReceivePkt
{
    DWORD RetCode;
    DWORD ReqBufSize;
    RAS_PORT_1 Data;
} PORT_INFO_RECEIVE, *PPORT_INFO_RECEIVE;


typedef struct tagPortClearReceivePkt
{
    DWORD RetCode;
} PORT_CLEAR_RECEIVE, *PPORT_CLEAR_RECEIVE;


typedef struct tagDisconnectUserReceivePkt
{
    DWORD RetCode;
} DISCONNECT_USER_RECEIVE, *PDISCONNECT_USER_RECEIVE;


typedef struct tagServerInfoReceivePkt
{
    WORD RetCode;   // VERY IMPORTANT TO BE A WORD!!! - RAS1.0 COMPATIBILITY
    RAS_SERVER_0 Data;
} SERVER_INFO_RECEIVE, *PSERVER_INFO_RECEIVE;


typedef struct _CLIENT_REQUEST
{
    WORD RequestCode;
    WCHAR PortName[RASSAPI_MAX_PORT_NAME];
    DWORD RcvBufSize;
    DWORD ClientVersion;
} CLIENT_REQUEST, *PCLIENT_REQUEST;



//
// These are the packed structures that are sent out on the network.
// It is up to the receiver to unpack and convert to the proper endian
// for the host.
//

typedef struct _P_RAS_PORT_0
{
    BYTE wszPortName[2 * RASSAPI_MAX_PORT_NAME];
    BYTE wszDeviceType[2 * RASSAPI_MAX_DEVICETYPE_NAME];
    BYTE wszDeviceName[2 * RASSAPI_MAX_DEVICE_NAME_OLD];
    BYTE wszMediaName[2 * RASSAPI_MAX_MEDIA_NAME];
    BYTE reserved[4];
    BYTE Flags[4];
    BYTE wszUserName[2 * (UNLEN + 1)];
    BYTE wszComputer[2 * NETBIOS_NAME_LEN];
    BYTE dwStartSessionTime[4];
    BYTE wszLogonDomain[2 * (DNLEN + 1)];
    BYTE fAdvancedServer[4];
} P_RAS_PORT_0, *PP_RAS_PORT_0;


typedef struct _P_RAS_STATISTIC
{
    BYTE Stat[4];
} P_RAS_STATISTIC, *PP_RAS_STATISTIC;



/* PPP control protocol results returned by RasPppGetInfo.
*/
typedef struct __PPP_NBFCP_RESULT
{
    BYTE dwError[4];
    BYTE dwNetBiosError[4];
    BYTE szName[NETBIOS_NAME_LEN + 1];
    BYTE wszWksta[2 * (NETBIOS_NAME_LEN + 1)];
} P_PPP_NBFCP_RESULT, *PP_PPP_NBFCP_RESULT;

typedef struct __PPP_IPCP_RESULT
{
    BYTE dwError[4];
    BYTE wszAddress[2 * (RAS_IPADDRESSLEN + 1)];
} P_PPP_IPCP_RESULT, *PP_PPP_IPCP_RESULT;

typedef struct __PPP_IPXCP_RESULT
{
    BYTE dwError[4];
    BYTE wszAddress[2 * (RAS_IPXADDRESSLEN + 1)];
} P_PPP_IPXCP_RESULT, *PP_PPP_IPXCP_RESULT;

typedef struct __PPP_ATCP_RESULT
{
    BYTE dwError[4];
    BYTE wszAddress[2 * (RAS_ATADDRESSLEN + 1)];
} P_PPP_ATCP_RESULT, *PP_PPP_ATCP_RESULT;

typedef struct __PPP_PROJECTION_RESULT
{
    P_PPP_NBFCP_RESULT nbf;
    P_PPP_IPCP_RESULT ip;
    P_PPP_IPXCP_RESULT ipx;
    P_PPP_ATCP_RESULT at;
} P_PPP_PROJECTION_RESULT, *PP_PPP_PROJECTION_RESULT;


typedef struct _P_RAS_PORT_1
{
    P_RAS_PORT_0 rasport0;
    BYTE LineCondition[4];
    BYTE HardwareCondition[4];
    BYTE LineSpeed[4];      // in bits/second
    BYTE NumStatistics[2];
    BYTE NumMediaParms[2];
    BYTE SizeMediaParms[4];
    P_PPP_PROJECTION_RESULT ProjResult;
} P_RAS_PORT_1, *PP_RAS_PORT_1;


typedef struct _P_RAS_FORMAT
{
    BYTE Format[4];
} P_RAS_FORMAT, *PP_RAS_FORMAT;


typedef union _P_RAS_VALUE
{
    BYTE Number[4];
    struct
    {
        BYTE Length[4];
        BYTE Offset[4];
    } String;
} P_RAS_VALUE, *PP_RAS_VALUE;


typedef struct _P_RAS_PARAMS
{
    BYTE P_Key[RASSAPI_MAX_PARAM_KEY_SIZE];
    P_RAS_FORMAT P_Type;
    BYTE P_Attributes;
    P_RAS_VALUE P_Value;
} P_RAS_PARAMS, *PP_RAS_PARAMS;


typedef struct _P_RAS_SERVER_0
{
    BYTE TotalPorts[2];
    BYTE PortsInUse[2];
    BYTE RasVersion[4];
} P_RAS_SERVER_0, *PP_RAS_SERVER_0;


typedef struct _P_PORT_ENUM_RECEIVE
{
    BYTE RetCode[4];
    BYTE TotalAvail[2];
    P_RAS_PORT_0 Data[1];
} P_PORT_ENUM_RECEIVE, *PP_PORT_ENUM_RECEIVE;


typedef struct _P_PORT_INFO_RECEIVE
{
    BYTE RetCode[4];
    BYTE ReqBufSize[4];
    P_RAS_PORT_1 Data;
} P_PORT_INFO_RECEIVE, *PP_PORT_INFO_RECEIVE;


typedef struct _P_PORT_CLEAR_RECEIVE
{
    BYTE RetCode[4];
} P_PORT_CLEAR_RECEIVE, *PP_PORT_CLEAR_RECEIVE;


typedef struct _P_DISCONNECT_USER_RECEIVE
{
    BYTE RetCode[4];
} P_DISCONNECT_USER_RECEIVE, *PP_DISCONNECT_USER_RECEIVE;


typedef struct _P_SERVER_INFO_RECEIVE
{
    BYTE RetCode[2];
    P_RAS_SERVER_0 Data;
} P_SERVER_INFO_RECEIVE, *PP_SERVER_INFO_RECEIVE;


typedef struct _P_CLIENT_REQUEST
{
    BYTE RequestCode[2];
    BYTE PortName[2 * RASSAPI_MAX_PORT_NAME];
    BYTE RcvBufSize[4];
    BYTE ClientVersion[4];
} P_CLIENT_REQUEST, *PP_CLIENT_REQUEST;


//
// The following macros deal with on-the-wire integer and long values
// On the wire format is little-endian i.e. a long value of 0x01020304 is
// represented as 04 03 02 01. Similarly an int value of 0x0102 is
// represented as 02 01.
//
// The host format is not assumed since it will vary from processor to
// processor.
//

// Get a short from on-the-wire format to the host format
#define GETUSHORT(DstPtr, SrcPtr)               \
    *(unsigned short *)(DstPtr) =               \
        ((*((unsigned char *)(SrcPtr)+1) << 8) +\
        (*((unsigned char *)(SrcPtr)+0)))

// Get a dword from on-the-wire format to the host format
#define GETULONG(DstPtr, SrcPtr)                 \
    *(unsigned long *)(DstPtr) =                 \
        ((*((unsigned char *)(SrcPtr)+3) << 24) +\
        (*((unsigned char *)(SrcPtr)+2) << 16) + \
        (*((unsigned char *)(SrcPtr)+1) << 8)  + \
        (*((unsigned char *)(SrcPtr)+0)))


// Put a ushort from the host format to on-the-wire format
#define PUTUSHORT(DstPtr, Src)   \
    *((unsigned char *)(DstPtr)+1)=(unsigned char)((unsigned short)(Src) >> 8),\
    *((unsigned char *)(DstPtr)+0)=(unsigned char)(Src)

// Put a ulong from the host format to on-the-wire format
#define PUTULONG(DstPtr, Src)   \
    *((unsigned char *)(DstPtr)+3)=(unsigned char)((unsigned long)(Src) >> 24),\
    *((unsigned char *)(DstPtr)+2)=(unsigned char)((unsigned long)(Src) >> 16),\
    *((unsigned char *)(DstPtr)+1)=(unsigned char)((unsigned long)(Src) >>  8),\
    *((unsigned char *)(DstPtr)+0)=(unsigned char)(Src)


#endif // _RASSAPIP_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\rcids.h ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//
// Copyright  1993-1995  Microsoft Corporation.  All Rights Reserved.
//
//      MODULE:         rcids.h
//
//      PURPOSE:        Constant definitions for resources
//
//	PLATFORMS:	Windows 95
//
//      FUNCTIONS:      N/A
//
//	SPECIAL INSTRUCTIONS: N/A
//

#define IDI_SCRIPT              100

#define IDD_TERMINALDLG         1000
#define CID_T_EB_SCREEN         (IDD_TERMINALDLG)
#define CID_T_PB_ENTER          (IDD_TERMINALDLG+1)
#define CID_T_CB_INPUT          (IDD_TERMINALDLG+2)
#define CID_T_CB_MIN            (IDD_TERMINALDLG+3)

#define IDD_TERMINALTESTDLG     2000
#define CID_T_ST_FILE           (IDD_TERMINALTESTDLG+2)
#define CID_T_EB_SCRIPT         (IDD_TERMINALTESTDLG+3)
#define CID_T_PB_STEP           (IDD_TERMINALTESTDLG+4)

#define IDC_STATIC              -1

//
// String IDs
//

#define IDS_ERR_ScriptNotFound      (IDS_ERR_BASE+0x0001)
#define IDS_ERR_UnexpectedEOF       (IDS_ERR_BASE+0x0002)
#define IDS_ERR_SyntaxError         (IDS_ERR_BASE+0x0003)
#define IDS_ERR_MainProcMissing     (IDS_ERR_BASE+0x0004)
#define IDS_ERR_IdentifierMissing   (IDS_ERR_BASE+0x0005)
#define IDS_ERR_StringMissing       (IDS_ERR_BASE+0x0006)
#define IDS_ERR_IntMissing          (IDS_ERR_BASE+0x0007)
#define IDS_ERR_InvalidType         (IDS_ERR_BASE+0x0008)
#define IDS_ERR_OutOfMemory         (IDS_ERR_BASE+0x0009)
#define IDS_ERR_InternalError       (IDS_ERR_BASE+0x000a)
#define IDS_ERR_InvalidParam        (IDS_ERR_BASE+0x000b)
#define IDS_ERR_InvalidIPParam      (IDS_ERR_BASE+0x000c)
#define IDS_ERR_InvalidPortParam    (IDS_ERR_BASE+0x000d)
#define IDS_ERR_InvalidRange        (IDS_ERR_BASE+0x000e)
#define IDS_ERR_InvalidScreenParam  (IDS_ERR_BASE+0x000f)
#define IDS_ERR_RParenMissing       (IDS_ERR_BASE+0x0010)
#define IDS_ERR_RequireInt          (IDS_ERR_BASE+0x0011)
#define IDS_ERR_RequireString       (IDS_ERR_BASE+0x0012)
#define IDS_ERR_RequireBool         (IDS_ERR_BASE+0x0013)
#define IDS_ERR_RequireIntString    (IDS_ERR_BASE+0x0014)
#define IDS_ERR_TypeMismatch        (IDS_ERR_BASE+0x0015)
#define IDS_ERR_Redefined           (IDS_ERR_BASE+0x0016)
#define IDS_ERR_Undefined           (IDS_ERR_BASE+0x0017)
#define IDS_ERR_RequireLabel        (IDS_ERR_BASE+0x0018)
#define IDS_ERR_DivByZero           (IDS_ERR_BASE+0x0019)
#define IDS_ERR_RequireIntStrBool   (IDS_ERR_BASE+0x001a)

#define IDS_CAP_Script              (IDS_RANDO_BASE+0x0001)

#define IDS_IP_Address              (IDS_RANDO_BASE+0X002)

#define IDS_RUN                     (IDS_RANDO_BASE+0X0010)
#define IDS_TEST                    (IDS_RANDO_BASE+0X0011)
#define IDS_COMPLETE                (IDS_RANDO_BASE+0X0012)
#define IDS_HALT                    (IDS_RANDO_BASE+0X0013)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\rassrvrc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by rassrvui.rc
//
#define VER_PRODUCTVER                  0074
#define IDC_HELP_BUTTON                 1197
#define IDD_SET_PASSWORD_WARNING_OTHER_FRIENDLY 5174
#define DID_UserTab_New                 7000
#define CID_UserTab_New_EB_Username     7001
#define CID_UserTab_New_EB_Fullname     7002
#define CID_UserTab_New_EB_Password1    7003
#define CID_UserTab_New_EB_Password2    7004
#define DID_UserTab_Callback            7005
#define CID_UserTab_Callback_RB_Caller  7006
#define CID_UserTab_Callback_RB_Admin   7007
#define CID_UserTab_Callback_EB_Number  7008
#define CID_UserTab_Callback_RB_No      7009
#define PID_GenTab                      7010
#define CID_GenTab_LV_Devices           7011
#define CID_GenTab_CB_Multilink         7012
#define CID_GenTab_PB_Properties        7013
#define CID_GenTab_CB_Vpn               7014
#define CID_GenTab_CB_ShowIcons         7015
#define DID_NetTab_Tcpipui              7016
#define CID_NetTab_Tcpipui_CB_ExposeNetwork 7017
#define CID_NetTab_Tcpipui_EB_Start     7018
#define CID_NetTab_Tcpipui_RB_Dhcp      7019
#define CID_NetTab_Tcpipui_RB_StaticPool 7020
#define CID_NetTab_Tcpipui_EB_Mask      7021
#define CID_NetTab_Tcpipui_CB_CallerSpec 7022
#define CID_NetTab_Tcpipui_EB_Range     7023
#define CID_NetTab_Tcpipui_EB_Total     7024
#define DID_NetTab_Ipxui                7025
#define CID_NetTab_Ipxui_RB_AutoAssign  7026
#define CID_NetTab_Ipxui_RB_ManualAssign 7027
#define CID_NetTab_Ipxui_CB_AssignSame  7028
#define CID_NetTab_Ipxui_EB_Netnum      7029
#define CID_NetTab_Ipxui_ST_Network     7030
#define CID_NetTab_Ipxui_CB_CallerSpec  7031
#define CID_NetTab_Ipxui_CB_ExposeNetwork 7032
#define DID_NetTab_GenProt              7033
#define CID_NetTab_GenProt_CB_ExposeNetwork 7034
#define PID_NetTab                      7035
#define CID_NetTab_LV_Components        7036
#define CID_NetTab_PB_Add               7037
#define CID_NetTab_PB_Remove            7038
#define CID_NetTab_PB_Properties        7039
#define CID_NetTab_ST_Description       7040
#define CID_NetTab_PB_SwitchToMMC       7041
#define PID_UserTab                     7042
#define CID_UserTab_LV_Users            7043
#define CID_UserTab_PB_New              7044
#define CID_UserTab_PB_Delete           7045
#define CID_UserTab_PB_Properties       7046
#define CID_UserTab_PB_SwitchToMMC      7047
#define PID_Wizard_UserTab              7049
#define CID_UserTab_CB_BypassDcc        7049
#define PID_Wizard_GenTab               7050
#define PID_Wizard_NetTab               7051
#define PID_Wizard_Vpn                  7052
#define CID_Wizard_Vpn_RB_Yes           7053
#define CID_Wizard_Vpn_RB_No            7054
#define PID_Wizard_Dccdev               7055
#define CID_Wizard_Dccdev_LB_Devices    7056
#define CID_UserTab_ST_AdvancedGroup    7057
#define CID_UserTab_ST_AdvancedText     7058
#define CID_NetTab_ST_AdvancedGroup     7059
#define CID_NetTab_ST_AdvancedText      7060
#define CID_Dccdev_PB_Properties        7061
#define CID_Wizard_Vpn_ST_Firewall      7062
#define SID_TCPIP_TITLE                 7301
#define SID_TCPIP_BADRANGE              7302
#define SID_TCPIP                       7303
#define SID_IPX                         7304
#define SID_NETBUI                      7305
#define ERR_GENERIC_CATAGORY            7306
#define ERR_GENERALTAB_CATAGORY         7307
#define ERR_USERTAB_CATAGORY            7308
#define ERR_ADVANCEDTAB_CATAGORY        7309
#define ERR_MULTILINK_CATAGORY          7310
#define ERR_RASSRV_CATAGORY             7311
#define ERR_GLOBAL_CATAGORY             7312
#define ERR_TCPIPPROP_CATAGORY          7313
#define ERR_IPXPROP_CATAGORY            7314
#define ERR_QUEUE_PROPERTY              7315
#define ERR_QUEUE_CATAGORY              7315
#define ERR_GENERIC_SUBCAT              7316
#define ERR_DEVICEDB_SUBCAT             7317
#define ERR_MISCDB_SUBCAT               7318
#define ERR_USERDB_SUBCAT               7319
#define ERR_PROTDB_SUBCAT               7320
#define ERR_LOGON_NAME_TOO_SMALL        7321
#define ERR_PASSWORD_TOO_SMALL          7322
#define ERR_PASSWORD_MISMATCH           7323
#define ERR_GENERIC_CODE                7324
#define ERR_LISTVIEW_SUBCAT             7325
#define ERR_USER_CANT_COMMIT_CHANGES    7326
#define ERR_CANT_ADD_USER_ACCESS        7327
#define ERR_CANT_ADD_USER_DUPLICATE     7328
#define ERR_CANT_ADD_USER_PASSWORD      7329
#define ERR_USER_CANT_RELOAD            7330
#define ERR_USER_DATABASE_CORRUPT       7331
#define ERR_USER_RESOURCE_ERROR         7332
#define ERR_USER_CANT_ROLLBACK_CHANGES  7333
#define ERR_DEVICE_DATABASE_CORRUPT     7334
#define ERR_GENERAL_RESOURCE            7335
#define ERR_GENERAL_CANT_COMMIT_CHANGES 7336
#define ERR_GENERAL_CANT_ROLLBACK_CHANGES 7337
#define ERR_PROT_DATABASE_CORRUPTED     7338
#define ERR_PROT_RESOURCE_ERROR         7339
#define ERR_PROT_CANT_COMMIT_CHANGES    7340
#define ERR_PROT_CANT_ROLLBACK_CHANGES  7341
#define ERR_TCPIP_CANT_SAVE             7342
#define ERR_IPX_CANT_SAVE               7343
#define ERR_TCPIP_CANT_DISPLAY          7344
#define ERR_IPX_CANT_DISPLAY            7345
#define ERR_TCPIP_CANT_LOAD             7346
#define ERR_IPX_CANT_LOAD               7347
#define ERR_SERVICE_CANT_START          7348
#define ERR_CANT_SHOW_NETTAB_INETCFG    7349
#define ERR_CANT_ADD_USER_GENERIC       7350
#define ERR_CANT_DELETE_USER_GENERAL    7351
#define ERR_CANT_REMOVE_NETCOMP_INUSE   7352
#define WRN_TITLE                       7353
#define WRN_DELETE_USER_PERMANENT       7354
#define WRN_SWITCHING_TO_MMC            7355
#define WRN_NETMASK_CHANGED             7356
#define SID_WIZUSERTITLE                7357
#define SID_WIZUSERSUBTITLE             7358
#define SID_WIZDEVICETITLE              7359
#define SID_WIZDEVICESUBTITLE           7360
#define SID_WIZVPNTITLE                 7361
#define SID_WIZVPNSUBTITLE              7362
#define SID_WIZPROTTITLE                7363
#define SID_WIZPROTSUBTITLE             7364
#define SID_WIZFINISHTITLE              7365
#define SID_WIZFINISHSUBTITLE           7366
#define SID_DEFAULT_CONNECTION_NAME     7367
#define SID_TCPIP_DESC                  7368
#define SID_IPX_DESC                    7369
#define SID_NBF_DESC                    7370
#define SID_NO_DEVICES1                 7371
#define SID_NO_DEVICES2                 7372
#define SID_NETWORKNUMBERLABEL          7373
#define SID_STARTNETNUMLABEL            7374
#define SID_NEWUSER                     7375
#define SID_WIZDCCDEVTITLE              7376
#define SID_WIZDCCDEVSUBTITLE           7377
#define SID_NO_DCC_DEVICES_INSTALLED    7378
#define WRN_WIZARD_NOT_ALLOWED_TITLE    7379
#define PID_Wizard_SwitchMmc            7379
#define WRN_WIZARD_NOT_ALLOWED_MSG      7380
#define SID_AUTO_NETNUM_LABEL           7381
#define SID_AUTO_NETNUMS_LABEL          7382
#define ERR_IPX_BAD_POOL_CONFIG         7383
#define SID_TCPIP_RANGE_SEPARATOR       7384
#define SID_COMPORT_FORMAT              7385
#define WRN_USERS_CONFIGURED_MMC        7386
#define ERR_CALLBACK_NUM_REQUIRED       7387
#define WRN_REBOOT_REQUIRED             7388
#define ERR_DEVICE_HAS_NO_CONFIG        7389
#define SID_TCPIP_RANGE_INVALID         7390
#define SID_STOP_FP_SERVICE             7391
#define SID_COM_PORT_NOT_ENABLED        7392
#define SID_DEFAULT_MSG_TITLE           7393
#define SID_TCPIP_InvalidPool           7394
#define SID_TCPIP_InvalidMask           7395
#define SID_TCPIP_InvalidNetId          7396
#define SID_TCPIP_NetidTooSpecific      7397
#define SID_TCPIP_NetidMaskSame         7398
#define SID_SERVICE_StopPending         7399
#define SID_DEVICE_DccDeviceFormat      7400
#define SID_DEVICE_MultiEndpointDeviceFormat 7401
#define SID_PPTP_Title                  7402
#define SID_L2TP_Title                  7403
#define SID_IKE_Title                   7404
#define SID_LoopbackAddr                7405
#define ERR_SERVICE_NOT_GRANTED         7406
#define SID_NAT_T_Title                 7407
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        7380
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         7063
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\rautil.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** rautil.h
** Remote Access RASAPI utility library
** Public header
**
** 12/26/95 Steve Cobb
*/

#ifndef _RAUTIL_H_
#define _RAUTIL_H_


#include <list.h>    // for LIST_ENTRY definitions
#include <serial.h>  // RAS serial media header, for SERIAL_TXT
#include <isdn.h>    // RAS ISDN media header, for ISDN_TXT
#include <x25.h>     // RAS X.25 media header, for X25_TXT
#include <rasmxs.h>  // RAS modem/X.25/switch device header, for MXS_*_TXT
#include <ras.h>     // Win32 RAS header, for constants


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

DWORD
FreeRasconnList(
    LIST_ENTRY *pListHead );

DWORD
GetRasconnList(
    LIST_ENTRY *pListHead );

DWORD
GetRasconnTable(
    OUT RASCONN** ppConnTable,
    OUT DWORD*    pdwConnCount );

DWORD
GetRasEntrynameTable(
    OUT RASENTRYNAME**  ppEntrynameTable,
    OUT DWORD*          pdwEntrynameCount );

DWORD
GetRasProjectionInfo(
    IN  HRASCONN    hrasconn,
    OUT RASAMB*     pamb,
    OUT RASPPPNBF*  pnbf,
    OUT RASPPPIP*   pip,
    OUT RASPPPIPX*  pipx,
    OUT RASPPPLCP*  plcp,
    OUT RASSLIP*    pslip,
    OUT RASPPPCCP*  pccp);

HRASCONN
HrasconnFromEntry(
    IN TCHAR* pszPhonebook,
    IN TCHAR* pszEntry );


#endif // _RAUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\rasscrpt.h ===
//============================================================================
// Copyright (c) Microsoft Corporation
//
// File:    rasscrpt.h
//
// History:
//  Abolade-Gbadegesin  Mar-29-96   Created.
//
// Contains declarations for the exported scripting API functions.
//============================================================================

#ifndef _RASSCRPT_H_
#define _RASSCRPT_H_


//
// Flags passed to RasScriptInit:
//
// RASSCRIPT_NotifyOnInput          Caller requires input-notification
// RASSCRIPT_HwndNotify             'hNotifier' is an HWND (defaults to event)
//
#define RASSCRIPT_NotifyOnInput     0x00000001
#define RASSCRIPT_HwndNotify        0x00000002


//
// event codes retrieved using RasScriptGetEventCode
//
#define SCRIPTCODE_Done             0
#define SCRIPTCODE_Halted           1
#define SCRIPTCODE_InputNotify      2
#define SCRIPTCODE_KeyboardEnable   3
#define SCRIPTCODE_KeyboardDisable  4
#define SCRIPTCODE_IpAddressSet     5
#define SCRIPTCODE_HaltedOnError    6


//
// path to log-file containing syntax errors, if any
//
#define RASSCRIPT_LOG               "%windir%\\system32\\ras\\script.log"



DWORD
APIENTRY
RasScriptExecute(
    IN      HRASCONN        hrasconn,
    IN      PBENTRY*        pEntry,
    IN      CHAR*           pszUserName,
    IN      CHAR*           pszPassword,
    OUT     CHAR*           pszIpAddress
    );


DWORD
RasScriptGetEventCode(
    IN      HANDLE          hscript
    );


DWORD
RasScriptGetIpAddress(
    IN      HANDLE          hscript,
    OUT     CHAR*           pszIpAddress
    );


DWORD
APIENTRY
RasScriptInit(
    IN      HRASCONN        hrasconn,
    IN      PBENTRY*        pEntry,
    IN      CHAR*           pszUserName,
    IN      CHAR*           pszPassword,
    IN      DWORD           dwFlags,
    IN      HANDLE          hNotifier,
    OUT     HANDLE*         phscript
    );


DWORD
APIENTRY
RasScriptReceive(
    IN      HANDLE          hscript,
    IN      BYTE*           pBuffer,
    IN OUT  DWORD*          pdwBufferSize
    );


DWORD
APIENTRY
RasScriptSend(
    IN      HANDLE          hscript,
    IN      BYTE*           pBuffer,
    IN      DWORD           dwBufferSize
    );


DWORD
APIENTRY
RasScriptTerm(
    IN      HANDLE          hscript
    );


#endif // _RASSCRPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\rassrvp.h ===
/*
    File    rassrvp.h

    Private header used to merge the ras server ui module
    with rasdlg.dll.

    Paul Mayfield, 12/4/97
*/

#ifndef __rassrv_private_header_for_merging
#define __rassrv_private_header_for_merging

// Callbacks for when processes/threads attach to this dll
DWORD RassrvHandleProcessAttach (HINSTANCE hInstDll, LPVOID pReserved);
DWORD RassrvHandleProcessDetach (HINSTANCE hInstDll, LPVOID pReserved);
DWORD RassrvHandleThreadAttach (HINSTANCE hInstDll, LPVOID pReserved);
DWORD RassrvHandleThreadDetach (HINSTANCE hInstDll, LPVOID pReserved);

// Function adds the host-side direct connect wizard pages
DWORD
APIENTRY
RassrvAddDccWizPages (
    IN LPFNADDPROPSHEETPAGE pfnAddPage,
    IN LPARAM               lParam,
    IN OUT PVOID *          ppvContext);

// Function causes the ras-server specific wizard pages 
// to allow activation or not.
DWORD
APIENTRY
RassrvShowWizPages (
    IN PVOID pvContext,         // Context to be affected
    IN BOOL bShow);             // TRUE to show, FALSE to hide

// Saves any server changes related to the 
// given type.
DWORD 
APIENTRY
RassrvCommitSettings (
    IN PVOID pvContext,         // Context to commit
    IN DWORD dwRasWizType);     // Type of settings to commit

// Function returns the suggested name for an incoming connection. 
DWORD
APIENTRY
RassrvGetDefaultConnectionName (
    IN OUT PWCHAR pszBuffer,            // Buffer in which to place name
    IN OUT LPDWORD lpdwBufSize);        // Size of buffer in bytes

// Returns the maximum number of pages for the
// a ras server wizard of the given type
DWORD 
APIENTRY
RassrvQueryMaxPageCount(
    IN DWORD dwRasWizType);
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\rassrvrh.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rassrvui.rc
// Generated by Paul Mayfield
//
#define IDH_UserTab_LV_Users                  7001
#define IDH_UserTab_PB_SwitchToMMC            7002
#define IDH_UserTab_New_EB_Username           7004
#define IDH_UserTab_New_EB_Fullname           7005
#define IDH_UserTab_New_EB_Password1          7006
#define IDH_UserTab_New_EB_Password2          7007
#define IDH_UserTab_Callback_RB_Admin         7008
#define IDH_UserTab_Callback_EB_Number        7009
#define IDH_UserTab_Callback_RB_No            7010
#define IDH_GenTab_LV_Devices                 7011
#define IDH_GenTab_CB_Multilink               7012
#define IDH_GenTab_PB_Properties              7013
#define IDH_GenTab_CB_Vpn                     7014
#define IDH_GenTab_CB_ShowIcons               7015
#define IDH_NetTab_LV_Components              7016
#define IDH_NetTab_PB_Properties              7017
#define IDH_NetTab_PB_Remove                  7018
#define IDH_NetTab_PB_Add                     7019
#define IDH_NetTab_Tcpipui_EB_Start           7020
#define IDH_NetTab_Tcpipui_RB_Dhcp            7021
#define IDH_NetTab_Tcpipui_RB_StaticPool      7022
#define IDH_NetTab_Tcpipui_EB_Mask            7023
#define IDH_NetTab_Tcpipui_CB_CallerSpec      7024
#define IDH_NetTab_Ipxui_RB_AutoAssign        7025
#define IDH_NetTab_Ipxui_RB_ManualAssign      7026
#define IDH_NetTab_Ipxui_CB_AssignSame        7027
#define IDH_NetTab_Ipxui_EB_Netnum            7028
#define IDH_UserTab_PB_New                    7065
#define IDH_UserTab_PB_Delete                 7066
#define IDH_UserTab_PB_Properties             7067
#define IDH_Wizard_Dccdev_LB_Devices          7068
#define IDH_NetTab_Ipxui_CB_CallerSpec        7069
#define IDH_UserTab_Callback_RB_Caller        7071

#define IDH_UserTab_CB_BypassDcc              7072
#define IDH_NetTab_Tcpipui_CB_ExposeNetwork   7073
#define IDH_NetTab_Tcpipui_EB_Range           7074
#define IDH_NetTab_Tcpipui_EB_Total           7075
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\rmutil.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** rmutil.h
** Remote Access RASMAN utility library
** Public header
**
** 06/20/95 Steve Cobb
** 12/26/95 Merge Abolade Gbadesin routines
*/

#ifndef _RMUTIL_H_
#define _RMUTIL_H_


#include <rasman.h>  // RAS connection manager header
#include <serial.h>  // RAS serial media header, for SERIAL_TXT
#include <isdn.h>    // RAS ISDN media header, for ISDN_TXT
#include <x25.h>     // RAS X.25 media header, for X25_TXT
#include <rasmxs.h>  // RAS modem/X.25/switch device header, for MXS_*_TXT
#include <ras.h>     // Win32 RAS header, for constants

/* Private RASAPI32 entrypoints.
*/
extern HPORT APIENTRY RasGetHport( HRASCONN );
extern DWORD APIENTRY RasSetOldPassword( HRASCONN, CHAR* );


/*----------------------------------------------------------------------------
** Constants
**----------------------------------------------------------------------------
*/

/* String translation flags.
*/
#define XLATE_Ctrl      0x00000001
#define XLATE_Cr        0x00000002
#define XLATE_CrSpecial 0x00000004
#define XLATE_Lf        0x00000008
#define XLATE_LfSpecial 0x00000010
#define XLATE_LAngle    0x00000020
#define XLATE_RAngle    0x00000040
#define XLATE_BSlash    0x00000080
#define XLATE_SSpace    0x00000100

#define XLATE_None          0
#define XLATE_Diagnostic    (XLATE_Ctrl)
#define XLATE_ErrorResponse (XLATE_Ctrl | XLATE_LAngle | XLATE_RAngle \
                               | XLATE_BSlash | XLATE_CrSpecial \
                               | XLATE_LfSpecial)

/*----------------------------------------------------------------------------
** Datatypes
**----------------------------------------------------------------------------
*/
struct RASDEV {

    HANDLE          RD_Handle;
    DWORD           RD_Flags;
    PTSTR           RD_DeviceName;
    TCHAR           RD_PortName[MAX_PORT_NAME + 1];
    TCHAR           RD_DeviceType[RAS_MaxDeviceType + 1];

};

typedef struct RASDEV RASDEV, *PRASDEV, FAR *LPRASDEV;

#define RDFLAG_DialIn       0x00000001
#define RDFLAG_DialOut      0x00000002
#define RDFLAG_Router       0x00000004
#define RDFLAG_IsDialedIn   0x00000008
#define RDFLAG_IsDialedOut  0x00000010
#define RDFLAG_IsRouter     0x00000020
#define RDFLAG_User1        0x80000000


struct RASDEVSTATS {

    DWORD           RDS_Condition;
    DWORD           RDS_Flags;
    DWORD           RDS_LineSpeed;
    DWORD           RDS_ConnectTime;
    DWORD           RDS_InBytes;
    DWORD           RDS_InFrames;
    DWORD           RDS_InCompRatio;
    DWORD           RDS_OutBytes;
    DWORD           RDS_OutFrames;
    DWORD           RDS_OutCompRatio;
    DWORD           RDS_InBytesTotal;
    DWORD           RDS_OutBytesTotal;
    DWORD           RDS_ErrCRC;
    DWORD           RDS_ErrTimeout;
    DWORD           RDS_ErrAlignment;
    DWORD           RDS_ErrFraming;
    DWORD           RDS_ErrHwOverruns;
    DWORD           RDS_ErrBufOverruns;
    HRASCONN        RDS_Hrasconn;

};

typedef struct RASDEVSTATS RASDEVSTATS, *PRASDEVSTATS;


struct RASCONNENTRY {

    LIST_ENTRY      RCE_Node;
    RASCONN        *RCE_Entry;
    LIST_ENTRY      RCE_Links;

};

typedef struct RASCONNENTRY RASCONNENTRY, *PRASCONNENTRY;


struct RASCONNLINK {

    LIST_ENTRY      RCL_Node;
    RASCONN         RCL_Link;

};

typedef struct RASCONNLINK RASCONNLINK, *PRASCONNLINK;


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

DWORD
ClearRasdevStats(
    IN RASDEV*  pdev,
    IN BOOL     fBundle );

DWORD
DeviceIdFromDeviceName(
    TCHAR* pszDeviceName );

DWORD
FreeRasdevTable(
    RASDEV* pDevTable,
    DWORD   iDevCount );

DWORD
GetRasConnection0Table(
    OUT RAS_CONNECTION_0 ** ppRc0Table,
    OUT DWORD *             piRc0Count );

DWORD
GetConnectTime(
    IN  HRASCONN hrasconn,
    OUT DWORD*   pdwConnectTime );

DWORD
GetRasconnFraming(
    IN  HRASCONN hrasconn,
    OUT DWORD*   pdwSendFraming,
    OUT DWORD*   pdwRecvFraming );

DWORD
GetRasconnFromRasdev(
    IN  RASDEV*   pdev,
    OUT RASCONN** ppconn,
    IN  RASCONN*  pConnTable OPTIONAL,
    IN  DWORD     iConnCount OPTIONAL );

DWORD
GetRasdevBundle(
    IN  RASDEV*  pdev,
    OUT DWORD*   pdwBundle );

DWORD
GetRasdevFraming(
    IN  RASDEV*  pdev,
    OUT DWORD*   pdwFraming );

DWORD
GetRasdevFromRasconn(
    IN  RASCONN* pconn,
    OUT RASDEV** ppdev,
    IN  RASDEV*  pDevTable OPTIONAL,
    IN  DWORD    iDevCount OPTIONAL );

DWORD
GetRasdevFromRasPort0(
    IN  RAS_PORT_0* pport,
    OUT RASDEV**    ppdev,
    IN  RASDEV*     pDevTable OPTIONAL,
    IN  DWORD       iDevCount OPTIONAL );

DWORD
GetRasDeviceString(
    IN  HPORT  hport,
    IN  CHAR*  pszDeviceType,
    IN  CHAR*  pszDeviceName,
    IN  CHAR*  pszKey,
    OUT CHAR** ppszValue,
    IN  DWORD  dwXlate );

DWORD
GetRasdevStats(
    IN  RASDEV*      pdev,
    OUT RASDEVSTATS* pstats );

DWORD
GetRasdevTable(
    OUT RASDEV** ppDevTable,
    OUT DWORD*   piDevCount );

DWORD
GetRasMessage(
    IN  HRASCONN hrasconn,
    OUT TCHAR**  ppszMessage );

DWORD
GetRasPads(
    OUT RASMAN_DEVICE** ppDevices,
    OUT DWORD*          pdwEntries );

DWORD
GetRasPort0FromRasdev(
    IN  RASDEV*         pdev,
    OUT RAS_PORT_0**    ppport,
    IN  RAS_PORT_0*     pPortTable OPTIONAL,
    IN  DWORD           iPortCount OPTIONAL );

DWORD
GetRasPort0Info(
    IN  HANDLE          hPort,
    OUT RAS_PORT_1 *    pRasPort1 );

DWORD
GetRasPort0Table(
    OUT RAS_PORT_0 **   ppPortTable,
    OUT DWORD *         piPortCount );

TCHAR *
GetRasPort0UserString(
    IN  RAS_PORT_0 *    pport,
    IN  TCHAR *         pszUser );

VOID
GetRasPortMaxBps(
    IN  HPORT  hport,
    OUT DWORD* pdwMaxConnectBps,
    OUT DWORD* pdwMaxCarrierBps );

VOID
GetRasPortModemSettings(
    IN  HPORT hport,
    OUT BOOL* pfHwFlowDefault,
    OUT BOOL* pfEcDefault,
    OUT BOOL* pfEccDefault );

DWORD
GetRasPorts(
    IN  HANDLE        hConnection,
    OUT RASMAN_PORT** ppPorts,
    OUT DWORD*        pdwEntries );

DWORD
GetRasPortString(
    IN  HPORT  hport,
    IN  CHAR*  pszKey,
    OUT CHAR** ppszValue,
    IN  DWORD  dwXlate );

DWORD
GetRasSwitches(
    IN  HANDLE          hConnection,
    OUT RASMAN_DEVICE** ppDevices,
    OUT DWORD*          pdwEntries );

TCHAR*
GetRasX25Diagnostic(
    IN HRASCONN hrasconn );

BOOL
IsRasdevBundled(
    IN  RASDEV* prasdev,
    IN  RASDEV* pDevTable,
    IN  DWORD   iDevCount );

CHAR*
PszFromRasValue(
    IN RAS_VALUE* prasvalue,
    IN DWORD      dwXlate );

DWORD
RasPort0Hangup(
    IN  HANDLE      hPort );

#endif // _RMUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\rnk.h ===
/* Copyright (c) 1996, Microsoft Corporation, all rights reserved
**
** rnk.h
** Remote Access shortcut file (.RNK) library
** Public header
**
** 02/15/96 Steve Cobb
*/

#ifndef _RNK_H_
#define _RNK_H_


/*----------------------------------------------------------------------------
** Constants
**----------------------------------------------------------------------------
*/

#define RNK_SEC_Main      "Dial-Up Shortcut"
#define RNK_KEY_Phonebook "Phonebook"
#define RNK_KEY_Entry     "Entry"


/*----------------------------------------------------------------------------
** Datatypes
**----------------------------------------------------------------------------
*/

/* Information read from the .RNK file.
*/
#define RNKINFO struct tagRNKINFO
RNKINFO
{
    TCHAR* pszPhonebook;
    TCHAR* pszEntry;
};


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

VOID
FreeRnkInfo(
    IN RNKINFO* pInfo );

RNKINFO*
ReadShortcutFile(
    IN TCHAR* pszRnkPath );

DWORD
WriteShortcutFile(
    IN TCHAR* pszRnkPath,
    IN TCHAR* pszPbkPath,
    IN TCHAR* pszEntry );


#endif // _RNK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\tapiutil.h ===
/* Copyright (c) 1996, Microsoft Corporation, all rights reserved
**
** tapiutil.h
** TAPI helper routines
** Public header
**
** 06/18/95 Steve Cobb
*/

#ifndef _TAPIUTIL_H_
#define _TAPIUTIL_H_


#include <tapi.h>


/*----------------------------------------------------------------------------
** Datatypes
**----------------------------------------------------------------------------
*/

/* Information about a TAPI location.  See GetLocationInfo.
*/
#define LOCATION struct tagLOCATION
LOCATION
{
    TCHAR* pszName;
    DWORD  dwId;
};


/* Information about a TAPI country.  See GetCountryInfo.
*/
#define COUNTRY struct tagCOUNTRY
COUNTRY
{
    TCHAR* pszName;
    DWORD  dwId;
    DWORD  dwCode;
};


/*----------------------------------------------------------------------------
** Prototypes (alphabetically)
**----------------------------------------------------------------------------
*/

VOID
FreeCountryInfo(
    IN COUNTRY* pCountries,
    IN DWORD    cCountries );

VOID
FreeLocationInfo(
    IN LOCATION* pLocations,
    IN DWORD     cLocations );

DWORD
GetCountryInfo(
    OUT COUNTRY** ppCountries,
    OUT DWORD*    pcCountries,
    IN  DWORD     dwCountryID );

DWORD
GetCurrentLocation(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp );

DWORD
GetLocationInfo(
    IN     HINSTANCE  hInst,
    IN OUT HLINEAPP*  pHlineapp,
    OUT    LOCATION** ppLocations,
    OUT    DWORD*     pcLocations,
    OUT    DWORD*     pdwCurLocation );

DWORD
SetCurrentLocation(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    IN     DWORD     dwLocationId );

DWORD
TapiConfigureDlg(
    IN     HWND   hwndOwner,
    IN     DWORD  dwDeviceId,
    IN OUT BYTE** ppBlob,
    IN OUT DWORD* pcbBlob );

DWORD
TapiInit(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    OUT    DWORD*    pcDevices );

DWORD
TapiLocationDlg(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    IN     HWND      hwndOwner,
    IN     DWORD     dwCountryCode,
    IN     TCHAR*    pszAreaCode,
    IN     TCHAR*    pszPhoneNumber,
    IN     DWORD     dwDeviceId );

DWORD APIENTRY
TapiNewLocation(
    IN TCHAR* pszName );

DWORD
TapiNoLocationDlg(
    IN HINSTANCE hInst,
    IN HLINEAPP* pHlineapp,
    IN HWND      hwndOwner );

DWORD APIENTRY
TapiRemoveLocation(
    IN DWORD dwID );

DWORD APIENTRY
TapiRenameLocation(
    IN TCHAR* pszOldName,
    IN TCHAR* pszNewName );

DWORD
TapiShutdown(
    IN HLINEAPP hlineapp );

DWORD
TapiTranslateAddress(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    IN     DWORD     dwCountryCode,
    IN     TCHAR*    pszAreaCode,
    IN     TCHAR*    pszPhoneNumber,
    IN     DWORD     dwDeviceId,
    IN     BOOL      fDialable,
    OUT    TCHAR**   ppszResult );


#endif // _TAPIUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\perf\globals.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfras.c

Abstract:

    Global variables, except for the ones in dataras.c, for rasctr.dll.

Created:

    Patrick Y. Ng               12 Aug 93

Revision History


--*/

//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddser.h>

#include <windows.h>

#include "globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\uiutil.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** uiutil.h
** UI helper routines
** Public header
**
** 08/25/95 Steve Cobb
*/

#ifndef _UIUTIL_H_
#define _UIUTIL_H_


#include <nouiutil.h>


/* IP address custom control definitions.
*/
#ifndef EXCL_IPADDR_H
#include <ipaddr.h>
#endif

/* Error and Message dialog definitions.
*/
#ifndef EXCL_POPUPDLG_H
#include <popupdlg.h>
#endif


/*----------------------------------------------------------------------------
** Constants/datatypes
**----------------------------------------------------------------------------
*/

/* ListView of devices indices.
*/
#define DI_Modem   0
#define DI_Adapter 1
#define DI_Direct  2
#define DI_Phone   3

#define UI_Connections_User 0

#define NI_Protocol 0
#define NI_Service  1
#define NI_Client   2

/* Bitmap styles for use with Button_CreateBitmap.
*/
#define BMS_OnLeft  0x100
#define BMS_OnRight 0x200

#define BITMAPSTYLE enum tagBITMAPSTYLE
BITMAPSTYLE
{
    BMS_UpArrowOnLeft = BMS_OnLeft,
    BMS_DownArrowOnLeft,
    BMS_UpTriangleOnLeft,
    BMS_DownTriangleOnLeft,
    BMS_UpArrowOnRight = BMS_OnRight,
    BMS_DownArrowOnRight,
    BMS_UpTriangleOnRight,
    BMS_DownTriangleOnRight
};


/* The extended list view control calls the owner back to find out the layout
** and desired characteristics of the enhanced list view.
*/
#define LVX_MaxCols      10
#define LVX_MaxColTchars 512

/* 'dwFlags' option bits.
*/
#define LVXDI_DxFill     1  // Auto-fill wasted space on right (recommended)
#define LVXDI_Blend50Sel 2  // Dither small icon if selected (not recommended)
#define LVXDI_Blend50Dis 4  // Dither small icon if disabled (recommended)

/* 'adwFlags' option bits.
*/
#define LVXDIA_3dFace 1  // Column is not editable but other columns are
#define LVXDIA_Static 2  // Emulates static text control w/icon if disabled

/* Returned by owner at draw item time.
*/
#define LVXDRAWINFO struct tagLVXDRAWINFO
LVXDRAWINFO
{
    /* The number of columns.  The list view extensions require that your
    ** columns are numbered sequentially from left to right where 0 is the
    ** item column and 1 is the first sub-item column.  Required always.
    */
    INT cCols;

    /* Pixels to indent this item, or -1 to indent a "small icon" width.  Set
    ** 0 to disable.
    */
    INT dxIndent;

    /* LVXDI_* options applying to all columns.
    */
    DWORD dwFlags;

    /* LVXDIA_* options applying to individual columns.
    */
    DWORD adwFlags[ LVX_MaxCols ];
};

typedef LVXDRAWINFO* (*PLVXCALLBACK)( IN HWND, IN DWORD dwItem );

/* Sent by ListView when check changes on an item
*/
#define LVXN_SETCHECK (LVN_LAST + 1)

/* Sent by ListView when item is double clicked so properties can be 
 * raised.
*/
#define LVXN_DBLCLK (LVN_LAST + 2)

/* SetOffDesktop actions.
*/
#define SOD_MoveOff        1
#define SOD_MoveBackFree   2
#define SOD_MoveBackHidden 3
#define SOD_Free           4
#define SOD_GetOrgRect     5


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

VOID
AddContextHelpButton(
    IN HWND hwnd );

VOID
Button_MakeDefault(
    IN HWND hwndDlg,
    IN HWND hwndPb );

HBITMAP
Button_CreateBitmap(
    IN HWND        hwndPb,
    IN BITMAPSTYLE bitmapstyle );

VOID
CancelOwnedWindows(
    IN HWND hwnd );

VOID
CenterWindow(
    IN HWND hwnd,
    IN HWND hwndRef );

//For whislter bug 320863
//
VOID
CenterExpandWindowRemainLeftMargin(
    IN HWND hwnd,
    IN HWND hwndRef,
    BOOL bHoriz,
    BOOL bVert,
    IN HWND hwndVertBottomBound);

VOID
CloseOwnedWindows(
    IN HWND hwnd );

INT
ComboBox_AddItem(
    IN HWND    hwndLb,
    IN LPCTSTR pszText,
    IN VOID*   pItem );

INT
ComboBox_AddItemFromId(
    IN HINSTANCE hinstance,
    IN HWND      hwndLb,
    IN DWORD     dwStringId,
    IN VOID*     pItem );

INT
ComboBox_AddItemSorted(
    IN HWND    hwndLb,
    IN LPCTSTR pszText,
    IN VOID*   pItem );

VOID
ComboBox_AutoSizeDroppedWidth(
    IN HWND hwndLb );

VOID
ComboBox_FillFromPszList(
    IN HWND     hwndLb,
    IN DTLLIST* pdtllistPsz );

VOID*
ComboBox_GetItemDataPtr(
    IN HWND hwndLb,
    IN INT  nIndex );

TCHAR*
ComboBox_GetPsz(
    IN HWND hwnd,
    IN INT  nIndex );

VOID
ComboBox_SetCurSelNotify(
    IN HWND hwndLb,
    IN INT  nIndex );

TCHAR*
Ellipsisize(
    IN HDC    hdc,
    IN TCHAR* psz,
    IN INT    dxColumn,
    IN INT    dxColText OPTIONAL );

VOID
ExpandWindow(
    IN HWND hwnd,
    IN LONG dx,
    IN LONG dy );

TCHAR*
GetText(
    IN HWND hwnd );

HWND
HwndFromCursorPos(
    IN HINSTANCE    hinstance,
    IN POINT*       ppt OPTIONAL );

LPTSTR
IpGetAddressAsText(
    HWND    hwndIp );

void
IpSetAddressText(
    HWND    hwndIp,
    LPCTSTR pszIpAddress );

INT
ListBox_AddItem(
    IN HWND   hwndLb,
    IN TCHAR* pszText,
    IN VOID*  pItem );

TCHAR*
ListBox_GetPsz(
    IN HWND hwnd,
    IN INT  nIndex );

INT
ListBox_IndexFromString(
    IN HWND   hwnd,
    IN TCHAR* psz );

VOID
ListBox_SetCurSelNotify(
    IN HWND hwndLb,
    IN INT  nIndex );

BOOL
ListView_GetCheck(
    IN HWND hwndLv,
    IN INT  iItem );

UINT
ListView_GetCheckedCount(
    IN HWND hwndLv );

VOID*
ListView_GetParamPtr(
    IN HWND hwndLv,
    IN INT  iItem );

VOID*
ListView_GetSelectedParamPtr(
    IN HWND hwndLv );

VOID
ListView_InsertSingleAutoWidthColumn(
    HWND hwndLv );

BOOL
ListView_InstallChecks(
    IN HWND      hwndLv,
    IN HINSTANCE hinst );

BOOL
ListView_OwnerHandler(
    IN HWND         hwnd,
    IN UINT         unMsg,
    IN WPARAM       wparam,
    IN LPARAM       lparam,
    IN PLVXCALLBACK pLvxCallback );

VOID
ListView_SetCheck(
    IN HWND hwndLv,
    IN INT  iItem,
    IN BOOL fCheck );

BOOL
ListView_IsCheckDisabled(
        IN HWND hwndLv,
        IN INT  iItem);

VOID
ListView_DisableCheck(
        IN HWND hwndLv,
        IN INT  iItem);

VOID
ListView_EnableCheck(
        IN HWND hwndLv,
        IN INT  iItem);

VOID
ListView_SetDeviceImageList(
    IN HWND      hwndLv,
    IN HINSTANCE hinst );

VOID
ListView_SetUserImageList(
    IN HWND      hwndLv,
    IN HINSTANCE hinst );

VOID
ListView_SetNetworkComponentImageList(
    IN HWND      hwndLv,
    IN HINSTANCE hinst );

BOOL
ListView_SetParamPtr(
    IN HWND  hwndLv,
    IN INT   iItem,
    IN VOID* pParam );

VOID
ListView_UninstallChecks(
    IN HWND hwndLv );

DWORD
LoadRas(
    IN HINSTANCE hInst,
    IN HWND      hwnd );

VOID
Menu_CreateAccelProxies(
    IN HINSTANCE hinst,
    IN HWND      hwndParent,
    IN DWORD     dwMid );

BOOL
SetEvenTabWidths(
    IN HWND  hwndDlg,
    IN DWORD cPages );

VOID
SlideWindow(
    IN HWND hwnd,
    IN HWND hwndParent,
    IN LONG dx,
    IN LONG dy );

VOID
UnclipWindow(
    IN HWND hwnd );

BOOL
SetDlgItemNum(
    IN HWND     hwndDlg,
    IN INT      iDlgItem,
    IN UINT     uValue );

VOID
ScreenToClientRect(
    IN     HWND  hwnd,
    IN OUT RECT* pRect );

BOOL
SetOffDesktop(
    IN  HWND    hwnd,
    IN  DWORD   dwAction,
    OUT RECT*   prectOrg );

VOID
UnloadRas(
    void );


#endif // _UIUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\treelist.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    treelist.h
//
// History:
//  Abolade Gbadegesin   Nov-20-1995    Created.
//
// The control whose declarations are included here provides a view
// which is a hybrid treeview/listview. Like a listview, each item
// may have zero or more subitems. Like a treeview, items are organized
// hierarchically, and displayed as a n-ary tree.
//
//  [  Header1        ][ Header2
//  -- Level 1          subtext
//      |- Level 2      subtext
//      |   |- Level 3
//      |   +- Level 3
//      |- Level 2      subtext
//      +- Level 2
//  +- Level 1          subtext
//
//
// The control is implemented as window which provides item-management,
// and which contains a listview window to which display is delegated.
//
// Once the window class has been initialized by calling TL_Init(),
// a treelist window can be created by calling CreateWindow() or
// CreateWindowEx() and passing it WC_TREELIST as the name of the class
// of window to be created.
//
// Communication with the window is via message passing, and macros are
// provided below for the operations supported by the treelist.
//
// As with a listview, at least one column must be inserted into the treelist
// before inserted items are displayed. Columns are described using 
// the LV_COLUMN structure defined in commctrl.h. Use the macros
// TreeList_InsertColumn() and TreeList_DeleteColumn() for column management.
// 
// Item insertion and deletion shoudl be done with TreeList_InsertItem() and
// TreeList_DeleteItem(). The insertion macro takes a TL_INSERTSTRUCT,
// which contains a pointer to a LV_ITEM structure which, as with listviews,
// is used to describe the item to be inserted. The LV_ITEM structure
// is defined in commctrl.h. (Note the iItem field is ignored).
// As with a treeview, once items have been inserted, there are referred to
// via handles. The type for treelist handles is HTLITEM.
//
// Once an item has been inserted, its attributes can be retreived or changed,
// it can be deleted, and subitems can be set for it. The LV_ITEM structure
// is used to retrieve or set an items attributes, and the iItem field
// is used to store the HTLITEM of the item to which the operation refers.
//
//============================================================================


#ifndef _TREELIST_H_
#define _TREELIST_H_


//
// Window class name string
//

#define WC_TREELIST         TEXT("TreeList")


//
// Item handle definition
//

typedef VOID *HTLITEM;


//
// struct passed to TreeList_InsertItem
//

typedef struct _TL_INSERTSTRUCT {

    HTLITEM     hParent; 
    HTLITEM     hInsertAfter;
    LV_ITEM    *plvi;

} TL_INSERTSTRUCT;



//
// values for TL_INSERTSTRUCT::hInsertAfter
//

#define TLI_FIRST           ((HTLITEM)UlongToPtr(0xffff0001))
#define TLI_LAST            ((HTLITEM)UlongToPtr(0xffff0002))
#define TLI_SORT            ((HTLITEM)UlongToPtr(0xffff0003))


//
// struct sent in notifications by a treelist
//

typedef struct _NMTREELIST {

    NMHDR   hdr;
    HTLITEM hItem;
    LPARAM  lParam;

} NMTREELIST;


//
// flags for TreeList_GetNextItem
//

#define TLGN_FIRST          0x0000
#define TLGN_PARENT         0x0001
#define TLGN_CHILD          0x0002
#define TLGN_NEXTSIBLING    0x0004
#define TLGN_PREVSIBLING    0x0008
#define TLGN_ENUMERATE      0x0010
#define TLGN_SELECTION      0x0020


//
// flags for TreeList_Expand
//

#define TLE_EXPAND          0x0001
#define TLE_COLLAPSE        0x0002
#define TLE_TOGGLE          0x0003


#define TLM_FIRST           (WM_USER + 1)
#define TLM_INSERTITEM      (TLM_FIRST + 0)
#define TLM_DELETEITEM      (TLM_FIRST + 1)
#define TLM_DELETEALLITEMS  (TLM_FIRST + 2)
#define TLM_GETITEM         (TLM_FIRST + 3)
#define TLM_SETITEM         (TLM_FIRST + 4)
#define TLM_GETITEMCOUNT    (TLM_FIRST + 5)
#define TLM_GETNEXTITEM     (TLM_FIRST + 6)
#define TLM_EXPAND          (TLM_FIRST + 7)
#define TLM_SETIMAGELIST    (TLM_FIRST + 8)
#define TLM_GETIMAGELIST    (TLM_FIRST + 9)
#define TLM_INSERTCOLUMN    (TLM_FIRST + 10)
#define TLM_DELETECOLUMN    (TLM_FIRST + 11)
#define TLM_SETSELECTION    (TLM_FIRST + 12)
#define TLM_REDRAW          (TLM_FIRST + 13)
#define TLM_ISITEMEXPANDED  (TLM_FIRST + 14)
#define TLM_GETCOLUMNWIDTH  (TLM_FIRST + 15)
#define TLM_SETCOLUMNWIDTH  (TLM_FIRST + 16)

#define TLN_FIRST           (0U - 1000U)
#define TLN_DELETEITEM      (TLN_FIRST - 1)
#define TLN_SELCHANGED      (TLN_FIRST - 2)


BOOL
TL_Init(
    HINSTANCE hInstance
    );

#define TreeList_InsertItem(hwnd, ptlis) \
        (HTLITEM)SendMessage( \
            (hwnd), TLM_INSERTITEM, 0, (LPARAM)(CONST TL_INSERTSTRUCT *)(ptlis)\
            )
#define TreeList_DeleteItem(hwnd, hItem) \
        (BOOL)SendMessage( \
            (hwnd), TLM_DELETEITEM, 0, (LPARAM)(CONST HTLITEM)(hItem) \
            )
#define TreeList_DeleteAllItems(hwnd) \
        (BOOL)SendMessage((hwnd), TLM_DELETEALLITEMS, 0, 0)
#define TreeList_GetItem(hwnd, pItem) \
        (BOOL)SendMessage( \
            (hwnd), TLM_GETITEM, 0, (LPARAM)(LV_ITEM *)(pItem) \
            )
#define TreeList_SetItem(hwnd, pItem) \
        (BOOL)SendMessage( \
            (hwnd), TLM_SETITEM, 0, (LPARAM)(CONST LV_ITEM *)(pItem) \
            )
#define TreeList_GetItemCount(hwnd) \
        (UINT)SendMessage((hwnd), TLM_GETITEMCOUNT, 0, 0)
#define TreeList_GetNextItem(hwnd, hItem, flag) \
        (HTLITEM)SendMessage( \
            (hwnd), TLM_GETNEXTITEM, (WPARAM)(UINT)(flag), \
            (LPARAM)(CONST HTLITEM)(hItem) \
            )
#define TreeList_GetFirst(hwnd) \
        TreeList_GetNextItem((hwnd), NULL, TLGN_FIRST)
#define TreeList_GetParent(hwnd, hItem) \
        TreeList_GetNextItem((hwnd), (hItem), TLGN_PARENT)
#define TreeList_GetChild(hwnd, hItem) \
        TreeList_GetNextItem((hwnd), (hItem), TLGN_CHILD)
#define TreeList_GetNextSibling(hwnd, hItem) \
        TreeList_GetNextItem((hwnd), (hItem), TLGN_NEXTSIBLING)
#define TreeList_GetPrevSibling(hwnd, hItem) \
        TreeList_GetNextItem((hwnd), (hItem), TLGN_PREVSIBLING)
#define TreeList_GetEnumerate(hwnd, hItem) \
        TreeList_GetNextItem((hwnd), (hItem), TLGN_ENUMERATE)
#define TreeList_GetSelection(hwnd) \
        TreeList_GetNextItem((hwnd), NULL, TLGN_SELECTION)
#define TreeList_Expand(hwnd, hItem, flag) \
        (BOOL)SendMessage( \
            (hwnd), TLM_EXPAND, (WPARAM)(UINT)(flag), \
            (LPARAM)(CONST HTLITEM)(hItem) \
            )
#define TreeList_SetImageList(hwnd, himl) \
        (BOOL)SendMessage( \
            (hwnd), TLM_SETIMAGELIST, 0, (LPARAM)(CONST HIMAGELIST)(himl) \
            )
#define TreeList_GetImageList(hwnd, himl) \
        (HIMAGELIST)SendMessage((hwnd), TLM_GETIMAGELIST, 0, 0)
#define TreeList_InsertColumn(hwnd, iCol, pCol) \
        (INT)SendMessage( \
            (hwnd),  TLM_INSERTCOLUMN, (WPARAM)(INT)(iCol), \
            (LPARAM)(CONST LV_COLUMN *)(pCol) \
            )
#define TreeList_DeleteColumn(hwnd, iCol) \
        (BOOL)SendMessage((hwnd), TLM_DELETECOLUMN, (WPARAM)(INT)(iCol), 0)
#define TreeList_SetSelection(hwnd, hItem) \
        (BOOL)SendMessage( \
            (hwnd), TLM_SETSELECTION, 0, (LPARAM)(CONST HTLITEM)(hItem) \
            )
#define TreeList_Redraw(hwnd) \
        (BOOL)SendMessage((hwnd), TLM_REDRAW, 0, 0)
#define TreeList_IsItemExpanded(hwnd, hItem) \
        (BOOL)SendMessage( \
            (hwnd), TLM_ISITEMEXPANDED, 0, (LPARAM)(CONST HTLITEM)(hItem) \
            )
#define TreeList_GetColumnWidth(hwnd, iCol) \
        (INT)SendMessage((hwnd), TLM_GETCOLUMNWIDTH, (WPARAM)(int)(iCol), 0)
#define TreeList_SetColumnWidth(hwnd, iCol, cx) \
        (BOOL)SendMessage( \
            (hwnd), TLM_SETCOLUMNWIDTH, (WPARAM)(int)(iCol), \
            MAKELPARAM((cx), 0) \
            )


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\perf\dataras.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

      dataras.h

Abstract:

    Header file for the RAS Extensible Object data definitions

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

   Russ Blake		02/24/93
   Thomas J. Dimitri	05/28/93

Revision History:

   Patrick Y. Ng        08/12/93


--*/

#ifndef _DATARAS_H_
#define _DATARAS_H_

/****************************************************************************\
								   18 Jan 92
								   russbl

           Adding a Counter to the Extensible Objects Code



1.  Modify the object definition in extdata.h:

    a.	Add a define for the offset of the counter in the
	data block for the given object type.

    b.	Add a PERF_COUNTER_DEFINITION to the <object>_DATA_DEFINITION.

2.  Add the Titles to the Registry in perfctrs.ini and perfhelp.ini:

    a.	Add Text for the Counter Name and the Text for the Help.

    b.	Add them to the bottom so we don't have to change all the
        numbers.

    c.  Change the Last Counter and Last Help entries under
        PerfLib in software.ini.

    d.  To do this at setup time, see section in pmintrnl.txt for
        protocol.

3.  Now add the counter to the object definition in extdata.c.
    This is the initializing, constant data which will actually go
    into the structure you added to the <object>_DATA_DEFINITION in
    step 1.b.	The type of the structure you are initializing is a
    PERF_COUNTER_DEFINITION.  These are defined in winperf.h.

4.  Add code in extobjct.c to collect the data.

Note: adding an object is a little more work, but in all the same
places.  See the existing code for examples.  In addition, you must
increase the *NumObjectTypes parameter to Get<object>PerfomanceData
on return from that routine.

\****************************************************************************/

//
//  The routines that load these structures assume that all fields
//  are packed and aligned on DWORD boundries. Alpha support may
//  change this assumption so the pack pragma is used here to insure
//  the DWORD packing assumption remains valid.
//

#include <winperf.h>
#include <rasman.h>

#define ALIGN8(_x)   (((_x) + 7) & ~7)

#pragma pack (4)

//
//  Extensible Object definitions
//

//  Update the following sort of define when adding an object type.

#define RAS_NUM_PERF_OBJECT_TYPES 1

//----------------------------------------------------------------------------

//
//  RAS Resource object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

#define NUM_BYTESTX_OFFSET	    	sizeof(DWORD) // The DWORD is for the
                                                      // field ByteLength

#define NUM_BYTESRX_OFFSET	    	( NUM_BYTESTX_OFFSET + sizeof(DWORD) )

#define NUM_FRAMESTX_OFFSET	    	( NUM_BYTESRX_OFFSET + sizeof(DWORD) )
#define NUM_FRAMESRX_OFFSET	    	( NUM_FRAMESTX_OFFSET + sizeof(DWORD) )

#define NUM_PERCENTTXC_OFFSET	        ( NUM_FRAMESRX_OFFSET + sizeof(DWORD) )
#define NUM_PERCENTRXC_OFFSET	        ( NUM_PERCENTTXC_OFFSET + sizeof(DWORD) )

#define NUM_CRCERRORS_OFFSET	        ( NUM_PERCENTRXC_OFFSET + sizeof(DWORD) )
#define NUM_TIMEOUTERRORS_OFFSET	( NUM_CRCERRORS_OFFSET + sizeof(DWORD) )
#define NUM_SERIALOVERRUNS_OFFSET	( NUM_TIMEOUTERRORS_OFFSET + sizeof(DWORD) )
#define NUM_ALIGNMENTERRORS_OFFSET	( NUM_SERIALOVERRUNS_OFFSET + sizeof(DWORD) )
#define NUM_BUFFEROVERRUNS_OFFSET	( NUM_ALIGNMENTERRORS_OFFSET + sizeof(DWORD) )

#define NUM_TOTALERRORS_OFFSET	        ( NUM_BUFFEROVERRUNS_OFFSET + sizeof(DWORD) )

#define NUM_BYTESTXSEC_OFFSET	        ( NUM_TOTALERRORS_OFFSET + sizeof(DWORD) )
#define NUM_BYTESRXSEC_OFFSET	        ( NUM_BYTESTXSEC_OFFSET + sizeof(DWORD) )

#define NUM_FRAMESTXSEC_OFFSET	        ( NUM_BYTESRXSEC_OFFSET + sizeof(DWORD) )
#define NUM_FRAMESRXSEC_OFFSET	        ( NUM_FRAMESTXSEC_OFFSET + sizeof(DWORD) )

#define NUM_TOTALERRORSSEC_OFFSET	( NUM_FRAMESRXSEC_OFFSET + sizeof(DWORD) )

#define SIZE_OF_RAS_PORT_PERFORMANCE_DATA ( NUM_TOTALERRORSSEC_OFFSET + sizeof(DWORD) )


#define NUM_TOTALCONNECTIONS_OFFSET     ( NUM_TOTALERRORSSEC_OFFSET + sizeof(DWORD) )

#define SIZE_OF_RAS_TOTAL_PERFORMANCE_DATA  ( NUM_TOTALCONNECTIONS_OFFSET + sizeof(DWORD) )


//
//  This is the counter structure presently returned by RAS for
//  each Resource.  Each Resource is an Instance, named by its number.
//


//
// Data structure returned for RAS Port Object.  Note that the instance
// definitions for all port will be appended to it.
//

typedef struct _RAS_PORT_DATA_DEFINITION 
{

    PERF_OBJECT_TYPE		RasObjectType;

    PERF_COUNTER_DEFINITION	BytesTx;
    PERF_COUNTER_DEFINITION	BytesRx;

    PERF_COUNTER_DEFINITION	FramesTx;
    PERF_COUNTER_DEFINITION	FramesRx;

    PERF_COUNTER_DEFINITION	PercentTxC;
    PERF_COUNTER_DEFINITION	PercentRxC;

    PERF_COUNTER_DEFINITION	CRCErrors;
    PERF_COUNTER_DEFINITION	TimeoutErrors;
    PERF_COUNTER_DEFINITION	SerialOverruns;
    PERF_COUNTER_DEFINITION	AlignmentErrors;
    PERF_COUNTER_DEFINITION	BufferOverruns;

    PERF_COUNTER_DEFINITION	TotalErrors;

    PERF_COUNTER_DEFINITION	BytesTxSec;
    PERF_COUNTER_DEFINITION	BytesRxSec;

    PERF_COUNTER_DEFINITION	FramesTxSec;
    PERF_COUNTER_DEFINITION	FramesRxSec;

    PERF_COUNTER_DEFINITION	TotalErrorsSec;

} RAS_PORT_DATA_DEFINITION, *PRAS_PORT_DATA_DEFINITION;


//
// Structure returned for each instance of object RAS Port.  Note that data
// for all counters will be appended to it.
//

typedef struct _RAS_PORT_INSTANCE_DEFINITION
{

    PERF_INSTANCE_DEFINITION    RasInstanceType;

    WCHAR                       InstanceName[ MAX_PORT_NAME ];

} RAS_PORT_INSTANCE_DEFINITION, *PRAS_PORT_INSTANCE_DEFINITION;


//
// Data structure returned for RAS Total Object.  Note that data for each
// counter will be appended to it.
//

typedef struct _RAS_TOTAL_DATA_DEFINITION 
{

    PERF_OBJECT_TYPE		RasObjectType;

    PERF_COUNTER_DEFINITION	BytesTx;
    PERF_COUNTER_DEFINITION	BytesRx;

    PERF_COUNTER_DEFINITION	FramesTx;
    PERF_COUNTER_DEFINITION	FramesRx;

    PERF_COUNTER_DEFINITION	PercentTxC;
    PERF_COUNTER_DEFINITION	PercentRxC;

    PERF_COUNTER_DEFINITION	CRCErrors;
    PERF_COUNTER_DEFINITION	TimeoutErrors;
    PERF_COUNTER_DEFINITION	SerialOverruns;
    PERF_COUNTER_DEFINITION	AlignmentErrors;
    PERF_COUNTER_DEFINITION	BufferOverruns;

    PERF_COUNTER_DEFINITION	TotalErrors;

    PERF_COUNTER_DEFINITION	BytesTxSec;
    PERF_COUNTER_DEFINITION	BytesRxSec;

    PERF_COUNTER_DEFINITION	FramesTxSec;
    PERF_COUNTER_DEFINITION	FramesRxSec;

    PERF_COUNTER_DEFINITION	TotalErrorsSec;

    PERF_COUNTER_DEFINITION     TotalConnections;

} RAS_TOTAL_DATA_DEFINITION, *PRAS_TOTAL_DATA_DEFINITION;

#pragma pack ()


extern RAS_PORT_DATA_DEFINITION gRasPortDataDefinition;
extern RAS_TOTAL_DATA_DEFINITION gRasTotalDataDefinition;

//
// External functions
//

VOID InitObjectCounterIndex ( DWORD dwFirstCounter, DWORD dwFirstHelp );

#endif //_DATARAS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\inc\x25.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** x25.h
** Remote Access Connection Manager
** Native X.25 media/device header
*/


#ifndef _X25MEDIA_
#define _X25MEDIA_


/* Media/device identification string.
*/
#define X25_TXT "x25"

/* Device parameter key strings.
*/
#define X25_ADDRESS_KEY    "X25Address"
#define X25_USERDATA_KEY   "UserData"
#define X25_FACILITIES_KEY "Facilities"


#endif // _X25MEDIA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\perf\dataras.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dataras.c

Abstract:

    a file containing the constant data structures used by the Performance
    Monitor data for the RAS Extensible Objects.

    This file contains a set of constant data structures which are
    currently defined for the RAS Extensible Objects.  This is an
    example of how other such objects could be defined.

Created:

    Russ Blake 		 26 Feb 93
    Thomas J. Dimitri	 28 May 93

Revision History:

    Patrick Y. Ng        12 Aug 93      

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include "rasctrnm.h"
#include "dataras.h"

//
//  Constant structure initializations
//      defined in dataras.h
//
//
//  The _PERF_DATA_BLOCK structure is followed by NumObjectTypes of
//  data sections, one for each type of object measured.  Each object
//  type section begins with a _PERF_OBJECT_TYPE structure.
//


RAS_PORT_DATA_DEFINITION gRasPortDataDefinition = 
{
    {
	// TotalByteLength.  Undefined until RasPortInit() is 
        // called.
	0,

	// DefinitionLength
	sizeof(RAS_PORT_DATA_DEFINITION),

	// HeaderLength
    	sizeof(PERF_OBJECT_TYPE),

	// ObjectNameTitleIndex
    	RASPORTOBJ,

	// ObjectNameTitle
    	0,

	// ObjectHelpTitleIndex
	RASPORTOBJ,

	// ObjectHelpTitle
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// NumCounters
	(sizeof(RAS_PORT_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/ sizeof(PERF_COUNTER_DEFINITION),

	// DefaultCounter
	0,

	// NumInstances.  Undefined until RasPortInit() is called.
    	0,

	// CodePage
    	0,

	//PerfTime
	{0,1},

	//PerfFreq
	{0,5}
    },

    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	BYTESTX,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	BYTESTX,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_BYTESTX_OFFSET
    },

    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	BYTESRX,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	BYTESRX,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_BYTESRX_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	FRAMESTX,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	FRAMESTX,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_FRAMESTX_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	FRAMESRX,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	FRAMESRX,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_FRAMESRX_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	PERCENTTXC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	PERCENTTXC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_PERCENTTXC_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	PERCENTRXC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	PERCENTRXC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_PERCENTRXC_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	CRCERRORS,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	CRCERRORS,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_CRCERRORS_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	TIMEOUTERRORS,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	TIMEOUTERRORS,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_TIMEOUTERRORS_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	SERIALOVERRUNS,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	SERIALOVERRUNS,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_SERIALOVERRUNS_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	ALIGNMENTERRORS,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	ALIGNMENTERRORS,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_ALIGNMENTERRORS_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	BUFFEROVERRUNS,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	BUFFEROVERRUNS,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_BUFFEROVERRUNS_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	TOTALERRORS,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	TOTALERRORS,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_TOTALERRORS_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	BYTESTXSEC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	BYTESTXSEC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_COUNTER,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_BYTESTXSEC_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	BYTESRXSEC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	BYTESRXSEC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_COUNTER,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_BYTESRXSEC_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	FRAMESTXSEC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	FRAMESTXSEC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_COUNTER,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_FRAMESTXSEC_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	FRAMESRXSEC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	FRAMESRXSEC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_COUNTER,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_FRAMESRXSEC_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	TOTALERRORSSEC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	TOTALERRORSSEC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_COUNTER,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_TOTALERRORSSEC_OFFSET
    }
};


RAS_TOTAL_DATA_DEFINITION gRasTotalDataDefinition = 
{
    {
	// TotalByteLength
	sizeof(RAS_TOTAL_DATA_DEFINITION) + ALIGN8(SIZE_OF_RAS_TOTAL_PERFORMANCE_DATA),

	// DefinitionLength
	sizeof(RAS_TOTAL_DATA_DEFINITION),

	// HeaderLength
    	sizeof(PERF_OBJECT_TYPE),

	// ObjectNameTitleIndex
    	RASTOTALOBJ,

	// ObjectNameTitle
    	0,

	// ObjectHelpTitleIndex
	RASTOTALOBJ,

	// ObjectHelpTitle
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// NumCounters
	(sizeof(RAS_TOTAL_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/ sizeof(PERF_COUNTER_DEFINITION),

	// DefaultCounter
	0,

	// NumInstances
    	PERF_NO_INSTANCES,

	// CodePage
    	0,

	//PerfTime
	{0,1},

	//PerfFreq
	{0,5}
    },

    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	BYTESTX,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	BYTESTX,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_BYTESTX_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	BYTESRX,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	BYTESRX,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_BYTESRX_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	FRAMESTX,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	FRAMESTX,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_FRAMESTX_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	FRAMESRX,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	FRAMESRX,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_FRAMESRX_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	PERCENTTXC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	PERCENTTXC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
        PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_PERCENTTXC_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	PERCENTRXC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	PERCENTRXC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
        PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_PERCENTRXC_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	CRCERRORS,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	CRCERRORS,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_CRCERRORS_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	TIMEOUTERRORS,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	TIMEOUTERRORS,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_TIMEOUTERRORS_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	SERIALOVERRUNS,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	SERIALOVERRUNS,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_SERIALOVERRUNS_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	ALIGNMENTERRORS,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	ALIGNMENTERRORS,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_ALIGNMENTERRORS_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	BUFFEROVERRUNS,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	BUFFEROVERRUNS,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_BUFFEROVERRUNS_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	TOTALERRORS,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	TOTALERRORS,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_TOTALERRORS_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	BYTESTXSEC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	BYTESTXSEC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_COUNTER,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_BYTESTXSEC_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	BYTESRXSEC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	BYTESRXSEC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_COUNTER,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_BYTESRXSEC_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	FRAMESTXSEC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	FRAMESTXSEC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_COUNTER,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_FRAMESTXSEC_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	FRAMESRXSEC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	FRAMESRXSEC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_COUNTER,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_FRAMESRXSEC_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	TOTALERRORSSEC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	TOTALERRORSSEC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_COUNTER,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_TOTALERRORSSEC_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	TOTALCONNECTIONS,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	TOTALCONNECTIONS,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_TOTALCONNECTIONS_OFFSET
    }

};


//***
// 
// Routine Description:
//
//      Initiailizes all the indexes in the counter definitions in all objects.
//
// Arguments:
//
//      None.
//
// Return Value:
//
//      None.
//
//***

VOID InitObjectCounterIndex ( DWORD dwFirstCounter, DWORD dwFirstHelp )
{

    //
    // Init the counter definition structures for the object RAS Port.
    //

    gRasPortDataDefinition.RasObjectType.ObjectNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.RasObjectType.ObjectHelpTitleIndex += dwFirstHelp;

    gRasPortDataDefinition.BytesTx.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.BytesTx.CounterHelpTitleIndex += dwFirstHelp;
    gRasPortDataDefinition.BytesRx.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.BytesRx.CounterHelpTitleIndex += dwFirstHelp;

    gRasPortDataDefinition.FramesTx.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.FramesTx.CounterHelpTitleIndex += dwFirstHelp;
    gRasPortDataDefinition.FramesRx.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.FramesRx.CounterHelpTitleIndex += dwFirstHelp;

    gRasPortDataDefinition.PercentTxC.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.PercentTxC.CounterHelpTitleIndex += dwFirstHelp;
    gRasPortDataDefinition.PercentRxC.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.PercentRxC.CounterHelpTitleIndex += dwFirstHelp;

    gRasPortDataDefinition.CRCErrors.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.CRCErrors.CounterHelpTitleIndex += dwFirstHelp;
    gRasPortDataDefinition.TimeoutErrors.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.TimeoutErrors.CounterHelpTitleIndex += dwFirstHelp;
    gRasPortDataDefinition.SerialOverruns.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.SerialOverruns.CounterHelpTitleIndex += dwFirstHelp;
    gRasPortDataDefinition.AlignmentErrors.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.AlignmentErrors.CounterHelpTitleIndex += dwFirstHelp;
    gRasPortDataDefinition.BufferOverruns.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.BufferOverruns.CounterHelpTitleIndex += dwFirstHelp;

    gRasPortDataDefinition.TotalErrors.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.TotalErrors.CounterHelpTitleIndex += dwFirstHelp;
	
    gRasPortDataDefinition.BytesTxSec.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.BytesTxSec.CounterHelpTitleIndex += dwFirstHelp;
    gRasPortDataDefinition.BytesRxSec.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.BytesRxSec.CounterHelpTitleIndex += dwFirstHelp;

    gRasPortDataDefinition.FramesTxSec.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.FramesTxSec.CounterHelpTitleIndex += dwFirstHelp;
    gRasPortDataDefinition.FramesRxSec.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.FramesRxSec.CounterHelpTitleIndex += dwFirstHelp;

    gRasPortDataDefinition.TotalErrorsSec.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.TotalErrorsSec.CounterHelpTitleIndex += dwFirstHelp;


    //
    // Init the counter definition structures for the object RAS Total.
    //

    gRasTotalDataDefinition.RasObjectType.ObjectNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.RasObjectType.ObjectHelpTitleIndex += dwFirstHelp;

    gRasTotalDataDefinition.BytesTx.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.BytesTx.CounterHelpTitleIndex += dwFirstHelp;
    gRasTotalDataDefinition.BytesRx.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.BytesRx.CounterHelpTitleIndex += dwFirstHelp;

    gRasTotalDataDefinition.FramesTx.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.FramesTx.CounterHelpTitleIndex += dwFirstHelp;
    gRasTotalDataDefinition.FramesRx.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.FramesRx.CounterHelpTitleIndex += dwFirstHelp;

    gRasTotalDataDefinition.PercentTxC.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.PercentTxC.CounterHelpTitleIndex += dwFirstHelp;
    gRasTotalDataDefinition.PercentRxC.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.PercentRxC.CounterHelpTitleIndex += dwFirstHelp;

    gRasTotalDataDefinition.CRCErrors.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.CRCErrors.CounterHelpTitleIndex += dwFirstHelp;
    gRasTotalDataDefinition.TimeoutErrors.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.TimeoutErrors.CounterHelpTitleIndex += dwFirstHelp;
    gRasTotalDataDefinition.SerialOverruns.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.SerialOverruns.CounterHelpTitleIndex += dwFirstHelp;
    gRasTotalDataDefinition.AlignmentErrors.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.AlignmentErrors.CounterHelpTitleIndex += dwFirstHelp;
    gRasTotalDataDefinition.BufferOverruns.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.BufferOverruns.CounterHelpTitleIndex += dwFirstHelp;

    gRasTotalDataDefinition.TotalErrors.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.TotalErrors.CounterHelpTitleIndex += dwFirstHelp;
	
    gRasTotalDataDefinition.BytesTxSec.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.BytesTxSec.CounterHelpTitleIndex += dwFirstHelp;
    gRasTotalDataDefinition.BytesRxSec.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.BytesRxSec.CounterHelpTitleIndex += dwFirstHelp;

    gRasTotalDataDefinition.FramesTxSec.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.FramesTxSec.CounterHelpTitleIndex += dwFirstHelp;
    gRasTotalDataDefinition.FramesRxSec.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.FramesRxSec.CounterHelpTitleIndex += dwFirstHelp;

    gRasTotalDataDefinition.TotalErrorsSec.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.TotalErrorsSec.CounterHelpTitleIndex += dwFirstHelp;

    gRasTotalDataDefinition.TotalConnections.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.TotalConnections.CounterHelpTitleIndex += dwFirstHelp;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\perf\globals.h ===
/*++ 

Copyright (c) 1992  Microsoft Corporation

Module Name:

    globals.h

Abstract:

    Global variables, except for the ones in dataras.c, for rasctr.dll.

Created:

    Patrick Y. Ng               12 Aug 93

Revision History


--*/

#ifndef GLOBALS_H
#define GLOBALS_H

//
//  Include Files
//

#include <nt.h>

#include <rasman.h>
#include <serial.h>

#endif // GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\perf\makefile.inc ===
ver.rc: rasctrs.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\perf\perfutil.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfutil.h  

Abstract:

    This file supports routines used to parse and
    create Performance Monitor Data Structures.
    It actually supports Performance Object types with
    multiple instances

Author:

    Russ Blake  7/30/92

Revision History:


--*/
#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

// enable this define to log process heap data to the event log
#ifdef PROBE_HEAP_USAGE
#undef PROBE_HEAP_USAGE
#endif
//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//
#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))

//    (assumes dword is 4 bytes long and pointer is a dword in size)
#define ALIGN_ON_DWORD(x) ((VOID *)( ((DWORD) x & 0x00000003) ? ( ((DWORD) x & 0xFFFFFFFC) + 4 ) : ( (DWORD) x ) ))

extern WCHAR  GLOBAL_STRING[];      // Global command (get all local ctrs)
extern WCHAR  FOREIGN_STRING[];           // get data from foreign computers
extern WCHAR  COSTLY_STRING[];      
extern WCHAR  NULL_STRING[];

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

//
// The definition of the only routine of perfutil.c, It builds part of a 
// performance data instance (PERF_INSTANCE_DEFINITION) as described in 
// winperf.h
//

HANDLE MonOpenEventLog ();
VOID MonCloseEventLog ();
DWORD GetQueryType (IN LPWSTR);
BOOL IsNumberInUnicodeList (DWORD, LPWSTR);

typedef struct _LOCAL_HEAP_INFO_BLOCK {
    DWORD   AllocatedEntries;
    DWORD   AllocatedBytes;
    DWORD   FreeEntries;
    DWORD   FreeBytes;
} LOCAL_HEAP_INFO, *PLOCAL_HEAP_INFO;


//
//  Memory Probe macro
//
#ifdef PROBE_HEAP_USAGE

#define HEAP_PROBE()    { \
    DWORD   dwHeapStatus[5]; \
    NTSTATUS CallStatus; \
    dwHeapStatus[4] = __LINE__; \
    if (!(CallStatus = memprobe (dwHeapStatus, 16L, NULL))) { \
        REPORT_INFORMATION_DATA (TCP_HEAP_STATUS, LOG_DEBUG,    \
            &dwHeapStatus, sizeof(dwHeapStatus));  \
    } else {  \
        REPORT_ERROR_DATA (TCP_HEAP_STATUS_ERROR, LOG_DEBUG, \
            &CallStatus, sizeof (DWORD)); \
    } \
}

#else

#define HEAP_PROBE()    ;

#endif

#endif  //_PERFUTIL_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\perf\perfutil.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfutil.c

Abstract:

    This file implements the utility routines used to construct the
	common parts of a PERF_INSTANCE_DEFINITION (see winperf.h) and
    perform event logging functions.

Created:

    Russ Blake  		07/30/92
	Thomas J. Dimitri	05/28/93
Revision History:

--*/
//
//  include files
//
#include <windows.h>
#include <string.h>
#include <winperf.h>
#include "rasctrs.h"	 // error message definition
#include "perfmsg.h"
#include "perfutil.h"

#define INITIAL_SIZE     1024L
#define EXTEND_SIZE      1024L

//
// Global data definitions.
//

ULONG                   ulInfoBufferSize = 0;

HANDLE hEventLog = NULL;      // event log handle for reporting events
                              // initialized in Open... routines
DWORD  dwLogUsers = 0;        // count of functions using event log

DWORD MESSAGE_LEVEL = 0;

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";    // pointer to null string

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


HANDLE
MonOpenEventLog (
)
/*++

Routine Description:

    Reads the level of event logging from the registry and opens the
        channel to the event logger for subsequent event log entries.

Arguments:

      None

Return Value:

    Handle to the event log for reporting events.
    NULL if open not successful.

--*/
{
    HKEY hAppKey;
    TCHAR LogLevelKeyName[] = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
    TCHAR LogLevelValueName[] = "EventLogLevel";

    LONG lStatus;

    DWORD dwLogLevel;
    DWORD dwValueType;
    DWORD dwValueSize;

    // if global value of the logging level not initialized or is disabled,
    //  check the registry to see if it should be updated.

    if (!MESSAGE_LEVEL) {

       lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                               LogLevelKeyName,
                               0,
                               KEY_READ,
                               &hAppKey);

       dwValueSize = sizeof (dwLogLevel);

       if (lStatus == ERROR_SUCCESS) {
            lStatus = RegQueryValueEx (hAppKey,
                               LogLevelValueName,
                               (LPDWORD)NULL,
                               &dwValueType,
                               (LPBYTE)&dwLogLevel,
                               &dwValueSize);

            if (lStatus == ERROR_SUCCESS) {
               MESSAGE_LEVEL = dwLogLevel;
            } else {
               MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
            }
            RegCloseKey (hAppKey);
       } else {
         MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
       }
    }

    if (hEventLog == NULL){
         hEventLog = RegisterEventSource (
            (LPTSTR)NULL,            // Use Local Machine
            APP_NAME);               // event log app name to find in registry

         if (hEventLog != NULL) {
            REPORT_INFORMATION (UTIL_LOG_OPEN, LOG_DEBUG);
         }
    }

    if (hEventLog != NULL) {
         dwLogUsers++;           // increment count of perfctr log users
    }
    return (hEventLog);
}


VOID
MonCloseEventLog (
)
/*++

Routine Description:

      Closes the handle to the event logger if this is the last caller

Arguments:

      None

Return Value:

      None

--*/
{
    if (hEventLog != NULL) {
        dwLogUsers--;         // decrement usage
        if (dwLogUsers <= 0) {    // and if we're the last, then close up log
            REPORT_INFORMATION (UTIL_CLOSING_LOG, LOG_DEBUG);
            DeregisterEventSource (hEventLog);
            hEventLog = NULL;
        }
    }
}

DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    BOOL    bReturnValue;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\perf\port.h ===
/*++ 

Copyright (c) 1992  Microsoft Corporation

Module Name:

    port.h

Abstract:

    Header file information for port.h.

Created:

    Patrick Y. Ng               12 Aug 93

Revision History

--*/

#ifndef PORT_H
#define PORT_H

#include <rasman.h>

//
// Data structure used to store the statistics for each open port.
//

typedef struct _RAS_PORT_STAT
{

    ULONG BytesTransmitted;
    ULONG BytesReceived;
    ULONG FramesTransmitted;
    ULONG FramesReceived;

    ULONG CRCErrors;
    ULONG TimeoutErrors;
    ULONG SerialOverrunErrors;
    ULONG AlignmentErrors;
    ULONG BufferOverrunErrors;
    
    ULONG BytesTransmittedUncompressed;
    ULONG BytesReceivedUncompressed;
    ULONG BytesTransmittedCompressed;
    ULONG BytesReceivedCompressed;
    
    ULONG TotalErrors;
    
} RAS_PORT_STAT, *PRAS_PORT_STAT;


//
// Data structure used to store both the statistics and the name of each
// open port.
//

typedef struct _RAS_PORT_DATA
{
    RAS_PORT_STAT       RasPortStat;

    WCHAR               PortName[ MAX_PORT_NAME ];

} RAS_PORT_DATA, *PRAS_PORT_DATA;



//
// Exported functions
//

extern LONG InitPortInfo();

extern LONG InitRasFunctions();

extern ULONG GetSpaceNeeded( BOOL IsRasPortObject, BOOL IsRasTotalObject );

extern NTSTATUS CollectRasStatistics();

extern DWORD GetNumOfPorts();

extern LPWSTR GetInstanceName( INT i );

extern VOID GetInstanceData( INT Port, PVOID *lppData );

extern VOID GetTotalData( PVOID *lppData );

extern VOID ClosePortInfo();

//
// Internal functions
//

#endif // PORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\perf\port.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    port.c

Abstract:

    Contains functions responsible for data collection from the RAS ports.

Created:

    Patrick Y. Ng               12 Aug 93

Revision History

--*/

//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddser.h>

#include <raserror.h>
#include <malloc.h>
#include <windows.h>
#include <string.h>
#include <wcstr.h>

#include "rasctrs.h" // error message definition
#include "perfmsg.h"
#include "perfutil.h"
#include "dataras.h"
#include "globals.h"
#include "port.h"

#include <rasman.h>
#include <serial.h>
#include <isdn.h>


HANDLE   ghRasmanLib;             // Handle of RASMAN.DLL

#define RASMAN_DLL              "rasman.dll"


//
// Function types for the functions in RASMAN.DLL
//

typedef DWORD ( WINAPI *FPRASPORTENUM ) ( HANDLE, LPBYTE, LPDWORD, LPDWORD );
typedef DWORD ( WINAPI *FPRASGETINFO ) (HANDLE,  HPORT, RASMAN_INFO* );
typedef DWORD ( WINAPI *FPRASPORTGETSTATISTICS ) (HANDLE,  HPORT, LPBYTE, LPDWORD );
typedef DWORD ( WINAPI *FPRASINITIALIZE) ();
typedef DWORD ( WINAPI *FPRASPORTGETBUNDLE) (HANDLE, HPORT, HBUNDLE*);

FPRASPORTENUM                   lpRasPortEnum;
FPRASGETINFO                    lpRasGetInfo;
FPRASPORTGETSTATISTICS          lpRasPortGetStatistics;
FPRASINITIALIZE                 lpRasInitialize;
FPRASPORTGETBUNDLE				lpRasPortGetBundle;

//
// Pointer to the port table array.
//

PRAS_PORT_DATA	gpPortDataArray;
RAS_PORT_STAT	gTotalStat;

DWORD		    gcPorts;
RASMAN_PORT		*gpPorts = NULL;
DWORD			gPortEnumSize;

DWORD			gTotalConnections;
		
//***
//
// Routine Description:
//
//      It will load rasman.dll and call GetProcAddress to obtain all the
//      necessary RAS functions.
//
// Arguments:
//
//      None.
//
// Return Value:
//
//      ERROR_SUCCESS - Successful.
//      ERROR_CAN_NOT_COMPLETE - Otherwise.
//
//***

LONG InitRasFunctions()
{
    ghRasmanLib = LoadLibrary( RASMAN_DLL );

    // log error if unsuccessful

    if( !ghRasmanLib )
    {
        REPORT_ERROR (RASPERF_OPEN_FILE_DRIVER_ERROR, LOG_USER);

        // this is fatal, if we can't get data then there's no
        // point in continuing.

        return ERROR_CAN_NOT_COMPLETE;

    }

    lpRasInitialize =
	(FPRASPORTENUM) GetProcAddress( ghRasmanLib, "RasInitialize" );

    lpRasPortEnum =
	(FPRASPORTENUM) GetProcAddress( ghRasmanLib, "RasPortEnum" );

    lpRasGetInfo =
	(FPRASGETINFO) GetProcAddress( ghRasmanLib, "RasGetInfo" );

    lpRasPortGetStatistics =
	(FPRASPORTGETSTATISTICS) GetProcAddress( ghRasmanLib, "RasPortGetStatistics" );

    lpRasPortGetBundle =
	(FPRASPORTGETBUNDLE) GetProcAddress( ghRasmanLib, "RasPortGetBundle" );

    if( !lpRasInitialize || !lpRasPortEnum || !lpRasGetInfo
	        || !lpRasPortGetStatistics || !lpRasPortGetBundle)
	        // || lpRasInitialize() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // ANSHULD: BUG: 750860
    // This function returns success even if RASMAN service is not running.
    // It is the responsibility of the users of the RASMAN functions to make 
    // sure that the service is running.
    //
    
#if 0
    else
    {
        SC_HANDLE schandle = NULL;
        SC_HANDLE svchandle = NULL;
        DWORD dwErr = NO_ERROR;
        
        //
        // Check to see if rasman service is started.
        // fail if it isn't - we don't want ras perf
        // to start rasman service.
        //
        schandle = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);

        if(NULL != schandle)
        {
            svchandle = OpenService(schandle,
                                    "RASMAN",
                                    SERVICE_QUERY_STATUS);

            if(NULL != svchandle)
            {
                SERVICE_STATUS status;
                
                if(     (!QueryServiceStatus(svchandle, &status))
                    ||  (status.dwCurrentState != SERVICE_RUNNING))
                {
                    dwErr = ERROR_CAN_NOT_COMPLETE;
                }

                CloseServiceHandle(svchandle);
            }

            CloseServiceHandle(schandle);
        }

        return dwErr;

    }
#endif

    return ERROR_SUCCESS;
}


//***
//
// Routine Description:
//
//      This routine will call lpRasPortEnum() and generate an array of port
//      tables which contains all the information for all the ports such as
//      number of bytes transferred, and number of errors, etc.
//
//      The remaining initialization work of gRasPortDataDefinition is also
//      finished here.
//
// Arguments:
//
//      None.
//
// Return Value:
//
//      ERROR_SUCCESS - Successful.
//      ERROR_CAN_NOT_COMPLETE - Otherwise.
//
//***

LONG InitPortInfo()
{
    DWORD        Size;
    DWORD         i;

    gPortEnumSize = 0;
    gcPorts = 0;

    //
    // Free the portinfo information we got earlier
    //
    ClosePortInfo();

    if( lpRasPortEnum(NULL, NULL, &gPortEnumSize, &gcPorts) != ERROR_BUFFER_TOO_SMALL )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }


    gpPorts = (RASMAN_PORT *) malloc( gPortEnumSize );

    if (!gpPorts)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }


    if (lpRasPortEnum(NULL, (LPBYTE) gpPorts, &gPortEnumSize, &gcPorts))
    {
        return ERROR_CAN_NOT_COMPLETE;
    }



    //
    // Generate the array of data tables for all the ports, and fill up the
    // name of each port.
    //

    Size = gcPorts * sizeof( RAS_PORT_DATA );

    if(gpPortDataArray)
    {
        free(gpPortDataArray);
    }

    gpPortDataArray = ( PRAS_PORT_DATA ) malloc( Size );

    if( gpPortDataArray == NULL )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    memset( gpPortDataArray, 0, Size );

    //
    // Fill up the names.
    //

    for( i = 0; i < gcPorts; i++ )
    {
        //
        // Note that the names passed to perfmon are in Unicodes.
        //

        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                             gpPorts[i].P_PortName,
                             MAX_PORT_NAME,
                             gpPortDataArray[i].PortName,
                             MAX_PORT_NAME);
    }


    //
    // Finish the initialization of gRasPortDataDefinition.
    //

    gRasPortDataDefinition.RasObjectType.TotalByteLength =
                sizeof( RAS_PORT_DATA_DEFINITION ) +
                gcPorts * ( sizeof( RAS_PORT_INSTANCE_DEFINITION ) +
                           SIZE_OF_RAS_PORT_PERFORMANCE_DATA );

    gRasPortDataDefinition.RasObjectType.NumInstances = gcPorts;

    return ERROR_SUCCESS;
}


VOID ClosePortInfo()
{
    if(NULL != gpPortDataArray)
    {
        free( gpPortDataArray );
        gpPortDataArray = NULL;
    }

    if(NULL != gpPorts)
    {
        free( gpPorts );    
        gpPorts = NULL;
    }
}


DWORD GetNumOfPorts()
{
    return gcPorts;
}


LPWSTR GetInstanceName( INT i )
{
    return (LPWSTR) gpPortDataArray[i].PortName;
}


VOID GetInstanceData( INT Port, PVOID *lppData )
{
    PPERF_COUNTER_BLOCK pPerfCounterBlock;
    PDWORD              pdwCounter;
    PRAS_PORT_STAT      pRasPortStat;


    pPerfCounterBlock = (PERF_COUNTER_BLOCK *) *lppData;

    pPerfCounterBlock->ByteLength = SIZE_OF_RAS_PORT_PERFORMANCE_DATA;

    pRasPortStat = &gpPortDataArray[Port].RasPortStat;


    //
    // Go to end of PerfCounterBlock to get of array of counters
    //

    pdwCounter = (PDWORD) (&pPerfCounterBlock[1]);

    {
       ULONG ulBxu      = pRasPortStat->BytesTransmittedUncompressed;
       ULONG ulBxc      = pRasPortStat->BytesTransmittedCompressed;
       ULONG ulBx       = pRasPortStat->BytesTransmitted;
       ULONG ulBxGone   = 0;
       ULONG ulBxResult = 0;
       ULONG ulBru      = pRasPortStat->BytesReceivedUncompressed;
       ULONG ulBrc      = pRasPortStat->BytesReceivedCompressed;
       ULONG ulBr       = pRasPortStat->BytesReceived;
       ULONG ulBrGone   = 0;
       ULONG ulBrResult = 0;

       if (ulBxc <ulBxu) {
          ulBxGone = ulBxu - ulBxc;
       }

       if (ulBrc <ulBru) {
          ulBrGone = ulBru - ulBrc;
       }

       *pdwCounter++ = pRasPortStat->BytesTransmitted + ulBxGone;
       *pdwCounter++ = pRasPortStat->BytesReceived + ulBrGone;
       *pdwCounter++ = pRasPortStat->FramesTransmitted;
       *pdwCounter++ = pRasPortStat->FramesReceived;

       if (ulBx + ulBxGone > 100) {
          ULONG ulDen = (ulBx + ulBxGone) / 100;
          ULONG ulNum = ulBxGone + (ulDen / 2);
          ulBxResult = ulNum / ulDen;
       }

	*pdwCounter++ = ulBxResult;  // % bytes compress out

       if (ulBr + ulBrGone > 100) {
          ULONG ulDen = (ulBr + ulBrGone) / 100;
          ULONG ulNum = ulBrGone + (ulDen / 2);
          ulBrResult = ulNum / ulDen;
       }
	*pdwCounter++ = ulBrResult;  // % bytes compress in

       *pdwCounter++ = pRasPortStat->CRCErrors;
       *pdwCounter++ = pRasPortStat->TimeoutErrors;
       *pdwCounter++ = pRasPortStat->SerialOverrunErrors;
       *pdwCounter++ = pRasPortStat->AlignmentErrors;
       *pdwCounter++ = pRasPortStat->BufferOverrunErrors;

       *pdwCounter++ = pRasPortStat->TotalErrors;

       *pdwCounter++ = pRasPortStat->BytesTransmitted + ulBxGone;
       *pdwCounter++ = pRasPortStat->BytesReceived + ulBrGone;

       *pdwCounter++ = pRasPortStat->FramesTransmitted;
       *pdwCounter++ = pRasPortStat->FramesReceived;

       *pdwCounter++ = pRasPortStat->TotalErrors;
    }
    //
    // Update *lppData to the next available byte.
    //

    *lppData = (PVOID) pdwCounter;

}


VOID GetTotalData( PVOID *lppData )
{
    PPERF_COUNTER_BLOCK pPerfCounterBlock;
    PDWORD              pdwCounter;


    pPerfCounterBlock = (PERF_COUNTER_BLOCK *) *lppData;

    //DbgPrint("RASCTRS: total bytelength before align = 0x%x\n",
    //            SIZE_OF_RAS_TOTAL_PERFORMANCE_DATA);

    pPerfCounterBlock->ByteLength = ALIGN8(SIZE_OF_RAS_TOTAL_PERFORMANCE_DATA);

    //DbgPrint("RASCTRS: total bytelength after align = 0x%x\n",
    //            pPerfCounterBlock->ByteLength);


    //
    // Go to end of PerfCounterBlock to get of array of counters
    //

    pdwCounter = (PDWORD) (&pPerfCounterBlock[1]);

    {
       ULONG ulBxu      = gTotalStat.BytesTransmittedUncompressed;
       ULONG ulBxc      = gTotalStat.BytesTransmittedCompressed;
       ULONG ulBx       = gTotalStat.BytesTransmitted;
       ULONG ulBxGone   = 0;
       ULONG ulBxResult = 0;
       ULONG ulBru      = gTotalStat.BytesReceivedUncompressed;
       ULONG ulBrc      = gTotalStat.BytesReceivedCompressed;
       ULONG ulBr       = gTotalStat.BytesReceived;
       ULONG ulBrGone   = 0;
       ULONG ulBrResult = 0;


       if (ulBxc <ulBxu) {
          ulBxGone = ulBxu - ulBxc;
       }

       if (ulBrc <ulBru) {
          ulBrGone = ulBru - ulBrc;
       }

       *pdwCounter++ = gTotalStat.BytesTransmitted + ulBxGone;
       *pdwCounter++ = gTotalStat.BytesReceived + ulBrGone;
       *pdwCounter++ = gTotalStat.FramesTransmitted;
       *pdwCounter++ = gTotalStat.FramesReceived;

       if (ulBx + ulBxGone > 100) {
          ULONG ulDen = (ulBx + ulBxGone) / 100;
          ULONG ulNum = ulBxGone + (ulDen / 2);
          ulBxResult = ulNum / ulDen;
       }

	*pdwCounter++ = ulBxResult;  // % bytes compress out

       if (ulBr + ulBrGone > 100) {
          ULONG ulDen = (ulBr + ulBrGone) / 100;
          ULONG ulNum = ulBrGone + (ulDen / 2);
          ulBrResult = ulNum / ulDen;
       }
	*pdwCounter++ = ulBrResult;  // % bytes compress in

       *pdwCounter++ = gTotalStat.CRCErrors;
       *pdwCounter++ = gTotalStat.TimeoutErrors;
       *pdwCounter++ = gTotalStat.SerialOverrunErrors;
       *pdwCounter++ = gTotalStat.AlignmentErrors;
       *pdwCounter++ = gTotalStat.BufferOverrunErrors;

       *pdwCounter++ = gTotalStat.TotalErrors;

       *pdwCounter++ = gTotalStat.BytesTransmitted + ulBxGone;
       *pdwCounter++ = gTotalStat.BytesReceived + ulBrGone;

       *pdwCounter++ = gTotalStat.FramesTransmitted;
       *pdwCounter++ = gTotalStat.FramesReceived;

       *pdwCounter++ = gTotalStat.TotalErrors;
       *pdwCounter++ = gTotalConnections;
    }

    //
    // Update *lppData to the next available byte.
    //

    *lppData = (PVOID) ((PBYTE) pPerfCounterBlock + pPerfCounterBlock->ByteLength);

    //DbgPrint("RASCTRS : totalcount *lppdata = 0x%x\n", *lppData);

}


//***
//
// Routine Description:
//
//      This routine will return the number of gTotalStat.Bytes needed for all the
//      objects requested.
//
// Arguments:
//
//      None.
//
// Return Value:
//
//      The number of gTotalStat.Bytes.
//
//***

ULONG GetSpaceNeeded( BOOL IsRasPortObject, BOOL IsRasTotalObject )
{
    ULONG       Space = 0;

    if( IsRasPortObject )
    {
        Space += gRasPortDataDefinition.RasObjectType.TotalByteLength;
    }

    if( IsRasTotalObject )
    {
        Space += gRasTotalDataDefinition.RasObjectType.TotalByteLength;
    }

    return Space;
}


//***
//
// Routine Description:
//
//      This routine will return the number of bytes needed for all the
//      objects requested.
//
// Arguments:
//
//      None.
//
// Return Value:
//
//      The number of bytes.
//
//***

NTSTATUS CollectRasStatistics()
{
    NTSTATUS    status;
    DWORD         i;
	HBUNDLE		*hBundleArray = NULL;

    gTotalConnections = 0;

    //
    // We also initialize the data structure for the total.
    //

    memset( &gTotalStat, 0, sizeof( gTotalStat ) );

    //
    // First we do a lpRasPortEnum to obtain the port connection info.
    //
#if 0
    status = lpRasPortEnum(NULL, (LPBYTE) gpPorts, &gPortEnumSize, &gcPorts);

    if( status != ERROR_SUCCESS )
    {
        REPORT_ERROR_DATA (RASPERF_RASPORTENUM_FAILED, LOG_USER,
                &status, sizeof(status));

        return ERROR_CAN_NOT_COMPLETE;
    }

#endif

	hBundleArray = (HBUNDLE*)malloc(gcPorts * sizeof(HBUNDLE));

	if(NULL == hBundleArray)
	{
	    return ERROR_NOT_ENOUGH_MEMORY;
	}

	memset (hBundleArray, 0, gcPorts * sizeof(HBUNDLE)) ;

	if (hBundleArray == NULL) {
		return ERROR_CAN_NOT_COMPLETE;
	}

    for( i = 0; i < gcPorts; i++ )
    {
        RASMAN_INFO	RasmanInfo;
        HPORT           hPort;
        DWORD            wSize;
        RAS_STATISTICS  *pStats;
        PRAS_PORT_STAT  pData;
		BOOLEAN			AddTotal;
		DWORD				n;
		HBUNDLE			hBundle;


        //
        // First we want to know if the port is open.
        //

    	if( gpPorts[i].P_Status != OPEN )
        {
            //
            // Reset the port data and continue with next port.
            //

            memset( &gpPortDataArray[i].RasPortStat,0, sizeof(RAS_PORT_STAT));

            continue;
        }

        hPort = gpPorts[i].P_Handle;


        //
        // Check if the port is connected.
        //

        lpRasGetInfo(NULL, hPort, &RasmanInfo );

        if( RasmanInfo.RI_ConnState != CONNECTED )
        {
            //
            // Reset the port data and continue with next port.
            //

            memset( &gpPortDataArray[i].RasPortStat,0, sizeof(RAS_PORT_STAT));

            continue;
        }

        gTotalConnections++;


        //
        //
        // Obtain the statistics for the port.
        //

        wSize = sizeof(RAS_STATISTICS) +
                        (NUM_RAS_SERIAL_STATS * sizeof(ULONG));

        pStats = (RAS_STATISTICS* )malloc( wSize );

        if (!pStats)
        {
            //
            // If it fails then we should return error.
            //

            status = ERROR_NOT_ENOUGH_MEMORY;

            REPORT_ERROR_DATA (RASPERF_NOT_ENOUGH_MEMORY, LOG_USER,
                &status, sizeof(status));

            return status;
        }

        lpRasPortGetStatistics( NULL, hPort, (PVOID)pStats, &wSize );

        //
        // Now store the data in the data array.
        //

        pData = &(gpPortDataArray[i].RasPortStat);


        pData->BytesTransmitted =     pStats->S_Statistics[ BYTES_XMITED ];
        pData->BytesReceived =        pStats->S_Statistics[ BYTES_RCVED ];
        pData->FramesTransmitted =    pStats->S_Statistics[ FRAMES_XMITED ];
        pData->FramesReceived =       pStats->S_Statistics[ FRAMES_RCVED ];
	
	
         pData->CRCErrors =            pStats->S_Statistics[ CRC_ERR ];
         pData->TimeoutErrors =        pStats->S_Statistics[ TIMEOUT_ERR ];
         pData->SerialOverrunErrors =  pStats->S_Statistics[ SERIAL_OVERRUN_ERR ];
         pData->AlignmentErrors =      pStats->S_Statistics[ ALIGNMENT_ERR ];
         pData->BufferOverrunErrors =  pStats->S_Statistics[ BUFFER_OVERRUN_ERR ];

         pData->TotalErrors =   pStats->S_Statistics[ CRC_ERR ] +
                                pStats->S_Statistics[ TIMEOUT_ERR ] +
                                pStats->S_Statistics[ SERIAL_OVERRUN_ERR ] +
                                pStats->S_Statistics[ ALIGNMENT_ERR ] +
                                pStats->S_Statistics[ BUFFER_OVERRUN_ERR ];

			
        pData->BytesTransmittedUncompressed = pStats->S_Statistics[ BYTES_XMITED_UNCOMP ];

        pData->BytesReceivedUncompressed = pStats->S_Statistics[ BYTES_RCVED_UNCOMP ];

        pData->BytesTransmittedCompressed = pStats->S_Statistics[ BYTES_XMITED_COMP ];

        pData->BytesReceivedCompressed = pStats->S_Statistics[ BYTES_RCVED_COMP ];

		lpRasPortGetBundle( NULL, hPort, &hBundle);

		//
		// See if we have already added in this bundle's stats
		// to the total stats!
		//
		AddTotal = TRUE;

		for (n = 0; n < gcPorts; n++) {

			if (hBundle == hBundleArray[n]) {

				AddTotal = FALSE;
				break;
			}

			if (NULL == (PVOID)hBundleArray[n]) {
				break;
			}
			
		}

		if (AddTotal) {

			hBundleArray[n] = hBundle;

			//
			// Also update the total data structure
			//
	
			gTotalStat.BytesTransmitted +=  pData->BytesTransmitted;
			gTotalStat.BytesReceived +=	pData->BytesReceived;
			gTotalStat.FramesTransmitted += pData->FramesTransmitted;
			gTotalStat.FramesReceived +=    pData->FramesReceived;
	
			gTotalStat.CRCErrors +=           pData->CRCErrors;
			gTotalStat.TimeoutErrors +=       pData->TimeoutErrors;
			gTotalStat.SerialOverrunErrors += pData->SerialOverrunErrors;
			gTotalStat.AlignmentErrors +=     pData->AlignmentErrors;
			gTotalStat.BufferOverrunErrors += pData->BufferOverrunErrors;
	
			gTotalStat.BytesTransmittedUncompressed += pData->BytesTransmittedUncompressed;
			gTotalStat.BytesReceivedUncompressed +=    pData->BytesReceivedUncompressed;
			gTotalStat.BytesTransmittedCompressed +=   pData->BytesTransmittedCompressed;
			gTotalStat.BytesReceivedCompressed +=      pData->BytesReceivedCompressed;
	
			gTotalStat.TotalErrors +=      pData->TotalErrors;
		}

        free( pStats );
    }

	free (hBundleArray);

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\perf\rasctrnm.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    rasctrnm.h

Abstract:

    This file defines the ras symbols used in the rasctrs.ini file for
    loading the counters to registry. 

Created:

    Thomas J. Dimitri	        28 May 93

Revision History

    Ram Cherala                 04 Nov 93   Added this header 


--*/
//
//  rasctrnm.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the
//  "First Counter" and "First Help" values fo the device they belong to,
//  in order to determine the  absolute location of the counter and
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//


#define RASPORTOBJ 		0


//
// The following constants are good for both Total and individual port.
//

#define BYTESTX			2
#define BYTESRX			4

#define FRAMESTX		6
#define FRAMESRX		8

#define PERCENTTXC		10
#define PERCENTRXC		12

#define CRCERRORS		14
#define TIMEOUTERRORS	        16
#define SERIALOVERRUNS	        18
#define ALIGNMENTERRORS	        20
#define BUFFEROVERRUNS	        22

#define TOTALERRORS		24

#define BYTESTXSEC 		26
#define BYTESRXSEC 		28

#define FRAMESTXSEC		30
#define FRAMESRXSEC		32

#define TOTALERRORSSEC          34


//
// The following constants are good only for Total.
//

#define RASTOTALOBJ             36

#define TOTALCONNECTIONS        38
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\perf\perfmsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfmsg.h

Abstract:

    This file provides the macros and definitions used by the extensible
    counters for reporting events to the event logging facility

Author:

      Bob Watson (a-robw) 5 Oct 92

Revision History:


--*/
#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_
//
// Report error message ID's for Counters
//

#define APP_NAME  "rasctrs"

//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//    Levels:  LOG_NONE = No event log messages ever
//             LOG_USER = User event log messages (e.g. errors)
//             LOG_DEBUG = Minimum Debugging
//             LOG_VERBOSE = Maximum Debugging
//

#define  LOG_NONE     0
#define  LOG_USER     1
#define  LOG_DEBUG    2
#define  LOG_VERBOSE  3

#define  MESSAGE_LEVEL_DEFAULT  LOG_USER

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//    REPORT_xxx (message_value, message_level)
//       where:
//          xxx is the severity to be displayed in the event log
//          message_value is the numeric ID from above
//          message_level is the "filtering" level of error reporting
//             using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the
//
//    REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//

//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could
// (should) be changed  in the future
//


#define REPORT_SUCCESS(i,l)

#define REPORT_INFORMATION(i,l)

#define REPORT_WARNING(i,l)

#define REPORT_ERROR(i,l)

#define REPORT_INFORMATION_DATA

#define REPORT_WARNING_DATA(i,l,d,s)

#define REPORT_ERROR_DATA(i,l,d,s)

// External Variables

extern HANDLE hEventLog;   // handle to event log
extern DWORD  dwLogUsers;  // counter of event log using routines
extern DWORD  MESSAGE_LEVEL; // event logging detail level

#endif //_PERFMSG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\perf\perfras.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfras.c

Abstract:

    This file implements the Extensible Objects for  the Ras object type

Created:

    Russ Blake			           24 Feb 93
    Thomas J. Dimitri	        28 May 93

Revision History

    Ram Cherala                 15 Feb 96

      Don't hard code the length of the instance name in
      CollectRasPerformanceData.
      PerfMon checks the actual instance name length to determine
      if the name is properly formatted, so compute it for each
      instance name.

    Patrick Y. Ng               12 Aug 93


--*/

//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddser.h>

#include <windows.h>
#include <string.h>
#include <wcstr.h>
#include <winperf.h>

#include <malloc.h>
#include <ntprfctr.h>

#include "globals.h"
#include "rasctrs.h" // error message definition
#include "perfmsg.h"
#include "perfutil.h"
#include "dataras.h"
#include "port.h"

#include <rasman.h>
#include <serial.h>
#include <isdn.h>
#include <raserror.h>

#include <stdarg.h>
#include <string.h>
#include <stdio.h>

//
//  References to constants which initialize the Object type definitions
//

DWORD   dwOpenCount = 0;        // count of "Open" threads
BOOL    bInitOK = FALSE;        // true = DLL initialized OK
CRITICAL_SECTION g_csPerf;

//
//  Function Prototypes
//
//      these are used to insure that the data collection functions
//      accessed by Perflib will have the correct calling format.
//

PM_OPEN_PROC            OpenRasPerformanceData;
PM_COLLECT_PROC         CollectRasPerformanceData;
PM_CLOSE_PROC           CloseRasPerformanceData;


BOOL
FRasmanStarted()
{
    SC_HANDLE schandle = NULL;
    SC_HANDLE svchandle = NULL;
    BOOL fRet = FALSE;
    
    //
    // Check to see if rasman service is started.
    // fail if it isn't - we don't want ras perf
    // to start rasman service.
    //
    schandle = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);

    if(NULL != schandle)
    {
        svchandle = OpenService(schandle,
                                "RASMAN",
                                SERVICE_QUERY_STATUS);

        if(NULL != svchandle)
        {
            SERVICE_STATUS status;
            
            if(     (QueryServiceStatus(svchandle, &status))
                &&  (status.dwCurrentState == SERVICE_RUNNING))
            {
                fRet = TRUE;
            }

            CloseServiceHandle(svchandle);
        }

        CloseServiceHandle(schandle);
    }

    return fRet;
}

DWORD
DwInitializeRasCounters()
{
    LONG status;

    HKEY hKeyDriverPerf = NULL;
    DWORD size;
    DWORD type;

    DWORD dwFirstCounter;
    DWORD dwFirstHelp;
    
    if (!dwOpenCount)
    {

        InitializeCriticalSection(&g_csPerf);

        //
        // open Eventlog interface
        //

        hEventLog = MonOpenEventLog();

        //
        // Load rasman.dll and get all the required functions.
        //

        status = InitRasFunctions();

        if( status != ERROR_SUCCESS )
        {

            REPORT_ERROR (RASPERF_UNABLE_DO_IOCTL, LOG_USER);

            // this is fatal, if we can't get data then there's no
            // point in continuing.

            goto OpenExitPoint;

        }

        // AnshulD: BUG: 750860
        // get counter and help index base values
        // update static data structures by adding base to
        // offset value in structure.

        status = RegOpenKeyEx ( HKEY_LOCAL_MACHINE,
                                TEXT("SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Performance"),
                                0L,
                                KEY_READ,
                                &hKeyDriverPerf);

        if (status != ERROR_SUCCESS)
        {

            REPORT_ERROR (RASPERF_UNABLE_OPEN_DRIVER_KEY, LOG_USER);                
                
            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.

            goto OpenExitPoint;
        }

        size = sizeof (DWORD);
        status = RegQueryValueEx( hKeyDriverPerf,
                                    TEXT("First Counter"),
                                    0L,
                                    &type,
                                    (LPBYTE)&dwFirstCounter,
                                    &size);

        if (status != ERROR_SUCCESS)
        {
            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.

            REPORT_ERROR (RASPERF_UNABLE_READ_FIRST_COUNTER, LOG_USER);                
            goto OpenExitPoint;
        }

        size = sizeof (DWORD);
        status = RegQueryValueEx(   hKeyDriverPerf,
                                    TEXT("First Help"),
                                    0L,
                                    &type,
                                    (LPBYTE)&dwFirstHelp,
                                    &size);

        if (status != ERROR_SUCCESS)
        {
            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            
            REPORT_ERROR (RASPERF_UNABLE_READ_FIRST_HELP, LOG_USER);                
            goto OpenExitPoint;
        }

        InitObjectCounterIndex( dwFirstCounter,
                                dwFirstHelp );

        bInitOK = TRUE; // ok to use this function
    }


    dwOpenCount++;  // increment OPEN counter

    status = ERROR_SUCCESS; // for successful exit


OpenExitPoint:

    if ( hKeyDriverPerf )
        RegCloseKey (hKeyDriverPerf);

    return status;

}

//***
//
// Routine Description:
//
//      This routine will open and map the memory used by the RAS driver to
//      pass performance data in. This routine also initializes the data
//      structures used to pass data back to the registry
//
// Arguments:
//
//      Pointer to object ID of each device to be opened (RAS)
//
//
// Return Value:
//
//      None.
//
//***

DWORD OpenRasPerformanceData( LPWSTR lpDeviceNames )
{
    LONG status;

    //
    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem
    //

    status = DwInitializeRasCounters();
    
    return status;

}


//***
//
// Routine Description:
//
//      This routine will return the data for the RAS counters.
//
// Arguments:
//
//    IN OUT    LPWSTR  lpValueName
//		        pointer to a wide character string passed by registry.
//
//    IN OUT	LPVOID   *lppData
//    IN:	        pointer to the address of the buffer to receive the completed
//                PerfDataBlock and subordinate structures. This routine will
//                append its data to the buffer starting at the point referenced
//                by *lppData.
//    OUT:	points to the first byte after the data structure added by this
//                routine. This routine updated the value at lppdata after appending
//                its data.
//
//    IN OUT	LPDWORD  lpcbTotalBytes
//    IN:		the address of the DWORD that tells the size in bytes of the
//                buffer referenced by the lppData argument
//    OUT:	the number of bytes added by this routine is written to the
//                DWORD pointed to by this argument
//
//    IN OUT	LPDWORD  NumObjectTypes
//    IN:		the address of the DWORD to receive the number of objects added
//                by this routine
//    OUT:	the number of objects added by this routine is written to the
//                DWORD pointed to by this argument
//
// Return Value:
//
//      ERROR_MORE_DATA if buffer passed is too small to hold data
//         any error conditions encountered are reported to the event log if
//         event logging is enabled.
//
//      ERROR_SUCCESS  if success or any other error. Errors, however are
//         also reported to the event log.
//
//***

DWORD CollectRasPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes )
{

    //  Variables for reformating the data

    NTSTATUS    Status;
    ULONG       SpaceNeeded;
    PBYTE       pbIn = (PBYTE) *lppData;


    // variables used for error logging

    DWORD       dwQueryType;


    // Variables used to record which objects are required

    static BOOL IsRasPortObject;
    static BOOL IsRasTotalObject;

    if (    lpValueName == NULL ||
            lppData == NULL || *lppData == NULL ||
            lpcbTotalBytes == NULL || lpNumObjectTypes == NULL ) {

        if ( lpcbTotalBytes )   *lpcbTotalBytes = 0;
        if ( lpNumObjectTypes ) *lpNumObjectTypes = 0;
        return ERROR_SUCCESS; 
    }

    if(!bInitOK)
    {
        Status = DwInitializeRasCounters();
    }

    //
    // before doing anything else, see if Open went OK
    //

    if (!bInitOK)
    {
        // unable to continue because open failed.
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS; // yes, this is a successful exit
    }

    if(!FRasmanStarted())
    {
        PRAS_PORT_DATA_DEFINITION pRasPortDataDefinition;
        PRAS_TOTAL_DATA_DEFINITION pRasTotalDataDefinition;
        PPERF_COUNTER_BLOCK pPerfCounterBlock;
        PVOID   pData;
        DWORD   TotalBytes = 0;
        DWORD   ObjectTypes = 0;
        DWORD   BytesRequired;
        
        BytesRequired = ALIGN8(sizeof(RAS_PORT_DATA_DEFINITION)) +
                        ALIGN8(sizeof(RAS_TOTAL_DATA_DEFINITION))+
                        ALIGN8(SIZE_OF_RAS_TOTAL_PERFORMANCE_DATA);
        
        if ( *lpcbTotalBytes < BytesRequired ) {
            *lpcbTotalBytes = 0;
            *lpNumObjectTypes = 0;
            return ERROR_MORE_DATA;
        }
        
        pData = *lppData;

        //
        // Copy the (constant, initialized) RAS PORT Object Type and 
        // counter definitions to the caller's data buffer
        //
        pRasPortDataDefinition = pData;
        memcpy( pRasPortDataDefinition,
            &gRasPortDataDefinition,
            sizeof(RAS_PORT_DATA_DEFINITION));
    
        //
        // Move pData to the location where we are going to copy the 
        // RAS_TOTAL_DATA_DEFINITION
        //
        pData = (PBYTE) pData + ALIGN8(sizeof(RAS_PORT_DATA_DEFINITION));
        TotalBytes += ALIGN8(sizeof(RAS_PORT_DATA_DEFINITION));

        pRasPortDataDefinition->RasObjectType.TotalByteLength =
            ALIGN8(sizeof(RAS_PORT_DATA_DEFINITION));
        
        ObjectTypes++;



        //
        // Copy the (constant, initialized) RAS TOTAL Object Type and 
        // counter definitions to the caller's data buffer
        //
        memcpy( pData,
            &gRasTotalDataDefinition,
            sizeof(RAS_TOTAL_DATA_DEFINITION));

        //
        // Move pData to the location where we are going to copy the 
        // counter block for RAS TOTAL
        //
        pData = (PBYTE) pData + ALIGN8(sizeof(RAS_TOTAL_DATA_DEFINITION));
        TotalBytes += ALIGN8(sizeof(RAS_TOTAL_DATA_DEFINITION));

        //
        // Set all the counter values to 0
        //
        memset ( pData, 0, ALIGN8(SIZE_OF_RAS_TOTAL_PERFORMANCE_DATA));

        //
        // Set the Bytelength field of the counter block
        //
        pPerfCounterBlock = pData;
        pPerfCounterBlock->ByteLength = ALIGN8(SIZE_OF_RAS_TOTAL_PERFORMANCE_DATA);

        //
        // Move pData to the end of the RAS TOTAL counter block
        //
        pData = (PBYTE) pData + ALIGN8(SIZE_OF_RAS_TOTAL_PERFORMANCE_DATA);
        TotalBytes += ALIGN8(SIZE_OF_RAS_TOTAL_PERFORMANCE_DATA);


        ObjectTypes++;

        *lpcbTotalBytes = TotalBytes;
        *lpNumObjectTypes = ObjectTypes;

        *lppData = pData;

        return ERROR_SUCCESS;
    }

    //
    // Rasman is up and running. 
    //

    //
    // Reset some output variables.
    //

    *lpNumObjectTypes = 0;

    EnterCriticalSection(&g_csPerf);
    
    //
    // Initialize all the port information.
    //

    if(ERROR_SUCCESS != InitPortInfo())
    {
        REPORT_ERROR_DATA (RASPERF_UNABLE_CREATE_PORT_TABLE, LOG_USER,
            &status, sizeof(status));

        // this is fatal, if we can't get the base values of the
        // counter or help names, then the names won't be available
        // to the requesting application  so there's not much
        // point in continuing.
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        LeaveCriticalSection(&g_csPerf);
        return ERROR_SUCCESS;
    }


    //
    // see if this is a foreign (i.e. non-NT) computer data request
    //

    dwQueryType = GetQueryType (lpValueName);

    if (dwQueryType == QUERY_FOREIGN)
    {
        // this routine does not service requests for data from
        // Non-NT computers
	    *lpcbTotalBytes = (DWORD) 0;
    	*lpNumObjectTypes = (DWORD) 0;
        LeaveCriticalSection(&g_csPerf);
        return ERROR_SUCCESS;
    }
    else if (dwQueryType == QUERY_ITEMS)
    {
        IsRasPortObject = IsNumberInUnicodeList (gRasPortDataDefinition.RasObjectType.ObjectNameTitleIndex,
                                                        lpValueName);

        IsRasTotalObject = IsNumberInUnicodeList (gRasTotalDataDefinition.RasObjectType.ObjectNameTitleIndex,
                                                        lpValueName);

	if ( !IsRasPortObject && !IsRasTotalObject )
        {
            //
            // request received for data object not provided by this routine
            //

            *lpcbTotalBytes = (DWORD) 0;
    	    *lpNumObjectTypes = (DWORD) 0;
            LeaveCriticalSection(&g_csPerf);
            return ERROR_SUCCESS;
        }
    }
    else if( dwQueryType == QUERY_GLOBAL )
    {
        IsRasPortObject = IsRasTotalObject = TRUE;
    }

    //
    // Now check to see if we have enough space to hold all the data
    //

    SpaceNeeded = GetSpaceNeeded(IsRasPortObject, IsRasTotalObject);


    if ( *lpcbTotalBytes < SpaceNeeded )
    {
	    *lpcbTotalBytes = (DWORD) 0;
    	*lpNumObjectTypes = (DWORD) 0;
        LeaveCriticalSection(&g_csPerf);
        return ERROR_MORE_DATA;
    }

    //
    // Collect all the RAS statistics now.
    //

    Status = CollectRasStatistics();

    if( Status != ERROR_SUCCESS )
    {
        REPORT_ERROR_DATA (RASPERF_CANNOT_GET_RAS_STATISTICS, LOG_USER,
                &Status, sizeof(Status));

    	*lpcbTotalBytes = (DWORD) 0;
	    *lpNumObjectTypes = (DWORD) 0;
        LeaveCriticalSection(&g_csPerf);
        return ERROR_SUCCESS;
    }

    //
    // We first fill in the data for object Ras Port, if needed.
    //

    if( IsRasPortObject )
    {
        PRAS_PORT_DATA_DEFINITION pRasPortDataDefinition;
        RAS_PORT_INSTANCE_DEFINITION RasPortInstanceDefinition;
        PRAS_PORT_INSTANCE_DEFINITION pRasPortInstanceDefinition;
        DWORD    cPorts;
        DWORD     i;
        PVOID   pData;


        cPorts = GetNumOfPorts();

        pRasPortDataDefinition = (PRAS_PORT_DATA_DEFINITION) *lppData;



        //
        // Copy the (constant, initialized) Object Type and counter definitions
        // to the caller's data buffer
        //

        memcpy( pRasPortDataDefinition,
		 &gRasPortDataDefinition,
		 sizeof(RAS_PORT_DATA_DEFINITION));


        //
        // Now copy the instance definition and counter block.
        //


        //
        // First construct the default perf instance definition.
        //

        RasPortInstanceDefinition.RasInstanceType.ByteLength =
                                ALIGN8(sizeof(RAS_PORT_INSTANCE_DEFINITION));

        RasPortInstanceDefinition.RasInstanceType.ParentObjectTitleIndex = 0;

        RasPortInstanceDefinition.RasInstanceType.ParentObjectInstance = 0;

        RasPortInstanceDefinition.RasInstanceType.NameOffset =
                                sizeof(PERF_INSTANCE_DEFINITION);

        //DbgPrint("RASCTRS: RasPortinstanceDefinition.ByteLength = 0x%x\n",
        //        RasPortInstanceDefinition.RasInstanceType.ByteLength);
                

/*      Don't hard code the length of the instance name.
**      PerfMon checks the actual instance name length to determine
**      if the name is properly formatted, so compute it for
**      each instance name. ramc 2/15/96.
**        RasPortInstanceDefinition.RasInstanceType.NameLength =
**                                sizeof( WCHAR ) * MAX_PORT_NAME;
*/

        //
        // Get to the end of the data definition.
        //

        // pData = (PVOID) &(pRasPortDataDefinition[1]);

        pData = ((PBYTE) pRasPortDataDefinition + ALIGN8(sizeof(RAS_PORT_DATA_DEFINITION)));


        for( i=0; i < cPorts; i++ )
        {

            //DbgPrint("RASCTRS: port %d, pData = 0x%x\n", i, pData);
        
            //
            // First copy the instance definition data.
            //

            RasPortInstanceDefinition.RasInstanceType.UniqueID = PERF_NO_UNIQUE_ID;

            lstrcpyW( (LPWSTR)&RasPortInstanceDefinition.InstanceName,
                      GetInstanceName(i) );

            // Compute the instance name length

            RasPortInstanceDefinition.RasInstanceType.NameLength =
                (lstrlenW(RasPortInstanceDefinition.InstanceName) + 1) *
                sizeof( WCHAR );


            memcpy( pData, &RasPortInstanceDefinition,
                     sizeof( RasPortInstanceDefinition ) );

            //
            // Move pPerfInstanceDefinition to the beginning of data block.
            //

            pData = (PVOID)((PBYTE) pData + ALIGN8(sizeof(RAS_PORT_INSTANCE_DEFINITION)));


            //
            // Get the data block.  Note that pPerfInstanceDefinition will be
            // set to the next available byte.
            //

            GetInstanceData( i, &pData );
        }

        //
        // Set *lppData to the next available byte.
        //

        *lppData = pData;

        (*lpNumObjectTypes)++;


    }
    


    //
    // Then we fill in the data for object Ras Total, if needed.
    //

    if( IsRasTotalObject )
    {
        PRAS_TOTAL_DATA_DEFINITION pRasTotalDataDefinition;
        PVOID   pData;

        pRasTotalDataDefinition = (PRAS_TOTAL_DATA_DEFINITION) *lppData;


        //DbgPrint("RASCTRS: RasTotalDataDefinition = 0x%x\n", 
        //        pRasTotalDataDefinition);

        //
        // Copy the (constant, initialized) Object Type and counter definitions
        // to the caller's data buffer
        //

        memcpy( pRasTotalDataDefinition,
		 &gRasTotalDataDefinition,
		 sizeof(RAS_TOTAL_DATA_DEFINITION));


        //
        // Now copy the counter block.
        //


        //
        // Set pRasTotalDataDefinition to the beginning of counter block.
        //

        // pData = (PVOID) &(pRasTotalDataDefinition[1]);
        pData = (PBYTE) pRasTotalDataDefinition + ALIGN8(sizeof(RAS_TOTAL_DATA_DEFINITION));

        //DbgPrint("RASCTRS: pData for total = 0x%x\n", pData);

        GetTotalData( &pData );

        //
        // Set *lppData to the next available byte.
        //

        *lppData = pData;

        (*lpNumObjectTypes)++;
    }

    //DbgPrint("RASCTRS: pbOut = 0x%x\n", *lppData);

    *lpcbTotalBytes = SpaceNeeded;

    /*
    DbgPrint("pbIn+SpaceNeeded=0x%x, *lppData=0x%x\n",
            pbIn+SpaceNeeded,
            *lppData);
    */            

    ASSERT((pbIn + SpaceNeeded) == (PBYTE) *lppData);

    LeaveCriticalSection(&g_csPerf);
    
    return ERROR_SUCCESS;
}


//***
//
// Routine Description:
//
//      This routine closes the open handles to RAS device performance
//      counters.
//
// Arguments:
//
//      None.
//
// Return Value:
//
//      ERROR_SUCCESS
//
//***

DWORD CloseRasPerformanceData()
{
    if(!bInitOK)
    {
    
        return ERROR_SUCCESS;
    }
    if (!(--dwOpenCount))
    {
        // when this is the last thread...

        MonCloseEventLog();
        EnterCriticalSection(&g_csPerf);
        ClosePortInfo();
        DeleteCriticalSection(&g_csPerf);
    }

    return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasadmin\api\dllinit.c ===
/******************************************************************\
*                     Microsoft Windows NT                         *
*               Copyright(c) Microsoft Corp., 1995                 *
\******************************************************************/

/*++

Module Name:

    DLLINIT.C


Description:

    This module contains code for the rasadm.dll initialization.
Author:

    Janakiram Cherala (RamC)    November 29, 1995

Revision History:

--*/

#include <windows.h>

BOOL
DllMain(
    HANDLE hinstDll,
    DWORD  fdwReason,
    LPVOID lpReserved
    )
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls(hinstDll);
            break;
        case DLL_PROCESS_DETACH:
            break;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdial\src\rasdial.c ===
/*****************************************************************************/
/**                         Microsoft LAN Manager                           **/
/**                   Copyright (C) 1993 Microsoft Corp.                    **/
/*****************************************************************************/

//***
//    File Name:
//       RASDIAL.C
//
//    Function:
//        Command line interface for making Remote Access connections,
//        as well as disconnecting from and enumerating these connections.
//
//    History:
//        03/18/93 - Michael Salamone (MikeSa) - Original Version 1.0
//***


#ifdef UNICODE
#error This program is built ANSI-only so it will run, as is, on Chicago.
#undef UNICODE
#endif

#include <windows.h>

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>
#include <io.h>

#include <lmcons.h>
#include <lmerr.h>

#include <mbstring.h>

#include <ras.h>
#include <raserror.h>

#include "rasdial.h"
#include "rasdial.rch"
#include <mprerror.h>

#include "rasuip.h" //for DwRasUninitialize

#include "winnlsp.h"

//For Secure password bug, gangz
#include "pwutil.h"
#include "debug.h"

char g_progname[MAX_PATH + 1];
char g_username[UNLEN + 1];
char g_password[PWLEN + 1];
char g_domain[DNLEN + 1];
char g_entryname[RAS_MaxEntryName * sizeof( USHORT ) + 1];
char g_phone_num[RAS_MaxPhoneNumber + 1];
char g_callback_num[RAS_MaxCallbackNumber + 1];
char g_phone_book[MAX_PATH + 1];
BOOL g_OpenPortBefore = FALSE;
BOOL g_UsePrefixSuffix = FALSE;

HANDLE g_hEvent;
DWORD g_exitcode;
BOOL g_fHangupCalled = FALSE;
PBYTE g_Args[9];
BOOL g_fNotDialAll = FALSE;


HRASCONN g_hRasConn = NULL;
DWORD g_dbg = 0;

DWORD dwSubEntries = 0;
PBOOLEAN pSubEntryDone = NULL;
BOOLEAN fSubEntryConnected = FALSE;
BOOLEAN fRasUninitialize = FALSE;

#define IsBetweenInclusive(x, y, z) (((x) >= (y)) && ((x) <= (z)))

void _cdecl main(int argc, char *argv[])
{
    WORD len;
    UCHAR term;
    DWORD Action;
    BYTE ErrorMsg[1024];

    g_exitcode = 0L;

   // Initialize trace and assert support.
   //
   DEBUGINIT( "RASDIAL" );
   
    // For bug 453885   
    // To make the console Apps MUI ready, we need to call
    // LANGID WINAPI SetThreadUILanguage(WORD wReserved);  
    // This wReserved is reserved and can be set to 0
    // It is in winnlsp.h, implemented in kernel32.dll, use kernel32p.lib for 
    // static link
    //
    SetThreadUILanguage(0);
    
    Action = ParseCmdLine(argc, argv);

    switch (Action)
    {
        case HELP:
            Usage();
            break;


        case DIAL:
            //
            // Was username specified on command line?  If not, prompt for it.
            //
            // gangz
            //(1) prompt usage, 
            //      rasdial gangz-d-2  *  *
            //      the first * stands for username and the second one stands for password
            //(2) When using prompt usage
            //       and in the username prompt, need to include the domain info like
            //       Username:gangz-d-2\foo
            //      password:XXXXXXX
            //
            if (!strcmp(g_username, "*"))
            {
                PrintMessage(DIAL_USERNAME_PROMPT, NULL);
                GetString(g_username, UNLEN + 1, &len, &term);
            }

            //
            // Was password specified on command line?  If not, prompt for it.
            //
            //gangz
            //For secure password bug .Net 754400
            SafeDecodePasswordBuf(g_password);
            if (!strcmp(g_password, "*"))
            {
                PrintMessage(DIAL_PASSWORD_PROMPT, NULL);
                
                RtlSecureZeroMemory(g_password,sizeof(g_password));
                GetPasswdStr(g_password, PWLEN + 1, &len);
            }
            SafeEncodePasswordBuf(g_password);

            Dial();
            fRasUninitialize = TRUE;
            break;


        case DISCONNECT:
            Disconnect();
            fRasUninitialize = TRUE;
            break;


        case ENUMERATE_CONNECTIONS:
            EnumerateConnections();
            fRasUninitialize = TRUE;
            break;
    }


    if (g_exitcode)
    {
        if ( 
            IsBetweenInclusive(g_exitcode, RASBASE, RASBASEEND) ||
            IsBetweenInclusive(g_exitcode, ROUTEBASE, ROUTEBASEEND))
        {
            BYTE str[10];

            g_Args[0] = _itoa(g_exitcode, str, 10);
            g_Args[1] = NULL;
            PrintMessage(DIAL_ERROR_PREFIX, g_Args);

            RasGetErrorStringA(g_exitcode, ErrorMsg, 1024L);

            CharToOemA(ErrorMsg, ErrorMsg);
            fputs(ErrorMsg, stdout); //For whistler 524729

            if (IsBetweenInclusive(g_exitcode, RASBASE, RASBASEEND))
            {
                PrintMessage(DIAL_MORE_HELP, g_Args);
            }                    
        }
        else
        {
            FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS |
                    FORMAT_MESSAGE_MAX_WIDTH_MASK | FORMAT_MESSAGE_FROM_SYSTEM,
                    GetModuleHandle(NULL), g_exitcode, 0, ErrorMsg, 1024, NULL);

            CharToOemA(ErrorMsg, ErrorMsg);
            fputs( ErrorMsg,stdout);
        }
    }
    else
    {
        PrintMessage(DIAL_COMMAND_SUCCESS, NULL);
    }

    //
    // Uninitialize ras if we are done
    //
    if(fRasUninitialize)
    {
        (void) DwRasUninitialize();
    }

    //Wipe the global password buffer before exit.
    //so, there can be only 1 exit in thie main() function
    //
    SafeWipePasswordBuf(g_password);
    
   /* Terminate trace and assert support.
   */
   DEBUGTERM();

   exit(g_exitcode);
}


VOID Dial(VOID)
{
    DWORD rc;
    LPSTR pPhoneFile = NULL;
    RASDIALPARAMSA DialParms;
    RASDIALEXTENSIONS DialExts;
    RASDIALEXTENSIONS* pDialExts;
    RASEAPUSERIDENTITYA* pRasEapUserIdentity = NULL;
    DWORD NumEntries;
    RASCONNA *RasConn = NULL;
    RASCONNA *SaveRasConn = NULL;
    LPRASENTRY lpEntry;
    DWORD dwcbEntry, dwcbIgnored;


    //
    // This just gets us an array of RASCONN structs
    //
    if (Enumerate(&RasConn, &NumEntries))
    {
        return;
    }

    SaveRasConn = RasConn;


    while (NumEntries--)
    {
        if (!_mbsicmp(g_entryname, RasConn->szEntryName))
        {
            g_Args[0] = RasConn->szEntryName;
            g_Args[1] = NULL;
            PrintMessage(DIAL_ALREADY_CONNECTED, g_Args);

            GlobalFree(SaveRasConn);
            return;
        }

        RasConn++;
    }

    GlobalFree(SaveRasConn);


    //
    // This is the structure we pass to RasDial
    //
    DialParms.dwSize = sizeof(RASDIALPARAMSA);

    strcpy(DialParms.szUserName, g_username);

    SafeDecodePasswordBuf(g_password);
    strcpy(DialParms.szPassword, g_password);
    SafeEncodePasswordBuf(g_password);
    SafeEncodePasswordBuf(DialParms.szPassword);

    strcpy(DialParms.szEntryName, g_entryname);
    strcpy(DialParms.szDomain, g_domain);
    strcpy(DialParms.szPhoneNumber, g_phone_num);
    strcpy(DialParms.szCallbackNumber, g_callback_num);

    ZeroMemory((PBYTE) &DialExts, sizeof(RASDIALEXTENSIONS));

    //
    // The parameter extension structure passed to RasDial
    //
    if (g_UsePrefixSuffix)
    {
        DialExts.dwSize = sizeof(DialExts);
        DialExts.dwfOptions = RDEOPT_UsePrefixSuffix;
#if DBG
        DialExts.dwfOptions |= (RDEOPT_IgnoreModemSpeaker/*|RDEOPT_SetModemSpeaker*/);
#endif
        DialExts.hwndParent = NULL;
        DialExts.reserved = 0;

        pDialExts = &DialExts;
    }
    else
        pDialExts = NULL;


    //
    // This event will get signaled in the RasDialCallback routine
    // once dial has completed (either successfully or because of error.
    //
    g_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!g_hEvent)
    {
        g_exitcode = GetLastError();

#if DBG
        if (g_dbg)
            printf("Error creating event - rc=%li\n", g_exitcode);
#endif

        return;
    }


    //
    // We need a routine to handle CTRL-C, CTRL-BREAK, etc.
    //
    if (!SetConsoleCtrlHandler(DialControlSignalHandler, TRUE))
    {
#if DBG
        printf("SetConsoleCtrlHandler returned error\n");
#endif
    }


    if (g_phone_book[0])
    {
        pPhoneFile = g_phone_book;
    }

    //
    // Get the number of subentries in this connection.
    //
    rc = RasGetEntryProperties(
           pPhoneFile,
           g_entryname,
           NULL,
           &dwcbEntry,
           NULL,
           &dwcbIgnored);
    if (rc != ERROR_BUFFER_TOO_SMALL) {
        g_exitcode = rc;
        return;
    }
    lpEntry = LocalAlloc(LPTR, dwcbEntry);
    if (lpEntry == NULL) {
        rc = GetLastError();
        g_exitcode = rc;
        return;
    }
    lpEntry->dwSize = sizeof (RASENTRY);
    rc = RasGetEntryProperties(
           pPhoneFile,
           g_entryname,
           lpEntry,
           &dwcbEntry,
           NULL,
           &dwcbIgnored);
    if (rc) {
        g_exitcode = rc;
        return;
    }
    dwSubEntries = lpEntry->dwSubEntries;
#if DBG
    if (g_dbg)
        printf("%s has %d subentries\n", g_entryname, dwSubEntries);
#endif

    g_fNotDialAll = !(lpEntry->dwDialMode & RASEDM_DialAll);

    LocalFree(lpEntry);
    //
    // Allocate an array to keep the completion
    // status for each subentry.
    //
    pSubEntryDone = LocalAlloc(LPTR, dwSubEntries * sizeof (BOOLEAN));
    if (pSubEntryDone == NULL) {
        rc = GetLastError();
        g_exitcode = rc;
        return;
    }

    {
        rc = RasGetEapUserIdentity(
               pPhoneFile,
               g_entryname,
               RASEAPF_NonInteractive,
               NULL,
               &pRasEapUserIdentity);

        switch (rc)
        {
        case ERROR_INVALID_FUNCTION_FOR_ENTRY:

            break;

        case NO_ERROR:

            strcpy(DialParms.szUserName, pRasEapUserIdentity->szUserName);
            DialExts.dwSize = sizeof(DialExts);
            pDialExts = &DialExts;
            pDialExts->RasEapInfo.dwSizeofEapInfo =
                pRasEapUserIdentity->dwSizeofEapInfo;
            pDialExts->RasEapInfo.pbEapInfo =
                pRasEapUserIdentity->pbEapInfo;

            break;

        default:

            g_exitcode = rc;
            return;
        }
    }

    //
    // Now dial
    //

    SafeDecodePasswordBuf(DialParms.szPassword);
    if (rc = RasDialA(
            pDialExts, pPhoneFile, &DialParms, 2, RasDialFunc2,
            &g_hRasConn))
    {
        g_exitcode = rc;

#if DBG
        if (g_dbg)
            printf("Error from RasDial = %li\n", rc);
#endif

        SafeWipePasswordBuf(DialParms.szPassword);
        RasFreeEapUserIdentity(pRasEapUserIdentity);
        return;
    }

    SafeWipePasswordBuf(DialParms.szPassword);


#ifdef PRINTDOTS

    //
    // Now we just print "." every second until dial has completed.
    //
    while (1)
    {
        rc = WaitForSingleObject(g_hEvent, 1000L);
        if (rc == WAIT_TIMEOUT)
        {
            PrintMessage(DIAL_DOT, NULL);
        }
        else
        {
            break;
        }
    }

#else

    WaitForSingleObject(g_hEvent, INFINITE);

#endif

    if (g_fHangupCalled)
    {
        WaitForRasCompletion();
    }


    RasFreeEapUserIdentity(pRasEapUserIdentity);
    return;
}


VOID EnumerateConnections(VOID)
{
    DWORD NumEntries;
    RASCONNA *RasConn = NULL, *SaveRasConn;


    //
    // This just gets us an array of RASCONN structs
    //
    if (Enumerate(&RasConn, &NumEntries))
    {
        if(NULL != RasConn)
        {
            GlobalFree(RasConn);
        }
        return;
    }

    SaveRasConn = RasConn;


    //
    // Now, go thru array of RASCONN structs and print out each connection.
    //
    if (!NumEntries)
    {
        PrintMessage(DIAL_NO_CONNECTIONS, NULL);
    }
    else
    {
        PrintMessage(DIAL_ENUM_HEADER, NULL);

        while (NumEntries--)
        {
            g_Args[0] = RasConn->szEntryName;
            g_Args[1] = NULL;
            PrintMessage(DIAL_ENUM_ENTRY, g_Args);

            RasConn++;
        }
    }


    //
    // This was allocated for us by the Enumerate call above
    //
    GlobalFree(SaveRasConn);

    return;
}


VOID Disconnect(VOID)
{
    DWORD rc;
    DWORD NumEntries;
    RASCONNA *RasConn = NULL, *SaveRasConn;
    BOOL fFoundEntry = FALSE;


    //
    // This just gets us an array of RASCONN structs
    //
    if (Enumerate(&RasConn, &NumEntries))
    {
        if(NULL != RasConn)
        {
            GlobalFree(RasConn);
        }
        return;
    }

    SaveRasConn = RasConn;


    //
    // Now, go thru array of RASCONN structs searching for the
    // right entry to disconnect.
    //
    // Also, If no entryname specified on cmd line AND there
    // is only one connection, we'll set the entryname to that
    // one (thus having the effect of disconnecting that one).
    // If no entryname given AND more than one connection, we
    // won't disconnect anything - we'll enumerate the connections
    // and give the user an error message.
    //
    // For whistler 517024
    //
    if ( !g_entryname[0] && (NumEntries > 1))
    {
        PrintMessage(DIAL_DISCONNECT_ERROR, NULL);
        EnumerateConnections();

        goto Done;
    }


    if (!NumEntries)
    {
        PrintMessage(DIAL_NO_CONNECTIONS, NULL);

        goto Done;
    }


    if ( !g_entryname[0] && (NumEntries == 1))
    {
        strcpy(g_entryname, RasConn->szEntryName);
    }


    while (NumEntries-- && !fFoundEntry)
    {
        if (!_mbsicmp(g_entryname, RasConn->szEntryName))
        {
            fFoundEntry = TRUE;

            if (!SetConsoleCtrlHandler(DisconnectControlSignalHandler, TRUE))
            {
#if DBG
                printf("SetConsoleCtrlHandler returned error\n");
#endif
            }

            if (rc = RasHangUpA(RasConn->hrasconn))
            {
                g_exitcode = rc;

#if DBG
                if (g_dbg)
                    printf("Error from RasHangUp = %li\n", rc);
#endif

            }

            WaitForRasCompletion();

            break;
        }

        RasConn++;
    }


    if (!fFoundEntry)
    {
        g_Args[0] = g_entryname;
        g_Args[1] = NULL;
        PrintMessage(DIAL_NOT_CONNECTED, g_Args);
    }


Done:

    //
    // This was allocated for us by the Enumerate call above
    //
    GlobalFree(SaveRasConn);


    return;
}


//
// To get array of RASCONN structures
//
DWORD Enumerate(RASCONNA **RasConn, PDWORD NumEntries)
{
    DWORD rc;
    DWORD EnumSize = 0L;

    // For whistler bug 513878
    if ( NULL == NumEntries )
    {
        return 0L;
    }

    *NumEntries = 0;

    *RasConn = (RASCONNA *) GlobalAlloc(GMEM_FIXED, sizeof(RASCONNA));
    if (!*RasConn)
    {
        g_exitcode = GetLastError();

#if DBG
        if (g_dbg)
            printf("No memory for enumerating connections!\n");
#endif

        *NumEntries = 0;
        return (1L);
    }

    (*RasConn)->dwSize = sizeof(RASCONNA);


    //
    // This first call will tell us how much space we need to
    // fit in all the structures.
    //
    rc = RasEnumConnectionsA(*RasConn, &EnumSize, NumEntries);
    if (!rc && !*NumEntries)
    {
        return (0L);
    }


    if (rc != ERROR_BUFFER_TOO_SMALL)
    {
        g_exitcode = rc;

#if DBG
        if (g_dbg)
            printf("Error from RasEnumConnectionsA = %li!\n", rc);
#endif

        GlobalFree(*RasConn);
        *RasConn = NULL;

        *NumEntries = 0;
        return (1L);
    }

    //
    // Now we get memory for the structures.
    //
    GlobalFree(*RasConn);
    *RasConn = (RASCONNA *) GlobalAlloc(GMEM_FIXED, EnumSize);

    if (!*RasConn)
    {
        g_exitcode = GetLastError();

#if DBG
        if (g_dbg)
            printf("No memory for enumerating connections!\n");
#endif

        *NumEntries = 0;
        return (1L);
    }


    (*RasConn)->dwSize = sizeof(RASCONNA);

    //
    // This second call will now fill up our buffer with the
    // RASCONN structures.
    //
    if (rc = RasEnumConnectionsA(*RasConn, &EnumSize, NumEntries))
    {
        g_exitcode = rc;

#if DBG
        if (g_dbg)
            printf("Error from RasEnumConnectionsA = %li!\n", rc);
#endif

        *NumEntries = 0;
        GlobalFree(*RasConn);
        *RasConn = NULL;

        return (1L);
    }

    return (0L);
}


VOID Usage(VOID)
{
    g_Args[0] = g_progname;
    g_Args[1] = NULL;
    PrintMessage(DIAL_USAGE, g_Args);

    return;
}


DWORD ParseCmdLine(int argc, char *argv[])
{
    int i;
    BYTE CmdLineSwitch[80];
    PCHAR pColon;


    strcpy(g_progname, argv[0]);

    //
    // Set up defaults for these, in case switch isn't given on the
    // command line for them.
    //
    g_username[0] = '\0';       // means use name user is logged on with

     // gangz
    //Even this is the first time g_password referred currently in this code,
    // to keep it logic safe for future changes, do this first. 
    //
    SafeWipePasswordBuf(g_password);
    g_password[0] = '\0';       // means use password user is logged on with
    
    //To be logic safe, always encode the password after assinging a value to it, no matter what 
    // the value it, other places will assume it encode before using it.
    //
    SafeEncodePasswordBuf(g_password);
    
    strcpy(g_domain, "*");      // means use domain stored in phonebook
    g_phone_num[0] = '\0';      // means use phone number stored in phonebook
    g_phone_book[0] = '\0';     // means use default phone book file
    g_callback_num[0] = '\0';   // means don't callback if user-specified
    g_UsePrefixSuffix = FALSE;  // means don't use prefix/suffix, if defined


    if (argc == 1)
    {
        //
        // In this case, only the name of the program was specified,
        // which means all we have to do is enumerate connections.
        //
        return (ENUMERATE_CONNECTIONS);
    }


    //
    // see if an entryname is present (must be 1st argument if it is)
    //
    if (is_valid_entryname(argv[1]))
    {
        //
        // We have a valid entryname - user either wants to dial to
        // it or disconnect from it.
        //

        strcpy(g_entryname, argv[1]);
        _mbsupr(g_entryname);
        LoadStringA(GetModuleHandle(NULL), DIAL_DISCONNECT_SWITCH,
                CmdLineSwitch, 80);
        if ((argc == 3) && (argv[2][0] == '/') && (strlen(&argv[2][1])) &&
                match(&argv[2][1], CmdLineSwitch))
        {
            return (DISCONNECT);
        }
        else
        {
            if ((argc > 3) && (argv[2][0] == '/') && (strlen(&argv[2][1])) &&
                    match(&argv[2][1], CmdLineSwitch))
            {
                return (HELP);
            }
        }


        //
        // User wants to connect - get username, password, and options
        //

        //
        // Username specified?  If next arg doesn't start with "/", then
        // YEA!.  If it does, then neither username or password are
        // specified.
        //
        if ((argc > 2) && (argv[2][0] != '/'))
        {
            if (strlen(argv[2]) > UNLEN)
            {
                return (HELP);
            }

            strcpy(g_username, argv[2]);


            //
            // Password specified?  If next arg doesn't start with "/", then
            // YEA!.
            //
            if ((argc > 3) && (argv[3][0] != '/'))
            {
                if (strlen(argv[3]) > PWLEN)
                {
                    return (HELP);
                }

                SafeWipePasswordBuf(g_password);
                
                strcpy(g_password, argv[3]);
                
                SafeEncodePasswordBuf( g_password);
                RtlSecureZeroMemory(argv[3], lstrlenA(argv[3]) );
                
                i = 4;
            }
            else
            {
                i = 3;
            }
        }
        else
        {
            //
            // No username or password specified
            //
            i = 2;
        }


        //
        // Now get any other options.  If any cmd line switch is
        // invalid, or is specified more than once, we'll bail
        // out.
        //
        for (; i<argc; i++)
        {
            BOOL fDomainSpecified = FALSE;
            BOOL fCallbackSpecified = FALSE;


            //
            // Command line switched must be designated by '/'!
            if (argv[i][0] != '/')
            {
                return (HELP);
            }


            LoadStringA(GetModuleHandle(NULL), DIAL_DOMAIN_SWITCH,
                    CmdLineSwitch, 80);
            if (match(&argv[i][1], CmdLineSwitch))
            {
                //
                // Switch previously specified?
                //
                if (fDomainSpecified)
                {
                    return (HELP);
                }

                fDomainSpecified = TRUE;

                pColon = strchr(argv[i], ':');
                if (pColon)
                {
                    strncpy(g_domain, pColon+1, DNLEN);
                    g_domain[DNLEN] = '\0';
                    _strupr(g_domain);
                }
                else
                {
                    return (HELP);
                }

                continue;
            }


            LoadStringA(GetModuleHandle(NULL), DIAL_PHONE_NO_SWITCH,
                    CmdLineSwitch, 80);
            if (match(&argv[i][1], CmdLineSwitch))
            {
                //
                // Switch previously specified?
                //
                if (g_phone_num[0])
                {
                    return (HELP);
                }

                pColon = strchr(argv[i], ':');
                if (pColon && strlen(pColon+1))
                {
                    strncpy(g_phone_num, pColon+1, RAS_MaxPhoneNumber);
                    g_phone_num[RAS_MaxPhoneNumber] = '\0';
                }
                else
                {
                    return (HELP);
                }

                continue;
            }


            LoadStringA(GetModuleHandle(NULL), DIAL_PHONE_BOOK_SWITCH,
                    CmdLineSwitch, 80);
            if (match(&argv[i][1], CmdLineSwitch))
            {
                OFSTRUCT of_struct;

                //
                // Switch previously specified?
                //
                if (g_phone_book[0])
                {
                    return (HELP);
                }


                //
                // This is the default path for the phone book file.
                // Our method is, if the phone book switch is supplied,
                // we will append it to this string and check for file
                // existence.  If it does not exist, we will test for
                // existence of the literal value supplied.  If that
                // still does not exist, we give a help message and exit.
                //
                ExpandEnvironmentStringsA("%windir%\\system32\\ras\\",
                        g_phone_book, MAX_PATH);

                pColon = strchr(argv[i], ':');
                if (pColon && strlen(pColon+1))
                {
                    if ((strlen(pColon+1) + strlen(g_phone_book)) > MAX_PATH-1)
                    {
                        //
                        // The catenated string would exceed MAX_PATH, so
                        // forget it - just use the string supplied.
                        //
                        strncpy(g_phone_book, pColon+1, MAX_PATH);
                        g_phone_book[MAX_PATH] = '\0';
                    }
                    else
                    {
                        strcat(g_phone_book, pColon+1);
                        if (OpenFile(g_phone_book, &of_struct, OF_EXIST) ==
                                HFILE_ERROR)
                        {
                            //
                            // The file doesn't exist in the default directory,
                            // so we'll use the value supplied straight away.
                            //
                            strncpy(g_phone_book, pColon+1, MAX_PATH);
                            g_phone_book[MAX_PATH] = '\0';
                        }
                    }

                    // OpenFile here previously removed, so the case falls thru
                    // and sets exit code correctly.  See bug 73798.
                }
                else
                {
                    return (HELP);
                }

                continue;
            }


            LoadStringA(GetModuleHandle(NULL), DIAL_CALLBACK_NO_SWITCH,
                    CmdLineSwitch, 80);
            if (match(&argv[i][1], CmdLineSwitch))
            {
                //
                // Switch previously specified?
                //
                if (fCallbackSpecified)
                {
                    return (HELP);
                }

                fCallbackSpecified = TRUE;

                pColon = strchr(argv[i], ':');
                if (pColon && strlen(pColon+1))
                {
                    strncpy(g_callback_num, pColon+1, RAS_MaxCallbackNumber);
                    g_callback_num[RAS_MaxCallbackNumber] = '\0';
                }
                else
                {
                    return (HELP);
                }

                continue;
            }


            LoadStringA(GetModuleHandle(NULL), DIAL_PREFIXSUFFIX_SWITCH,
                    CmdLineSwitch, 80);
            if (match(&argv[i][1], CmdLineSwitch))
            {
                g_UsePrefixSuffix = TRUE;
                continue;
            }


            //
            // Invalid switch, so we're out of here
            //
            return (HELP);
        }

        return (DIAL);
    }
    else
    {
        //
        // since no entryname was specified, there are 2 possibilities:
        //    1. user wants help
        //    2. user wants to disconnect
        //
        LoadStringA(GetModuleHandle(NULL), DIAL_HELP_SWITCH,
                CmdLineSwitch, 80);
        if (match(&argv[1][1], CmdLineSwitch))
        {
            return (HELP);
        }

        LoadStringA(GetModuleHandle(NULL), DIAL_DISCONNECT_SWITCH,
                CmdLineSwitch, 80);
        if (match(&argv[1][1], CmdLineSwitch))
        {
            //
            // Ok, user wants to disconnect, but we don't know what the
            // entryname is.  We'll just put in blank for now.
            //
            g_entryname[0] = '\0';

            if (argc == 2)
            {
                return (DISCONNECT);
            }
            else
            {
                return (HELP);
            }
        }


        //
        // Invalid command line if we get here
        //
        return (HELP);
    }
}


BOOLEAN
AllSubEntriesCompleted(VOID)
{
    DWORD i;
    BOOLEAN bCompleted = TRUE;

    for (i = 0; i < dwSubEntries; i++) {
#if DBG
        if (g_dbg)
            printf("pSubEntryDone[%d]=%d\n", i, pSubEntryDone[i]);
#endif
        if (!pSubEntryDone[i]) {
            bCompleted = FALSE;
            break;
        }
    }
    return bCompleted;
}


DWORD WINAPI
RasDialFunc2(
    DWORD        dwCallbackId,
    DWORD        dwSubEntry,
    HRASCONN     hrasconn,
    UINT         unMsg,
    RASCONNSTATE state,
    DWORD        dwError,
    DWORD        dwExtendedError
    )
{
#if DBG
    if (g_dbg)
        printf("%d: state=%d, dwError=%d\n", dwSubEntry, state, dwError);
#endif

    if (dwError ||
        state == RASCS_SubEntryDisconnected ||
        state == RASCS_Disconnected)
    {
        DWORD i, dwErr;
        HRASCONN hrassubcon;
        BOOLEAN bDropConnection = TRUE;

        pSubEntryDone[dwSubEntry - 1] = TRUE;

        if ((   !g_fNotDialAll
            &&  AllSubEntriesCompleted())
            ||  g_fNotDialAll
            ||  state == RASCS_Disconnected) {
#ifdef DBG
            if (g_dbg)
                printf("hanging up connection\n");
#endif

            if (!fSubEntryConnected) {
                g_exitcode = dwError;

                RasHangUpA(g_hRasConn);
                g_fHangupCalled = TRUE;

            }

            SetEvent(g_hEvent);
        }

        return 1;
    }


    switch (state)
    {
        case RASCS_OpenPort:
            g_Args[0] = g_entryname;
            g_Args[1] = NULL;
            if (g_OpenPortBefore)
                PrintMessage(DIAL_CONNECTING2, g_Args);
            else
            {
                PrintMessage(DIAL_CONNECTING, g_Args);
                g_OpenPortBefore = TRUE;
            }
            break;

        case RASCS_PortOpened:
        case RASCS_ConnectDevice:
        case RASCS_DeviceConnected:
        case RASCS_AllDevicesConnected:
            break;

        case RASCS_Authenticate:
            PrintMessage(DIAL_AUTHENTICATING, NULL);
            break;

        case RASCS_ReAuthenticate:
            PrintMessage(DIAL_REAUTHENTICATING, NULL);
            break;

        case RASCS_AuthNotify:
        case RASCS_AuthCallback:
        case RASCS_AuthAck:
        case RASCS_AuthChangePassword:
        case RASCS_AuthRetry:
            break;

        case RASCS_AuthProject:
            PrintMessage(DIAL_PROJECTING, NULL);
            break;

        case RASCS_AuthLinkSpeed:
            PrintMessage(DIAL_LINK_SPEED, NULL);
            break;

        case RASCS_Authenticated:
            //PrintMessage(DIAL_NEWLINE, NULL);
            break;

        case RASCS_PrepareForCallback:
            PrintMessage(DIAL_CALLBACK, NULL);
            break;

        case RASCS_WaitForModemReset:
        case RASCS_WaitForCallback:
            break;

        case RASCS_Interactive:
        case RASCS_RetryAuthentication:
        case RASCS_CallbackSetByCaller:
        case RASCS_PasswordExpired:
        {
            BYTE str[8];

            g_Args[0] = _itoa(state, str, 10);
            g_Args[1] = NULL;
            PrintMessage(DIAL_AUTH_ERROR, g_Args);

            RasHangUpA(g_hRasConn);
            g_fHangupCalled = TRUE;

            SetEvent(g_hEvent);
            break;
        }

        case RASCS_SubEntryConnected:
        case RASCS_Connected:
            fSubEntryConnected = TRUE;
            pSubEntryDone[dwSubEntry-1] = TRUE;
            if (    AllSubEntriesCompleted()
                ||  g_fNotDialAll) {
                g_Args[0] = g_entryname;
                g_Args[1] = NULL;
                PrintMessage(DIAL_CONNECT_SUCCESS, g_Args);
                SetEvent(g_hEvent);
            }

            break;

        case RASCS_Disconnected:
            PrintMessage(DIAL_DISCONNECTED, NULL);
            SetEvent(g_hEvent);
            break;
    }


    return 1;
}


BOOL DialControlSignalHandler(DWORD ControlType)
{
    //
    // Do we have a handle back from Rasdial call?
    //
    if (g_hRasConn)
    {
        RasHangUpA(g_hRasConn);
    }

    WaitForRasCompletion();

    PrintMessage(DIAL_CONTROL_C, NULL);

    exit(1L);

    return (TRUE);    // have to satisfy the compiler, you know.
}


BOOL DisconnectControlSignalHandler(DWORD ControlType)
{
    return (TRUE);
}


VOID WaitForRasCompletion(VOID)
{
    RASCONNSTATUSA Status;

    Status.dwSize = sizeof(RASCONNSTATUSA);

    while (RasGetConnectStatusA(g_hRasConn, &Status) != ERROR_INVALID_HANDLE)
    {
        Sleep(125L);
    }
}


BOOL is_valid_entryname(char *candidate)
{
    if (_mbslen(candidate) > RAS_MaxEntryName)
    {
        return (FALSE);
    }

    if (candidate[0] == '/')
    {
        return (FALSE);
    }

    return (TRUE);
}


//
// Returns TRUE if str1 is a substr of str2, starting at the beginning
// of str2 and ignoring case.  I.e. "Mike" will match "MIKESA".  "MIKESA"
// will not match "Mike"
//
BOOL match(
    char *str1,
    char *str2
    )
{
    BOOL retval;
    char *tstr1;
    char *tstr2;
    char *pcolon;

    tstr1 = (char *) GlobalAlloc(GMEM_FIXED, strlen(str1) + 1);
    if (!tstr1)
    {
        return (FALSE);
    }

    tstr2 = (char *) GlobalAlloc(GMEM_FIXED, strlen(str2) + 1);
    if (!tstr2)
    {
        GlobalFree(tstr1);
        return (FALSE);
    }


    strcpy(tstr1, str1);
    strcpy(tstr2, str2);

    _strupr(tstr1);
    _strupr(tstr2);

    pcolon = strchr(tstr1, ':');
    if (pcolon)
    {
        *pcolon = '\0';
    }

    if (strstr(tstr2, tstr1) == tstr2)
    {
        retval = TRUE;
    }
    else
    {
        retval = FALSE;
    }

    GlobalFree(tstr1);
    GlobalFree(tstr2);

    return (retval);
}


/***    GetPasswdStr -- read in password string
 *
 *      USHORT LUI_GetPasswdStr(char far *, USHORT);
 *
 *      ENTRY:  buf             buffer to put string in
 *              buflen          size of buffer
 *              &len            address of USHORT to place length in
 *
 *      RETURNS:
 *              0 or NERR_BufTooSmall if user typed too much.  Buffer
 *              contents are only valid on 0 return.
 *
 *      History:
 *              who     when    what
 *              erichn  5/10/89 initial code
 *              dannygl 5/28/89 modified DBCS usage
 *              erichn  7/04/89 handles backspaces
 *              danhi   4/16/91 32 bit version for NT
 */
#define CR              0xD
#define BACKSPACE       0x8

USHORT GetPasswdStr(
    UCHAR *buf,
    USHORT buflen,
    USHORT *len
    )
{
    USHORT ch;
    CHAR *bufPtr = buf;

    buflen -= 1;    // make space for null terminator
    *len = 0;       // GP fault probe (a la API's)

    while (TRUE)
    {
        ch = LOWORD(_getch());                   // grab char silently
        if ((ch == CR) || (ch == 0xFFFF))       // end of the line
        {
            break;
        }

        if (ch == BACKSPACE)    // back up one or two
        {
            //
            // IF bufPtr == buf then the next two lines are
            // a no op.
            //
            if (bufPtr != buf)
            {
                bufPtr--;
                (*len)--;
            }
            continue;           // bail out, start loop over
        }

        *bufPtr = (UCHAR) ch;

        bufPtr += (*len < buflen) ? 1 : 0;   // don't overflow buf
        (*len)++;               // always increment len
    }

    *bufPtr = '\0';             // null terminate the string

    putchar('\n');

    return((*len <= buflen) ? (USHORT) 0 : (USHORT) NERR_BufTooSmall);
}


#define MAX_ARGS 9


// For whistler bug 453885      gangz
// Change to be widechar compatable
//
VOID PrintMessage(
    DWORD MsgId,
    PBYTE *pArgs
    )
{
    DWORD NumArgs;
    DWORD BufSize;
    BOOL BufAllocated = FALSE;
    WCHAR * Buf = NULL;
    PBYTE *pTmpArgs;
    WCHAR * pSub;
    WCHAR MsgBuf[513];
    WCHAR * pMsgBuf = MsgBuf;
    WCHAR wArgs[MAX_ARGS][512];
    char * pOemBuf = NULL;
    int num = 0;

    __try
    {
        num = LoadStringW(GetModuleHandle(NULL), MsgId, MsgBuf, 
                          sizeof(MsgBuf)/sizeof(WCHAR)-1);
        if( 0 == num)
        {
            __leave;
        }

        if (pArgs)
        {
            //
            // Find out how many arguments were passed in.  We do this to detect
            // if the string requires a parameter that wasn't supplied.  If that
            // happens, we just won't substitute anything.
            //
            int i = 0;
            
            for (  i = 0; i < MAX_ARGS; i ++ )
            {
                wArgs[i][0]=L'\0';
                if ( NULL == pArgs[i] )
                {
                    continue;
                }
                
                if ( 512 <= strlen(pArgs[i]) )
                {
                    __leave;
                }

               if ( 0 == MultiByteToWideChar(
                            CP_ACP,
                            0,
                            pArgs[i],
                            -1,
                            wArgs[i],
                            512) )
               {
                    __leave;
               }
             }
            
            for (NumArgs=0, pTmpArgs=pArgs; *pTmpArgs!=NULL; NumArgs++, pTmpArgs++);

            if (NumArgs >= MAX_ARGS)
            {
                __leave;
            }


            //
            // We'll figure out how large our buffer should be to contain the
            // final output (length of string + sum(length of substitution params)
            //
            BufSize = ( wcslen(MsgBuf) + 1 ) * 2;

            while (pSub = wcschr(pMsgBuf, L'%'))
            {
                DWORD Num = *(pSub+1) - L'0';
                if (Num >=1 && Num <=NumArgs)
                {
                    BufSize += 2*( strlen(pArgs[Num-1])+1 );

                    pMsgBuf = pSub+2;
                }
                else
                {
                    pMsgBuf = pSub+2;
                }
            }


            
            //
            // Get space for our buffer (we multiply by 2 because we want buf to
            // be big enough for Oem character set.
            //
            Buf = GlobalAlloc(GMEM_FIXED, BufSize * 2);
            if ( NULL == Buf)
            {
                __leave;
            }

            BufAllocated = TRUE;


            Buf[0] = L'\0';
            pMsgBuf = MsgBuf;

             // Now make our final output buffer.  Strategy is to strcat
            // the first part of the string up to where the 1st substitution
            // goes, then strcat the substitution param.  Do this until no
            // more substitutions.
            //
            while (pSub = wcschr(pMsgBuf, L'%'))
            {
                DWORD Num = *(pSub+1) - L'0';
                if (Num >=1 && Num <=NumArgs)
                {
                    *pSub = L'\0';

                    wcscat(Buf, pMsgBuf);
                    wcscat(Buf, wArgs[Num-1]);

                    pMsgBuf = pSub+2;
                }
                else
                {
                    wcscat(Buf, pMsgBuf);

                    pMsgBuf = pSub+2;
                }
            }

            //
            // Now get everything after the last substitution.
            //
            if (*pMsgBuf)
            {
                wcscat(Buf, pMsgBuf);
            }
        }
        else
        {
            Buf = MsgBuf;
        }

        {
            int len = 0;
            len =lstrlenW(Buf);

            pOemBuf = GlobalAlloc(GMEM_FIXED, (len +1)*2);
            if( NULL == pOemBuf )
            {
                __leave;
            }

        }

        CharToOemW( Buf, pOemBuf );
        fputs( pOemBuf, stdout );
        
     }
    __finally
    {
        if ( Buf  &&
        	BufAllocated
        	) //For .Net 688889
        {
            GlobalFree(Buf);
        }
        
        if ( pOemBuf )
        {
            GlobalFree( pOemBuf);
        }
    }

    return;
}


/***    GetString -- read in string with echo
 *
 *      USHORT LUI_GetString(char far *, USHORT, USHORT far *, char far *);
 *
 *      ENTRY:  buf             buffer to put string in
 *              buflen          size of buffer
 *              &len            address of USHORT to place length in
 *              &terminator     holds the char used to terminate the string
 *
 *      RETURNS:
 *              0 or NERR_BufTooSmall if user typed too much.  Buffer
 *              contents are only valid on 0 return.  Len is ALWAYS valid.
 *
 *      OTHER EFFECTS:
 *              len is set to hold number of bytes typed, regardless of
 *              buffer length.  Terminator (Arnold) is set to hold the
 *              terminating character (newline or EOF) that the user typed.
 *
 *      Read in a string a character at a time.  Is aware of DBCS.
 *
 *      History:
 *              who     when    what
 *              erichn  5/11/89 initial code
 *              dannygl 5/28/89 modified DBCS usage
 *              danhi   3/20/91 ported to 32 bits
 */

USHORT GetString(
    register UCHAR *buf,
    register USHORT buflen,
    register USHORT *len,
    register UCHAR *terminator
    )
{
    buflen -= 1;                        // make space for null terminator
    *len = 0;                           // GP fault probe (a la API's)

    while (TRUE)
    {
        *buf = (UCHAR) getchar();
        if (*buf == '\n' || *buf == (UCHAR) EOF)
        {
            break;
        }

        buf += (*len < buflen) ? 1 : 0; // don't overflow buf
        (*len)++;                       // always increment len
    }

    *terminator = *buf;                 // set terminator
    *buf = '\0';                        // null terminate the string

    return ((*len <= buflen) ? (USHORT) 0 : (USHORT) NERR_BufTooSmall);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasadmin\api\nmapi.c ===
/******************************************************************\
*                     Microsoft Windows NT                         *
*               Copyright(c) Microsoft Corp., 1992                 *
\******************************************************************/

/*++

Module Name:

    NMAPI.C


Description:

    This module contains code for all the RASADMIN APIs
    that communicate with the server using Named pipes.

    RasAdminPortEnum
    RasAdminPortGetInfo
    RasAdminPortClearStatistics
    RasAdminServerGetInfo
    RasAdminPortDisconnect
    BuildPipeName         - internal routine
    GetRasServerVersion   - internal routine

Author:

    Janakiram Cherala (RamC)    July 7,1992

Revision History:

    Jan 04,1993    RamC    Set the Media type to MEDIA_RAS10_SERIAL in
                           RasAdminPortEnum to fix a problem with port
                           enumeration against downlevel servers.
                           Changed the hardcoded stats indices to defines

    Aug 25,1992    RamC    Code review changes:

                           o changed all lpbBuffers to actual structure
                             pointers.
                           o changed all LPWSTR to LPWSTR

    July 7,1992    RamC    Ported from RAS 1.0 (Original version
                           written by Narendra Gidwani - nareng)

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "rassapi.h"

//
// Deprecated API in .Net #526819
//
DWORD APIENTRY RasAdminPortEnum(
    IN const WCHAR * lpszServer,
    OUT PRAS_PORT_0 *ppRasPort0,
    OUT WORD *pcEntriesRead
    )
/*++

Routine Description:

    This routine enumerates all the ports on the specified server
    and fills up the caller's lpBuffer with an array of RAS_PORT_0
    structures for each port.  A NULL lpszServer indicates the
    local server.

Arguments:

    lpszServer      name of the server to enumerate ports on.

    pRasPort0       pointer to a buffer in which port information is
                    returned as an array of RAS_PORT_0 structures.

    pcEntriesRead   The number of RAS_PORT_0 entries loaded.

Return Value:

    ERROR_SUCCESS if successful

    One of the following non-zero error codes indicating failure:

        NERR_ItemNotFound indicates no ports were found.
        error codes from CallNamedPipe.
        ERROR_MORE_DATA indicating more data is available.
--*/
{
    DbgPrint("Unsupported Interface - RasAdminPortEnum");

    if (ppRasPort0)
    {
        *ppRasPort0 = NULL;
    }

    if (pcEntriesRead)
    {
        *pcEntriesRead = 0;
    }

    return ERROR_CALL_NOT_IMPLEMENTED;
}

//
// Deprecated API in .Net #526819
//
DWORD APIENTRY RasAdminPortGetInfo(
  IN const WCHAR          *  lpszServer,
  IN const WCHAR          *  lpszPort,
  OUT RAS_PORT_1          *  pRasPort1,
  OUT RAS_PORT_STATISTICS *  pRasStats,
  OUT RAS_PARAMETERS      ** ppRasParams
  )
/*++

Routine Description:

    This routine retrieves information associated with a port on the
    server. It loads the caller's pRasPort1 with a RAS_PORT_1 structure.

Arguments:

    lpszServer  name of the server which has the port, eg.,"\\SERVER"

    lpszPort    port name to retrieve information for, e.g. "COM1".

    pRasPort1   pointer to a buffer in which port information is
                returned.  The returned info is a RAS_PORT_1 structure.

    pRasStats   pointer to a buffer in which port statistics information is
                returned.  The returned info is a RAS_PORT_STATISTICS structure.

    ppRasParams pointer to a buffer in which port parameters information is
                returned.  The returned info is an array of RAS_PARAMETERS structure.
                It is the responsibility of the caller to free this buffer calling
                RasAdminBufferFree.

Return Value:

    ERROR_SUCCESS on successful return.

    One of the following non-zero error codes indicating failure:

        ERROR_MORE_DATA indicating that more data than can fit in
                        pRasPort1 is available
        return codes from CallNamedPipe.
        ERROR_DEV_NOT_EXIST indicating requested port is invalid.
--*/
{
    DbgPrint("Unsupported Interface - RasAdminPortGetInfo");

    if (pRasPort1)
    {
        ZeroMemory(pRasPort1, sizeof(RAS_PORT_1));
    }

    if (pRasStats)
    {
        ZeroMemory(pRasStats, sizeof(RAS_PORT_STATISTICS));
    }

    if (ppRasParams)
    {
        *ppRasParams = NULL;
    }

    return ERROR_CALL_NOT_IMPLEMENTED;
}

//
// Deprecated API in .Net #526819
//
DWORD APIENTRY RasAdminPortClearStatistics(
    IN const WCHAR * lpszServer,
    IN const WCHAR * lpszPort
    )
/*++

Routine Description:

    This routine clears the statistics associated with the specified
    port.

Arguments:

    lpszServer    name of the server which has the port, eg.,"\\SERVER"

    lpszPort      port name to retrieve information for, e.g. "COM1".


Return Value:

    ERROR_SUCCESS on successful return.

    One of the following non-zero error codes indicating failure:

        return codes from CallNamedPipe.
        ERROR_DEV_NOT_EXIST if the specified port does not belong
                            to RAS.
--*/
{
    DbgPrint("Unsupported Interface - RasAdminPortClearStatistics");

    return ERROR_CALL_NOT_IMPLEMENTED;
}

//
// Deprecated API in .Net #526819
//
DWORD APIENTRY RasAdminServerGetInfo(
    IN  const WCHAR * lpszServer,
    OUT PRAS_SERVER_0 pRasServer0
    )
/*++

Routine Description:

    This routine retrieves RAS specific information from the specified
    RAS server.  The server name can be NULL in which case the local
    machine is assumed.

Arguments:

    lpszServer  name of the RAS server to get information from or
                NULL for the local machine.

    pRasServer0 points to a buffer to store the returned data. On
                successful return this buffer contains a
                RAS_SERVER_0 structure.

Return Value:

    ERROR_SUCCESS on successful return.

    one of the following non-zero error codes on failure:

        error codes from CallNamedPipe.
        NERR_BufTooSmall indicating that the input buffer is smaller
        than size of RAS_SERVER_0.
--*/
{
    DbgPrint("Unsupported Interface - RasAdminServerGetInfo");

    if (pRasServer0)
    {
        ZeroMemory(pRasServer0, sizeof(RAS_SERVER_0));
    }

    return ERROR_CALL_NOT_IMPLEMENTED;
}

//
// Deprecated API in .Net #526819
//
DWORD APIENTRY RasAdminPortDisconnect(
    IN const WCHAR * lpszServer,
    IN const WCHAR * lpszPort
    )
/*++

Routine Description:

    This routine disconnects the user attached to the specified
    port on the server lpszServer.

Arguments:

    lpszServer  name of the RAS server.

    lpszPort    name of the port, e.g. "COM1"

Return Value:

    ERROR_SUCCESS on successful return.

    one of the following non-zero error codes on failure:

        ERROR_INVALID_PORT indicating the port name is invalid.
        error codes from CallNamedPipe.
        NERR_UserNotFound indicating that no user is logged on
        at the specified port.
--*/
{
    DbgPrint("Unsupported Interface - RasAdminPortDisconnect");

    return ERROR_CALL_NOT_IMPLEMENTED;
}

//
// Deprecated API in .Net #526819
//
DWORD RasAdminFreeBuffer(PVOID Pointer)
{
    DbgPrint("Unsupported Interface - RasAdminFreeBuffer");

    return ERROR_CALL_NOT_IMPLEMENTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdial\src\rasdial.h ===
/*****************************************************************************/
/**                         Microsoft LAN Manager                           **/
/**                   Copyright (C) 1993 Microsoft Corp.                    **/
/*****************************************************************************/

//***
//    File Name:
//       RASDIAL.H
//
//    Function:
//        Header information for RASDIAL command line interface.
//
//    History:
//        03/18/93 - Michael Salamone (MikeSa) - Original Version 1.0
//***

#ifndef _RASDIAL_H_
#define _RASDIAL_H_

#define ENUMERATE_CONNECTIONS  0
#define DIAL                   1
#define DISCONNECT             2
#define HELP                   3

void _cdecl main(int argc, char *argv[]);

VOID Dial(VOID);
VOID Disconnect(VOID);
VOID EnumerateConnections(VOID);
VOID Usage(VOID);

DWORD Enumerate(RASCONNA **RasConn, PDWORD NumEntries);
DWORD WINAPI
RasDialFunc2(
    DWORD        dwCallbackId,
    DWORD        dwSubEntry,
    HRASCONN     hrasconn,
    UINT         unMsg,
    RASCONNSTATE state,
    DWORD        dwError,
    DWORD        dwExtendedError
    );
BOOL DialControlSignalHandler(DWORD ControlType);
BOOL DisconnectControlSignalHandler(DWORD ControlType);
VOID WaitForRasCompletion(VOID);

BOOL is_valid_entryname(char *candidate);
BOOL match(char *str1, char *str2);

DWORD ParseCmdLine(int argc, char *argv[]);
VOID PrintMessage(DWORD MsgId, PBYTE *pArgs);

USHORT GetPasswdStr(UCHAR *buf, WORD buflen, WORD *len);

USHORT GetString(
    register UCHAR *buf,
    register WORD buflen,
    register WORD *len,
    register UCHAR *terminator
    );

#endif  // _RASDIAL_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasadmin\api\rassapi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rassapi.h

Description:

    This file contains the RASADMIN structures, defines and
    function prototypes for the following APIs and they can
    be imported from RASSAPI.DLL:

     RasAdminServerGetInfo
     RasAdminGetUserAccountServer
     RasAdminUserSetInfo
     RasAdminUserGetInfo
     RasAdminPortEnum
     RasAdminPortGetInfo
     RasAdminPortClearStatistics
     RasAdminPortDisconnect
     RasAdminFreeBuffer

Note:

    This header file and the sources containing the APIs will work
    only with UNICODE strings.

--*/

#ifndef _RASSAPI_H_
#define _RASSAPI_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef UNLEN
#include <lmcons.h>
#endif

#define RASSAPI_MAX_PHONENUMBER_SIZE     128
#define RASSAPI_MAX_MEDIA_NAME	         16
#define RASSAPI_MAX_PORT_NAME	            16
#define RASSAPI_MAX_DEVICE_NAME          128
#define RASSAPI_MAX_DEVICETYPE_NAME       16
#define RASSAPI_MAX_PARAM_KEY_SIZE        32

// Bits indicating user's Remote Access privileges and mask to isolate
// call back privilege.
//
// Note: Bit 0 MUST represent NoCallback due to a quirk of the "userparms"
//       storage method.  When a new LAN Manager user is created, bit 0 of the
//       userparms field is set to 1 and all other bits are 0.  These bits are
//       arranged so this "no Dial-In info" state maps to the "default Dial-In
//       privilege" state.

#define RASPRIV_NoCallback        0x01
#define RASPRIV_AdminSetCallback  0x02
#define RASPRIV_CallerSetCallback 0x04
#define RASPRIV_DialinPrivilege   0x08

#define RASPRIV_CallbackType (RASPRIV_AdminSetCallback \
                              | RASPRIV_CallerSetCallback \
                              | RASPRIV_NoCallback)

//
// Modem condition codes
//
#define	RAS_MODEM_OPERATIONAL	     1	// No modem errors.
#define	RAS_MODEM_NOT_RESPONDING     2
#define	RAS_MODEM_HARDWARE_FAILURE   3
#define	RAS_MODEM_INCORRECT_RESPONSE 4
#define	RAS_MODEM_UNKNOWN 	        5
//
// Line condition codes
//
#define	RAS_PORT_NON_OPERATIONAL 1
#define	RAS_PORT_DISCONNECTED	 2
#define	RAS_PORT_CALLING_BACK    3
#define	RAS_PORT_LISTENING	    4
#define	RAS_PORT_AUTHENTICATING  5
#define	RAS_PORT_AUTHENTICATED	 6
#define	RAS_PORT_INITIALIZING	 7

// The following three structures are same as the ones
// defined in rasman.h and have been renamed to prevent
// redefinitions when both header files are included.

enum RAS_PARAMS_FORMAT {

	ParamNumber	    = 0,

	ParamString	    = 1

} ;
typedef enum RAS_PARAMS_FORMAT	RAS_PARAMS_FORMAT ;

union RAS_PARAMS_VALUE {

	DWORD	Number ;

	struct	{
		DWORD	Length ;
		PCHAR	Data ;
		} String ;
} ;
typedef union RAS_PARAMS_VALUE	RAS_PARAMS_VALUE ;

struct RAS_PARAMETERS {

    CHAR	P_Key	[RASSAPI_MAX_PARAM_KEY_SIZE] ;

    RAS_PARAMS_FORMAT	P_Type ;

    BYTE	P_Attributes ;

    RAS_PARAMS_VALUE	P_Value ;

} ;
typedef struct RAS_PARAMETERS	RAS_PARAMETERS ;

// structures used by the RASADMIN APIs

typedef struct _RAS_USER_0
{
    BYTE bfPrivilege;
    WCHAR szPhoneNumber[ RASSAPI_MAX_PHONENUMBER_SIZE + 1];
} RAS_USER_0, *PRAS_USER_0;

typedef struct _RAS_PORT_0
{
    WCHAR wszPortName[RASSAPI_MAX_PORT_NAME];
    WCHAR wszDeviceType[RASSAPI_MAX_DEVICETYPE_NAME];
    WCHAR wszDeviceName[RASSAPI_MAX_DEVICE_NAME];
    WCHAR wszMediaName[RASSAPI_MAX_MEDIA_NAME];
    DWORD reserved;
    DWORD Flags;
    WCHAR wszUserName[UNLEN + 1];
    WCHAR wszComputer[NETBIOS_NAME_LEN];
    DWORD dwStartSessionTime;          // seconds from 1/1/1970
    WCHAR wszLogonDomain[DNLEN + 1];
    BOOL fAdvancedServer;
} RAS_PORT_0, *PRAS_PORT_0;


// Possible values for MediaId

#define MEDIA_UNKNOWN       0
#define MEDIA_SERIAL        1
#define MEDIA_RAS10_SERIAL  2
#define MEDIA_X25           3
#define MEDIA_ISDN          4


// Possible bits set in Flags field

#define USER_AUTHENTICATED    0x0001
#define MESSENGER_PRESENT     0x0002
#define PPP_CLIENT            0x0004
#define GATEWAY_ACTIVE        0x0008
#define REMOTE_LISTEN         0x0010
#define PORT_MULTILINKED      0x0020


typedef ULONG IPADDR;

// The following PPP structures are same as the ones
// defined in rasppp.h and have been renamed to prevent
// redefinitions when both header files are included
// in a module.

/* Maximum length of address string, e.g. "255.255.255.255" for IP.
*/
#define RAS_IPADDRESSLEN  15
#define RAS_IPXADDRESSLEN 22
#define RAS_ATADDRESSLEN  32

typedef struct _RAS_PPP_NBFCP_RESULT
{
    DWORD dwError;
    DWORD dwNetBiosError;
    CHAR  szName[ NETBIOS_NAME_LEN + 1 ];
    WCHAR wszWksta[ NETBIOS_NAME_LEN + 1 ];
} RAS_PPP_NBFCP_RESULT;

typedef struct _RAS_PPP_IPCP_RESULT
{
    DWORD dwError;
    WCHAR wszAddress[ RAS_IPADDRESSLEN + 1 ];
} RAS_PPP_IPCP_RESULT;

typedef struct _RAS_PPP_IPXCP_RESULT
{
    DWORD dwError;
    WCHAR wszAddress[ RAS_IPXADDRESSLEN + 1 ];
} RAS_PPP_IPXCP_RESULT;

typedef struct _RAS_PPP_ATCP_RESULT
{
    DWORD dwError;
    WCHAR wszAddress[ RAS_ATADDRESSLEN + 1 ];
} RAS_PPP_ATCP_RESULT;

typedef struct _RAS_PPP_PROJECTION_RESULT
{
    RAS_PPP_NBFCP_RESULT nbf;
    RAS_PPP_IPCP_RESULT  ip;
    RAS_PPP_IPXCP_RESULT ipx;
    RAS_PPP_ATCP_RESULT  at;
} RAS_PPP_PROJECTION_RESULT;

typedef struct _RAS_PORT_1
{
    RAS_PORT_0                 rasport0;
    DWORD                      LineCondition;
    DWORD                      HardwareCondition;
    DWORD                      LineSpeed;        // in bits/second
    WORD                       NumStatistics;
    WORD                       NumMediaParms;
    DWORD                      SizeMediaParms;
    RAS_PPP_PROJECTION_RESULT  ProjResult;
} RAS_PORT_1, *PRAS_PORT_1;

typedef struct _RAS_PORT_STATISTICS
{
    // The connection statistics are followed by port statistics
    // A connection is across multiple ports.
    DWORD   dwBytesXmited;
    DWORD   dwBytesRcved;
    DWORD   dwFramesXmited;
    DWORD   dwFramesRcved;
    DWORD   dwCrcErr;
    DWORD   dwTimeoutErr;
    DWORD   dwAlignmentErr;
    DWORD   dwHardwareOverrunErr;
    DWORD   dwFramingErr;
    DWORD   dwBufferOverrunErr;
    DWORD   dwBytesXmitedUncompressed;
    DWORD   dwBytesRcvedUncompressed;
    DWORD   dwBytesXmitedCompressed;
    DWORD   dwBytesRcvedCompressed;

    // the following are the port statistics
    DWORD   dwPortBytesXmited;
    DWORD   dwPortBytesRcved;
    DWORD   dwPortFramesXmited;
    DWORD   dwPortFramesRcved;
    DWORD   dwPortCrcErr;
    DWORD   dwPortTimeoutErr;
    DWORD   dwPortAlignmentErr;
    DWORD   dwPortHardwareOverrunErr;
    DWORD   dwPortFramingErr;
    DWORD   dwPortBufferOverrunErr;
    DWORD   dwPortBytesXmitedUncompressed;
    DWORD   dwPortBytesRcvedUncompressed;
    DWORD   dwPortBytesXmitedCompressed;
    DWORD   dwPortBytesRcvedCompressed;

} RAS_PORT_STATISTICS, *PRAS_PORT_STATISTICS;

//
// Server version numbers
//
#define RASDOWNLEVEL       10    // identifies a LM RAS 1.0 server
#define RASADMIN_35        35    // Identifies a NT RAS 3.5 server or client
#define RASADMIN_CURRENT   40    // Identifies a NT RAS 4.0 server or client


typedef struct _RAS_SERVER_0
{
    WORD TotalPorts;             // Total ports configured on the server
    WORD PortsInUse;             // Ports currently in use by remote clients
    DWORD RasVersion;            // version of RAS server
} RAS_SERVER_0, *PRAS_SERVER_0;


//
// function prototypes
//

DWORD APIENTRY RasAdminServerGetInfo(
    IN const WCHAR *  lpszServer,
    OUT PRAS_SERVER_0 pRasServer0
    );

DWORD APIENTRY RasAdminGetUserAccountServer(
    IN const WCHAR * lpszDomain,
    IN const WCHAR * lpszServer,
    OUT LPWSTR       lpszUserAccountServer
    );

DWORD APIENTRY RasAdminUserGetInfo(
    IN const WCHAR   * lpszUserAccountServer,
    IN const WCHAR   * lpszUser,
    OUT PRAS_USER_0    pRasUser0
    );

DWORD APIENTRY RasAdminUserSetInfo(
    IN const WCHAR       * lpszUserAccountServer,
    IN const WCHAR       * lpszUser,
    IN const PRAS_USER_0   pRasUser0
    );

DWORD APIENTRY RasAdminPortEnum(
    IN  const WCHAR * lpszServer,
    OUT PRAS_PORT_0 * ppRasPort0,
    OUT WORD *        pcEntriesRead
    );

DWORD APIENTRY RasAdminPortGetInfo(
    IN const WCHAR *            lpszServer,
    IN const WCHAR *            lpszPort,
    OUT RAS_PORT_1 *            pRasPort1,
    OUT RAS_PORT_STATISTICS *   pRasStats,
    OUT RAS_PARAMETERS **       ppRasParams
    );

DWORD APIENTRY RasAdminPortClearStatistics(
    IN const WCHAR * lpszServer,
    IN const WCHAR * lpszPort
    );

DWORD APIENTRY RasAdminPortDisconnect(
    IN const WCHAR * lpszServer,
    IN const WCHAR * lpszPort
    );

DWORD APIENTRY RasAdminFreeBuffer(
    PVOID Pointer
    );

BOOL APIENTRY RasAdminAcceptNewConnection (
	IN 		RAS_PORT_1 *		      pRasPort1,
    IN      RAS_PORT_STATISTICS *   pRasStats,
    IN      RAS_PARAMETERS *        pRasParams
	);

VOID APIENTRY RasAdminConnectionHangupNotification (
	IN 		RAS_PORT_1 *		      pRasPort1,
    IN      RAS_PORT_STATISTICS *   pRasStats,
    IN      RAS_PARAMETERS *        pRasParams
	);

DWORD APIENTRY RasAdminGetIpAddressForUser (
	IN 		WCHAR  *		lpszUserName,
	IN 		WCHAR  *		lpszPortName,
	IN OUT 	IPADDR *	   pipAddress,
	OUT		BOOL	 *    bNotifyRelease
	);

VOID APIENTRY RasAdminReleaseIpAddress (
	IN 		WCHAR  *		lpszUserName,
	IN 		WCHAR  *		lpszPortName,
	IN 		IPADDR *	   pipAddress
	);

#ifdef __cplusplus
}
#endif

#endif // _RASSAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\devcfg.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// devcfg.c
// Remote Access Common Dialog APIs
// Device configuration dialogs
//
// 10/20/95 Steve Cobb


#include "rasdlgp.h"
#include "mcx.h"

//----------------------------------------------------------------------------
// Help maps
//----------------------------------------------------------------------------

static DWORD g_adwIcHelp[] =
{
    CID_IC_ST_LineType,    HID_IC_LB_LineType,
    CID_IC_LB_LineType,    HID_IC_LB_LineType,
    CID_IC_CB_Fallback,    HID_IC_CB_Fallback,
    CID_IC_GB_DownLevel,   HID_IC_CB_DownLevel,
    CID_IC_CB_DownLevel,   HID_IC_CB_DownLevel,
    CID_IC_CB_Compression, HID_IC_CB_Compression,
    CID_IC_ST_Channels,    HID_IC_EB_Channels,
    CID_IC_EB_Channels,    HID_IC_EB_Channels,
    0, 0
};

static DWORD g_adwMcHelp[] =
{
    CID_MC_I_Modem,           HID_MC_I_Modem,
    CID_MC_EB_ModemValue,     HID_MC_EB_ModemValue,
    CID_MC_ST_MaxBps,         HID_MC_LB_MaxBps,
    CID_MC_LB_MaxBps,         HID_MC_LB_MaxBps,
    CID_MC_GB_Features,       HID_MC_GB_Features,
    CID_MC_CB_FlowControl,    HID_MC_CB_FlowControl,
    CID_MC_CB_ErrorControl,   HID_MC_CB_ErrorControl,
    CID_MC_CB_Compression,    HID_MC_CB_Compression,
    CID_MC_CB_Terminal,       HID_MC_CB_Terminal,
    CID_MC_CB_EnableSpeaker,  HID_MC_CB_EnableSpeaker,
    CID_MC_ST_ModemProtocol,  HID_MC_LB_ModemProtocol,
    CID_MC_LB_ModemProtocol,  HID_MC_LB_ModemProtocol,
    0, 0
};

static DWORD g_adwXsHelp[] =
{
    CID_XS_ST_Explain,    HID_XS_ST_Explain,
    CID_XS_ST_Networks,   HID_XS_LB_Networks,
    CID_XS_LB_Networks,   HID_XS_LB_Networks,
    CID_XS_ST_Address,    HID_XS_EB_Address,
    CID_XS_EB_Address,    HID_XS_EB_Address,
    CID_XS_GB_Optional,   HID_XS_GB_Optional,
    CID_XS_ST_UserData,   HID_XS_EB_UserData,
    CID_XS_EB_UserData,   HID_XS_EB_UserData,
    CID_XS_ST_Facilities, HID_XS_EB_Facilities,
    CID_XS_EB_Facilities, HID_XS_EB_Facilities,
    0, 0
};

//----------------------------------------------------------------------------
// Local datatypes
//----------------------------------------------------------------------------

// ISDN Configuration dialog argument block.
//
typedef struct
_ICARGS
{
    BOOL fShowProprietary;
    PBLINK* pLink;
}
ICARGS;


// ISDN Configuration dialog context block.
//
typedef struct
_ICINFO
{
    // Stub API arguments including shortcut to link associated with the
    // entry.
    //
    ICARGS* pArgs;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndLbLineType;
    HWND hwndCbFallback;
    HWND hwndCbProprietary;
    HWND hwndCbCompression;
    HWND hwndStChannels;
    HWND hwndEbChannels;
    HWND hwndUdChannels;
}
ICINFO;

typedef struct
_MC_INIT_INFO
{
    PBLINK* pLink;
    BOOL fRouter;
} 
MC_INIT_INFO;

// Modem Configuration dialog context block.
//
typedef struct
_MCINFO
{
    // Stub API arguments.  Shortcut to link associated with the entry.
    //
    PBLINK* pLink;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndEbModemValue;
    HWND hwndLbBps;
    HWND hwndCbHwFlow;
    HWND hwndCbEc;
    HWND hwndCbEcc;
    HWND hwndCbTerminal;
    HWND hwndCbEnableSpeaker;
    HWND hwndLbModemProtocols;

    // Script utilities context.
    //
    SUINFO suinfo;
    BOOL fSuInfoInitialized;
    BOOL fRouter;
}
MCINFO;


// X.25 Logon Settings dialog argument block.
//
typedef struct
_XSARGS
{
    BOOL fLocalPad;
    PBENTRY* pEntry;
}
XSARGS;


// X.25 Logon Settings dialog context block.
//
typedef struct
_XSINFO
{
    // Caller's arguments to the dialog.
    //
    XSARGS* pArgs;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndLbNetworks;
    HWND hwndEbAddress;
    HWND hwndEbUserData;
    HWND hwndEbFacilities;
}
XSINFO;

//----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//----------------------------------------------------------------------------

BOOL
IcCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
IcDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
IcInit(
    IN HWND hwndDlg,
    IN ICARGS* pArgs );

VOID
IcTerm(
    IN HWND hwndDlg );

BOOL
IsdnConfigureDlg(
    IN HWND hwndOwner,
    IN PBLINK* pLink,
    IN BOOL fShowProprietary );

BOOL
ModemConfigureDlg(
    IN HWND hwndOwner,
    IN PBLINK* pLink,
    IN BOOL fRouter);

INT_PTR CALLBACK
McDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
McCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

BOOL
McInit(
    IN HWND hwndDlg,
    IN MC_INIT_INFO* pInitInfo );

VOID
McTerm(
    IN HWND hwndDlg );

BOOL
XsCommand(
    IN XSINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
XsDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
XsFillPadsList(
    IN XSINFO* pInfo );

BOOL
XsInit(
    IN HWND hwndDlg,
    IN XSARGS* pArgs );

BOOL
XsSave(
    IN XSINFO* pInfo );

VOID
XsTerm(
    IN HWND hwndDlg );


//----------------------------------------------------------------------------
// Device configuration dialog
//----------------------------------------------------------------------------

BOOL
DeviceConfigureDlg(
    IN HWND hwndOwner,
    IN PBLINK* pLink,
    IN PBENTRY* pEntry,
    IN BOOL fSingleLink,
    IN BOOL fRouter)

    // Popup a dialog to edit the device 'PLink'.  'HwndOwner' is the owner of
    // the dialog.  'PEntry' is the phonebook entry containing the X.25
    // settings or NULL if X.25 settings should not be displayed for PAD and
    // X.25 devices.  'FSingleLink' is true if 'pLink' is a single link
    // entry's link and false if multi-link.
    //
    // Returns true if user pressed OK and succeeded, false if user pressed
    // Cancel or encountered an error.
    //
{
    DWORD dwErr;
    PBDEVICETYPE pbdt;

    pbdt = pLink->pbport.pbdevicetype;
    if (!pEntry && (pbdt == PBDT_Pad || pbdt == PBDT_X25))
    {
        pbdt = PBDT_None;
    }

    // pmay: 245860
    //
    // We need to allow the editing of null modems too.
    //
    if ( pLink->pbport.dwFlags & PBP_F_NullModem )
    {
        pbdt = PBDT_Modem;
    }
    
    switch (pbdt)
    {
        case PBDT_Isdn:
        {
            return IsdnConfigureDlg( hwndOwner, pLink, fSingleLink );
        }

        case PBDT_Modem:
        {
            return ModemConfigureDlg( hwndOwner, pLink, fRouter );
        }

        case PBDT_Pad:
        {
            return X25LogonSettingsDlg( hwndOwner, TRUE, pEntry );
        }

        case PBDT_X25:
        {
            return X25LogonSettingsDlg( hwndOwner, FALSE, pEntry );
        }

        default:
        {
            MsgDlg( hwndOwner, SID_NoConfigure, NULL );
            return FALSE;
        }
    }
}


//----------------------------------------------------------------------------
// ISDN configuration dialog
// Listed alphabetically following stub API and dialog proc
//----------------------------------------------------------------------------

BOOL
IsdnConfigureDlg(
    IN HWND hwndOwner,
    IN PBLINK* pLink,
    IN BOOL fShowProprietary )

    // Popup the ISDN device configuration dialog.  'HwndOwner' is the owner
    // of the dialog.  'PLink' is the link to edit.  'FShowProprietary'
    // indicates the old proprietary Digiboard options should be shown.
    //
    // Returns true if user pressed OK and succeeded, false if user pressed
    // Cancel or encountered an error.
    //
{
    INT_PTR nStatus;
    ICARGS args;

    TRACE( "IsdnConfigureDlg" );

    args.fShowProprietary = fShowProprietary;
    args.pLink = pLink;

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            (fShowProprietary)
                ? MAKEINTRESOURCE( DID_IC_IsdnConfigure )
                : MAKEINTRESOURCE( DID_IC_IsdnConfigureMlink ),
            hwndOwner,
            IcDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
IcDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the ISDN Configure dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "IcDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return IcInit( hwnd, (ICARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwIcHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            return IcCommand(
                hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            IcTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
IcCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    // the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    DWORD dwErr;

    TRACE3( "IcCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_IC_CB_DownLevel:
        {
            if (wNotification == BN_CLICKED)
            {
                BOOL fCheck;
                ICINFO* pInfo;

                pInfo = (ICINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
                ASSERT( pInfo );

                if (pInfo->pArgs->fShowProprietary)
                {
                    fCheck = Button_GetCheck( pInfo->hwndCbProprietary );

                    EnableWindow( pInfo->hwndCbCompression, fCheck );
                    EnableWindow( pInfo->hwndStChannels, fCheck );
                    EnableWindow( pInfo->hwndEbChannels, fCheck );
                    EnableWindow( pInfo->hwndUdChannels, fCheck );
                }
            }
            return TRUE;
        }

        case IDOK:
        {
            ICINFO* pInfo;
            INT iSel;

            TRACE( "OK pressed" );

            pInfo = (ICINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            iSel = ComboBox_GetCurSel( pInfo->hwndLbLineType );
            if (iSel >= 0)
            {
                pInfo->pArgs->pLink->lLineType = iSel;
            }

            pInfo->pArgs->pLink->fFallback =
                Button_GetCheck( pInfo->hwndCbFallback );

            pInfo->pArgs->pLink->fProprietaryIsdn =
                Button_GetCheck( pInfo->hwndCbProprietary );

            if (pInfo->pArgs->fShowProprietary)
            {
                BOOL f;
                UINT unValue;

                pInfo->pArgs->pLink->fCompression =
                    Button_GetCheck( pInfo->hwndCbCompression );

                unValue = GetDlgItemInt(
                    pInfo->hwndDlg, CID_IC_EB_Channels, &f, FALSE );
                if (f && unValue >= 1 && unValue <= 999999999)
                {
                    pInfo->pArgs->pLink->lChannels = unValue;
                }
            }

            EndDialog( pInfo->hwndDlg, TRUE );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( hwnd, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
IcInit(
    IN HWND hwndDlg,
    IN ICARGS* pArgs )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    // 'PArgs' is the caller's stub API arguments.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    ICINFO* pInfo;

    TRACE( "IcInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->hwndLbLineType = GetDlgItem( hwndDlg, CID_IC_LB_LineType );
    ASSERT( pInfo->hwndLbLineType );
    pInfo->hwndCbFallback = GetDlgItem( hwndDlg, CID_IC_CB_Fallback );
    ASSERT( pInfo->hwndCbFallback );
    if (pArgs->fShowProprietary)
    {
        pInfo->hwndCbProprietary = GetDlgItem( hwndDlg, CID_IC_CB_DownLevel );
        ASSERT( pInfo->hwndCbProprietary );
        pInfo->hwndCbCompression = GetDlgItem( hwndDlg, CID_IC_CB_Compression );
        ASSERT( pInfo->hwndCbCompression );
        pInfo->hwndStChannels = GetDlgItem( hwndDlg, CID_IC_ST_Channels );
        ASSERT( pInfo->hwndStChannels );
        pInfo->hwndEbChannels = GetDlgItem( hwndDlg, CID_IC_EB_Channels );
        ASSERT( pInfo->hwndEbChannels );
    }

    // Initialize fields.
    //
    ComboBox_AddItemFromId( g_hinstDll, pInfo->hwndLbLineType,
        SID_IsdnLineType0, NULL );
    ComboBox_AddItemFromId( g_hinstDll, pInfo->hwndLbLineType,
        SID_IsdnLineType1, NULL );
    ComboBox_AddItemFromId( g_hinstDll, pInfo->hwndLbLineType,
        SID_IsdnLineType2, NULL );
    ComboBox_SetCurSel( pInfo->hwndLbLineType, pArgs->pLink->lLineType );

    Button_SetCheck( pInfo->hwndCbFallback, pArgs->pLink->fFallback );

    if (pArgs->fShowProprietary)
    {
        // Send click to triggle window enable update.
        //
        Button_SetCheck( pInfo->hwndCbProprietary,
            !pArgs->pLink->fProprietaryIsdn );
        SendMessage( pInfo->hwndCbProprietary, BM_CLICK, 0, 0 );

        Button_SetCheck( pInfo->hwndCbCompression, pArgs->pLink->fCompression );

        pInfo->hwndUdChannels = CreateUpDownControl(
            WS_CHILD + WS_VISIBLE + WS_BORDER +
                UDS_SETBUDDYINT + UDS_ALIGNRIGHT + UDS_NOTHOUSANDS +
                UDS_ARROWKEYS,
            0, 0, 0, 0, hwndDlg, 100, g_hinstDll, pInfo->hwndEbChannels,
            UD_MAXVAL, 1, 0 );
        ASSERT( pInfo->hwndUdChannels );
        Edit_LimitText( pInfo->hwndEbChannels, 9 );
        SetDlgItemInt( hwndDlg, CID_IC_EB_Channels,
            pArgs->pLink->lChannels, FALSE );
    }

    // Position the dialog centered on the owner window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    return TRUE;
}


VOID
IcTerm(
    IN HWND hwndDlg )

    // Dialog termination.  Releases the context block.  'HwndDlg' is the
    // handle of a dialog.
    //
{
    ICINFO* pInfo;

    TRACE( "IcTerm" );

    pInfo = (ICINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );
    if (pInfo)
    {
        Free( pInfo );
        TRACE( "Context freed" );
    }
}


//----------------------------------------------------------------------------
// Modem configuration dialog
// Listed alphabetically following stub API and dialog proc
//----------------------------------------------------------------------------

BOOL
ModemConfigureDlg(
    IN HWND hwndOwner,
    IN PBLINK* pLink, 
    IN BOOL fRouter)

    // Popup the modem configuration dialog.  'HwndOwner' is the owner of the
    // dialog.  'PLink' is the link to edit.
    //
    // Returns true if user pressed OK and succeeded, false if user pressed
    // Cancel or encountered an error.
    //
{
    INT_PTR nStatus;
    MC_INIT_INFO InitInfo;

    TRACE( "ModemConfigureDlg" );

    ZeroMemory(&InitInfo, sizeof(InitInfo));
    InitInfo.pLink = pLink;
    InitInfo.fRouter = fRouter;

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_MC_ModemConfigure ),
            hwndOwner,
            McDlgProc,
            (LPARAM ) &InitInfo );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
McDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Modem Settings dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "McDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return McInit( hwnd, (MC_INIT_INFO* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwMcHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            return McCommand(
                hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            McTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
McCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    // the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    DWORD dwErr;

    TRACE3( "McCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_MC_CB_FlowControl:
        {
            if (wNotification == BN_CLICKED)
            {
                MCINFO* pInfo = (MCINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
                ASSERT( pInfo );

                if (!Button_GetCheck( pInfo->hwndCbHwFlow ))
                {
                    Button_SetCheck( pInfo->hwndCbEc, FALSE );
                    Button_SetCheck( pInfo->hwndCbEcc, FALSE );
                }
                return TRUE;
            }
            break;
        }

        case CID_MC_CB_ErrorControl:
        {
            if (wNotification == BN_CLICKED)
            {
                MCINFO* pInfo = (MCINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
                ASSERT( pInfo );

                if (Button_GetCheck( pInfo->hwndCbEc ))
                {
                    Button_SetCheck( pInfo->hwndCbHwFlow, TRUE );
                }
                else
                {
                    Button_SetCheck( pInfo->hwndCbEcc, FALSE );
                }
                return TRUE;
            }
            break;
        }

        case CID_MC_CB_Compression:
        {
            if (wNotification == BN_CLICKED)
            {
                MCINFO* pInfo = (MCINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
                ASSERT( pInfo );

                if (Button_GetCheck( pInfo->hwndCbEcc ))
                {
                    Button_SetCheck( pInfo->hwndCbHwFlow, TRUE );
                    Button_SetCheck( pInfo->hwndCbEc, TRUE );
                }
                return TRUE;
            }
            break;
        }

        case IDOK:
        {
            MCINFO* pInfo;
            PBLINK* pLink;
            BOOL    fScriptBefore = FALSE;

            TRACE( "OK pressed" );

            pInfo = (MCINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            pLink = pInfo->pLink;

            pLink->dwBps =
                (DWORD)ComboBox_GetItemData(
                        pInfo->hwndLbBps,
                        (INT)ComboBox_GetCurSel( pInfo->hwndLbBps ) );

            pLink->fHwFlow = Button_GetCheck( pInfo->hwndCbHwFlow );
            pLink->fEc = Button_GetCheck( pInfo->hwndCbEc );
            pLink->fEcc = Button_GetCheck( pInfo->hwndCbEcc );
            pLink->fSpeaker = Button_GetCheck( pInfo->hwndCbEnableSpeaker );
            
            // pmay: 228565
            // Find the selected modem protocol
            //
            if (IsWindowEnabled( pInfo->hwndLbModemProtocols ))
            {
                DTLNODE* pNode;
                INT iSel;

                iSel = ComboBox_GetCurSel( pInfo->hwndLbModemProtocols );
                pNode = (DTLNODE*) 
                    ComboBox_GetItemDataPtr(pInfo->hwndLbModemProtocols, iSel);

                if ( pNode )
                {
                    pLink->dwModemProtocol = (DWORD) DtlGetNodeId( pNode );
                }
            }

            Free0( pLink->pbport.pszScriptBefore );

            // Whistler bug: 308135 Dialup Scripting: Pre-Dial scripts can be
            // selected but are not executed
            //
            SuGetInfo( &pInfo->suinfo,
                &fScriptBefore,
                &pLink->pbport.fScriptBeforeTerminal,
                NULL );

            EndDialog( pInfo->hwndDlg, TRUE );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( hwnd, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
McInit(
    IN HWND hwndDlg,
    IN MC_INIT_INFO* pInitInfo )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    // 'PLink' is the link information to be edited.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr, dwFlags = 0;
    MCINFO* pInfo;
    PBLINK* pLink = pInitInfo->pLink;

    TRACE( "McInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pLink = pInitInfo->pLink;
        pInfo->fRouter = pInitInfo->fRouter;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->hwndEbModemValue = GetDlgItem( hwndDlg, CID_MC_EB_ModemValue );
    ASSERT( pInfo->hwndEbModemValue );
    pInfo->hwndLbBps = GetDlgItem( hwndDlg, CID_MC_LB_MaxBps );
    ASSERT( pInfo->hwndLbBps );
    pInfo->hwndCbHwFlow = GetDlgItem( hwndDlg, CID_MC_CB_FlowControl );
    ASSERT( pInfo->hwndCbHwFlow );
    pInfo->hwndCbEc = GetDlgItem( hwndDlg, CID_MC_CB_ErrorControl );
    ASSERT( pInfo->hwndCbEc );
    pInfo->hwndCbEcc = GetDlgItem( hwndDlg, CID_MC_CB_Compression );
    ASSERT( pInfo->hwndCbEcc );
    pInfo->hwndCbTerminal = GetDlgItem( hwndDlg, CID_MC_CB_Terminal );
    ASSERT( pInfo->hwndCbTerminal );
    pInfo->hwndCbEnableSpeaker = GetDlgItem( hwndDlg, CID_MC_CB_EnableSpeaker );
    ASSERT( pInfo->hwndCbEnableSpeaker );
    pInfo->hwndLbModemProtocols = GetDlgItem( hwndDlg, CID_MC_LB_ModemProtocol );
    ASSERT( pInfo->hwndLbModemProtocols );

    Button_SetCheck( pInfo->hwndCbHwFlow, pLink->fHwFlow );
    Button_SetCheck( pInfo->hwndCbEc, pLink->fEc );
    Button_SetCheck( pInfo->hwndCbEcc, pLink->fEcc );
    Button_SetCheck( pInfo->hwndCbEnableSpeaker, pLink->fSpeaker );

    // Fill in the modem name.
    //
    {
        TCHAR* psz;
        psz = DisplayPszFromDeviceAndPort(
            pLink->pbport.pszDevice, pLink->pbport.pszPort );
        if (psz)
        {
            SetWindowText( pInfo->hwndEbModemValue, psz );
            Free( psz );
        }
    }

    // Fill in the BPS list.
    //
    {
        TCHAR szBps[ MAXLTOTLEN + 1 ];
        DWORD* pdwBps;
        INT i;

        //Add 230400 for whistler bug 307879
        //
        static DWORD adwBps[] =
        {
            1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200, 230400, 460800, 921600,
            0
        };

        for (pdwBps = adwBps; *pdwBps; ++pdwBps)
        {
            LToT( *pdwBps, szBps, 10 );
            i = ComboBox_AddString( pInfo->hwndLbBps, szBps );
            ComboBox_SetItemData( pInfo->hwndLbBps, i, *pdwBps );
            if (*pdwBps == pLink->dwBps)
            {
                ComboBox_SetCurSel( pInfo->hwndLbBps, i );
            }
        }

        if (ComboBox_GetCurSel( pInfo->hwndLbBps ) < 0)
        {
            // Entry lists an unknown BPS rate.  Add it to the end of the
            // list.
            //
            TRACE( "Irregular BPS" );
            LToT( pLink->dwBps, szBps, 10 );
            i = ComboBox_AddString( pInfo->hwndLbBps, szBps );
            ComboBox_SetItemData( pInfo->hwndLbBps, i, pLink->dwBps );
            ComboBox_SetCurSel( pInfo->hwndLbBps, i );
        }
    }
    
    // Fill in the modem protocol list
    //
    {
        PBPORT* pPort = &(pLink->pbport);
        DTLNODE* pNode;
        WCHAR pszBuffer[64];
        INT iItemSel = 0, iItem = 0;

        DbgPrint("pListProtocols=0x%x\n", pPort->pListProtocols);
        
        // Only fill in the modem protocol information 
        // if it was supplied by the link
        //
        if ((pPort->pListProtocols) && 
            (DtlGetNodes (pPort->pListProtocols))
           )
        {
            for (pNode = DtlGetFirstNode( pPort->pListProtocols );
                 pNode;
                 pNode = DtlGetNextNode( pNode ))
            {   
                iItem = ComboBox_AddItem(
                            pInfo->hwndLbModemProtocols,
                            (PWCHAR) DtlGetData(pNode),
                            (VOID*) pNode);
                            
                if (DtlGetNodeId(pNode) == (LONG_PTR)pLink->dwModemProtocol)
                {
                    iItemSel = iItem;
                }
            }

            ComboBox_SetCurSelNotify(
                pInfo->hwndLbModemProtocols,
                iItemSel);
        }

        // Otherwise, disable the protocol selector
        //       
        else
        {
            EnableWindow( pInfo->hwndLbModemProtocols, FALSE );
        }
    }

    // Set up the before-dial scripting controls.
    //
    // Whistler bug 181371 re-enabled pre-dial scripting from Win2K
    //
    // Whistler bug: 308135 Dialup Scripting: Pre-Dial scripts can be selected
    // but are not executed
    //
    // We QFE'd re-enabling this for SP2. According to the Unimodem guys this
    // has never worked and isn't supported. I had test verify that even with
    // the SP2 fix on 2195, although the UI is re-enabled, the scripts fail.
    //
    dwFlags |= SU_F_DisableScripting;

    SuInit( &pInfo->suinfo,
        NULL,
        pInfo->hwndCbTerminal,
        NULL,
        NULL,
        NULL,
        dwFlags);
    pInfo->fSuInfoInitialized = TRUE;

    SuSetInfo( &pInfo->suinfo,
        FALSE,
        pLink->pbport.fScriptBeforeTerminal,
        NULL );

    // Position the dialog centered on the owner window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    // Set focust to Bps since the default focus in the not very useful device
    // name.
    //
    SetFocus( pInfo->hwndLbBps );

    return FALSE;
}

VOID
McTerm(
    IN HWND hwndDlg )

    // Dialog termination.  Releases the context block.  'HwndDlg' is the
    // handle of a dialog.
    //
{
    MCINFO* pInfo;

    TRACE( "McTerm" );

    pInfo = (MCINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );
    if (pInfo)
    {
        if (pInfo->fSuInfoInitialized)
        {
            SuFree( &pInfo->suinfo );
        }

        Free( pInfo );
        TRACE( "Context freed" );
    }
}


//----------------------------------------------------------------------------
// X.25 Logon Settings dialog routines
// Listed alphabetically following entrypoint and dialog proc
//----------------------------------------------------------------------------

BOOL
X25LogonSettingsDlg(
    IN HWND hwndOwner,
    IN BOOL fLocalPad,
    IN OUT PBENTRY* pEntry )

    // Popup a dialog to set X.25 logon settings for phonebook entry 'pEntry'.
    // 'HwndOwner' is the owning window.  'FLocalPad' is set when the selected
    // device is a local X.25 PAD device.
    //
    // Returns true if user pressed OK and succeeded or false on Cancel or
    // error.
    //
{
    INT_PTR nStatus;
    XSARGS args;

    TRACE( "X25LogonSettingsDlg" );

    args.fLocalPad = fLocalPad;
    args.pEntry = pEntry;

    nStatus =
        DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_XS_X25Settings ),
            hwndOwner,
            XsDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
XsDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the X.25 Logon Settings dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "XsDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return XsInit( hwnd, (XSARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwXsHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            XSINFO* pInfo = (XSINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            return XsCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            XsTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
XsCommand(
    IN XSINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "XsCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case IDOK:
        {
            EndDialog( pInfo->hwndDlg, XsSave( pInfo ) );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


VOID
XsFillPadsList(
    IN XSINFO* pInfo )

    // Fill PADs list and selects the PAD from user's entry.  'PInfo' is the
    // dialog context.
    //
{
    DWORD dwErr;
    DTLNODE* pNode;
    PBENTRY* pEntry;
    INT nIndex;

    TRACE( "XsFillPadsList" );

    // Add the "(none)" item.
    //
    ComboBox_AddItemFromId(
        g_hinstDll, pInfo->hwndLbNetworks, SID_NoneSelected, NULL );
    ComboBox_SetCurSel( pInfo->hwndLbNetworks, 0 );

    if (!pInfo->pArgs->fLocalPad)
    {
        DTLLIST* pListPads;

        dwErr = LoadPadsList( &pListPads );
        if (dwErr != 0)
        {
            ErrorDlg( pInfo->hwndDlg, SID_OP_LoadX25Info, dwErr, NULL );
            return;
        }

        pEntry = pInfo->pArgs->pEntry;

        for (pNode = DtlGetFirstNode( pListPads );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            TCHAR* psz;

            psz = (TCHAR* )DtlGetData( pNode );
            nIndex = ComboBox_AddString( pInfo->hwndLbNetworks, psz );

            if (pEntry->pszX25Network
                && lstrcmp( psz, pEntry->pszX25Network ) == 0)
            {
                ComboBox_SetCurSel( pInfo->hwndLbNetworks, nIndex );
            }
        }

        DtlDestroyList( pListPads, DestroyPszNode );

        if (pEntry->pszX25Network
            && ComboBox_GetCurSel( pInfo->hwndLbNetworks ) == 0)
        {
            // The PAD from the phonebook entry is not in the PAD list.  Add
            // it and select it.
            //
            nIndex = ComboBox_AddString(
                pInfo->hwndLbNetworks, pEntry->pszX25Network );
            ComboBox_SetCurSel( pInfo->hwndLbNetworks, nIndex );
        }
    }

    ComboBox_AutoSizeDroppedWidth( pInfo->hwndLbNetworks );
}


BOOL
XsInit(
    IN HWND hwndDlg,
    IN XSARGS* pArgs )

    // Called on WM_INITDIALOG.  'HwndDlg' is the handle of the phonebook
    // dialog window.  'PArgs' is caller's arguments as passed to the stub
    // API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    XSINFO* pInfo;
    PBENTRY* pEntry;

    TRACE( "XsInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->hwndLbNetworks = GetDlgItem( hwndDlg, CID_XS_LB_Networks );
    ASSERT( pInfo->hwndLbNetworks );
    pInfo->hwndEbAddress = GetDlgItem( hwndDlg, CID_XS_EB_Address );
    ASSERT( pInfo->hwndEbAddress );
    pInfo->hwndEbUserData = GetDlgItem( hwndDlg, CID_XS_EB_UserData );
    ASSERT( pInfo->hwndEbUserData );
    pInfo->hwndEbFacilities = GetDlgItem( hwndDlg, CID_XS_EB_Facilities );
    ASSERT( pInfo->hwndEbFacilities );

    XsFillPadsList( pInfo );

    pEntry = pArgs->pEntry;

    Edit_LimitText( pInfo->hwndEbAddress, RAS_MaxX25Address );
    if (pEntry->pszX25Address)
    {
        SetWindowText( pInfo->hwndEbAddress, pEntry->pszX25Address );
    }

    Edit_LimitText( pInfo->hwndEbUserData, RAS_MaxUserData );
    if (pEntry->pszX25UserData)
    {
        SetWindowText( pInfo->hwndEbUserData, pEntry->pszX25UserData );
    }

    Edit_LimitText( pInfo->hwndEbFacilities, RAS_MaxFacilities );
    if (pEntry->pszX25Facilities)
    {
        SetWindowText( pInfo->hwndEbFacilities, pEntry->pszX25Facilities );
    }

    // Center dialog on the owner window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    if (pArgs->fLocalPad)
    {
        // No point in setting focus to "X.25 Network" on local PAD, so set to
        // X.25 Address field instead.
        //
        SetFocus( pInfo->hwndEbAddress );
        Edit_SetSel( pInfo->hwndEbAddress, 0, -1 );
        return FALSE;
    }

    return TRUE;
}


BOOL
XsSave(
    IN XSINFO* pInfo )

    // Load the contents of the dialog into caller's stub API output argument.
    // 'PInfo' is the dialog context.
    //
    // Returns true if succesful, false otherwise.
    //
{

    INT iPadSelection;
    PBENTRY* pEntry;

    TRACE( "XsSave" );

    pEntry = pInfo->pArgs->pEntry;

    iPadSelection = ComboBox_GetCurSel( pInfo->hwndLbNetworks );
    Free0( pEntry->pszX25Network );
    if (iPadSelection > 0)
    {
        pEntry->pszX25Network = GetText( pInfo->hwndLbNetworks );
    }
    else
    {
        pEntry->pszX25Network = NULL;
    }

    Free0( pEntry->pszX25Address );
    pEntry->pszX25Address = GetText( pInfo->hwndEbAddress );

    Free0( pEntry->pszX25UserData );
    pEntry->pszX25UserData = GetText( pInfo->hwndEbUserData );

    Free0( pEntry->pszX25Facilities );
    pEntry->pszX25Facilities = GetText( pInfo->hwndEbFacilities );

    pEntry->fDirty = TRUE;

    if (!pEntry->pszX25Address
        || !pEntry->pszX25UserData
        || !pEntry->pszX25Facilities)
    {
        Free0( pEntry->pszX25Address );
        Free0( pEntry->pszX25UserData );
        ErrorDlg( pInfo->hwndDlg, SID_OP_RetrievingData,
            ERROR_NOT_ENOUGH_MEMORY, NULL );
        return FALSE;
    }

    return TRUE;
}


VOID
XsTerm(
    IN HWND hwndDlg )

    // Dialog termination.  Releases the context block.  'HwndDlg' is the
    // handle of a dialog.
    //
{
    XSINFO* pInfo;

    TRACE( "XsTerm" );

    pInfo = (XSINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );
    if (pInfo)
    {
        Free( pInfo );
        TRACE( "Context freed" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\autodial.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// autodial.c
// Remote Access Common Dialog APIs
// Autodial APIs, currently private
//
// 11/19/95 Steve Cobb


#include "rasdlgp.h"
#include "shlobjp.h"


//-----------------------------------------------------------------------------
// Local datatypes
//-----------------------------------------------------------------------------

// Auto-dial query dialog argument block.
//
typedef struct
_AQARGS
{
    WCHAR* pszDestination;
    WCHAR* pszEntry;
    WCHAR* pszNewEntry;  // points a buffer at least [RAS_MaxEntryName + 1]
    DWORD  dwTimeout;
    UINT_PTR nIdTimer;   //add for bug 336524       gangz
}
AQARGS;


// Auto-dial query dialog context block.
//
typedef struct
_AQINFO
{
    // RAS API arguments.
    //
    AQARGS* pArgs;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndStText;
    HWND hwndAqPbNo;
    HWND hwndAqPbSettings;
    HWND hwndAqLvConnections;
}
AQINFO;


//-----------------------------------------------------------------------------
// External entry points
//-----------------------------------------------------------------------------

DWORD APIENTRY
RasAutodialQueryDlgA(
    IN HWND hwndOwner,
    IN LPSTR lpszDestination,
    IN LPSTR lpszEntry,
    IN DWORD dwTimeout,
    OUT LPSTR lpszEntryUserSelected);

BOOL APIENTRY
RasAutodialDisableDlgA(
    IN HWND hwndOwner );

DWORD
APIENTRY
RasUserPrefsDlgAutodial (
    HWND hwndParent);

//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

INT_PTR CALLBACK
AqDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
AqCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

BOOL
AqInit(
    IN HWND hwndDlg,
    IN AQARGS* pArgs );
    
LVXDRAWINFO*
AqLvCallback(
    IN HWND hwndLv,
    IN DWORD dwItem );
    
BOOL
AqNotify(
    HWND hwnd, 
    int idCtrl, 
    LPNMHDR pnmh);
    
VOID
AqTerm(
    IN HWND hwndDlg );

//Add the timer function for bug 336524
//
BOOL
AqTimer(
    IN HWND hwndDlg );

INT_PTR CALLBACK
DqDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
DqCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

BOOL
DqInit(
    IN HWND hwndDlg );


//-----------------------------------------------------------------------------
// Auto-Dial Query dialog Listed alphabetically following API and dialog proc
//-----------------------------------------------------------------------------

DWORD APIENTRY
RasAutodialQueryDlgW(
    IN HWND  hwndOwner,
    IN LPWSTR lpszDestination,
    IN LPWSTR lpszEntry,
    IN DWORD dwTimeout,
    OUT PWCHAR lpszNewEntry)

    // Private external entry point to popup the Auto-Dial Query, i.e. the
    // "Cannot reach 'pszDestination'.  Do you want to dial?" dialog.
    // 'HwndOwner' is the owning window or NULL if none.  'PszDestination' is
    // the network address that triggered the auto-dial for display.
    // 'DwTimeout' is the initial seconds on the countdown timer that ends the
    // dialog with a "do not dial" selection on timeout, or 0 for none.
    //
    // Returns true if user chooses to dial, false otherwise.
    //
{
    INT_PTR nStatus;
    AQARGS args;
    DWORD dwErr = NO_ERROR;

    TRACE1( "RasAutodialQueryDlgW(t=%d)", dwTimeout );

    ZeroMemory(&args, sizeof(args));
    args.dwTimeout = dwTimeout;
    args.pszDestination = StrDup( lpszDestination );
    args.pszNewEntry = lpszNewEntry;
    if (lpszEntry)
    {
        args.pszEntry = StrDup( lpszEntry );
    }        

    if (args.pszDestination == NULL)
    {
        Free0(args.pszEntry);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    nStatus =
        DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_AQ_AutoDialQuery ),
            hwndOwner,
            AqDlgProc,
            (LPARAM )&args );

    Free0( args.pszDestination );
    Free0( args.pszEntry );

    if (nStatus == -1)
    {
        dwErr = GetLastError();
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, dwErr, NULL );
        nStatus = FALSE;
    }
    else
    {
        dwErr = (DWORD)nStatus;
    }

    return dwErr;
}

DWORD APIENTRY
RasAutodialQueryDlgA(
    IN HWND  hwndOwner,
    IN LPSTR lpszDestination,
    IN LPSTR lpszEntry,
    IN DWORD dwTimeout,
    OUT LPSTR lpszEntryUserSelected)

    // Private external entry point to popup the Auto-Dial Query, i.e. the
    // "Cannot reach 'pszDestination'.  Do you want to dial?" dialog.
    // 'HwndOwner' is the owning window or NULL if none.  'PszDestination' is
    // the network address that triggered the auto-dial for display.
    // 'DwTimeout' is the initial seconds on the countdown timer that ends the
    // dialog with a "do not dial" selection on timeout, or 0 for none.
    //
    // Returns true if user chooses to dial, false otherwise.
    //
{
    WCHAR* pszDestinationW = NULL, *pszEntryW = NULL;
    WCHAR pszNewEntryW[RAS_MaxEntryName + 1];
    BOOL dwErr = ERROR_NOT_ENOUGH_MEMORY;

    pszNewEntryW[0] = L'\0';
    pszDestinationW = StrDupWFromAUsingAnsiEncoding( lpszDestination );
    if ( lpszEntry )
    {
        pszEntryW = StrDupWFromAUsingAnsiEncoding ( lpszEntry );
    }        

    if (NULL != pszDestinationW)
    {
        dwErr = RasAutodialQueryDlgW(
                    hwndOwner, 
                    pszDestinationW, 
                    pszEntryW, 
                    dwTimeout, 
                    pszNewEntryW);
                    
        Free( pszDestinationW );
    }    

    Free0( pszEntryW );

    StrCpyAFromWUsingAnsiEncoding(
        lpszEntryUserSelected,
        pszNewEntryW,
        sizeof(pszNewEntryW) / sizeof(WCHAR));
    
    return dwErr;
}

INT_PTR CALLBACK
AqDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Auto-Dial Query dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
    if (ListView_OwnerHandler(
            hwnd, unMsg, wparam, lparam, AqLvCallback ))
    {
        return TRUE;
    }

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return AqInit( hwnd, (AQARGS* )lparam );
        }

        case WM_COMMAND:
        {
            return AqCommand(
               hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_NOTIFY:
        {
            return AqNotify(hwnd, (int)wparam, (LPNMHDR) lparam);
        }

        case WM_TIMER:
        {
            return AqTimer( hwnd );
        }

        case WM_DESTROY:
        {
            AqTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
AqCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    // the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    DWORD dwErr = NO_ERROR;
    INT iSelected;
    AQINFO* pInfo = NULL;

    TRACE3( "AqCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    pInfo = (AQINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
    
    switch (wId)
    {
        case CID_AQ_PB_Settings:
        {
            if (pInfo)
            {

                //For whistler bug 357164       gangz
                // Save the "disable current session" checkbox, 
                //
                {
                     DWORD dwFlag = (DWORD )IsDlgButtonChecked(
                                                   hwnd, 
                                                   CID_AQ_CB_DisableThisSession );

                    dwErr = g_pRasSetAutodialParam( 
                                RASADP_LoginSessionDisable,
                                &dwFlag, 
                                sizeof(dwFlag) );
                }
            
                //For whistler bug 336524
                //Kill the timer
                ASSERT( pInfo->pArgs );
                if( pInfo->pArgs->nIdTimer )
                {
                    KillTimer( hwnd, 
                           pInfo->pArgs->nIdTimer );
                           
                    pInfo->pArgs->nIdTimer = 0;
                }
                
                RasUserPrefsDlgAutodial(pInfo->hwndDlg);

             //For whistler bug 357164       gangz
             // Initialize the "disable current session" checkbox
             //
            {
                DWORD dwFlag = FALSE, dwErrTmp = NO_ERROR;
                DWORD cb = sizeof(dwFlag);
            
                dwErrTmp = g_pRasGetAutodialParam(
                                        RASADP_LoginSessionDisable, 
                                        &dwFlag, 
                                        &cb );

                // For whistler 522872
                if( NO_ERROR != dwErrTmp )
                {
                    dwFlag = FALSE;
                }
                
                CheckDlgButton( 
                    hwnd, 
                    CID_AQ_CB_DisableThisSession, 
                    (BOOL )dwFlag );
                
             }
                
            }                
            
            return TRUE;
        }

        case CID_AQ_PB_Dial:
        case CID_AQ_PB_DoNotDial:
        {
            TRACE( "(No)Dial pressed" );

            if (wId == CID_AQ_PB_Dial && pInfo)
            {
                iSelected = 
                    ListView_GetSelectionMark(pInfo->hwndAqLvConnections);

                // If user does not select a connection, then default to the 
                // first one.  Alternatively, an error popup could be 
                // raised here but that is annoying.
                //
                if (iSelected == -1)
                {
                    iSelected = 0;                    
                }

                // Get the name of the selected connection
                //
                if (pInfo)
                {
                    ListView_GetItemText(
                        pInfo->hwndAqLvConnections,
                        iSelected,
                        0,
                        pInfo->pArgs->pszNewEntry,
                        RAS_MaxEntryName + 1);
                }                        
            }

            //For whistler bug 357164       gangz
            // Save the "disable current session" checkbox, 
            //
            {
                 DWORD dwFlag = (DWORD )IsDlgButtonChecked(
                                                   hwnd, 
                                                   CID_AQ_CB_DisableThisSession );

                dwErr = g_pRasSetAutodialParam( 
                            RASADP_LoginSessionDisable,
                            &dwFlag, 
                            sizeof(dwFlag) );
            }
        
            EndDialog( hwnd, (wId == CID_AQ_PB_Dial) ? NO_ERROR : ERROR_CANCELLED );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( hwnd, ERROR_CANCELLED );
            return TRUE;
        }
    }

    return FALSE;
}

// Fills the list view of connections and selects the appropriate one to 
// dial
//
DWORD
AqFillListView(
    IN AQINFO* pInfo)
{
    DWORD dwErr = NO_ERROR, cb, cEntries = 0, i;
    RASENTRYNAME ren, *pRasEntryNames = NULL;
    LVITEM lvItem;
    INT iIndex, iSelect = 0;

    do
    {
        // Enumerate entries across all phonebooks. 
        //
        cb = ren.dwSize = sizeof(RASENTRYNAME);
        ASSERT( g_pRasEnumEntries );
        dwErr = g_pRasEnumEntries(NULL, NULL, &ren, &cb, &cEntries);

        // If there are no entries, then we return an error to signal that
        // there is no point to the dialog.
        //
        if ((SUCCESS == dwErr) && (0 == cEntries))
        {
            dwErr = ERROR_CANCELLED;
            break;
        }

        // Allocate a buffer to receive the connections
        //
        if(     (   (ERROR_BUFFER_TOO_SMALL == dwErr)
                ||   (SUCCESS == dwErr))
            &&  (cb >= sizeof(RASENTRYNAME)))
        {
            pRasEntryNames = (RASENTRYNAME *) Malloc(cb);
            if(NULL == pRasEntryNames)
            {
                // Nothing else can be done in this case
                //
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            pRasEntryNames->dwSize = sizeof(RASENTRYNAME);
            dwErr = g_pRasEnumEntries(NULL, NULL, pRasEntryNames, &cb, &cEntries);
            if ( NO_ERROR != dwErr )
            {
                break;
            }
        }
        else
        {
            break;
        }

        // Initialize the list view
        //
        if (ListView_GetItemCount( pInfo->hwndAqLvConnections ) == 0)
        {
            // Add a single column exactly wide enough to fully display
            // the widest member of the list.
            //
            LV_COLUMN col;

            ZeroMemory( &col, sizeof(col) );
            col.mask = LVCF_FMT;
            col.fmt = LVCFMT_LEFT;
            ListView_InsertColumn( pInfo->hwndAqLvConnections, 0, &col );
            ListView_SetColumnWidth( 
                pInfo->hwndAqLvConnections, 
                0, 
                LVSCW_AUTOSIZE_USEHEADER );
        }
        else
        {
            ListView_DeleteAllItems( pInfo->hwndAqLvConnections );
        }

        // Fill the list view
        //
        for (i = 0; i < cEntries; i++)
        {
            ZeroMemory(&lvItem, sizeof(lvItem));
            lvItem.mask = LVIF_TEXT;
            lvItem.pszText = pRasEntryNames[i].szEntryName;
            lvItem.iItem = i;
            iIndex = ListView_InsertItem( pInfo->hwndAqLvConnections, &lvItem );
            if ((pInfo->pArgs->pszEntry) &&
                (wcsncmp(
                    pInfo->pArgs->pszEntry, 
                    pRasEntryNames[i].szEntryName,
                    sizeof(pRasEntryNames[i].szEntryName) / sizeof(WCHAR)) == 0))
            {
                iSelect = (iIndex != -1) ? iIndex : 0;
            }
        }
    }while (FALSE);

    // Select the appropriate connection
    //
    ListView_SetItemState( 
        pInfo->hwndAqLvConnections, 
        iSelect, 
        LVIS_SELECTED | LVIS_FOCUSED, 
        LVIS_SELECTED | LVIS_FOCUSED);

    // Cleanup
    {
        Free0(pRasEntryNames);
    }

    return dwErr;
}

BOOL
AqInit(
    IN HWND hwndDlg,
    IN AQARGS* pArgs )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    // 'PArgs' is caller's arguments to the RAS API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    AQINFO* pInfo;

    TRACE( "AqInit" );

    // Load the Rasapi32Dll so that we can enumerate connections
    // and set autodial properties
    //
    dwErr = LoadRasapi32Dll();
    if (dwErr != NO_ERROR)
    {
        ErrorDlg( hwndDlg, SID_OP_LoadDlg, dwErr, NULL );
        EndDialog( hwndDlg, FALSE);
        return TRUE;
    }
    
    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "AQ: Context set" );
    }

    pInfo->hwndStText = GetDlgItem( hwndDlg, CID_AQ_ST_Text );
    ASSERT( pInfo->hwndStText );
    pInfo->hwndAqPbNo = GetDlgItem( hwndDlg, CID_AQ_PB_DoNotDial );
    ASSERT( pInfo->hwndAqPbNo );
    pInfo->hwndAqPbSettings = GetDlgItem( hwndDlg, CID_AQ_PB_Settings );
    ASSERT( pInfo->hwndAqPbSettings );
    pInfo->hwndAqLvConnections = GetDlgItem( hwndDlg, CID_AQ_LV_Connections );
    ASSERT( pInfo->hwndAqLvConnections );
    
    // Fill in the listview of connections
    //
    dwErr = AqFillListView(pInfo);
    if (dwErr != NO_ERROR)
    {
        EndDialog(hwndDlg, dwErr);
        return TRUE;
    }

    // Fill in the argument in the explanatory text.
    //
    {
        TCHAR* pszTextFormat;
        TCHAR* pszText;
        TCHAR* apszArgs[ 1 ];

        pszTextFormat = PszFromId( g_hinstDll, SID_AQ_Text );
        if (pszTextFormat)
        {
            apszArgs[ 0 ] = pArgs->pszDestination;
            pszText = NULL;

            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING
                    | FORMAT_MESSAGE_ALLOCATE_BUFFER
                    | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                pszTextFormat, 0, 0, (LPTSTR )&pszText, 1,
                (va_list* )apszArgs );

            Free( pszTextFormat );

            if (pszText)
            {
                SetWindowText( pInfo->hwndStText, pszText );
                LocalFree( pszText );
            }
        }
    }

    // Display the finished window above all other windows.  The window
    // position is set to "topmost" then immediately set to "not topmost"
    // because we want it on top but not always-on-top.
    //
    SetWindowPos(
        hwndDlg, HWND_TOPMOST, 0, 0, 0, 0,
        SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE );

    CenterWindow( hwndDlg, GetParent( hwndDlg ) );
    ShowWindow( hwndDlg, SW_SHOW );

    SetWindowPos(
        hwndDlg, HWND_NOTOPMOST, 0, 0, 0, 0,
        SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE );

    // for whistler bug 391195
    // Default is to connect, so set the focus on list box and default button 
    // to connect
    //
    SetFocus( GetDlgItem( hwndDlg, CID_AQ_LV_Connections) ); //CID_AQ_PB_DoNotDial ) );


    //For whistler bug 357164       gangz
    // Initialize the "disable current session" checkbox
    //
    {
        DWORD dwFlag = FALSE, dwErrTmp = NO_ERROR;
        DWORD cb = sizeof(dwFlag);
        
        dwErrTmp = g_pRasGetAutodialParam(
                                        RASADP_LoginSessionDisable, 
                                        &dwFlag, 
                                        &cb );
        // For whistler 522872
        
        if( NO_ERROR != dwErrTmp)
        {
            dwFlag = FALSE;
        }
        
        CheckDlgButton( 
            hwndDlg, 
            CID_AQ_CB_DisableThisSession, 
            (BOOL )dwFlag );
    }
    
    //Set up the timer for bug 336524   gangz
    //
    pInfo->pArgs->nIdTimer = 1;
    SetTimer( hwndDlg,
              pInfo->pArgs->nIdTimer,              
              (pInfo->pArgs->dwTimeout) *1000,//in milliseconds
              NULL);
              
    return FALSE;
}

LVXDRAWINFO*
AqLvCallback(
    IN HWND hwndLv,
    IN DWORD dwItem )

    // Enhanced list view callback to report drawing information.  'HwndLv' is
    // the handle of the list view control.  'DwItem' is the index of the item
    // being drawn.
    //
    // Returns the address of the draw information.
    //
{
    // Use "full row select" and other recommended options.
    //
    // Fields are 'nCols', 'dxIndent', 'dwFlags', 'adwFlags[]'.
    //
    static LVXDRAWINFO info = { 1, 0, 0, { 0, 0 } };

    return &info;
}

BOOL
AqNotify(
    HWND hwnd, 
    int idCtrl, 
    LPNMHDR pnmh)    
{
    AQINFO* pInfo = (AQINFO* )GetWindowLongPtr( hwnd, DWLP_USER );

    ASSERT(pInfo);
    ASSERT(pnmh);

    if(!pnmh || !pInfo)
    {
        return FALSE;
    }
     
    switch ( pnmh->code)
    {
        case LVN_ITEMACTIVATE:
        case LVN_KEYDOWN:
        case LVN_ITEMCHANGED:
        case LVN_ODSTATECHANGED:
        case LVN_COLUMNCLICK:
        case LVN_HOTTRACK:

        //re-set up the timer   
        //

        ASSERT( pInfo->pArgs );
              
        if ( pInfo->pArgs->nIdTimer )
        {
           KillTimer( hwnd,
                     pInfo->pArgs->nIdTimer);            
         }
         break;

         default:  
            break;
     }

    return FALSE;
}

VOID
AqTerm(
    IN HWND hwndDlg )

    // Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    //
{
    AQINFO* pInfo = (AQINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );

    TRACE( "AqTerm" );

    if (pInfo)
    {
        ASSERT(pInfo->pArgs);

        if( pInfo->pArgs->nIdTimer )
        {
            KillTimer( hwndDlg, 
                       pInfo->pArgs->nIdTimer );
         }
        
        Free( pInfo );
    }
}

//Add the timer function for bug 336524
//
BOOL
AqTimer(
    IN HWND hwndDlg )
{
    AQINFO* pInfo = (AQINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );

    TRACE( "AqTimer" );

    pInfo->pArgs->nIdTimer = 0;
    EndDialog( hwndDlg, ERROR_CANCELLED );

    return TRUE;
}

//----------------------------------------------------------------------------
// Auto-Dial Disable dialog
// Listed alphabetically following API and dialog proc
//----------------------------------------------------------------------------

BOOL APIENTRY
RasAutodialDisableDlgW(
    IN HWND hwndOwner )

    // Private external entry point to popup the Auto-Dial Disable Query, i.e.
    // the "Attempt failed Do you want to disable auto-dial for this
    // location?" dialog.  'HwndOwner' is the owning window or NULL if none.
    //
    // Returns true if user chose to disable, false otherwise.
    //
{
    INT_PTR nStatus;

    TRACE( "RasAutodialDisableDlgA" );

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_DQ_DisableAutoDialQuery ),
            hwndOwner,
            DqDlgProc,
            (LPARAM )0 );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}

BOOL APIENTRY
RasAutodialDisableDlgA(
    IN HWND hwndOwner )
{
    return RasAutodialDisableDlgW( hwndOwner );
}

INT_PTR CALLBACK
DqDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Auto-Dial Query dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "AqDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return DqInit( hwnd );
        }

        case WM_COMMAND:
        {
            return DqCommand(
               hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}


BOOL
DqCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    // the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    DWORD dwErr;

    TRACE3( "DqCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case IDOK:
        {
            DWORD dwId;
            HLINEAPP hlineapp;

            TRACE( "Yes pressed" );

            // User chose to permanently disable auto-dial for the current
            // TAPI location.
            //
            dwErr = LoadRasapi32Dll();
            if (dwErr == 0)
            {
                hlineapp = 0;
                dwId = GetCurrentLocation( g_hinstDll, &hlineapp );
                ASSERT( g_pRasSetAutodialEnable );
                TRACE1( "RasSetAutodialEnable(%d)", dwId );
                dwErr = g_pRasSetAutodialEnable( dwId, FALSE );
                TRACE1( "RasSetAutodialEnable=%d", dwErr );
                TapiShutdown( hlineapp );
            }

            if (dwErr != 0)
            {
                ErrorDlg( hwnd, SID_OP_SetADialInfo, dwErr, NULL );
            }

            EndDialog( hwnd, TRUE );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "No or cancel pressed" );
            EndDialog( hwnd, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
DqInit(
    IN HWND hwndDlg )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    TRACE( "DqInit" );

    // Display the finished window above all other windows.  The window
    // position is set to "topmost" then immediately set to "not topmost"
    // because we want it on top but not always-on-top.
    //
    SetWindowPos(
        hwndDlg, HWND_TOPMOST, 0, 0, 0, 0,
        SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE );

    CenterWindow( hwndDlg, GetParent( hwndDlg ) );
    ShowWindow( hwndDlg, SW_SHOW );

    SetWindowPos(
        hwndDlg, HWND_NOTOPMOST, 0, 0, 0, 0,
        SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE );

    // Default is to not disable auto-dial.
    //
    SetFocus( GetDlgItem( hwndDlg, IDCANCEL ) );

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasadmin\api\userapi.c ===
/******************************************************************\
*                     Microsoft Windows NT                         *
*               Copyright(c) Microsoft Corp., 1992                 *
\******************************************************************/

/*++

Module Name:

    USERAPI.C


Description:

    This module contains code for all the RASADMIN APIs
    that require RAS information from the UAS.

//     RasAdminUserEnum
     RasAdminGetUserAccountServer
     RasAdminUserSetInfo
     RasAdminUserGetInfo
     RasAdminGetErrorString

Author:

    Janakiram Cherala (RamC)    July 6,1992

Revision History:

    Feb  1,1996    RamC    Changes to export these APIs to 3rd parties. These APIs
                           are now part of RASSAPI.DLL. Added a couple new routines
                           and renamed some. RasAdminUserEnum is not exported any more.
    June 8,1993    RamC    Changes to RasAdminUserEnum to speed up user enumeration.
    May 13,1993    AndyHe  Modified to coexist with other apps using user parms

    Mar 16,1993    RamC    Change to speed up User enumeration. Now, when
                           RasAdminUserEnum is invoked, only the user name
                           information is returned. RasAdminUserGetInfo should
                           be invoked to get the Ras permissions and Callback
                           information.

    Aug 25,1992    RamC    Code review changes:

                           o changed all lpbBuffers to actual structure
                             pointers.
                           o changed all LPTSTR to LPWSTR
                           o Added a new function RasPrivilegeAndCallBackNumber
    July 6,1992    RamC    Begun porting from RAS 1.0 (Original version
                           written by Narendra Gidwani - nareng)

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "rassapi.h"

//
// Deprecated API in .Net #526819
//
DWORD APIENTRY
RasAdminUserSetInfo(
    IN const WCHAR        * lpszServer,
    IN const WCHAR        * lpszUser,
    IN const PRAS_USER_0    pRasUser0
    )
/*++

Routine Description:

    This routine allows the admin to change the RAS permission for a
    user.  If the user parms field of a user is being used by another
    application, it will be destroyed.

Arguments:

    lpszServer      name of the server which has the user database,
                    eg., "\\\\UASSRVR" (the server must be one on which
                    the UAS can be changed i.e., the name returned by
                    RasAdminGetUserAccountServer).

    lpszUser        user account name to retrieve information for,
                    e.g. "USER".

    pRasUser0       pointer to a buffer in which user information is
                    provided.  The buffer should contain a filled
                    RAS_USER_0 structure.


Return Value:

    ERROR_SUCCESS on successful return.

    One of the following non-zero error codes indicating failure:

        return codes from NetUserGetInfo or NetUserSetInfo

        ERROR_INVALID_DATA indicates that the data in pRasUser0 is bad.
--*/
{
    DbgPrint("Unsupported Interface - RasAdminUserSetInfo");

    return ERROR_CALL_NOT_IMPLEMENTED;
}

//
// Deprecated API in .Net #526819
//
DWORD APIENTRY
RasAdminUserGetInfo(
    IN const WCHAR   * lpszServer,
    IN const WCHAR   * lpszUser,
    OUT PRAS_USER_0    pRasUser0
    )
/*++

Routine Description:

    This routine retrieves RAS and other UAS information for a user
    in the domain the specified server belongs to. It loads the caller's
    pRasUser0 with a RAS_USER_0 structure.

Arguments:

    lpszServer      name of the server which has the user database,
                    eg., "\\\\UASSRVR" (the server must be one on which
                    the UAS can be changed i.e., the name returned by
                    RasAdminGetUserAccountServer).

    lpszUser        user account name to retrieve information for,
                    e.g. "USER".

    pRasUser0       pointer to a buffer in which user information is
                    returned.  The returned info is a RAS_USER_0 structure.

Return Value:

    ERROR_SUCCESS on successful return.

    One of the following non-zero error codes indicating failure:

        return codes from NetUserGetInfo or NetUserSetInfo

        ERROR_INVALID_DATA indicates that user parms is invalid.
--*/
{
    DbgPrint("Unsupported Interface - RasAdminUserGetInfo");

    if (pRasUser0)
    {
        ZeroMemory(pRasUser0, sizeof(RAS_USER_0));
    }

    return ERROR_CALL_NOT_IMPLEMENTED;
}

//
// Deprecated API in .Net #526819
//
DWORD APIENTRY
RasAdminGetUserAccountServer(
    IN const WCHAR * lpszDomain,
    IN const WCHAR * lpszServer,
    OUT LPWSTR lpszUasServer
    )
/*++

Routine Description:

    This routine finds the server with the master UAS (the PDC) from
    either a domain name or a server name.  Either the domain or the
    server (but not both) may be NULL.

Arguments:

    lpszDomain      Domain name or NULL if none.

    lpszServer      name of the server which has the user database.

    lpszUasServer   Caller's buffer for the returned UAS server name.
                    The buffer should be atleast UNCLEN + 1 characters
                    long.

Return Value:

    ERROR_SUCCESS on successful return.
    ERROR_INVALID_PARAMETER if both lpszDomain and lpszServer are NULL.

    one of the following non-zero error codes on failure:

        return codes from NetGetDCName

--*/
{
    DbgPrint("Unsupported Interface - RasAdminGetUserAccountServer");

    if (lpszUasServer)
    {
        lpszUasServer[0] = L'\0';
    }

    return ERROR_CALL_NOT_IMPLEMENTED;
}

DWORD APIENTRY
RasAdminSetUserParms(
    IN OUT   WCHAR    * lpszParms,
    IN DWORD          cchNewParms,
    IN PRAS_USER_0    pRasUser0
    )
{
    DbgPrint("Unsupported Interface - RasAdminSetUserParms");

    if (lpszParms)
    {
        lpszParms[0] = L'\0';
    }

    return ERROR_CALL_NOT_IMPLEMENTED;
}

DWORD APIENTRY
RasAdminGetUserParms(
    IN     WCHAR          * lpszParms,
    IN OUT PRAS_USER_0      pRasUser0
    )
{
    DbgPrint("Unsupported Interface - RasAdminGetUserParms");

    if (pRasUser0)
    {
        ZeroMemory(pRasUser0, sizeof(RAS_USER_0));
    }

    return ERROR_CALL_NOT_IMPLEMENTED;
}


DWORD APIENTRY
RasAdminGetErrorString(
    IN  UINT    ResourceId,
    OUT WCHAR * lpszString,
    IN  DWORD   InBufSize )
{
    DbgPrint("Unsupported Interface - RasAdminGetErrorString");

    if (lpszString)
    {
        lpszString[0] = L'\0';
    }

    return ERROR_CALL_NOT_IMPLEMENTED;
}

BOOL
RasAdminDLLInit(
    IN HINSTANCE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
    )
{
    DbgPrint("Unsupported Interface - RasAdminDLLInit");

    return FALSE;
}

USHORT
RasAdminCompressPhoneNumber(
   IN  LPWSTR UncompNumber,
   OUT LPWSTR CompNumber
   )
{
    DbgPrint("Unsupported Interface - RasAdminCompressPhoneNumber");

    return ERROR_CALL_NOT_IMPLEMENTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\alternat.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// alternat.c
// Remote Access Common Dialog APIs
// Alternate phone number dialogs
//
// 11/06/97 Steve Cobb


#include "rasdlgp.h"


//----------------------------------------------------------------------------
// Help maps
//----------------------------------------------------------------------------

static DWORD g_adwAnHelp[] =
{
    CID_AN_ST_Explain,       HID_AN_ST_Explain,
    CID_AN_ST_Numbers,       HID_AN_LV_Numbers,
    CID_AN_LV_Numbers,       HID_AN_LV_Numbers,
    CID_AN_PB_Up,            HID_AN_PB_Up,
    CID_AN_PB_Down,          HID_AN_PB_Down,
    CID_AN_PB_Add,           HID_AN_PB_Add,
    CID_AN_PB_Edit,          HID_AN_PB_Edit,
    CID_AN_PB_Delete,        HID_AN_PB_Delete,
    CID_AN_CB_MoveToTop,     HID_AN_CB_MoveToTop,
    CID_AN_CB_TryNextOnFail, HID_AN_CB_TryNextOnFail,
    0, 0
};


static DWORD g_adwCeHelp[] =
{
    CID_CE_GB_PhoneNumber,     HID_CE_GB_PhoneNumber,
    CID_CE_ST_AreaCodes,       HID_CE_CLB_AreaCodes,
    CID_CE_CLB_AreaCodes,      HID_CE_CLB_AreaCodes,
    CID_CE_ST_PhoneNumber,     HID_CE_EB_PhoneNumber,
    CID_CE_EB_PhoneNumber,     HID_CE_EB_PhoneNumber,
    CID_CE_ST_CountryCodes,    HID_CE_LB_CountryCodes,
    CID_CE_LB_CountryCodes,    HID_CE_LB_CountryCodes,
    CID_CE_GB_Comment,         HID_CE_GB_Comment,
    CID_CE_EB_Comment,         HID_CE_EB_Comment,
    CID_CE_CB_UseDialingRules, HID_CE_CB_UseDialingRules,
    0, 0
};


//----------------------------------------------------------------------------
// Local datatypes
//----------------------------------------------------------------------------

// Alternate Phone Number dialog argument block.
//
typedef struct
_ANARGS
{
    DTLNODE* pLinkNode;
    DTLLIST* pListAreaCodes;
}
ANARGS;


// Alternate Phone Number dialog context block.
//
typedef struct
_ANINFO
{
    // Caller's arguments to the dialog.
    //
    ANARGS* pArgs;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndLv;
    HWND hwndPbUp;
    HWND hwndPbDown;
    HWND hwndPbAdd;
    HWND hwndPbEdit;
    HWND hwndPbDelete;
    HWND hwndCbTryNext;
    HWND hwndCbMoveToTop;
    HWND hwndPbOk;

    // Up/down arrow icons.
    //
    HANDLE hiconUpArr;
    HANDLE hiconDnArr;
    HANDLE hiconUpArrDis;
    HANDLE hiconDnArrDis;

    // The state to display in the "move to top" checkbox should it be
    // enabled.
    //
    BOOL fMoveToTop;

    // Link node containing edited phone number list and check box settings
    // and a shortcut to the contained link.
    //
    DTLNODE* pNode;
    PBLINK* pLink;

    // List of area codes passed to CuInit plus all strings retrieved with
    // CuGetInfo.  The list is an editing duplicate of the one in 'pArgs'.
    //
    DTLLIST* pListAreaCodes;
}
ANINFO;


// Phone number editor dialog argument block
//
typedef struct
_CEARGS
{
    DTLNODE* pPhoneNode;
    DTLLIST* pListAreaCodes;
    DWORD sidTitle;
}
CEARGS;


// Phone number editor dialog context block.
//
typedef struct
_CEINFO
{
    // Caller's arguments to the dialog.
    //
    CEARGS* pArgs;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndStAreaCodes;
    HWND hwndClbAreaCodes;
    HWND hwndEbPhoneNumber;
    HWND hwndLbCountryCodes;
    HWND hwndStCountryCodes;
    HWND hwndCbUseDialingRules;
    HWND hwndEbComment;

    // Phone node containing edited phone number settings and a shortcut to
    // the contained PBPHONE.
    //
    DTLNODE* pNode;
    PBPHONE* pPhone;

    // List of area codes passed to CuInit plus all strings retrieved with
    // CuGetInfo.  The list is an editing duplicate of the one in 'pArgs'.
    //
    DTLLIST* pListAreaCodes;

    // Area-code and country-code helper context block, and a flag indicating
    // if the block has been initialized.
    //
    CUINFO cuinfo;
    BOOL fCuInfoInitialized;
}
CEINFO;


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

VOID
AnAddNumber(
    IN ANINFO* pInfo );

BOOL
AnCommand(
    IN ANINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
AnDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
AnDeleteNumber(
    IN ANINFO* pInfo );

VOID
AnEditNumber(
    IN ANINFO* pInfo );

VOID
AnFillLv(
    IN ANINFO* pInfo,
    IN DTLNODE* pNodeToSelect );

BOOL
AnInit(
    IN HWND hwndDlg,
    IN ANARGS* pArgs );

VOID
AnInitLv(
    IN ANINFO* pInfo );

VOID
AnListFromLv(
    IN ANINFO* pInfo );

LVXDRAWINFO*
AnLvCallback(
    IN HWND hwndLv,
    IN DWORD dwItem );

VOID
AnMoveNumber(
    IN ANINFO* pInfo,
    IN BOOL fUp );

BOOL
AnSave(
    IN ANINFO* pInfo );

VOID
AnTerm(
    IN HWND hwndDlg );

VOID
AnUpdateButtons(
    IN ANINFO* pInfo );

VOID
AnUpdateCheckboxes(
    IN ANINFO* pInfo );

BOOL
CeCommand(
    IN CEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
CeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
CeInit(
    IN HWND hwndDlg,
    IN CEARGS* pArgs );

BOOL
CeSave(
    IN CEINFO* pInfo );

VOID
CeTerm(
    IN HWND hwndDlg );


//----------------------------------------------------------------------------
// Alternate Phone Number dialog routines
// Listed alphabetically following entrypoint and dialog proc
//----------------------------------------------------------------------------

BOOL
AlternatePhoneNumbersDlg(
    IN HWND hwndOwner,
    IN OUT DTLNODE* pLinkNode,
    IN OUT DTLLIST* pListAreaCodes )

    // Popup a dialog to edit the phone number list for in 'pLinkNode'.
    // 'HwndOwner' is the owning window.
    //
    // Returns true if user pressed OK and succeeded or false on Cancel or
    // error.
    //
{
    INT_PTR nStatus;
    ANARGS args;

    TRACE( "AlternatePhoneNumbersDlg" );

    args.pLinkNode = pLinkNode;
    args.pListAreaCodes = pListAreaCodes;

    nStatus =
        DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_AN_AlternateNumbers ),
            hwndOwner,
            AnDlgProc,
            (LPARAM )(&args) );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
AnDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Alternate Phone Number dialog.  Parameters
    // and return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "AnDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    if (ListView_OwnerHandler(
            hwnd, unMsg, wparam, lparam, AnLvCallback ))
    {
        return TRUE;
    }

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return AnInit( hwnd, (ANARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwAnHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            ANINFO* pInfo = (ANINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            return AnCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case LVN_ITEMCHANGED:
                {
                    NM_LISTVIEW* p;

                    p = (NM_LISTVIEW* )lparam;
                    if ((p->uNewState & LVIS_SELECTED)
                        && !(p->uOldState & LVIS_SELECTED))
                    {
                        ANINFO* pInfo;

                        // This item was just selected.
                        //
                        pInfo = (ANINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
                        ASSERT( pInfo );
                        AnUpdateButtons( pInfo );
                    }

                    // For whistler bug 29378       gangz
                    // Disable Edit and Delete Button if no item is selected
                    //
                    {
                        UINT uNumSelected = 0;

                        uNumSelected= ListView_GetSelectedCount( 
                                        ((NMHDR*)lparam)->hwndFrom
                                                                );
                        if ( 0 == uNumSelected )
                        {
                            EnableWindow( GetDlgItem(hwnd,
                                                     CID_AN_PB_Edit),
                                          FALSE);
                            
                            EnableWindow( GetDlgItem(hwnd,
                                                     CID_AN_PB_Delete),
                                          FALSE);
                                                     
                        }   
                    }

                    break;
                }
            }
            break;
        }

        case WM_DESTROY:
        {
            AnTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
AnCommand(
    IN ANINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "AnCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_AN_PB_Up:
        {
            AnMoveNumber( pInfo, TRUE );
            return TRUE;
        }

        case CID_AN_PB_Down:
        {
            AnMoveNumber( pInfo, FALSE );
            return TRUE;
        }

        case CID_AN_PB_Add:
        {
            AnAddNumber( pInfo );
            return TRUE;
        }

        case CID_AN_PB_Edit:
        {
            AnEditNumber( pInfo );
            return TRUE;
        }

        case CID_AN_PB_Delete:
        {
            AnDeleteNumber( pInfo );
            return TRUE;
        }

        case CID_AN_CB_TryNextOnFail:
        {
            AnUpdateCheckboxes( pInfo );
            return TRUE;
        }

        case IDOK:
        {
            EndDialog( pInfo->hwndDlg, AnSave( pInfo ) );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


VOID
AnAddNumber(
    IN ANINFO* pInfo )

    // Add a new phone number to the bottom of the ListView, by prompting user
    // with dialog.  'PInfo' is the dialog context.
    //
{
    DTLNODE* pNode;

    pNode = CreatePhoneNode();
    if (!pNode)
    {
        return;
    }

    if (!EditPhoneNumberDlg(
            pInfo->hwndDlg,
            pNode,
            pInfo->pListAreaCodes,
            SID_AddAlternateTitle ))
    {
        DestroyPhoneNode( pNode );
        return;
    }

    AnListFromLv( pInfo );
    DtlAddNodeLast( pInfo->pLink->pdtllistPhones, pNode );
    AnFillLv( pInfo, pNode );

}


VOID
AnDeleteNumber(
    IN ANINFO* pInfo )

    // Deletes the selected phone number in the ListView.  'PInfo' is the
    // dialog context.
    //
{
    DTLNODE* pNode;
    DTLNODE* pSelNode;

    pNode = (DTLNODE* )ListView_GetSelectedParamPtr( pInfo->hwndLv );
    if (!pNode)
    {
        ASSERT( FALSE );
        return;
    }

    AnListFromLv( pInfo );

    // The item under the deleted selection gets the selection unless the
    // lowest item was deleted.  In that case the item above the deleted item
    // is selected.
    //
    pSelNode = DtlGetNextNode( pNode );
    if (!pSelNode)
    {
        pSelNode = DtlGetPrevNode( pNode );
    }

    DtlRemoveNode( pInfo->pLink->pdtllistPhones, pNode );
    DestroyPhoneNode( pNode );

    AnFillLv( pInfo, pSelNode );
}


VOID
AnEditNumber(
    IN ANINFO* pInfo )

    // Edit the selected phone number in the ListView, by prompting user with
    // dialog.  'PInfo' is the dialog context.
    //
{
    DTLNODE* pNode;

    pNode = (DTLNODE* )ListView_GetSelectedParamPtr( pInfo->hwndLv );
    if (!pNode)
    {
        ASSERT( FALSE );
        return;
    }

    if (!EditPhoneNumberDlg(
            pInfo->hwndDlg,
            pNode,
            pInfo->pListAreaCodes,
            SID_EditAlternateTitle ))
    {
        return;
    }

    AnListFromLv( pInfo );
    AnFillLv( pInfo, pNode );
}


VOID
AnFillLv(
    IN ANINFO* pInfo,
    IN DTLNODE* pNodeToSelect )

    // Fill the ListView from the edit node, and select the 'pNodeToSelect'
    // node.  'PInfo' is the dialog context.
    //
{
    INT iItem;
    INT iSelItem;
    DTLNODE* pNode;

    TRACE( "AnFillLv" );
    ASSERT( ListView_GetItemCount( pInfo->hwndLv ) == 0 );

    // Transfer nodes from the edit node list to the ListView one at a time,
    // noticing the item number of the node we'll need to select later.
    //
    iSelItem = 0;

    iItem = 0;
    while (pNode = DtlGetFirstNode( pInfo->pLink->pdtllistPhones ))
    {
        PBPHONE* pPhone;
        LV_ITEM item;
        TCHAR* psz;

        DtlRemoveNode( pInfo->pLink->pdtllistPhones, pNode );

        if (PhoneNodeIsBlank( pNode ))
        {
            // "Blank" numbers are discarded.
            //
            DestroyPhoneNode( pNode );
            continue;
        }

        pPhone = (PBPHONE* )DtlGetData( pNode );
        ASSERT( pPhone );

        ZeroMemory( &item, sizeof(item) );
        item.mask = LVIF_TEXT | LVIF_PARAM;
        item.iItem = iItem;
        item.pszText = pPhone->pszPhoneNumber;
        item.lParam = (LPARAM )pNode;

        ListView_InsertItem( pInfo->hwndLv, &item );
        if (pNode == pNodeToSelect)
        {
            iSelItem = iItem;
        }

        ListView_SetItemText( pInfo->hwndLv, iItem, 1, pPhone->pszComment );
        ++iItem;
    }

    if (ListView_GetItemCount( pInfo->hwndLv ) > 0)
    {
        // Select the specified node, or if none, the first node which
        // triggers updates of the button states.
        //
        ListView_SetItemState(
            pInfo->hwndLv, iSelItem, LVIS_SELECTED, LVIS_SELECTED );
    }
    else
    {
        // Trigger the button state update directly when the list is redrawn
        // empty.
        //
        AnUpdateButtons( pInfo );
    }
}


BOOL
AnInit(
    IN HWND hwndDlg,
    IN ANARGS* pArgs )

    // Called on WM_INITDIALOG.  'HwndDlg' is the handle of the phonebook
    // dialog window.  'PArgs' is caller's arguments as passed to the stub
    // API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    ANINFO* pInfo;
    DTLNODE* pNode;
    PBPHONE* pPhone;

    TRACE( "AnInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->hwndLv = GetDlgItem( hwndDlg, CID_AN_LV_Numbers );
    ASSERT( pInfo->hwndLv );
    pInfo->hwndPbUp = GetDlgItem( hwndDlg, CID_AN_PB_Up );
    ASSERT( pInfo->hwndPbUp );
    pInfo->hwndPbDown = GetDlgItem( hwndDlg, CID_AN_PB_Down );
    ASSERT( pInfo->hwndPbDown );
    pInfo->hwndPbAdd = GetDlgItem( hwndDlg, CID_AN_PB_Add );
    ASSERT( pInfo->hwndPbAdd );
    pInfo->hwndPbEdit = GetDlgItem( hwndDlg, CID_AN_PB_Edit );
    ASSERT( pInfo->hwndPbEdit );
    pInfo->hwndPbDelete = GetDlgItem( hwndDlg, CID_AN_PB_Delete );
    ASSERT( pInfo->hwndPbDelete );
    pInfo->hwndCbMoveToTop = GetDlgItem( hwndDlg, CID_AN_CB_MoveToTop );
    ASSERT( pInfo->hwndCbMoveToTop );
    pInfo->hwndCbTryNext = GetDlgItem( hwndDlg, CID_AN_CB_TryNextOnFail );
    ASSERT( pInfo->hwndCbTryNext );
    pInfo->hwndPbOk = GetDlgItem( hwndDlg, IDOK );
    ASSERT( pInfo->hwndPbOk );

    // Load the up and down arrow icons, enabled and disabled versions,
    // loading the disabled version into the move up and move down buttons.
    // Making a selection in the ListView will trigger the enabled version to
    // be loaded if appropriate.  From what I can tell tell in MSDN, you don't
    // have to close or destroy the icon handle.
    //
    pInfo->hiconUpArr = LoadImage(
        g_hinstDll, MAKEINTRESOURCE( IID_UpArr ), IMAGE_ICON, 0, 0, 0 );
    pInfo->hiconDnArr = LoadImage(
        g_hinstDll, MAKEINTRESOURCE( IID_DnArr ), IMAGE_ICON, 0, 0, 0 );
    pInfo->hiconUpArrDis = LoadImage(
        g_hinstDll, MAKEINTRESOURCE( IID_UpArrDis ), IMAGE_ICON, 0, 0, 0 );
    pInfo->hiconDnArrDis = LoadImage(
        g_hinstDll, MAKEINTRESOURCE( IID_DnArrDis ), IMAGE_ICON, 0, 0, 0 );

    // Make a copy of the argument node and list for editing since user can
    // Cancel the dialog and discard any edits.
    //
    pInfo->pNode = CreateLinkNode();
    if (!pInfo->pNode)
    {
        ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
        EndDialog( hwndDlg, FALSE );
        return TRUE;
    }

    CopyLinkPhoneNumberInfo( pInfo->pNode, pInfo->pArgs->pLinkNode );
    pInfo->pLink = (PBLINK* )DtlGetData( pInfo->pNode );
    ASSERT( pInfo->pLink );

    pInfo->pListAreaCodes = DtlDuplicateList(
        pArgs->pListAreaCodes, DuplicatePszNode, DestroyPszNode );

    // Fill the ListView of phone numbers and select the first one.
    //
    AnInitLv( pInfo );
    AnFillLv( pInfo, NULL );

    // Initialize the check boxes.
    //
    Button_SetCheck( pInfo->hwndCbTryNext,
        pInfo->pLink->fTryNextAlternateOnFail );
    Button_SetCheck( pInfo->hwndCbMoveToTop,
        pInfo->pLink->fPromoteAlternates );
    pInfo->fMoveToTop = pInfo->pLink->fPromoteAlternates;
    AnUpdateCheckboxes( pInfo );

    // Center dialog on the owner window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    return TRUE;
}


VOID
AnInitLv(
    IN ANINFO* pInfo )

    // Fill the ListView with phone numbers and comments.  'PInfo' is the
    // dialog context.
    //
{
    TRACE( "AnInitLv" );

    // Add columns.
    //
    {
        LV_COLUMN col;
        TCHAR* pszHeader0;
        TCHAR* pszHeader1;

        pszHeader0 = PszFromId( g_hinstDll, SID_PhoneNumbersColHead );
        pszHeader1 = PszFromId( g_hinstDll, SID_CommentColHead );

        ZeroMemory( &col, sizeof(col) );
        col.mask = LVCF_FMT + LVCF_TEXT;
        col.fmt = LVCFMT_LEFT;
        col.pszText = (pszHeader0) ? pszHeader0 : TEXT("");
        ListView_InsertColumn( pInfo->hwndLv, 0, &col );

        ZeroMemory( &col, sizeof(col) );
        col.mask = LVCF_FMT + LVCF_SUBITEM + LVCF_TEXT;
        col.fmt = LVCFMT_LEFT;
        col.pszText = (pszHeader1) ? pszHeader1 : TEXT("");
        col.iSubItem = 1;
        ListView_InsertColumn( pInfo->hwndLv, 1, &col );

        Free0( pszHeader0 );
        Free0( pszHeader1 );
    }

    // Size columns.  Gives half for phone number and half for comment.
    //
    {
        RECT rect;
        LONG dx;
        LONG dxPhone;
        LONG dxComment;

        // The (2 * 2) is 2 columns of 2-pel column separator which the
        // ListView doesn't seem to account for when accepting column widths.
        // This gives a full ListView with no horizontal scroll bar.
        //
        GetWindowRect( pInfo->hwndLv, &rect );
        dx = rect.right - rect.left - (2 * 2);
        dxPhone = dx / 2;
        dxComment = dx - dxPhone;
        ListView_SetColumnWidth( pInfo->hwndLv, 0, dxPhone );
        ListView_SetColumnWidth( pInfo->hwndLv, 1, dxComment );
    }
}


VOID
AnListFromLv(
    IN ANINFO* pInfo )

    // Rebuild the edit link's PBPHONE list from the ListView.  'PInfo' is the
    // dialog context.
    //
{
    INT i;

    i = -1;
    while ((i = ListView_GetNextItem( pInfo->hwndLv, i, LVNI_ALL )) >= 0)
    {
        DTLNODE* pNode;

        pNode = (DTLNODE* )ListView_GetParamPtr( pInfo->hwndLv, i );
        ASSERT( pNode );

        if(NULL == pNode)
        {
            continue;
        }

        if (PhoneNodeIsBlank( pNode ))
        {
            // "Blank" numbers are discarded.
            //
            DestroyPhoneNode( pNode );
            continue;
        }

        DtlAddNodeLast( pInfo->pLink->pdtllistPhones, pNode );
    }

    ListView_DeleteAllItems( pInfo->hwndLv );
}


LVXDRAWINFO*
AnLvCallback(
    IN HWND hwndLv,
    IN DWORD dwItem )

    // Enhanced list view callback to report drawing information.  'HwndLv' is
    // the handle of the list view control.  'DwItem' is the index of the item
    // being drawn.
    //
    // Returns the address of the draw information.
    //
{
    // Use "full row select" and other recommended options.
    //
    // Fields are 'nCols', 'dxIndent', 'dwFlags', 'adwFlags[]'.
    //
    static LVXDRAWINFO info = { 2, 0, 0, { 0, 0 } };

    return &info;
}


VOID
AnMoveNumber(
    IN ANINFO* pInfo,
    IN BOOL fUp )

    // Refill the ListView of devices with the selected item moved up or down
    // one position.  'FUp' is set to move up, otherwise moves down.  'PInfo'
    // is the property sheeet context.
    //
{
    DTLNODE* pNode;
    DTLNODE* pPrevNode;
    DTLNODE* pNextNode;
    DTLLIST* pList;

    // Notice which node is selected, then rebuild the edit link's PBPHONE
    // list from the ListView.
    //
    pNode = (DTLNODE* )ListView_GetSelectedParamPtr( pInfo->hwndLv );
    if (pNode == NULL)
    {
        return;
    }
    AnListFromLv( pInfo );
    pList = pInfo->pLink->pdtllistPhones;

    // Move the selected node forward or backward a node in the chain.
    //
    if (fUp)
    {
        pPrevNode = DtlGetPrevNode( pNode );
        if (pPrevNode)
        {
            DtlRemoveNode( pList, pNode );
            DtlAddNodeBefore( pList, pPrevNode, pNode );
        }
    }
    else
    {
        pNextNode = DtlGetNextNode( pNode );
        if (pNextNode)
        {
            DtlRemoveNode( pList, pNode );
            DtlAddNodeAfter( pList, pNextNode, pNode );
        }
    }

    // Refill the ListView with the new order.
    //
    AnFillLv( pInfo, pNode );
}


BOOL
AnSave(
    IN ANINFO* pInfo )

    // Load the contents of the dialog into caller's stub API output argument.
    // 'PInfo' is the dialog context.
    //
    // Returns true if succesful, false otherwise.
    //
{
    TRACE( "AnSave" );

    // Rebuild the edit link's PBPHONE list from the ListView.
    //
    AnListFromLv( pInfo );

    // Retrieve check box settings.
    //
    pInfo->pLink->fPromoteAlternates =
        Button_GetCheck( pInfo->hwndCbMoveToTop );
    pInfo->pLink->fTryNextAlternateOnFail =
        Button_GetCheck( pInfo->hwndCbTryNext );

    // Copy the edit buffer to caller's output argument.
    //
    CopyLinkPhoneNumberInfo( pInfo->pArgs->pLinkNode, pInfo->pNode );

    // Swap lists, saving updates to caller's global list of area codes.
    // Caller's original list will be destroyed by AnTerm.
    //
    if (pInfo->pListAreaCodes)
    {
        DtlSwapLists( pInfo->pArgs->pListAreaCodes, pInfo->pListAreaCodes );
    }

    return TRUE;
}


VOID
AnTerm(
    IN HWND hwndDlg )

    // Dialog termination.
    //
{
    ANINFO* pInfo;

    TRACE( "AnTerm" );

    pInfo = (ANINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );
    if (pInfo)
    {
        // Release any PBPHONE nodes still in the list, e.g. if user Canceled.
        //
        if (pInfo->pNode)
        {
            AnListFromLv( pInfo );
            DestroyLinkNode( pInfo->pNode );
        }

        if (pInfo->pListAreaCodes)
        {
            DtlDestroyList( pInfo->pListAreaCodes, DestroyPszNode );
        }

        Free( pInfo );
        TRACE( "Context freed" );
    }
}


VOID
AnUpdateButtons(
    IN ANINFO* pInfo )

    // Determine if the Up, Down, Edit, and Delete operations make sense and
    // enable/disable those buttons accordingly.  If a disabled button has
    // focus, focus is given to the ListView.  'PInfo' is the dialog context.
    //
{
    INT iSel;
    INT cItems;
    BOOL fSel;

    iSel = ListView_GetNextItem( pInfo->hwndLv, -1, LVNI_SELECTED );
    fSel = (iSel >= 0);
    cItems = ListView_GetItemCount( pInfo->hwndLv );

    // "Up" button.
    //
    if (iSel > 0)
    {
        EnableWindow( pInfo->hwndPbUp, TRUE );
        SendMessage( pInfo->hwndPbUp, BM_SETIMAGE, IMAGE_ICON,
            (LPARAM )pInfo->hiconUpArr );
    }
    else
    {
        EnableWindow( pInfo->hwndPbUp, FALSE );
        SendMessage( pInfo->hwndPbUp, BM_SETIMAGE, IMAGE_ICON,
            (LPARAM )pInfo->hiconUpArrDis );
    }

    // "Down" button.
    //
    if (fSel && (iSel < cItems - 1))
    {
        EnableWindow( pInfo->hwndPbDown, TRUE );
        SendMessage( pInfo->hwndPbDown, BM_SETIMAGE, IMAGE_ICON,
            (LPARAM )pInfo->hiconDnArr );
    }
    else
    {
        EnableWindow( pInfo->hwndPbDown, FALSE );
        SendMessage( pInfo->hwndPbDown, BM_SETIMAGE, IMAGE_ICON,
            (LPARAM )pInfo->hiconDnArrDis );
    }

    // "Edit" and "Delete" buttons.
    //
    EnableWindow( pInfo->hwndPbEdit, fSel );
    EnableWindow( pInfo->hwndPbDelete, fSel );

    // If the focus button is disabled, move focus to the ListView and make OK
    // the default button.
    //
    if (!IsWindowEnabled( GetFocus() ))
    {
        SetFocus( pInfo->hwndLv );
        Button_MakeDefault( pInfo->hwndDlg, pInfo->hwndPbOk );
    }
}


VOID
AnUpdateCheckboxes(
    IN ANINFO* pInfo )

    // Update so "move to top" checkbox is enabled only when "try next" is set
    // maintaining a restore state for "move to top".  'PInfo' is the dialog
    // context.
    //
{
    if (Button_GetCheck( pInfo->hwndCbTryNext ))
    {
        Button_SetCheck( pInfo->hwndCbMoveToTop, pInfo->fMoveToTop );
        EnableWindow( pInfo->hwndCbMoveToTop, TRUE );
    }
    else
    {
        pInfo->fMoveToTop = Button_GetCheck( pInfo->hwndCbMoveToTop );
        Button_SetCheck( pInfo->hwndCbMoveToTop, FALSE );
        EnableWindow( pInfo->hwndCbMoveToTop, FALSE );
    }
}


//----------------------------------------------------------------------------
// Phone number editor dialog routines
// Listed alphabetically following entrypoint and dialog proc
//----------------------------------------------------------------------------

BOOL
EditPhoneNumberDlg(
    IN HWND hwndOwner,
    IN OUT DTLNODE* pPhoneNode,
    IN OUT DTLLIST* pListAreaCodes,
    IN DWORD sidTitle )

    // Popup a dialog to edit the phone number in 'pPhoneNode' and update the
    // area code list 'pListAreaCodes'.  'HwndOwner' is the owning window.
    // 'SidTitle' is the string ID of the title for the dialog.
    //
    // Returns true if user pressed OK and succeeded or false on Cancel or
    // error.
    //
{
    INT_PTR nStatus;
    CEARGS args;

    TRACE( "EditPhoneNumberDlg" );

    args.pPhoneNode = pPhoneNode;
    args.pListAreaCodes = pListAreaCodes;
    args.sidTitle = sidTitle;

    nStatus =
        DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_CE_ComplexPhoneEditor ),
            hwndOwner,
            CeDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
CeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the phone number editor dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "CeDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return CeInit( hwnd, (CEARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwCeHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            CEINFO* pInfo = (CEINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            return CeCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            CeTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
CeCommand(
    IN CEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "CeCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_CE_CB_UseDialingRules:
        {
            if (CuDialingRulesCbHandler( &pInfo->cuinfo, wNotification ))
            {
                return TRUE;
            }
            break;
        }

        case CID_CE_LB_CountryCodes:
        {
            if (CuCountryCodeLbHandler( &pInfo->cuinfo, wNotification ))
            {
                return TRUE;
            }
            break;
        }

        case IDOK:
        {
            EndDialog( pInfo->hwndDlg, CeSave( pInfo ) );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
CeInit(
    IN HWND hwndDlg,
    IN CEARGS* pArgs )

    // Called on WM_INITDIALOG.  'HwndDlg' is the handle of the phonebook
    // dialog window.  'PArgs' is caller's link node argument as passed to the
    // stub API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    CEINFO* pInfo;
    DTLNODE* pNode;
    PBPHONE* pPhone;

    TRACE( "CeInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->hwndStAreaCodes =
        GetDlgItem( hwndDlg, CID_CE_ST_AreaCodes );
    ASSERT( pInfo->hwndStAreaCodes );

    pInfo->hwndClbAreaCodes =
        GetDlgItem( hwndDlg, CID_CE_CLB_AreaCodes );
    ASSERT( pInfo->hwndClbAreaCodes );

    pInfo->hwndEbPhoneNumber =
        GetDlgItem( hwndDlg, CID_CE_EB_PhoneNumber );
    ASSERT( pInfo->hwndEbPhoneNumber );

    pInfo->hwndLbCountryCodes =
        GetDlgItem( hwndDlg, CID_CE_LB_CountryCodes );
    ASSERT( pInfo->hwndLbCountryCodes );

    pInfo->hwndCbUseDialingRules =
        GetDlgItem( hwndDlg, CID_CE_CB_UseDialingRules );
    ASSERT( pInfo->hwndCbUseDialingRules );

    pInfo->hwndEbComment =
        GetDlgItem( hwndDlg, CID_CE_EB_Comment );
    ASSERT( pInfo->hwndEbComment );

    // Set title to caller's resource string.
    //
    {
        TCHAR* pszTitle;

        pszTitle = PszFromId( g_hinstDll, pArgs->sidTitle );
        if (pszTitle)
        {
            SetWindowText( hwndDlg, pszTitle );
            Free( pszTitle );
        }
    }

    // Make an edit copy of the argument node and area-code list.
    //
    pInfo->pNode = DuplicatePhoneNode( pArgs->pPhoneNode );
    if (!pInfo->pNode)
    {
        ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
        EndDialog( hwndDlg, FALSE );
        return TRUE;
    }

    pInfo->pPhone = (PBPHONE* )DtlGetData( pInfo->pNode );
    ASSERT( pInfo->pPhone );

    pInfo->pListAreaCodes = DtlDuplicateList(
        pArgs->pListAreaCodes, DuplicatePszNode, DestroyPszNode );

    // Initialize area-code/country-code helper context.
    //
    CuInit( &pInfo->cuinfo,
        pInfo->hwndStAreaCodes, pInfo->hwndClbAreaCodes,
        NULL, pInfo->hwndEbPhoneNumber,
        pInfo->hwndStCountryCodes, pInfo->hwndLbCountryCodes,
        pInfo->hwndCbUseDialingRules, NULL, 
        NULL,
        NULL, pInfo->hwndEbComment,
        pInfo->pListAreaCodes );

    pInfo->fCuInfoInitialized = TRUE;

    // Load the fields.
    //
    CuSetInfo( &pInfo->cuinfo, pInfo->pNode, FALSE );

    // Center dialog on the owner window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    // Initial focus is on the phone number.
    //
    Edit_SetSel( pInfo->hwndEbPhoneNumber, 0, -1 );
    SetFocus( pInfo->hwndEbPhoneNumber );

    return FALSE;
}


BOOL
CeSave(
    IN CEINFO* pInfo )

    // Load the contents of the dialog into caller's stub API output argument.
    // 'PInfo' is the dialog context.
    //
    // Returns true if succesful, false otherwise.
    //
{
    PBPHONE* pSrcPhone;
    PBPHONE* pDstPhone;

    TRACE( "CeSave" );

    // Load the settings in the controls into the edit node.
    //
    CuGetInfo( &pInfo->cuinfo, pInfo->pNode );

    // Copy the edit node to the stub API caller's argument node.
    //
    pDstPhone = (PBPHONE* )DtlGetData( pInfo->pArgs->pPhoneNode );
    pSrcPhone = pInfo->pPhone;

    pDstPhone->dwCountryCode = pSrcPhone->dwCountryCode;
    pDstPhone->dwCountryID = pSrcPhone->dwCountryID;
    pDstPhone->fUseDialingRules = pSrcPhone->fUseDialingRules;
    Free0( pDstPhone->pszPhoneNumber );
    pDstPhone->pszPhoneNumber = StrDup( pSrcPhone->pszPhoneNumber );
    Free0( pDstPhone->pszAreaCode );
    pDstPhone->pszAreaCode = StrDup( pSrcPhone->pszAreaCode );
    Free0( pDstPhone->pszComment );
    pDstPhone->pszComment = StrDup( pSrcPhone->pszComment );

    // Swap lists, saving updates to caller's global list of area codes.
    // Caller's original list will be destroyed by AnTerm.
    //
    if (pInfo->pListAreaCodes)
    {
        DtlSwapLists( pInfo->pArgs->pListAreaCodes, pInfo->pListAreaCodes );
    }

    return TRUE;
}


VOID
CeTerm(
    IN HWND hwndDlg )

    // Dialog termination.
    //
{
    CEINFO* pInfo;

    TRACE( "CeTerm" );

    pInfo = (CEINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );
    if (pInfo)
    {
        if (pInfo->pNode)
        {
            DestroyPhoneNode( pInfo->pNode );
        }

        if (pInfo->pListAreaCodes)
        {
            DtlDestroyList( pInfo->pListAreaCodes, DestroyPszNode );
        }

        if (pInfo->fCuInfoInitialized)
        {
            CuFree( &pInfo->cuinfo );
        }

        Free( pInfo );
        TRACE( "Context freed" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\entry.h ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// entry.h
// Remote Access Common Dialog APIs
// Phonebook entry property sheet and wizard header
//
// 06/18/95 Steve Cobb


#ifndef _ENTRY_H_
#define _ENTRY_H_


#define RASEDFLAG_AnyNewEntry       (RASEDFLAG_NewEntry       | \
                                     RASEDFLAG_NewPhoneEntry  | \
                                     RASEDFLAG_NewTunnelEntry | \
                                     RASEDFLAG_NewDirectEntry | \
                                     RASEDFLAG_NewBroadbandEntry)
//
// pmay: 233287
//
// We need to be able to filter ports lists such that
// all port types are included in the list and such that
// all non-vpn port types are included in the list.  This
// is a requirement for the demand dial interface wizard.
//
// Define private RASET_* types to be used with the
// EuChangeEntryType function.
//
#define RASET_P_AllTypes        ((DWORD)-1)
#define RASET_P_NonVpnTypes     ((DWORD)-2)

//
// pmay: 378432
//
// Add more flexibility to Su* api's
// See SUINFO.dwFlags
//
#define SU_F_DisableTerminal       0x1
#define SU_F_DisableScripting      0x2

//-----------------------------------------------------------------------------
// Datatypes
//-----------------------------------------------------------------------------

// Phonebook Entry common block.
//
typedef struct
_EINFO
{
    // RAS API arguments.
    //
    TCHAR* pszPhonebook;
    TCHAR* pszEntry;
    RASENTRYDLG* pApiArgs;

    // Set true by property sheet or wizard when changes should be committed
    // before returning from the API.  Does not apply in ShellOwned-mode where
    // the API returns before the property sheet is dismissed.
    //
    BOOL fCommit;

    // Set if we have been called via RouterEntryDlg.
    //
    BOOL fRouter;

    // Set if fRouter is TRUE and pszRouter refers to a remote machine.
    //
    BOOL fRemote;

    // Set if pszRouter is an NT4 steelhead machine.  Valid only 
    // if fRouter is true.
    //
    BOOL fNt4Router;

    //Set if pszRouter is an Windows 2000 machine, Valid only if
    // fRouter is true
    BOOL fW2kRouter;

    // The name of the server in "\\server" form or NULL if none (or if
    // 'fRouter' is not set).
    //
    TCHAR* pszRouter;

    // Set by the add entry or add interface wizards if user chooses to end
    // the wizard and go edit the properties directly.  When this flag is set
    // the wizard should *not* call EuFree before returning.
    //
    BOOL fChainPropertySheet;

    // Phonebook settings read from the phonebook file.  All access should be
    // thru 'pFile' as 'file' will only be used in cases where the open
    // phonebook is not passed thru the reserved word hack.
    //
    PBFILE* pFile;
    PBFILE file;

    // Global preferences read via phonebook library.  All access should be
    // thru 'pUser' as 'user' will only be used in cases where the preferences
    // are not passed thru the reserved word hack.
    //
    PBUSER* pUser;
    PBUSER user;

    // Set if "no user before logon" mode.
    //
    BOOL fNoUser;

    // Set by the add-entry wizard if the selected port is an X.25 PAD.
    //
    BOOL fPadSelected;

    // Set if there are multiple devices configured, i.e. if the UI is running
    // in the multiple device mode.  This is implicitly false in VPN and
    // Direct modes.
    //
    BOOL fMultipleDevices;

    // Link storing the List of PBPHONEs and alternate options for shared
    // phone number mode.  This allows user to change the port/device to
    // another link without losing the phone number he typed.
    //
    DTLNODE* pSharedNode;

    // The node being edited (still in the list), and the original entry name
    // for use in comparison later.  These are valid in "edit" case only.
    //
    DTLNODE* pOldNode;
    TCHAR szOldEntryName[ RAS_MaxEntryName + 1 ];

    // The work entry node containing and a shortcut pointer to the entry
    // inside.
    //
    DTLNODE* pNode;
    PBENTRY* pEntry;

    // The master list of configured ports used by EuChangeEntryType to
    // construct an appropriate sub-list of PBLINKs in the work entry node.
    //
    DTLLIST* pListPorts;

    // The "current" device.  This value is NULL for multilink entries.  It
    // is the device that the entry will use if no change is made.  We compare
    // the current device to the device selected from the general tab to know
    // when it is appropriate to update the phonebook's "preferred" device.
    //
    TCHAR* pszCurDevice;
    TCHAR* pszCurPort;

    // Set true if there are no ports of the current entry type configured,
    // not including any bogus "uninstalled" ports added to the link list so
    // the rest of the code can assume there is at least one link.
    //
    BOOL fNoPortsConfigured;

    // Dial-out user info for router; used by AiWizard.  Used to set interface
    // credentials via MprAdminInterfaceSetCredentials.
    //
    TCHAR* pszRouterUserName;
    TCHAR* pszRouterDomain;
    TCHAR* pszRouterPassword;

    // Dial-in user info for router (optional); used by AiWizard.  Used to
    // create dial-in user account via NetUserAdd; the user name for the
    // account is the interface (phonebook entry) name.
    //
    BOOL fAddUser;
    TCHAR* pszRouterDialInPassword;

    // Home networking settings for the entry.
    //
    BOOL fComInitialized;
    HRESULT hShowHNetPagesResult;
    BOOL fShared;
    BOOL fDemandDial;
    BOOL fNewShared;
    BOOL fNewDemandDial;
    DWORD dwLanCount;
    IHNetConnection *pPrivateLanConnection;

    // AboladeG - security level of the current user.
    // Set true if the user is an administrator/power user.
    // This is required by several pages, both in the wizard
    // and in the property sheet.
    //
    BOOL fIsUserAdminOrPowerUser;

    // Set if strong encryption is supported by NDISWAN, as determined in
    // EuInit.
    //
    BOOL fStrongEncryption;

    // Set whent the VPN "first connect" controls should be read-only, e.g. in
    // the dialer's Properties button is pressed in the middle of a double
    // dial.
    //
    BOOL fDisableFirstConnect;

    //Used in the IPSec Policy in the Security tab for a VPN connection
    //
    BOOL fPSKCached;
    TCHAR szPSK[PWLEN + 1];


    // Flags to track whether to save the default Internet connection
    //
    BOOL fDefInternet;

    // Default credentials
    //
    BOOL   fGlobalCred;     //add for whistler bug 328673
    TCHAR* pszDefUserName;
    TCHAR* pszDefPassword;
}
EINFO;


// Complex phone number utilities context block.
//
typedef struct
_CUINFO
{
    // Array of country information.
    //
    COUNTRY* pCountries;

    // Number of countries in the 'pCountries' array.
    //
    DWORD cCountries;

    // The complete country list, rather than a partial, is loaded.
    //
    BOOL fComplete;

    // Handles of the controls involved.
    //
    HWND hwndStAreaCodes;
    HWND hwndClbAreaCodes;
    HWND hwndStPhoneNumber;     // May be NULL
    HWND hwndEbPhoneNumber;
    HWND hwndStCountryCodes;
    HWND hwndLbCountryCodes;
    HWND hwndCbUseDialingRules;
    HWND hwndPbDialingRules;    // May be NULL  
    HWND hwndPbAlternates;      // May be NULL
    HWND hwndStComment;         // May be NULL
    HWND hwndEbComment;         // May be NULL

    // List of area codes modified to include all strings retrieved with
    // CuGetInfo.  The list is owned by the caller, i.e. it is not cleaned up
    // on CuFree.
    //
    DTLLIST* pListAreaCodes;    // May be NULL

    // The area code and country code fields are blanked when "use dialing
    // rules" is not checked to avoid confusing the typical user who doesn't
    // understand them.  The setting to which each field would be restored
    // were "use dialing rules" to be enabled is stored here.  These fields
    // always reflect the value at the last rules toggle or set swap.
    //
    // This country ID also serves as the "country ID to select" passed to
    // CuUpdateCountryCodeLb, which allows an optimization where the full
    // Country Code list is only loaded when user requests to view it.
    //
    TCHAR* pszAreaCode;
    DWORD dwCountryId;
    DWORD dwCountryCode;

    // Used by tapi for the dialing rules
    HLINEAPP hlineapp;
}
CUINFO;


// Scripting utilities context block.
//
typedef struct
_SUINFO
{
    // The managed controls.
    //
    HWND hwndCbRunScript;
    HWND hwndCbTerminal;
    HWND hwndLbScripts;
    HWND hwndPbEdit;
    HWND hwndPbBrowse;

    // List of scripts loaded.
    //
    DTLLIST* pList;

    // The current list selection or if disabled the hidden selection.
    //
    TCHAR* pszSelection;

    // hConnection to the server in case this is a remote
    // machine.
    //
    HANDLE hConnection;

    // The flags
    //
    DWORD dwFlags;
}
SUINFO;


// "Dial another first" list item context block.
//
typedef struct
PREREQITEM
{
    TCHAR* pszEntry;
    TCHAR* pszPbk;
}
PREREQITEM;


//-----------------------------------------------------------------------------
// Prototypes
//-----------------------------------------------------------------------------

VOID
AeWizard(
    IN OUT EINFO* pEinfo );

VOID
AiWizard(
    IN OUT EINFO* pEinfo );

VOID
PePropertySheet(
    IN OUT EINFO* pEinfo );

DWORD
EuChangeEntryType(
    IN EINFO* pInfo,
    IN DWORD dwType );

BOOL
EuCommit(
    IN EINFO* pInfo );

DWORD
EuRouterInterfaceCreate(
    IN EINFO* pInfo );

DWORD
EuCredentialsCommit(
    IN EINFO* pInfo );

DWORD
EuCredentialsCommitRouterStandard(
    IN EINFO* pInfo );

DWORD
EuCredentialsCommitRouterIPSec(
    IN EINFO* pInfo );

DWORD
EuCredentialsCommitRasGlobal(
    IN EINFO* pInfo );
    
DWORD
EuCredentialsCommitRasIPSec(
    IN EINFO* pInfo );

BOOL 
EuRouterInterfaceIsNew(
     IN EINFO * pInfo );

DWORD
EuInternetSettingsCommitDefault( 
    IN EINFO* pInfo );

DWORD
EuHomenetCommitSettings(
    IN EINFO* pInfo);
    
VOID
EuFree(
    IN EINFO* pInfo );

VOID
EuGetEditFlags(
    IN EINFO* pEinfo,
    OUT BOOL* pfEditMode,
    OUT BOOL* pfChangedNameInEditMode );

DWORD
EuInit(
    IN TCHAR* pszPhonebook,
    IN TCHAR* pszEntry,
    IN RASENTRYDLG* pArgs,
    IN BOOL fRouter,
    OUT EINFO** ppInfo,
    OUT DWORD* pdwOp );

BOOL
EuValidateName(
    IN HWND hwndOwner,
    IN EINFO* pEinfo );

VOID
CuClearCountryCodeLb(
    IN CUINFO* pCuInfo );

BOOL
CuCountryCodeLbHandler(
    IN CUINFO* pCuInfo,
    IN WORD wNotification );

VOID
CuCountryCodeLbSelChange(
    IN CUINFO* pCuInfo );

BOOL
CuDialingRulesCbHandler(
    IN CUINFO* pCuInfo,
    IN WORD wNotification );

VOID
CuFree(
    IN CUINFO* pCuInfo );

VOID
CuGetInfo(
    IN CUINFO* pCuInfo,
    OUT DTLNODE* pPhoneNode );

VOID
CuInit(
    OUT CUINFO* pCuInfo,
    IN HWND hwndStAreaCodes,
    IN HWND hwndClbAreaCodes,
    IN HWND hwndStPhoneNumber,
    IN HWND hwndEbPhoneNumber,
    IN HWND hwndStCountryCodes,
    IN HWND hwndLbCountryCodes,
    IN HWND hwndCbUseDialingRules,
    IN HWND hwndPbDialingRules,
    IN HWND hwndPbAlternates,
    IN HWND hwndStComment,
    IN HWND hwndEbComment,
    IN DTLLIST* pListAreaCodes );

VOID
CuSaveToAreaCodeList(
    IN CUINFO* pCuInfo,
    IN TCHAR* pszAreaCode );

VOID
CuSetInfo(
    IN CUINFO* pCuInfo,
    IN DTLNODE* pPhoneNode,
    IN BOOL fDisableAll );

VOID
CuUpdateAreaCodeClb(
    IN CUINFO* pCuInfo );

VOID
CuUpdateCountryCodeLb(
    IN CUINFO* pCuInfo,
    IN BOOL fComplete );

BOOL
SuBrowsePbHandler(
    IN SUINFO* pSuInfo,
    IN WORD wNotification );

BOOL
SuEditPbHandler(
    IN SUINFO* pSuInfo,
    IN WORD wNotification );

VOID
SuEditScpScript(
    IN HWND   hwndOwner,
    IN TCHAR* pszScript );

VOID
SuEditSwitchInf(
    IN HWND hwndOwner );

VOID
SuFillDoubleScriptsList(
    IN SUINFO* pSuInfo );

VOID
SuFillScriptsList(
    IN EINFO* pEinfo,
    IN HWND hwndLbScripts,
    IN TCHAR* pszSelection );

VOID
SuFree(
    IN SUINFO* pSuInfo );

VOID
SuGetInfo(
    IN SUINFO* pSuInfo,
    OUT BOOL* pfScript,
    OUT BOOL* pfTerminal,
    OUT TCHAR** ppszScript );

VOID
SuInit(
    IN SUINFO* pSuInfo,
    IN HWND hwndCbRunScript,
    IN HWND hwndCbTerminal,
    IN HWND hwndLbScripts,
    IN HWND hwndPbEdit,
    IN HWND hwndPbBrowse,
    IN DWORD dwFlags);

DWORD
SuLoadScpScriptsList(
    OUT DTLLIST** ppList );

BOOL
SuScriptsCbHandler(
    IN SUINFO* pSuInfo,
    IN WORD wNotification );

VOID
SuSetInfo(
    IN SUINFO* pSuInfo,
    IN BOOL fScript,
    IN BOOL fTerminal,
    IN TCHAR* pszScript );

VOID
SuUpdateScriptControls(
    IN SUINFO* pSuInfo );


#endif // _ENTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\dial.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// dial.c
// Remote Access Common Dialog APIs
// RasDialDlg APIs
//
// 11/19/95 Steve Cobb

#include "rasdlgp.h"
#include "raseapif.h"
#include "inetcfgp.h"
#include "netconp.h"
#include "pref.h"


// Posted message codes for tasks that should not or cannot occur in the
// RasDial callback.
//
#define WM_RASEVENT       0xCCCC
#define WM_RASERROR       0xCCCD
#define WM_RASDIAL        0xCCCE
#define WM_RASBUNDLEERROR 0xCCCF
#define WM_DPENDDIALOG    0xCCD0

// Dialer dialog mode bits
//
#define DR_U 0x00000001 // Username and password present
#define DR_D 0x00000002 // Domain present
#define DR_N 0x00000004 // Phone number present
#define DR_L 0x00000008 // Location controls present
#define DR_I 0x00000010 // Eap identity dialog
// For whistler bug 500731
#define DR_B 0x00000020 // No User name No Password(Basic)Eap dialog

// Internal constants used by DrXxx routines to implement the "manual edit"
// combo-box.
//
#define DR_WM_SETTEXT 0xCCC0
#define DR_BOGUSWIDTH 19591

#define EAP_RASTLS      13

// For whistler 460931  459793      gangz
extern BOOL WINAPI LinkWindow_RegisterClass();


//----------------------------------------------------------------------------
// Help maps
//----------------------------------------------------------------------------

static DWORD g_adwDrHelp[] =
{
    CID_DR_BM_Useless,      HID_DR_BM_Useless,
    CID_DR_ST_User,         HID_DR_EB_User,
    CID_DR_EB_User,         HID_DR_EB_User,
    CID_DR_ST_Password,     HID_DR_EB_Password,
    CID_DR_EB_Password,     HID_DR_EB_Password,
    CID_DR_ST_Domain,       HID_DR_EB_Domain,
    CID_DR_EB_Domain,       HID_DR_EB_Domain,
    CID_DR_CB_SavePassword, HID_DR_CB_SavePassword,
    CID_DR_ST_Numbers,      HID_DR_CLB_Numbers,
    CID_DR_CLB_Numbers,     HID_DR_CLB_Numbers,
    CID_DR_ST_Locations,    HID_DR_LB_Locations,
    CID_DR_LB_Locations,    HID_DR_LB_Locations,
    CID_DR_PB_Rules,        HID_DR_PB_Rules,
    CID_DR_PB_Properties,   HID_DR_PB_Properties,
    CID_DR_PB_DialConnect,  HID_DR_PB_DialConnect,
    CID_DR_PB_Cancel,       HID_DR_PB_Cancel,
    CID_DR_PB_Help,         HID_DR_PB_Help,
    CID_DR_RB_SaveForMe,    HID_DR_RB_SaveForMe,
    CID_DR_RB_SaveForEveryone, HID_DR_RB_SaveForEveryone,
    0, 0
};

static DWORD g_adwCpHelp[] =
{
    CID_CP_ST_Explain,         HID_CP_ST_Explain,
    CID_CP_ST_OldPassword,     HID_CP_EB_OldPassword,
    CID_CP_EB_OldPassword,     HID_CP_EB_OldPassword,
    CID_CP_ST_Password,        HID_CP_EB_Password,
    CID_CP_EB_Password,        HID_CP_EB_Password,
    CID_CP_ST_ConfirmPassword, HID_CP_EB_ConfirmPassword,
    CID_CP_EB_ConfirmPassword, HID_CP_EB_ConfirmPassword,
    0, 0
};

static DWORD g_adwDcHelp[] =
{
    CID_DC_ST_Explain, HID_DC_ST_Explain,
    CID_DC_ST_Number,  HID_DC_EB_Number,
    CID_DC_EB_Number,  HID_DC_EB_Number,
    0, 0
};

static DWORD g_adwDeHelp[] =
{
    CID_DE_CB_EnableDiag,   HID_DE_CB_EnableDiag,
    CID_DE_ST_ConfigureLnk, HID_DE_ST_ConfigureLnk,        
    CID_DE_PB_More,         HID_DE_PB_More,
    IDOK,                   HID_DE_PB_Redial,
    0, 0
};

static DWORD g_adwPrHelp[] =
{
    CID_PR_ST_Text,             HID_PR_ST_Text,
    CID_PR_CB_DisableProtocols, CID_PR_CB_DisableProtocols,
    IDOK,                       HID_PR_PB_Accept,
    IDCANCEL,                   HID_PR_PB_HangUp,
    0, 0
};

static DWORD g_adwUaHelp[] =
{
    CID_UA_ST_UserName,     HID_UA_EB_UserName,
    CID_UA_EB_UserName,     HID_UA_EB_UserName,
    CID_UA_ST_Password,     HID_UA_EB_Password,
    CID_UA_EB_Password,     HID_UA_EB_Password,
    CID_UA_ST_Domain,       HID_UA_EB_Domain,
    CID_UA_EB_Domain,       HID_UA_EB_Domain,
    CID_UA_CB_SavePassword, HID_UA_CB_SavePassword,
    0, 0
};

CONST WCHAR g_pszSavedPasswordToken[] = L"****************";
#define g_dwSavedPasswordTokenLength \
    ( sizeof(g_pszSavedPasswordToken) / sizeof(TCHAR) )

// Save password macro, determines if either User or Global password is saved
// (p) must be a pointer to a DINFO struct (see dial.c)
//
// Whistler bug: 288234 When switching back and forth from "I connect" and
// "Any user connects" password is not caching correctly
//
#define HaveSavedPw(p) \
            ((p)->fHaveSavedPwUser || (p)->fHaveSavedPwGlobal)

//----------------------------------------------------------------------------
// Local datatypes
//----------------------------------------------------------------------------

// Dial dialogs common context block.  This block contains information common
// to more than one dialog in the string of dial-related dialogs.
//
typedef struct
_DINFO
{
    // Caller's  arguments to the RAS API.  Outputs in 'pArgs' are visible to
    // the API which has the address of same.  Careful using 'pszEntry' as
    // 'pEntry->pszEntryName' is generally more appropriate, the latter
    // reflecting the name of any prerequisite entry while the prequisite is
    // being dialed.
    //
    LPTSTR pszPhonebook;
    LPTSTR pszEntry;
    LPTSTR pszPhoneNumber;
    RASDIALDLG* pArgs;

    // Phonebook settings read from the phonebook file.  All access should be
    // thru 'pFile'.  'PFile' is set to either '&filePrereq' or 'pFileMain'
    // depending on 'fFilePrereqOpen'.  'File' will only be used in cases
    // where the open phonebook is not passed thru the reserved word hack, and
    // in that case 'pFileMain' will point to it.  'FilePrereq' is the
    // phonebook file of the prequisite entry which may be different from the
    // main entry.  During prerequisite dial 'pFile' points to 'filePrereq'
    // rather than 'file' and 'fFilePrereqOpen is true.  Otherwise, 'pFile'
    // points to whatever 'pFileMain' points at.
    //
    PBFILE* pFile;
    PBFILE* pFileMain;
    PBFILE file;
    PBFILE filePrereq;
    BOOL fFilePrereqOpen;
    BOOL fIsPublicPbk;

    // Global preferences read via phonebook library.  All access should be
    // thru 'pUser' as 'user' will only be used in cases where the preferences
    // are not passed thru the reserved word hack.
    //
    PBUSER* pUser;
    PBUSER user;

    // User credentials provided by API caller for "during logon" dialing
    // where there is no current user.  If user changes the credentials
    // *pfNoUserChanged is set and the 'pNoUser' credentials updated.
    //
    RASNOUSER* pNoUser;
    BOOL* pfNoUserChanged;

    // Set if the call is unattended, i.e. a call by RASAUTO to redial a
    // failed link.
    //
    BOOL fUnattended;

    // Private flags from calling RAS API, the first informing us he wants to
    // be hidden off the desktop while we dial, and the second that he will
    // close if we return "connected" so we can avoid flicker and not bother
    // restoring him.
    //
    BOOL fMoveOwnerOffDesktop;
    BOOL fForceCloseOnDial;

    // Set when something occurs during dial that affects the phonebook entry.
    // The entry is re-read after a successful connection.
    //
    BOOL fResetAutoLogon;
    DWORD dwfExcludedProtocols;
    DTLLIST* pListPortsToDelete;

    // The entry node and a shortcut pointer to the entry inside.
    //
    DTLNODE* pNode;
    PBENTRY* pEntry;

    // The entry of the main entry that referred to any prerequisite entry
    // that might be contained by 'pEntry'.  If no prerequisite entry is
    // involved this is the same as 'pEntry'.
    //
    PBENTRY* pEntryMain;

    // Set is admin has disabled the save password feature in the registry.
    //
    BOOL fDisableSavePw;

    // Set true if a cached password is available for the entry.
    //
    BOOL fHaveSavedPwUser;      // whether there are saved per-user creds
    BOOL fHaveSavedPwGlobal;    // whether there are saved per-connect creds

    // Set when the dial in progress is the prerequisite entry, rather than
    // the main entry.
    //
    BOOL fPrerequisiteDial;

    // Set when calling RasDial on a connected entry to add a reference only.
    // All interaction with user is skipped in this case.  See bug 272794.
    //
    BOOL fDialForReferenceOnly;

    // The dial parameters used on this connection attempt.  Initialized in
    // RasDialDlgW.  Credentials are updated by DialerDlg.  Callback number is
    // updated by DialProgressDlg.
    //
    RASDIALPARAMS rdp;      // actual dial parameters passed to RasDial
    RASDIALPARAMS rdpu;     // per-user credentials
    RASDIALPARAMS rdpg;     // per-connection credentials

    // The dial parameter extensions used on this connection attempt.  Set in
    // RasDialDlgW, except hwndOwner which is set in DialProgressDlg.
    //
    RASDIALEXTENSIONS rde;
}
DINFO;


// Dialer dialogs argument block.  Used for all 5 variations of the dialer.
//
typedef struct
_DRARGS
{
    DINFO* pDinfo;
    DWORD dwfMode;
    DWORD fReload;
}
DRARGS;


// Dialer dialogs context block.  Used for all 5 variations of the dialer.
//
typedef struct
DRINFO
{
    // Common dial context information including the RAS API arguments.
    //
    DRARGS* pArgs;

    // Handle of the dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndEbUser;
    HWND hwndEbPw;
    HWND hwndEbDomain;
    HWND hwndCbSavePw;
    HWND hwndRbSaveForMe;
    HWND hwndRbSaveForEveryone;
    HWND hwndClbNumbers;
    HWND hwndStLocations;
    HWND hwndLbLocations;
    HWND hwndPbRules;
    HWND hwndPbProperties;
    HWND hwndBmDialer;

    // Whistler bug: 195480 Dial-up connection dialog - Number of
    // asterisks does not match the length of the password and causes
    // confusion
    //
    WCHAR szPasswordChar;
    HFONT hNormalFont;
    HFONT hItalicFont;

    // TAPI session handle.
    //
    HLINEAPP hlineapp;

    // The phonebook entry link containing the displayed phone number list.
    // Set up only when DR_N mode bit is set.
    //
    DTLNODE* pLinkNode;
    PBLINK* pLink;

    // The index of the item initially selected in the phone number list.
    //
    DWORD iFirstSelectedPhone;

    // Window handles and original window procedure of the subclassed
    // 'hwndClbNumbers' control's edit-box and list-box child windows.
    //
    HWND hwndClbNumbersEb;
    HWND hwndClbNumbersLb;
    WNDPROC wndprocClbNumbersEb;
    WNDPROC wndprocClbNumbersLb;
    INetConnectionUiUtilities * pNetConUtilities;

    // Set if COM has been initialized (necessary for calls to netshell).
    //
    BOOL fComInitialized;

    // Handle to the original bitmap for the dialer if it is modified 
    // in DrSetBitmap
    //
    HBITMAP hbmOrig;
    
}
DRINFO;


// Context of an item in the dialer's 'ClbNumbers' list.
//
typedef struct
_DRNUMBERSITEM
{
    TCHAR* pszNumber;
    PBPHONE* pPhone;
}
DRNUMBERSITEM;


// Subentry state information.
//
typedef struct
_DPSTATE
{
    RASCONNSTATE state;
    DWORD dwError;
    DWORD dwExtendedError;
    TCHAR szExtendedError[ NETBIOS_NAME_LEN + 1 ];
    TCHAR* pszStatusArg;
    TCHAR* pszFormatArg;
    PBDEVICETYPE pbdt;
    DWORD sidState;
    DWORD sidFormatMsg;
    DWORD sidPrevState;
    BOOL fNotPreSwitch;
    HRASCONN hrasconnLink;
}
DPSTATE;


// Dial Progress dialog context block.
//
typedef struct
_DPINFO
{
    // When the block is valid contains the value 0xC0BBC0DE, otherwise 0.
    // Used as a workaround until RasDial is fixed to stop calling
    // RasDialFunc2 after being told not to, see bug 49469.
    //
    DWORD dwValid;

    // RAS API arguments.
    //
    DINFO* pArgs;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndStState;

    // The saved username and password that authenticated but resulted in a
    // change password event.  If the change password operation fails these
    // are restored to make the redial button work properly.
    //
    TCHAR* pszGoodUserName;
    TCHAR* pszGoodPassword;

    // The handle to the RAS connection being initiated.
    //
    HRASCONN hrasconn;

    // The original window proc we subclassed.
    //
    WNDPROC pOldWndProc;

    // Number of auto-redials not yet attempted on the connection.
    //
    DWORD dwRedialAttemptsLeft;

    // Array of RasDial states, one per subentry, set by DpRasDialFunc2 and
    // used by DpRasDialEvent.
    //
    DPSTATE* pStates;
    DWORD cStates;

    // The number of the most advanced subentry and the "latest" state it has
    // reached.  Note that certain states, like RASCS_AuthNotify, are
    // revisited after reaching a "later" state.  Such changes are ignored.
    //
    RASCONNSTATE state;
    DWORD dwSubEntry;

    // UI thread, Call back function synchronization members
    // for  XPSP2 511810, .Net 668164, 668164  gangz

    CRITICAL_SECTION * pcsActiveLock;

    //Add a per-thread Terminate flag for whistler bug 277365,291613  gangz
    //
    // Flag indicating that RasDial callbacks are active.  The callback
    // context must not be destroyed when this flag is set.  Access to this
    // field is protected by g_csCallbacks, see Get/SetCallbackActive .
    //
    BOOL fCallbacksActive;
    BOOL fTerminateAsap;

    //for whistler bug 381337
    //
    BOOL fCancelPressed;
}
DPINFO;


// Dial Error dialog argument block.
//
typedef struct
_DEARGS
{
    DINFO* pDinfo;       // For whistler 474514
    TCHAR* pszPhonebook; // For whistler 460931
    TCHAR* pszEntry;
    DWORD dwError;
    DWORD sidState;
    TCHAR* pszStatusArg;
    DWORD sidFormatMsg;
    TCHAR* pszFormatArg;
    LONG lRedialCountdown;
    BOOL fPopupOnTop;
}
DEARGS;


// Dial Error dialog context block.
//
typedef struct
_DEINFO
{
    // Caller's arguments to the stub API.
    //
    DEARGS* pArgs;

    // Handle of dialog and controls.
    //
    HWND hwndDlg;
    HWND hwndStText;
    HWND hwndPbRedial;
    HWND hwndPbCancel;
    HWND hwndPbMore;

    // For whistler 460931  459793  
    //
    DiagnosticInfo diagInfo;
    HWND hwndCbEnableDiagLog;
    HWND hwndStConfigureLnk;
    HWND hwndStEnableHelp;
    HWND hwndStLinkHelp;
    

    // Number of seconds remaining in "Redial=x" countdown or -1 if inactive.
    //
    LONG lRedialCountdown;
}
DEINFO;


// Projection Result dialog argument block.
//
typedef struct
_PRARGS
{
    TCHAR* pszLines;
    BOOL* pfDisableFailedProtocols;
}
PRARGS;


// Change Password dialog argument block.
//
typedef struct
_CPARGS
{
    BOOL fOldPassword;
    TCHAR* pszOldPassword;
    TCHAR* pszNewPassword;
}
CPARGS;


// Change Password dialog context block.
// (unconventional name because CPINFO conflicts with a system header)
//
typedef struct
_CPWINFO
{
    // Caller's arguments to the stub API.
    //
    CPARGS* pArgs;

    // Handle of dialog and controls.
    //
    HWND hwndDlg;
    HWND hwndEbOldPassword;
    HWND hwndEbNewPassword;
    HWND hwndEbNewPassword2;
}
CPWINFO;


// Retry Authentication dialog context block.
//
typedef struct
UAINFO
{
    // Commond dial context including original RAS API arguments.
    //
    DINFO* pArgs;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndEbUserName;
    HWND hwndEbPassword;
    HWND hwndEbDomain;
    HWND hwndCbSavePw;

    // Set when the password field contains a phony password in place of the
    // "" one we don't really know.
    //
    BOOL fAutoLogonPassword;

    // Set when the Domain field is present.
    //
    BOOL fDomain;
}
UAINFO;

//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

BOOL
BeCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
BeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
BeFillLvErrors(
    IN HWND hwndLv,
    IN DPINFO* pInfo );

TCHAR*
BeGetErrorPsz(
    IN DWORD dwError );

BOOL
BeInit(
    IN HWND hwndDlg,
    IN DPINFO* pArgs );

LVXDRAWINFO*
BeLvErrorsCallback(
    IN HWND hwndLv,
    IN DWORD dwItem );

BOOL
BundlingErrorsDlg(
    IN OUT DPINFO* pInfo );

BOOL
ChangePasswordDlg(
    IN HWND hwndOwner,
    IN BOOL fOldPassword,
    OUT TCHAR* pszOldPassword,
    OUT TCHAR* pszNewPassword );

BOOL
CpCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
CpDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
CpInit(
    IN HWND hwndDlg,
    IN CPARGS* pArgs );

BOOL
CcCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
CcDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
CcInit(
    IN HWND hwndDlg,
    IN DINFO* pInfo );

VOID
ConnectCompleteDlg(
    IN HWND hwndOwner,
    IN DINFO* pInfo );

BOOL
DcCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
DcDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
DcInit(
    IN HWND hwndDlg,
    IN TCHAR* pszNumber );

VOID
DeAdjustPbRedial(
    IN DEINFO* pInfo );

BOOL
DeCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
DeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

void DeEnableDiagnostic(
    IN HWND hwnd );

BOOL
DeInit(
    IN HWND hwndDlg,
    IN DEARGS* pArgs );

DWORD
DeleteSavedCredentials(
    IN DINFO* pDinfo,
    IN HWND   hwndDlg,
    IN BOOL   fDefault,
    IN BOOL   fDeleteIdentity );

VOID
DeTerm(
    IN HWND hwndDlg );

BOOL
DialCallbackDlg(
    IN HWND hwndOwner,
    IN OUT TCHAR* pszNumber );

BOOL
DialErrorDlg(
    IN HWND hwndOwner,
    IN DINFO * pDinfo,      // For whistler bug 474514
    IN TCHAR* pszPhonebook, // For whistler 460931
    IN TCHAR* pszEntry,
    IN DWORD dwError,
    IN DWORD sidState,
    IN TCHAR* pszStatusArg,
    IN DWORD sidFormatMsg,
    IN TCHAR* pszFormatArg,
    IN LONG lRedialCountdown,
    IN BOOL fPopupOnTop );

BOOL
DialerDlg(
    IN HWND hwndOwner,
    IN OUT DINFO* pInfo );

BOOL
DialProgressDlg(
    IN DINFO* pInfo );

VOID
DpAppendBlankLine(
    IN OUT TCHAR* pszLines );

VOID
DpAppendConnectErrorLine(
    IN OUT TCHAR* pszLines,
    IN DWORD sidProtocol,
    IN DWORD dwError );

VOID
DpAppendConnectOkLine(
    IN OUT TCHAR* pszLines,
    IN DWORD sidProtocol );

VOID
DpAppendFailCodeLine(
    IN OUT TCHAR* pszLines,
    IN DWORD dw );

VOID
DpAppendNameLine(
    IN OUT TCHAR* pszLines,
    IN TCHAR* psz );

VOID
DpAuthNotify(
    IN DPINFO* pInfo,
    IN DPSTATE* pState );

VOID
DpCallbackSetByCaller(
    IN DPINFO* pInfo,
    IN DPSTATE* pState );

VOID
DpCancel(
    IN DPINFO* pInfo );

BOOL
DpCommand(
    IN DPINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

VOID
DpConnectDevice(
    IN DPINFO* pInfo,
    IN DPSTATE* pState );

VOID
DpDeviceConnected(
    IN DPINFO* pInfo,
    IN DPSTATE* pState );

VOID
DpDial(
    IN DPINFO* pInfo,
    IN BOOL fPauseRestart );

INT_PTR CALLBACK
DpDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

//For whistler 435725
void
DpEndDialog( 
    IN DPINFO * pInfo,
    IN BOOL fFlag);

VOID
DpError(
    IN DPINFO* pInfo,
    IN DPSTATE* pState );

DWORD
DpEvent(
    IN DPINFO* pInfo,
    IN DWORD dwSubEntry );

BOOL
DpInit(
    IN HWND hwndDlg,
    IN DINFO* pArgs );

VOID
DpInitStates(
    DPINFO* pInfo );

BOOL
DpInteractive(
    IN DPINFO* pInfo,
    IN DPSTATE* pState,
    OUT BOOL* pfChange );

BOOL
DpIsLaterState(
    IN RASCONNSTATE stateNew,
    IN RASCONNSTATE stateOld );

BOOL
DpPasswordExpired(
    IN DPINFO* pInfo,
    IN DPSTATE* pState );

BOOL
DpProjected(
    IN DPINFO* pInfo,
    IN DPSTATE* pState );

BOOL
DpProjectionError(
    IN RASPPPNBF* pnbf,
    IN RASPPPIPX* pipx,
    IN RASPPPIP* pip,
    OUT BOOL* pfIncomplete,
    OUT DWORD* pdwfFailedProtocols,
    OUT TCHAR** ppszLines,
    OUT DWORD* pdwError );

DWORD WINAPI
DpRasDialFunc2(
    ULONG_PTR dwCallbackId,
    DWORD dwSubEntry,
    HRASCONN hrasconn,
    UINT unMsg,
    RASCONNSTATE state,
    DWORD dwError,
    DWORD dwExtendedError );

VOID
DpTerm(
    IN HWND hwndDlg );

INT_PTR CALLBACK
DrDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL CALLBACK
DrClbNumbersEnumChildProc(
    IN HWND hwnd,
    IN LPARAM lparam );

BOOL CALLBACK
DrClbNumbersEnumWindowsProc(
    IN HWND hwnd,
    IN LPARAM lparam );

BOOL
DrCommand(
    IN DRINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

VOID
DrEditSelectedLocation(
    IN DRINFO* pInfo );

DWORD
DrFillLocationList(
    IN DRINFO* pInfo );

VOID
DrFillNumbersList(
    IN DRINFO* pInfo );

DWORD
DrFindAndSubclassClbNumbersControls(
    IN DRINFO* pInfo );

VOID
DrFreeClbNumbers(
    IN DRINFO* pInfo );

BOOL
DrInit(
    IN HWND hwndDlg,
    IN DRARGS* pArgs );

VOID
DrLocationsSelChange(
    IN DRINFO* pInfo );

VOID
DrNumbersSelChange(
    IN DRINFO* pInfo );

DWORD
DrPopulateIdentificationFields(
    IN DRINFO* pInfo, 
    IN BOOL fForMe);

DWORD
DrPopulatePasswordField(
    IN DRINFO* pInfo,
    IN BOOL fInit,
    IN BOOL fDisable,
    OUT BOOL * pfUseDefaultFocus    
    );

VOID
DrProperties(
    IN DRINFO* pInfo );

VOID
DrSave(
    IN DRINFO* pInfo );

DWORD
DrSetBitmap(
    IN DRINFO* pInfo);
    
VOID
DrSetClbNumbersText(
    IN DRINFO* pInfo,
    IN TCHAR* pszText );

VOID
DrTerm(
    IN HWND hwndDlg );

LRESULT APIENTRY
DpWndProc(
    HWND hwnd,
    UINT unMsg,
    WPARAM wParam,
    LPARAM lParam );

DWORD
FindEntryAndSetDialParams(
    IN DINFO* pInfo );


BOOL GetTerminateFlag(
    IN DPINFO * pInfo);

BOOL  SetTerminateFlag(
    IN DPINFO * pInfo);

BOOL  ResetTerminateFlag(
    IN DPINFO * pInfo);

BOOL  GetCallbackActive(
    IN DPINFO * pInfo);

BOOL  SetCallbackActive(
    IN DPINFO * pInfo);

BOOL  ResetCallbackActive(
    IN DPINFO * pInfo);

INT_PTR CALLBACK
PrDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
PrCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

BOOL
PrInit(
    IN HWND hwndDlg,
    IN PRARGS* pArgs );

BOOL
ProjectionResultDlg(
    IN HWND hwndOwner,
    IN TCHAR* pszLines,
    OUT BOOL* pfDisableFailedProtocols );

BOOL
RetryAuthenticationDlg(
    IN HWND hwndOwner,
    IN DINFO* pDinfo );

INT_PTR CALLBACK
UaDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
UaCommand(
    IN UAINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

BOOL
UaInit(
    IN HWND   hwndDlg,
    IN DINFO* pArgs );

VOID
UaSave(
    IN UAINFO* pInfo );

VOID
UaTerm(
    IN HWND hwndDlg );

BOOL
VpnDoubleDialDlg(
    IN HWND hwndOwner,
    IN DINFO* pInfo );

INT_PTR CALLBACK
ViDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
ViCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

BOOL
ViInit(
    IN HWND hwndDlg,
    IN DINFO* pInfo );


//-----------------------------------------------------------------------------
// External entry points
//-----------------------------------------------------------------------------

typedef struct EAPFREE_DATA {
    BOOL bInitialized;
    HINSTANCE hLib;
    RASEAPFREE pFreeFunc;
} EAPFREE_DATA;

//Add those OutputDebug_XXXX() functions for debug use when debugging 291613
//        gangz
//
void    OutputDebug_DWCODE(DWORD dwCode)
{
    WCHAR tmpBuf[100];

    wsprintf(tmpBuf, 
             L"The dwCode returned is %x\n", dwCode);
             
    OutputDebugStringW(tmpBuf);
}

void  OutputDebug_NumOfCallbacksActive(ULONG ulCallbacksActive)
{
    WCHAR tmpBuf[100];

    wsprintf(tmpBuf, 
             L"Current CallbacksActive is %x\n", 
             ulCallbacksActive);
             
    OutputDebugStringW(tmpBuf);
}

void OutputDebug_ThreadId()
{
    DWORD dwId;
    WCHAR tmpBuf[100];


    dwId = GetCurrentThreadId();
    
    wsprintf(tmpBuf, L"Current Thread is %x\n", dwId);
    OutputDebugStringW(tmpBuf);
  
}

void OutputDebug_ProcessThreadId()
{
    DWORD dwIdProc, dwIdThread;
    WCHAR tmpBuf[100];

    dwIdProc    = GetCurrentProcessId();
    dwIdThread  = GetCurrentThreadId();
    
    wsprintf(tmpBuf, L"Current Proc is: %x , Thread is: %x\n", dwIdProc, dwIdThread);
    OutputDebugStringW(tmpBuf);
  
}

//
// Raises the appriate eap indentity dialog
//
DWORD
DialerDlgEap (
    IN  HWND hwndOwner,
    IN  PWCHAR lpszPhonebook,
    IN  PWCHAR lpszEntry,
    IN  PBENTRY * pEntry,
    IN  DINFO *pInfo,
    OUT PBYTE * ppUserDataOut,
    OUT DWORD * lpdwSizeOfUserDataOut,
    OUT LPWSTR * lplpwszIdentity,
    OUT PHANDLE phFree
    )
{
    DWORD dwErr = NO_ERROR, dwInSize = 0;
    PBYTE pbUserIn = NULL;
    HINSTANCE hLib = NULL;
    EAPFREE_DATA * pFreeData = NULL;
    DTLLIST * pListEaps = NULL;
    DTLNODE * pEapcfgNode = NULL;
    EAPCFG * pEapcfg = NULL;
    RASEAPFREE pFreeFunc = NULL;
    RASEAPGETIDENTITY pIdenFunc = NULL;
    DWORD dwFlags;
    DWORD cbData = 0;
    PBYTE pbData = NULL;

    // Initialize the free data handle we'll return
    pFreeData  = Malloc ( sizeof(EAPFREE_DATA) );
    if (pFreeData == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;
    ZeroMemory( pFreeData, sizeof(EAPFREE_DATA) );

    // Make sure we're configured with some list of
    // eap configuration options
    pListEaps = ReadEapcfgList( NULL );
    if (pListEaps == NULL)
    {
        Free(pFreeData);
        return ERROR_CAN_NOT_COMPLETE;
    }

    // for whistler 522872, use __leave instead of directly return in the __try 
    // ..__finally block
    //
    __try {
        // Find the eap node we're interested in
        pEapcfgNode = EapcfgNodeFromKey(
                        pListEaps,
                        pEntry->dwCustomAuthKey );
        if (pEapcfgNode)
            pEapcfg = (EAPCFG*)DtlGetData( pEapcfgNode );
        else
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            __leave;
        }
                

        // Only call eap identity ui if we're told not to
        // get the user name through the standard credentials
        // dialog
        if (pEapcfg->dwStdCredentialFlags &
               EAPCFG_FLAG_RequireUsername)
        {
            dwErr = NO_ERROR;
            __leave;
        }

        if(!pInfo->pNoUser)
        {
            // Get the size of the input user data
            dwErr = RasGetEapUserData(
                        NULL,
                        lpszPhonebook,
                        lpszEntry,
                        NULL,
                        &dwInSize);

            // Read in the user data
            if (dwErr != NO_ERROR) 
            {
                if (dwErr == ERROR_BUFFER_TOO_SMALL) 
                {
                    if (dwInSize == 0)
                    {
                        pbUserIn = NULL;
                        // return ERROR_CAN_NOT_COMPLETE;
                    }
                    else
                    {
                        // Allocate a blob to hold the data
                        pbUserIn = Malloc (dwInSize);
                        if (pbUserIn == NULL)
                        {
                            dwErr = ERROR_NOT_ENOUGH_MEMORY;
                            __leave;
                        }

                        // Read in the new blob
                        dwErr = RasGetEapUserData(
                                    NULL,
                                    lpszPhonebook,
                                    lpszEntry,
                                    pbUserIn,
                                    &dwInSize);
                        if (dwErr != NO_ERROR)
                        {
                            __leave;
                        }
                    }
                }
                else
                {
                    __leave;
                }
            }
        }
        else
        {
            INTERNALARGS *piargs;

            piargs = (INTERNALARGS *) pInfo->pArgs->reserved;

            if(     (NULL != piargs)
                &&  (NULL != piargs->pvEapInfo)
                // pmay: 386489
                //
                &&  (pEntry->dwCustomAuthKey == EAPCFG_DefaultKey))
            {
                pbUserIn = (BYTE *) piargs->pvEapInfo;
                dwInSize = ((EAPLOGONINFO *) piargs->pvEapInfo)->dwSize;
            }
            else
            {
                pbUserIn = NULL;
                dwInSize = 0;
            }
        }

        // Load the identity library
        hLib = LoadLibrary (pEapcfg->pszIdentityDll);
        if (hLib == NULL)
       {
            dwErr = GetLastError();
            __leave;
       }

        // Get pointers to the functions we'll be needing
        pIdenFunc = (RASEAPGETIDENTITY)
                        GetProcAddress(hLib, "RasEapGetIdentity");
        pFreeFunc = (RASEAPFREE) GetProcAddress(hLib, "RasEapFreeMemory");
        if ( (pFreeFunc == NULL) || (pIdenFunc == NULL) )
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            __leave;
        }

        dwFlags = (pInfo->pNoUser) ? RAS_EAP_FLAG_LOGON : 0;
        if (!pEntry->fAutoLogon && pEntry->fPreviewUserPw)
        {
            dwFlags |= RAS_EAP_FLAG_PREVIEW;
        }

        if(pInfo->fUnattended)
        {
            dwFlags &= ~RAS_EAP_FLAG_PREVIEW;
        }
        
        dwErr = DwGetCustomAuthData(
                        pEntry,
                        &cbData,
                        &pbData);

        if(ERROR_SUCCESS != dwErr)
        {
            __leave;
        }

        // Call the eap-provided identity UI
        dwErr = (*(pIdenFunc))(
                    pEntry->dwCustomAuthKey,
                    hwndOwner,
                    dwFlags,
                    lpszPhonebook,
                    lpszEntry,
                    pbData,
                    cbData,
                    pbUserIn,
                    dwInSize,
                    ppUserDataOut,
                    lpdwSizeOfUserDataOut,
                    lplpwszIdentity);
        if (dwErr != NO_ERROR)
        {
            __leave;
        }

        // Assign the data used to cleanup later
        pFreeData->bInitialized = TRUE;
        pFreeData->hLib = hLib;
        pFreeData->pFreeFunc = pFreeFunc;
        *phFree = (HANDLE)pFreeData;
    }
    __finally {
        if (pListEaps)
        {
            DtlDestroyList(pListEaps, NULL);
        }
        
        if (    (!pInfo->pNoUser)
            &&  (pbUserIn))
        {
            Free0(pbUserIn);
        }
        
        if ((pFreeData) && (!pFreeData->bInitialized)) 
        {
            Free(pFreeData);
            if(NULL != hLib)
            {            
                FreeLibrary(hLib);
            }
        }
    }

    return dwErr;
}

DWORD
DialerEapCleanup (
    IN HANDLE hEapFree,
    IN PBYTE pUserDataOut,
    IN LPWSTR lpwszIdentity)
{
    EAPFREE_DATA * pFreeData = (EAPFREE_DATA*)hEapFree;

    if (pFreeData == NULL)
        return ERROR_INVALID_PARAMETER;

    if (pFreeData->pFreeFunc) {
        if (pUserDataOut)
            (*(pFreeData->pFreeFunc))(pUserDataOut);
        if (lpwszIdentity)
            (*(pFreeData->pFreeFunc))((BYTE*)lpwszIdentity);
    }

    if (pFreeData->hLib)
        FreeLibrary(pFreeData->hLib);

    Free (pFreeData);

    return NO_ERROR;
}

//
// Customizes the dialer flags for the eap provider
// of the given entry;
//
// TODO -- try to optimize this.  The list of eaps
// may not need to be read if we keep enough state
// in the phonebook.
//
DWORD DialerEapAssignMode(
        IN  DINFO* pInfo,
        OUT LPDWORD lpdwfMode)
{
    DWORD dwfMode = *lpdwfMode;
    DTLLIST * pListEaps;
    DTLNODE * pEapcfgNode;
    EAPCFG * pEapcfg;

    // If eap is not used in this entry,
    // then no action is required
    if (! (pInfo->pEntry->dwAuthRestrictions & AR_F_AuthEAP))
        return NO_ERROR;

    // Make sure we're configured with some list of
    // eap configuration options
    pListEaps = ReadEapcfgList( NULL );
    if (pListEaps == NULL)
        return ERROR_CAN_NOT_COMPLETE;

    // Find the eap node we're interested in
    pEapcfgNode = EapcfgNodeFromKey(
                    pListEaps,
                    pInfo->pEntry->dwCustomAuthKey );
    if (pEapcfgNode)
        pEapcfg = (EAPCFG*)DtlGetData( pEapcfgNode );
    else
    {
        if (pListEaps)
            DtlDestroyList(pListEaps, NULL);
    
        return ERROR_CAN_NOT_COMPLETE;
    }

    // If eap provider requests user name then
    // request identity.
    if (pEapcfg->dwStdCredentialFlags &
           EAPCFG_FLAG_RequireUsername
       )
    {
        // Use the "I" flavors if the eap wants a user
        // name but no password.  
        //
        if (!(pEapcfg->dwStdCredentialFlags &
               EAPCFG_FLAG_RequirePassword)
           )
        {
            // Clear the username+password property (DR_U) if it
            // exists and replace it with the username property 
            // (DR_I).  Only do this if DR_U is already set.  It
            // wont be set for autodial connections or for connections
            // where that option was specifically disabled as can
            // be seen in the DialerDlg function.
            //
            // See whistler bug 30841
            //
            if (dwfMode & DR_U)
            {
                dwfMode &= ~DR_U;
                dwfMode |= DR_I;
            }                
        }
    }
    else
    {
        // Otherwise, make sure that we request neither user name nor password
        // Since domain cannot appear without username clear that also.
        //
        dwfMode &= ~(DR_U | DR_D);

        // For whistler bug 500731      gangz
        if ( 0 == dwfMode &&
             (pInfo->pEntry->fPreviewUserPw)
            )
        {
            dwfMode |= DR_B;
        }
    }

    // Cleanup
    if (pListEaps)
        DtlDestroyList(pListEaps, NULL);

    // Assign the correct mode
    *lpdwfMode = dwfMode;

    return NO_ERROR;
}

BOOL APIENTRY
RasDialDlgA(
    IN LPSTR lpszPhonebook,
    IN LPSTR lpszEntry,
    IN LPSTR lpszPhoneNumber,
    IN OUT LPRASDIALDLG lpInfo )

    // Win32 ANSI entrypoint that displays the dial progress and related
    // dialogs, including authentication, error w/redial, callback, and retry
    // authentication.  'LpszPhonebook' is the full path the phonebook or NULL
    // indicating the default phonebook.  'LpszEntry' is the entry to dial.
    // 'LpszPhoneNumber' is caller's override phone number or NULL to use the
    // one in the entry.  'LpInfo' is caller's additional input/output
    // parameters.
    //
    // Returns true if user establishes a connection, false otherwise.
    //
{
    WCHAR* pszPhonebookW;
    WCHAR* pszEntryW;
    WCHAR* pszPhoneNumberW;
    BOOL fStatus;

    TRACE( "RasDialDlgA" );

    if (!lpInfo)
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (!lpszEntry)
    {
        lpInfo->dwError = ERROR_INVALID_PARAMETER;
        return FALSE;
    }

    if (lpInfo->dwSize != sizeof(RASDIALDLG))
    {
        lpInfo->dwError = ERROR_INVALID_SIZE;
        return FALSE;
    }

    // Thunk "A" arguments to "W" arguments.
    //
    if (lpszPhonebook)
    {
        pszPhonebookW = StrDupTFromAUsingAnsiEncoding( lpszPhonebook );
        if (!pszPhonebookW)
        {
            lpInfo->dwError = ERROR_NOT_ENOUGH_MEMORY;
            return FALSE;
        }
    }
    else
    {
        pszPhonebookW = NULL;
    }

    pszEntryW = StrDupTFromAUsingAnsiEncoding( lpszEntry );
    if (!pszEntryW)
    {
        Free0( pszPhonebookW );
        lpInfo->dwError = ERROR_NOT_ENOUGH_MEMORY;
        return FALSE;
    }

    if (lpszPhoneNumber)
    {
        pszPhoneNumberW = StrDupTFromAUsingAnsiEncoding( lpszPhoneNumber );
        if (!pszPhoneNumberW)
        {
            Free0( pszPhonebookW );
            Free( pszEntryW );
            lpInfo->dwError = ERROR_NOT_ENOUGH_MEMORY;
            return FALSE;
        }
    }
    else
    {
            pszPhoneNumberW = NULL;
    }

    // Thunk to the equivalent "W" API.
    //
    fStatus = RasDialDlgW( pszPhonebookW, pszEntryW, pszPhoneNumberW, lpInfo );

    Free0( pszPhonebookW );
    Free( pszEntryW );

    return fStatus;
}

DWORD
DoEapProcessing(
    LPRASDIALDLG lpInfo,
    DINFO *pInfo,
    PBYTE *ppbEapUserData,
    WCHAR **ppwszEapIdentity,
    HANDLE *phEapFree,
    BOOL *pfStatus
    )
{
    // If this is an eap connection, then use the eap identity
    // ui to get the user name and password. 
    //
    DWORD dwSize = 0;
    DWORD dwErr = NO_ERROR;

    *pfStatus = TRUE;
                
    // Bring up the Eap dialer dialog
    dwErr = DialerDlgEap(
                lpInfo->hwndOwner,
                pInfo->pFile->pszPath,
                pInfo->pEntry->pszEntryName,
                pInfo->pEntry,
                pInfo,
                ppbEapUserData,
                &dwSize,
                ppwszEapIdentity,
                phEapFree);

    if (dwErr != NO_ERROR)
    {
        if (ERROR_CANCELLED == dwErr)
        {
            dwErr = NO_ERROR;
        }

        *pfStatus = FALSE;

        goto done;
    }

    if(!pInfo->pNoUser)
    {
        // Set the extended dial params accordingly
        pInfo->rde.RasEapInfo.dwSizeofEapInfo = dwSize;
        pInfo->rde.RasEapInfo.pbEapInfo = *ppbEapUserData;
    }
    else if (   (*ppbEapUserData != NULL)
             && (dwSize != 0))
    {
        pInfo->rde.RasEapInfo.dwSizeofEapInfo = dwSize;
        pInfo->rde.RasEapInfo.pbEapInfo = *ppbEapUserData;
    }
    else
    {
        INTERNALARGS *piargs;

        piargs = (INTERNALARGS *) (pInfo->pArgs->reserved);
        if(     (NULL != piargs)
            &&  (NULL != piargs->pvEapInfo)
            // pmay: 386489
            //
            &&  (pInfo->pEntry->dwCustomAuthKey == EAPCFG_DefaultKey))
        {
            pInfo->rde.RasEapInfo.dwSizeofEapInfo =
                        ((EAPLOGONINFO *) piargs->pvEapInfo)->dwSize;

            pInfo->rde.RasEapInfo.pbEapInfo =  (BYTE *) piargs->pvEapInfo;
        }
        else
        {
            pInfo->rde.RasEapInfo.dwSizeofEapInfo = 0;
            pInfo->rde.RasEapInfo.pbEapInfo = NULL;
        }
    }

    if (*ppwszEapIdentity) 
    {
        DWORD dwSizeTmp =
            sizeof(pInfo->rdp.szUserName) / sizeof(WCHAR);

        wcsncpy(pInfo->rdp.szUserName, *ppwszEapIdentity,
            dwSizeTmp - 1);
        pInfo->rdp.szUserName[dwSizeTmp - 1] = 0;

        // Ignore the domain setting if the EAP supplied the 
        // identity.
        pInfo->rdp.szDomain[ 0 ] = L'\0';
    }

done:
    return dwErr;
}

INT
DialDlgDisplayError(
    IN LPRASDIALDLG pInfo,
    IN HWND hwndOwner, 
    IN DWORD dwSid, 
    IN DWORD dwError, 
    IN ERRORARGS* pArgs)
{
    if (pInfo->dwFlags & RASDDFLAG_NoPrompt)
    {
        return 0;
    }

    return ErrorDlg(hwndOwner, dwSid, dwError, pArgs);
}

BOOL APIENTRY
RasDialDlgW(
    IN LPWSTR lpszPhonebook,
    IN LPWSTR lpszEntry,
    IN LPWSTR lpszPhoneNumber,
    IN OUT LPRASDIALDLG lpInfo )

    // Win32 UNICODE entrypoint that displays the dial progress and related
    // dialogs, including authentication, error w/redial, callback, and retry
    // authentication.  'LpszPhonebook' is the full path the phonebook or NULL
    // indicating the default phonebook.  'LpszEntry' is the entry to dial.
    // 'LpszPhoneNumber' is caller's override phone number or NULL to use the
    // one in the entry.  'LpInfo' is caller's additional input/output
    // parameters.
    //
    // Returns true if user establishes a connection, false otherwise.  If
    // 'RASDDFLAG_AutoDialQueryOnly' is set, returns true if user pressed
    // "Dial", false otherwise.
    //
{
    DWORD dwErr;
    BOOL fStatus;
    BOOL fFirstPass;
    DINFO* pInfo;
    LPWSTR pwszEapIdentity = NULL;
    PBYTE pbEapUserData = NULL;
    HANDLE hEapFree = NULL;
    BOOL fCustom = FALSE;
    PVOID pvInfo = NULL;
    HRASCONN hrasconnPrereq = NULL;

    TRACE( "RasDialDlgW" );

    if (!lpInfo)
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (!lpszEntry)
    {
        lpInfo->dwError = ERROR_INVALID_PARAMETER;
        return FALSE;
    }

    if (lpInfo->dwSize != sizeof(RASDIALDLG))
    {
        lpInfo->dwError = ERROR_INVALID_SIZE;
        return FALSE;
    }

    if (lpszPhoneNumber && lstrlen( lpszPhoneNumber ) > RAS_MaxPhoneNumber)
    {
        lpInfo->dwError = ERROR_INVALID_PARAMETER;
        return FALSE;
    }

    // Load RAS DLL entrypoints which starts RASMAN, if necessary.
    //
    lpInfo->dwError = LoadRas( g_hinstDll, lpInfo->hwndOwner );
    if (lpInfo->dwError != 0)
    {
        // Whistler bug 301784
        //
        // Check specifically for access denied.  
        //
        if (lpInfo->dwError == ERROR_ACCESS_DENIED)
        {
            DialDlgDisplayError( 
                lpInfo,
                lpInfo->hwndOwner, 
                SID_OP_LoadRasAccessDenied, 
                lpInfo->dwError, 
                NULL );
        }
        else
        {
            DialDlgDisplayError(
                lpInfo,
                lpInfo->hwndOwner, 
                SID_OP_LoadRas, 
                lpInfo->dwError, 
                NULL );
        }       
        
        return FALSE;
    }

    // Allocate the context information block and initialize it enough so that
    // it can be destroyed properly.
    //
    pInfo = Malloc( sizeof(*pInfo) );
    if (!pInfo)
    {
        DialDlgDisplayError( 
            lpInfo,
            lpInfo->hwndOwner, 
            SID_OP_LoadDlg,
            ERROR_NOT_ENOUGH_MEMORY, 
            NULL );
            
        lpInfo->dwError = ERROR_NOT_ENOUGH_MEMORY;
        return FALSE;
    }

    ZeroMemory( pInfo, sizeof(*pInfo) );
    pInfo->pszPhonebook = lpszPhonebook;
    pInfo->pszEntry = lpszEntry;
    pInfo->pszPhoneNumber = lpszPhoneNumber;
    pInfo->pArgs = lpInfo;

    fStatus = FALSE;
    dwErr = 0;

    do
    {
        // Load the phonebook file and user preferences, or figure out that
        // caller has already loaded them.
        //
        if (lpInfo->reserved)
        {
            INTERNALARGS* piargs;

            // We've received an open phonebook file and user preferences via
            // the secret hack.
            //
            piargs = (INTERNALARGS* )lpInfo->reserved;
            pInfo->pFile = pInfo->pFileMain = piargs->pFile;
            pInfo->pUser = piargs->pUser;
            pInfo->pNoUser = piargs->pNoUser;
            pInfo->pfNoUserChanged = &piargs->fNoUserChanged;
            pInfo->fMoveOwnerOffDesktop = piargs->fMoveOwnerOffDesktop;
            pInfo->fForceCloseOnDial = piargs->fForceCloseOnDial;

        }
        else
        {
            // Read user preferences from registry.
            //
            dwErr = g_pGetUserPreferences( NULL, &pInfo->user, UPM_Normal );
            if (dwErr != 0)
            {
                DialDlgDisplayError( 
                    lpInfo,
                    lpInfo->hwndOwner, 
                    SID_OP_LoadPrefs, 
                    dwErr, 
                    NULL );
                    
                break;
            }

            pInfo->pUser = &pInfo->user;

            // Load and parse the phonebook file.
            //
            dwErr = ReadPhonebookFile(
                lpszPhonebook, &pInfo->user, NULL, 0, &pInfo->file );
            if (dwErr != 0)
            {
                DialDlgDisplayError( 
                    lpInfo,
                    lpInfo->hwndOwner, 
                    SID_OP_LoadPhonebook,
                    dwErr, 
                    NULL );
                break;
            }

            pInfo->pFile = pInfo->pFileMain = &pInfo->file;
        }

        // Record whether this is a for-all-users phonebook
        //
        // Whistler bug 288596 Autodial has wrong save password option marked -
        // prompts user to save password for all users
        //
        pInfo->fIsPublicPbk =
            (!pInfo->pszPhonebook) || IsPublicPhonebook(pInfo->pszPhonebook);

        if (!pInfo->pNoUser)
        {
            DWORD dwErrR;
            HKEY hkey;

            // See if admin has disabled the "save password" feature.
            //
            pInfo->fDisableSavePw = FALSE;

            dwErrR = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                TEXT("SYSTEM\\CurrentControlSet\\Services\\RasMan\\Parameters"),
                0, KEY_READ, &hkey );

            if (dwErrR == 0)
            {
                DWORD dwResult;

                dwResult = (DWORD )pInfo->fDisableSavePw;
                GetRegDword( hkey, TEXT("DisableSavePassword"), &dwResult );
                pInfo->fDisableSavePw = (BOOL )dwResult;

                RegCloseKey( hkey );
            }
        }

        // Hide parent dialog when initiated by another RAS API that requests
        // it.  This is the first stage of "close on dial" behavior, allowing
        // the parent to appear closed to user though, as owner, it must
        // really stay open until the dial dialogs complete.  At that point it
        // can silently close or reappear as desired.
        //
        if (lpInfo->hwndOwner && pInfo->fMoveOwnerOffDesktop)
        {
            SetOffDesktop( lpInfo->hwndOwner, SOD_MoveOff, NULL );
        }

        // Set true initially, but will be set false by
        // FindEntryAndSetDialParams if the entry has no "dial first" entry
        // associated with it.
        //
        pInfo->fPrerequisiteDial = TRUE;
        fFirstPass = TRUE;
        for (;;)
        {
            pInfo->fDialForReferenceOnly = FALSE;

            // Look up the entry and fill in the RASDIALPARAMS structure
            // accordingly.  This done as a routine so it can be re-done
            // should user press the Properties button.
            //
            dwErr = FindEntryAndSetDialParams( pInfo );
            if (dwErr != 0)
            {
                // we need to maintain 2 phonebooks
                // but we need to do this in case we break existing
                // apps which look specifically in system\ras dir.
                // Feel free to rip this code off, if you feel
                // strongly about it.
                //
                if(     (ERROR_CANNOT_FIND_PHONEBOOK_ENTRY == dwErr)
                    &&  (NULL == lpszPhonebook))
                {
                    DTLNODE *pNode;

                    //
                    // Close the all users phonebook file
                    //
                    ClosePhonebookFile(&pInfo->file);

                    dwErr = GetPbkAndEntryName(
                            lpszPhonebook,
                            lpszEntry,
                            0,
                            &pInfo->file,
                            &pNode);

                    if(     (NULL == pNode)
                        ||  (ERROR_SUCCESS != dwErr))
                    {
                        dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
                        break;
                    }

                    pInfo->pFile = pInfo->pFileMain = &pInfo->file;

                    dwErr = FindEntryAndSetDialParams(pInfo);

                    if(dwErr != 0)
                    {
                        break;
                    }
                }
                else
                {
                    break;
                }
            }

            if(lpInfo->reserved)
            {
                INTERNALARGS *piargs = (INTERNALARGS *) lpInfo->reserved;

                if (pInfo->pEntry->dwAuthRestrictions & AR_F_AuthEAP)
                {
                    pvInfo = piargs->pvEapInfo;
                }
                else
                {
                    pvInfo = piargs->pNoUser;
                }
            }

            if(pInfo->fPrerequisiteDial
               && (NULL != pInfo->pEntry->pszCustomDialerName)
               && (TEXT('\0') != pInfo->pEntry->pszCustomDialerName[0]))
            {
                RASDIALDLG Info;
                DWORD dwCustomFlags = 0;
                RASNOUSER nouser, *pNoUser = NULL;

                ZeroMemory(&Info, sizeof(RASDIALDLG));
                ZeroMemory(&nouser, sizeof(RASNOUSER));

                Info.dwSize = sizeof(RASDIALDLG);
                Info.hwndOwner = lpInfo->hwndOwner;
                Info.xDlg = lpInfo->xDlg;
                Info.yDlg = lpInfo->yDlg;

                fCustom = TRUE;

                if(pInfo->pEntry->dwAuthRestrictions & AR_F_AuthEAP)
                {
                    dwCustomFlags  |= RCD_Eap;
                }

                if(     (NULL != pInfo->pNoUser)
                    &&  (RASNOUSER_SmartCard & pInfo->pNoUser->dwFlags)
                    &&  (   (0 == (dwCustomFlags & RCD_Eap))
                        ||  (EAP_RASTLS != pInfo->pEntry->dwCustomAuthKey)
                    ))
                {
                    CopyMemory(&nouser, pInfo->pNoUser, sizeof(RASNOUSER));    
                    RtlSecureZeroMemory(nouser.szPassword, (PWLEN+1) * sizeof(TCHAR));
                    pvInfo = &nouser;
                }

                // DwCustomDialDlg returns ERROR_SUCCESS if it handled
                // the CustomRasDial. returns E_NOINTERFACE otherwise
                // which implies that there is no custom dlg interface
                // supported for this entry and the default dial should
                // happen
                //
                // Whistler bug 314578 When connecting with CM via Winlogon I
                // get the following error "Error 1:  Incorrect function"
                //
                // This is a case where we call into a custom dialer, ie CM,
                // and we are using creds that we got from winlogon. They are
                // currently encoded and must be decoded before we call out.
                // We have to assume that the Custom Dialer leaves the password
                // un-encoded upon return.
                //
                if ( !(pInfo->pEntry->dwAuthRestrictions & AR_F_AuthEAP) )
                {
                    // pNoUser is used to encode/decode passwords.  If this
                    // is an EAP connection, then pvInfo will point to an
                    // eap blob, not a "no user" blob.  
                    //
                    pNoUser = pvInfo;
                }                    
                if ( pNoUser )
                {
                    DecodePassword( pNoUser->szPassword );
                }

                if(pInfo->pNoUser)
                {
                    dwCustomFlags |= RCD_Logon;
                }

                dwErr = DwCustomDialDlg(pInfo->pFile->pszPath,
                                        pInfo->pEntry->pszEntryName,
                                        NULL,
                                        &Info,
                                        dwCustomFlags,
                                        &fStatus,
                                        pvInfo,
                                        pInfo->pEntry->pszCustomDialerName);
                if ( pNoUser )
                {
                    EncodePassword( pNoUser->szPassword );
                }

                if(!fStatus)
                {
                    lpInfo->dwError = Info.dwError;
                    break;
                }
                else
                {
                    pInfo->fPrerequisiteDial = FALSE;
                    fCustom = FALSE;
                    continue;
                }
            }
            else if ((NULL != pInfo->pEntry->pszCustomDialerName)
                    && (TEXT('\0') != pInfo->pEntry->pszCustomDialerName[0]))
            {
                DWORD dwCustomFlags = 0;
                RASNOUSER nouser, *pNoUser = NULL;

                ZeroMemory(&nouser, sizeof(RASNOUSER));

                if(pInfo->pEntry->dwAuthRestrictions & AR_F_AuthEAP)
                {
                    dwCustomFlags  |= RCD_Eap;
                }

                if(     (NULL != pInfo->pNoUser)
                    &&  (RASNOUSER_SmartCard & pInfo->pNoUser->dwFlags)
                    &&  (   (0 == (dwCustomFlags & RCD_Eap))
                        ||  (EAP_RASTLS != pInfo->pEntry->dwCustomAuthKey))
                    )
                {
                    CopyMemory(&nouser, pInfo->pNoUser, sizeof(RASNOUSER));
                    RtlSecureZeroMemory(nouser.szPassword, (PWLEN+1) * sizeof(TCHAR));
                    pvInfo = &nouser;
                }

                fCustom = TRUE;


                // DwCustomDialDlg returns ERROR_SUCCESS if it handled
                // the CustomRasDial. returns E_NOINTERFACE otherwise
                // which implies that there is no custom dlg interface
                // supported for this entry and the default dial should
                // happen
                //
                // Whistler bug 314578 When connecting with CM via Winlogon I
                // get the following error "Error 1:  Incorrect function"
                //
                // This is a case where we call into a custom dialer, ie CM,
                // and we are using creds that we got from winlogon. They are
                // currently encoded and must be decoded before we call out.
                // We have to assume that the Custom Dialer leaves the password
                // un-encoded upon return.
                //
                if ( !(pInfo->pEntry->dwAuthRestrictions & AR_F_AuthEAP) )
                {
                    // pNoUser is used to encode/decode passwords.  If this
                    // is an EAP connection, then pvInfo will point to an
                    // eap blob, not a "no user" blob.  
                    //
                    pNoUser = pvInfo;
                }                    
                if ( pNoUser )
                {
                    DecodePassword( pNoUser->szPassword );
                }

                if(pInfo->pNoUser)
                {
                    dwCustomFlags |= RCD_Logon;
                }

                dwErr = DwCustomDialDlg(lpszPhonebook,
                                        lpszEntry,
                                        lpszPhoneNumber,
                                        lpInfo,
                                        dwCustomFlags,
                                        &fStatus,
                                        pvInfo,
                                        pInfo->pEntry->pszCustomDialerName);
                if ( pNoUser )
                {
                    EncodePassword( pNoUser->szPassword );
                }

                break;
            }

            // If a prerequisite entry is already connected, there's no need
            // for any UI but the dial must occur to set the reference in the
            // RASAPI level.
            //
            if (pInfo->fPrerequisiteDial
                && HrasconnFromEntry(
                       pInfo->pFile->pszPath, pInfo->pEntry->pszEntryName ))
            {
                pInfo->fDialForReferenceOnly = TRUE;
            }

            // Set up extension parameter block, except 'hwndOwner' which is
            // set to the Dial Progress dialog window later.
            //
            {
                RASDIALEXTENSIONS* prde = &pInfo->rde;

                ZeroMemory( prde, sizeof(*prde) );
                prde->dwSize = sizeof(*prde);
                prde->dwfOptions = RDEOPT_PausedStates | RDEOPT_PauseOnScript;

                if (pInfo->pNoUser)
                {
                    prde->dwfOptions |= RDEOPT_NoUser;
                }

                if (!pInfo->pszPhoneNumber)
                {
                    prde->dwfOptions |= RDEOPT_UsePrefixSuffix;
                }
            }

            if (        (pInfo->fUnattended)
                &&      ((HaveSavedPw( pInfo ))
                    ||  (pInfo->pEntry->dwAuthRestrictions & AR_F_AuthEAP)))
            {
                // Popup the countdown to link failure redial version of the
                // dial error dialog, which will lead to a dial unless user
                // stops it.
                //
                fStatus = DialErrorDlg(
                    lpInfo->hwndOwner,
                    pInfo,                  // For whistler 474514
                    pInfo->pszPhonebook,    // For whislter 460931
                    pInfo->pEntry->pszEntryName,
                    0, 0, NULL, 0, NULL,
                    GetOverridableParam(
                        pInfo->pUser, pInfo->pEntry, RASOR_RedialSeconds ),
                    GetOverridableParam(
                        pInfo->pUser, pInfo->pEntry,
                        RASOR_PopupOnTopWhenRedialing ) );

                if(!fStatus)
                {
                    break;
                }
                        
                if (pInfo->pEntry->dwAuthRestrictions & AR_F_AuthEAP)
                {
                    dwErr = DoEapProcessing(
                                lpInfo,
                                pInfo,
                                &pbEapUserData,
                                &pwszEapIdentity,
                                &hEapFree,
                                &fStatus);

                    if(     (NO_ERROR != dwErr)
                        ||  (!fStatus))
                    {
                        break;
                    }
                }
                
            }
            else if (!pInfo->fDialForReferenceOnly)
            {
                if (!pInfo->fUnattended && fFirstPass)
                {
                    // Warn about active NWC LAN connections being blown away,
                    // if indicated.
                    //
                    if (!NwConnectionCheck(
                            lpInfo->hwndOwner,
                            (pInfo->pArgs->dwFlags & RASDDFLAG_PositionDlg),
                            pInfo->pArgs->xDlg, pInfo->pArgs->yDlg,
                            pInfo->pFile, pInfo->pEntry ))
                    {
                        break;
                    }

                    // Popup the double-dial help popup, if indicated.
                    //
                    if (!VpnDoubleDialDlg( lpInfo->hwndOwner, pInfo ))
                    {
                        break;
                    }
                }

                // Check to see if its smartcardlogon case and blank
                // out the password if its not an eap tls connectoid
                //
                if(     (NULL != pInfo->pNoUser)
                    &&  (RASNOUSER_SmartCard & pInfo->pNoUser->dwFlags)
                    &&  (pInfo->pEntry->dwCustomAuthKey != EAP_RASTLS))
                {
                    RtlSecureZeroMemory(pInfo->rdp.szPassword, (PWLEN+1) * sizeof(TCHAR));
                }

                // Prompt for credentials and/or phone number (or not)
                // as configured in the entry properties.
                //
                if (!DialerDlg( lpInfo->hwndOwner, pInfo ))
                {
                    if(!fFirstPass)
                    {
                        fStatus = FALSE;
                    }
                    break;
                }

                if (pInfo->pEntry->dwAuthRestrictions & AR_F_AuthEAP)
                {
                    dwErr = DoEapProcessing(
                                lpInfo,
                                pInfo,
                                &pbEapUserData,
                                &pwszEapIdentity,
                                &hEapFree,
                                &fStatus);

                    if(     (NO_ERROR != dwErr)
                        ||  (!fStatus))
                    {
                        break;
                    }
                }

                fStatus = TRUE;
            }
            else
            {
                fStatus = TRUE;
            }

            // Dial and show progress.
            //
            if (fStatus
                && !fCustom)
            {

                // Clear this here because beyond this rasman
                // will take care of dropping the prereq link
                // since beyond this point rasdial api will get
                // called. [raos]
                //
                hrasconnPrereq = NULL;

                fStatus = DialProgressDlg( pInfo );

                // Show connect complete dialog unless user has nixed it or
                // it's a prerequisite dial.
                // (AboladeG) Also suppress the dialog in no-prompt mode.
                //
                if (!pInfo->fPrerequisiteDial
                    && fStatus
                    && !pInfo->pUser->fSkipConnectComplete
                    && !(pInfo->pArgs->dwFlags & RASDDFLAG_NoPrompt))
                {
                    //For whistler bug 378078       gangz
                    //We will comment out this status explaination dialog
                    //box because some users complained that it is confusing
                    //
                    // ConnectCompleteDlg( lpInfo->hwndOwner, pInfo );
                }
            }

            // Don't loop a second time to dial the main entry if the
            // prerequisite dial failed.
            //
            if (!fStatus || !pInfo->fPrerequisiteDial)
            {
                break;
            }

            // Save the rasconn of the prereq dial in case we need to hang
            // it up for the case where the vpn dialog fails before rasdial
            // gets called. [raos]
            //
            if (pInfo->fPrerequisiteDial)
            {
                hrasconnPrereq = HrasconnFromEntry(
                   pInfo->pFile->pszPath, pInfo->pEntry->pszEntryName);
            }      
            

            pInfo->fPrerequisiteDial = FALSE;
            fFirstPass = FALSE;
            // Cleanup eap stuff
            if (hEapFree)
            {
                DialerEapCleanup(hEapFree, pbEapUserData, pwszEapIdentity);
                hEapFree = NULL;
                pbEapUserData = NULL;
                pwszEapIdentity = NULL;
            }
        }
    }
    while (FALSE);

    // Unhide parent dialog when initiated by another RAS API.
    //
    if (lpInfo->hwndOwner && pInfo->fMoveOwnerOffDesktop
        && (!fStatus
            || !(pInfo->pUser->fCloseOnDial || pInfo->fForceCloseOnDial)))
    {
        SetOffDesktop( lpInfo->hwndOwner, SOD_MoveBackFree, NULL );
    }

    if(!fCustom)
    {
        // Save the several little user preferences adjustments we may have made.
        //
        g_pSetUserPreferences(
            NULL, pInfo->pUser, (pInfo->pNoUser) ? UPM_Logon : UPM_Normal );

        // Report error, if any.
        //
        if (dwErr)
        {
            DialDlgDisplayError( 
                lpInfo,
                lpInfo->hwndOwner, 
                SID_OP_LoadDlg, 
                dwErr, 
                NULL );
            lpInfo->dwError = dwErr;
        }

        TRACE1("hrasconnPrereq=0x%x",hrasconnPrereq);

        //
        // Drop the connection if we failed to connect the vpn connection
        //
        if(     !fStatus
            &&  (NULL != hrasconnPrereq)
            &&  (pInfo->pEntry)
            &&  (pInfo->pEntry->pszPrerequisiteEntry)
            && *(pInfo->pEntry->pszPrerequisiteEntry))
        {
            g_pRasHangUp(hrasconnPrereq);
        }
    }

    // Clean up.
    //
    if (!lpInfo->reserved)
    {
        if (pInfo->pFileMain)
        {
            ClosePhonebookFile( pInfo->pFileMain );
        }

        if (pInfo->pUser)
        {
            DestroyUserPreferences( pInfo->pUser );
        }
    }

    if (pInfo->fFilePrereqOpen)
    {
        ClosePhonebookFile( &pInfo->filePrereq );
    }

    RtlSecureZeroMemory( pInfo->rdp.szPassword, sizeof(pInfo->rdp.szPassword) );
    if (pInfo->pListPortsToDelete)
    {
        DtlDestroyList( pInfo->pListPortsToDelete, DestroyPszNode );
    }

    if (hEapFree)
        DialerEapCleanup(hEapFree, pbEapUserData, pwszEapIdentity);
        
    Free( pInfo );
    pInfo = NULL;

    return fStatus;
}


//----------------------------------------------------------------------------
// Local utilities
// Listed alphabetically
//----------------------------------------------------------------------------

DWORD
RasCredToDialParam(
    IN  TCHAR* pszDefaultUserName,
    IN  TCHAR* pszDefaultDomain,
    IN  RASCREDENTIALS* pCreds,
    OUT RASDIALPARAMS* pParams)
{
    TCHAR* pszComputer = NULL;
    TCHAR* pszLogonDomain = NULL;
    TCHAR* pszUser = NULL;

    // Set the user name, defaulting it if needed
    //
    if (pCreds->dwMask & RASCM_UserName)
    {
        lstrcpyn(
            pParams->szUserName,
            pCreds->szUserName,
            sizeof(pParams->szUserName) / sizeof(TCHAR));
    }            
    else if (pszDefaultUserName)
    {
        lstrcpyn(
            pParams->szUserName,
            pszDefaultUserName,
            sizeof(pParams->szUserName) / sizeof(TCHAR));
    }
    else
    {
        pszUser = GetLogonUser();
        
        if (pszUser)
        {
            lstrcpyn(
                pParams->szUserName,
                pszUser,
                sizeof(pParams->szUserName) / sizeof(TCHAR));
        }
    }

    // Set the domain name, defaulting it if needed
    //
    if (pCreds->dwMask & RASCM_Domain)
    {
        lstrcpyn(
            pParams->szDomain,
            pCreds->szDomain,
            sizeof(pParams->szDomain) / sizeof(TCHAR));
    }            
    else if ( pszDefaultDomain )
    {
        lstrcpyn(
            pParams->szDomain,
            pszDefaultDomain,
            sizeof(pParams->szDomain) / sizeof(TCHAR));
    }
    else
    {
        pszComputer = GetComputer();
        pszLogonDomain = GetLogonDomain();
        
        if ( (pszComputer)      &&
             (pszLogonDomain)   && 
             (lstrcmp( pszComputer, pszLogonDomain ) != 0))
        {
            lstrcpyn( 
                pParams->szDomain, 
                pszLogonDomain,
                sizeof(pParams->szDomain) / sizeof(TCHAR));
        }
    }

    // Fill in the password field
    //
    if (pCreds->dwMask & RASCM_Password)
    {
        // Whistler bug 254385 encode password when not being used
        // Assumed password was encoded previously
        //
        DecodePassword( pCreds->szPassword );
        lstrcpyn(
            pParams->szPassword,
            pCreds->szPassword,
            sizeof(pParams->szPassword) / sizeof(TCHAR) );
        EncodePassword( pCreds->szPassword );
        EncodePassword( pParams->szPassword );
    }

    return NO_ERROR;
}

DWORD 
FindEntryCredentials(
    IN  TCHAR* pszPath,
    IN  TCHAR* pszEntryName,
    IN  TCHAR* pszDefaultUserName,
    IN  TCHAR* pszDefaultDomain,
    OUT RASDIALPARAMS* pUser,       // per user credentials
    OUT RASDIALPARAMS* pGlobal,     // global credentials
    OUT BOOL* pfUser,               // set true if per user creds found
    OUT BOOL* pfGlobal              // set true if global creds found
    )

// Loads the credentials for the given entry into memory.  This routine 
// determines whether per-user or per-connection credentials exist or 
// both. 
// 
// The logic is a little complicated because RasGetCredentials had to 
// support legacy usage of the API.
//
// Here's how it works.  If only one set of credentials is stored for a 
// connection, then RasGetCredentials will return that set regardless of 
// whether the RASCM_DefalutCreds flag is set.  If two sets of credentials
// are saved, then RasGetCredentials will return the per-user credentials
// if the RASCM_DefaultCreds bit is set, and the per-connection credentials
// otherwise.
//
// Here is the algorithm for loading the credentials
//
// 1. Call RasGetCredentials with the RASCM_DefaultCreds bit cleared
//    1a. If nothing is returned, no credentials are saved
//    1b. If the RASCM_DefaultCreds bit is set on return, then only
//        global credentials are saved.
//
// 2. Call RasGetCredentials with the RASCM_DefaultCreds bit set
//    2a. If the RASCM_DefaultCreds bit is set on return, then 
//        both global and per-connection credentials are saved.
//    2b. Otherwise, only per-user credentials are saved.
//
{
    DWORD dwErr;
    RASCREDENTIALS rc1, rc2;
    BOOL fUseLogonDomain;

    TRACE( "FindEntryCredentials" );

    // Initialize
    //
    *pfUser = FALSE;
    *pfGlobal = FALSE;
    ZeroMemory( &rc1, sizeof(rc1) );
    ZeroMemory( &rc2, sizeof(rc2) );
    rc1.dwSize = sizeof(rc1);
    rc2.dwSize = sizeof(rc2);

    do 
    {

        // Look up per-user cached username, password, and domain.
        // See comment '1.' in the function header
        //
        rc1.dwMask = RASCM_UserName | RASCM_Password | RASCM_Domain;
        ASSERT( g_pRasGetCredentials );
        TRACE( "RasGetCredentials per-user" );
        dwErr = g_pRasGetCredentials(pszPath, pszEntryName, &rc1 );
        TRACE2( "RasGetCredentials=%d,m=%d", dwErr, rc1.dwMask );
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // See 1a. in the function header comments
        //
        if (rc1.dwMask == 0)
        {
            // No credentials are saved.  pUser will be used for the 
            // connection in this case so initialize it to use the default
            // user name and domain name.  XP 446571
            //
            ZeroMemory(&rc1, sizeof(rc1));
            RasCredToDialParam(
                pszDefaultUserName,
                pszDefaultDomain,
                &rc1,
                pUser );
            
            dwErr = NO_ERROR;
            break;
        }

        // See 1b. in the function header comments
        //
        else if (rc1.dwMask & RASCM_DefaultCreds)
        {
            *pfGlobal = TRUE;

            // Whistler bug 254385 encode password when not being used
            // Assumed password was not encoded by RasGetCredentials()
            //
            EncodePassword( rc1.szPassword );
            RasCredToDialParam(
                pszDefaultUserName,
                pszDefaultDomain,
                &rc1,
                pGlobal );

            dwErr = NO_ERROR;
            break;
        }

        // Look up global per-user cached username, password, domain.
        // See comment 2. in the function header
        //
        rc2.dwMask =  
            RASCM_UserName | RASCM_Password | RASCM_Domain | RASCM_DefaultCreds;
        ASSERT( g_pRasGetCredentials );
        TRACE( "RasGetCredentials global" );
        dwErr = g_pRasGetCredentials(pszPath, pszEntryName, &rc2 );
        TRACE2( "RasGetCredentials=%d,m=%d", dwErr, rc2.dwMask );
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // See 2a. in the function header comments
        //
        if (rc2.dwMask & RASCM_DefaultCreds)
        {
            *pfGlobal = TRUE;

            if (rc1.dwMask & RASCM_Password)
            {
                *pfUser = TRUE;
            }

            // Whistler bug 254385 encode password when not being used
            // Assumed password was not encoded by RasGetCredentials()
            //
            EncodePassword( rc1.szPassword );
            RasCredToDialParam(
                pszDefaultUserName,
                pszDefaultDomain,
                &rc1,
                pUser );

            EncodePassword( rc2.szPassword );
            RasCredToDialParam(
                pszDefaultUserName,
                pszDefaultDomain,
                &rc2,
                pGlobal );
        }

        // See 2b. in the function header comments
        //
        else
        {
            if (rc1.dwMask & RASCM_Password)
            {
                *pfUser = TRUE;
            }

            // Whistler bug 254385 encode password when not being used
            // Assumed password was not encoded by RasGetCredentials()
            //
            EncodePassword( rc1.szPassword );
            RasCredToDialParam(
                pszDefaultUserName,
                pszDefaultDomain,
                &rc1,
                pUser );
        }

    }while (FALSE);

    // Cleanup
    //
    {
        // Whistler bug 254385 encode password when not being used
        //
        RtlSecureZeroMemory( rc1.szPassword, sizeof(rc1.szPassword) );
        RtlSecureZeroMemory( rc2.szPassword, sizeof(rc2.szPassword) );
    }

    return dwErr;
}

DWORD
FindEntryAndSetDialParams(
    IN DINFO* pInfo )

    // Look up the entry and fill in the RASDIALPARAMS parameters accordingly.
    // This routine contains all DINFO context initialization that can be
    // affected by user actions on the property sheet.  'PInfo' is the
    // partially initialized common dial dialog context.
    //
    // 'pInfo->fPrerequisiteDial'is set at entry if the prerequisite entry, if
    // any, should be dialed first.  If there is no prerequisite entry, the
    // flag is cleared and the main entry dialed.
    //
{
    DWORD dwErr = NO_ERROR;
    RASDIALPARAMS* prdp, *prdpu, *prdpg;

    if (pInfo->fFilePrereqOpen)
    {
        ClosePhonebookFile( pInfo->pFile );
        pInfo->pFile = pInfo->pFileMain;
        pInfo->fFilePrereqOpen = FALSE;
    }

    // Lookup entry node specified by caller and save reference for
    // convenience elsewhere.
    //
    pInfo->pNode = EntryNodeFromName(
        pInfo->pFile->pdtllistEntries, pInfo->pszEntry );
    if (!pInfo->pNode)
    {
        dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
        return dwErr;
    }

    pInfo->pEntry = pInfo->pEntryMain = (PBENTRY* )DtlGetData( pInfo->pNode );
    ASSERT( pInfo->pEntry );

    // Switch to the prerequisite entry, if indicated.
    //
    if (pInfo->fPrerequisiteDial)
    {
        if (pInfo->pEntry->pszPrerequisiteEntry
            && *(pInfo->pEntry->pszPrerequisiteEntry))
        {
            ASSERT( !pInfo->fFilePrereqOpen );

            // GetPbkAndEntryName first looks in the All Users phonebook file
            // if a phonebook file is not specified.  If the entry is not
            // found there it looks in files present in the Users profile.
            // This needs to be done since we are discontinuing the per-user
            // pbk file being set through user preferences.
            //
            dwErr = GetPbkAndEntryName(
                    pInfo->pEntry->pszPrerequisitePbk,
                    pInfo->pEntry->pszPrerequisiteEntry,
                    0,
                    &pInfo->filePrereq,
                    &pInfo->pNode);

            if (dwErr != 0)
            {
                return dwErr;
            }

            pInfo->pFile = &pInfo->filePrereq;
            pInfo->fFilePrereqOpen = TRUE;

            pInfo->pEntry = (PBENTRY* )DtlGetData( pInfo->pNode );
            ASSERT( pInfo->pEntry );
        }
        else
        {
            pInfo->fPrerequisiteDial = FALSE;
        }
    }

    // Set up RasDial parameter blocks.
    //
    prdp = &pInfo->rdp;
    prdpu = &pInfo->rdpu;
    prdpg = &pInfo->rdpg;
    ZeroMemory( prdp, sizeof(*prdp) );
    pInfo->fUnattended = FALSE;
    prdp->dwSize = sizeof(*prdp);
    
    lstrcpyn( 
        prdp->szEntryName, 
        pInfo->pEntry->pszEntryName,  
        sizeof(prdp->szEntryName) / sizeof(TCHAR));

    if (pInfo->pszPhoneNumber)
    {
        lstrcpyn( 
            prdp->szPhoneNumber, 
            pInfo->pszPhoneNumber,
            RAS_MaxPhoneNumber + 1);
    }

    // Whistler bug 272819 Not prompted for callback number
    // We must do this before the init of per-user and global variants
    //
    if (!pInfo->fUnattended)
    {
        // '*' means "behave as defined in user preferences", while leaving it
        // zero would mean "don't request callback if server offers".
        //
        // Whistler bug 224074 use only lstrcpyn's to prevent maliciousness
        //
        lstrcpyn(
            prdp->szCallbackNumber,
            TEXT("*"),
            sizeof(prdp->szCallbackNumber) / sizeof(TCHAR) );
    }

    // Initialze the per-user and global variants
    //
    CopyMemory(prdpu, prdp, sizeof(*prdp));
    CopyMemory(prdpg, prdp, sizeof(*prdp));

    // Set the subentry link to whatever the RasDialDlg caller specified.  See
    // bug 200351.
    //
    prdp->dwSubEntry = pInfo->pArgs->dwSubEntry;

    // If running in "unattended" mode, i.e. called by RASAUTO to redial on
    // link failure, read the user/password/domain and callback number used on
    // the original call.  (Actually found a use for the crappy
    // RasGetEntryDialParams API)
    //
    if (pInfo->pArgs->dwFlags & RASDDFLAG_LinkFailure)
    {
        RASDIALPARAMS rdp;
        BOOL fSavedPw = HaveSavedPw( pInfo );

        ZeroMemory( &rdp, sizeof(rdp) );
        rdp.dwSize = sizeof(rdp);
        
        lstrcpyn( 
            rdp.szEntryName, 
            pInfo->pEntry->pszEntryName,
            sizeof(rdp.szEntryName) / sizeof(TCHAR) 
            );

        //For whistler bug 313509			gangz
        //We use FindEntryCredentials() to get saved password perUser and 
        //perConnection inforation, use RasGetEntryDialParams() to get back
        //Callback Numbers
        //
       {
            RASDIALPARAMS rdTemp; 
            TCHAR * pszTempUser, * pszTempDomain;

            pszTempUser = pszTempDomain = NULL;
            TRACE("FindEntryCredentials");
            dwErr = FindEntryCredentials(
                        pInfo->pFile->pszPath,
                        pInfo->pEntry->pszEntryName,
                        pszTempUser,
                        pszTempDomain,                    
                        &rdTemp,
                        &rdTemp,
                        &(pInfo->fHaveSavedPwUser),
                        &(pInfo->fHaveSavedPwGlobal));
            
             TRACE1("FindEntryCredentials=%d", dwErr);
             ZeroMemory( &rdTemp, sizeof(rdTemp) );
             Free0(pszTempUser);
             Free0(pszTempDomain);
        }
        
        
        TRACE( "RasGetEntryDialParams" );
        ASSERT( g_pRasGetEntryDialParams );
        dwErr = g_pRasGetEntryDialParams(
            pInfo->pFile->pszPath, &rdp, &fSavedPw );
        TRACE2( "RasGetEntryDialParams=%d,f=%d", dwErr, &fSavedPw );
        TRACEW1( "u=%s", rdp.szUserName );
        //TRACEW1( "p=%s", rdp.szPassword );
        TRACEW1( "d=%s", rdp.szDomain );
        TRACEW1( "c=%s", rdp.szCallbackNumber );

        if (dwErr == 0)
        {
            lstrcpyn( 
                prdp->szUserName, 
                rdp.szUserName,
                sizeof(prdp->szUserName) / sizeof(TCHAR));

            // Whistler bug 254385 encode password when not being used
            // Assumed password was not encoded by RasGetEntryDialParams()
            //
            lstrcpyn(
                prdp->szPassword,
                rdp.szPassword,
                sizeof(prdp->szPassword) / sizeof(TCHAR) );
            EncodePassword( prdp->szPassword );

            lstrcpyn( 
                prdp->szDomain, 
                rdp.szDomain,
                sizeof(prdp->szDomain) / sizeof(TCHAR));
            lstrcpyn( 
                prdp->szCallbackNumber, 
                rdp.szCallbackNumber,
                sizeof(prdp->szCallbackNumber) / sizeof(TCHAR));

			
            pInfo->fUnattended = TRUE;
        }

        RtlSecureZeroMemory( rdp.szPassword, sizeof(rdp.szPassword) );
    }

    if (pInfo->pNoUser)
    {
        // Use the credentials we got from API caller, presumably the ones
        // entered at Ctrl-Alt-Del.
        //
        lstrcpyn( 
            prdp->szUserName, 
            pInfo->pNoUser->szUserName,
            sizeof(prdp->szUserName) / sizeof(TCHAR));

        //
        // Don't copy the password if its smartcard logon 
        // and the entry being used is a non-eap connectoid
        //
        // Whistler bug 254385 encode password when not being used
        // Assumed password was encoded by caller of RasDialDlg()
        //
        DecodePassword( pInfo->pNoUser->szPassword );
        
        lstrcpyn(
            prdp->szPassword,
            pInfo->pNoUser->szPassword,
            sizeof(prdp->szPassword) / sizeof(TCHAR) );
        EncodePassword( pInfo->pNoUser->szPassword );
        EncodePassword( prdp->szPassword );

        if (pInfo->pEntry->fPreviewDomain)
        {
            lstrcpyn( 
                prdp->szDomain, 
                pInfo->pNoUser->szDomain,
                sizeof(prdp->szDomain) / sizeof(TCHAR));
        }
        else
        {
            // Don't use Winlogon domain unless "include domain" option is
            // selected.  See bug 387266.
            //
            // Whistler bug 224074 use only lstrcpyn's to prevent maliciousness
            //
            lstrcpyn(
                prdp->szDomain,
                TEXT(""),
                sizeof(prdp->szDomain) / sizeof(TCHAR) );
        }
    }
    else if (!pInfo->fUnattended)
    {
        DWORD dwErrRc;
        BOOL fUseLogonDomain;
        TCHAR* pszDefaultUser;

        dwErrRc = FindEntryCredentials(
                    pInfo->pFile->pszPath,
                    pInfo->pEntry->pszEntryName,
                    pInfo->pEntry->pszOldUser,
                    pInfo->pEntry->pszOldDomain,                    
                    prdpu,
                    prdpg,
                    &(pInfo->fHaveSavedPwUser),
                    &(pInfo->fHaveSavedPwGlobal));

        if (! pInfo->pEntry->fAutoLogon)
        {
            // If saved passwords are disabled, clear here
            //
            if (pInfo->fDisableSavePw)
            {
                pInfo->fHaveSavedPwUser = FALSE;
                pInfo->fHaveSavedPwGlobal = FALSE;
                RtlSecureZeroMemory(prdp->szPassword, sizeof(prdp->szPassword));
                RtlSecureZeroMemory(prdpu->szPassword, sizeof(prdpu->szPassword));
                RtlSecureZeroMemory(prdpg->szPassword, sizeof(prdpg->szPassword));
            }

            // If including domains is disabled, clear here
            //
            if (! pInfo->pEntry->fPreviewDomain)
            {
                // (SteveC) Don't do this in the 'fAutoLogon' case.  See bug
                // 207611.
                //
                ZeroMemory(prdp->szDomain, sizeof(prdp->szDomain));
                ZeroMemory(prdpu->szDomain, sizeof(prdpu->szDomain));
                ZeroMemory(prdpg->szDomain, sizeof(prdpg->szDomain));
            }
        }
        
        if(!pInfo->pEntry->fAutoLogon)
        {
            // Initialize the dial params that will be passed to RasDial.
            //
            // Note that per-user credentials are always used when both 
            // per-user and global credentials are saved.  The per-user
            // credentials should be copied even if there is no saved 
            // password since there may be a saved identity.
            //
            CopyMemory(prdp, prdpu, sizeof(*prdp));
            if (pInfo->fHaveSavedPwGlobal && !pInfo->fHaveSavedPwUser)
            {
                CopyMemory(prdp, prdpg, sizeof(*prdp));
            }
        }
    }

    return 0;
}

//----------------------------------------------------------------------------
// Bundling Errors dialog
// Listed alphabetically following stub API and dialog proc
//----------------------------------------------------------------------------

BOOL
BundlingErrorsDlg(
    IN OUT DPINFO* pInfo )

    // Popup the Bundling Errors dialog.  'PInfo' is the dialing progress
    // dialog context.
    //
    // Returns true if user chooses to accept the results or false if he
    // chooses to hang up.
    //
{
    INT_PTR nStatus;

    TRACE( "BundlingErrorsDlg" );

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_BE_BundlingErrors ),
            pInfo->hwndDlg,
            BeDlgProc,
            (LPARAM )pInfo );

    if (nStatus == -1)
    {
        ErrorDlg( pInfo->hwndDlg, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
BeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Bundling Errors dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "BeDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    if (ListView_OwnerHandler(
            hwnd, unMsg, wparam, lparam, BeLvErrorsCallback ))
    {
        return TRUE;
    }

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return BeInit( hwnd, (DPINFO* )lparam );
        }

        case WM_COMMAND:
        {
            return BeCommand(
                hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}


BOOL
BeCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    // the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    DWORD dwErr;

    TRACE3( "BeCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case IDOK:
        case IDCANCEL:
        {
            TRACE1( "%s pressed", (wId==IDOK) ? "OK" : "Cancel" );

            if (IsDlgButtonChecked( hwnd, CID_BE_CB_DisableLink ))
            {
                DWORD i;
                DPINFO* pInfo;
                DPSTATE* pState;

                // Caller says to delete the links that failed in the entry.
                // Create a list of Psz nodes containing the unique port name
                // of each failed link so they can be removed after the state
                // information is freed.
                //
                pInfo = (DPINFO* )GetWindowLongPtr( hwnd, DWLP_USER );

                for (i = 0, pState = pInfo->pStates;
                     i < pInfo->cStates;
                     ++i, ++pState)
                {
                    DTLNODE* pNode;
                    DTLNODE* pNodePtd;
                    PBLINK* pLink;

                    if (pState->dwError != 0)
                    {
                        if (!pInfo->pArgs->pListPortsToDelete)
                        {
                            pInfo->pArgs->pListPortsToDelete =
                                DtlCreateList( 0L );
                            if (!pInfo->pArgs->pListPortsToDelete)
                            {
                                continue;
                            }
                        }

                        pNode = DtlNodeFromIndex(
                            pInfo->pArgs->pEntry->pdtllistLinks, (LONG )i );
                        if (!pNode)
                        {
                            continue;
                        }

                        pLink = (PBLINK* )DtlGetData( pNode );

                        pNodePtd = CreatePszNode( pLink->pbport.pszPort );
                        if (!pNodePtd)
                        {
                            continue;
                        }

                        DtlAddNodeLast(
                            pInfo->pArgs->pListPortsToDelete, pNodePtd );
                    }
                }
            }

            EndDialog( hwnd, (wId == IDOK) );
            return TRUE;
        }
    }

    return FALSE;
}


VOID
BeFillLvErrors(
    IN HWND hwndLv,
    IN DPINFO* pInfo )

    // Fill the listview 'hwndLv' with devices and error strings and select
    // the first item.  'PInfo' is the dialing progress dialog context.
    //
{
    INT iItem;
    DWORD i;
    DPSTATE* pState;

    TRACE( "BeFillLvErrors" );

    ListView_DeleteAllItems( hwndLv );

    // Add columns.
    //
    {
        LV_COLUMN col;
        TCHAR* pszHeader0;
        TCHAR* pszHeader1;

        pszHeader0 = PszFromId( g_hinstDll, SID_DeviceColHead );
        pszHeader1 = PszFromId( g_hinstDll, SID_StatusColHead );

        ZeroMemory( &col, sizeof(col) );
        col.mask = LVCF_FMT + LVCF_TEXT;
        col.fmt = LVCFMT_LEFT;
        col.pszText = (pszHeader0) ? pszHeader0 : TEXT("");
        ListView_InsertColumn( hwndLv, 0, &col );

        ZeroMemory( &col, sizeof(col) );
        col.mask = LVCF_FMT + LVCF_SUBITEM + LVCF_TEXT;
        col.fmt = LVCFMT_LEFT;
        col.pszText = (pszHeader1) ? pszHeader1 : TEXT("");
        col.iSubItem = 1;
        ListView_InsertColumn( hwndLv, 1, &col );

        Free0( pszHeader0 );
        Free0( pszHeader1 );
    }

    // Add the modem and adapter images.
    //
    ListView_SetDeviceImageList( hwndLv, g_hinstDll );

    // Load listview with device/status pairs.
    //
    iItem = 0;
    for (i = 0, pState = pInfo->pStates; i < pInfo->cStates; ++i, ++pState)
    {
        LV_ITEM item;
        DTLNODE* pNode;
        PBLINK* pLink;
        TCHAR* psz;

        pNode = DtlNodeFromIndex(
            pInfo->pArgs->pEntry->pdtllistLinks, (LONG )i );
        if (pNode)
        {
            pLink = (PBLINK* )DtlGetData( pNode );

            psz = DisplayPszFromDeviceAndPort(
                      pLink->pbport.pszDevice, pLink->pbport.pszPort );
            if (psz)
            {
                ZeroMemory( &item, sizeof(item) );
                item.mask = LVIF_TEXT + LVIF_IMAGE;
                item.iItem = iItem;
                item.pszText = psz;
                item.iImage =
                    (pLink->pbport.pbdevicetype == PBDT_Modem)
                        ? DI_Modem : DI_Adapter;
                ListView_InsertItem( hwndLv, &item );
                Free( psz );

                if (pState->dwError == 0)
                {
                    psz = PszFromId( g_hinstDll, SID_Connected );
                    ListView_SetItemText( hwndLv, iItem, 1, psz );
                    Free( psz );
                }
                else
                {
                    psz = BeGetErrorPsz( pState->dwError );
                    ListView_SetItemText( hwndLv, iItem, 1, psz );
                    LocalFree( psz );
                }

                ++iItem;
            }
        }
    }

    // Auto-size columns to look good with the text they contain.
    //
    ListView_SetColumnWidth( hwndLv, 0, LVSCW_AUTOSIZE_USEHEADER );
    ListView_SetColumnWidth( hwndLv, 1, LVSCW_AUTOSIZE_USEHEADER );

    // Select the first item.
    //
    ListView_SetItemState( hwndLv, 0, LVIS_SELECTED, LVIS_SELECTED );
}


TCHAR*
BeGetErrorPsz(
    IN DWORD dwError )

    // Returns a string suitable for the Status column with error 'dwError' or
    // NULL on error.  'DwError' is assumed to be non-0.  It is caller's
    // responsiblility to LocalFree the returned string.
    //
{
    TCHAR* pszErrStr;
    TCHAR szErrNumBuf[ MAXLTOTLEN + 1 ];
    TCHAR* pszLineFormat;
    TCHAR* pszLine;
    TCHAR* apszArgs[ 2 ];

    LToT( dwError, szErrNumBuf, 10 );

    pszErrStr = NULL;
    GetErrorText( dwError, &pszErrStr );

    pszLine = NULL;
    pszLineFormat = PszFromId( g_hinstDll, SID_FMT_Error );
    if (pszLineFormat)
    {
        apszArgs[ 0 ] = szErrNumBuf;
        apszArgs[ 1 ] = (pszErrStr) ? pszErrStr : TEXT("");

        FormatMessage(
            FORMAT_MESSAGE_FROM_STRING
                | FORMAT_MESSAGE_ALLOCATE_BUFFER
                | FORMAT_MESSAGE_ARGUMENT_ARRAY,
            pszLineFormat, 0, 0, (LPTSTR )&pszLine, 1,
            (va_list* )apszArgs );

        Free( pszLineFormat );
    }

    Free0( pszErrStr );
    return pszLine;
}


BOOL
BeInit(
    IN HWND hwndDlg,
    IN DPINFO* pArgs )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    // 'PArgs' is caller's arguments to the stub API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    HWND hwndLvErrors;
    HWND hwndCbDisableLink;

    TRACE( "BeInit" );

    hwndLvErrors = GetDlgItem( hwndDlg, CID_BE_LV_Errors );
    ASSERT( hwndLvErrors );
    hwndCbDisableLink = GetDlgItem( hwndDlg, CID_BE_CB_DisableLink );
    ASSERT( hwndCbDisableLink );

    // Save Dial Progress context as dialog context.
    //
    SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pArgs );

    // Load listview with device/error information.
    //
    BeFillLvErrors( hwndLvErrors, pArgs );

    // Display the finished window above all other windows.  The window
    // position is set to "topmost" then immediately set to "not topmost"
    // because we want it on top but not always-on-top.  Always-on-top alone
    // is incredibly annoying, e.g. it is always on top of the on-line help if
    // user presses the Help button.
    //
    SetWindowPos(
        hwndDlg, HWND_TOPMOST, 0, 0, 0, 0,
        SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE );

    CenterWindow( hwndDlg, GetParent( hwndDlg ) );
    ShowWindow( hwndDlg, SW_SHOW );

    SetWindowPos(
        hwndDlg, HWND_NOTOPMOST, 0, 0, 0, 0,
        SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE );

    SetFocus( hwndCbDisableLink );
    return FALSE;
}


LVXDRAWINFO*
BeLvErrorsCallback(
    IN HWND hwndLv,
    IN DWORD dwItem )

    // Enhanced list view callback to report drawing information.  'HwndLv' is
    // the handle of the list view control.  'DwItem' is the index of the item
    // being drawn.
    //
    // Returns the address of the column information.
    //
{
    // Use "wide selection bar" feature and the other recommended options.
    //
    // Fields are 'nCols', 'dxIndent', 'dwFlags', 'adwFlags[]'.
    //
    static LVXDRAWINFO info =
        { 2, 0, LVXDI_Blend50Dis + LVXDI_DxFill, { 0, 0 } };

    return &info;
}


//----------------------------------------------------------------------------
// Change Password dialog
// Listed alphabetically following stub API and dialog proc
//----------------------------------------------------------------------------

BOOL
ChangePasswordDlg(
    IN HWND hwndOwner,
    IN BOOL fOldPassword,
    OUT TCHAR* pszOldPassword,
    OUT TCHAR* pszNewPassword )

    // Popup the Change Password dialog.  'HwndOwner' is the owning window.
    // 'FOldPassword' is set true if user must supply an old password, false
    // if no old password is required.  'PszOldPassword' and 'pszNewPassword'
    // are caller's buffers for the returned passwords.
    //
    // Returns true if user presses OK and succeeds, false otherwise.
    //
{
    INT_PTR nStatus;
    CPARGS args;

    TRACE( "ChangePasswordDlg" );

    args.fOldPassword = fOldPassword;
    args.pszOldPassword = pszOldPassword;
    args.pszNewPassword = pszNewPassword;

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            (fOldPassword)
                ? MAKEINTRESOURCE( DID_CP_ChangePassword2 )
                : MAKEINTRESOURCE( DID_CP_ChangePassword ),
            hwndOwner,
            CpDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
CpDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Change Password dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "CpDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return CpInit( hwnd, (CPARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwCpHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            return CpCommand(
                hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}


BOOL
CpCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    // the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    DWORD dwErr;

    TRACE3( "CpCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case IDOK:
        {
            CPWINFO* pInfo;
            TCHAR szNewPassword[ PWLEN + 1 ];
            TCHAR szNewPassword2[ PWLEN + 1 ];

            TRACE( "OK pressed" );

            pInfo = (CPWINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            szNewPassword[ 0 ] = TEXT('\0');
            GetWindowText(
                pInfo->hwndEbNewPassword, szNewPassword, PWLEN + 1 );
            szNewPassword2[ 0 ] = TEXT('\0');
            GetWindowText(
                pInfo->hwndEbNewPassword2, szNewPassword2, PWLEN + 1 );

            if (lstrcmp( szNewPassword, szNewPassword2 ) != 0)
            {
                // The two passwords don't match, i.e. user made a typo.  Make
                // him re-enter.
                //
                MsgDlg( hwnd, SID_PasswordsDontMatch, NULL );
                SetWindowText( pInfo->hwndEbNewPassword, TEXT("") );
                SetWindowText( pInfo->hwndEbNewPassword2, TEXT("") );
                SetFocus( pInfo->hwndEbNewPassword );
                RtlSecureZeroMemory( szNewPassword, sizeof(szNewPassword) );
                RtlSecureZeroMemory( szNewPassword2, sizeof(szNewPassword2) );
                return TRUE;
            }

            if (pInfo->pArgs->fOldPassword)
            {
                pInfo->pArgs->pszOldPassword[ 0 ] = TEXT('\0');

                // Whistler bug 254385 encode password when not being used
                // Assumed password was not encoded by GetWindowText()
                //
                GetWindowText(
                    pInfo->hwndEbOldPassword,
                    pInfo->pArgs->pszOldPassword,
                    PWLEN + 1 );
                EncodePassword( pInfo->pArgs->pszOldPassword );
            }

            // Whistler bug 224074 use only lstrcpyn's to prevent maliciousness
            //
            // pInfo->pArgs->pszNewPassword points back to RASDIALPARAMS->
            // szPassword[ PWLEN + 1 ]
            //
            // Whistler bug 254385 encode password when not being used
            // Assumed password was not encoded by GetWindowText()
            //
            lstrcpyn(
                pInfo->pArgs->pszNewPassword,
                szNewPassword,
                PWLEN + 1 );
            EncodePassword( pInfo->pArgs->pszNewPassword );
            RtlSecureZeroMemory( szNewPassword, sizeof(szNewPassword) );
            RtlSecureZeroMemory( szNewPassword2, sizeof(szNewPassword2) );
            EndDialog( hwnd, TRUE );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( hwnd, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
CpInit(
    IN HWND hwndDlg,
    IN CPARGS* pArgs )

    // Called on WM_INITDIALOG.  'HwndDlg' is the handle of the dialog window.
    // 'PArgs' is caller's arguments to the stub API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    CPWINFO* pInfo;

    TRACE( "CpInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    if (pArgs->fOldPassword)
    {
        pInfo->hwndEbOldPassword =
            GetDlgItem( hwndDlg, CID_CP_EB_OldPassword );
        ASSERT( pInfo->hwndEbOldPassword );
        Edit_LimitText( pInfo->hwndEbOldPassword, PWLEN );
    }
    pInfo->hwndEbNewPassword =
        GetDlgItem( hwndDlg, CID_CP_EB_Password );
    ASSERT( pInfo->hwndEbNewPassword );
    Edit_LimitText( pInfo->hwndEbNewPassword, PWLEN );

    pInfo->hwndEbNewPassword2 =
        GetDlgItem( hwndDlg, CID_CP_EB_ConfirmPassword );
    ASSERT( pInfo->hwndEbNewPassword2 );
    Edit_LimitText( pInfo->hwndEbNewPassword2, PWLEN );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    // Display finished window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );
    SetForegroundWindow( hwndDlg );

    return TRUE;
}


//----------------------------------------------------------------------------
// Connect Complete dialog
// Listed alphabetically following stub API and dialog proc
//----------------------------------------------------------------------------

VOID
ConnectCompleteDlg(
    IN HWND hwndOwner,
    IN DINFO* pInfo )

    // Popup the connection complete dialog.  'HwndOwner' is the owning
    // window.  'PUser' is the user preferences.
    //
{
    INT_PTR nStatus;

    TRACE( "ConnectCompleteDlg" );

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_CC_ConnectComplete ),
            hwndOwner,
            CcDlgProc,
            (LPARAM )pInfo );
}


INT_PTR CALLBACK
CcDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the dialog.  Parameters and return value are as
    // described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "CcDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return CcInit( hwnd, (DINFO* )lparam );
        }

        case WM_COMMAND:
        {
            return CcCommand(
                hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
            //For whistler bug 372078
            //GetCurrentIconEntryType() loads Icon from netshell where the icon is loaded
            //by LoadImage() without LR_SHARED, so I have to destroy it when we are done
            //with it
            //
            {
                HICON hIcon=NULL;
                hIcon = (HICON)SendMessage( GetDlgItem( hwnd, CID_CC_I_Rasmon ),
                                     STM_GETICON,
                                     (WPARAM)0,
                                     (LPARAM)0);
                
                ASSERT(hIcon);
                if( hIcon )
                {
                    DestroyIcon(hIcon);
                }
                else
                {
                    TRACE("CcDlgProc:Destroy Icon");
                }
            }
            
            break;
        
    }

    return FALSE;
}


BOOL
CcCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    // the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "CcCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case IDOK:
        {
            DINFO * pInfo = (DINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            PBUSER* pUser = pInfo->pUser;
            ASSERT( pUser );

            if (IsDlgButtonChecked( hwnd, CID_CC_CB_SkipMessage ))
            {
                pUser->fSkipConnectComplete = TRUE;
                pUser->fDirty = TRUE;
            }
        }

        // ...fall thru...

        case IDCANCEL:
        {
            EndDialog( hwnd, TRUE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
CcInit(
    IN HWND hwndDlg,
    IN DINFO* pInfo )

    // Called on WM_INITDIALOG.  'HwndDlg' is the handle of dialog.  'PUser'
    // is caller's argument to the stub API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    TRACE( "CcInit" );

    // Set the dialog context.
    //
    SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );

    // Set the explanatory text.
    //
    {
        MSGARGS msgargs;

        ZeroMemory( &msgargs, sizeof(msgargs) );
        msgargs.apszArgs[ 0 ] = pInfo->pEntry->pszEntryName;
        msgargs.fStringOutput = TRUE;

        MsgDlgUtil( NULL, SID_ConnectComplete, &msgargs, g_hinstDll, 0 );

        if (msgargs.pszOutput)
        {
            SetDlgItemText( hwndDlg, CID_CC_ST_Text, msgargs.pszOutput );
            Free( msgargs.pszOutput );
        }
    }

    // Set the correct icon.    For whistler bug 372078
    //  
    
    SetIconFromEntryType(
        GetDlgItem( hwndDlg, CID_CC_I_Rasmon ),
        pInfo->pEntry->dwType,
        FALSE); //FALSE means Large Icon
    
    // Display finished window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );
    SetForegroundWindow( hwndDlg );

    return TRUE;
}


//----------------------------------------------------------------------------
// Dial Callback dialog
// Listed alphabetically following stub API and dialog proc
//----------------------------------------------------------------------------

BOOL
DialCallbackDlg(
    IN HWND hwndOwner,
    IN OUT TCHAR* pszNumber )

    // Popup the Dial Callback dialog.  'HwndOwner' is the owning window.
    // 'PszNumber' is caller's buffer for the number of the local machine that
    // the server will be told to callback.  It contains the default number on
    // entry and the user-edited number on exit.
    //
    // Returns true if user OK and succeeds, false if Cancel or error.
    //
{
    INT_PTR nStatus;

    TRACE( "DialCallbackDlg" );

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_DC_DialCallback ),
            hwndOwner,
            DcDlgProc,
            (LPARAM )pszNumber );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
DcDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Dial Callback dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "DcDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return DcInit( hwnd, (TCHAR* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwDcHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            return DcCommand(
                hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}


BOOL
DcCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    // the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    DWORD dwErr;

    TRACE3( "DcCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case IDOK:
        {
            BOOL fStatus;
            HWND hwndEbNumber;
            TCHAR* pszNumber;

            TRACE( "OK pressed" );

            hwndEbNumber = GetDlgItem( hwnd, CID_DC_EB_Number );
            ASSERT( hwndEbNumber );
            pszNumber = (TCHAR* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pszNumber );
            GetWindowText( hwndEbNumber, pszNumber, RAS_MaxCallbackNumber + 1 );

            if (IsAllWhite( pszNumber ))
            {
                // OK with blank callback number is same as Cancel.
                //
                TRACE( "Blank number cancel" );
                fStatus = FALSE;
            }
            else
            {
                fStatus = TRUE;
            }

            EndDialog( hwnd, fStatus );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( hwnd, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
DcInit(
    IN HWND hwndDlg,
    IN TCHAR* pszNumber )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    // 'PszNumber' is the callback number.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    HWND hwndEbNumber;

    TRACE( "DcInit" );

    // Stash address of caller's buffer for OK processing.
    //
    ASSERT( pszNumber );
    SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pszNumber );

    // Initialize edit field to caller's default.
    //
    hwndEbNumber = GetDlgItem( hwndDlg, CID_DC_EB_Number );
    ASSERT( hwndEbNumber );
    Edit_LimitText( hwndEbNumber, RAS_MaxCallbackNumber );
    SetWindowText( hwndEbNumber, pszNumber );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    // Display finished window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );
    SetForegroundWindow( hwndDlg );

    return TRUE;
}


//----------------------------------------------------------------------------
// Dial Error dialog
// Listed alphabetically following stub API and dialog proc
//----------------------------------------------------------------------------

BOOL
DialErrorDlg(
    IN HWND hwndOwner,
    IN DINFO * pDinfo,      // For whistler bug 474514
    IN TCHAR* pszPhonebook, // For whistler 460931
    IN TCHAR* pszEntry,
    IN DWORD dwError,
    IN DWORD sidState,
    IN TCHAR* pszStatusArg,
    IN DWORD sidFormatMsg,
    IN TCHAR* pszFormatArg,
    IN LONG lRedialCountdown,
    IN BOOL fPopupOnTop )

    // Popup the Dial Error dialog.  'HwndOwner' is the owning window.
    // 'PszEntry' is the entry being dialed.  'DwError' is the error that
    // occurred or 0 if redialing after a link failure.  'sidStatusArg' is the
    // argument to the 'sidState' 'SidState' is the string ID of the dial
    // state executing when the error occurred.  string or NULL if none.
    // 'SidFormatMsg' is the string containing the format of the error message
    // or 0 to use the default.  'PszFormatArg' is the additional argument to
    // the format message or NULL if none.  'LRedialCountdown' is the number
    // of seconds before auto-redial, or -1 to disable countdown, or -2 to
    // hide the "Redial" button entirely.  'FPopupOnTop' indicates the status
    // window should be brought to the front when redialing.
    //
    // Returns true if user chooses to redial or lets it timeout, false if
    // cancels.
    //
{
    INT_PTR nStatus;
    DEARGS args;

    TRACE( "DialErrorDlg" );

    // For whistler 460931  459793      gangz
    //
    LinkWindow_RegisterClass();

    args.pszPhonebook = pszPhonebook;   // For whistler 460931
    args.pDinfo = pDinfo;               // For whislter 474514
    args.pszEntry = pszEntry;
    args.dwError = dwError;
    args.sidState = sidState;
    args.pszStatusArg = pszStatusArg;
    args.sidFormatMsg = sidFormatMsg;
    args.pszFormatArg = pszFormatArg;
    args.lRedialCountdown = lRedialCountdown;
    args.fPopupOnTop = fPopupOnTop;

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_DE_DialError ),
            hwndOwner,
            DeDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
DeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Dial Error dialog.  Parameters and return
    // value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "DeDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return DeInit( hwnd, (DEARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwDeHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            return DeCommand(
                hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_TIMER:
        {
            DEINFO* pInfo = (DEINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            KillTimer( pInfo->hwndDlg, 1 );
            if (pInfo->lRedialCountdown > 0)
            {
                --pInfo->lRedialCountdown;
            }

            DeAdjustPbRedial( pInfo );

            if (pInfo->lRedialCountdown == 0)
            {
                // Fake a press of the Redial button.  Note that BM_CLICK
                // cannot be used because it doesn't generate the WM_COMMAND
                // when the thread is not the foreground window, due to
                // SetCapture use and restriction.
                //
                SendMessage( pInfo->hwndDlg, WM_COMMAND,
                    MAKEWPARAM( IDOK, BN_CLICKED ),
                    (LPARAM )pInfo->hwndPbRedial );
            }
            else
            {
                SetTimer( pInfo->hwndDlg, 1, 1000L, NULL );
            }

            return TRUE;
        }

        case WM_DESTROY:
        {
            DeTerm( hwnd );
            break;
        }

        // For whistler bug 460931  459793        gangz
        //
        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case NM_CLICK:
                case NM_RETURN:
                {
                    DEINFO* pInfo = (DEINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
                    BOOL bCommit = FALSE;
                    ASSERT(pInfo);

                    KillTimer( pInfo->hwndDlg, 1 );
                    DeAdjustPbRedial( pInfo );

                    TRACE( "RasUserPrefsDlgInternal");

                    // Because the launched property pages will do the 
                    // Load/UnLoad too.

                    RasUserPrefDiagOnly ( hwnd, &bCommit );

                    if( bCommit )
                    {
                        if ( NULL == pInfo->diagInfo.pfnGetDiagFunc ||
                             NULL == pInfo->diagInfo.strDiagFuncs.GetState
                            )
                        {
                            break;
                        }
                        else
                        {
                          BOOL fEnable = FALSE;

                          fEnable =  pInfo->diagInfo.strDiagFuncs.GetState();
                          Button_SetCheck( pInfo->hwndCbEnableDiagLog,
                                           fEnable);
                        }
                    }

                    SetTimer( pInfo->hwndDlg, 1, 1000L, NULL );

                    break;
                }
            }
        }
        break;

    }

    return FALSE;
}


VOID
DeAdjustPbRedial(
    IN DEINFO* pInfo )

    // Set the label of the Redial button or disable it as indicated by the
    // redial countdown.  If enabled, the button shows the number of seconds
    // to auto-redial unless this is not the final redial.  'PInfo' is the
    // dialog context block.
    //
{
    TCHAR* psz;

    if (pInfo->lRedialCountdown == -2)
    {
        // Redial button is to be hidden.  See bug 230594.
        //
        SetFocus( pInfo->hwndPbCancel );
        ShowWindow( pInfo->hwndPbRedial, SW_HIDE );
        EnableWindow( pInfo->hwndPbRedial, FALSE );
    }
    else
    {
        // Go ahead and change the label "Redial" or "Redial=%d" as
        // appropriate.
        //
        psz = PszFromId( g_hinstDll, SID_RedialLabel );
        if (psz)
        {
            TCHAR szBuf[ 128 ];

            lstrcpyn( 
                szBuf, 
                psz, 
                (sizeof(szBuf) / sizeof(TCHAR)) - 4);
            Free( psz );

            if (pInfo->lRedialCountdown >= 0)
            {
                TCHAR szNum[ MAXLTOTLEN + 1 ];
                DWORD dwLen, dwSize = sizeof(szBuf)/sizeof(TCHAR);
                LToT( pInfo->lRedialCountdown, szNum, 10 );
                lstrcat( szBuf, TEXT(" = ") );
                dwLen = lstrlen(szBuf) + 1;
                lstrcpyn( szBuf + (dwLen - 1), szNum, dwSize - dwLen );
            }

            SetWindowText( pInfo->hwndPbRedial, szBuf );
        }
    }
}

void DeEnableDiagnostic(
    IN HWND hwnd )
{
            DEINFO* pInfo = NULL;

    do
    {
            pInfo = (DEINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            if( NULL == pInfo )
            {
                break;
            }

            // For whistler bug 474514      gangz
            //
            if( pInfo->pArgs->pDinfo->pNoUser )
            {
                break;
            }

            if ( NULL == pInfo->diagInfo.pfnGetDiagFunc ||
                 NULL == pInfo->diagInfo.strDiagFuncs.SetAll 
                )
            {
//                ErrorDlg( hwnd, SID_DG_LoadDiag, ERROR_UNKNOWN, NULL );
                break;
            }
            else
            {
              BOOL fEnable = FALSE;

              fEnable = Button_GetCheck( pInfo->hwndCbEnableDiagLog );
              pInfo->diagInfo.strDiagFuncs.SetAll( fEnable );
            }
      }
      while(FALSE);

    return;    
}


BOOL
DeCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    // the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    DWORD dwErr;

    TRACE3( "DeCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    TRACE2("Current proces:(0x%d), Current Thread:(0x%d)",
            GetCurrentProcessId(),
            GetCurrentThreadId());

    switch (wId)
    {
        case IDOK:
        {
            TRACE( "Redial pressed" );
            DeEnableDiagnostic( hwnd );
            EndDialog( hwnd, TRUE );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            DeEnableDiagnostic( hwnd );
            EndDialog( hwnd, FALSE );
            return TRUE;
        }

        case CID_DE_PB_More:
        {
            DEINFO* pInfo;
            DWORD dwContext;

            pInfo = (DEINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            if (pInfo->pArgs->dwError >= RASBASE
                && pInfo->pArgs->dwError <= RASBASEEND)
            {
                dwContext = HID_RASERRORBASE - RASBASE + pInfo->pArgs->dwError;
            }
            else if (pInfo->pArgs->dwError == 0)
            {
                dwContext = HID_RECONNECTING;
            }
            else
            {
                dwContext = HID_NONRASERROR;
            }

            WinHelp( hwnd, g_pszHelpFile, HELP_CONTEXTPOPUP, dwContext );
        }
        break;

        // For whistler 460931
        // 
        case CID_DE_CB_EnableDiag:
        {
            DEINFO* pInfo = NULL;

            pInfo = (DEINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            if( NULL == pInfo )
            {
                break;
            }

            if ( NULL == pInfo->diagInfo.pfnGetDiagFunc ||
                 NULL == pInfo->diagInfo.strDiagFuncs.SetAll 
                )
            {
                ErrorDlg( hwnd, SID_DG_LoadDiag, ERROR_UNKNOWN, NULL );
                break;
            }
        }
        break;
    }

    return FALSE;
}

BOOL
DeInit(
    IN HWND hwndDlg,
    IN DEARGS* pArgs )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    // 'PArgs' is caller's arguments to the stub API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    DEINFO* pInfo;

    TRACE( "DeInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->hwndStText = GetDlgItem( hwndDlg, CID_DE_ST_Text );
    ASSERT( pInfo->hwndStText );
    pInfo->hwndPbRedial = GetDlgItem( hwndDlg, IDOK );
    ASSERT( pInfo->hwndPbRedial );
    pInfo->hwndPbCancel = GetDlgItem( hwndDlg, IDCANCEL );
    ASSERT( pInfo->hwndPbCancel );
    pInfo->hwndPbMore = GetDlgItem( hwndDlg, CID_DE_PB_More );
    ASSERT( pInfo->hwndPbMore );
    // For whistler 460931  459793
    //
    pInfo->hwndCbEnableDiagLog= GetDlgItem( hwndDlg, CID_DE_CB_EnableDiag);
    ASSERT( pInfo->hwndCbEnableDiagLog );
    pInfo->hwndStConfigureLnk= GetDlgItem( hwndDlg, CID_DE_ST_ConfigureLnk);
    ASSERT( pInfo->hwndStConfigureLnk);
    pInfo->hwndStEnableHelp =  GetDlgItem( hwndDlg, CID_DE_ST_EnableHelp );
    ASSERT( pInfo->hwndStEnableHelp );
    pInfo->hwndStLinkHelp   =  GetDlgItem( hwndDlg, CID_DE_ST_LinkHelp );
    ASSERT( pInfo->hwndStLinkHelp );
                    

    // For whistler 474514              gangz
    // Have to block the diagnostic functionality from winlogon
    // For .Net 530448, diagnostic functionality is only availabe for 
    // Administrator or Power users
    if( pInfo->pArgs->pDinfo->pNoUser ||
        !FIsUserAdminOrPowerUser() )
    {
        EnableWindow(pInfo->hwndCbEnableDiagLog, FALSE);
        EnableWindow(pInfo->hwndStConfigureLnk, FALSE);
        ShowWindow(pInfo->hwndStConfigureLnk, SW_HIDE);
        EnableWindow(pInfo->hwndStEnableHelp, FALSE);
        EnableWindow(pInfo->hwndStLinkHelp, FALSE);
    }
    else
    {
        // For whistler bug 460931          gangz
        // Load the Diagnostic functions
        //
        // Have to zero memory, or else LoadDiagnosticDll may fail
        ZeroMemory( &pInfo->diagInfo, sizeof(pInfo->diagInfo ) );
        if ( NO_ERROR == LoadDiagnosticDll( &pInfo->diagInfo ) )
        {
             BOOL fEnable = FALSE;

             fEnable = pInfo->diagInfo.strDiagFuncs.GetState();

             Button_SetCheck( pInfo->hwndCbEnableDiagLog,
                                     fEnable 
                                    );
        } 
        else
        {
            ;
          //  EnableWindow( pInfo->hwndCbEnableDiagLog, FALSE );
          //  EnableWindow( pInfo->hwndStConfigureLnk, FALSE );
        }
    }
    
    // Hide/disable "more info" button if WinHelp won't work.  See
    // common\uiutil\ui.c.
    //
    {
        extern BOOL g_fNoWinHelp;

        if (g_fNoWinHelp)
        {
            ShowWindow( pInfo->hwndPbMore, SW_HIDE );
            EnableWindow( pInfo->hwndPbMore, FALSE );
        }
    }

    if (pArgs->dwError == 0)
    {
        TCHAR* pszFormat;
        TCHAR* psz;
        TCHAR* apszArgs[ 1 ];

        // Redialing on link failure.  Set title to "Dial-Up Networking".
        //
        psz = PszFromId( g_hinstDll, SID_PopupTitle );
        if (psz)
        {
            SetWindowText( hwndDlg, psz );
            Free( psz );
        }

        // Set static placeholder text control to "Link to <entry> failed.
        // Reconnect pending...".
        //
        pszFormat = PszFromId( g_hinstDll, SID_DE_LinkFailed );
        if (pszFormat)
        {
            apszArgs[ 0 ] = pArgs->pszEntry;
            psz = NULL;

            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING
                    | FORMAT_MESSAGE_ALLOCATE_BUFFER
                    | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                pszFormat, 0, 0, (LPTSTR )&psz, 1,
                (va_list* )apszArgs );

            Free( pszFormat );

            if (psz)
            {
                SetWindowText( pInfo->hwndStText, psz );
                LocalFree( psz );
            }
        }
    }
    else
    {
        TCHAR* pszTitleFormat;
        TCHAR* pszTitle;
        TCHAR* apszArgs[ 1 ];
        ERRORARGS args;

        // Set title to "Error Connecting to <entry>".
        //
        pszTitleFormat = GetText( hwndDlg );
        if (pszTitleFormat)
        {
            apszArgs[ 0 ] = pArgs->pszEntry;
            pszTitle = NULL;

            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING
                    | FORMAT_MESSAGE_ALLOCATE_BUFFER
                    | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                pszTitleFormat, 0, 0, (LPTSTR )&pszTitle, 1,
                (va_list* )apszArgs );

            Free( pszTitleFormat );

            if (pszTitle)
            {
                SetWindowText( hwndDlg, pszTitle );
                LocalFree( pszTitle );
            }
        }

        // Build the error text and load it into the placeholder text control.
        //
        ZeroMemory( &args, sizeof(args) );
        if (pArgs->pszStatusArg)
            args.apszOpArgs[ 0 ] = pArgs->pszStatusArg;
        if (pArgs->pszFormatArg)
            args.apszAuxFmtArgs[ 0 ] = pArgs->pszFormatArg;
        args.fStringOutput = TRUE;

        ErrorDlgUtil( hwndDlg,
            pArgs->sidState, pArgs->dwError, &args, g_hinstDll, 0,
            (pArgs->sidFormatMsg) ? pArgs->sidFormatMsg : SID_FMT_ErrorMsg );

        if (args.pszOutput)
        {
            SetWindowText( pInfo->hwndStText, args.pszOutput );
            LocalFree( args.pszOutput );
        }
    }

    // Stretch the dialog window to a vertical size appropriate for the text
    // we loaded.
    //
    {
        HDC hdc;
        RECT rect;
        RECT rectNew;
        HFONT hfont;
        LONG dyGrow;
        TCHAR* psz;

        psz = GetText( pInfo->hwndStText );
        if (psz)
        {
            GetClientRect( pInfo->hwndStText, &rect );
            hdc = GetDC( pInfo->hwndStText );

            if(NULL != hdc)
            {

                hfont = (HFONT )SendMessage( pInfo->hwndStText, 
                                            WM_GETFONT, 0, 0 );
                if (hfont)
                {
                    SelectObject( hdc, hfont );
                }

                rectNew = rect;
                DrawText( hdc, psz, -1, &rectNew,
                    DT_CALCRECT | DT_WORDBREAK | DT_EXPANDTABS | DT_NOPREFIX );
                ReleaseDC( pInfo->hwndStText, hdc );
            }

            dyGrow = rectNew.bottom - rect.bottom;
            ExpandWindow( pInfo->hwndDlg, 0, dyGrow );
            ExpandWindow( pInfo->hwndStText, 0, dyGrow );
            
            // For whistler 460931  459793  
            //
            SlideWindow( pInfo->hwndCbEnableDiagLog, pInfo->hwndDlg, 0, dyGrow );
            SlideWindow( pInfo->hwndStLinkHelp, pInfo->hwndDlg, 0, dyGrow );
            SlideWindow( pInfo->hwndStConfigureLnk, pInfo->hwndDlg, 0, dyGrow );
            SlideWindow( pInfo->hwndStEnableHelp, pInfo->hwndDlg, 0, dyGrow );
            SlideWindow( pInfo->hwndPbRedial, pInfo->hwndDlg, 0, dyGrow );
            SlideWindow( pInfo->hwndPbCancel, pInfo->hwndDlg, 0, dyGrow );
            SlideWindow( pInfo->hwndPbMore, pInfo->hwndDlg, 0, dyGrow );
            
            Free( psz );
        }
    }

    // Set Redial button label or disable the button.  Always choose to redial
    // after 5 seconds for the biplex error, since this will normally solve
    // the problem.  Otherwise, no countdown is used.
    //
    if (pArgs->dwError == ERROR_BIPLEX_PORT_NOT_AVAILABLE)
    {
        pInfo->lRedialCountdown = 5;
    }
    else
    {
        pInfo->lRedialCountdown = pArgs->lRedialCountdown;
    }

    DeAdjustPbRedial( pInfo );

    if (pInfo->lRedialCountdown >= 0)
    {
        SetTimer( pInfo->hwndDlg, 1, 1000L, NULL );
    }

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    if (pArgs->fPopupOnTop)
    {
        // Display the finished window above all other windows.  The window
        // position is set to "topmost" then immediately set to "not topmost"
        // because we want it on top but not always-on-top.  Always-on-top
        // alone is too annoying.
        //
        SetWindowPos(
            hwndDlg, HWND_TOPMOST, 0, 0, 0, 0,
            SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE );
    }

    CenterWindow( hwndDlg, GetParent( hwndDlg ) );
    ShowWindow( hwndDlg, SW_SHOW );

    if (pArgs->fPopupOnTop)
    {
        SetForegroundWindow( hwndDlg );

        SetWindowPos(
            hwndDlg, HWND_NOTOPMOST, 0, 0, 0, 0,
            SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE );
    }

    return TRUE;
}

// Helper function to delete credentials
//
// fDeleteDefault specifies whether it is the default credentials that 
// should be deleted.
//
// fDeleteIdentity specifies whether to delete the user and domain names
// in addition to the password. 
//
DWORD
DeleteSavedCredentials(
    IN DINFO* pDinfo,
    IN HWND   hwndDlg,
    IN BOOL   fDefault,
    IN BOOL   fDeleteIdentity )
{
    RASCREDENTIALS rc;
    DWORD dwErr = NO_ERROR;

    TRACE2( "DeleteSavedCredentials: %d %d", fDefault, fDeleteIdentity );

    ZeroMemory(&rc, sizeof(rc));
    rc.dwSize = sizeof(RASCREDENTIALS);
    rc.dwMask = RASCM_Password;

    if (fDeleteIdentity)
    {
        rc.dwMask |= (RASCM_UserName | RASCM_Domain);
    }

    if (    (fDefault)
        &&  (IsPublicPhonebook(pDinfo->pFile->pszPath)))
    {
        rc.dwMask |= RASCM_DefaultCreds;
    }

    dwErr = g_pRasSetCredentials(
                pDinfo->pFile->pszPath,
                pDinfo->pEntry->pszEntryName,
                &rc,
                TRUE );

    if (dwErr != 0)
    {
        ErrorDlg( hwndDlg, SID_OP_UncachePw, dwErr, NULL );
    }

    TRACE1( "DeleteSavedCredentials: RasSetCredentials=%d", dwErr );

    return dwErr;
}

VOID
DeTerm(
    IN HWND hwndDlg )

    // Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    //
{
    DEINFO* pInfo = (DEINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );

    TRACE( "DeTerm" );

    if (pInfo)
    {
        if(! pInfo->pArgs->pDinfo->pNoUser )
        {
            UnLoadDiagnosticDll( &pInfo->diagInfo);
        }
        
        Free( pInfo );
        pInfo = NULL;
    }
}


//----------------------------------------------------------------------------
// Dial Progress dialog
// Listed alphabetically following stub API dialog proc
//----------------------------------------------------------------------------

BOOL
DialProgressDlg(
    IN DINFO* pInfo )

    // Popup the Dial Progress dialog.  'PInfo' is the dialog context.
    //
    // Returns true if user connected successfully, false is he cancelled or
    // hit an error.
    //
{
    INT_PTR nStatus;

    // Run the dialog.
    //
    nStatus =
        DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_DP_DialProgress ),
            pInfo->pArgs->hwndOwner,
            DpDlgProc,
            (LPARAM )pInfo );

    if (nStatus == -1)
    {
        ErrorDlg( pInfo->pArgs->hwndOwner, SID_OP_LoadDlg,
            ERROR_UNKNOWN, NULL );
        pInfo->pArgs->dwError = ERROR_UNKNOWN;
        nStatus = FALSE;
    }

    if (nStatus)
    {
        DWORD  dwErr;
        PBFILE file;

        // Connected successfully, so read possible changes to the entry made
        // by RasDial.
        //
        dwErr = ReadPhonebookFile( pInfo->pFile->pszPath, pInfo->pUser,
                    pInfo->pEntry->pszEntryName, RPBF_ReadOnly, &file );
        if (dwErr == 0)
        {
            DTLNODE* pNodeNew;

            pNodeNew = DtlGetFirstNode( file.pdtllistEntries );
            if (pNodeNew)
            {
                DtlRemoveNode( pInfo->pFile->pdtllistEntries, pInfo->pNode );
                DestroyEntryNode( pInfo->pNode );

                DtlRemoveNode( file.pdtllistEntries, pNodeNew );
                DtlAddNodeLast( pInfo->pFile->pdtllistEntries, pNodeNew );

                pInfo->pNode = pNodeNew;
                pInfo->pEntry = (PBENTRY* )DtlGetData( pNodeNew );
            }

            ClosePhonebookFile( &file );
        }
    }

    // See if we need to change the entry based on what happened while
    // dialing.
    //
    {
        BOOL fChange = FALSE;

        if (pInfo->fResetAutoLogon)
        {
            ASSERT( !pInfo->pNoUser );
            pInfo->pEntry->fAutoLogon = FALSE;
            fChange = TRUE;
        }

        if (pInfo->dwfExcludedProtocols)
        {
            pInfo->pEntry->dwfExcludedProtocols
                |= pInfo->dwfExcludedProtocols;
            fChange = TRUE;
        }

        if (pInfo->pListPortsToDelete)
        {
            DTLNODE* pNode;

            pNode = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
            while (pNode)
            {
                DTLNODE* pNodeNext;
                DTLNODE* pNodePtd;
                PBLINK*  pLink;
                TCHAR*   pszPort;

                pNodeNext = DtlGetNextNode( pNode );

                pLink = (PBLINK* )DtlGetData( pNode );
                pszPort = pLink->pbport.pszPort;

                for (pNodePtd = DtlGetFirstNode( pInfo->pListPortsToDelete );
                     pNodePtd;
                     pNodePtd = DtlGetNextNode( pNodePtd ))
                {
                    TCHAR* pszPtd = (TCHAR* )DtlGetData( pNodePtd );

                    if (lstrcmp( pszPtd, pszPort ) == 0)
                    {
                        pNode = DtlRemoveNode(
                            pInfo->pEntry->pdtllistLinks, pNode );
                        DestroyLinkNode( pNode );
                        fChange = TRUE;
                        break;
                    }
                }

                pNode = pNodeNext;
            }
        }

        if (fChange)
        {
            pInfo->pEntry->fDirty = TRUE;
            WritePhonebookFile( pInfo->pFile, NULL );
        }
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
DpDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the User Authentication dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "DpDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return DpInit( hwnd, (DINFO* )lparam );
        }

        case WM_COMMAND:
        {
            DPINFO* pInfo = (DPINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            return DpCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_RASDIAL:
        {
            DPINFO* pInfo = (DPINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            Sleep( 0 );
            DpDial( pInfo, (BOOL)wparam );
            return TRUE;
        }

        case WM_RASERROR:
        {
            DPINFO* pInfo = (DPINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            Sleep( 0 );

            //For whistler bug 381337
            //
            if ( !pInfo->fCancelPressed )
            {
                DpError( pInfo, (DPSTATE* )lparam );
            }
            else
            {
                TRACE("DpDlgProc is already canceled, wont respond to WM_RASERROR");
            }
            
            return TRUE;
        }

        case WM_RASBUNDLEERROR:
        {
            DPINFO* pInfo = (DPINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            Sleep( 0 );
            if (BundlingErrorsDlg( pInfo ))
            {
                EndDialog( pInfo->hwndDlg, TRUE );
            }
            else
            {
                DpCancel( pInfo );
            }
            return TRUE;
        }

        case WM_DPENDDIALOG:
       {
            DPINFO* pInfo = (DPINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            // XPSP2 511810, .Net 668164
            if ( GetCallbackActive(pInfo))
            {
                // Callbacks are active.  Stall until they complete.
                //
   //             SetTerminateFlag(pInfo);
                
                TRACE( "Stall until callbacks disabled" );
                PostMessage( hwnd, WM_DPENDDIALOG, wparam, lparam );
            }
            else
            {
                EndDialog( hwnd, (BOOL)lparam);
            }
       }
       return TRUE;
        
        case WM_DESTROY:
        {
            DPINFO* pInfo = (DPINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            // Whistler Bugs: 344019 SECBUGBASH: leaving leaked password in
            // memory when user changes password over RAS
            //
            // 289587 Failed RAS connections reset password to blank
            //
            if (pInfo->pszGoodPassword)
            {
                ZeroMemory(
                    pInfo->pszGoodPassword,
                    (lstrlen( pInfo->pszGoodPassword ) + 1) * sizeof(TCHAR) );
                Free( pInfo->pszGoodPassword );
                pInfo->pszGoodPassword = NULL;
            }

            if (pInfo->pszGoodUserName)
            {
                Free( pInfo->pszGoodUserName );
                pInfo->pszGoodUserName = NULL;
            }

            if (GetCallbackActive(pInfo))
            {
                // Callbacks are active.  Stall until they complete.
                //
                TRACE( "Stall until callbacks disabled" );

                SetTerminateFlag(pInfo);

                PostMessage( hwnd, WM_DESTROY, wparam, lparam );
                return TRUE;
            }
            DpTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


VOID
DpAppendBlankLine(
    IN OUT TCHAR* pszLines )

    // Append a blank line on the end of 'pszLines'.
    //
{
    lstrcat( pszLines, TEXT("\n") );
}


VOID
DpAppendConnectErrorLine(
    IN OUT TCHAR* pszLines,
    IN DWORD sidProtocol,
    IN DWORD dwError )

    // Append a connect error line for protocol 'sidProtocol' and error
    // 'dwError' onto the end of 'pszLines'.
    //
{
#define MAXRASERRORLEN 256

    TCHAR* pszProtocol;
    TCHAR* pszErrStr;
    TCHAR szErrNumBuf[ MAXLTOTLEN + 1 ];

    // Gather the argument strings.
    //
    pszProtocol = PszFromId( g_hinstDll, sidProtocol );
    if (!pszProtocol)
    {
        return;
    }

    LToT( dwError, szErrNumBuf, 10 );

    pszErrStr = NULL;
    GetErrorText( dwError, &pszErrStr );

    // Format the line and append it to caller's line buffer.
    //
    {
        TCHAR* pszLineFormat;
        TCHAR* pszLine;
        TCHAR* apszArgs[ 3 ];

        pszLineFormat = PszFromId( g_hinstDll, SID_FMT_ProjectError );
        if (pszLineFormat)
        {
            apszArgs[ 0 ] = pszProtocol;
            apszArgs[ 1 ] = szErrNumBuf;
            apszArgs[ 2 ] = (pszErrStr) ? pszErrStr : TEXT("");
            pszLine = NULL;

            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING
                    | FORMAT_MESSAGE_ALLOCATE_BUFFER
                    | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                pszLineFormat, 0, 0, (LPTSTR )&pszLine, 1,
                (va_list* )apszArgs );

            Free( pszLineFormat );

            if (pszLine)
            {
                lstrcat( pszLines, pszLine );
                LocalFree( pszLine );
            }
        }
    }

    Free( pszProtocol );
    Free0( pszErrStr );
}


VOID
DpAppendConnectOkLine(
    IN OUT TCHAR* pszLines,
    IN DWORD sidProtocol )

    // Append a "connected successfully" line for protocol 'sidProtocol' onto
    // the end of 'pszLines'.
    //
{
    TCHAR* pszProtocol;

    // Get the argument string.
    //
    pszProtocol = PszFromId( g_hinstDll, sidProtocol );
    if (!pszProtocol)
    {
        return;
    }

    // Format the line and append it to caller's line buffer.
    //
    {
        TCHAR* pszLineFormat;
        TCHAR* pszLine;
        TCHAR* apszArgs[ 1 ];

        pszLineFormat = PszFromId( g_hinstDll, SID_FMT_ProjectOk );
        if (pszLineFormat)
        {
            apszArgs[ 0 ] = pszProtocol;
            pszLine = NULL;

            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING
                    | FORMAT_MESSAGE_ALLOCATE_BUFFER
                    | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                pszLineFormat, 0, 0, (LPTSTR )&pszLine, 1,
                (va_list* )apszArgs );

            Free( pszLineFormat );

            if (pszLine)
            {
                lstrcat( pszLines, pszLine );
                LocalFree( pszLine );
            }
        }
    }

    Free( pszProtocol );
}


VOID
DpAppendFailCodeLine(
    IN OUT TCHAR* pszLines,
    IN DWORD dw )

    // Append hexidecimal fail code 'dw' as an extended error line on the end
    // of 'pszLines'.
    //
{
    TCHAR szNumBuf[ MAXLTOTLEN + 1 ];

    // Get the argument string.
    //
    LToT( dw, szNumBuf, 16 );

    // Format the line and append it to caller's line buffer.
    //
    {
        TCHAR* pszLineFormat;
        TCHAR* pszLine;
        TCHAR* apszArgs[ 1 ];

        pszLineFormat = PszFromId( g_hinstDll, SID_FMT_FailCode );
        if (pszLineFormat)
        {
            apszArgs[ 0 ] = szNumBuf;
            pszLine = NULL;

            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING
                    | FORMAT_MESSAGE_ALLOCATE_BUFFER
                    | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                pszLineFormat, 0, 0, (LPTSTR )&pszLine, 1,
                (va_list* )apszArgs );

            Free( pszLineFormat );

            if (pszLine)
            {
                lstrcat( pszLines, pszLine );
                LocalFree( pszLine );
            }
        }
    }
}


VOID
DpAppendNameLine(
    IN OUT TCHAR* pszLines,
    IN TCHAR* psz )

    // Append NetBIOS name 'psz' as an extended error line on the end of
    // 'pszLines'.
    //
{
    TCHAR* pszLineFormat;
    TCHAR* pszLine;
    TCHAR* apszArgs[ 1 ];

    pszLineFormat = PszFromId( g_hinstDll, SID_FMT_Name );
    if (pszLineFormat)
    {
        apszArgs[ 0 ] = psz;
        pszLine = NULL;

        FormatMessage(
            FORMAT_MESSAGE_FROM_STRING
                | FORMAT_MESSAGE_ALLOCATE_BUFFER
                | FORMAT_MESSAGE_ARGUMENT_ARRAY,
            pszLineFormat, 0, 0, (LPTSTR )&pszLine, 1,
            (va_list* )apszArgs );

        Free( pszLineFormat );

        if (pszLine)
        {
            lstrcat( pszLines, pszLine );
            LocalFree( pszLine );
        }
    }
}


VOID
DpAuthNotify(
    IN DPINFO* pInfo,
    IN DPSTATE* pState )

    // Called on an authentication notify, i.e. a message from RASCAUTH.DLL or
    // RASPPPEN.DLL.  'PInfo' is the dialog context.  'PState' is the current
    // link's context.
    //
{
    PBENTRY* pEntry;

    TRACE( "DpAuthNotify" );

    pEntry = pInfo->pArgs->pEntry;

    if (pState->dwError == ERROR_ACCESS_DENIED && pEntry->fAutoLogon)
    {
        // A third party box has negotiated an authentication protocol that
        // can't deal with the NT one-way-hashed password, i.e. something
        // besides MS-extended CHAP or AMB.  Map the error to a more
        // informative error message.
        //
        pState->dwError = ERROR_CANNOT_USE_LOGON_CREDENTIALS;

        if (!pInfo->pArgs->pNoUser)
        {
            TRACE( "Disable auto-logon" );
            pEntry->fAutoLogon = FALSE;
            pInfo->pArgs->fResetAutoLogon = TRUE;
        }
    }

    if (pState->dwError == ERROR_CHANGING_PASSWORD)
    {
        TRACE( "DpAuthNotify - ERROR_CHANGING_PASSWORD" );

        // Change password failed.  Restore the password that worked for the
        // "button" redial.
        //
        if (pInfo->pszGoodPassword)
        {
            // Whistler bug 254385 encode password when not being used
            // Assumed password was encoded by DpPasswordExpired()
            //
            DecodePassword( pInfo->pszGoodPassword );
            lstrcpyn(
                pInfo->pArgs->rdp.szPassword,
                pInfo->pszGoodPassword,
                sizeof(pInfo->pArgs->rdp.szPassword) / sizeof(TCHAR) );
            EncodePassword( pInfo->pArgs->rdp.szPassword );

            ZeroMemory(
                pInfo->pszGoodPassword,
                (lstrlen( pInfo->pszGoodPassword ) + 1) * sizeof(TCHAR) );
            Free( pInfo->pszGoodPassword );
            pInfo->pszGoodPassword = NULL;
        }

        if (pInfo->pszGoodUserName)
        {
            lstrcpyn(
                pInfo->pArgs->rdp.szUserName,
                pInfo->pszGoodUserName,
                sizeof(pInfo->pArgs->rdp.szUserName) / sizeof(TCHAR) );
            Free( pInfo->pszGoodUserName );
            pInfo->pszGoodUserName = NULL;
        }
    }

    // Update cached credentials, if any, with new password.
    //
    // Whistler Bugs: 344019 SECBUGBASH: leaving leaked password in memory when
    // user changes password over RAS
    //
    // 289587 Failed RAS connections reset password to blank
    //
    if ((pState->sidState == SID_S_Projected) &&
        (pInfo->pszGoodPassword) &&
        (pInfo->pszGoodUserName))
    {
        DWORD dwErr;
        RASCREDENTIALS rc;

        TRACE( "DpAuthNotify - Success changing password, caching if necessary" );

        ZeroMemory( &rc, sizeof(rc) );
        rc.dwSize = sizeof(rc);

        // Look up cached password. Since we are only calling in with the
        // RASCM_Password flag here, with the current implementation of
        // RasGet/SetCredentials, this works for the Set below whether we are
        // saving a Per-User, Global, or the special case of having both saved
        // at the same time. Whew, complicated!
        //
        rc.dwMask = RASCM_Password;
        ASSERT( g_pRasGetCredentials );
        TRACE( "RasGetCredentials" );
        dwErr = g_pRasGetCredentials(
            pInfo->pArgs->pFile->pszPath,
            pInfo->pArgs->pEntry->pszEntryName,
            &rc );
        TRACE2( "RasGetCredentials=%d,m=%x", dwErr, rc.dwMask );

        if (dwErr == 0 && (rc.dwMask & RASCM_Password))
        {
            // Password was cached, so update it.
            //
            DecodePassword( pInfo->pArgs->rdp.szPassword );
            lstrcpyn(
                rc.szPassword,
                pInfo->pArgs->rdp.szPassword,
                sizeof(rc.szPassword) / sizeof(TCHAR) );
            EncodePassword( pInfo->pArgs->rdp.szPassword );

            ASSERT( g_pRasSetCredentials );
            TRACE( "RasSetCredentials(p,FALSE)" );
            dwErr = g_pRasSetCredentials(
                pInfo->pArgs->pFile->pszPath,
                pInfo->pArgs->pEntry->pszEntryName, &rc, FALSE );
            TRACE1( "RasSetCredentials=%d", dwErr );

            if (dwErr != 0)
            {
                ErrorDlg( pInfo->hwndDlg, SID_OP_UncachePw, dwErr, NULL );
            }
        }

        // Clean up
        //
        RtlSecureZeroMemory( rc.szPassword, sizeof(rc.szPassword) );

        RtlSecureZeroMemory(
            pInfo->pszGoodPassword,
            (lstrlen( pInfo->pszGoodPassword ) + 1) * sizeof(TCHAR) );
        Free( pInfo->pszGoodPassword );
        pInfo->pszGoodPassword = NULL;

        Free( pInfo->pszGoodUserName );
        pInfo->pszGoodUserName = NULL;
    }
}


VOID
DpCallbackSetByCaller(
    IN DPINFO* pInfo,
    IN DPSTATE* pState )

    // RASCS_CallbackSetByCaller state handling.  'PInfo' is the dialog
    // context.  'PState' is the subentry state.
    //
    // Returns true if successful, or an error code.
    //
{
    TCHAR* pszDefault;
    TCHAR szNum[ RAS_MaxCallbackNumber + 1 ];

    TRACE( "DpCallbackSetByCaller" );

    pszDefault = pInfo->pArgs->pUser->pszLastCallbackByCaller;
    if (!pszDefault)
    {
        pszDefault = TEXT("");
    }

    lstrcpyn( szNum, pszDefault, RAS_MaxCallbackNumber + 1 );

    if (DialCallbackDlg( pInfo->hwndDlg, szNum ))
    {
        lstrcpyn( pInfo->pArgs->rdp.szCallbackNumber, szNum, RAS_MaxCallbackNumber + 1 );

        if (lstrcmp( szNum, pszDefault ) != 0)
        {
            Free0( pInfo->pArgs->pUser->pszLastCallbackByCaller );
            pInfo->pArgs->pUser->pszLastCallbackByCaller = StrDup( szNum );
            pInfo->pArgs->pUser->fDirty = TRUE;
        }
    }
    else
    {
        pInfo->pArgs->rdp.szCallbackNumber[ 0 ] = TEXT('\0');
    }

    pState->sidState = 0;
}

BOOL GetTerminateFlag(
    IN DPINFO * pInfo)
{
    BOOL ret = FALSE;
    
    __try
    {
        EnterCriticalSection( &g_csCallBacks );

        ret =  pInfo->fTerminateAsap;
    }
    __finally
    {
        LeaveCriticalSection( &g_csCallBacks );
    }

    return ret;
}

BOOL  SetTerminateFlag(
    IN DPINFO * pInfo)
{
    BOOL ret = FALSE;
    
    __try
    {
        EnterCriticalSection( &g_csCallBacks );

        ret = pInfo->fTerminateAsap = 1;
        TRACE1("CallActive is:%d", ret);
    }
    __finally
    {
        LeaveCriticalSection( &g_csCallBacks );
    }

    return ret;
}

BOOL  ResetTerminateFlag(
    IN DPINFO * pInfo)
{
    BOOL ret = FALSE;
    __try
    {
        EnterCriticalSection( &g_csCallBacks );

        ret = pInfo->fTerminateAsap = 0;
        TRACE1("CallActive is:%d", ret);
    }
    __finally
    {
        LeaveCriticalSection( &g_csCallBacks );
    }

    return ret;
}

BOOL  GetCallbackActive(
    IN DPINFO * pInfo)
{
    BOOL ret = FALSE;
    
    __try
    {
        EnterCriticalSection( &g_csCallBacks );

        ret = pInfo->fCallbacksActive;
        TRACE1("CallActive is:%d", ret);
    }
    __finally
    {
        LeaveCriticalSection( &g_csCallBacks );
    }

    return ret;
}

BOOL  SetCallbackActive(
    IN DPINFO * pInfo)
{
    BOOL ret = FALSE;
    __try
    {
        EnterCriticalSection( &g_csCallBacks );

        ret =  pInfo->fCallbacksActive = 1;
        TRACE1("CallActive is:%d", ret);
    }
    __finally
    {
        LeaveCriticalSection( &g_csCallBacks );
    }

    return ret;
}

BOOL  ResetCallbackActive(
    IN DPINFO * pInfo)
{
    BOOL ret = FALSE;
    __try
    {
        EnterCriticalSection( &g_csCallBacks );

        ret = pInfo->fCallbacksActive = 0;
        TRACE1("CallActive is:%d", ret);
    }
    __finally
    {
        LeaveCriticalSection( &g_csCallBacks );
    }

    return ret;
}


VOID
DpCancel(
    IN DPINFO* pInfo )

    // Kill the dialog and any partially initiated call, as when cancel button
    // is pressed.  'PInfo' is the dialog context block.
    //
{
    TRACE( "DpCancel" );

    // Hide window to prevent visual complaints that arise if RasHangUp takes
    // a long time to complete.
    //
    ShowWindow( pInfo->hwndDlg, SW_HIDE );

    if (pInfo->hrasconn)
    {
        DWORD dwErr;

        ASSERT( g_pRasHangUp );
        TRACE( "RasHangUp" );

        TRACE("DpCancel:call RasHangUp");

        dwErr = g_pRasHangUp( pInfo->hrasconn );

        TRACE1("DpCancel:get dwErr from RasHangUp:(%d)", dwErr);
        TRACE1( "RasHangUp=%d", dwErr );
    }

     //For whistler 435725
     // 
      if( !pInfo->fCancelPressed )
      {
          TRACE("DpEndDialog:Cancel pressed");
          pInfo->fCancelPressed = TRUE;
      }
 
       DpEndDialog( pInfo, FALSE );
}


BOOL
DpCommand(
    IN DPINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    DWORD dwErr = NO_ERROR;

    TRACE3( "DpCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    TRACE2("DpCommand:pInfo address (0x%x), Dialog Handle (0x%x)",
            pInfo,
            pInfo->hwndDlg);
            
    TRACE2("DpCommand:Current proces:(0x%d), Current Thread:(0x%d)",
            GetCurrentProcessId(),
            GetCurrentThreadId());

    switch (wId)
    {
        case IDCANCEL:
        {
            BOOL fCallbackActive = FALSE;

            ShowWindow( pInfo->hwndDlg, SW_HIDE );

            //For whistler bug 381337
            //
            if( !pInfo->fCancelPressed)
            {
                TRACE("DpCommand:Cancel pressed");
                pInfo->fCancelPressed = TRUE;
            }
            
            if (pInfo->hrasconn)
            {
                ASSERT( g_pRasHangUp );
                TRACE( "RasHangUp" );
                dwErr = g_pRasHangUp( pInfo->hrasconn );
                TRACE1( "RasHangUp=%d", dwErr );
            }

            // for XPSP2 511810, .Net 668164

	     fCallbackActive = GetCallbackActive(pInfo);
            if ( TRUE == fCallbackActive )           
            {
                TRACE1( "DpCommand stall, current thread's fCallbacksActive n=%d", fCallbackActive );

                SetTerminateFlag(pInfo);

                PostMessage( pInfo->hwndDlg, WM_COMMAND, 
                             MAKEWPARAM(wId, wNotification), 
                             (LPARAM) hwndCtrl );

                //For whistler bug 378086       gangz
                //to sleep a bit to give the rasdial machine a break to call our callback 
                //function DpRasDialFunc2()
                //
                Sleep(10);
                
                return TRUE;
            }

            EndDialog( pInfo->hwndDlg, FALSE );

            //Reset the pInfo->fTerminateAsap flag
            // for  XPSP2 511810, .Net 668164
            ResetTerminateFlag(pInfo);
            
            return TRUE;
        }
    }

    return FALSE;
}


VOID
DpConnectDevice(
    IN DPINFO* pInfo,
    IN DPSTATE* pState )

    // RASCS_ConnectDevice state handling.  'PInfo' is the dialog context.
    // 'PState' is the subentry state.
    //
{
    DWORD dwErr;
    RASCONNSTATUS rcs;
    DWORD cb;
    HRASCONN hrasconn;
    TCHAR* pszPhoneNumber;

    TRACE( "DpConnectDevice" );

    // Get fully translated phone number, if any.
    //
    ZeroMemory( &rcs, sizeof(rcs) );
    rcs.dwSize = sizeof(rcs);
    ASSERT( g_pRasGetConnectStatus );
    TRACE1( "RasGetConnectStatus($%08x)", pState->hrasconnLink );
    dwErr = g_pRasGetConnectStatus( pState->hrasconnLink, &rcs );
    TRACE1( "RasGetConnectStatus=%d", dwErr );
    TRACEW1( " dt=%s", rcs.szDeviceType );
    TRACEW1( " dn=%s", rcs.szDeviceName );
    TRACEW1( " pn=%s", rcs.szPhoneNumber );
    if (dwErr != 0)
    {
        pState->pbdt = PBDT_None;
    }

    pState->pbdt = PbdevicetypeFromPszType( rcs.szDeviceType );
    pszPhoneNumber = rcs.szPhoneNumber;

    switch (pState->pbdt)
    {
        case PBDT_Modem:
        {
            Free0( pState->pszStatusArg );
            pState->pszStatusArg = StrDup( pszPhoneNumber );

            if (pInfo->pArgs->pUser->fOperatorDial
                && AllLinksAreModems( pInfo->pArgs->pEntry ))
            {
                pState->sidState = SID_S_ConnectModemOperator;
            }
            else if (pInfo->pArgs->pEntry->fPreviewPhoneNumber)
            {
                pState->sidState = SID_S_ConnectNumber;
            }
            else
            {
                pState->sidState = SID_S_ConnectModemNoNum;
            }
            break;
        }

        case PBDT_Pad:
        {
            Free0( pState->pszStatusArg );
            pState->pszStatusArg = StrDup( rcs.szDeviceName );
            pState->sidState = SID_S_ConnectPad;

            if (pState->dwError == ERROR_X25_DIAGNOSTIC)
            {
                TCHAR* psz;

                // Get the X.25 diagnostic string for display in the
                // custom "diagnostics" error message format.
                //
                Free0( pState->pszFormatArg );
                pState->pszFormatArg =
                    GetRasX25Diagnostic( pState->hrasconnLink );
            }
            break;
        }

        case PBDT_Switch:
        {
            Free0( pState->pszStatusArg );
            pState->pszStatusArg = StrDup( rcs.szDeviceName );

            pState->sidState =
                (pState->fNotPreSwitch)
                    ? SID_S_ConnectPostSwitch
                    : SID_S_ConnectPreSwitch;
            break;
        }

        case PBDT_Null:
        {
            pState->sidState = SID_S_ConnectNull;
            break;
        }

        case PBDT_Parallel:
        {
            pState->sidState = SID_S_ConnectParallel;
            break;
        }

        case PBDT_Irda:
        {
            pState->sidState = SID_S_ConnectIrda;
            break;
        }

        case PBDT_Isdn:
        {
            Free0( pState->pszStatusArg );
            pState->pszStatusArg = StrDup( pszPhoneNumber );
            pState->sidState = SID_S_ConnectNumber;
            break;
        }

        case PBDT_Vpn:
        {
            Free0( pState->pszStatusArg );
            pState->pszStatusArg = StrDup( pszPhoneNumber );
            pState->sidState = SID_S_ConnectVpn;
            break;
        }

        default:
        {
            Free0( pState->pszStatusArg );
            if (pszPhoneNumber[ 0 ] != TEXT('\0'))
            {
                pState->pszStatusArg = StrDup( pszPhoneNumber );
                pState->sidState = SID_S_ConnectNumber;
            }
            else
            {
                pState->pszStatusArg = StrDup( rcs.szDeviceName );
                pState->sidState = SID_S_ConnectDevice;
            }
            break;
        }
    }
}

VOID
DpDeviceConnected(
    IN DPINFO* pInfo,
    IN DPSTATE* pState )

    // RASCS_DeviceConnected state handling.  'PInfo' is the dialog context.
    // 'PState' is the subentry state.
    //
    // Returns 0 if successful, or an error code.
    //
{
    TRACE( "DpDeviceConnected" );

    switch (pState->pbdt)
    {
        case PBDT_Modem:
        {
            pState->sidState = SID_S_ModemConnected;
            pState->fNotPreSwitch = TRUE;
            break;
        }

        case PBDT_Pad:
        {
            pState->sidState = SID_S_PadConnected;
            pState->fNotPreSwitch = TRUE;
            break;
        }

        case PBDT_Switch:
        {
            pState->sidState =
                (pState->fNotPreSwitch)
                    ? SID_S_PostSwitchConnected
                    : SID_S_PreSwitchConnected;
            pState->fNotPreSwitch = TRUE;
            break;
        }

        case PBDT_Null:
        {
            pState->sidState = SID_S_NullConnected;
            pState->fNotPreSwitch = TRUE;
            break;
        }

        case PBDT_Parallel:
        {
            pState->sidState = SID_S_ParallelConnected;
            pState->fNotPreSwitch = TRUE;
            break;
        }

        case PBDT_Irda:
        {
            pState->sidState = SID_S_IrdaConnected;
            pState->fNotPreSwitch = TRUE;
            break;
        }

        default:
        {
            pState->sidState = SID_S_DeviceConnected;
            break;
        }
    }
}


VOID
DpDial(
    IN DPINFO* pInfo,
    IN BOOL fPauseRestart )

    // Dial with the parameters in the 'pInfo' dialog context block.
    // 'FPausedRestart' indicates the dial is restarting from a paused state
    // and dial states should not be reset.
    //
{
    DWORD dwErr;

    TRACE1( "DpDial,fPauseRestart=%d", fPauseRestart );

    if (!fPauseRestart)
    {
        DpInitStates( pInfo );
        
        //comment for bug 277365, 291613 gangz
        //Set the fCallbacksActive to be TRUE
        //
        TRACE("DpDial:Init global actives");

        // XPSP2 511810, .Net 668164
        SetCallbackActive(pInfo);
        IncGlobalCallbackActive();
    }
    else
    {
        TRACE("DpDial:WONT Init global actives for pausedRestart");
    }

    // Whistler bug 254385 encode password when not being used
    // Assumed password was encoded previously
    //
    DecodePassword( pInfo->pArgs->rdp.szPassword );

    TRACE1( "RasDial(h=$%08x)", pInfo->hrasconn );
    ASSERT( g_pRasDial );
    dwErr = g_pRasDial( &pInfo->pArgs->rde, pInfo->pArgs->pFile->pszPath,
            &pInfo->pArgs->rdp, 2, (LPVOID )DpRasDialFunc2, &pInfo->hrasconn );
    TRACE2( "RasDial=%d,h=$%08x", dwErr, pInfo->hrasconn );

    EncodePassword( pInfo->pArgs->rdp.szPassword );

    if (dwErr != 0)
    {
        // This same error will show up via the callback route on restarts
        // from PAUSEd states so avoid double popups in that case.  See bug
        // 367482.
        //
        if (!fPauseRestart)
        {
            // ErrorDlg( pInfo->hwndDlg, SID_OP_RasDial, dwErr, NULL );
            // For whistler 460931
            //
            DialErrorDlg(
                pInfo->hwndDlg,
                pInfo->pArgs, // For whistler 474514
                pInfo->pArgs->pszPhonebook,
                pInfo->pArgs->pszEntry,
                dwErr,
                SID_OP_RasDial,
                NULL,
                SID_FMT_ErrorMsg,
                NULL,
                -2,
                TRUE);
                
            //for  XPSP2 511810, .Net 668164
            ResetCallbackActive(pInfo);
            DecGlobalCallbackActive();
        }
        
        // If we receive error 668 here, it means that a rasevent is currently
        // posted for state RASCS_Disconnected.  We shouldn't cancel in this
        // case since we Normal processing of RASCS_Disconnected will allow the
        // user to redial.  Also, calling DpCancel below will insert
        // WM_DESTROY which will process before the popup that the rasevent
        // produces can display.  367482 
        //
        if (dwErr != ERROR_NO_CONNECTION)
        {
            DpCancel( pInfo );
        }            
    }
}


VOID
DpError(
    IN DPINFO* pInfo,
    IN DPSTATE* pState )

    // Popup error dialog for error identified by 'pState' and cancel or
    // redial as indicated by user.  'PInfo' is the dialog context.
    //
{
    DWORD dwErr;
    DWORD dwRedialAttemptsLeft;
    DWORD sidState;

    TRACE( "DpError" );

    // Retrieve additional text from RASMXS on those special errors where the
    // device returned something useful to display.
    //
    if (pState->dwError == ERROR_FROM_DEVICE
        || pState->dwError == ERROR_UNRECOGNIZED_RESPONSE)
    {
        TCHAR* pszMessage;

        dwErr = GetRasMessage( pInfo->hrasconn, &pszMessage );
        if (dwErr == 0)
        {
            pState->sidFormatMsg = SID_FMT_ErrorMsgResp;
            Free0( pState->pszFormatArg );
            pState->pszFormatArg = pszMessage;
        }
    }

    if (pState->sidFormatMsg == 0)
    {
        if (pState->dwExtendedError != 0)
        {
            // Translate extended error code into arguments.
            //
            TCHAR szNum[ 2 + MAXLTOTLEN + 1 ];

            pState->sidFormatMsg = SID_FMT_ErrorMsgExt;

            szNum[ 0 ] = TEXT('0');
            szNum[ 1 ] = TEXT('x');
            LToT( pState->dwExtendedError, szNum + 2, 16 );

            Free0( pState->pszFormatArg );
            pState->pszFormatArg = StrDup( szNum );
        }
        else if (pState->szExtendedError[ 0 ] != TEXT('\0'))
        {
            // Translate extended error string to argument.  Currently, the
            // string is always a NetBIOS name.
            //
            pState->sidFormatMsg = SID_FMT_ErrorMsgName;
            Free0( pState->pszFormatArg );
            pState->pszFormatArg = StrDup( pState->szExtendedError );
        }
    }

    if (pInfo->hrasconn)
    {
        // Hang up before displaying error popup so server side resources are
        // not tied up waiting for client to acknowledge error.
        //
        ASSERT( g_pRasHangUp );
        TRACE( "RasHangUp" );
        dwErr = g_pRasHangUp( pInfo->hrasconn );
        TRACE1( "RasHangUp=%d", dwErr );
        pInfo->hrasconn = NULL;
    }

    if (pInfo->pArgs->pEntry->pszPrerequisiteEntry
        && *pInfo->pArgs->pEntry->pszPrerequisiteEntry)
    {
        // Select "no Redial button" mode for entries that have prerequisite
        // entries.  This is because RASMAN drops the prerequisite entry as
        // soon as the dependent entry fails, thus dooming to defeat a redial
        // of only the dependent entry.  Yes, it should really redial both
        // entries here, but that is not really feasible with the current
        // non-integrated serial implementation of prerequisite entries.  This
        // at least improves the poor behavior cited in bug 230594.
        //
        dwRedialAttemptsLeft = -2;
    }
    else if (pInfo->dwRedialAttemptsLeft <= 0)
    {
        // No auto-redial countdown, but "Redial" button does appear in place
        // of the default "OK".
        //
        dwRedialAttemptsLeft = -1;
    }
    else
    {
        // Auto-redial countdown based on the entries configuration.
        //
        dwRedialAttemptsLeft =
            GetOverridableParam(
                pInfo->pArgs->pUser,
                pInfo->pArgs->pEntry,
                RASOR_RedialSeconds );
    }

    // This hack works around a bug in RasDial API.  See bug 313102.
    //
    sidState = pState ->sidState;
    if (!sidState)
    {
        sidState = SID_S_AuthNotify;
    }

    if (DialErrorDlg(
            pInfo->hwndDlg,
            pInfo->pArgs,               // For whistler 474514
            pInfo->pArgs->pszPhonebook, // For whislter 460931
            pInfo->pArgs->pEntry->pszEntryName,
            pState->dwError,
            sidState,
            pState->pszStatusArg,
            pState->sidFormatMsg,
            pState->pszFormatArg,
            dwRedialAttemptsLeft,
            GetOverridableParam(
                pInfo->pArgs->pUser, pInfo->pArgs->pEntry,
                RASOR_PopupOnTopWhenRedialing ) ))
    {
        TRACE( "User redials" );
        if (pInfo->dwRedialAttemptsLeft > 0)
        {
            --pInfo->dwRedialAttemptsLeft;
        }

        TRACE(" Post(DIAL)" );
        PostMessage( pInfo->hwndDlg, WM_RASDIAL, FALSE, 0 );
    }
    else
    {
        TRACE( "User cancels" );
        DpCancel( pInfo );
    }

    //
    // Set the error so that the error is propagated back
    // to the caller of the RasDialDlg api.
    //
    TRACE2("DpError settings error (0x%x) to %d",
            &pInfo->pArgs->pArgs->dwError,
            pState->dwError);
    pInfo->pArgs->pArgs->dwError = pState->dwError;
}

// For whistler 435725
//
void
DpEndDialog( 
    IN DPINFO * pInfo,
    IN BOOL fFlag)
{

    PostMessage( pInfo->hwndDlg, WM_DPENDDIALOG, 0, (WPARAM)fFlag );
}


DWORD
DpEvent(
    IN DPINFO* pInfo,
    IN DWORD dwSubEntry )

    // Handle a RasDial callback event on subentry 'dwSubEntry'.  'PInfo' is
    // the dialog context.
    //
    // Return 0 to stop callbacks from RasDial, or 1 to continue callbacks
    // (normal), or 2 to indicate that the phonebook entry has changed and
    // should be re-read by RasDial.
    //
{
    DWORD dwErr;
    DWORD dwCode;
    BOOL fLeader;
    DWORD dwcSuccessLinks, dwcFailedLinks, i;
    DPSTATE* pState;
    BOOL fPartialMultilink;
    BOOL fIsLaterState;

    TRACE( "DpEvent" );

    // Default to "normal" return.
    //
    dwCode = 1;
    fPartialMultilink = FALSE;

    TRACE2("Current proces:(0x%d), Current Thread:(0x%d)",
            GetCurrentProcessId(),
            GetCurrentThreadId());
            
    // Find the associated state information and figure out if this is the
    // most advanced sub-entry.
    //
    pState = &pInfo->pStates[ dwSubEntry - 1 ];
    fIsLaterState = DpIsLaterState( pState->state, pInfo->state );
    if (dwSubEntry == pInfo->dwSubEntry || fIsLaterState)
    {
        fLeader = TRUE;
        if (fIsLaterState)
        {
            pInfo->dwSubEntry = dwSubEntry;
            pInfo->state = pState->state;
        }
    }
    else
    {
        fLeader = FALSE;
        TRACE( "Trailing" );
    }

    // Execute the state.
    //
    TRACE1("State is:(%d)", pState->state);

    switch (pState->state)
    {
        case RASCS_OpenPort:
        {
            pState->pbdt = PBDT_None;
            pState->sidState = SID_S_OpenPort;
            break;
        }

        case RASCS_PortOpened:
        {
            // Should have an hrasconnLink for this subentry now.  Look it up
            // and stash it in our context.
            //
            ASSERT( g_pRasGetSubEntryHandle );
            TRACE1( "RasGetSubEntryHandle(se=%d)", dwSubEntry );
            dwErr = g_pRasGetSubEntryHandle(
                pInfo->hrasconn, dwSubEntry, &pState->hrasconnLink );
            TRACE2( "RasGetSubEntryHandle=%d,hL=$%08x",
                dwErr, pState->hrasconnLink );
            if (dwErr != 0)
            {
                pState->dwError = dwErr;
            }

            pState->sidState = SID_S_PortOpened;
            break;
        }

        case RASCS_ConnectDevice:
        {
            DTLNODE* pNode;
            PBLINK* pLink;

            pNode = DtlNodeFromIndex(
                pInfo->pArgs->pEntry->pdtllistLinks, dwSubEntry - 1 );
            ASSERT( pNode );

            if(NULL == pNode)
            {
                pState->dwError = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                pLink = (PBLINK* )DtlGetData( pNode );
            }

            if ((pState->dwError == ERROR_PORT_OR_DEVICE
                    && (pLink->pbport.fScriptBeforeTerminal
                        || pLink->pbport.fScriptBefore))
                || (pState->dwError == ERROR_USER_DISCONNECTION
                    && (pInfo->pArgs->pUser->fOperatorDial
                        && AllLinksAreModems( pInfo->pArgs->pEntry ))))
            {
                // This happens when user presses Cancel on the Unimodem
                // "Pre-Dial Terminal Screen" or "Operator Assisted or Manual
                // Dial" dialog.
                //
                TRACE("DpEvent:Call DpCancel() in connectDevice, but still return 1\n");
                DpCancel( pInfo );
                return dwCode;
            }

            DpConnectDevice( pInfo, pState );
            break;
        }

        case RASCS_DeviceConnected:
        {
            DpDeviceConnected( pInfo, pState );
            break;
        }

        case RASCS_AllDevicesConnected:
        {
           pState->sidState = SID_S_AllDevicesConnected;
            break;
        }

        case RASCS_Authenticate:
        {
            pState->sidState = SID_S_Authenticate;
            break;
        }

        case RASCS_AuthNotify:
        {
            DpAuthNotify( pInfo, pState );
            break;
        }

        case RASCS_AuthRetry:
        {
            pState->sidState = SID_S_AuthRetry;
            break;
        }

        case RASCS_AuthCallback:
        {
            pState->sidState = SID_S_AuthCallback;
            break;
        }

        case RASCS_AuthChangePassword:
        {
            pState->sidState = SID_S_AuthChangePassword;
            break;
        }

        case RASCS_AuthProject:
        {
            pState->sidState = SID_S_AuthProject;
            break;
        }

        case RASCS_AuthLinkSpeed:
        {
            pState->sidState = SID_S_AuthLinkSpeed;
            break;
        }

        case RASCS_AuthAck:
        {
            pState->sidState = SID_S_AuthAck;
            break;
        }

        case RASCS_ReAuthenticate:
        {
            pState->sidState = SID_S_ReAuthenticate;
            break;
        }

        case RASCS_Authenticated:
        {
            pState->sidState = SID_S_Authenticated;
            break;
        }

        case RASCS_PrepareForCallback:
        {
            pState->sidState = SID_S_PrepareForCallback;
            break;
        }

        case RASCS_WaitForModemReset:
        {
            pState->sidState = SID_S_WaitForModemReset;
            break;
        }

        case RASCS_WaitForCallback:
        {
            pState->sidState = SID_S_WaitForCallback;
            break;
        }

        case RASCS_Projected:
        {
            if (fLeader)
            {
                // If DpProjected returns FALSE, it detected a fatal error,
                // and the dialing process will stop.  If DpProjected returns
                // with pState->dwError non-zero, we display the error in a
                // redial dialog, if redial is configured.
                //
                if (!DpProjected( pInfo, pState ))
                {
                    TRACE("DpEvent:Call DpCancel() in RASCS_Projected, but still return 1 to DpRasDialFunc2()\n");
                
                    DpCancel( pInfo );
                    return dwCode;
                }
                else if (pState->dwError)
                {
                    TRACE("DpCancel() in RASCS_Projected,return 0 to DpRasDialFunc2()");
                    
                    TRACE( "DpEvent:Post(ERROR), return 0 to DpRasDialFunc2()" );
                    PostMessage( pInfo->hwndDlg,
                        WM_RASERROR, 0, (LPARAM )pState );
                    return 0;
                }
            }
            break;
        }

        case RASCS_Interactive:
        {
            BOOL fChange = FALSE;

            if (!DpInteractive( pInfo, pState, &fChange ))
            {
                DpCancel( pInfo );
                return dwCode;
            }

            if (fChange)
            {
                dwCode = 2;
            }
            break;
        }

        case RASCS_RetryAuthentication:
        {
            if (!RetryAuthenticationDlg(
                pInfo->hwndDlg, pInfo->pArgs ))
            {
                DpCancel( pInfo );
                return dwCode;
            }

            pState->sidState = 0;
            break;
        }

        case RASCS_InvokeEapUI:
        {
            if (g_pRasInvokeEapUI(
                    pInfo->hrasconn, dwSubEntry,
                    &pInfo->pArgs->rde, pInfo->hwndDlg ))
            {
                DpCancel( pInfo );
                return dwCode;
            }

            pState->sidState = 0;
            break;
        }

        case RASCS_CallbackSetByCaller:
        {
            DpCallbackSetByCaller( pInfo, pState );
            break;
        }

        case RASCS_PasswordExpired:
        {
            if (!DpPasswordExpired( pInfo, pState ))
            {
                DpCancel( pInfo );
                return dwCode;
            }
            break;
        }

        case RASCS_SubEntryConnected:
        {
            if (pInfo->cStates > 1)
            {
                pState->sidState = SID_S_SubConnected;
            }
            break;
        }

        case RASCS_SubEntryDisconnected:
        {
            break;
        }

        case RASCS_Connected:
        {
            pState->sidState = SID_S_Connected;
            break;
        }

        case RASCS_Disconnected:
        {
            pState->sidState = SID_S_Disconnected;
            break;
        }

        default:
        {
            pState->sidState = SID_S_Unknown;
            break;
        }
    }

    // Count the successful and failed links.
    //
    {
        DPSTATE* p;

        dwcSuccessLinks = dwcFailedLinks = 0;
        for (i = 0, p = pInfo->pStates; i < pInfo->cStates; ++i, ++p)
        {
            if (p->state == RASCS_SubEntryConnected)
            {
                ++dwcSuccessLinks;
            }

            if (p->dwError)
            {
                ++dwcFailedLinks;
            }
        }
    }
    TRACE3( "s=%d,f=%d,t=%d", dwcSuccessLinks, dwcFailedLinks, pInfo->cStates );

    if (pState->dwError)
    {
        DTLNODE *pdtlnode = NULL;
        DWORD dwIndex = pInfo->pArgs->rdp.dwSubEntry;

        if(0 != dwIndex)
        {

            pdtlnode = DtlNodeFromIndex(
                                pInfo->pArgs->pEntry->pdtllistLinks,
                                dwIndex - 1);
        }

        if (    (dwcFailedLinks == pInfo->cStates)
            ||  (   (RASEDM_DialAll != pInfo->pArgs->pEntry->dwDialMode)
                &&  (dwcSuccessLinks == 0))
            ||  (NULL != pdtlnode))
        {
            // A terminal error state has occurred on all links.  Post a
            // message telling ourselves to popup an error, then release the
            // callback so it doesn't hold the port open while the error popup
            // is up,
            //
            TRACE( "Post(ERROR)" );
            PostMessage( pInfo->hwndDlg, WM_RASERROR, 0, (LPARAM )pState );
            return 0;
        }
        else if (dwcSuccessLinks + dwcFailedLinks == pInfo->cStates)
        {
            // An error occurred on the final link, but some link connected.
            // It would be nice if RasDial would followup with a
            // RASCS_Connected in that case, but it doesn't, so we duplicate
            // the RASCS_Connected-style exit here.
            //
            TRACE( "Post(BUNDLEERROR)" );
            PostMessage( pInfo->hwndDlg,
                WM_RASBUNDLEERROR, 0, (LPARAM )pState );
            return 0;
        }

        // A fatal error has occurred on a link, but there are other links
        // still trying, so let it die quietly.
        //
        TRACE2( "Link %d fails, e=%d", dwSubEntry + 1, pState->dwError );
        return dwCode;
    }

    // Display the status string for this state.
    //
    if (pState->sidState)
    {
        if (pState->sidState != pState->sidPrevState)
        {
            pState->sidPrevState = pState->sidState;
        }

        if (fLeader)
        {
            TCHAR* pszState = PszFromId( g_hinstDll, pState->sidState );

            if (    (NULL != pszState)
                &&  pState->pszStatusArg)
            {
                TCHAR* pszFormattedState;
                TCHAR* pszArg;
                TCHAR* apszArgs[ 1 ];
                DWORD cch;

                pszArg = (pState->pszStatusArg)
                    ? pState->pszStatusArg : TEXT("");

                // Find length of formatted string with text argument (if any)
                // inserted and any progress dots appended.
                //
                cch = lstrlen( pszState ) + lstrlen( pszArg ) + 1;

                pszFormattedState = Malloc( cch * sizeof(TCHAR) );
                if (pszFormattedState)
                {
                    apszArgs[ 0 ] = pszArg;
                    *pszFormattedState = TEXT('\0');

                    FormatMessage(
                        FORMAT_MESSAGE_FROM_STRING
                            | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        pszState, 0, 0, pszFormattedState, cch,
                        (va_list* )apszArgs );

                    Free( pszState );
                    pszState = pszFormattedState;
                }
            }

            TRACE1("DpEvent:State:'%s'",pszState);
    
            if (pszState)
            {
                SetWindowText( pInfo->hwndStState, pszState );
                InvalidateRect( pInfo->hwndStState, NULL, TRUE );
                UpdateWindow( pInfo->hwndStState );
                LocalFree( pszState );
            }
        }
    }

    if (pState->state & RASCS_PAUSED)
    {
        // Paused state just processed.  Release the callback, and dial again
        // to resume.
        //
        TRACE("DpEvent:Paused, will dial again\nthe global callbacks wont init again");
        TRACE( "Post(DIAL)" );
        PostMessage( pInfo->hwndDlg, WM_RASDIAL, TRUE, 0 );
        return dwCode;
    }

    if (pState->state & RASCS_DONE)
    {
        // Terminal state just processed.
        //
        if (pState->state == RASCS_Connected)
        {
            // For multi-link entries, if there is at least one successful
            // line and at least one failed line, popup the bundling error
            // dialog.
            //
            if (pInfo->cStates > 1)
            {
                DPSTATE* p;

                dwcSuccessLinks = dwcFailedLinks = 0;
                for (i = 0, p = pInfo->pStates; i < pInfo->cStates; ++i, ++p)
                {
                    if (p->dwError == 0)
                    {
                        ++dwcSuccessLinks;
                    }
                    else
                    {
                        ++dwcFailedLinks;
                    }
                }

                if (dwcSuccessLinks > 0 && dwcFailedLinks > 0)
                {
                     TRACE( "Post(BUNDLEERROR)" );
                     PostMessage( pInfo->hwndDlg,
                         WM_RASBUNDLEERROR, 0, (LPARAM )pState );
                     return 0;
                }
            }

              //For whistler 435725
              //  
              DpEndDialog( pInfo, TRUE );
        }
        else
        {
            DpCancel( pInfo );
        }   

        return 0;
    }

    TRACE1("DpEvent:returned dwCode:(%d)", dwCode);
    TRACE("End of DpEvent");
    
    return dwCode;
}


BOOL
DpInit(
    IN HWND hwndDlg,
    IN DINFO* pArgs )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    // 'PArgs' is caller's arguments as passed to the stub API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    DPINFO* pInfo;
    PBENTRY* pEntry;

    TRACE( "DpInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->dwValid = 0xC0BBC0DE;
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        //Add a per-thread Terminate flag for whistler bug 291613 gangz
        //
        pInfo->fTerminateAsap = FALSE;

        // for  XPSP2 511810, .Net 668164, 668164

        pInfo->pcsActiveLock = 
        (CRITICAL_SECTION*)Malloc(sizeof(CRITICAL_SECTION));
        
        if(NULL == pInfo->pcsActiveLock )
        {
            TRACE("No memory for critical section");
            
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }
        
        __try
        {
            InitializeCriticalSection( pInfo->pcsActiveLock );
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            DWORD dwExceptionCode = GetExceptionCode();
            TRACE1("InitializeCriticalSection() raise:0x%x",dwExceptionCode);
            
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }
        
        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->hwndStState = GetDlgItem( hwndDlg, CID_DP_ST_State );
    ASSERT( pInfo->hwndStState );

    pEntry = pArgs->pEntry;

    // Set up our context to be returned by the RasDialFunc2 callback.
    //
    pInfo->pArgs->rdp.dwCallbackId = (ULONG_PTR )pInfo;

    // Subclass the dialog so we can get the result from
    // SendMessage(WM_RASDIALEVENT) in RasDlgFunc2.
    //
    pInfo->pOldWndProc =
        (WNDPROC )SetWindowLongPtr(
            pInfo->hwndDlg, GWLP_WNDPROC, (ULONG_PTR )DpWndProc );

    // Set the title.
    //
    {
        TCHAR* pszTitleFormat;
        TCHAR* pszTitle;
        TCHAR* apszArgs[ 1 ];

        pszTitleFormat = GetText( hwndDlg );
        if (pszTitleFormat)
        {
            apszArgs[ 0 ] = pEntry->pszEntryName;
            pszTitle = NULL;

            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING
                    | FORMAT_MESSAGE_ALLOCATE_BUFFER
                    | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                pszTitleFormat, 0, 0, (LPTSTR )&pszTitle, 1,
                (va_list* )apszArgs );

            Free( pszTitleFormat );

            if (pszTitle)
            {
                SetWindowText( hwndDlg, pszTitle );
                LocalFree( pszTitle );
            }
        }
    }

    // Set the correct icon. For whistler bug 372078    gangz
    //
    SetIconFromEntryType(
        GetDlgItem( hwndDlg, CID_DP_Icon ),
        pArgs->pEntry->dwType,
        FALSE);     //FALSE means large Icon
    
    // Position the dialog per caller's instructions.
    //
    PositionDlg( hwndDlg,
        pArgs->pArgs->dwFlags & RASDDFLAG_PositionDlg,
        pArgs->pArgs->xDlg, pArgs->pArgs->yDlg );

    // Hide the dialog if "no progress" user preference is set.
    //
    if (!pArgs->pEntry->fShowDialingProgress
        || pArgs->fDialForReferenceOnly)
    {
        SetOffDesktop( hwndDlg, SOD_MoveOff, NULL );
    }

    SetForegroundWindow( hwndDlg );

    // Allocate subentry status array.  It's initialized by DpDial.
    //
    {
        DWORD cb;

        ASSERT( pEntry->pdtllistLinks );
        pInfo->cStates = DtlGetNodes( pEntry->pdtllistLinks );
        cb = sizeof(DPSTATE) * pInfo->cStates;
        pInfo->pStates = Malloc( cb );
        if (!pInfo->pStates)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        pInfo->dwRedialAttemptsLeft =
            GetOverridableParam(
                pInfo->pArgs->pUser, pInfo->pArgs->pEntry,
                RASOR_RedialAttempts );
    }

    //for whistler bug 316622   gangz
    //The dwSubEntry is not initialized
    //
    pInfo->pArgs->rdp.dwSubEntry = pInfo->pArgs->pArgs->dwSubEntry;
    
    // Rock and roll.
    //
    DpDial( pInfo, FALSE );

    return TRUE;
}


VOID
DpInitStates(
    DPINFO* pInfo )

    // Resets 'pInfo->pStates' to initial values.  'PInfo' is the dialog
    // context.
    //
{
    DWORD    i;
    DPSTATE* pState;

    for (i = 0, pState = pInfo->pStates; i < pInfo->cStates; ++i, ++pState)
    {
        ZeroMemory( pState, sizeof(*pState) );
        pInfo->state = (RASCONNSTATE )-1;
        pState->dwError = 0;
    }
}


BOOL
DpInteractive(
    IN DPINFO* pInfo,
    IN DPSTATE* pState,
    OUT BOOL* pfChange )

    // RASCS_Interactive handling.  'PInfo' is the dialog context.  'PState'
    // is the subentry state.  '*pfChange' is set true if the entry (i.e. SLIP
    // address) was changed or false otherwise.
    //
    // Returns true if successful, false if cancel.
    //
{
    DWORD dwErr = NO_ERROR;
    DWORD sidTitle;
    TCHAR szIpAddress[ TERM_IpAddress ];
    TCHAR* pszIpAddress;
    PBENTRY* pEntry;

    TRACE( "DpInteractive" );

    *pfChange = FALSE;
    pEntry = pInfo->pArgs->pEntry;

    if (pEntry->dwBaseProtocol == BP_Slip)
    {
        lstrcpyn( 
            szIpAddress,
            (pEntry->pszIpAddress) ? pEntry->pszIpAddress : TEXT("0.0.0.0"),
            sizeof(szIpAddress) / sizeof(TCHAR));
        pszIpAddress = szIpAddress;
        sidTitle = SID_T_SlipTerminal;
    }
    else
    {
        szIpAddress[0] = TEXT('\0');
        pszIpAddress = szIpAddress;
        sidTitle =
            (pState->sidState == SID_S_ConnectPreSwitch)
                ? SID_T_PreconnectTerminal
                : (pState->sidState == SID_S_ConnectPostSwitch)
                      ? SID_T_PostconnectTerminal
                      : SID_T_ManualDialTerminal;
    }

    if(1 == pEntry->dwCustomScript)
    {
        dwErr = DwCustomTerminalDlg(
                        pInfo->pArgs->pFile->pszPath,
                        pInfo->hrasconn,
                        pEntry,
                        pInfo->hwndDlg,
                        &pInfo->pArgs->rdp,
                        NULL);

        if(SUCCESS == dwErr)
        {
#if 0
            //
            // Reread the phonebook file since the
            // custom script could have written
            // new information to the file.
            // 
            ClosePhonebookFile(pInfo->pArgs->pFile);

            dwErr = ReadPhonebookFile(
                        pInfo->pArgs->pszPhonebook, 
                        &pInfo->pArgs->user, 
                        NULL, 0, &pInfo->pArgs->file );

            if(SUCCESS == dwErr)
            {
                pInfo->pArgs->pFile = &pInfo->pArgs->file;
            }
#endif            
        }
        
        if ( 0 != dwErr )
        {
            ErrorDlg( pInfo->hwndDlg, SID_OP_ScriptHalted, dwErr, NULL );
        }
        
        return (ERROR_SUCCESS == dwErr);
    }

    if (!TerminalDlg(
            pInfo->pArgs->pEntry, &pInfo->pArgs->rdp, pInfo->hwndDlg,
            pState->hrasconnLink, sidTitle, pszIpAddress ))
    {
        TRACE( "TerminalDlg==FALSE" );
        return FALSE;
    }

    TRACE2( "pszIpAddress=0x%08x(%ls)", pszIpAddress,
        pszIpAddress ? pszIpAddress : TEXT("") );
    TRACE2( "pEntry->pszIpAddress=0x%08x(%ls)", pEntry->pszIpAddress,
        pEntry->pszIpAddress ? pEntry->pszIpAddress : TEXT("") );

    if (pszIpAddress[0]
        && (!pEntry->pszIpAddress
            || lstrcmp( pszIpAddress, pEntry->pszIpAddress ) != 0))
    {
        Free0( pEntry->pszIpAddress );
        pEntry->pszIpAddress = StrDup( szIpAddress );
        pEntry->fDirty = TRUE;
        *pfChange = TRUE;

        dwErr = WritePhonebookFile( pInfo->pArgs->pFile, NULL );
        if (dwErr != 0)
        {
            ErrorDlg( pInfo->hwndDlg, SID_OP_WritePhonebook, dwErr, NULL );
        }
    }

    pState->sidState = 0;
    return TRUE;
}


BOOL
DpIsLaterState(
    IN RASCONNSTATE stateNew,
    IN RASCONNSTATE stateOld )

    // Returns true if 'stateNew' is farther along in the connection than
    // 'stateOld' false if the same or not as far along.
    //
{
    // This array is in the order events normally occur.
    //
    // !!! New EAP states?
    //
    static RASCONNSTATE aState[] =
    {
        (RASCONNSTATE )-1,
        RASCS_OpenPort,
        RASCS_PortOpened,
        RASCS_ConnectDevice,
        RASCS_DeviceConnected,
        RASCS_Interactive,
        RASCS_AllDevicesConnected,
        RASCS_StartAuthentication,
        RASCS_Authenticate,
        RASCS_InvokeEapUI,
        RASCS_AuthNotify,
        RASCS_AuthRetry,
        RASCS_AuthAck,
        RASCS_PasswordExpired,
        RASCS_AuthChangePassword,
        RASCS_AuthCallback,
        RASCS_CallbackSetByCaller,
        RASCS_PrepareForCallback,
        RASCS_WaitForModemReset,
        RASCS_WaitForCallback,
        RASCS_CallbackComplete,
        RASCS_RetryAuthentication,
        RASCS_ReAuthenticate,
        RASCS_Authenticated,
        RASCS_AuthLinkSpeed,
        RASCS_AuthProject,
        RASCS_Projected,
        RASCS_LogonNetwork,
        RASCS_SubEntryDisconnected,
        RASCS_SubEntryConnected,
        RASCS_Disconnected,
        RASCS_Connected,
        (RASCONNSTATE )-2,
    };

    RASCONNSTATE* pState;

    for (pState = aState; *pState != (RASCONNSTATE )-2; ++pState)
    {
        if (*pState == stateNew)
        {
            return FALSE;
        }
        else if (*pState == stateOld)
        {
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
DpPasswordExpired(
    IN DPINFO* pInfo,
    IN DPSTATE* pState )

    // RASCS_PasswordExpired state handling.  'PInfo' is the dialog context.
    // 'PState' is the subentry state.
    //
    // Returns true if successful, false otherwise.
    //
{
    TCHAR szOldPassword[ PWLEN + 1 ];
    BOOL fSuppliedOldPassword;

    TRACE( "DpPasswordExpired" );

    szOldPassword[ 0 ] = TEXT('\0');

    // Stash "good" username and password which are restored if the password
    // change fails.
    //
    pInfo->pszGoodUserName = StrDup( pInfo->pArgs->rdp.szUserName );

    // Whistler bug 254385 encode password when not being used
    // Assumed password was encoded previously
    //
    DecodePassword( pInfo->pArgs->rdp.szPassword );
    pInfo->pszGoodPassword = StrDup( pInfo->pArgs->rdp.szPassword );
    EncodePassword( pInfo->pArgs->rdp.szPassword );
    EncodePassword( pInfo->pszGoodPassword );

    fSuppliedOldPassword =
        (!pInfo->pArgs->pEntry->fAutoLogon || pInfo->pArgs->pNoUser);

    if (!ChangePasswordDlg(
            pInfo->hwndDlg, !fSuppliedOldPassword,
            szOldPassword, pInfo->pArgs->rdp.szPassword ))
    {
        // Whistler bug 254385 encode password when not being used
        //
        RtlSecureZeroMemory( szOldPassword, sizeof(szOldPassword) );
        return FALSE;
    }

    if (pInfo->pArgs->pNoUser)
    {
        // Whistler bug 254385 encode password when not being used
        // Assumed password was encoded previously
        //
        DecodePassword( pInfo->pArgs->rdp.szPassword );
        lstrcpyn( 
            pInfo->pArgs->pNoUser->szPassword,
            pInfo->pArgs->rdp.szPassword,
            PWLEN + 1);
        EncodePassword( pInfo->pArgs->rdp.szPassword );
        EncodePassword( pInfo->pArgs->pNoUser->szPassword );
        *pInfo->pArgs->pfNoUserChanged = TRUE;
    }

    // The old password (in text form) is explicitly set, since in AutoLogon
    // case a text form has not yet been specified.  The old password in text
    // form is required to change the password.  The "old" private API expects
    // an ANSI argument.
    //
    if (!fSuppliedOldPassword)
    {
        // Whistler bug 254385 encode password when not being used
        // Assumed password was encoded by ChangePasswordDlg()
        //
        CHAR* pszOldPasswordA;

        DecodePassword( szOldPassword );
        pszOldPasswordA = StrDupAFromT( szOldPassword );
        if (pszOldPasswordA)
        {
            ASSERT( g_pRasSetOldPassword );
            g_pRasSetOldPassword( pInfo->hrasconn, pszOldPasswordA );
            RtlSecureZeroMemory( pszOldPasswordA, lstrlenA( pszOldPasswordA ) );
            Free( pszOldPasswordA );
        }
    }

    RtlSecureZeroMemory( szOldPassword, sizeof(szOldPassword) );

    if (pInfo->pArgs->rdp.szUserName[ 0 ] == TEXT('\0'))
    {
        // Explicitly set the username, effectively turning off AutoLogon for
        // the "resume" password authentication, where the new password should
        // be used.
        //
        lstrcpyn( pInfo->pArgs->rdp.szUserName, GetLogonUser(), UNLEN + 1 );
    }

    pState->sidState = 0;
    return TRUE;
}


BOOL
DpProjected(
    IN DPINFO* pInfo,
    IN DPSTATE* pState )

    // RASCS_Projected state handling.  'PInfo' is the dialog context.
    // 'PState' is the subentry state.
    //
    // Returns true if successful, false otherwise.
    //
{
    DWORD dwErr;
    RASAMB amb;
    RASPPPNBF nbf;
    RASPPPIPX ipx;
    RASPPPIP ip;
    RASPPPLCP lcp;
    RASSLIP slip;
    RASPPPCCP ccp;
    BOOL fIncomplete;
    DWORD dwfProtocols;
    TCHAR* pszLines;

    TRACE( "DpProjected" );

    pState->sidState = SID_S_Projected;

    //
    // If PORT_NOT_OPEN is indicated, it probably means that the 
    // server disconnected the connection before result dialog
    // was dismissed.  In that case, this is the 2nd time DpProjected
    // is called.  This time, the error is indicated by ras and the
    // state remains "projected".
    //
    // We need to return an error in this case so that the connection
    // isn't hung since this is the last indication RAS will give us.
    //
    // See bug 382254
    //

    TRACE1("DpProjected: dwErr:(%d)", pState->dwError);
    
    if ( (pState->dwError == ERROR_PORT_NOT_OPEN) ||
         (pState->dwError == ERROR_NO_CONNECTION) )     //See bug 169111 whistler
    {
        return FALSE;
    }

    // Do this little dance to ignore the error that comes back from the
    // "all-failed" projection since we detect this in the earlier
    // notification where pState->dwError == 0.  This avoids a race where the
    // API comes back with the error before we can hang him up.  This race
    // would not occur if we called RasHangUp from within the callback thread
    // (as recommended in our API doc).  It's the price we pay for posting the
    // error to the other thread in order to avoid holding the port open while
    // an error dialog is up.
    //
    else if (pState->dwError != 0)
    {
        pState->dwError = 0;

        //For  XPSP2 511810, .Net 668164
        ResetCallbackActive(pInfo);
        DecGlobalCallbackActive();
        
        return TRUE;
    }

    // Read projection info for all protocols, translating "not requested"
    // into an in-structure code for later reference.
    //
    dwErr = GetRasProjectionInfo(
        pState->hrasconnLink, &amb, &nbf, &ip, &ipx, &lcp, &slip, &ccp );
    if (dwErr != 0)
    {
        ErrorDlg( pInfo->hwndDlg, SID_OP_RasGetProtocolInfo, dwErr, NULL );
        return FALSE;
    }

    if (amb.dwError != ERROR_PROTOCOL_NOT_CONFIGURED)
    {
        // It's an AMB projection.
        //
        if (amb.dwError != 0)
        {
            // Translate AMB projection errors into regular error codes.  AMB
            // does not use the special PPP projection error mechanism.
            //
            pState->dwError = amb.dwError;
            lstrcpyn( 
                pState->szExtendedError, 
                amb.szNetBiosError,
                sizeof(pState->szExtendedError) / sizeof(TCHAR));
        }
        return TRUE;
    }

    // At this point, all projection information has been gathered
    // successfully and we know it's a PPP-based projection.  Now analyze the
    // projection results...
    //
    dwfProtocols = 0;
    fIncomplete = FALSE;
    if (DpProjectionError(
            &nbf, &ipx, &ip,
            &fIncomplete, &dwfProtocols, &pszLines, &pState->dwError ))
    {
        // A projection error occurred.
        //
        if (fIncomplete)
        {
            BOOL fStatus;
            BOOL fDisable;

            // An incomplete projection occurred, i.e. some requested CPs
            // connected and some did not.  Ask the user if what worked is
            // good enough or he wants to bail.
            //
            pState->dwError = 0;
            fDisable = FALSE;
            fStatus = ProjectionResultDlg(
                pInfo->hwndDlg, pszLines, &fDisable );
            Free( pszLines );

            if (fDisable)
            {
                pInfo->pArgs->dwfExcludedProtocols = dwfProtocols;
            }

            // Return now if user chose to hang up.
            //
            if (!fStatus)
            {
                return FALSE;
            }
        }
        else
        {
            // All CPs in the projection failed.  Process as a regular fatal
            // error with 'pState->dwError' set to the first error in NBF, IP,
            // or IPX, but with a format that substitutes the status argument
            // for the "Error nnn: Description" text.  This lets us patch in
            // the special multiple error projection text, while still giving
            // a meaningful help context.
            //
            Free0( pState->pszFormatArg );
            pState->pszFormatArg = pszLines;
            pState->sidFormatMsg = SID_FMT_ErrorMsgProject;
        }
    }

    //
    // pmay: 190394
    //
    // If the admin has a message, display it.
    //
    if ( (pState->dwError == NO_ERROR)     &&
         (wcslen (lcp.szReplyMessage) != 0)
       )
    {
        MSGARGS MsgArgs, *pMsgArgs = &MsgArgs;

        ZeroMemory(pMsgArgs, sizeof(MSGARGS));
        pMsgArgs->dwFlags = MB_OK | MB_ICONINFORMATION;
        pMsgArgs->apszArgs[0] = lcp.szReplyMessage;

        //MsgDlg(
        //    pInfo->hwndDlg,
        //    SID_ReplyMessageFmt,
        //    pMsgArgs);
    }

    pState->sidState = SID_S_Projected;
    return TRUE;
}


BOOL
DpProjectionError(
    IN RASPPPNBF* pnbf,
    IN RASPPPIPX* pipx,
    IN RASPPPIP* pip,
    OUT BOOL* pfIncomplete,
    OUT DWORD* pdwfFailedProtocols,
    OUT TCHAR** ppszLines,
    OUT DWORD* pdwError )

    // Figure out if a projection error occurred and, if so, build the
    // appropriate status/error text lines into '*ppszLines'.  '*PfIncomlete'
    // is set true if at least one CP succeeded and at least one failed.
    // '*pdwfFailedProtocols' is set to the bit mask of NP_* that failed.
    // '*pdwError' is set to the first error that occurred in NBF, IP, or IPX
    // in that order or 0 if none.  'pnbf', 'pipx', and 'pip' are projection
    // information for the respective protocols with dwError set to
    // ERROR_PROTOCOL_NOT_CONFIGURED if the protocols was not requested.
    //
    // This routine assumes that at least one protocol was requested.
    //
    // Returns true if a projection error occurred, false if not.  It's
    // caller's responsiblity to free '*ppszLines'.
    //
{
#define MAXPROJERRLEN 1024

    TCHAR szLines[ MAXPROJERRLEN ];
    BOOL fIp = (pip->dwError != ERROR_PROTOCOL_NOT_CONFIGURED);
    BOOL fIpx = (pipx->dwError != ERROR_PROTOCOL_NOT_CONFIGURED);
    BOOL fNbf = (pnbf->dwError != ERROR_PROTOCOL_NOT_CONFIGURED);
    BOOL fIpBad = (fIp && pip->dwError != 0);
    BOOL fIpxBad = (fIpx && pipx->dwError != 0);
    BOOL fNbfBad = (fNbf && pnbf->dwError != 0);

    TRACE( "DpProjectionError" );

    *pdwfFailedProtocols = 0;
    if (!fNbfBad && !fIpxBad && !fIpBad)
    {
        return FALSE;
    }

    if (fNbfBad)
    {
        *pdwfFailedProtocols |= NP_Nbf;
    }
    if (fIpxBad)
    {
        *pdwfFailedProtocols |= NP_Ipx;
    }
    if (fIpBad)
    {
        *pdwfFailedProtocols |= NP_Ip;
    }

    *pfIncomplete =
        ((fIp && pip->dwError == 0)
         || (fIpx && pipx->dwError == 0)
         || (fNbf && pnbf->dwError == 0));

    szLines[ 0 ] = 0;
    *ppszLines = NULL;
    *pdwError = 0;

    if (fIpBad || (*pfIncomplete && fIp))
    {
        if (fIpBad)
        {
            *pdwError = pip->dwError;
            DpAppendConnectErrorLine( szLines, SID_Ip, pip->dwError );
        }
        else
        {
            DpAppendConnectOkLine( szLines, SID_Ip );
        }
        DpAppendBlankLine( szLines );
    }

    if (fIpxBad || (*pfIncomplete && fIpx))
    {
        if (fIpxBad)
        {
            *pdwError = pipx->dwError;
            DpAppendConnectErrorLine( szLines, SID_Ipx, pipx->dwError );
        }
        else
        {
            DpAppendConnectOkLine( szLines, SID_Ipx );
        }
        DpAppendBlankLine( szLines );
    }

    if (fNbfBad || (*pfIncomplete && fNbf))
    {
        if (fNbfBad)
        {
            *pdwError = pnbf->dwError;
            DpAppendConnectErrorLine( szLines, SID_Nbf, pnbf->dwError );

            if (pnbf->dwNetBiosError)
            {
                DpAppendFailCodeLine( szLines, pnbf->dwNetBiosError );
            }

            if (pnbf->szNetBiosError[ 0 ] != '\0')
            {
                DpAppendNameLine( szLines, pnbf->szNetBiosError );
            }
        }
        else
        {
            DpAppendConnectOkLine( szLines, SID_Nbf );
        }
        DpAppendBlankLine( szLines );
    }

    *ppszLines = StrDup( szLines );
    return TRUE;
}


DWORD WINAPI
DpRasDialFunc2(
    ULONG_PTR dwCallbackId,
    DWORD dwSubEntry,
    HRASCONN hrasconn,
    UINT unMsg,
    RASCONNSTATE state,
    DWORD dwError,
    DWORD dwExtendedError )

    // RASDIALFUNC2 callback to receive RasDial events.
    //
    // Returns 0 to stop callbacks, 1 to continue callbacks (normal), and 2 to
    // tell RAS API that relevant entry information (like SLIP IP address) has
    // changed.
    //
{
    DWORD dwErr;
    DWORD dwCode;
    DPINFO* pInfo;
    DPSTATE* pState;
    BOOL fTerminateAsap;
    long ulCallbacksActive;
    
    TRACE4( "/DpRasDialFunc2(rcs=%d,s=%d,e=%d,x=%d)",
        state, dwSubEntry, dwError, dwExtendedError );

            
    pInfo = (DPINFO* )dwCallbackId;
    if( NULL == pInfo )
    {
        TRACE("DpRasDialFunc2(): Invalid pInfo");
        return 0;
    }
    
    if (pInfo->dwValid != 0xC0BBC0DE)
    {
        TRACE( "DpRasDialFunc2 returns for Late callback?" );

        return 0;
    }

    if (dwSubEntry == 0 || dwSubEntry > pInfo->cStates)
    {
        TRACE( "DpRasDialFunc2 returns for Subentry out of range?" );
        return 1;
    }

    pState = &pInfo->pStates[ dwSubEntry - 1 ];
    pState->state = state;
    pState->dwError = dwError;
    pState->dwExtendedError = dwExtendedError;

    // Post the event to the Dial Progress window and wait for it to be
    // processed before returning.  This avoids subtle problems with Z-order
    // and focus when a window is manipulated from two different threads.
    //
    TRACE1("Send RasEvent to Dial Progress window, subEntry:(%d)", dwSubEntry);
    TRACE1("Get dwError=(%d) from RasMan",pState->dwError);
    TRACE2("DpRasDialFunc2:Process:(%x),Thread(%x)", 
            GetCurrentProcessId,
            GetCurrentThreadId);
    TRACE2("DpRasDialFunc2:pInfo address (0x%x), Dialog Handle (0x%x)",
            pInfo, 
            pInfo->hwndDlg);
    
    dwCode = (DWORD)SendMessage( pInfo->hwndDlg, WM_RASEVENT, dwSubEntry, 0 );

    TRACE1( "\\DpRasDialFunc2: dwCode from SendMessage()=%d", dwCode );
    TRACE1("dwCode returned:(%d)", dwCode);


    //Check if current thread is cancelled by user
    //
    // For XPSP2 511810, .Net 668164
    fTerminateAsap = GetTerminateFlag(pInfo);
    ulCallbacksActive = GetCallbackActive(pInfo);
    TRACE1("Current thread's active:(%d)", ulCallbacksActive);
    
    if ( fTerminateAsap )
     {
       TRACE("Current Thread wants to terminate itself, its fterminateASSP=1!");
       TRACE("Current thread will decrease its own and global active!");
   
       //reset per-thread terminateASAP flag
       //
       // For XPSP2 511810, .Net 668164
       DecGlobalCallbackActive();
       ResetTerminateFlag( pInfo );
       ResetCallbackActive(pInfo);

       //End callback function for this connection
       //Have to return immediately after ResetCallbackActive() to avoid race 
       // conditions because the UI thread is polling on pInfo->fCallbackActive
       //
       
       return 0; 
     }
     else
     {
       TRACE("Current Thread does NOT want to terminate itself,its fterminateASAP=0!");
     }
   
     //return the global number of active callbacks for tracing
     //
     // For  XPSP2 511810, .Net 668164
     ulCallbacksActive = GetGlobalCallbackActive();
   
     TRACE1("Global active:(%d)", ulCallbacksActive);
     TRACE1("Current thread's active:(%d)", GetCallbackActive(pInfo));
      
    // Check if UI thread want the Callback because of Error, connected, 
    // disconnected etc.
    //
    if (dwCode == 0)
    {
        // Reset thread-safe flag indicating callbacks have terminated.
        //for  XPSP2 511810, .Net 668164
        ResetCallbackActive( pInfo);
        DecGlobalCallbackActive();
    }

    TRACE1( "\\DpRasDialFunc2:final dwCode returned=%d", dwCode );

    return dwCode;
}

// For whistler bug 435725
//
void
DpFreeStates(
    IN DPSTATE * pStates,
    IN DWORD dwSize )
{
    DWORD dwCount = 0;

    for ( dwCount = 0; dwCount < dwSize; dwCount ++ )
    {
        Free0( pStates[dwCount].pszFormatArg );
        Free0( pStates[dwCount].pszStatusArg );
    }
    Free0(pStates);
}

VOID
DpTerm(
    IN HWND hwndDlg )

    // Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    //
{
    DPINFO* pInfo = (DPINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );

    TRACE( "DpTerm" );

    if (pInfo)
    {
        if (pInfo->pOldWndProc)
        {
            SetWindowLongPtr( pInfo->hwndDlg,
                GWLP_WNDPROC, (ULONG_PTR )pInfo->pOldWndProc );
        }

        // For whistler bug 435725      gangz
        // Need to free the strings inside pStates
        //
        DpFreeStates( pInfo->pStates, pInfo->cStates );
        
        pInfo->dwValid = 0;

        // for  XPSP2 511810, .Net 668164, 668164
        DeleteCriticalSection(pInfo->pcsActiveLock);

        Free( pInfo );
        pInfo = NULL;
    }

    //For whistler bug 372078       gangz
    //
    {
        HICON hIcon=NULL;
        hIcon = (HICON)SendMessage( GetDlgItem( hwndDlg, CID_DP_Icon ),
                             STM_GETICON,
                             0,
                             0);
                              
        ASSERT(hIcon);
        if( hIcon )
        {
            DestroyIcon(hIcon);
        }
        else
        {
            TRACE("DpTerm:Destroy Icon failed");
        }
     }
    
}


LRESULT APIENTRY
DpWndProc(
    HWND hwnd,
    UINT unMsg,
    WPARAM wParam,
    LPARAM lParam )

    // Subclassed dialog window procedure.
    //
{
    DPINFO* pInfo = (DPINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
    ASSERT( pInfo );

    if (unMsg == WM_RASEVENT)
    {
        return DpEvent( pInfo, (DWORD )wParam );
    }

    return
        CallWindowProc(
            pInfo->pOldWndProc, hwnd, unMsg, wParam, lParam );
}


//----------------------------------------------------------------------------
// Dialer dialogs
// Listed alphabetically following stub API and dialog proc
//----------------------------------------------------------------------------

BOOL
DialerDlg(
    IN HWND hwndOwner,
    IN OUT DINFO* pInfo )

    // Determine if it's necessary, and if so, popup one of the variations of
    // the dialer dialog, i.e. the prompter for user/password/domain, phone
    // number, and location.  'HwndOwner' is the owning window.  'PInfo' is
    // the dial dialog common context.
    //
    // Returns true if no dialog is needed or user chooses OK.
    //
{
    INT_PTR nStatus = FALSE;
    int nDid;
    DWORD dwfMode;
    DRARGS args;

    TRACE( "DialerDlg" );

    do
    {
        dwfMode = 0;

        if (!pInfo->pEntry->fAutoLogon
            && pInfo->pEntry->fPreviewUserPw
            && (!(pInfo->pArgs->dwFlags & RASDDFLAG_NoPrompt)
                || (pInfo->fUnattended && !HaveSavedPw( pInfo ))))
        {
            dwfMode |= DR_U;

            if (pInfo->pEntry->fPreviewDomain)
            {
                dwfMode |= DR_D;
            }
        }

        if (pInfo->pEntry->fPreviewPhoneNumber
            && (!(pInfo->pArgs->dwFlags & RASDDFLAG_NoPrompt)
                || (pInfo->fUnattended && !HaveSavedPw( pInfo ))))
        {
            DTLNODE* pNode;
            PBLINK* pLink;

            dwfMode |= DR_N;

            // Location controls mode only when at least one phone number in
            // the list is TAPI-enabled.
            //
            pNode = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
            pLink = (PBLINK* )DtlGetData( pNode );
            for (pNode = DtlGetFirstNode( pLink->pdtllistPhones );
                 pNode;
                 pNode = DtlGetNextNode( pNode ))
            {
                PBPHONE* pPhone = (PBPHONE* )DtlGetData( pNode );
                
                if ( pPhone->fUseDialingRules )
                {
                    dwfMode |= DR_L;
                    break;
                }
            }
        }

        // Customize the dialing flags for the type of eap authentication
        // specified for this entry (if any)
        if (DialerEapAssignMode(pInfo, &dwfMode) != NO_ERROR)
            break;

        if (dwfMode == DR_U)
        {
            nDid = DID_DR_DialerU;
        }
        else if (dwfMode == (DR_U | DR_D))
        {
            nDid = DID_DR_DialerUD;
        }
        else if (dwfMode == (DR_U | DR_N))
        {
            nDid = DID_DR_DialerUN;
        }
        else if (dwfMode == (DR_U | DR_N | DR_L))
        {
            nDid = DID_DR_DialerUNL;
        }
        else if (dwfMode == (DR_U | DR_D | DR_N))
        {
            nDid = DID_DR_DialerUDN;
        }
        else if (dwfMode == (DR_U | DR_D | DR_N | DR_L))
        {
            nDid = DID_DR_DialerUDNL;
        }
        else if (dwfMode == DR_N)
        {
            nDid = DID_DR_DialerN;
        }
        else if (dwfMode == (DR_N | DR_L))
        {
            nDid = DID_DR_DialerNL;
        }
        else if (dwfMode == DR_I) {
            nDid = DID_DR_DialerI;
        }
        else if (dwfMode == (DR_I | DR_N)) {
            nDid = DID_DR_DialerIN;
        }
        else if (dwfMode == (DR_I | DR_N | DR_L)) {
            nDid = DID_DR_DialerINL;
        }

        // pmay:  The following 3 permutations of the
        // dialer dialog were added for bug 183577 which
        // states that eap modules (that use DR_I) want to
        // have the domain field available to them as well.
        else if (dwfMode == (DR_I | DR_D)) {
            nDid = DID_DR_DialerID;
        }
        else if (dwfMode == (DR_I | DR_D | DR_N)) {
            nDid = DID_DR_DialerIDN;
        }
        else if (dwfMode == (DR_I | DR_D | DR_N | DR_L)) {
            nDid = DID_DR_DialerIDNL;
        }
        else if( dwfMode == DR_B )
        {
            nDid = DID_DR_DialerB;
        }
        else
        {
            ASSERT( dwfMode == 0 );
            return TRUE;
        }

        args.pDinfo = pInfo;
        args.dwfMode = dwfMode;
        args.fReload = FALSE;

        nStatus =
            (BOOL )DialogBoxParam(
                g_hinstDll,
                MAKEINTRESOURCE( nDid ),
                hwndOwner,
                DrDlgProc,
                (LPARAM )&args );

        if (nStatus == -1)
        {
            ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
            nStatus = FALSE;
        }
    }
    while (args.fReload);

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
DrDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the dialer dialogs.  Parameters and return
    // value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "DrDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return DrInit( hwnd, (DRARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwDrHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            DRINFO* pInfo = (DRINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            return DrCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            DrTerm( hwnd );
            break;
        }
    }

    return FALSE;
}

VOID
DrGetFriendlyFont(
    IN HWND hwnd,
    IN BOOL fUpdate,
    OUT HFONT* phFont )

    // Whistler bug: 195480 Dial-up connection dialog - Number of asterisks
    // does not match the length of the password and causes confusion
    //
{
    LOGFONT BoldLogFont;
    HFONT   hFont;
    HDC     hdc;

    *phFont = NULL;

    // Get the font used by the specified window
    //
    hFont = (HFONT)SendMessage( hwnd, WM_GETFONT, 0, 0L );
    if (NULL == hFont)
    {
        // If not found then the control is using the system font
        //
        hFont = (HFONT)GetStockObject( SYSTEM_FONT );
    }

    if (hFont && GetObject( hFont, sizeof(BoldLogFont), &BoldLogFont ))
    {
        if (fUpdate)
        {
            BoldLogFont.lfItalic = TRUE;
        }

        hdc = GetDC( hwnd );
        if (hdc)
        {
            *phFont = CreateFontIndirect( &BoldLogFont );
            ReleaseDC( hwnd, hdc );
        }
    }

    return;
}

DWORD
DrEnableDisablePwControls(
    IN DRINFO* pInfo,
    IN BOOL fEnable )
{
    if (pInfo->pArgs->pDinfo->fIsPublicPbk)
    {
        EnableWindow( pInfo->hwndRbSaveForEveryone, fEnable );
    }
    else
    {
        EnableWindow( pInfo->hwndRbSaveForEveryone, FALSE );
    }

    EnableWindow( pInfo->hwndRbSaveForMe, fEnable );

    return NO_ERROR;
}

VOID
DrClearFriendlyPassword(
    IN DRINFO* pInfo,
    IN BOOL fFocus )
{
    SetWindowText( pInfo->hwndEbPw, L"" );

    if (fFocus)
    {
        SendMessage( pInfo->hwndEbPw, EM_SETPASSWORDCHAR,
            pInfo->szPasswordChar, 0 );

        if (pInfo->hNormalFont)
        {
            SendMessage(
                pInfo->hwndEbPw,
                WM_SETFONT,
                (WPARAM)pInfo->hNormalFont,
                MAKELPARAM(TRUE, 0) );
        }

        SetFocus( pInfo->hwndEbPw );
    }

    return;
}

VOID
DrDisplayFriendlyPassword(
    IN DRINFO* pInfo,
    IN TCHAR* pszFriendly )
{
    if (pszFriendly)
    {
        SendMessage( pInfo->hwndEbPw, EM_SETPASSWORDCHAR, 0, 0 );
        SetWindowText( pInfo->hwndEbPw, pszFriendly );
    }
    else
    {
        SetWindowText( pInfo->hwndEbPw, L"" );
    }

    if (pInfo->hItalicFont)
    {
        SendMessage(
            pInfo->hwndEbPw,
            WM_SETFONT,
            (WPARAM)pInfo->hItalicFont,
            MAKELPARAM(TRUE, 0) );
    }

    return;
}

BOOL
DrIsPasswordStyleEnabled(
    IN HWND hWnd )
{
    return SendMessage( hWnd, EM_GETPASSWORDCHAR, 0, 0 ) ? TRUE : FALSE;
}

BOOL
DrCommand(
    IN DRINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    DWORD dwErr = NO_ERROR;

    TRACE3( "DrCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_DR_CLB_Numbers:
        {
            if (wNotification == CBN_SELCHANGE)
            {
                DrNumbersSelChange( pInfo );
                return TRUE;
            }
            break;
        }

        case CID_DR_CB_SavePassword:
        {
            BOOL fEnable = Button_GetCheck( hwndCtrl );
            DrEnableDisablePwControls( pInfo, fEnable );
            DrPopulatePasswordField( pInfo, FALSE, FALSE, NULL );
            return TRUE;
        }

        // Whistler bug: 195480 Dial-up connection dialog - Number of asterisks
        // does not match the length of the password and causes confusion
        //
        case CID_DR_EB_Password:
        {
            // This is a hack really so that we restore the Tab Stop to the
            // username field. The reason it had to be removed was because we
            // were receiving complaints that the focus shouldn't always go to
            // the username field if it's non-null. The only way to fix this,
            // since windows sets the initial focus to the first visible non-
            // hidden tab stopped field, is to remove the tab stop temporarily
            // from the username field.
            //
            if (wNotification == EN_KILLFOCUS)
            {
                LONG lStyle = GetWindowLong( pInfo->hwndEbUser, GWL_STYLE );
                HWND hwndTmp = NULL;
/*
                if (!(lStyle & WS_TABSTOP))
                {
                    // If we detect tap stop removed from the username field,
                    // restore it. Since this case only fires when the password
                    // was not previously saved on init, we can return here.
                    //
                    SetWindowLong( pInfo->hwndEbUser, GWL_STYLE,
                        lStyle | WS_TABSTOP );

                    // for whistler bug 424209      gangz
                    // The help button receive the focus before the kill focus 
                    // sent to password edit box
                    //

                    hwndTmp = GetDlgItem( pInfo->hwndDlg, CID_DR_PB_Help );

                    if ( GetFocus() == hwndTmp )
                    {
                        SetFocus( pInfo->hwndEbUser );
                    }
                    
                    return TRUE;
                }
*/
                // If the user leaves the password field w/o typing a new
                // password, and a saved password is present, restore the
                // friendly password text.
                //
                DrPopulatePasswordField( pInfo, FALSE, FALSE, NULL );
                return TRUE;
            }
            // If the password field ever receives the focus, clear the
            // friendly password text if applicable.
            //
            else if (wNotification == EN_SETFOCUS &&
                     !DrIsPasswordStyleEnabled( pInfo->hwndEbPw ))
            {
                DrPopulatePasswordField( pInfo, FALSE, TRUE, NULL );
                return TRUE;
            }
            break;
        }

        case CID_DR_LB_Locations:
        {
            if (wNotification == CBN_SELCHANGE)
            {
                DrLocationsSelChange( pInfo );
                return TRUE;
            }
            break;
        }

        case CID_DR_PB_Rules:
        {
            DrEditSelectedLocation( pInfo );
            return TRUE;
        }

        case CID_DR_PB_Properties:
        {
            DrProperties( pInfo );
            DrPopulatePasswordField( pInfo, FALSE, FALSE, NULL );
            return TRUE;
        }

        case CID_DR_RB_SaveForMe:
        case CID_DR_RB_SaveForEveryone:
        {
            DrPopulatePasswordField( pInfo, FALSE, FALSE, NULL );
            DrPopulateIdentificationFields( pInfo, (wId == CID_DR_RB_SaveForMe));
            return TRUE;
        }

        case IDOK:
        case CID_DR_PB_DialConnect:
        {
            DrSave( pInfo );
            EndDialog( pInfo->hwndDlg, TRUE );
            return TRUE;
        }

        case IDCANCEL:
        case CID_DR_PB_Cancel:
        {
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
        }

        case IDHELP:
        case CID_DR_PB_Help:
        {
            TCHAR* pszCmdLine;

            // Help button now invokes troubleshooting help per bug 210247.
            //
            pszCmdLine = PszFromId( g_hinstDll, SID_DialerHelpCmdLine );
            if (pszCmdLine)
            {
                STARTUPINFO sInfo;
                PROCESS_INFORMATION pProcInfo;

                ZeroMemory( &sInfo, sizeof(sInfo) );
                sInfo.cb = sizeof(sInfo);
                ZeroMemory( &pProcInfo, sizeof(pProcInfo) );
                CreateProcess(
                    NULL, pszCmdLine, NULL, NULL, FALSE,
                    0, NULL, NULL, &sInfo, &pProcInfo );

                Free( pszCmdLine );
            }
            return TRUE;
        }
    }

    return FALSE;
}


BOOL CALLBACK
DrClbNumbersEnumChildProc(
    IN HWND hwnd,
    IN LPARAM lparam )

    // Standard Windows EnumChildProc routine called back for each child
    // window of the 'ClbNumbers' control.
    //
{
    DRINFO* pInfo;
    LONG lId;

    pInfo = (DRINFO* )lparam;

    // There only one child window and it's the edit window.
    //
    pInfo->hwndClbNumbersEb = hwnd;

    return FALSE;
}


BOOL CALLBACK
DrClbNumbersEnumWindowsProc(
    IN HWND hwnd,
    IN LPARAM lparam )

    // Standard Windows EnumWindowsProc routine called back for each top-level
    // window.
    //
{
    RECT rect;

    GetWindowRect( hwnd, &rect );
    if (rect.right - rect.left == DR_BOGUSWIDTH)
    {
        // This window has the unusual bogus width, so it must be the
        // list-box.
        //
        ((DRINFO* )lparam)->hwndClbNumbersLb = hwnd;
        return FALSE;
    }

    return TRUE;
}


LRESULT APIENTRY
DrClbNumbersEbWndProc(
    HWND hwnd,
    UINT unMsg,
    WPARAM wParam,
    LPARAM lParam )

    // Subclassed combo-box edit-box child window procedure providing "manual
    // edit" behavior.
    //
    // Return value depends on message type.
    //
{
    DRINFO* pInfo;

    switch (unMsg)
    {
        case WM_SETTEXT:
        {
            // Prevent the combo-box from setting the contents of the edit box
            // by discarding the request and reporting success.
            //
            return TRUE;
        }

        case DR_WM_SETTEXT:
        {
            // Convert our private SETTEXT to a regular SETTEXT and pass it on
            // to the edit control.
            //
            unMsg = WM_SETTEXT;
            break;
        }
    }

    // Call the previous window procedure for everything else.
    //
    pInfo = (DRINFO* )GetProp( hwnd, g_contextId );
    ASSERT( pInfo );

    return
        CallWindowProc(
            pInfo->wndprocClbNumbersEb, hwnd, unMsg, wParam, lParam );
}


LRESULT APIENTRY
DrClbNumbersLbWndProc(
    HWND hwnd,
    UINT unMsg,
    WPARAM wParam,
    LPARAM lParam )

    // Subclassed combo-box list-box child window procedure providing "manual
    // edit" behavior.
    //
    // Return value depends on message type.
    //
{
    DRINFO* pInfo;

    pInfo = (DRINFO* )GetProp( hwnd, g_contextId );
    ASSERT( pInfo );

    switch (unMsg)
    {
        case LB_FINDSTRINGEXACT:
        case LB_FINDSTRING:
        {
            // This prevents the edit-box "completion" behavior of the
            // combo-box, i.e. it prevents the edit-box contents from being
            // extended to the closest match in the list.
            //
            return -1;
        }

        case LB_SETCURSEL:
        case LB_SETTOPINDEX:
        {
            // Prevent the "match selection to edit-box" combo-box behavior by
            // discarding any attempts to set the selection or top index to
            // anything other than what we set.
            //
            if (wParam != pInfo->pLink->iLastSelectedPhone)
            {
                return -1;
            }
            break;
        }
    }

    // Call the previous window procedure for everything else.
    //
    return
        CallWindowProc(
            pInfo->wndprocClbNumbersLb, hwnd, unMsg, wParam, lParam );
}

VOID
DrEditSelectedLocation(
    IN DRINFO* pInfo )

    // Called when the Dialing Rules button is pressed.  'PInfo' is the dialog
    // context.
    //
{
    DWORD dwErr;
    INT iSel;
    DRNUMBERSITEM* pItem;

    TRACE( "DrEditSelectedLocation" );

    // Look up the phone number information for the selected number.
    //
    pItem = (DRNUMBERSITEM* )ComboBox_GetItemDataPtr(
        pInfo->hwndClbNumbers, ComboBox_GetCurSel( pInfo->hwndClbNumbers ) );
    ASSERT( pItem );

    if(NULL == pItem)
    {   
        return;
    }
    
    ASSERT( pItem->pPhone->fUseDialingRules );

    // Popup TAPI dialing rules dialog.
    //
    dwErr = TapiLocationDlg(
        g_hinstDll,
        &pInfo->hlineapp,
        pInfo->hwndDlg,
        pItem->pPhone->dwCountryCode,
        pItem->pPhone->pszAreaCode,
        pItem->pPhone->pszPhoneNumber,
        0 );

    if (dwErr != 0)
    {
        ErrorDlg( pInfo->hwndDlg, SID_OP_LoadTapiInfo, dwErr, NULL );
    }

    // Might have changed the location list so re-fill it.
    //
    DrFillLocationList( pInfo );
}


DWORD
DrFillLocationList(
    IN DRINFO* pInfo )

    // Fills the dropdown list of locations and sets the current selection.
    //
    // Returns 0 if successful, or an error code.
    //
{
    DWORD dwErr;
    LOCATION* pLocations;
    LOCATION* pLocation;
    DWORD cLocations;
    DWORD dwCurLocation;
    DWORD i;

    TRACE( "DrFillLocationList" );

    ComboBox_ResetContent( pInfo->hwndLbLocations );

    pLocations = NULL;
    cLocations = 0;
    dwCurLocation = 0xFFFFFFFF;
    dwErr = GetLocationInfo(
        g_hinstDll, &pInfo->hlineapp,
        &pLocations, &cLocations, &dwCurLocation );
    if (dwErr != 0)
    {
        return dwErr;
    }

    for (i = 0, pLocation = pLocations;
         i < cLocations;
         ++i, ++pLocation)
    {
        INT iItem;

        iItem = ComboBox_AddItem(
            pInfo->hwndLbLocations, pLocation->pszName,
            (VOID* )UlongToPtr(pLocation->dwId ));

        if (pLocation->dwId == dwCurLocation)
        {
            ComboBox_SetCurSelNotify( pInfo->hwndLbLocations, iItem );
        }
    }

    FreeLocationInfo( pLocations, cLocations );
    ComboBox_AutoSizeDroppedWidth( pInfo->hwndLbLocations );

    return dwErr;
}


VOID
DrFillNumbersList(
    IN DRINFO* pInfo )

    // Fill the "Dial" combo-box with phone numbers and comments, and
    // re-select the selected item in the list, or if none, the last one
    // selected as specified in the PBLINK.
    //
{
    DTLNODE* pNode;
    PBLINK* pLink;
    PBPHONE* pPhone;
    INT cItems;
    INT i;

    DrFreeClbNumbers( pInfo );

    for (pNode = DtlGetFirstNode( pInfo->pLink->pdtllistPhones ), i = 0;
         pNode;
         pNode = DtlGetNextNode( pNode ), ++i)
    {
        TCHAR szBuf[ RAS_MaxPhoneNumber + RAS_MaxDescription + 3 + 1 ];
        DRNUMBERSITEM* pItem;

        pPhone = (PBPHONE* )DtlGetData( pNode );
        ASSERT( pPhone );

        pItem = Malloc( sizeof(DRNUMBERSITEM) );
        if (!pItem)
        {
            break;
        }

        // Build the "<number> - <comment>" string in 'szBuf'.
        //
        pItem->pszNumber =
            LinkPhoneNumberFromParts(
                g_hinstDll, &pInfo->hlineapp,
                pInfo->pArgs->pDinfo->pUser,  pInfo->pArgs->pDinfo->pEntry,
                pInfo->pLink, i, NULL, FALSE );

        if (!pItem->pszNumber)
        {
            // Should not happen.
            //
            Free( pItem );
            break;
        }

        lstrcpyn( szBuf, pItem->pszNumber,  RAS_MaxPhoneNumber);
        if (pPhone->pszComment && !IsAllWhite( pPhone->pszComment ))
        {
            DWORD dwLen, dwSize = sizeof(szBuf) / sizeof(TCHAR);
            
            lstrcat( szBuf, TEXT(" - ") );
            dwLen = lstrlen(szBuf) + 1;
            lstrcpyn( 
                szBuf + (dwLen - 1), 
                pPhone->pszComment,
                dwSize - dwLen );
        }

        pItem->pPhone = pPhone;

        ComboBox_AddItem( pInfo->hwndClbNumbers, szBuf, pItem );
    }

    // Make the selection and trigger the update of the edit-box to the number
    // without the comment.
    //
    cItems = ComboBox_GetCount( pInfo->hwndClbNumbers );
    if (cItems > 0)
    {
        if ((INT )pInfo->pLink->iLastSelectedPhone >= cItems)
        {
            pInfo->pLink->iLastSelectedPhone = 0;
        }

        ListBox_SetTopIndex(
            pInfo->hwndClbNumbersLb, pInfo->pLink->iLastSelectedPhone );
        ComboBox_SetCurSelNotify(
            pInfo->hwndClbNumbers, pInfo->pLink->iLastSelectedPhone );
    }

    ComboBox_AutoSizeDroppedWidth( pInfo->hwndClbNumbers );
}


VOID
DrFreeClbNumbers(
    IN DRINFO* pInfo )

    // Free up the displayable number string associated with each entry of the
    // phone number combo-box leaving the box empty.
    //
{
    DRNUMBERSITEM* pItem;

    while (pItem = ComboBox_GetItemDataPtr( pInfo->hwndClbNumbers, 0 ))
    {
        ComboBox_DeleteString( pInfo->hwndClbNumbers, 0 );
        Free( pItem->pszNumber );
        Free( pItem );
    }
}


DWORD
DrFindAndSubclassClbNumbersControls(
    IN DRINFO* pInfo )

    // Locate and sub-class the edit-box and list-box child controls of the
    // phone number combo-box.  This is necessary to get "manual edit"
    // behavior, i.e. prevent the combo-box from automatically updating the
    // edit box at various times.  We need this because the phone number
    // comments are to be appended in the list, but not in the edit box.
    // 'PInfo' is the dialog context.
    //
    // Returns 0 if successful or an error code.
    //
{
    DWORD dxOld;

    // Find the edit window which is simply a child enumeration.
    //
    EnumChildWindows(
        pInfo->hwndClbNumbers,
        DrClbNumbersEnumChildProc,
        (LPARAM)pInfo );

    if (!pInfo->hwndClbNumbersEb)
    {
        return ERROR_NOT_FOUND;
    }

    // Find the list window which *sigh* doesn't show up in the child
    // enumeration though it has WS_CHILD style because Windows sets it's
    // parent window to NULL after it is created.  To find it, we set the
    // dropped width to an unusual bogus value, then search all windows for
    // one with that width.
    //
    dxOld = (DWORD )SendMessage(
        pInfo->hwndClbNumbers, CB_GETDROPPEDWIDTH, 0, 0 );
    SendMessage( pInfo->hwndClbNumbers,
        CB_SETDROPPEDWIDTH, (WPARAM )DR_BOGUSWIDTH, 0 );
    EnumWindows( DrClbNumbersEnumWindowsProc, (LPARAM)pInfo );
    SendMessage( pInfo->hwndClbNumbers,
        CB_SETDROPPEDWIDTH, (WPARAM )dxOld, 0 );

    if (!pInfo->hwndClbNumbersLb)
    {
        return ERROR_NOT_FOUND;
    }

    // Subclass the windows after associating the dialog context with them for
    // retrieval in the WndProcs.
    //
    SetProp( pInfo->hwndClbNumbersEb, g_contextId, pInfo );
    SetProp( pInfo->hwndClbNumbersLb, g_contextId, pInfo );

    pInfo->wndprocClbNumbersEb =
        (WNDPROC )SetWindowLongPtr(
            pInfo->hwndClbNumbersEb,
            GWLP_WNDPROC, (ULONG_PTR )DrClbNumbersEbWndProc );

    pInfo->wndprocClbNumbersLb =
        (WNDPROC )SetWindowLongPtr(
            pInfo->hwndClbNumbersLb,
            GWLP_WNDPROC, (ULONG_PTR )DrClbNumbersLbWndProc );


    return 0;
}

void
DrEnsureNetshellLoaded (
    IN DRINFO* pInfo)
{
    // Load the netshell utilities interface.  The interface is freed in PeTerm.
    //
    if (!pInfo->pNetConUtilities)
    {
        // Initialize the NetConnectionsUiUtilities
        //
        HrCreateNetConnectionUtilities( &pInfo->pNetConUtilities );
    }
}

BOOL
DrInit(
    IN HWND hwndDlg,
    IN DRARGS* pArgs )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    // 'PArgs' is caller's arguments to the stub API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr = NO_ERROR;
    DRINFO* pInfo;
    PBENTRY* pEntry;
    BOOL fEnableProperties;
    
    // For whistler bug 424209      gangz
    //
    BOOL fUseDefaultFocus = TRUE;
    
    TRACE( "DrInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pEntry = pArgs->pDinfo->pEntry;

    pInfo->hwndBmDialer = GetDlgItem( hwndDlg, CID_DR_BM_Useless );
    ASSERT( pInfo->hwndBmDialer );

    // Look up control handles.
    //
    if ((pArgs->dwfMode & DR_U) ||
        (pArgs->dwfMode & DR_I))
    {
        pInfo->hwndEbUser = GetDlgItem( hwndDlg, CID_DR_EB_User );
        ASSERT( pInfo->hwndEbUser );

        if (pArgs->dwfMode & DR_U)
        {
            pInfo->hwndEbPw = GetDlgItem( hwndDlg, CID_DR_EB_Password );
            ASSERT( pInfo->hwndEbPw );

            pInfo->hwndCbSavePw = GetDlgItem( hwndDlg, CID_DR_CB_SavePassword );
            ASSERT( pInfo->hwndCbSavePw );
            pInfo->hwndRbSaveForMe = GetDlgItem( hwndDlg, CID_DR_RB_SaveForMe );
            ASSERT( pInfo->hwndRbSaveForMe );
            pInfo->hwndRbSaveForEveryone =
                GetDlgItem( hwndDlg, CID_DR_RB_SaveForEveryone );
            ASSERT( pInfo->hwndRbSaveForEveryone );
        }

        if (pArgs->dwfMode & DR_D)
        {
            pInfo->hwndEbDomain = GetDlgItem( hwndDlg, CID_DR_EB_Domain );
            ASSERT( pInfo->hwndEbDomain );
        }
    }

    if (pArgs->dwfMode & DR_N)
    {
        pInfo->hwndClbNumbers = GetDlgItem( hwndDlg, CID_DR_CLB_Numbers );
        ASSERT( pInfo->hwndClbNumbers );

        if (pArgs->dwfMode & DR_L)
        {
            pInfo->hwndStLocations = GetDlgItem( hwndDlg, CID_DR_ST_Locations );
            ASSERT( pInfo->hwndStLocations );
            pInfo->hwndLbLocations = GetDlgItem( hwndDlg, CID_DR_LB_Locations );
            ASSERT( pInfo->hwndLbLocations );
            pInfo->hwndPbRules = GetDlgItem( hwndDlg, CID_DR_PB_Rules );
            ASSERT( pInfo->hwndPbRules );
        }
    }

    pInfo->hwndPbProperties = GetDlgItem( hwndDlg, CID_DR_PB_Properties );
    ASSERT( pInfo->hwndPbProperties );

    // In location-enabled mode, popup TAPI's "first location" dialog if they
    // are uninitialized.  Typically, this will do nothing.
    //
    if (pArgs->dwfMode & DR_L)
    {
        dwErr = TapiNoLocationDlg( g_hinstDll, &pInfo->hlineapp, hwndDlg );
        if (dwErr != 0)
        {
            // Error here is treated as a "cancel" per bug 288385.
            //
            pArgs->pDinfo->pArgs->dwError = 0;
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }
    }

    // Set the title.
    //
    {
        TCHAR* pszTitleFormat;
        TCHAR* pszTitle;
        TCHAR* apszArgs[ 1 ];

        if (pArgs->pDinfo->fUnattended)
        {
            pszTitleFormat = PszFromId( g_hinstDll, SID_DR_ReconnectTitle );
        }
        else
        {
            pszTitleFormat = GetText( hwndDlg );
        }

        if (pszTitleFormat)
        {
            apszArgs[ 0 ] = pEntry->pszEntryName;
            pszTitle = NULL;

            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING
                    | FORMAT_MESSAGE_ALLOCATE_BUFFER
                    | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                pszTitleFormat, 0, 0, (LPTSTR )&pszTitle, 1,
                (va_list* )apszArgs );

            Free( pszTitleFormat );

            if (pszTitle)
            {
                SetWindowText( hwndDlg, pszTitle );
                LocalFree( pszTitle );
            }
        }
    }

    // Change the Dial button to Connect for non-phone devices.
    //
    if (pEntry->dwType != RASET_Phone)
    {
        TCHAR* psz;

        psz = PszFromId( g_hinstDll, SID_ConnectButton );
        if (psz)
        {
            SetWindowText( GetDlgItem( hwndDlg, CID_DR_PB_DialConnect ), psz );
            Free( psz );
        }
    }

    // Initialize credentials section.
    //
    if (pArgs->dwfMode & DR_U)
    {
        ASSERT( !pEntry->fAutoLogon );

        // Fill credential fields with initial values.
        //
        Edit_LimitText( pInfo->hwndEbUser, UNLEN );
        SetWindowText( pInfo->hwndEbUser, pArgs->pDinfo->rdp.szUserName );
        Edit_LimitText( pInfo->hwndEbPw, PWLEN );

        if (pArgs->dwfMode & DR_D)
        {
            Edit_LimitText( pInfo->hwndEbDomain, DNLEN );
            SetWindowText( pInfo->hwndEbDomain, pArgs->pDinfo->rdp.szDomain );
        }

        if (pArgs->pDinfo->pNoUser || pArgs->pDinfo->fDisableSavePw)
        {
            // Can't stash password without a logon context, so hide the
            // checkbox.
            //
            ASSERT( !HaveSavedPw( pArgs->pDinfo )) ;
            EnableWindow( pInfo->hwndCbSavePw, FALSE );
            EnableWindow( pInfo->hwndRbSaveForMe, FALSE );
            EnableWindow( pInfo->hwndRbSaveForEveryone, FALSE );

            // Whistler bug 400714 RAS does not grab password at winlogon time
            // when Connect dialog is displayed
            //
            // Whistler bug 254385 encode password when not being used
            // Assumed password was encoded previously
            //
            DecodePassword( pArgs->pDinfo->rdp.szPassword );
            SetWindowText( pInfo->hwndEbPw, pArgs->pDinfo->rdp.szPassword );
            EncodePassword( pArgs->pDinfo->rdp.szPassword );
        }
        else
        {
            // Whistler bug: 195480 Dial-up connection dialog - Number of
            // asterisks does not match the length of the password and causes
            // confusion
            //
            // Init the password character. Default to the round dot if we fail
            // to get it.
            //
            pInfo->szPasswordChar = (WCHAR) SendMessage( pInfo->hwndEbPw,
                                                EM_GETPASSWORDCHAR, 0, 0 );
            if (!pInfo->szPasswordChar)
            {
                pInfo->szPasswordChar = 0x25CF;
            }

            // Init the fonts for the password field
            //
            DrGetFriendlyFont( hwndDlg, TRUE, &(pInfo->hItalicFont) );
            DrGetFriendlyFont( hwndDlg, FALSE, &(pInfo->hNormalFont) );

            // Check "save password" and render the type of saved
            // password.
            //
            Button_SetCheck(
               pInfo->hwndCbSavePw,
               HaveSavedPw( pArgs->pDinfo ));

            if ((!pArgs->pDinfo->fIsPublicPbk) ||
                (!HaveSavedPw( pArgs->pDinfo )))
            {
                // If this is a for-me-only connection or if
                // there is no saved password, then  initialize the 
                // pw save type to save-for-me
                //
                Button_SetCheck( pInfo->hwndRbSaveForMe, TRUE );
            }
            else
            {
                // Check the appropriate radio button
                // Note that a per-user password is always used if
                // both a per-user and global password are saved.
                // Dont check global password if its a per-user connectoid
                //
                Button_SetCheck( 
                    (pArgs->pDinfo->fHaveSavedPwUser)   ?
                        pInfo->hwndRbSaveForMe          :
                        pInfo->hwndRbSaveForEveryone,
                    TRUE);
            }

            DrEnableDisablePwControls( pInfo, HaveSavedPw( pArgs->pDinfo ) );

            // Whistler bug: 195480 Dial-up connection dialog - Number of
            // asterisks does not match the length of the password and causes
            // confusion
            //
            DrPopulatePasswordField( pInfo, TRUE, FALSE, 
                &fUseDefaultFocus);

        }
    }

    if (pArgs->dwfMode & DR_N)
    {
        pInfo->pLinkNode = NULL;
        if (pArgs->pDinfo->pArgs->dwSubEntry > 0)
        {
            // Look up the API caller specified link.
            //
            pInfo->pLinkNode =
                DtlNodeFromIndex(
                    pArgs->pDinfo->pEntry->pdtllistLinks,
                    pArgs->pDinfo->pArgs->dwSubEntry - 1 );
        }

        if (!pInfo->pLinkNode)
        {
            // Look up the default (first) link.
            //
            pInfo->pLinkNode =
                DtlGetFirstNode( pArgs->pDinfo->pEntry->pdtllistLinks );
        }

        ASSERT( pInfo->pLinkNode );
        pInfo->pLink = (PBLINK* )DtlGetData( pInfo->pLinkNode );

        dwErr = DrFindAndSubclassClbNumbersControls( pInfo );
        if (dwErr != 0)
        {
            pArgs->pDinfo->pArgs->dwError = ERROR_NOT_FOUND;
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        // Ignore any "last selected" information when the "try next on fail"
        // flag is set.  New entries will not have "last selected" non-0 in
        // this case but pre-existing entries might, so double-check here.
        // See bug 150958.
        //
        if (pInfo->pLink->fTryNextAlternateOnFail)
        {
            pInfo->pLink->iLastSelectedPhone = 0;
        }

        // Record the initially selected phone number, used to determine
        // whether user has changed the selection.
        //
        pInfo->iFirstSelectedPhone = pInfo->pLink->iLastSelectedPhone;

        DrFillNumbersList( pInfo );

        if (pArgs->dwfMode & DR_L)
        {
            DrFillLocationList( pInfo );
        }
    }

    // danielwe: Bug #222744, scottbri Bug #245310
    // Disable Properties... button if user does not have sufficent rights.
    //
    {
        HRESULT hr;

        hr = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );
        if (hr == RPC_E_CHANGED_MODE)
        {
            hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
        }

        if (hr == S_OK || hr == S_FALSE)
        {
            pInfo->fComInitialized = TRUE;
        }
    }

    fEnableProperties = FALSE;
    DrEnsureNetshellLoaded (pInfo);
    if (NULL != pInfo->pNetConUtilities)
    {
        //For whislter bug 409504           gangz
        //for a VPN double dial scenario,if now it is in the prerequiste dial
        //process, we should use DINFO->pEntryMain->pszPrerequisitePbk to check
        //if it is a publicPhonebook
        //
        BOOL fAllUsers = TRUE;
        
        if( pArgs->pDinfo->fPrerequisiteDial )
        {
            fAllUsers = 
                IsPublicPhonebook(pArgs->pDinfo->pEntryMain->pszPrerequisitePbk);
        }
        else
        {
            fAllUsers = IsPublicPhonebook(pArgs->pDinfo->pszPhonebook);
        }
        
        if (((fAllUsers && INetConnectionUiUtilities_UserHasPermission(
                                        pInfo->pNetConUtilities, 
                                        NCPERM_RasAllUserProperties)) ||
            (!fAllUsers && INetConnectionUiUtilities_UserHasPermission(
                                        pInfo->pNetConUtilities, 
                                        NCPERM_RasMyProperties))) &&
            (NULL == pArgs->pDinfo->pNoUser))
        {
            fEnableProperties = TRUE;
        }

        // We only needed it breifly, release it
        INetConnectionUiUtilities_Release(pInfo->pNetConUtilities);
        pInfo->pNetConUtilities = NULL;
    }

    // stevec: 267157-Allow access at win-login if admin enables.
    //
    if (NULL != pArgs->pDinfo->pNoUser
        && pArgs->pDinfo->pUser->fAllowLogonPhonebookEdits)
    {
        fEnableProperties = TRUE;
    }

    EnableWindow( pInfo->hwndPbProperties, fEnableProperties );

    // The help engine doesn't work at win-logon as it requires a user
    // context, so disable the Help button in that case.  See bug 343030.
    //
    if (pArgs->pDinfo->pNoUser)
    {
        HWND hwndPbHelp;

        hwndPbHelp = GetDlgItem( hwndDlg, CID_DR_PB_Help );
        ASSERT( hwndPbHelp );

        EnableWindow( hwndPbHelp, FALSE );
        ShowWindow( hwndPbHelp, SW_HIDE );
    }

    // Set the bitmap to the low res version if that is appropriate
    //
    // Ignore the error -- it is non-critical
    //
    DrSetBitmap(pInfo);

    // Position the dialog per caller's instructions.
    //
    PositionDlg( hwndDlg,
        !!(pArgs->pDinfo->pArgs->dwFlags & RASDDFLAG_PositionDlg),
        pArgs->pDinfo->pArgs->xDlg, pArgs->pDinfo->pArgs->yDlg );

    //Add this function for whislter bug  320863    gangz
    //To adjust the bitmap's position and size
    //
    CenterExpandWindowRemainLeftMargin( pInfo->hwndBmDialer,
                                        hwndDlg,
                                        TRUE,
                                        TRUE,
                                        pInfo->hwndEbUser);

    // Adjust the title bar widgets.
    //
    //TweakTitleBar( hwndDlg );
    AddContextHelpButton( hwndDlg );

    return fUseDefaultFocus;
}

VOID
DrLocationsSelChange(
    IN DRINFO* pInfo )

    // Called when a location is selected from the list.  'PInfo' is the
    // dialog context.
    //
{
    DWORD dwErr;
    DWORD dwLocationId;

    TRACE("DuLocationChange");

    // Set global TAPI location based on user's selection.
    //
    dwLocationId = (DWORD )ComboBox_GetItemData(
        pInfo->hwndLbLocations, ComboBox_GetCurSel( pInfo->hwndLbLocations ) );

    dwErr = SetCurrentLocation( g_hinstDll, &pInfo->hlineapp, dwLocationId );
    if (dwErr != 0)
    {
        ErrorDlg( pInfo->hwndDlg, SID_OP_SaveTapiInfo, dwErr, NULL );
    }

    // Location change may cause changes in built numbers so re-fill the
    // numbers combo-box.
    //
    DrFillNumbersList( pInfo );
}


VOID
DrNumbersSelChange(
    IN DRINFO* pInfo )

    // Called when a phone number is selected from the list.  'PInfo' is the
    // dialog context.
    //
{
    INT iSel;
    BOOL fEnable;
    DRNUMBERSITEM* pItem;

    iSel = ComboBox_GetCurSel( pInfo->hwndClbNumbers );
    if (iSel >= 0)
    {
        if (iSel != (INT )pInfo->pLink->iLastSelectedPhone)
        {
            pInfo->pArgs->pDinfo->pEntry->fDirty = TRUE;
        }
        pInfo->pLink->iLastSelectedPhone = (DWORD )iSel;
    }

    pItem = (DRNUMBERSITEM* )ComboBox_GetItemDataPtr(
        pInfo->hwndClbNumbers, iSel );
    ASSERT( pItem );

    if(NULL == pItem)
    {
        return;
    }

    // Enable/disable the location fields based on whether they are relevant
    // to the selected number.
    //
    if (pInfo->pArgs->dwfMode & DR_L)
    {
        fEnable = pItem->pPhone->fUseDialingRules;
        EnableWindow( pInfo->hwndStLocations, fEnable );
        EnableWindow( pInfo->hwndLbLocations, fEnable );
        EnableWindow( pInfo->hwndPbRules, fEnable );
    }

    DrSetClbNumbersText( pInfo, pItem->pszNumber );
}


DWORD
DrPopulateIdentificationFields(
    IN DRINFO* pInfo,
    IN BOOL fForMe )

    // Updates the identification fields in the dialer
    // UI according to whether the all-user or per-user
    // dialparms should be used.
    //
    
{
    RASDIALPARAMS* prdp, *prdpOld;
    BOOL fUpdate;
    TCHAR pszUser[UNLEN + 1];
    INT iCount;

    prdp = (fForMe) 
        ? &(pInfo->pArgs->pDinfo->rdpu) : &(pInfo->pArgs->pDinfo->rdpg);
    prdpOld = (fForMe) 
        ? &(pInfo->pArgs->pDinfo->rdpg) : &(pInfo->pArgs->pDinfo->rdpu);

    iCount = GetWindowText(
                pInfo->hwndEbUser,
                pszUser, 
                UNLEN + 1);
    if (iCount == 0)
    {
        fUpdate = TRUE;
    }
    else
    {
        if (lstrcmp(prdpOld->szUserName, pszUser) == 0)
        {
            fUpdate = TRUE;
        }
        else
        {
            fUpdate = FALSE;
        }
    }

    if (fUpdate)
    {
        if (pInfo->hwndEbUser && *(prdp->szUserName))
        {
            SetWindowText(pInfo->hwndEbUser, prdp->szUserName);
        }
        if (pInfo->hwndEbDomain && *(prdp->szDomain))
        {
            SetWindowText(pInfo->hwndEbDomain, prdp->szDomain);
        }
    }

    return NO_ERROR;
}

DWORD
DrPopulatePasswordField(
    IN DRINFO* pInfo,
    IN BOOL fInit,
    IN BOOL fDisable,
    OUT BOOL * pfUseDefaultFocus)
{
    BOOL fSave, fMeOnly;
    TCHAR* pszFriendly = NULL;

    // Whistler bug: 195480 Dial-up connection dialog - Number of asterisks
    // does not match the length of the password and causes confusion
    //
    // Case 1. The user has clicked on the password field. We clear the
    // friendly password and set the font back to normal.
    //
    if(NULL != pfUseDefaultFocus )
    {
        *pfUseDefaultFocus = TRUE;
    }
    
    if (fDisable)
    {
        DrClearFriendlyPassword( pInfo, TRUE );
        return NO_ERROR;
    }

    // Initialze
    //
    fSave = Button_GetCheck( pInfo->hwndCbSavePw );
    fMeOnly = Button_GetCheck( pInfo->hwndRbSaveForMe );
    pszFriendly = PszFromId( g_hinstDll, SID_SavePasswordFrndly );

    // Case 2. Clear the password field if the user a) choose not to save the
    // password and b) has not manually entered a password.
    //
    if ( (!fSave) && !DrIsPasswordStyleEnabled( pInfo->hwndEbPw ) )
    {
        DrClearFriendlyPassword( pInfo, FALSE );
    }

    // Case 3. Show the friendly saved password text if the user a) choose to
    // save the password of himself only and b) there is a per-user password
    // saved and c) the user has not entered a password manually.
    //
    else if ( (fSave) && (fMeOnly) &&
              ((fInit) || ( !DrIsPasswordStyleEnabled( pInfo->hwndEbPw ))) )
    {
        // Whistler bug: 288234 When switching back and forth from
        // "I connect" and "Any user connects" password is not
        // caching correctly
        //
        if (pInfo->pArgs->pDinfo->fHaveSavedPwUser)
        {
            DrDisplayFriendlyPassword(pInfo, pszFriendly );
        }
        else
        {
            DrClearFriendlyPassword( pInfo, FALSE );
        }
    }

    // Case 4. Show the friendly saved password text if the user a) choose to
    // save the password for everyone and b) there is a default password saved
    // and c) the user has not entered a password manually.
    //
    else if ( (fSave) && (!fMeOnly) &&
             ((fInit) || ( !DrIsPasswordStyleEnabled( pInfo->hwndEbPw ))) )
    {
        if (pInfo->pArgs->pDinfo->fHaveSavedPwGlobal)
        {
            DrDisplayFriendlyPassword( pInfo, pszFriendly );
        }
        else
        {
            DrClearFriendlyPassword( pInfo, FALSE );
        }
    }

    // Case 5. Show the friendly saved password text if the user a) choose to
    // save the password for everyone or himself and b) there is a
    // corresponding password saved and c) the user has not entered a password
    // manually.
    //
    // This case catches a) when the user is switching between "me" and
    // "everyone" and b) when the user leaves the focus of the password field
    // but hasn't changed the password
    //
    else if ( (fSave) && !GetWindowTextLength( pInfo->hwndEbPw ) &&
              DrIsPasswordStyleEnabled( pInfo->hwndEbPw ) &&
              ((pInfo->pArgs->pDinfo->fHaveSavedPwGlobal && !fMeOnly) ||
               (pInfo->pArgs->pDinfo->fHaveSavedPwUser && fMeOnly)) )
    {
        DrDisplayFriendlyPassword( pInfo, pszFriendly );
    }

    // NT5 bug: 215432, Whistler bug: 364341
    //
    // Whistler bug: 195480 Dial-up connection dialog - Number of asterisks
    // does not match the length of the password and causes confusion
    //
    // Set focus appropiately
    //
    if (fInit)
    {
        if (!GetWindowTextLength( pInfo->hwndEbUser ))
        {
            SetFocus( pInfo->hwndEbUser );
        }
        else if (!GetWindowTextLength( pInfo->hwndEbPw ))
        {
            SetFocus( pInfo->hwndEbPw );

            // This removes the tab stop property from the username field. This
            // is a hack so we can set the focus properly. Tab stop is put back
            // in DrCommand.
            //
            /*
            SetWindowLong( pInfo->hwndEbUser, GWL_STYLE,
                GetWindowLong( pInfo->hwndEbUser, GWL_STYLE ) & ~WS_TABSTOP );
            */
            // For whistler bug 424209      gangz
            // Dont hack the WS_TABSTOP attribute, just let DrInit() return 
            // false to indicate that we set the focus ourself
            //
            if( NULL != pfUseDefaultFocus )
            {
                *pfUseDefaultFocus = FALSE;
            }

        }
        else
        {
            SetFocus( pInfo->hwndEbUser );
        }
    }

    // Clean up
    //
    Free0( pszFriendly );

    return NO_ERROR;
}

VOID
DrProperties(
    IN DRINFO* pInfo )

    // Called when the Properties button is pressed.  'PInfo' is the dialog
    // context.
    //
{
    BOOL fOk;
    RASENTRYDLG info;
    INTERNALARGS iargs;
    DINFO* pDinfo;

    // First, save any entry related changes user has made on the dial dialog.
    //
    DrSave( pInfo );

    // Set up for parameters for call to RasEntryDlg.
    //
    ZeroMemory( &info, sizeof(info) );
    info.dwSize = sizeof(info);
    info.hwndOwner = pInfo->hwndDlg;

    {
        RECT rect;

        info.dwFlags = RASEDFLAG_PositionDlg;
        GetWindowRect( pInfo->hwndDlg, &rect );
        info.xDlg = rect.left + DXSHEET;
        info.yDlg = rect.top + DYSHEET;
    }

    // The secret hack to share information already loaded with the entry API.
    //
    pDinfo = pInfo->pArgs->pDinfo;
    ZeroMemory( &iargs, sizeof(iargs) );
    iargs.pFile = pDinfo->pFile;
    iargs.pUser = pDinfo->pUser;
    iargs.pNoUser = pDinfo->pNoUser;
    iargs.fNoUser = !!(pDinfo->pNoUser);

    //For whislter bug 234515 set fDisableFirstConnect to be FALSE
    //
    iargs.fDisableFirstConnect = FALSE;
    info.reserved = (ULONG_PTR )&iargs;

    TRACE( "RasEntryDlg" );
    fOk = RasEntryDlg(
        pDinfo->pszPhonebook, pDinfo->pEntry->pszEntryName, &info );
    TRACE1( "RasEntryDlg=%d", fOk );

    if (fOk)
    {
        DWORD dwErr;

        // Reload when user presses OK on properties since that may change the
        // appearance and content of this dialog.  Must first reset the DINFO
        // context parameters based on the replaced PBENTRY from the property
        // sheet.
        //
        dwErr = FindEntryAndSetDialParams( pInfo->pArgs->pDinfo );
        if (dwErr != 0)
        {
            // Should not happen.
            //
            EndDialog( pInfo->hwndDlg, FALSE );
        }

        pInfo->pArgs->fReload = TRUE;
        EndDialog( pInfo->hwndDlg, FALSE );
    }
}

VOID
DrSave(
    IN DRINFO* pInfo )

    // Saves dialog field contents to RASDIALPARAMS, and if appropriate to LSA
    // secret area or NOUSER output argument.  'PInfo' is the dialog context.
    //
{
    DWORD dwErr;
    RASDIALPARAMS* prdp;
    RASCREDENTIALS rc;
    DINFO* pDinfo;

    pDinfo = pInfo->pArgs->pDinfo;

    if ((pInfo->pArgs->dwfMode & DR_U) ||
        (pInfo->pArgs->dwfMode & DR_I))
    {
        // Save credentials into parameter block to be passed to RasDial.
        //
        prdp = &pDinfo->rdp;
        GetWindowText( pInfo->hwndEbUser, prdp->szUserName, UNLEN + 1 );

        if (pInfo->pArgs->dwfMode & DR_U)
        {
            // Whistler bug 254385 encode password when not being used
            // Assumed password was not encoded by GetWindowText()
            //
            // Whistler bug: 195480 Dial-up connection dialog - Number of
            // asterisks does not match the length of the password and causes
            // confusion
            //
            if (!DrIsPasswordStyleEnabled( pInfo->hwndEbPw ))
            {
                lstrcpyn( prdp->szPassword, g_pszSavedPasswordToken,
                    g_dwSavedPasswordTokenLength );
            }
            else
            {
                GetWindowText( pInfo->hwndEbPw, prdp->szPassword, PWLEN + 1 );
            }

            SetWindowText( pInfo->hwndEbPw, L"" );
            EncodePassword( prdp->szPassword );
        }

        if (pInfo->pArgs->dwfMode & DR_D)
        {
            GetWindowText( pInfo->hwndEbDomain, prdp->szDomain, DNLEN + 1 );
        }

        ZeroMemory( &rc, sizeof(rc) );
        rc.dwSize = sizeof(rc);
        lstrcpyn( rc.szUserName, prdp->szUserName, UNLEN + 1 );

        // Whistler bug 254385 encode password when not being used
        // Assumed password was encoded previously
        //
        DecodePassword( prdp->szPassword );
        lstrcpyn( rc.szPassword, prdp->szPassword, PWLEN + 1 );
        EncodePassword( prdp->szPassword );

        lstrcpyn( rc.szDomain, prdp->szDomain, DNLEN + 1);

        if (pDinfo->pNoUser)
        {
            // Save credentials into output block for return to caller,
            // typically WinLogon.
            //
            lstrcpyn( pDinfo->pNoUser->szUserName, rc.szUserName, UNLEN + 1 );

            // Whistler bug 254385 encode password when not being used
            // Assumed password was not encoded previously
            //
            lstrcpyn( pDinfo->pNoUser->szPassword, rc.szPassword, PWLEN + 1 );
            EncodePassword( pDinfo->pNoUser->szPassword );

            lstrcpyn( pDinfo->pNoUser->szDomain, rc.szDomain, DNLEN + 1 );
            *(pDinfo->pfNoUserChanged) = TRUE;
        }
        else if (pInfo->pArgs->dwfMode & DR_I)
        {
            // Nothing to do
        }
        else if (!pDinfo->fDisableSavePw)
        {
            BOOL fGlobalCreds = FALSE;
            ASSERT( g_pRasSetCredentials );

            if (Button_GetCheck( pInfo->hwndCbSavePw ))
            {
                rc.dwMask = 0;
                
                // If the user elected to save the credentials for 
                // everybody, then clear any previously saved per-user
                // credentials
                //
                fGlobalCreds = Button_GetCheck( pInfo->hwndRbSaveForEveryone );
                if(     (fGlobalCreds)
                    &&  IsPublicPhonebook(pDinfo->pFile->pszPath))
                {
                    DeleteSavedCredentials(
                        pDinfo,
                        pInfo->hwndDlg,
                        FALSE,
                        TRUE );
                    pDinfo->fHaveSavedPwUser = FALSE;
                    rc.dwMask = RASCM_DefaultCreds;
                }

                // If there is currently no saved per-user password and the user
                // opts to save the password himself, then ask whetehr the global
                // password should be deleted if it exists.
                //
                else if (pDinfo->fHaveSavedPwGlobal && !pDinfo->fHaveSavedPwUser)
                {
                    MSGARGS msgargs;
                    ZeroMemory( &msgargs, sizeof(msgargs) );
                    msgargs.dwFlags = MB_ICONQUESTION | MB_YESNO;

                    // Delete the default credentials if the user answers yes
                    //
                    if (IDYES == 
                       MsgDlg(pInfo->hwndDlg, SID_DR_GlobalPassword, &msgargs))
                    {
                        DeleteSavedCredentials(
                            pDinfo,
                            pInfo->hwndDlg,
                            TRUE,
                            TRUE );
                        pDinfo->fHaveSavedPwGlobal = FALSE;
                    }
                }

                // User chose to save password.  Cache username, password, and
                // domain.
                //
                rc.dwMask |= RASCM_UserName | 
                             RASCM_Password | RASCM_Domain;

                TRACE( "RasSetCredentials(u|p|d,FALSE)" );
                dwErr = g_pRasSetCredentials(
                    pDinfo->pFile->pszPath, pDinfo->pEntry->pszEntryName,
                    &rc, FALSE );
                TRACE1( "RasSetCredentials=%d", dwErr );
                
                if (dwErr != 0)
                {
                    ErrorDlg( pInfo->hwndDlg, SID_OP_CachePw,  dwErr, NULL );
                }
                else
                {
                    if (fGlobalCreds)
                    {
                        pDinfo->fHaveSavedPwGlobal = TRUE;
                    }
                    else
                    {
                        // Whistler bug: 288234 When switching back and forth
                        // from "I connect" and "Any user connects" password is
                        // not caching correctly
                        //
                        pDinfo->fHaveSavedPwUser = TRUE;
                    }
                }
            }
            else
            {
                // Delete the global credentials.
                //
                // Note that we have to delete the global identity 
                // as well because we do not support deleting 
                // just the global password.  This is so that 
                // RasSetCredentials can emulate RasSetDialParams.
                //
                DeleteSavedCredentials(
                    pDinfo,
                    pInfo->hwndDlg,
                    TRUE,
                    TRUE );

                // Delete the password saved per-user.  Keep the user name
                // and domain saved, however.
                //
                DeleteSavedCredentials(
                    pDinfo,
                    pInfo->hwndDlg,
                    FALSE,
                    FALSE );

                pDinfo->fHaveSavedPwUser = FALSE;
                pDinfo->fHaveSavedPwGlobal = FALSE;
            }
        }

        RtlSecureZeroMemory( rc.szPassword, sizeof(rc.szPassword) );
    }

    if (pInfo->pArgs->dwfMode & DR_N)
    {
        TCHAR* pszNumber;
        TCHAR* pszOriginal;
        DTLNODE* pPhoneNode;
        DRNUMBERSITEM* pItem;
        PBPHONE* pPhone;
        BOOL fUserChange;

        pszNumber = GetText( pInfo->hwndClbNumbers );
        if (!pszNumber)
        {
            return;
        }

        pItem = (DRNUMBERSITEM* )ComboBox_GetItemDataPtr(
            pInfo->hwndClbNumbers, pInfo->pLink->iLastSelectedPhone );
        if (pItem)
        {
            pszOriginal = pItem->pszNumber;
        }
        else
        {
            pszOriginal = TEXT("");
        }

        if (lstrcmp( pszNumber, pszOriginal ) != 0
            || (pInfo->pLink->iLastSelectedPhone != pInfo->iFirstSelectedPhone))
        {
            MSGARGS msgargs;
            BOOL fMultiLink;
            BOOL fSingleNumber;

            // The phone number was edited by user to something not originally
            // on the list OR the user selected a different item on the list.
            //
            fSingleNumber = (DtlGetNodes( pInfo->pLink->pdtllistPhones ) == 1);
            fMultiLink = (DtlGetNodes( pDinfo->pEntry->pdtllistLinks ) > 1);

            ZeroMemory( &msgargs, sizeof(msgargs) );
            msgargs.dwFlags = MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2;

            if (fSingleNumber
                && (!fMultiLink || pDinfo->pEntry->fSharedPhoneNumbers)
                    && MsgDlg( pInfo->hwndDlg,
                           SID_SavePreview, &msgargs ) == IDYES)
            {
                // User says he wants to make the change permanent.
                //
                pDinfo->pEntry->fDirty = TRUE;

                if (pItem)
                {
                    pPhone = pItem->pPhone;
                    Free0( pItem->pszNumber );
                    pItem->pszNumber = StrDup( pszNumber );
                }
                else
                {
                    pPhoneNode = CreatePhoneNode();
                    if (pPhoneNode)
                    {
                        DtlAddNodeFirst(
                            pInfo->pLink->pdtllistPhones, pPhoneNode );
                        pPhone = (PBPHONE* )DtlGetData( pPhoneNode );
                    }
                }

                if (pItem)
                {
                    ASSERT( pItem->pPhone );
                    Free0( pPhone->pszPhoneNumber );
                    pPhone->pszPhoneNumber = StrDup( pszNumber );
                    pPhone->fUseDialingRules = FALSE;

                    if (fMultiLink)
                    {
                        DTLNODE* pNode;

                        for (pNode = DtlGetFirstNode(
                                 pDinfo->pEntry->pdtllistLinks );
                             pNode;
                             pNode = DtlGetNextNode( pNode ))
                        {
                            PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
                            ASSERT( pLink );
                            ASSERT( pLink->fEnabled );
                            CopyLinkPhoneNumberInfo( pNode, pInfo->pLinkNode );
                        }
                    }
                }
            }

            fUserChange = TRUE;
        }
        else
        {
            fUserChange = FALSE;
        }

        if (fUserChange || !pInfo->pLink->fTryNextAlternateOnFail)
        {
            if (!*pszNumber)
            {
                TCHAR* psz;

                // We have a problem when user edits in an empty string,
                // because the RasDial API does not accept an empty override
                // phone number.  Convert it to a single blank string in this
                // case, which is as good as we can do.  If user really needs
                // to dial an empty string they can enter one as the entry's
                // permanent phone number.  See bug 179561.
                //
                psz = StrDup( TEXT(" ") );
                if (psz)
                {
                    Free( pszNumber );
                    pszNumber = psz;
                }
            }

            // Set the override phone number to what user typed or selected.
            //
            lstrcpyn( 
                pDinfo->rdp.szPhoneNumber, 
                pszNumber,
                RAS_MaxPhoneNumber + 1);
        }

        Free( pszNumber );
    }

    if (pDinfo->pEntry->fDirty)
    {
        // Write the new phone number and/or "last selected phone number" to
        // the phonebook.
        //
        dwErr = WritePhonebookFile( pDinfo->pFile, NULL );
        if (dwErr != 0)
        {
            ErrorDlg( pInfo->hwndDlg, SID_OP_WritePhonebook, dwErr, NULL );
        }
    }
}

DWORD
DrSetBitmap(
    IN DRINFO* pInfo)

    // Set the appropriate bitmap for this dialer.
    //
{
    DWORD dwErr = NO_ERROR;
    HBITMAP hbmNew = NULL;
    HDC hdc = NULL;
    INT iDepth = 0;

    do
    {
        if (pInfo->hwndBmDialer == NULL)
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }
    
        // Get the device context for the window
        //
        hdc = GetDC( pInfo->hwndBmDialer );
        if (hdc == NULL)
        {
            dwErr = GetLastError();
            break;
        }

        // If the color depth >= 8bit, the current bitmap
        // is fine (high res is default)
        //
        iDepth = GetDeviceCaps(hdc, NUMCOLORS);
        if ( (iDepth == -1) || (iDepth == 256) )
        {
            dwErr = NO_ERROR;
            break;
        }

        // Load in the low-res bitmap
        //
        hbmNew = LoadBitmap(g_hinstDll, MAKEINTRESOURCE( BID_Dialer ));
        if (hbmNew == NULL)
        {
            dwErr = GetLastError();
            break;
        }

        // Set the low-res bitmap
        //
        pInfo->hbmOrig = (HBITMAP)
            SendMessage( 
                pInfo->hwndBmDialer, 
                STM_SETIMAGE, 
                IMAGE_BITMAP, 
                (LPARAM )hbmNew );
    
    } while (FALSE);

    // Cleanup
    //
    {
        if (hdc)
        {
            ReleaseDC(pInfo->hwndBmDialer, hdc);
        }
    }
    
    return dwErr;
}

VOID
DrSetClbNumbersText(
    IN DRINFO* pInfo,
    IN TCHAR* pszText )

    // Set the text of the 'ClbNumbers' edit box to 'pszText'.  See
    // DrClbNumbersEbWndProc.  'PInfo' is the dialog context.
    //
{
    ASSERT( pInfo->hwndClbNumbersEb );

    SendMessage( pInfo->hwndClbNumbersEb, DR_WM_SETTEXT, 0, (LPARAM )pszText );
}


VOID
DrTerm(
    IN HWND hwndDlg )

    // Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    //
{
    DRINFO* pInfo = (DRINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );
    HBITMAP hbmNew = NULL;

    TRACE( "DrTerm" );

    if (pInfo)
    {
        // Note: Don't use 'pInfo->pLinkNode' or 'pInfo->pLink' here as they
        //       are not currently restored prior to exit for post-Property
        //       button reloading.
        //
        if (pInfo->hwndClbNumbers)
        {
            DrFreeClbNumbers( pInfo );

            if (pInfo->wndprocClbNumbersEb)
            {
                SetWindowLongPtr( pInfo->hwndClbNumbersEb,
                    GWLP_WNDPROC, (ULONG_PTR )pInfo->wndprocClbNumbersEb );
            }

            if (pInfo->wndprocClbNumbersLb)
            {
                SetWindowLongPtr( pInfo->hwndClbNumbersLb,
                    GWLP_WNDPROC, (ULONG_PTR )pInfo->wndprocClbNumbersLb );
            }
        }

        // Whistler bug: 195480 Dial-up connection dialog - Number of
        // asterisks does not match the length of the password and causes
        // confusion
        //
        if (pInfo->hItalicFont)
        {
            DeleteObject( pInfo->hItalicFont );
        }

        if (pInfo->hNormalFont)
        {
            DeleteObject( pInfo->hNormalFont );
        }

        if (pInfo->fComInitialized)
        {
            CoUninitialize();
        }

        // Clean up the low-res bitmap if appropriate
        //
        if ( pInfo->hbmOrig )
        {
            hbmNew = (HBITMAP)
                SendMessage( 
                    pInfo->hwndBmDialer, 
                    STM_SETIMAGE, 
                    IMAGE_BITMAP, 
                    (LPARAM ) pInfo->hbmOrig );
                    
            if (hbmNew)
            {
                DeleteObject(hbmNew);
            }
        }

        Free( pInfo );
        pInfo = NULL;
    }
}


//----------------------------------------------------------------------------
// Projection Result dialog
// Listed alphabetically following stub API and dialog proc
//----------------------------------------------------------------------------

BOOL
ProjectionResultDlg(
    IN HWND hwndOwner,
    IN TCHAR* pszLines,
    OUT BOOL* pfDisableFailedProtocols )

    // Popup the Projection Result dialog.  'HwndOwner' is the owning window.
    // 'PszLines' is the status line text to display.  See DpProjectionError.
    // 'DwfDisableFailedProtocols' indicates user chose to disable the failed
    // protocols.
    //
    // Returns true if user chooses to redial or lets it timeout, false if
    // cancels.
    //
{
    INT_PTR nStatus;
    PRARGS args;

    TRACE( "ProjectionResultDlg" );

    args.pszLines = pszLines;
    args.pfDisableFailedProtocols = pfDisableFailedProtocols;

    nStatus =
        DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_PR_ProjectionResult ),
            hwndOwner,
            PrDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (nStatus) ? TRUE : FALSE;
}


INT_PTR CALLBACK
PrDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Projection Result dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "PrDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return PrInit( hwnd, (PRARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwPrHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            return PrCommand(
                hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}


BOOL
PrCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    // the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    DWORD dwErr;

    TRACE3( "PrCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case IDOK:
        case IDCANCEL:
        {
            BOOL fCb;
            BOOL* pfDisable;

            TRACE1( "%s pressed", (wId==IDOK) ? "OK" : "Cancel" );

            fCb = IsDlgButtonChecked( hwnd, CID_PR_CB_DisableProtocols );
            pfDisable = (BOOL* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pfDisable );
            *pfDisable = fCb;
            EndDialog( hwnd, (wId == IDOK) );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
PrInit(
    IN HWND hwndDlg,
    IN PRARGS* pArgs )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    // 'PArgs' is caller's arguments to the stub API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    HWND hwndStText;
    HWND hwndPbAccept;
    HWND hwndPbHangUp;
    HWND hwndCbDisable;

    TRACE( "PrInit" );

    hwndStText = GetDlgItem( hwndDlg, CID_PR_ST_Text );
    ASSERT( hwndStText );
    hwndPbAccept = GetDlgItem( hwndDlg, IDOK );
    ASSERT( hwndPbAccept );
    hwndPbHangUp = GetDlgItem( hwndDlg, IDCANCEL );
    ASSERT( hwndPbHangUp );
    hwndCbDisable = GetDlgItem( hwndDlg, CID_PR_CB_DisableProtocols );
    ASSERT( hwndCbDisable );

    {
        TCHAR szBuf[ 1024 ];
        TCHAR* psz;

        // Build the message text.
        //
        szBuf[ 0 ] = TEXT('\0');
        psz = PszFromId( g_hinstDll, SID_ProjectionResult1 );
        if (psz)
        {
            lstrcat( szBuf, psz );
            Free( psz );
        }
        lstrcat( szBuf, pArgs->pszLines );
        psz = PszFromId( g_hinstDll, SID_ProjectionResult2 );
        if (psz)
        {
            lstrcat( szBuf, psz );
            Free( psz );
        }

        // Load the text into the static control, then stretch the window to a
        // vertical size appropriate for the text.
        //
        {
            HDC hdc;
            RECT rect;
            RECT rectNew;
            HFONT hfont;
            LONG dyGrow;

            SetWindowText( hwndStText, szBuf );
            GetClientRect( hwndStText, &rect );
            hdc = GetDC( hwndStText );

            if(NULL != hdc)
            {

                hfont = (HFONT )SendMessage( hwndStText, WM_GETFONT, 0, 0 );
                if (hfont)
                    SelectObject( hdc, hfont );

                rectNew = rect;
                DrawText( hdc, szBuf, -1, &rectNew,
                    DT_CALCRECT | DT_WORDBREAK | DT_EXPANDTABS | DT_NOPREFIX );
                ReleaseDC( hwndStText, hdc );
            }

            dyGrow = rectNew.bottom - rect.bottom;
            ExpandWindow( hwndDlg, 0, dyGrow );
            ExpandWindow( hwndStText, 0, dyGrow );
            SlideWindow( hwndPbAccept, hwndDlg, 0, dyGrow );
            SlideWindow( hwndPbHangUp, hwndDlg, 0, dyGrow );
            SlideWindow( hwndCbDisable, hwndDlg, 0, dyGrow );
        }
    }

    // Save address of caller's BOOL as the dialog context.
    //
    SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pArgs->pfDisableFailedProtocols );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    // Display the finished window above all other windows.  The window
    // position is set to "topmost" then immediately set to "not topmost"
    // because we want it on top but not always-on-top.  Always-on-top alone
    // is incredibly annoying, e.g. it is always on top of the on-line help if
    // user presses the Help button.
    //
    SetWindowPos(
        hwndDlg, HWND_TOPMOST, 0, 0, 0, 0,
        SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE );

    CenterWindow( hwndDlg, GetParent( hwndDlg ) );
    ShowWindow( hwndDlg, SW_SHOW );

    SetWindowPos(
        hwndDlg, HWND_NOTOPMOST, 0, 0, 0, 0,
        SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE );

    return TRUE;
}


//----------------------------------------------------------------------------
// Retry Authentication dialog
// Listed alphabetically following stub API and dialog proc
//----------------------------------------------------------------------------

BOOL
RetryAuthenticationDlg(
    IN HWND hwndOwner,
    IN DINFO* pDinfo )

    // Pops up the retry authentication dialog.  'PDinfo' is the dial dialog
    // common context.
    //
    // Returns true if user presses OK, false if Cancel or an error occurs.
    //
{
    INT_PTR nStatus;

    TRACE( "RetryAuthenticationDlg" );

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_UA_RetryAuthenticationUD ),
            hwndOwner,
            UaDlgProc,
            (LPARAM )pDinfo );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
UaDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the User Authentication dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "UaDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return UaInit( hwnd, (DINFO* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwUaHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            UAINFO* pInfo = (UAINFO* )GetWindowLongPtr( hwnd, DWLP_USER );

            if (!pInfo)
            {
                // This happened in stress one night.  Don't understand how
                // unless it was a WinUser bug or something.  Anyhow, this
                // avoids an AV in such case.
                //
                break;
            }

            return UaCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            UaTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
UaCommand(
    IN UAINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "UaCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_UA_EB_UserName:
        {
            if (pInfo->fAutoLogonPassword && wNotification == EN_CHANGE)
            {
                // User's changing the username in auto-logon retry mode,
                // which means we have to admit we don't really have the text
                // password and force him to re-enter it.
                //
                pInfo->fAutoLogonPassword = FALSE;
                SetWindowText( pInfo->hwndEbPassword, TEXT("") );
            }
            break;
        }

        case CID_UA_EB_Password:
        {
            if (wNotification == EN_CHANGE)
            {
                pInfo->fAutoLogonPassword = FALSE;
            }
            break;
        }

        case IDOK:
        {
            UaSave( pInfo );
            EndDialog( pInfo->hwndDlg, TRUE );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
UaInit(
    IN HWND   hwndDlg,
    IN DINFO* pArgs )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    // 'PArgs' is caller's arguments as passed to the stub API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    UAINFO* pInfo;
    PBENTRY* pEntry;

    TRACE( "UaInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->fDomain = TRUE;

    pInfo->hwndEbUserName = GetDlgItem( hwndDlg, CID_UA_EB_UserName );
    ASSERT( pInfo->hwndEbUserName );
    pInfo->hwndEbPassword = GetDlgItem( hwndDlg, CID_UA_EB_Password );
    ASSERT( pInfo->hwndEbPassword );
    if (pInfo->fDomain)
    {
        pInfo->hwndEbDomain = GetDlgItem( hwndDlg, CID_UA_EB_Domain );
        ASSERT( pInfo->hwndEbDomain );
    }
    pInfo->hwndCbSavePw = GetDlgItem( hwndDlg, CID_UA_CB_SavePassword );
    ASSERT( pInfo->hwndCbSavePw );

    pEntry = pArgs->pEntry;

    // Set the title.
    //
    {
        TCHAR* pszTitleFormat;
        TCHAR* pszTitle;
        TCHAR* apszArgs[ 1 ];

        pszTitleFormat = GetText( hwndDlg );
        if (pszTitleFormat)
        {
            apszArgs[ 0 ] = pEntry->pszEntryName;
            pszTitle = NULL;

            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING
                    | FORMAT_MESSAGE_ALLOCATE_BUFFER
                    | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                pszTitleFormat, 0, 0, (LPTSTR )&pszTitle, 1,
                (va_list* )apszArgs );

            Free( pszTitleFormat );

            if (pszTitle)
            {
                SetWindowText( hwndDlg, pszTitle );
                LocalFree( pszTitle );
            }
        }
    }

    // Fill edit fields with initial values.
    //
    Edit_LimitText( pInfo->hwndEbUserName, UNLEN );
    Edit_LimitText( pInfo->hwndEbPassword, PWLEN );
    if (pInfo->fDomain)
    {
        Edit_LimitText( pInfo->hwndEbDomain, DNLEN );
    }

    {
        BOOL fUserNameSet = FALSE;
        BOOL fPasswordSet = FALSE;

        if (pEntry->fAutoLogon && !pInfo->pArgs->pNoUser)
        {
            // On the first retry use the logged on user's name.  Act like the
            // user's password is in the edit box.  If he changes the username
            // or password we'll have to admit we don't have it, but he'll
            // probably just change the domain.
            //
            if (pArgs->rdp.szUserName[ 0 ] == TEXT('\0'))
            {
                SetWindowText( pInfo->hwndEbUserName, GetLogonUser() );
                fUserNameSet = TRUE;
            }

            if (pArgs->rdp.szPassword[ 0 ] == TEXT('\0'))
            {
                SetWindowText( pInfo->hwndEbPassword, TEXT("********") );
                pInfo->fAutoLogonPassword = TRUE;
                fPasswordSet = TRUE;
            }
        }

        if (!fUserNameSet)
        {
            SetWindowText( pInfo->hwndEbUserName, pArgs->rdp.szUserName );
        }

        if (!fPasswordSet)
        {
            // Whistler bug 254385 encode password when not being used
            // Assumed password was encoded previously
            //
            DecodePassword( pArgs->rdp.szPassword );
            SetWindowText( pInfo->hwndEbPassword, pArgs->rdp.szPassword );
            EncodePassword( pArgs->rdp.szPassword );
        }

        if (pInfo->fDomain)
        {
            SetWindowText( pInfo->hwndEbDomain, pArgs->rdp.szDomain );
        }
    }

    if (pArgs->pNoUser || pArgs->fDisableSavePw)
    {
        // Can't stash password without a logon context, so hide the checkbox.
        //
        ASSERT( !HaveSavedPw( pArgs ) );
        EnableWindow( pInfo->hwndCbSavePw, FALSE );
        ShowWindow( pInfo->hwndCbSavePw, SW_HIDE );
    }
    else
    {
        // Check "save  password" if a password was previously  cached.  Maybe
        // he changed the password while on the LAN.
        //
        Button_SetCheck( pInfo->hwndCbSavePw, HaveSavedPw( pArgs ) );
    }

    // Position the dialog per caller's instructions.
    //
    PositionDlg( hwndDlg,
        (pArgs->pArgs->dwFlags & RASDDFLAG_PositionDlg),
        pArgs->pArgs->xDlg, pArgs->pArgs->yDlg );
    SetForegroundWindow( hwndDlg );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    // Set focus to the empty username or empty password, or if both are
    // present to the domain if auto-logon or the password if not.
    //
    if (Edit_GetTextLength( pInfo->hwndEbUserName ) == 0)
    {
        Edit_SetSel( pInfo->hwndEbUserName, 0, -1 );
        SetFocus( pInfo->hwndEbUserName );
    }
    else if (Edit_GetTextLength( pInfo->hwndEbPassword ) == 0
             || !pEntry->fAutoLogon
             || !pInfo->fDomain)
    {
        Edit_SetSel( pInfo->hwndEbPassword, 0, -1 );
        SetFocus( pInfo->hwndEbPassword );
    }
    else
    {
        ASSERT( pInfo->fDomain );
        Edit_SetSel( pInfo->hwndEbDomain, 0, -1 );
        SetFocus( pInfo->hwndEbDomain );
    }

    // Hide the Dial Progress dialog.
    //
    SetOffDesktop( GetParent( hwndDlg ), SOD_MoveOff, NULL );

    return FALSE;
}


VOID
UaSave(
    IN UAINFO* pInfo )

    // Called when the OK button is pressed.
    //
    // Returns true if user presses OK, false if Cancel or an error occurs.
    //
{
    DWORD dwErr;
    PBENTRY* pEntry;
    BOOL fSavePw;
    RASDIALPARAMS* prdp;
    RASCREDENTIALS rc;

    TRACE( "UaSave" );

    prdp = &pInfo->pArgs->rdp;
    GetWindowText( pInfo->hwndEbUserName, prdp->szUserName, UNLEN + 1 );

    // Whistler bug 254385 encode password when not being used
    // Assumed password was not encoded by GetWindowText()
    //
    GetWindowText( pInfo->hwndEbPassword, prdp->szPassword, PWLEN + 1 );
    EncodePassword( prdp->szPassword );
    if (pInfo->fDomain)
    {
        GetWindowText( pInfo->hwndEbDomain, prdp->szDomain, DNLEN + 1 );
        //
        //if the Domain is not empty, set the "include Windows Logon Domain check box on Option Tab" 
        //        for bug  167229 whistler
        //
        if ( ( 0 < lstrlen ( prdp->szDomain ) ) && (!pInfo->pArgs->pEntry->fPreviewDomain ))
        {
            pInfo->pArgs->pEntry->fPreviewDomain = TRUE;
            pInfo->pArgs->pEntry->fDirty = TRUE;
            dwErr = WritePhonebookFile( pInfo->pArgs->pFile, NULL );

            if (dwErr != 0)
            {
                ErrorDlg( pInfo->hwndDlg, SID_OP_WritePhonebook, dwErr, NULL );
            }
        }
    }

    pEntry = pInfo->pArgs->pEntry;
    if (pEntry->fAutoLogon && !pInfo->pArgs->pNoUser)
    {
        if (pInfo->fAutoLogonPassword)
        {
            // User did not change username or password, so continue to
            // retrieve logon username and password credentials.
            //
            TRACE( "Retain auto-logon" );
            prdp->szUserName[ 0 ] = TEXT('\0');
            prdp->szPassword[ 0 ] = TEXT('\0');
        }
        else
        {
            // User changed username and/or password so we can no longer
            // retrieve the logon username and password credentials from the
            // system.  Switch the entry to non-auto-logon mode.
            //
            TRACE( "Disable auto-logon" );
            pEntry->fAutoLogon = FALSE;
            pInfo->pArgs->fResetAutoLogon = TRUE;
        }
    }

    ZeroMemory( &rc, sizeof(rc) );
    rc.dwSize = sizeof(rc);
    lstrcpyn( rc.szUserName, prdp->szUserName, UNLEN + 1 );

    // Whistler bug 254385 encode password when not being used
    // Assumed password was encoded previously
    //
    DecodePassword( prdp->szPassword );
    lstrcpyn( rc.szPassword, prdp->szPassword, PWLEN + 1 );
    EncodePassword( prdp->szPassword );

    lstrcpyn( rc.szDomain, prdp->szDomain, DNLEN + 1 );

    if (pInfo->pArgs->pNoUser)
    {
        lstrcpyn( pInfo->pArgs->pNoUser->szUserName, rc.szUserName, UNLEN + 1 );

        // Whistler bug 254385 encode password when not being used
        // Assumed password was not encoded previously
        //
        lstrcpyn( pInfo->pArgs->pNoUser->szPassword, rc.szPassword, PWLEN + 1 );
        EncodePassword( pInfo->pArgs->pNoUser->szPassword );

        lstrcpyn( pInfo->pArgs->pNoUser->szDomain, rc.szDomain, DNLEN + 1 );
        *pInfo->pArgs->pfNoUserChanged = TRUE;
    }
    else if (!pInfo->pArgs->fDisableSavePw)
    {
        ASSERT( g_pRasSetCredentials );

        if (Button_GetCheck( pInfo->hwndCbSavePw ))
        {
            // User chose "save password".  Cache username, password, and
            // domain.
            //
            rc.dwMask = RASCM_UserName | RASCM_Password | RASCM_Domain;

            // Whistler bug: 288234 When switching back and forth from
            // "I connect" and "Any user connects" password is not
            // caching correctly
            //
            if(     (pInfo->pArgs->fHaveSavedPwGlobal)
                &&  !pInfo->pArgs->fHaveSavedPwUser
                &&  IsPublicPhonebook(pInfo->pArgs->pFile->pszPath))
            {
                rc.dwMask |= RASCM_DefaultCreds;
            }
            
            TRACE( "RasSetCredentials(u|p|d,FALSE)" );
            dwErr = g_pRasSetCredentials(
                pInfo->pArgs->pFile->pszPath,
                pInfo->pArgs->pEntry->pszEntryName,
                &rc, FALSE );
            TRACE1( "RasSetCredentials=%d", dwErr );

            if (dwErr != 0)
            {
                ErrorDlg( pInfo->hwndDlg, SID_OP_CachePw,  dwErr, NULL );
            }
        }
        else
        {
            // Whistler bug: 288234 When switching back and forth from
            // "I connect" and "Any user connects" password is not
            // caching correctly
            //
            // User chose not to save password; Cache username and domain only
            //
            rc.dwMask = RASCM_UserName | RASCM_Domain;

            TRACE( "RasSetCredentials(u|d,FALSE)" );
            dwErr = g_pRasSetCredentials(
                pInfo->pArgs->pFile->pszPath,
                pInfo->pArgs->pEntry->pszEntryName,
                &rc, FALSE );
            TRACE1( "RasSetCredentials=%d", dwErr );

            if (dwErr != 0)
            {
                ErrorDlg( pInfo->hwndDlg, SID_OP_UncachePw, dwErr, NULL );
            }

            // Whistler bug: 288234 When switching back and forth from
            // "I connect" and "Any user connects" password is not
            // caching correctly
            //

            // Delete the password saved per-user; Keep the user name
            // and domain saved, however.
            //
            if (pInfo->pArgs->fHaveSavedPwUser)
            {
                DeleteSavedCredentials(
                    pInfo->pArgs,
                    pInfo->hwndDlg,
                    FALSE,
                    FALSE );
                pInfo->pArgs->fHaveSavedPwUser = FALSE;
            }

            // Delete the global credentials.  
            //
            // Note that we have to delete the global identity 
            // as well because we do not support deleting 
            // just the global password.  This is so that 
            // RasSetCredentials can emulate RasSetDialParams.
            //
            else if (pInfo->pArgs->fHaveSavedPwGlobal)
            {
                DeleteSavedCredentials(
                    pInfo->pArgs,
                    pInfo->hwndDlg,
                    TRUE,
                    TRUE );
                pInfo->pArgs->fHaveSavedPwGlobal = FALSE;
            }
        }
    }

    RtlSecureZeroMemory( rc.szPassword, sizeof(rc.szPassword) );
}


VOID
UaTerm(
    IN HWND hwndDlg )

    // Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    //
{
    UAINFO* pInfo = (UAINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );

    TRACE( "UaTerm" );

    if (pInfo)
    {
        // Restore the Dial Progress dialog.
        //
        SetOffDesktop( GetParent( hwndDlg ), SOD_MoveBackFree, NULL );

        Free( pInfo );
        pInfo = NULL;
    }
}


//----------------------------------------------------------------------------
// VPN Double Dial help dialog
// Listed alphabetically following stub API and dialog proc
//----------------------------------------------------------------------------

BOOL
VpnDoubleDialDlg(
    IN HWND hwndOwner,
    IN DINFO* pInfo )

    // Popup the VPN double dial help dialog.  'HwndOwner' is the owning
    // window.  'PInfo' is the dialing context information.
    //
    // Returns false if user sees the dialog and decides not to continue, true
    // otherwise.
    //
{
    INT_PTR nStatus;

    TRACE( "VpnDoubleDialDlg" );

    if (pInfo->pEntryMain->dwType != RASET_Vpn
        || !pInfo->fPrerequisiteDial
        || pInfo->pEntryMain->fSkipDoubleDialDialog)
    {
        return TRUE;
    }

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_VI_VpnInitial ),
            hwndOwner,
            ViDlgProc,
            (LPARAM )pInfo );

    if (nStatus == -1)
    {
        nStatus = FALSE;
    }

    return !!(nStatus);
}


INT_PTR CALLBACK
ViDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the dialog.  Parameters and return value are as
    // described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "ViDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return ViInit( hwnd, (DINFO* )lparam );
        }

        case WM_COMMAND:
        {
            return ViCommand(
                hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}


BOOL
ViCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    // the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "ViCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case IDYES:
        case IDNO:
        {
            // Per bug 261955, the box setting is saved when either the Yes or
            // No, but not the 'X' button, is pressed.
            //
            DINFO* pInfo = (DINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            if (IsDlgButtonChecked( hwnd, CID_VI_CB_SkipMessage ))
            {
                pInfo->pEntryMain->fSkipDoubleDialDialog = TRUE;
                pInfo->pEntryMain->fDirty = TRUE;
                WritePhonebookFile( pInfo->pFileMain, NULL );
            }

            EndDialog( hwnd, (wId == IDYES) );
            return TRUE;
        }

        case IDCANCEL:
        {
            EndDialog( hwnd, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
ViInit(
    IN HWND hwndDlg,
    IN DINFO* pInfo )

    // Called on WM_INITDIALOG.  'HwndDlg' is the handle of dialog.  'PUser'
    // is caller's argument to the stub API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    TRACE( "ViInit" );

    // Set the dialog context.
    //
    SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );

    // Set the explanatory text.
    //
    {
        MSGARGS msgargs;

        ZeroMemory( &msgargs, sizeof(msgargs) );
        msgargs.apszArgs[ 0 ] = pInfo->pEntryMain->pszEntryName;
        msgargs.apszArgs[ 1 ] = pInfo->pEntry->pszEntryName;
        msgargs.fStringOutput = TRUE;

        MsgDlgUtil( NULL, SID_VI_ST_Explain, &msgargs, g_hinstDll, 0 );

        if (msgargs.pszOutput)
        {
            SetDlgItemText( hwndDlg, CID_VI_ST_Explain, msgargs.pszOutput );
            Free( msgargs.pszOutput );
        }
    }

    // Display finished window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );
    SetForegroundWindow( hwndDlg );

    return TRUE;
}

DWORD
DwTerminalDlg(
    LPCWSTR lpszPhonebook,
    LPCWSTR lpszEntry,
    RASDIALPARAMS *prdp,
    HWND hwndOwner,
    HRASCONN hRasconn)
{
    DWORD dwErr = ERROR_SUCCESS;
    PBENTRY *pEntry = NULL;
    PBFILE pbfile;
    DTLNODE *pNode = NULL;
    WCHAR szIpAddress[ TERM_IpAddress ];
    DWORD sidTitle;
    WCHAR *pszIpAddress;

    //
    //Initialize memory for Whistler bug 160888
    //
    ZeroMemory(&pbfile, sizeof(PBFILE)); 
    pbfile.hrasfile = -1;

    dwErr = LoadRas( g_hinstDll, hwndOwner );

    if (ERROR_SUCCESS != dwErr)
    {
        goto done;
    }
    
    
    dwErr = GetPbkAndEntryName(
            lpszPhonebook,
            lpszEntry,
            0,
            &pbfile,
            &pNode);

    if(     (NULL == pNode)
        ||  (ERROR_SUCCESS != dwErr))
    {
        dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
        goto done;
    }

    pEntry = (PBENTRY *) DtlGetData(pNode);
    ASSERT(NULL != pEntry);

    if(NULL == pEntry)
    {
        goto done;
    }

    if (pEntry->dwBaseProtocol == BP_Slip)
    {
        lstrcpyn( 
            szIpAddress,
            (pEntry->pszIpAddress) ? pEntry->pszIpAddress : TEXT("0.0.0.0"),
            sizeof(szIpAddress) / sizeof(TCHAR));
        pszIpAddress = szIpAddress;
        sidTitle = SID_T_SlipTerminal;
    }
    else
    {
        szIpAddress[0] = TEXT('\0');
        pszIpAddress = szIpAddress;
        sidTitle = SID_T_PostconnectTerminal;
    }


    if (!TerminalDlg(
            pEntry, prdp, hwndOwner,
            hRasconn, sidTitle, pszIpAddress ))
    {
        TRACE( "TerminalDlg==FALSE" );
        dwErr = E_FAIL;
        goto done;
    }

    TRACE2( "pszIpAddress=0x%08x(%ls)", pszIpAddress,
        pszIpAddress ? pszIpAddress : TEXT("") );
    TRACE2( "pEntry->pszIpAddress=0x%08x(%ls)", pEntry->pszIpAddress,
        pEntry->pszIpAddress ? pEntry->pszIpAddress : TEXT("") );

    if (pszIpAddress[0]
        && (!pEntry->pszIpAddress
            || lstrcmp( pszIpAddress, pEntry->pszIpAddress ) != 0))
    {
        Free0( pEntry->pszIpAddress );
        pEntry->pszIpAddress = StrDup( szIpAddress );
        pEntry->fDirty = TRUE;
        
        dwErr = WritePhonebookFile( &pbfile, NULL );
        if (dwErr != 0)
        {
            ErrorDlg( hwndOwner, SID_OP_WritePhonebook, dwErr, NULL );
        }
    }
    
    done:
        ClosePhonebookFile(&pbfile);
        return dwErr;
        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\entryps.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// entryps.h
// Remote Access Common Dialog APIs
// Phonebook Entry property sheet
//
// 12/14/97 Shaun Cox (split out from entryps.c)


#ifndef _ENTRYPS_H_
#define _ENTRYPS_H_

#include "inetcfgp.h"
#include "netconp.h"

// Phonebook Entry property sheet context block.  All property pages refer to
// the single context block is associated with the sheet.
//
typedef struct
_PEINFO
{
    // Common input arguments.
    //
    EINFO* pArgs;

    // Property sheet dialog and property page handles.  'hwndFirstPage' is
    // the handle of the first property page initialized.  This is the page
    // that allocates and frees the context block.
    //
    // Note the "Network" page is missing.  This "NCPA" page, developed
    // separately by ShaunCo, does not use this shared area for page specfic
    // controls, instead returning users selections via the "penettab.h"
    // interface.
    //
    HWND hwndDlg;
    HWND hwndFirstPage;
    HWND hwndGe;
    HWND hwndOe;
    HWND hwndLo;
    HWND hwndFw;

    // General page.
    //
    HWND hwndLvDevices;
    HWND hwndLbDevices;
    HWND hwndPbUp;
    HWND hwndPbDown;
    HWND hwndCbSharedPhoneNumbers;
    HWND hwndPbConfigureDevice;
    HWND hwndGbPhoneNumber;
    HWND hwndStAreaCodes;
    HWND hwndClbAreaCodes;
    HWND hwndStCountryCodes;
    HWND hwndLbCountryCodes;
    HWND hwndStPhoneNumber;
    HWND hwndEbPhoneNumber;
    HWND hwndCbUseDialingRules;
    HWND hwndPbDialingRules;
    HWND hwndPbAlternates;
    HWND hwndCbShowIcon;

    HWND hwndEbHostName;
    HWND hwndCbDialAnotherFirst;
    HWND hwndLbDialAnotherFirst;

    HWND hwndEbBroadbandService;

    // Options page.
    //
    HWND hwndCbDisplayProgress;
    HWND hwndCbPreviewUserPw;
    HWND hwndCbPreviewDomain;
    HWND hwndCbPreviewNumber;
    HWND hwndEbRedialAttempts;
    HWND hwndLbRedialTimes;
    HWND hwndLbIdleTimes;
    HWND hwndCbRedialOnDrop;
    HWND hwndGbMultipleDevices;
    HWND hwndLbMultipleDevices;
    HWND hwndPbConfigureDialing;
    HWND hwndPbX25;
    HWND hwndPbTunnel;
    HWND hwndRbPersistent;  // only for fRouter
    HWND hwndRbDemandDial;  // only for fRouter

    // Security page.
    //
    HWND hwndGbSecurityOptions;
    HWND hwndRbTypicalSecurity;
    HWND hwndStAuths;
    HWND hwndLbAuths;
    HWND hwndCbUseWindowsPw;
    HWND hwndCbEncryption;
    HWND hwndRbAdvancedSecurity;
    HWND hwndStAdvancedText;
    HWND hwndPbAdvanced;
    HWND hwndPbIPSec;       //Only for VPN
    HWND hwndGbScripting;
    HWND hwndCbRunScript;
    HWND hwndCbTerminal;
    HWND hwndLbScripts;
    HWND hwndPbEdit;
    HWND hwndPbBrowse;

    // Networking page.
    //
    HWND hwndLbServerType;
    HWND hwndPbSettings;
    HWND hwndLvComponents;
    HWND hwndPbAdd;
    HWND hwndPbRemove;
    HWND hwndPbProperties;
    HWND hwndDescription;

    // Indicates that the informational popup noting that SLIP does not
    // support any authentication settings should appear the next time the
    // Security page is activated.
    //
    BOOL fShowSlipPopup;

    // The "restore" states of the typical security mode listbox and
    // checkboxes.  Initialized in LoInit and set whenever the controls are
    // disabled.
    //
    DWORD iLbAuths;
    BOOL fUseWindowsPw;
    BOOL fEncryption;

    // MoveUp/MoveDown icons, for enabled/disabled cases.
    //
    HANDLE hiconUpArr;
    HANDLE hiconDnArr;
    HANDLE hiconUpArrDis;
    HANDLE hiconDnArrDis;

    // The currently displayed link node, i.e. either the node of the selected
    // device or the shared node.  This is a shortcut for GeAlternates, that
    // keeps all the lookup code in GeUpdatePhoneNumberFields.
    //
    DTLNODE* pCurLinkNode;

    // The currently selected device.  Used to store phone number information
    // for the just unselected device when a new device is selected.
    //
    INT iDeviceSelected;

    // Complex phone number helper context block, and a flag indicating if the
    // block has been initialized.
    //
    CUINFO cuinfo;
    BOOL fCuInfoInitialized;

    // After dial scripting helper context block, and a flag indicating if the
    // block has been initialized.
    //
    SUINFO suinfo;
    BOOL fSuInfoInitialized;

    // Flags whether the user authorized a reboot after installing or removing
    // and networking component.
    //
    BOOL fRebootAlreadyRequested;

    // List of area codes passed CuInit plus all strings retrieved with
    // CuGetInfo.  The list is an editing duplicate of the one from the
    // PBUSER.
    //
    DTLLIST* pListAreaCodes;

    // Stash/restore values for Options page checkboxes.
    //
    BOOL fPreviewUserPw;
    BOOL fPreviewDomain;

    // Set when user changes to "Typical smartcard" security.  This causes the
    // registry based association of EAP per-user information to be discarded,
    // sort of like flushing cached credentials.
    //
    BOOL fDiscardEapUserData;

    // Set true on the first click of the Typical or Advanced radio button on
    // the security page, false before.  The first click is the one
    // artificially generated in LoInit.  The Advanced click handler uses the
    // information to avoid incorrectly adopting the Typical defaults in the
    // case of Advanced settings.
    //
    BOOL fAuthRbInitialized;

    // Used by the networking page
    //
    INetCfg*                        pNetCfg;
    BOOL                            fInitCom;
    BOOL                            fReadOnly;  // Netcfg was initialized in
                                                // read-only mode
    BOOL                            fNonAdmin;  // Run in non-admin mode (406630)                                                
    BOOL                            fNetCfgLock;// NetCfg needs to be unlocked
                                                // when uninited.
    SP_CLASSIMAGELIST_DATA          cild;
    INetConnectionUiUtilities *     pNetConUtilities;
    IUnknown*                       punkUiInfoCallback;

    // Set if COM has been initialized (necessary for calls to netshell).
    //
    BOOL fComInitialized;

    // Keep track of whether we have shown this warning, or if it was disabled by the user
    //
    BOOL fShowDisableFirewallWarning;
}
PEINFO;

INetCfgComponent*
PComponentFromItemIndex (
    HWND hwndLv,
    int  iItem);

INetCfgComponent*
PComponentFromCurSel (
    HWND hwndLv,
    int* piItem);

HRESULT
HrNeRefreshListView (
    PEINFO* pInfo);


void
NeEnableComponent (
    PEINFO*             pInfo,
    INetCfgComponent*   pComponent,
    BOOL                fEnable);

BOOL
NeIsComponentEnabled (
    PEINFO*             pInfo,
    INetCfgComponent*   pComponent);

void
NeShowComponentProperties (
    IN PEINFO*  pInfo);

ULONG
ReleaseObj (
    void* punk);


#endif // _ENTRYPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\diagnostic.c ===
//+--------------------------------------------------------------------------
//
//      File:       diagnostic.c
//
//      Module:     rasdlg.dll
//
//      Synopsis:   functions for the diagnostic tab in Dial-up preferrences 
//                  menu item under Advanced menu in connection folder
//
//      Copyright   (c) 2000-2001 Microsoft Corporation
//
//      Author:     09/12/2000 gangz      created
//
//+--------------------------------------------------------------------------

#include "rasdlgp.h"
#include "pref.h"
#include "vfw.h"
#include "Shellapi.h"

#define WM_EL_REPORT_DONE ( WM_USER + 1 )
#define WM_EL_PROGRESS_CANCEL ( WM_USER + 2 )
#define WM_PB_STEPS ( WM_USER + 3 )
#define WM_EL_REPORT_STATE_UPDATE ( WM_USER + 4 )

#define RASDLG_DIAG_MAX_REPORT_STRING 100

LONG g_lDiagTabLoaded = 0;

typedef struct
_ELINFO
{
    UPINFO * pUpinfo;

    // Error code from Generating report functions
    //
    DWORD dwErr;
    DWORD dwFlagExport; 
    WCHAR szFileOrEmail[MAX_PATH+1];
    
    // Event and thread handle for progress window
    //
    HANDLE   hTProgress;
    HWND     hwndNameOrAddress;

    // Flag for if user pressed cancel button on progress window
    //
    BOOL     fCancelled;    

    // Use Summarized report flag (which is less verbose )
    //
    BOOL fSimpleVerbose; //By default it is FALSE;
    
    // Window handles
    //
    HWND hwndPB;
    HWND hwndDlg;
    HWND hwndElRbView;
    HWND hwndElRbFile;
    HWND hwndElStFile;
    HWND hwndElEbFileName;
    HWND hwndElPbBrowse;
    HWND hwndElRbEmail;
    HWND hwndElEbEmailAddress;
    HWND hwndElCbSimpleReport;
}
ELINFO;

typedef struct
_PBARINFO
{
    ELINFO * pElInfo;
    HWND hwndDlg;
    HWND hwndPbar;
}
PBARINFO;

INT_PTR CALLBACK
PbDlgProc(
    IN HWND hwndDlg,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
DgInit(
    IN HWND hwndPage,
    IN OUT UPARGS* pArgs );

BOOL
DgCommand(
    IN HWND hwnd,
    IN UPINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

BOOL CALLBACK DgDisableAllChildWindows(
  IN    HWND hwnd,    
  IN    LPARAM lParam );

void
DgTerm(
    IN HWND hwndPage);

VOID
ElTerm(
    IN HWND hwndDlg );

DWORD
ElViewLog(
    IN PWSTR  pszFileName );

BOOL
ElCommand(
    IN ELINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

BOOL
ElInit(
    IN HWND hwndDlg,
    IN UPINFO * pUpinfo);

DWORD
ElGenerateReport(
    IN LPVOID pThreadArg );


void
ElEnableRadioControls(
    IN ELINFO * pInfo);

void
ElEnableAllControlsForProgress(
    IN ELINFO * pInfo,
    BOOL fEnable );

BOOL
ElSave(
    IN ELINFO * pInfo);

BOOL
ElAfterSave(
    IN ELINFO * pInfo);

void
ElCleanUpHandles(
    IN ELINFO * pInfo);

INT_PTR CALLBACK
ElDlgProc(
    IN HWND hwndDlg,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

// Help ID Arrays
//
static const DWORD g_adwDgHelp[] =
{
    CID_DG_CB_EnableLog, HID_DG_CB_EnableLog,
    CID_DG_PB_Clear,     HID_DG_PB_Clear,
    CID_DG_PB_Export,    HID_DG_PB_Export,
    0, 0
};

static const DWORD g_adwElHelp[] =
{
    CID_EL_RB_ViewReport,   HID_EL_RB_ViewReport,
    CID_EL_RB_File,         HID_EL_RB_File,
    CID_EL_ST_FileName,     HID_EL_ST_FileName,
    CID_EL_EB_FileName,     HID_EL_EB_FileName,
    CID_EL_PB_Browse,       HID_EL_PB_Browse,
    CID_EL_RB_Email,        HID_EL_RB_Email,
    CID_EL_EB_EmailAddress, HID_EL_EB_EmailAddress,
    CID_EL_CB_SimpleReport, HID_EL_CB_SimpleReport,
    0,0,
};


DWORD
UnLoadDiagnosticDll(
    IN DiagnosticInfo* pInfo )
{
    DWORD dwErr = NO_ERROR;
    TRACE("UnLoadDiagnosticDll");
    
    do
    {
        if ( NULL == pInfo ||
             NULL == pInfo->hDiagDll )
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        EnterCriticalSection( &g_csDiagTab );
        
        InterlockedDecrement( &g_lDiagTabLoaded );

        // Unload the diagnostic library
        //
        if ( 0 == g_lDiagTabLoaded )
        {
            if ( NULL != pInfo->strDiagFuncs.UnInit )
            {
                pInfo->strDiagFuncs.UnInit();
            }
            
        }

        // Load/FreeLibrary will keep the reference counting themselves
        //
        FreeLibrary( pInfo->hDiagDll );

        // Reset all functional pointers
        //
        pInfo->hDiagDll = NULL;
        pInfo->pfnGetDiagFunc= NULL;
        ZeroMemory(&(pInfo->strDiagFuncs),sizeof(pInfo->strDiagFuncs));

        LeaveCriticalSection( &g_csDiagTab );
    }
    while(FALSE);
    
    return dwErr;
}

// Each call to LoadDiagnosticDll() with the same pointer has to be paired by 
// the call to UnLoadDiagnosticDll(), or else, things are screwed up!
//
DWORD
LoadDiagnosticDll(
    IN DiagnosticInfo * pInfo)
{    
    DWORD dwErr = NO_ERROR;
    TRACE("LoadDiagnosticDll");
    
    do
    {
           if ( NULL == pInfo ||
                NULL != pInfo->hDiagDll
              )
           {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
           }

           EnterCriticalSection( &g_csDiagTab );
            
           InterlockedIncrement( &g_lDiagTabLoaded );
           
           if (  !( pInfo->hDiagDll = LoadLibrary( TEXT("RASMONTR.DLL") ) )  ||
                 !( pInfo->pfnGetDiagFunc =
                        (DiagGetDiagnosticFunctions )GetProcAddress(
                            pInfo->hDiagDll, "GetDiagnosticFunctions" ))
               )
           {
                pInfo->pfnGetDiagFunc= NULL;
                ZeroMemory(&(pInfo->strDiagFuncs),sizeof(pInfo->strDiagFuncs));
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
           }
                
           ZeroMemory(&(pInfo->strDiagFuncs), sizeof(pInfo->strDiagFuncs));
           dwErr = pInfo->pfnGetDiagFunc(&pInfo->strDiagFuncs );
           if( NO_ERROR != dwErr ||
               NULL == pInfo->strDiagFuncs.Init ||
               NULL == pInfo->strDiagFuncs.UnInit ||
               NULL == pInfo->strDiagFuncs.GetReport ||
               NULL == pInfo->strDiagFuncs.SetAll ||
               NULL == pInfo->strDiagFuncs.SetAllRas ||
               NULL == pInfo->strDiagFuncs.GetState ||
               NULL == pInfo->strDiagFuncs.ClearAll
             )
           {
                ZeroMemory(&(pInfo->strDiagFuncs),sizeof(pInfo->strDiagFuncs));
                pInfo->pfnGetDiagFunc = NULL;
                dwErr = NO_ERROR == dwErr ? ERROR_CAN_NOT_COMPLETE : dwErr;
           }

           // Call the Init() function only when the first time rasmontr.dll is 
           // loadded
           //
           if( 1 == g_lDiagTabLoaded )
           {
               pInfo->strDiagFuncs.Init();
           }

           LeaveCriticalSection( &g_csDiagTab );
           
    }
    while(FALSE);

    if( NO_ERROR != dwErr &&
        NULL != pInfo->hDiagDll )
    {
        UnLoadDiagnosticDll( pInfo );
    }
    
    return dwErr;
  } // End of Loading Diagnostic functions

void DgApply(
    IN UPINFO* pInfo )
{
    if(NULL == pInfo )
    {
        return;
    }

    if( NULL == pInfo->diagInfo.pfnGetDiagFunc ||
        NULL == pInfo->diagInfo.strDiagFuncs.SetAll )
    {
        return ;
    }
    else
    {
        BOOL fEnable = FALSE;

        fEnable = Button_GetCheck( pInfo->hwndDgCbEnableDiagLog );
        pInfo->diagInfo.strDiagFuncs.SetAll( fEnable );
    }

    return;    
}

//For .Net 530448
BOOL CALLBACK DgDisableAllChildWindows(
  IN    HWND hwnd,      // handle to child window
  IN    LPARAM lParam )
{
    BOOL fEnable = (BOOL)lParam;

    EnableWindow( hwnd, fEnable);

    return TRUE;
}

BOOL
DgInit(
    IN HWND hwndPage,
    IN OUT UPARGS* pArgs )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    UPINFO*  pInfo = NULL;
    HWND hwndDlg;

    TRACE( "DgInit" );

    do
    {
        pInfo = UpContext( hwndPage );
        if (pInfo)
        {
            break;
        }
        
        // Now means this is the show-only-diagnostic case
        hwndDlg = GetParent( hwndPage );

        // Allocate the context information block.  Initialize it enough so that
        // it can be destroyed properly, and associate the context with the
        // window.
        //
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
             TRACE( "Context NOT allocated in DgInit()" );
             ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
             UpExitInit( hwndDlg );
             break;
        }

        ZeroMemory( pInfo, sizeof(UPINFO) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;
        pInfo->hwndFirstPage = hwndPage;
        pInfo->fShowOnlyDiagnostic = TRUE;

        if (!SetProp( hwndDlg, g_contextId, pInfo ))
        {
             TRACE(" Context NOT set" );
             ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
             Free( pInfo );
             pInfo = NULL;
             UpExitInit( hwndDlg );
             break;
        }

        TRACE( "Context set in DgInit()" );
        break;
        
    }while(FALSE);

    if ( pInfo )
    {
        pInfo->hwndDg = hwndPage; 
        pInfo->hwndDgCbEnableDiagLog =
            GetDlgItem( hwndPage, CID_DG_CB_EnableLog );
        ASSERT( pInfo->hwndDgCbEnableDiagLog );
        pInfo->hwndDgPbClear=
            GetDlgItem( hwndPage, CID_DG_PB_Clear );
        ASSERT( pInfo->hwndDgPbClear );
        pInfo->hwndDgPbExport = 
            GetDlgItem( hwndPage, CID_DG_PB_Export );
        ASSERT( pInfo->hwndDgPbExport );

        // load Diagnostic functions
        //
        // Have to zero memory, or else LoadDiagnosticDll may fail
        ZeroMemory( &pInfo->diagInfo, sizeof(pInfo->diagInfo ) );
        if ( NO_ERROR == LoadDiagnosticDll( &pInfo->diagInfo) )
        {
            BOOL fEnable = FALSE;

            fEnable = pInfo->diagInfo.strDiagFuncs.GetState();

            Button_SetCheck( pInfo->hwndDgCbEnableDiagLog,
                             fEnable
                             );
        }
    }

    //Diagnostic is only available to admind/power users
    if( !FIsUserAdminOrPowerUser() )
    {
        EnumChildWindows( hwndPage, 
                          DgDisableAllChildWindows,
                          (LPARAM)FALSE);
        
    }
    
    return TRUE;
}

void
ElEnableRadioControls(
    IN ELINFO * pInfo)
{
    if( NULL == pInfo )
    {
        return;
    }

    if ( Button_GetCheck( pInfo->hwndElRbView ) )
    {
        EnableWindow( pInfo->hwndElStFile, FALSE );
        EnableWindow( pInfo->hwndElEbFileName, FALSE );
        EnableWindow( pInfo->hwndElPbBrowse, FALSE );
        EnableWindow( pInfo->hwndElEbEmailAddress, FALSE );
    }
    else if ( Button_GetCheck( pInfo->hwndElRbFile) )
    {
        EnableWindow( pInfo->hwndElStFile, TRUE );
        EnableWindow( pInfo->hwndElEbFileName, TRUE );
        EnableWindow( pInfo->hwndElPbBrowse, TRUE );
        EnableWindow( pInfo->hwndElEbEmailAddress, FALSE );
    }
    else if ( Button_GetCheck( pInfo->hwndElRbEmail ) )
    {
        EnableWindow( pInfo->hwndElStFile, FALSE );
        EnableWindow( pInfo->hwndElEbFileName, FALSE );
        EnableWindow( pInfo->hwndElPbBrowse, FALSE );
        EnableWindow( pInfo->hwndElEbEmailAddress, TRUE );
    }
}


BOOL
ElInit(
    IN HWND hwndDlg,
    IN UPINFO * pUpinfo)
{
    ELINFO * pInfo = NULL;
    TRACE("ElInit");
    
    pInfo = Malloc(sizeof(ELINFO));
    if( NULL == pInfo )
    {
         ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
         EndDialog( hwndDlg, FALSE );
         return TRUE;
    }

    // Initilization for ElCallBack()
    //
    ZeroMemory( pInfo, sizeof(*pInfo) );
    pInfo->pUpinfo = pUpinfo;
    pInfo->hwndDlg = hwndDlg;
    pInfo->hTProgress = NULL;
    pInfo->fSimpleVerbose = FALSE; // By default use verbose diagnostic report
    pInfo->dwErr = NO_ERROR;
    pInfo->dwFlagExport = 0;
    pInfo->hwndElRbView = 
            GetDlgItem(hwndDlg, CID_EL_RB_ViewReport);
    ASSERT( pInfo->hwndElRbView );
    pInfo->hwndElRbFile =
            GetDlgItem(hwndDlg, CID_EL_RB_File);
    ASSERT( pInfo->hwndElRbFile );
    pInfo->hwndElStFile = 
            GetDlgItem(hwndDlg, CID_EL_ST_FileName );
    ASSERT( pInfo->hwndElStFile );
    pInfo->hwndElEbFileName =
            GetDlgItem(hwndDlg, CID_EL_EB_FileName );
    ASSERT( pInfo->hwndElEbFileName );
    pInfo->hwndElPbBrowse =
            GetDlgItem(hwndDlg, CID_EL_PB_Browse);
    ASSERT(pInfo->hwndElPbBrowse);
    pInfo->hwndElRbEmail = 
            GetDlgItem( hwndDlg, CID_EL_RB_Email );
    ASSERT( pInfo->hwndElRbEmail );
    pInfo->hwndElEbEmailAddress =
            GetDlgItem( hwndDlg, CID_EL_EB_EmailAddress );
    ASSERT( pInfo->hwndElEbEmailAddress );    
    pInfo->hwndElCbSimpleReport =
            GetDlgItem( hwndDlg, CID_EL_CB_SimpleReport );
    ASSERT( pInfo->hwndElCbSimpleReport );

    SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );
              
    // Limit the length of file name or email address to be 256
    //
    Edit_LimitText( pInfo->hwndElEbFileName, PWLEN );  
    Edit_LimitText( pInfo->hwndElEbEmailAddress, PWLEN );  

    // By default, enable the view edit box
    //
    Button_SetCheck( pInfo->hwndElRbView, TRUE );
    pInfo->hwndNameOrAddress = NULL; // For view button
    
    Button_SetCheck( pInfo->hwndElRbEmail, FALSE );
    Button_SetCheck( pInfo->hwndElRbFile, FALSE );

    ElEnableRadioControls( pInfo );

    return TRUE;
}

// Starts hh.exe on the pszFileName htm file
//
DWORD
ElViewLog(
    IN PWSTR  pszFileName )
{
    WCHAR szCmd[ (MAX_PATH * 2) + 50 + 1 ];
    WCHAR szExe[ MAX_PATH];
    STARTUPINFO si;
    HINSTANCE h;
    PROCESS_INFORMATION pi;
    BOOL f;
    DWORD dwErr = NO_ERROR;


    do
    {
        h = FindExecutable(pszFileName, NULL,szExe);
        if( (HINSTANCE)31 == h )
        {
            lstrcpyW(szExe,L"hh.exe ");
        }
        else
        if( (HINSTANCE)32 >= h )
        {
            dwErr = GetLastError(); break;
        }
           
        wsprintfW( szCmd, L"\"%s\" \"%s\"", szExe, pszFileName );

        ZeroMemory( &si, sizeof(si) );
        si.cb = sizeof(si);

        f = CreateProcessW(
                NULL,  // App Name
                szCmd, // Command Line String
                NULL,  // Process SD
                NULL,  // Thread SD
                TRUE,  // Handle inheritance option
                0,     // Creation flags
                NULL,  // new environment block
                NULL,  // Current directory name
                &si,   // Startup info
                &pi ); // Process info

        if (f)
        {
           WaitForInputIdle( pi.hProcess, INFINITE);
           CloseHandle( pi.hThread );
           CloseHandle( pi.hProcess );

        }
        else
        {
            dwErr = GetLastError();
            break;
        }

    }
    while( FALSE );
        
    return dwErr;
}

DWORD ElCallBack(
    IN GET_REPORT_STRING_CB* pInfo)
{
    DWORD dwErr = NO_ERROR;
    ELINFO * pElInfo = NULL;

    do
    {
        if ( NULL == pInfo ||
             NULL == (pElInfo = (ELINFO *) pInfo->pContext)
            )
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }


        if ( pElInfo->hwndDlg )
        {
            SendMessage(   pElInfo->hwndDlg, 
                           WM_EL_REPORT_STATE_UPDATE, 
                           0, 
                           (LPARAM)pInfo );
        }

        if ( pElInfo->fCancelled )
        {
            pElInfo->fCancelled = FALSE;
            dwErr = ERROR_CANCELLED;
            break;
        }
    }
    while(FALSE);

    return dwErr;
}


DWORD
ElGenerateReport(
    IN LPVOID pThreadArg )
{    
    ELINFO * pInfo = (ELINFO *) pThreadArg;
    DWORD dwErr = NO_ERROR;
    TRACE("ElGenerateReport");
    
    do
    {
        if ( NULL == pInfo )
        {
           dwErr = ERROR_INVALID_PARAMETER;
           break;
        }

        if ( NULL == pInfo->hwndPB ||
             NULL == pInfo->szFileOrEmail
           )
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        if( NULL == pInfo->pUpinfo->diagInfo.strDiagFuncs.GetReport )
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

       dwErr = pInfo->pUpinfo->diagInfo.strDiagFuncs.GetReport( 
                            pInfo->dwFlagExport,
                            (PWSTR)pInfo->szFileOrEmail,
                            (DiagGetReportCb)ElCallBack,
                            (PVOID)pInfo);
    }
    while(FALSE);

    if(pInfo)
    {
        pInfo->dwErr = dwErr;

        // Prefast warning
        //
        SendMessage( pInfo->hwndDlg, WM_EL_REPORT_DONE, 0, 0 );
    }

    return dwErr;
}

void
ElEnableAllControlsForProgress(
    IN ELINFO * pInfo,
    BOOL fEnable )
{
    if ( NULL == pInfo )
    {
        return;
    }

    EnableWindow( pInfo->hwndDlg, fEnable);

}

DWORD
ElCleanLog()
{
    WIN32_FIND_DATA  strFileData;
    HANDLE h = NULL;
    DWORD dwErr = NO_ERROR, dwLen;
    TCHAR szFile[ 2*MAX_PATH  + 50 ];
    TCHAR szExt[]=TEXT("ras*.tmp.htm");

    do
   {
        dwLen = GetTempPath( MAX_PATH, szFile );
        if( 0 == dwLen ||
            MAX_PATH < dwLen )
        {
            dwErr = GetLastError();
            break;
        }


        if( NULL == lstrcat(szFile, szExt ) )
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }
        
        h = FindFirstFile(szFile, &strFileData );

        if ( INVALID_HANDLE_VALUE != h )
        {
            lstrcpy(szFile+dwLen,TEXT("\0") );
            
            if( NULL == lstrcat(szFile, strFileData.cFileName) )
            {
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }
                
            DeleteFile(szFile);
            
            while( FindNextFile(h, &strFileData ) )
            {
                lstrcpy(szFile+dwLen,TEXT("\0") );
                
                if( NULL == lstrcat(szFile, strFileData.cFileName) )
                {
                    dwErr = ERROR_CAN_NOT_COMPLETE;
                    break;
                }
                
                DeleteFile(szFile);
            }
        }
        else
        {
            dwErr = GetLastError();
            break;
        }
    }
    while(FALSE);
    
    return dwErr;
}

BOOL
ElSave(
    IN ELINFO * pInfo)
{
        BOOL  fViewChecked = FALSE ,fFileChecked = FALSE;
        BOOL  fEmailChecked = FALSE, fRet = TRUE;
        DWORD dwThreadId;

        TRACE("ElSave()");
        
        do
        {
            if ( NULL == pInfo )
            {
                fRet = FALSE; // Do not set up Timer
                break;
            }
            
            if ( NULL == pInfo->pUpinfo->diagInfo.pfnGetDiagFunc ||
                 NULL == pInfo->pUpinfo->diagInfo.strDiagFuncs.GetReport)
            {
               ErrorDlg( pInfo->hwndDlg, 
                         SID_DG_LoadDiag, 
                         ERROR_UNKNOWN, 
                         NULL );
               fRet = FALSE;
               break;
            }

            fViewChecked  = Button_GetCheck( pInfo->hwndElRbView );
            fFileChecked  = Button_GetCheck( pInfo->hwndElRbFile );
            fEmailChecked = Button_GetCheck( pInfo->hwndElRbEmail );
            
            {
                int tmp;

                tmp = (int)fViewChecked + (int)fFileChecked + 
                      (int)fEmailChecked ;
                
                if( 0 >= tmp ||
                    1 < tmp )
                {
                   fRet = FALSE;
                   break;
                }
            }

            if ( fViewChecked )
            {
                pInfo->dwFlagExport = RAS_DIAG_DISPLAY_FILE |(
                               pInfo->fSimpleVerbose ? 0:
                                    RAS_DIAG_VERBOSE_REPORT);
                                
                pInfo->hwndNameOrAddress = NULL;
            }
            else
            if ( fFileChecked )
            {
                pInfo->dwFlagExport = RAS_DIAG_EXPORT_TO_FILE |(
                               pInfo->fSimpleVerbose ? 0:
                                    RAS_DIAG_VERBOSE_REPORT);
                                
                pInfo->hwndNameOrAddress = pInfo->hwndElEbFileName;
            }
            else
            {
                pInfo->dwFlagExport = RAS_DIAG_EXPORT_TO_EMAIL |(
                               pInfo->fSimpleVerbose ? 0:
                                    RAS_DIAG_VERBOSE_REPORT);
                                
                pInfo->hwndNameOrAddress = pInfo->hwndElEbEmailAddress;
            }

            if ( pInfo->hwndNameOrAddress )
            {
                GetWindowTextW( pInfo->hwndNameOrAddress,
                                pInfo->szFileOrEmail,
                                PWLEN+1);
            
                if ( 0 == lstrlenW( pInfo->szFileOrEmail ) )
                {
                     MsgDlgUtil( pInfo->hwndDlg, 
                                 fFileChecked ? SID_EnterFileName : 
                                                SID_EnterEmailAddress,
                                 NULL, 
                                 g_hinstDll, 
                                 SID_PopupTitle );
                     
                     fRet = FALSE;
                     break;
                }
            }

            // Warning the user that the process can take them a long time
            //
            {
                MSGARGS msg;

                ZeroMemory( &msg, sizeof(msg) );
                msg.dwFlags = MB_ICONWARNING+MB_YESNO ;

                if ( IDNO == MsgDlgUtil( pInfo->hwndDlg, 
                                 SID_DG_ExportWarning,
                                 &msg, 
                                 g_hinstDll, 
                                 SID_PopupTitle )
                    )
               {
                   fRet = FALSE;
                   break;
               }
            }

            pInfo->fCancelled = FALSE; // Reset the cancel flag
            ElEnableAllControlsForProgress( pInfo, FALSE );
            
            pInfo->hwndPB =CreateDialogParam(
                        g_hinstDll,         // handle to module
                        MAKEINTRESOURCE( DID_PB_Progress ),    // dialog box template
                        pInfo->hwndDlg,     // handle to owner window
                        PbDlgProc,          // dialog box procedure
                        (LPARAM )pInfo      // initialization value
                        );

             if ( NULL == pInfo->hwndPB )  
             {
                    ElCleanUpHandles( pInfo );
                    ElEnableAllControlsForProgress( pInfo, TRUE);
                    
                    ErrorDlg( pInfo->hwndDlg, 
                              SID_OPERATION_FAILURE,
                              pInfo->dwErr, 
                              NULL );
                    
                    fRet = FALSE;
                    break;
             }

            ElCleanLog();
            pInfo->hTProgress = CreateThread(
                                NULL, 
                                0, 
                                ElGenerateReport, 
                                (LPVOID )pInfo, 
                                0,
                                (LPDWORD )&dwThreadId );

             if (  NULL == pInfo->hTProgress )
             {
                    ElCleanUpHandles( pInfo );
                    ElEnableAllControlsForProgress( pInfo, TRUE);
                    
                    ErrorDlg( pInfo->hwndDlg, 
                              SID_OPERATION_FAILURE,
                              pInfo->dwErr, 
                              NULL );
                    
                    fRet = FALSE;
                    break;
             }

             CenterWindow( pInfo->hwndPB, pInfo->hwndDlg );
             SendMessage( pInfo->hwndPB, PBM_STEPIT, 0, 0);
        }            
        while(FALSE);
        
        return fRet;
       
}  // End of ElSave()    

void
ElCleanUpHandles(
    IN ELINFO * pInfo)
{
    TRACE("ElCleanUpHandles");
    
    if ( NULL == pInfo )
    {
        return ;
    }

    // Clean up all handles
    //
    if( pInfo->hTProgress)
    {
         CloseHandle( pInfo->hTProgress );
         pInfo->hTProgress = NULL;
    }

    if ( pInfo->hwndPB )
    {
         DestroyWindow( pInfo->hwndPB );
         pInfo->hwndPB = NULL;
     }

    return;
}


BOOL
ElAfterSave(
    IN ELINFO * pInfo)
{    
    BOOL fRet = TRUE;
    BOOL  fViewChecked = FALSE, fFileChecked = FALSE, fEmailChecked = FALSE;
    TRACE("ElAfterSave");

     if ( NULL == pInfo )
     {
         return FALSE;
     }

     ElCleanUpHandles( pInfo );
     ElEnableAllControlsForProgress( pInfo, TRUE);

     fViewChecked  = Button_GetCheck( pInfo->hwndElRbView );
     fFileChecked  = Button_GetCheck( pInfo->hwndElRbFile );
     fEmailChecked = Button_GetCheck( pInfo->hwndElRbEmail );

    do
    {
         if ( NO_ERROR != pInfo->dwErr ||
              fViewChecked && (0 == lstrlenW(pInfo->szFileOrEmail))
             )
        {
             ErrorDlg( pInfo->hwndDlg, 
                       fViewChecked ? SID_DG_GetLogFailure :
                           fFileChecked ? SID_DG_ToFileFail :
                                         SID_DG_ToEmailFail ,
                       pInfo->dwErr, 
                       NULL );

              fRet = FALSE;
              break;
         }

        if ( fViewChecked )
        {
             if( NO_ERROR !=  ElViewLog( pInfo->szFileOrEmail) )
            {
                   fRet = FALSE;
                   ErrorDlg( pInfo->hwndDlg, 
                             SID_DG_LoadLogFailure, 
                             GetLastError(), 
                             NULL );
                  break;
             }
        }
    }
    while(FALSE);

    // Reset Error code
    //
    pInfo->dwErr = NO_ERROR;
    
    return fRet;
}

BOOL
ElCancel(
    IN ELINFO * pInfo )
{
    BOOL fRet = TRUE;
    TRACE("ElCancel");

    do
    {
        if( NULL == pInfo )
        {
            fRet = FALSE;
            break;
        }

        if( NULL != pInfo->hTProgress )
        {
            fRet = FALSE;
            break;
        }

    }
    while(FALSE);
    
    return fRet;
}

BOOL
ElCommand(
    IN ELINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
     BOOL fRet = FALSE;

    TRACE3( "ElCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );
    
    switch (wId)
    {
        case IDOK:
        {
            ElSave( pInfo );

            fRet = TRUE;
        }
        break;

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );

            if( ElCancel( pInfo ) )
            {
                EndDialog( pInfo->hwndDlg, FALSE );
            }

            fRet = TRUE;
        }
        break;

        case CID_EL_RB_ViewReport:
        {
            ElEnableRadioControls( pInfo );

            fRet = TRUE;
        }
        break;

        case CID_EL_RB_File:
        {
            ElEnableRadioControls( pInfo );

            fRet = TRUE;
        }
        break;

        case CID_EL_RB_Email:
        {
            ElEnableRadioControls( pInfo );

            fRet = TRUE;
        }
        break;

        case CID_EL_CB_SimpleReport:
        {
            pInfo->fSimpleVerbose = 
                Button_GetCheck( pInfo->hwndElCbSimpleReport);
        }
        break;
        
        case CID_EL_PB_Browse:
        {
            OPENFILENAMEW    strOpenFile;
            WCHAR szFileName[PWLEN+1] = L"\0";
            WCHAR szTitle[256+1] ;

            if ( !LoadStringW( g_hinstDll, 
                              (UINT )CID_PB_ST_StepsDone, 
                              szTitle, 
                              256 )
                )
            {
                szTitle[0] = L'\0';
            }

            ZeroMemory( &strOpenFile, sizeof(strOpenFile) );
            strOpenFile.lStructSize = sizeof(OPENFILENAME);
            strOpenFile.hwndOwner   = pInfo->hwndDlg;
            strOpenFile.lpstrFilter = L"HTML format Log files(*.htm)\0*.htm\0\0";
            strOpenFile.lpstrDefExt = L"htm";
            strOpenFile.lpstrFile   = szFileName;
            strOpenFile.nMaxFile  = PWLEN+1;
            strOpenFile.lpstrTitle  = szTitle;
            strOpenFile.nMaxFileTitle  = lstrlenW(szTitle);

            
            if ( GetSaveFileNameW(&strOpenFile) )
            {
                SetWindowTextW( pInfo->hwndElEbFileName,
                                szFileName);
            }

            fRet = TRUE;
        }
        break;
        
    }

    return fRet;
}//end of ElCommand()


INT_PTR CALLBACK
ElDlgProc(
    IN HWND hwndDlg,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )
{
    static DWORD dwCount = 0;
    
    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
           return ElInit(hwndDlg, (UPINFO*)lparam);
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwElHelp, hwndDlg, unMsg, wparam, lparam );
            break;
        }

        case WM_EL_REPORT_STATE_UPDATE:
        {
            GET_REPORT_STRING_CB * pReportCB = NULL;
            ELINFO* pInfo = (ELINFO *)GetWindowLongPtr( hwndDlg, DWLP_USER );
            ASSERT (pInfo);
            
            if ( NULL == pInfo )
            {
                break;
            }

            pReportCB = (GET_REPORT_STRING_CB *)lparam;
            if ( NULL == pReportCB )
            {
                break;
            }
            
            SendMessage( pInfo->hwndPB, WM_PB_STEPS, 0 , lparam);
        }
        break;
        
        case WM_EL_REPORT_DONE:
        {
            ELINFO* pInfo = (ELINFO *)GetWindowLongPtr( hwndDlg, DWLP_USER );
            ASSERT (pInfo);
            
            if ( NULL == pInfo )
            {
                break;
            }
            
            if ( ElAfterSave( pInfo ) )
            {
               EndDialog( pInfo->hwndDlg,TRUE );
            }
        }
        break;

        case WM_EL_PROGRESS_CANCEL:
        {
            ELINFO* pInfo = (ELINFO *)GetWindowLongPtr( hwndDlg, DWLP_USER );
            ASSERT (pInfo);
            
            if ( NULL == pInfo )
            {
                break;
            }
            pInfo->fCancelled = TRUE;
        }
        break;

        case WM_COMMAND:
        {
            ELINFO* pInfo = (ELINFO *)GetWindowLongPtr( hwndDlg, DWLP_USER );
            ASSERT (pInfo);

            if ( NULL == pInfo )
            {
                break;
            }

            return ElCommand( pInfo,
                              HIWORD( wparam ), 
                              LOWORD( wparam ), 
                              (HWND )lparam );
            
            break;
        }

        case WM_DESTROY:
        {
            ElTerm( hwndDlg );
            break;
        }
    }
    
    return FALSE;
}

VOID
ElTerm(
    IN HWND hwndDlg )

    // Dialog termination.  Releases the context block.  'HwndDlg' is the
    // handle of a dialog.
    //
{
    ELINFO* pInfo = NULL;

    TRACE( "ElTerm" );

    pInfo = (ELINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );
    if (pInfo)
    {
        Free( pInfo );
        TRACE( "Context freed" );
    }
}//end of ElTerm()

void
DgTerm(
    IN HWND hwndPage)
{
    UPINFO* pInfo = NULL;
   
    TRACE( "DgTerm" );
    
    return;

    pInfo = UpContext( hwndPage );

    if(pInfo)
    {
        UnLoadDiagnosticDll( &pInfo->diagInfo);
        Free( pInfo );
    }

    RemoveProp( GetParent( hwndPage ), g_contextId );
}

void
DgEnableButtons( 
    IN UPINFO * pInfo, 
    IN BOOL fEnable )
{
    EnableWindow( pInfo->hwndDgCbEnableDiagLog, fEnable );
    EnableWindow( pInfo->hwndDgPbClear, fEnable );
    EnableWindow( pInfo->hwndDgPbExport, fEnable );
}
    
BOOL
DgCommand(
    IN HWND hwnd,
    IN UPINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    BOOL fRet = FALSE;
    
    TRACE3( "DgCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    
    switch (wId)
    {
                case CID_DG_CB_EnableLog:
                {
                    if ( NULL == pInfo->diagInfo.pfnGetDiagFunc ||
                         NULL == pInfo->diagInfo.strDiagFuncs.SetAll 
                        )
                    {
                        ErrorDlg( hwnd, SID_DG_LoadDiag, ERROR_UNKNOWN, NULL );
                        break;
                    }
                }
                break;
                
                case CID_DG_PB_Clear:
                {
                    if( NULL == pInfo->diagInfo.pfnGetDiagFunc ||
                        NULL == pInfo->diagInfo.strDiagFuncs.GetState ||
                        NULL == pInfo->diagInfo.strDiagFuncs.ClearAll )
                    {
                        ErrorDlg( hwnd, SID_DG_LoadDiag, ERROR_UNKNOWN, NULL );
                    }
                    else
                    {
                        pInfo->diagInfo.strDiagFuncs.ClearAll();
                    }

#if 0                    
                    Button_SetCheck( pInfo->hwndDgCbEnableDiagLog,
                                     pInfo->diagInfo.strDiagFuncs.GetState()
                                    );
#endif                    
                    fRet = TRUE;
                    break;
               }
            
                case CID_DG_PB_Export:
                {
                    int nStatus;

                    if( NULL == pInfo->diagInfo.pfnGetDiagFunc ||
                        NULL == pInfo->diagInfo.strDiagFuncs.GetReport)
                    {
                        ErrorDlg( hwnd, SID_DG_LoadDiag, ERROR_UNKNOWN, NULL );
                    }
                    else
                    {
                        nStatus =
                            (BOOL )DialogBoxParam(
                                g_hinstDll,
                                MAKEINTRESOURCE( DID_EL_ExportLog ),
                                hwnd,
                                ElDlgProc,
                                (LPARAM )pInfo );

                        if (nStatus == -1)
                        {
                            ErrorDlg( hwnd, SID_DG_LoadDiag, ERROR_UNKNOWN, NULL );
                        }
                    }
    
                   fRet = TRUE;
                   break;
                }   
    }

    return fRet;    
}

INT_PTR CALLBACK
DgDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Diagnostic page of the Entry property sheet.
    // Parameters and return value are as described for standard windows
    // 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return DgInit( hwnd, (UPARGS* )(((PROPSHEETPAGE* )lparam)->lParam) );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwDgHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            UPINFO* pInfo = UpContext (hwnd);
            ASSERT(pInfo);
            
            if ( NULL == pInfo )
            {
                break;
            }

            return DgCommand( hwnd,
                              pInfo, 
                              HIWORD( wparam ), 
                              LOWORD( wparam ), 
                              (HWND )lparam );
        }
        break;

        case WM_NOTIFY:
        {
            
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_APPLY:
                {
                    UPINFO* pInfo = UpContext (hwnd);
                    ASSERT(pInfo);

                    // If not a show-only-diagnostic case,
                    // The diagnostic enabling/disabling should be done
                    // in the by GeDlgProc()
                    //
                    if ( NULL == pInfo ||
                        !pInfo->fShowOnlyDiagnostic )
                    {
                        break;
                    }

                    SetWindowLong(
                        hwnd, 
                        DWLP_MSGRESULT,
                        PSNRET_NOERROR );
                    
                    return TRUE;
                }
             }
            break;
        }

        case WM_DESTROY:
        {
            UPINFO* pInfo = UpContext (hwnd);

            // If not a show-only-diagnostic case,
            // The freeing pInfo memory should be done
            // in the by GeDlgProc()
            //
            if ( NULL == pInfo ||
                !pInfo->fShowOnlyDiagnostic )
            {
                  break;
            }

            DgTerm( hwnd );
            break;
        }
    }
    return FALSE;
}

INT_PTR CALLBACK
PbDlgProc(
    IN HWND hwndDlg,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )
{
    static HCURSOR hCursorDefault = NULL;
    static HCURSOR hCursor = NULL;
   
    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            HWND hwndTmp = NULL;
            WNDPROC  pOldWndProc = NULL;

            hCursor = LoadCursor( NULL, IDC_WAIT );
            if ( hCursor )
            {
                hCursorDefault = (HCURSOR)SetClassLongPtr( hwndDlg, 
                                                      GCLP_HCURSOR, 
                                                      (LONG_PTR)hCursor);
            }

            hwndTmp = GetDlgItem(hwndDlg,CID_PB_ProgressBar);
            if ( hwndTmp )
            {
                SendMessage( hwndTmp,
                             PBM_SETRANGE, 
                             0, MAKELPARAM(0, 100)); 
                
                SendMessage( hwndTmp,
                            PBM_SETSTEP, 
                            (WPARAM)1, 
                            0); 
            }
        }
        break;

        case WM_DESTROY:
        {
            if ( hCursorDefault )
            {
                SetClassLongPtr( hwndDlg, 
                                 GCLP_HCURSOR, 
                                (LONG_PTR) (hCursorDefault) );
            }
        }
        break;
        
        case WM_COMMAND:
        {
            switch ( LOWORD( wparam ) )
            {
                case IDCANCEL:
                {
                    EnableWindow( GetDlgItem(hwndDlg, IDCANCEL),
                                  FALSE);
                    
                    PostMessage( GetParent(hwndDlg),
                                 WM_EL_PROGRESS_CANCEL, 0, 0 );
               
                }
                break;
                
            }
        }
        break;

        case PBM_STEPIT:
        {
            if( GetDlgItem(hwndDlg,CID_PB_ProgressBar) )
            {
                SendMessage( GetDlgItem(hwndDlg,CID_PB_ProgressBar), 
                             PBM_STEPIT, 0 , 0);
            }
        }
        break;

        case WM_PB_STEPS:
        {
           WCHAR szStepText[45], szBuf[20];
           WCHAR szJobText[RASDLG_DIAG_MAX_REPORT_STRING]=L"\0";
           DWORD dwLen = 1;
           GET_REPORT_STRING_CB * pReportCB = NULL;

            pReportCB = (GET_REPORT_STRING_CB *)lparam;
            if ( NULL == pReportCB )
            {
                break;
            }

            if( pReportCB->pwszState )
            {
                dwLen = lstrlenW(pReportCB->pwszState) + 1;
                if( RASDLG_DIAG_MAX_REPORT_STRING <= dwLen )
                {
                    dwLen = RASDLG_DIAG_MAX_REPORT_STRING;
                }

                if( dwLen < 1 )
                {
                    dwLen = 1;
                }
                
                lstrcpynW( szJobText, pReportCB->pwszState, dwLen );
                SetWindowTextW( GetDlgItem(hwndDlg, CID_PB_ST_State), 
                                szJobText );
             }

            // Prefast warning
            //
            if ( LoadStringW( g_hinstDll,
                              (UINT )SID_PB_StepsDone,
                              szBuf,
                              sizeof(szBuf) / sizeof(WCHAR) )

               )
            {
                wsprintfW(szStepText, L"%s: %ld%%", szBuf, 
                         ( pReportCB->dwPercent > 100 ) ? 
                            100 : pReportCB->dwPercent );
                
                SetWindowTextW( GetDlgItem(hwndDlg, CID_PB_ST_StepsDone ),
                                szStepText );
            }

            if( GetDlgItem(hwndDlg,CID_PB_ProgressBar) )
            {
                SendMessage( GetDlgItem(hwndDlg,CID_PB_ProgressBar), 
                             PBM_SETPOS, 
                             (WPARAM)(pReportCB->dwPercent), 
                             0 );
            }
            
        }
        break;
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\edit.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// edit.c
// Remote Access Common Dialog APIs
// List editor, string editor dialog routines
//
// 08/28/95 Steve Cobb


#include "rasdlgp.h"


//-----------------------------------------------------------------------------
// Local datatypes (alphabetically)
//-----------------------------------------------------------------------------

// List editor dialog argument block.
//
typedef struct
_LEARGS
{
    // Caller's arguments to the stub API.
    //
    DTLLIST*     pList;
    BOOL*        pfCheck;
    DWORD        dwMaxItemLen;
    TCHAR*       pszTitle;
    TCHAR*       pszItemLabel;
    TCHAR*       pszListLabel;
    TCHAR*       pszCheckLabel;
    TCHAR*       pszDefaultItem;
    INT          iSelInitial;
    DWORD*       pdwHelp;
    DWORD        dwfFlags;
    PDESTROYNODE pDestroyId;
}
LEARGS;


// List editor dialog context block.
//
typedef struct
_LEINFO
{
    // Caller's arguments to the dialog.
    //
    LEARGS* pArgs;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndStItem;
    HWND hwndStList;
    HWND hwndPbAdd;
    HWND hwndPbReplace;
    HWND hwndPbUp;
    HWND hwndPbDown;
    HWND hwndPbDelete;
    HWND hwndPbOk;
    HWND hwndEb;
    HWND hwndLb;
    HWND hwndCb;

    // Convenient alternatives to (pInfo->pArgs->dwFlags & LEDFLAG_Sorted) and
    // (pInfo->pArgs->dwFlags & LEDFLAG_NoDeleteLastItem).
    //
    BOOL fSorted;
    BOOL fNoDeleteLast;

    // Button bitmaps.
    //
    HBITMAP hbmUp;
    HBITMAP hbmDown;

    // List of empty nodes whose node-IDs should be 'pDestroyId'ed if user
    // presses OK.
    //
    DTLLIST* pListDeletes;
}
LEINFO;


// String Editor dialog arument block.
//
typedef struct
_ZEARGS
{
    /* Caller's aruments to the stub API.
    */
    TCHAR*  pszIn;
    DWORD   dwSidTitle;
    DWORD   dwSidLabel;
    DWORD   cbMax;
    DWORD   dwHelpId;
    TCHAR** ppszOut;
}
ZEARGS;


// String Editor dialog context block.
//
typedef struct
_ZEINFO
{
    // Caller's arguments to the stub API.
    //
    ZEARGS* pArgs;

    // Dialog and control handles.
    //
    HWND hwndDlg;
    HWND hwndEb;
}
ZEINFO;


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

INT_PTR CALLBACK
LeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
LeAdd(
    IN LEINFO* pInfo );

BOOL
LeCommand(
    IN LEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

VOID
LeDelete(
    IN LEINFO* pInfo );

VOID
LeDown(
    IN LEINFO* pInfo );

VOID
LeEnableUpAndDownButtons(
    IN LEINFO* pInfo );

VOID
LeExitNoMemory(
    IN LEINFO* pInfo );

BOOL
LeInit(
    IN HWND hwndDlg,
    IN LEARGS* pArgs );

VOID
LeItemTextFromListSelection(
    IN LEINFO* pInfo );

VOID
LeReplace(
    IN LEINFO* pInfo );

BOOL
LeSaveSettings(
    IN LEINFO* pInfo );

VOID
LeTerm(
    IN HWND hwndDlg );

VOID
LeUp(
    IN LEINFO* pInfo );

INT_PTR CALLBACK
ZeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
ZeCommand(
    IN ZEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

BOOL
ZeInit(
    IN HWND hwndDlg,
    IN ZEARGS* pArgs );

VOID
ZeTerm(
    IN HWND hwndDlg );


//-----------------------------------------------------------------------------
// List Editor dialog entry point
//-----------------------------------------------------------------------------


BOOL
ListEditorDlg(
    IN HWND hwndOwner,
    IN OUT DTLLIST* pList,
    IN OUT BOOL* pfCheck,
    IN DWORD dwMaxItemLen,
    IN TCHAR* pszTitle,
    IN TCHAR* pszItemLabel,
    IN TCHAR* pszListLabel,
    IN TCHAR* pszCheckLabel,
    IN TCHAR* pszDefaultItem,
    IN INT iSelInitial,
    IN DWORD* pdwHelp,
    IN DWORD dwfFlags,
    IN PDESTROYNODE pDestroyId )

    // Pops-up the List Editor dialog.
    //
    // 'HwndOwner' is the owner of the dialog.  'PList' is, on entry, the Psz
    // list to display initially, and on successful exit, the result list.
    // 'PfCheck' is the state of the check box or NULL for the non-checkbox
    // style.  'DwMaxItemLen' is the maximum length of an individual list
    // item.  'PszTitle' is the dialog title.  'PszItemLabel' is the label
    // (and hotkey) associated with the item box.  'PszListLabel' is the label
    // (and hotkey) associated with the list.  'PszCheckLabel' is the label
    // (and hotkey) associated with the checkbox.  'PszDefaultItem' is the
    // default contents of the edit box or for the selected list text.
    // 'ISelInitial' is the item the list to initally select.  'PdwHelp' is
    // the array of CID_LE_* help contexts to use.  'DwfFlags' indicates
    // LEDFLAG_* behavior options.  'PDestroyId' is the routine to use to
    // destroy node IDs when they are deleted or NULL if none.
    //
    // Returns true if user pressed OK and succeeded, false if he pressed
    // Cancel or encountered an error.
    //
{
    INT_PTR nStatus;
    LEARGS args;

    TRACE( "ListEditorDlg" );

    args.pList = pList;
    args.pfCheck = pfCheck;
    args.dwMaxItemLen = dwMaxItemLen;
    args.pszTitle = pszTitle;
    args.pszItemLabel = pszItemLabel;
    args.pszListLabel = pszListLabel;
    args.pszCheckLabel = pszCheckLabel;
    args.pszDefaultItem = pszDefaultItem;
    args.iSelInitial = iSelInitial;
    args.pdwHelp = pdwHelp;
    args.dwfFlags = dwfFlags;
    args.pDestroyId = pDestroyId;

    nStatus =
        DialogBoxParam(
            g_hinstDll,
            (pfCheck)
                ? MAKEINTRESOURCE( DID_LE_ListEditor2 )
                : ((dwfFlags & LEDFLAG_Sorted)
                       ? MAKEINTRESOURCE( DID_LE_ListEditor3 )
                       : MAKEINTRESOURCE( DID_LE_ListEditor )),
            hwndOwner,
            LeDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (nStatus) ? TRUE : FALSE;
}


//----------------------------------------------------------------------------
// List Editor dialog routines
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
LeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the List Editor dialog.  Parameters and return
    // value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "LeDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return LeInit( hwnd, (LEARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            LEINFO* pInfo = (LEINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            ContextHelp( pInfo->pArgs->pdwHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            LEINFO* pInfo = (LEINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            return LeCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            LeTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


VOID
LeAdd(
    IN LEINFO* pInfo )

    // Add button click handler.  'PInfo' is the dialog context.
    //
{
    TCHAR* psz;

    psz = GetText( pInfo->hwndEb );
    if (!psz)
    {
        LeExitNoMemory( pInfo );
        return;
    }

    if (pInfo->pArgs->dwfFlags & LEDFLAG_Unique)
    {
        if (ListBox_IndexFromString( pInfo->hwndLb, psz ) >= 0)
        {
            MSGARGS msgargs;

            ZeroMemory( &msgargs, sizeof(msgargs) );
            msgargs.apszArgs[ 0 ] = psz;
            MsgDlg( pInfo->hwndDlg, SID_NotUnique, &msgargs );
            Edit_SetSel( pInfo->hwndEb, 0, -1 );
            SetFocus( pInfo->hwndEb );
            Free( psz );
            return;
        }
    }

    ListBox_SetCurSel( pInfo->hwndLb,
        ListBox_AddItem( pInfo->hwndLb, psz, 0 ) );
    Free( psz );
    LeEnableUpAndDownButtons( pInfo );
    EnableWindow( pInfo->hwndPbReplace, FALSE );

    if (!pInfo->fNoDeleteLast || ListBox_GetCount( pInfo->hwndLb ) > 1)
    {
        EnableWindow( pInfo->hwndPbDelete, TRUE );
    }

    SetWindowText( pInfo->hwndEb, TEXT("") );
    SetFocus( pInfo->hwndEb );
}


BOOL
LeCommand(
    IN LEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "LeCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_LE_PB_Add:
        {
            LeAdd( pInfo );
            return TRUE;
        }

        case CID_LE_PB_Replace:
        {
            LeReplace( pInfo );
            return TRUE;
        }

        case CID_LE_PB_Up:
        {
            LeUp( pInfo );
            return TRUE;
        }

        case CID_LE_PB_Down:
        {
            LeDown( pInfo );
            return TRUE;
        }

        case CID_LE_PB_Delete:
        {
            LeDelete( pInfo );
            return TRUE;
        }

        case CID_LE_EB_Item:
        {
            if (wNotification == EN_SETFOCUS || wNotification == EN_UPDATE)
            {
                TCHAR* psz = GetText( pInfo->hwndEb );

                if (psz && lstrlen( psz ) > 0 && !IsAllWhite( psz ))
                {
                    EnableWindow( pInfo->hwndPbAdd, TRUE );
                    EnableWindow( pInfo->hwndPbReplace, TRUE );
                    Button_MakeDefault( pInfo->hwndDlg, pInfo->hwndPbAdd );
                }
                else
                {
                    EnableWindow( pInfo->hwndPbAdd, FALSE );
                    EnableWindow( pInfo->hwndPbReplace, FALSE );
                    Button_MakeDefault( pInfo->hwndDlg, pInfo->hwndPbOk );
                }

                Free0( psz );
            }
            return TRUE;
        }

        case CID_LE_LB_List:
        {
            if (wNotification == LBN_SELCHANGE)
            {
                LeEnableUpAndDownButtons( pInfo );
                if (ListBox_GetCurSel( pInfo->hwndLb ) >= 0)
                {
                    LeItemTextFromListSelection( pInfo );
                }
            }
            return TRUE;
        }

        case CID_LE_CB_Promote:
        {
            if (wNotification == BN_SETFOCUS)
            {
                Button_MakeDefault( pInfo->hwndDlg, pInfo->hwndPbOk );
            }
            return TRUE;
        }

        case IDOK:
        {
            EndDialog( pInfo->hwndDlg, LeSaveSettings( pInfo ) );
            return TRUE;
        }

        case IDCANCEL:
        {
            DTLLIST* pList;
            DTLNODE* pNode;

            TRACE( "Cancel pressed" );
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


VOID
LeDelete(
    IN LEINFO* pInfo )

    // Delete button click handler.  'PInfo' is the dialog context.
    //
{
    INT i;
    INT c;

    i = ListBox_GetCurSel( pInfo->hwndLb );
    if (pInfo->pArgs->pDestroyId)
    {
        LONG_PTR lId = ListBox_GetItemData( pInfo->hwndLb, i );
        if (lId != 0)
        {
            DTLNODE* pNode;

            pNode = DtlCreateNode( NULL, lId );
            if (!pNode)
            {
                ErrorDlg( pInfo->hwndDlg, SID_OP_DisplayData,
                    ERROR_NOT_ENOUGH_MEMORY, NULL );
                EndDialog( pInfo->hwndDlg, FALSE );
                return;
            }

            DtlAddNodeFirst( pInfo->pListDeletes, pNode );
        }
    }
    ListBox_DeleteString( pInfo->hwndLb, i );
    c = ListBox_GetCount( pInfo->hwndLb );

    if (c == 0)
    {
        EnableWindow( pInfo->hwndPbReplace, FALSE );
        EnableWindow( pInfo->hwndPbDelete, FALSE );
        SetFocus( pInfo->hwndEb );
        Edit_SetSel( pInfo->hwndEb, 0, -1 );
    }
    else
    {
        if (c == 1 && pInfo->fNoDeleteLast)
        {
            EnableWindow( pInfo->hwndPbDelete, FALSE );
        }

        if (i >= c)
        {
            i = c - 1;
        }

        ListBox_SetCurSel( pInfo->hwndLb, i );
    }

    LeEnableUpAndDownButtons( pInfo );

    if (IsWindowEnabled( GetFocus() ))
    {
        SetFocus( pInfo->hwndEb );
        Edit_SetSel( pInfo->hwndEb, 0, -1 );
    }
}


VOID
LeDown(
    IN LEINFO* pInfo )

    // Down button click handler.  'PInfo' is the dialog context.
    //
{
    TCHAR* psz;
    INT i;
    LONG_PTR lId;

    ASSERT( !pInfo->fSorted );

    i = ListBox_GetCurSel( pInfo->hwndLb );
    psz = ListBox_GetPsz( pInfo->hwndLb, i );
    if (!psz)
    {
        LeExitNoMemory( pInfo );
        return;
    }

    lId = ListBox_GetItemData( pInfo->hwndLb, i );
    ListBox_InsertString( pInfo->hwndLb, i + 2, psz );
    ListBox_SetItemData( pInfo->hwndLb, i + 2, lId );
    Free( psz );
    ListBox_DeleteString( pInfo->hwndLb, i );
    ListBox_SetCurSel( pInfo->hwndLb, i + 1 );

    if (i == ListBox_GetCount( pInfo->hwndLb ))
    {
        Button_MakeDefault( pInfo->hwndDlg, pInfo->hwndPbUp );
        SetFocus( pInfo->hwndPbUp );
    }

    LeEnableUpAndDownButtons( pInfo );
}


VOID
LeEnableUpAndDownButtons(
    IN LEINFO* pInfo )

    // Determine if the Up and Down operations make sense and enable/disable
    // the buttons as appropriate.  'PInfo' is the dialog context.
    //
{
    INT i;
    INT c;

    if (pInfo->fSorted)
    {
        return;
    }

    i = ListBox_GetCurSel( pInfo->hwndLb );
    c = ListBox_GetCount( pInfo->hwndLb );

    EnableWindow( pInfo->hwndPbDown, (i < c - 1 ) );
    EnableWindow( pInfo->hwndPbUp, (i > 0) );
}


VOID
LeExitNoMemory(
    IN LEINFO* pInfo )

    // End the dialog reporting a memory.  'PInfo' is the dialog context.
    //
{
    ErrorDlg( pInfo->hwndDlg,
        SID_OP_DisplayData, ERROR_NOT_ENOUGH_MEMORY, NULL );
    EndDialog( pInfo->hwndDlg, FALSE );
}


BOOL
LeInit(
    IN HWND hwndDlg,
    IN LEARGS* pArgs )

    // Called on WM_INITDIALOG.  'HwndDlg' is the handle of the phonebook
    // dialog window.  'PArgs' is caller's arguments as passed to the stub
    // API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    LEINFO* pInfo;
    DTLNODE* pNode;
    INT c;

    TRACE( "LeInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    // Set up convenient shortcuts.
    //
    if (pArgs->dwfFlags & LEDFLAG_Sorted)
    {
        pInfo->fSorted = TRUE;
    }

    if (pArgs->dwfFlags & LEDFLAG_NoDeleteLastItem)
    {
        pInfo->fNoDeleteLast = TRUE;
    }

    pInfo->hwndStItem = GetDlgItem( hwndDlg, CID_LE_ST_Item );
    ASSERT( pInfo->hwndStItem );
    pInfo->hwndStList = GetDlgItem( hwndDlg, CID_LE_ST_List );
    ASSERT( pInfo->hwndStList );
    pInfo->hwndPbAdd = GetDlgItem( hwndDlg, CID_LE_PB_Add );
    ASSERT( pInfo->hwndPbAdd );
    pInfo->hwndPbReplace = GetDlgItem( hwndDlg, CID_LE_PB_Replace );
    ASSERT( pInfo->hwndPbReplace );
    pInfo->hwndPbDelete = GetDlgItem( hwndDlg, CID_LE_PB_Delete );
    ASSERT( pInfo->hwndPbDelete );
    pInfo->hwndPbOk = GetDlgItem( hwndDlg, IDOK );
    ASSERT( pInfo->hwndPbOk );
    pInfo->hwndEb = GetDlgItem( hwndDlg, CID_LE_EB_Item );
    ASSERT( pInfo->hwndEb );
    pInfo->hwndLb = GetDlgItem( hwndDlg, CID_LE_LB_List );
    ASSERT( pInfo->hwndLb );

    if (pArgs->pDestroyId)
    {
        // Create the empty list of deletions.
        //
        pInfo->pListDeletes = DtlCreateList( 0L );
        if (!pInfo->pListDeletes)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }
    }

    if (!pInfo->fSorted)
    {
        pInfo->hwndPbUp = GetDlgItem( hwndDlg, CID_LE_PB_Up );
        ASSERT( pInfo->hwndPbUp );
        pInfo->hwndPbDown = GetDlgItem( hwndDlg, CID_LE_PB_Down );
        ASSERT( pInfo->hwndPbDown );

        // Draw the graphical up and down arrow indicators.
        //
        pInfo->hbmUp = Button_CreateBitmap(
            pInfo->hwndPbUp, BMS_UpArrowOnRight );
        if (pInfo->hbmUp)
        {
            SendMessage( pInfo->hwndPbUp, BM_SETIMAGE, 0,
                (LPARAM )pInfo->hbmUp );
        }

        pInfo->hbmDown = Button_CreateBitmap(
            pInfo->hwndPbDown, BMS_DownArrowOnRight );
        if (pInfo->hbmDown)
        {
            SendMessage( pInfo->hwndPbDown, BM_SETIMAGE, 0,
                (LPARAM )pInfo->hbmDown );
        }
    }

    if (pArgs->pfCheck)
    {
        pInfo->hwndCb = GetDlgItem( hwndDlg, CID_LE_CB_Promote );
        ASSERT( pInf